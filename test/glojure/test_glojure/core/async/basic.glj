(ns glojure.test-glojure.core.async.basic
  (:use glojure.test)
  (:require [glojure.core.async :as a]))

(defn- chan-with
  [val]
  (let [c (a/chan 1)]
    (a/>! c val)
    c))

(defn- closed-chan
  []
  (let [c (a/chan)]
    (a/close! c)
    c))

(deftest simple-go
  (is (= 42 (a/<! (a/go 42)))))

(deftest offer!
  (is (true? (a/offer! (a/chan 1) 42)) "offer! should return true if accepted")
  (is (false? (a/offer! (closed-chan) 42)) "offer! should return false if channel is closed")
  (is (let [c (a/chan)
            res (a/offer! c 42)]
        (and (nil? res)
             (= 42 (a/<! c))))
      "offer! should return nil if enqueued, but still send"))

(deftest poll!
  (is (= 42 (a/poll! (chan-with 42))) "poll! should return true if accepted")
  (is (nil? (a/poll! (closed-chan))) "poll! should return nil if channel is closed")
  (is (let [c (a/chan 1)
            res (a/poll! c)]
        (and (nil? res)
             (= nil (do (a/>! c 42)
                        (a/close! c)
                        (time.Sleep time.Millisecond) ;; hack to let the other take win the race
                        (a/<! c)))))
      "poll! should return nil if enqueued, but still take"))

(deftest alts!
  (let [c (a/chan 1)
        _ (a/>! c 42)
        [v ch] (a/alts! [c])]
   (is (= 42 v))))
;;    (is (= c ch))))

(run-tests)

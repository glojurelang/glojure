// Code generated by glojure codegen. DO NOT EDIT.

package core

import (
	errors8 "errors"
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	uuid13 "github.com/google/uuid"
	io4 "io"
	math7 "math"
	big9 "math/big"
	rand16 "math/rand"
	http17 "net/http"
	url5 "net/url"
	os6 "os"
	reflect "reflect"
	regexp15 "regexp"
	runtime14 "runtime"
	strconv12 "strconv"
	strings11 "strings"
	time10 "time"
)

func init() {
	runtime.RegisterNSLoader("glojure/core", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "glojure.core"
func LoadNS() {
	sym__PCT_ := lang.NewSymbol("%")
	sym__AMP_ := lang.NewSymbol("&")
	sym__AMP_env := lang.NewSymbol("&env")
	sym__AMP_form := lang.NewSymbol("&form")
	sym__STAR_ := lang.NewSymbol("*")
	sym__STAR__TICK_ := lang.NewSymbol("*'")
	sym__STAR_1 := lang.NewSymbol("*1")
	sym__STAR_2 := lang.NewSymbol("*2")
	sym__STAR_3 := lang.NewSymbol("*3")
	sym__STAR_agent_STAR_ := lang.NewSymbol("*agent*")
	sym__STAR_assert_STAR_ := lang.NewSymbol("*assert*")
	sym__STAR_command_DASH_line_DASH_args_STAR_ := lang.NewSymbol("*command-line-args*")
	sym__STAR_compile_DASH_files_STAR_ := lang.NewSymbol("*compile-files*")
	sym__STAR_compile_DASH_path_STAR_ := lang.NewSymbol("*compile-path*")
	sym__STAR_compiler_DASH_options_STAR_ := lang.NewSymbol("*compiler-options*")
	sym__STAR_data_DASH_readers_STAR_ := lang.NewSymbol("*data-readers*")
	sym__STAR_default_DASH_data_DASH_reader_DASH_fn_STAR_ := lang.NewSymbol("*default-data-reader-fn*")
	sym__STAR_e := lang.NewSymbol("*e")
	sym__STAR_err_STAR_ := lang.NewSymbol("*err*")
	sym__STAR_file_STAR_ := lang.NewSymbol("*file*")
	sym__STAR_flush_DASH_on_DASH_newline_STAR_ := lang.NewSymbol("*flush-on-newline*")
	sym__STAR_in_STAR_ := lang.NewSymbol("*in*")
	sym__STAR_loaded_DASH_libs_STAR_ := lang.NewSymbol("*loaded-libs*")
	sym__STAR_loading_DASH_verbosely_STAR_ := lang.NewSymbol("*loading-verbosely*")
	sym__STAR_ns_STAR_ := lang.NewSymbol("*ns*")
	sym__STAR_out_STAR_ := lang.NewSymbol("*out*")
	sym__STAR_pending_DASH_paths_STAR_ := lang.NewSymbol("*pending-paths*")
	sym__STAR_print_DASH_dup_STAR_ := lang.NewSymbol("*print-dup*")
	sym__STAR_print_DASH_length_STAR_ := lang.NewSymbol("*print-length*")
	sym__STAR_print_DASH_level_STAR_ := lang.NewSymbol("*print-level*")
	sym__STAR_print_DASH_meta_STAR_ := lang.NewSymbol("*print-meta*")
	sym__STAR_print_DASH_namespace_DASH_maps_STAR_ := lang.NewSymbol("*print-namespace-maps*")
	sym__STAR_print_DASH_readably_STAR_ := lang.NewSymbol("*print-readably*")
	sym__STAR_read_DASH_eval_STAR_ := lang.NewSymbol("*read-eval*")
	sym__STAR_repl_STAR_ := lang.NewSymbol("*repl*")
	sym__STAR_unchecked_DASH_math_STAR_ := lang.NewSymbol("*unchecked-math*")
	sym__STAR_verbose_DASH_defrecords_STAR_ := lang.NewSymbol("*verbose-defrecords*")
	sym__STAR_warn_DASH_on_DASH_reflection_STAR_ := lang.NewSymbol("*warn-on-reflection*")
	sym__PLUS_ := lang.NewSymbol("+")
	sym__PLUS__TICK_ := lang.NewSymbol("+'")
	sym__DASH_ := lang.NewSymbol("-")
	sym__DASH__TICK_ := lang.NewSymbol("-'")
	sym__DASH__GT_ := lang.NewSymbol("->")
	sym__DASH__GT__GT_ := lang.NewSymbol("->>")
	sym__DASH_protocols := lang.NewSymbol("-protocols")
	sym__DOT_ := lang.NewSymbol(".")
	sym__DOT__DOT_ := lang.NewSymbol("..")
	sym__DOT_Deref := lang.NewSymbol(".Deref")
	sym__DOT_Equals := lang.NewSymbol(".Equals")
	sym__DOT_HasRoot := lang.NewSymbol(".HasRoot")
	sym__DOT_ResetMeta := lang.NewSymbol(".ResetMeta")
	sym__DOT_UnixNano := lang.NewSymbol(".UnixNano")
	sym__DOT_nth := lang.NewSymbol(".nth")
	sym__DOT_reset := lang.NewSymbol(".reset")
	sym__SLASH_ := lang.NewSymbol("/")
	sym__LT_ := lang.NewSymbol("<")
	sym__LT__EQ_ := lang.NewSymbol("<=")
	sym__EQ_ := lang.NewSymbol("=")
	sym__EQ__EQ_ := lang.NewSymbol("==")
	sym__GT_ := lang.NewSymbol(">")
	sym__GT_0_QMARK_ := lang.NewSymbol(">0?")
	sym__GT_1_QMARK_ := lang.NewSymbol(">1?")
	sym__GT__EQ_ := lang.NewSymbol(">=")
	sym_CollReduce := lang.NewSymbol("CollReduce")
	sym_Datafiable := lang.NewSymbol("Datafiable")
	sym_Double_SLASH_isInfinite := lang.NewSymbol("Double/isInfinite")
	sym_IKVReduce := lang.NewSymbol("IKVReduce")
	sym_IOFactory := lang.NewSymbol("IOFactory")
	sym_InternalReduce := lang.NewSymbol("InternalReduce")
	sym_NaN_QMARK_ := lang.NewSymbol("NaN?")
	sym_Navigable := lang.NewSymbol("Navigable")
	sym_SetMacro := lang.NewSymbol("SetMacro")
	sym_StackTraceElement_DASH__GT_vec := lang.NewSymbol("StackTraceElement->vec")
	sym_Throwable_DASH__GT_map := lang.NewSymbol("Throwable->map")
	sym_a := lang.NewSymbol("a")
	sym_a__0__auto__ := lang.NewSymbol("a__0__auto__")
	sym_abs := lang.NewSymbol("abs")
	sym_accessor := lang.NewSymbol("accessor")
	sym_aclone := lang.NewSymbol("aclone")
	sym_add := lang.NewSymbol("add")
	sym_add_DASH_classpath := lang.NewSymbol("add-classpath")
	sym_add_DASH_doc_DASH_and_DASH_meta := lang.NewSymbol("add-doc-and-meta")
	sym_add_DASH_watch := lang.NewSymbol("add-watch")
	sym_addP := lang.NewSymbol("addP")
	sym_agent := lang.NewSymbol("agent")
	sym_agent_DASH_error := lang.NewSymbol("agent-error")
	sym_agent_DASH_errors := lang.NewSymbol("agent-errors")
	sym_agents := lang.NewSymbol("agents")
	sym_aget := lang.NewSymbol("aget")
	sym_alength := lang.NewSymbol("alength")
	sym_alias := lang.NewSymbol("alias")
	sym_all_DASH_ns := lang.NewSymbol("all-ns")
	sym_alter := lang.NewSymbol("alter")
	sym_alter_DASH_meta_BANG_ := lang.NewSymbol("alter-meta!")
	sym_alter_DASH_var_DASH_root := lang.NewSymbol("alter-var-root")
	sym_amap := lang.NewSymbol("amap")
	sym_ancestors := lang.NewSymbol("ancestors")
	sym_and := lang.NewSymbol("and")
	sym_andNot := lang.NewSymbol("andNot")
	sym_and__0__auto__ := lang.NewSymbol("and__0__auto__")
	sym_any_QMARK_ := lang.NewSymbol("any?")
	sym_apply := lang.NewSymbol("apply")
	sym_areduce := lang.NewSymbol("areduce")
	sym_arg1 := lang.NewSymbol("arg1")
	sym_arg2 := lang.NewSymbol("arg2")
	sym_arg3 := lang.NewSymbol("arg3")
	sym_arglist := lang.NewSymbol("arglist")
	sym_args := lang.NewSymbol("args")
	sym_array := lang.NewSymbol("array")
	sym_array_DASH_map := lang.NewSymbol("array-map")
	sym_array__0__auto__ := lang.NewSymbol("array__0__auto__")
	sym_as_DASH__GT_ := lang.NewSymbol("as->")
	sym_aseq := lang.NewSymbol("aseq")
	sym_aset := lang.NewSymbol("aset")
	sym_aset_DASH_boolean := lang.NewSymbol("aset-boolean")
	sym_aset_DASH_byte := lang.NewSymbol("aset-byte")
	sym_aset_DASH_char := lang.NewSymbol("aset-char")
	sym_aset_DASH_double := lang.NewSymbol("aset-double")
	sym_aset_DASH_float := lang.NewSymbol("aset-float")
	sym_aset_DASH_int := lang.NewSymbol("aset-int")
	sym_aset_DASH_long := lang.NewSymbol("aset-long")
	sym_aset_DASH_short := lang.NewSymbol("aset-short")
	sym_assert := lang.NewSymbol("assert")
	sym_assert_DASH_args := lang.NewSymbol("assert-args")
	sym_assert_DASH_valid_DASH_fdecl := lang.NewSymbol("assert-valid-fdecl")
	sym_assoc := lang.NewSymbol("assoc")
	sym_assoc_BANG_ := lang.NewSymbol("assoc!")
	sym_assoc_DASH_in := lang.NewSymbol("assoc-in")
	sym_associative_QMARK_ := lang.NewSymbol("associative?")
	sym_atom := lang.NewSymbol("atom")
	sym_attr_DASH_map_QMARK_ := lang.NewSymbol("attr-map?")
	sym_atype := lang.NewSymbol("atype")
	sym_await := lang.NewSymbol("await")
	sym_await_DASH_for := lang.NewSymbol("await-for")
	sym_await1 := lang.NewSymbol("await1")
	sym_b := lang.NewSymbol("b")
	sym_bases := lang.NewSymbol("bases")
	sym_begin := lang.NewSymbol("begin")
	sym_bigdec := lang.NewSymbol("bigdec")
	sym_bigint := lang.NewSymbol("bigint")
	sym_biginteger := lang.NewSymbol("biginteger")
	sym_binding := lang.NewSymbol("binding")
	sym_binding_DASH_conveyor_DASH_fn := lang.NewSymbol("binding-conveyor-fn")
	sym_binding_DASH_map := lang.NewSymbol("binding-map")
	sym_bindings := lang.NewSymbol("bindings")
	sym_bindings_STAR_ := lang.NewSymbol("bindings*")
	sym_bit_DASH_and := lang.NewSymbol("bit-and")
	sym_bit_DASH_and_DASH_not := lang.NewSymbol("bit-and-not")
	sym_bit_DASH_clear := lang.NewSymbol("bit-clear")
	sym_bit_DASH_flip := lang.NewSymbol("bit-flip")
	sym_bit_DASH_not := lang.NewSymbol("bit-not")
	sym_bit_DASH_or := lang.NewSymbol("bit-or")
	sym_bit_DASH_set := lang.NewSymbol("bit-set")
	sym_bit_DASH_shift_DASH_left := lang.NewSymbol("bit-shift-left")
	sym_bit_DASH_shift_DASH_right := lang.NewSymbol("bit-shift-right")
	sym_bit_DASH_test := lang.NewSymbol("bit-test")
	sym_bit_DASH_xor := lang.NewSymbol("bit-xor")
	sym_body := lang.NewSymbol("body")
	sym_body_DASH_expr := lang.NewSymbol("body-expr")
	sym_boolean := lang.NewSymbol("boolean")
	sym_boolean_DASH_array := lang.NewSymbol("boolean-array")
	sym_boolean_QMARK_ := lang.NewSymbol("boolean?")
	sym_booleans := lang.NewSymbol("booleans")
	sym_bound_DASH_fn := lang.NewSymbol("bound-fn")
	sym_bound_DASH_fn_STAR_ := lang.NewSymbol("bound-fn*")
	sym_bound_QMARK_ := lang.NewSymbol("bound?")
	sym_bounded_DASH_count := lang.NewSymbol("bounded-count")
	sym_branch_QMARK_ := lang.NewSymbol("branch?")
	sym_butlast := lang.NewSymbol("butlast")
	sym_byte := lang.NewSymbol("byte")
	sym_byte_DASH_array := lang.NewSymbol("byte-array")
	sym_byteCast := lang.NewSymbol("byteCast")
	sym_bytes := lang.NewSymbol("bytes")
	sym_bytes_QMARK_ := lang.NewSymbol("bytes?")
	sym_c := lang.NewSymbol("c")
	sym_c1 := lang.NewSymbol("c1")
	sym_c2 := lang.NewSymbol("c2")
	sym_c3 := lang.NewSymbol("c3")
	sym_c__0__auto__ := lang.NewSymbol("c__0__auto__")
	sym_capacity := lang.NewSymbol("capacity")
	sym_case := lang.NewSymbol("case")
	sym_case_STAR_ := lang.NewSymbol("case*")
	sym_case_DASH_f := lang.NewSymbol("case-f")
	sym_case_DASH_map := lang.NewSymbol("case-map")
	sym_cast := lang.NewSymbol("cast")
	sym_cat := lang.NewSymbol("cat")
	sym_cause := lang.NewSymbol("cause")
	sym_cf := lang.NewSymbol("cf")
	sym_char := lang.NewSymbol("char")
	sym_char_DASH_array := lang.NewSymbol("char-array")
	sym_char_DASH_escape_DASH_string := lang.NewSymbol("char-escape-string")
	sym_char_DASH_name_DASH_string := lang.NewSymbol("char-name-string")
	sym_char_QMARK_ := lang.NewSymbol("char?")
	sym_charCast := lang.NewSymbol("charCast")
	sym_chars := lang.NewSymbol("chars")
	sym_check_DASH_cyclic_DASH_dependency := lang.NewSymbol("check-cyclic-dependency")
	sym_check_DASH_valid_DASH_options := lang.NewSymbol("check-valid-options")
	sym_child := lang.NewSymbol("child")
	sym_children := lang.NewSymbol("children")
	sym_chunk := lang.NewSymbol("chunk")
	sym_chunk_DASH_append := lang.NewSymbol("chunk-append")
	sym_chunk_DASH_buffer := lang.NewSymbol("chunk-buffer")
	sym_chunk_DASH_cons := lang.NewSymbol("chunk-cons")
	sym_chunk_DASH_first := lang.NewSymbol("chunk-first")
	sym_chunk_DASH_next := lang.NewSymbol("chunk-next")
	sym_chunk_DASH_rest := lang.NewSymbol("chunk-rest")
	sym_chunked_DASH_seq_QMARK_ := lang.NewSymbol("chunked-seq?")
	sym_class := lang.NewSymbol("class")
	sym_class_DASH_name := lang.NewSymbol("class-name")
	sym_class_QMARK_ := lang.NewSymbol("class?")
	sym_clauses := lang.NewSymbol("clauses")
	sym_clear_DASH_agent_DASH_errors := lang.NewSymbol("clear-agent-errors")
	sym_close := lang.NewSymbol("close")
	sym_codegen_DOT_test_DOT_case_DASH_switch := lang.NewSymbol("codegen.test.case-switch")
	sym_codegen_DOT_test_DOT_const_DASH_keyword := lang.NewSymbol("codegen.test.const-keyword")
	sym_codegen_DOT_test_DOT_const_DASH_number := lang.NewSymbol("codegen.test.const-number")
	sym_codegen_DOT_test_DOT_const_DASH_string := lang.NewSymbol("codegen.test.const-string")
	sym_codegen_DOT_test_DOT_def_DASH_simple := lang.NewSymbol("codegen.test.def-simple")
	sym_codegen_DOT_test_DOT_fn_DASH_closure := lang.NewSymbol("codegen.test.fn-closure")
	sym_codegen_DOT_test_DOT_fn_DASH_recur := lang.NewSymbol("codegen.test.fn-recur")
	sym_codegen_DOT_test_DOT_goroutine := lang.NewSymbol("codegen.test.goroutine")
	sym_codegen_DOT_test_DOT_loop_DASH_simple := lang.NewSymbol("codegen.test.loop-simple")
	sym_codegen_DOT_test_DOT_maybe_DASH_class := lang.NewSymbol("codegen.test.maybe-class")
	sym_codegen_DOT_test_DOT_multifn := lang.NewSymbol("codegen.test.multifn")
	sym_codegen_DOT_test_DOT_ns_DASH_skip := lang.NewSymbol("codegen.test.ns-skip")
	sym_codegen_DOT_test_DOT_quote_DASH_simple := lang.NewSymbol("codegen.test.quote-simple")
	sym_codegen_DOT_test_DOT_ref := lang.NewSymbol("codegen.test.ref")
	sym_codegen_DOT_test_DOT_set_DASH_bang := lang.NewSymbol("codegen.test.set-bang")
	sym_codegen_DOT_test_DOT_the_DASH_var := lang.NewSymbol("codegen.test.the-var")
	sym_codegen_DOT_test_DOT_throw_DASH_simple := lang.NewSymbol("codegen.test.throw-simple")
	sym_codegen_DOT_test_DOT_try_DASH_advanced := lang.NewSymbol("codegen.test.try-advanced")
	sym_codegen_DOT_test_DOT_try_DASH_basic := lang.NewSymbol("codegen.test.try-basic")
	sym_codegen_DOT_test_DOT_values := lang.NewSymbol("codegen.test.values")
	sym_codegen_DOT_test_DOT_with_DASH_meta := lang.NewSymbol("codegen.test.with-meta")
	sym_coerce := lang.NewSymbol("coerce")
	sym_coll := lang.NewSymbol("coll")
	sym_coll_DASH_reduce := lang.NewSymbol("coll-reduce")
	sym_coll_QMARK_ := lang.NewSymbol("coll?")
	sym_colls := lang.NewSymbol("colls")
	sym_comment := lang.NewSymbol("comment")
	sym_commute := lang.NewSymbol("commute")
	sym_comp := lang.NewSymbol("comp")
	sym_comparator := lang.NewSymbol("comparator")
	sym_compare := lang.NewSymbol("compare")
	sym_compare_DASH_and_DASH_set_BANG_ := lang.NewSymbol("compare-and-set!")
	sym_compile := lang.NewSymbol("compile")
	sym_complement := lang.NewSymbol("complement")
	sym_completing := lang.NewSymbol("completing")
	sym_concat := lang.NewSymbol("concat")
	sym_cond := lang.NewSymbol("cond")
	sym_cond_DASH__GT_ := lang.NewSymbol("cond->")
	sym_cond_DASH__GT__GT_ := lang.NewSymbol("cond->>")
	sym_condp := lang.NewSymbol("condp")
	sym_conj := lang.NewSymbol("conj")
	sym_conj_BANG_ := lang.NewSymbol("conj!")
	sym_cons := lang.NewSymbol("cons")
	sym_constantly := lang.NewSymbol("constantly")
	sym_contains_QMARK_ := lang.NewSymbol("contains?")
	sym_content := lang.NewSymbol("content")
	sym_copy := lang.NewSymbol("copy")
	sym_count := lang.NewSymbol("count")
	sym_counted_QMARK_ := lang.NewSymbol("counted?")
	sym_create := lang.NewSymbol("create")
	sym_create_DASH_ns := lang.NewSymbol("create-ns")
	sym_create_DASH_struct := lang.NewSymbol("create-struct")
	sym_cycle := lang.NewSymbol("cycle")
	sym_d := lang.NewSymbol("d")
	sym_data_DASH_reader_DASH_urls := lang.NewSymbol("data-reader-urls")
	sym_data_DASH_reader_DASH_var := lang.NewSymbol("data-reader-var")
	sym_datafy := lang.NewSymbol("datafy")
	sym_dec := lang.NewSymbol("dec")
	sym_dec_TICK_ := lang.NewSymbol("dec'")
	sym_decimal_QMARK_ := lang.NewSymbol("decimal?")
	sym_decl := lang.NewSymbol("decl")
	sym_declare := lang.NewSymbol("declare")
	sym_decls := lang.NewSymbol("decls")
	sym_dedupe := lang.NewSymbol("dedupe")
	sym_def := lang.NewSymbol("def")
	sym_def_DASH_aset := lang.NewSymbol("def-aset")
	sym_default := lang.NewSymbol("default")
	sym_definline := lang.NewSymbol("definline")
	sym_defmacro := lang.NewSymbol("defmacro")
	sym_defmethod := lang.NewSymbol("defmethod")
	sym_defmulti := lang.NewSymbol("defmulti")
	sym_defn := lang.NewSymbol("defn")
	sym_defn_DASH_ := lang.NewSymbol("defn-")
	sym_defonce := lang.NewSymbol("defonce")
	sym_defprotocol := lang.NewSymbol("defprotocol")
	sym_defstruct := lang.NewSymbol("defstruct")
	sym_delay := lang.NewSymbol("delay")
	sym_delay_QMARK_ := lang.NewSymbol("delay?")
	sym_deliver := lang.NewSymbol("deliver")
	sym_denominator := lang.NewSymbol("denominator")
	sym_deref := lang.NewSymbol("deref")
	sym_deref_DASH_as_DASH_map := lang.NewSymbol("deref-as-map")
	sym_deref_DASH_future := lang.NewSymbol("deref-future")
	sym_derive := lang.NewSymbol("derive")
	sym_descendants := lang.NewSymbol("descendants")
	sym_destructure := lang.NewSymbol("destructure")
	sym_dim := lang.NewSymbol("dim")
	sym_dir := lang.NewSymbol("dir")
	sym_disj := lang.NewSymbol("disj")
	sym_disj_BANG_ := lang.NewSymbol("disj!")
	sym_dispatch_DASH_fn := lang.NewSymbol("dispatch-fn")
	sym_dispatch_DASH_val := lang.NewSymbol("dispatch-val")
	sym_dispatch_DASH_val_DASH_x := lang.NewSymbol("dispatch-val-x")
	sym_dispatch_DASH_val_DASH_y := lang.NewSymbol("dispatch-val-y")
	sym_dissoc := lang.NewSymbol("dissoc")
	sym_dissoc_BANG_ := lang.NewSymbol("dissoc!")
	sym_distinct := lang.NewSymbol("distinct")
	sym_distinct_QMARK_ := lang.NewSymbol("distinct?")
	sym_div := lang.NewSymbol("div")
	sym_divide := lang.NewSymbol("divide")
	sym_do := lang.NewSymbol("do")
	sym_doall := lang.NewSymbol("doall")
	sym_doc_DASH_string_QMARK_ := lang.NewSymbol("doc-string?")
	sym_docstring := lang.NewSymbol("docstring")
	sym_docstring_QMARK_ := lang.NewSymbol("docstring?")
	sym_dorun := lang.NewSymbol("dorun")
	sym_doseq := lang.NewSymbol("doseq")
	sym_dosync := lang.NewSymbol("dosync")
	sym_dotimes := lang.NewSymbol("dotimes")
	sym_doto := lang.NewSymbol("doto")
	sym_double := lang.NewSymbol("double")
	sym_double_DASH_array := lang.NewSymbol("double-array")
	sym_double_QMARK_ := lang.NewSymbol("double?")
	sym_doubles := lang.NewSymbol("doubles")
	sym_drop := lang.NewSymbol("drop")
	sym_drop_DASH_last := lang.NewSymbol("drop-last")
	sym_drop_DASH_while := lang.NewSymbol("drop-while")
	sym_e := lang.NewSymbol("e")
	sym_elide_DASH_top_DASH_frames := lang.NewSymbol("elide-top-frames")
	sym_else := lang.NewSymbol("else")
	sym_emit_DASH_extend_DASH_protocol := lang.NewSymbol("emit-extend-protocol")
	sym_emit_DASH_extend_DASH_type := lang.NewSymbol("emit-extend-type")
	sym_emit_DASH_hinted_DASH_impl := lang.NewSymbol("emit-hinted-impl")
	sym_empty := lang.NewSymbol("empty")
	sym_empty_QMARK_ := lang.NewSymbol("empty?")
	sym_end := lang.NewSymbol("end")
	sym_end_DASH_key := lang.NewSymbol("end-key")
	sym_end_DASH_test := lang.NewSymbol("end-test")
	sym_ensure := lang.NewSymbol("ensure")
	sym_ensure_DASH_reduced := lang.NewSymbol("ensure-reduced")
	sym_enumeration_DASH_seq := lang.NewSymbol("enumeration-seq")
	sym_env := lang.NewSymbol("env")
	sym_eof_DASH_error_QMARK_ := lang.NewSymbol("eof-error?")
	sym_eof_DASH_value := lang.NewSymbol("eof-value")
	sym_error_DASH_handler := lang.NewSymbol("error-handler")
	sym_error_DASH_mode := lang.NewSymbol("error-mode")
	sym_eval := lang.NewSymbol("eval")
	sym_even_QMARK_ := lang.NewSymbol("even?")
	sym_every_DASH_pred := lang.NewSymbol("every-pred")
	sym_every_QMARK_ := lang.NewSymbol("every?")
	sym_ex := lang.NewSymbol("ex")
	sym_ex_DASH_cause := lang.NewSymbol("ex-cause")
	sym_ex_DASH_data := lang.NewSymbol("ex-data")
	sym_ex_DASH_info := lang.NewSymbol("ex-info")
	sym_ex_DASH_message := lang.NewSymbol("ex-message")
	sym_executor := lang.NewSymbol("executor")
	sym_expr := lang.NewSymbol("expr")
	sym_expr_DASH_sym := lang.NewSymbol("expr-sym")
	sym_exprs := lang.NewSymbol("exprs")
	sym_exprs_STAR_ := lang.NewSymbol("exprs*")
	sym_extend := lang.NewSymbol("extend")
	sym_extend_DASH_protocol := lang.NewSymbol("extend-protocol")
	sym_extend_DASH_type := lang.NewSymbol("extend-type")
	sym_f := lang.NewSymbol("f")
	sym_false_QMARK_ := lang.NewSymbol("false?")
	sym_fdecl := lang.NewSymbol("fdecl")
	sym_ffirst := lang.NewSymbol("ffirst")
	sym_file_DASH_seq := lang.NewSymbol("file-seq")
	sym_filter := lang.NewSymbol("filter")
	sym_filter_DASH_key := lang.NewSymbol("filter-key")
	sym_filters := lang.NewSymbol("filters")
	sym_filterv := lang.NewSymbol("filterv")
	sym_finally := lang.NewSymbol("finally")
	sym_find := lang.NewSymbol("find")
	sym_find_DASH_keyword := lang.NewSymbol("find-keyword")
	sym_find_DASH_ns := lang.NewSymbol("find-ns")
	sym_find_DASH_var := lang.NewSymbol("find-var")
	sym_first := lang.NewSymbol("first")
	sym_fits_DASH_table_QMARK_ := lang.NewSymbol("fits-table?")
	sym_flags_DASH_ignored_DASH_for_DASH_now := lang.NewSymbol("flags-ignored-for-now")
	sym_flatten := lang.NewSymbol("flatten")
	sym_float := lang.NewSymbol("float")
	sym_float_DASH_array := lang.NewSymbol("float-array")
	sym_float_QMARK_ := lang.NewSymbol("float?")
	sym_floatCast := lang.NewSymbol("floatCast")
	sym_floats := lang.NewSymbol("floats")
	sym_flush := lang.NewSymbol("flush")
	sym_fmt := lang.NewSymbol("fmt")
	sym_fn := lang.NewSymbol("fn")
	sym_fn_STAR_ := lang.NewSymbol("fn*")
	sym_fn_DASH_tail := lang.NewSymbol("fn-tail")
	sym_fn_QMARK_ := lang.NewSymbol("fn?")
	sym_fnext := lang.NewSymbol("fnext")
	sym_fnil := lang.NewSymbol("fnil")
	sym_fns := lang.NewSymbol("fns")
	sym_fnspecs := lang.NewSymbol("fnspecs")
	sym_fnspecs_STAR_ := lang.NewSymbol("fnspecs*")
	sym_fntail := lang.NewSymbol("fntail")
	sym_for := lang.NewSymbol("for")
	sym_force := lang.NewSymbol("force")
	sym_form := lang.NewSymbol("form")
	sym_format := lang.NewSymbol("format")
	sym_forms := lang.NewSymbol("forms")
	sym_frequencies := lang.NewSymbol("frequencies")
	sym_from := lang.NewSymbol("from")
	sym_fs := lang.NewSymbol("fs")
	sym_fs__1__auto__ := lang.NewSymbol("fs__1__auto__")
	sym_fun := lang.NewSymbol("fun")
	sym_func := lang.NewSymbol("func")
	sym_fut := lang.NewSymbol("fut")
	sym_future := lang.NewSymbol("future")
	sym_future_DASH_call := lang.NewSymbol("future-call")
	sym_future_DASH_cancel := lang.NewSymbol("future-cancel")
	sym_future_DASH_cancelled_QMARK_ := lang.NewSymbol("future-cancelled?")
	sym_future_DASH_done_QMARK_ := lang.NewSymbol("future-done?")
	sym_future_QMARK_ := lang.NewSymbol("future?")
	sym_g := lang.NewSymbol("g")
	sym_gen_DASH_class := lang.NewSymbol("gen-class")
	sym_gensym := lang.NewSymbol("gensym")
	sym_get := lang.NewSymbol("get")
	sym_get_DASH_in := lang.NewSymbol("get-in")
	sym_get_DASH_method := lang.NewSymbol("get-method")
	sym_get_DASH_thread_DASH_bindings := lang.NewSymbol("get-thread-bindings")
	sym_get_DASH_validator := lang.NewSymbol("get-validator")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT__STAR_MultiFn := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.*MultiFn")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT__STAR_Var := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.*Var")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Abs := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Abs")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_FindNamespace := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.FindNamespace")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_ISeq := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.ISeq")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Identical := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Identical")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Import := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Import")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_IsReduced := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.IsReduced")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_LockingTransaction := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.LockingTransaction")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewIllegalArgumentError := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewIllegalArgumentError")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewLazySeq := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewLazySeq")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewMultiFn := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewMultiFn")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewPersistentArrayMapAsIfByAssoc := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewPersistentArrayMapAsIfByAssoc")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PopThreadBindings := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PopThreadBindings")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PushThreadBindings := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PushThreadBindings")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Volatile := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Volatile")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT := lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")
	sym_global_DASH_hierarchy := lang.NewSymbol("global-hierarchy")
	sym_glojure_DOT_core := lang.NewSymbol("glojure.core")
	sym_glojure_DOT_core_DOT_protocols := lang.NewSymbol("glojure.core.protocols")
	sym_glojure_DOT_core_SLASH__STAR_in_STAR_ := lang.NewSymbol("glojure.core/*in*")
	sym_glojure_DOT_core_SLASH__STAR_loaded_DASH_libs_STAR_ := lang.NewSymbol("glojure.core/*loaded-libs*")
	sym_glojure_DOT_core_SLASH__STAR_math_DASH_context_STAR_ := lang.NewSymbol("glojure.core/*math-context*")
	sym_glojure_DOT_core_SLASH__STAR_out_STAR_ := lang.NewSymbol("glojure.core/*out*")
	sym_glojure_DOT_core_SLASH__DASH_ := lang.NewSymbol("glojure.core/-")
	sym_glojure_DOT_core_SLASH__DASH__GT_ := lang.NewSymbol("glojure.core/->")
	sym_glojure_DOT_core_SLASH__DASH__GT__GT_ := lang.NewSymbol("glojure.core/->>")
	sym_glojure_DOT_core_SLASH__DASH_protocols := lang.NewSymbol("glojure.core/-protocols")
	sym_glojure_DOT_core_SLASH__SLASH_ := lang.NewSymbol("glojure.core//")
	sym_glojure_DOT_core_SLASH__LT_ := lang.NewSymbol("glojure.core/<")
	sym_glojure_DOT_core_SLASH__EQ_ := lang.NewSymbol("glojure.core/=")
	sym_glojure_DOT_core_SLASH_Aclone := lang.NewSymbol("glojure.core/Aclone")
	sym_glojure_DOT_core_SLASH_AddMethod := lang.NewSymbol("glojure.core/AddMethod")
	sym_glojure_DOT_core_SLASH_Aget := lang.NewSymbol("glojure.core/Aget")
	sym_glojure_DOT_core_SLASH_Alength := lang.NewSymbol("glojure.core/Alength")
	sym_glojure_DOT_core_SLASH_Array := lang.NewSymbol("glojure.core/Array")
	sym_glojure_DOT_core_SLASH_Aset := lang.NewSymbol("glojure.core/Aset")
	sym_glojure_DOT_core_SLASH_AssertionError := lang.NewSymbol("glojure.core/AssertionError")
	sym_glojure_DOT_core_SLASH_BooleanCast := lang.NewSymbol("glojure.core/BooleanCast")
	sym_glojure_DOT_core_SLASH_Count := lang.NewSymbol("glojure.core/Count")
	sym_glojure_DOT_core_SLASH_DoubleCast := lang.NewSymbol("glojure.core/DoubleCast")
	sym_glojure_DOT_core_SLASH_Get := lang.NewSymbol("glojure.core/Get")
	sym_glojure_DOT_core_SLASH_IllegalStateException := lang.NewSymbol("glojure.core/IllegalStateException")
	sym_glojure_DOT_core_SLASH_LongCast := lang.NewSymbol("glojure.core/LongCast")
	sym_glojure_DOT_core_SLASH_Nth := lang.NewSymbol("glojure.core/Nth")
	sym_glojure_DOT_core_SLASH_Object_array := lang.NewSymbol("glojure.core/Object_array")
	sym_glojure_DOT_core_SLASH_RunInTransaction := lang.NewSymbol("glojure.core/RunInTransaction")
	sym_glojure_DOT_core_SLASH_UncheckedByteCast := lang.NewSymbol("glojure.core/UncheckedByteCast")
	sym_glojure_DOT_core_SLASH_UncheckedCharCast := lang.NewSymbol("glojure.core/UncheckedCharCast")
	sym_glojure_DOT_core_SLASH_UncheckedDoubleCast := lang.NewSymbol("glojure.core/UncheckedDoubleCast")
	sym_glojure_DOT_core_SLASH_UncheckedFloatCast := lang.NewSymbol("glojure.core/UncheckedFloatCast")
	sym_glojure_DOT_core_SLASH_UncheckedIntCast := lang.NewSymbol("glojure.core/UncheckedIntCast")
	sym_glojure_DOT_core_SLASH_UncheckedLongCast := lang.NewSymbol("glojure.core/UncheckedLongCast")
	sym_glojure_DOT_core_SLASH_UncheckedShortCast := lang.NewSymbol("glojure.core/UncheckedShortCast")
	sym_glojure_DOT_core_SLASH_aclone := lang.NewSymbol("glojure.core/aclone")
	sym_glojure_DOT_core_SLASH_aget := lang.NewSymbol("glojure.core/aget")
	sym_glojure_DOT_core_SLASH_alength := lang.NewSymbol("glojure.core/alength")
	sym_glojure_DOT_core_SLASH_alter_DASH_meta_BANG_ := lang.NewSymbol("glojure.core/alter-meta!")
	sym_glojure_DOT_core_SLASH_and := lang.NewSymbol("glojure.core/and")
	sym_glojure_DOT_core_SLASH_apply := lang.NewSymbol("glojure.core/apply")
	sym_glojure_DOT_core_SLASH_args := lang.NewSymbol("glojure.core/args")
	sym_glojure_DOT_core_SLASH_aset := lang.NewSymbol("glojure.core/aset")
	sym_glojure_DOT_core_SLASH_assert := lang.NewSymbol("glojure.core/assert")
	sym_glojure_DOT_core_SLASH_assert_DASH_args := lang.NewSymbol("glojure.core/assert-args")
	sym_glojure_DOT_core_SLASH_assoc := lang.NewSymbol("glojure.core/assoc")
	sym_glojure_DOT_core_SLASH_assoc_DASH_in := lang.NewSymbol("glojure.core/assoc-in")
	sym_glojure_DOT_core_SLASH_atom := lang.NewSymbol("glojure.core/atom")
	sym_glojure_DOT_core_SLASH_binding := lang.NewSymbol("glojure.core/binding")
	sym_glojure_DOT_core_SLASH_booleanArray := lang.NewSymbol("glojure.core/booleanArray")
	sym_glojure_DOT_core_SLASH_booleans := lang.NewSymbol("glojure.core/booleans")
	sym_glojure_DOT_core_SLASH_bound_DASH_fn_STAR_ := lang.NewSymbol("glojure.core/bound-fn*")
	sym_glojure_DOT_core_SLASH_byteArray := lang.NewSymbol("glojure.core/byteArray")
	sym_glojure_DOT_core_SLASH_bytes := lang.NewSymbol("glojure.core/bytes")
	sym_glojure_DOT_core_SLASH_c := lang.NewSymbol("glojure.core/c")
	sym_glojure_DOT_core_SLASH_charArray := lang.NewSymbol("glojure.core/charArray")
	sym_glojure_DOT_core_SLASH_chars := lang.NewSymbol("glojure.core/chars")
	sym_glojure_DOT_core_SLASH_chunk := lang.NewSymbol("glojure.core/chunk")
	sym_glojure_DOT_core_SLASH_chunk_DASH_append := lang.NewSymbol("glojure.core/chunk-append")
	sym_glojure_DOT_core_SLASH_chunk_DASH_buffer := lang.NewSymbol("glojure.core/chunk-buffer")
	sym_glojure_DOT_core_SLASH_chunk_DASH_cons := lang.NewSymbol("glojure.core/chunk-cons")
	sym_glojure_DOT_core_SLASH_chunk_DASH_first := lang.NewSymbol("glojure.core/chunk-first")
	sym_glojure_DOT_core_SLASH_chunk_DASH_rest := lang.NewSymbol("glojure.core/chunk-rest")
	sym_glojure_DOT_core_SLASH_chunked_DASH_seq_QMARK_ := lang.NewSymbol("glojure.core/chunked-seq?")
	sym_glojure_DOT_core_SLASH_class := lang.NewSymbol("glojure.core/class")
	sym_glojure_DOT_core_SLASH_commute := lang.NewSymbol("glojure.core/commute")
	sym_glojure_DOT_core_SLASH_compare := lang.NewSymbol("glojure.core/compare")
	sym_glojure_DOT_core_SLASH_concat := lang.NewSymbol("glojure.core/concat")
	sym_glojure_DOT_core_SLASH_cond := lang.NewSymbol("glojure.core/cond")
	sym_glojure_DOT_core_SLASH_condp := lang.NewSymbol("glojure.core/condp")
	sym_glojure_DOT_core_SLASH_conj := lang.NewSymbol("glojure.core/conj")
	sym_glojure_DOT_core_SLASH_cons := lang.NewSymbol("glojure.core/cons")
	sym_glojure_DOT_core_SLASH_count := lang.NewSymbol("glojure.core/count")
	sym_glojure_DOT_core_SLASH_create_DASH_struct := lang.NewSymbol("glojure.core/create-struct")
	sym_glojure_DOT_core_SLASH_decP := lang.NewSymbol("glojure.core/decP")
	sym_glojure_DOT_core_SLASH_defmulti := lang.NewSymbol("glojure.core/defmulti")
	sym_glojure_DOT_core_SLASH_defn := lang.NewSymbol("glojure.core/defn")
	sym_glojure_DOT_core_SLASH_deref := lang.NewSymbol("glojure.core/deref")
	sym_glojure_DOT_core_SLASH_dosync := lang.NewSymbol("glojure.core/dosync")
	sym_glojure_DOT_core_SLASH_double := lang.NewSymbol("glojure.core/double")
	sym_glojure_DOT_core_SLASH_doubleArray := lang.NewSymbol("glojure.core/doubleArray")
	sym_glojure_DOT_core_SLASH_doubles := lang.NewSymbol("glojure.core/doubles")
	sym_glojure_DOT_core_SLASH_equiv := lang.NewSymbol("glojure.core/equiv")
	sym_glojure_DOT_core_SLASH_extend := lang.NewSymbol("glojure.core/extend")
	sym_glojure_DOT_core_SLASH_extend_DASH_type := lang.NewSymbol("glojure.core/extend-type")
	sym_glojure_DOT_core_SLASH_first := lang.NewSymbol("glojure.core/first")
	sym_glojure_DOT_core_SLASH_floatArray := lang.NewSymbol("glojure.core/floatArray")
	sym_glojure_DOT_core_SLASH_floats := lang.NewSymbol("glojure.core/floats")
	sym_glojure_DOT_core_SLASH_fn := lang.NewSymbol("glojure.core/fn")
	sym_glojure_DOT_core_SLASH_future_DASH_call := lang.NewSymbol("glojure.core/future-call")
	sym_glojure_DOT_core_SLASH_gen_DASH_class := lang.NewSymbol("glojure.core/gen-class")
	sym_glojure_DOT_core_SLASH_get := lang.NewSymbol("glojure.core/get")
	sym_glojure_DOT_core_SLASH_gt := lang.NewSymbol("glojure.core/gt")
	sym_glojure_DOT_core_SLASH_gte := lang.NewSymbol("glojure.core/gte")
	sym_glojure_DOT_core_SLASH_hash_DASH_map := lang.NewSymbol("glojure.core/hash-map")
	sym_glojure_DOT_core_SLASH_i := lang.NewSymbol("glojure.core/i")
	sym_glojure_DOT_core_SLASH_identical := lang.NewSymbol("glojure.core/identical")
	sym_glojure_DOT_core_SLASH_if_DASH_let := lang.NewSymbol("glojure.core/if-let")
	sym_glojure_DOT_core_SLASH_if_DASH_not := lang.NewSymbol("glojure.core/if-not")
	sym_glojure_DOT_core_SLASH_if_DASH_some := lang.NewSymbol("glojure.core/if-some")
	sym_glojure_DOT_core_SLASH_in_DASH_ns := lang.NewSymbol("glojure.core/in-ns")
	sym_glojure_DOT_core_SLASH_incP := lang.NewSymbol("glojure.core/incP")
	sym_glojure_DOT_core_SLASH_instance_QMARK_ := lang.NewSymbol("glojure.core/instance?")
	sym_glojure_DOT_core_SLASH_int := lang.NewSymbol("glojure.core/int")
	sym_glojure_DOT_core_SLASH_intArray := lang.NewSymbol("glojure.core/intArray")
	sym_glojure_DOT_core_SLASH_ints := lang.NewSymbol("glojure.core/ints")
	sym_glojure_DOT_core_SLASH_isNeg := lang.NewSymbol("glojure.core/isNeg")
	sym_glojure_DOT_core_SLASH_isPos := lang.NewSymbol("glojure.core/isPos")
	sym_glojure_DOT_core_SLASH_isZero := lang.NewSymbol("glojure.core/isZero")
	sym_glojure_DOT_core_SLASH_keyword := lang.NewSymbol("glojure.core/keyword")
	sym_glojure_DOT_core_SLASH_lazy_DASH_seq := lang.NewSymbol("glojure.core/lazy-seq")
	sym_glojure_DOT_core_SLASH_let := lang.NewSymbol("glojure.core/let")
	sym_glojure_DOT_core_SLASH_long := lang.NewSymbol("glojure.core/long")
	sym_glojure_DOT_core_SLASH_longArray := lang.NewSymbol("glojure.core/longArray")
	sym_glojure_DOT_core_SLASH_longs := lang.NewSymbol("glojure.core/longs")
	sym_glojure_DOT_core_SLASH_loop := lang.NewSymbol("glojure.core/loop")
	sym_glojure_DOT_core_SLASH_lt := lang.NewSymbol("glojure.core/lt")
	sym_glojure_DOT_core_SLASH_lte := lang.NewSymbol("glojure.core/lte")
	sym_glojure_DOT_core_SLASH_merge := lang.NewSymbol("glojure.core/merge")
	sym_glojure_DOT_core_SLASH_meta := lang.NewSymbol("glojure.core/meta")
	sym_glojure_DOT_core_SLASH_next := lang.NewSymbol("glojure.core/next")
	sym_glojure_DOT_core_SLASH_nf := lang.NewSymbol("glojure.core/nf")
	sym_glojure_DOT_core_SLASH_nil_QMARK_ := lang.NewSymbol("glojure.core/nil?")
	sym_glojure_DOT_core_SLASH_not := lang.NewSymbol("glojure.core/not")
	sym_glojure_DOT_core_SLASH_nth := lang.NewSymbol("glojure.core/nth")
	sym_glojure_DOT_core_SLASH_num := lang.NewSymbol("glojure.core/num")
	sym_glojure_DOT_core_SLASH_or := lang.NewSymbol("glojure.core/or")
	sym_glojure_DOT_core_SLASH_pcalls := lang.NewSymbol("glojure.core/pcalls")
	sym_glojure_DOT_core_SLASH_pop_DASH_thread_DASH_bindings := lang.NewSymbol("glojure.core/pop-thread-bindings")
	sym_glojure_DOT_core_SLASH_pr_DASH_str := lang.NewSymbol("glojure.core/pr-str")
	sym_glojure_DOT_core_SLASH_prn := lang.NewSymbol("glojure.core/prn")
	sym_glojure_DOT_core_SLASH_push_DASH_thread_DASH_bindings := lang.NewSymbol("glojure.core/push-thread-bindings")
	sym_glojure_DOT_core_SLASH_quotient := lang.NewSymbol("glojure.core/quotient")
	sym_glojure_DOT_core_SLASH_refer := lang.NewSymbol("glojure.core/refer")
	sym_glojure_DOT_core_SLASH_remainder := lang.NewSymbol("glojure.core/remainder")
	sym_glojure_DOT_core_SLASH_rest := lang.NewSymbol("glojure.core/rest")
	sym_glojure_DOT_core_SLASH_seq := lang.NewSymbol("glojure.core/seq")
	sym_glojure_DOT_core_SLASH_seq_QMARK_ := lang.NewSymbol("glojure.core/seq?")
	sym_glojure_DOT_core_SLASH_shiftLeft := lang.NewSymbol("glojure.core/shiftLeft")
	sym_glojure_DOT_core_SLASH_shiftRight := lang.NewSymbol("glojure.core/shiftRight")
	sym_glojure_DOT_core_SLASH_shortArray := lang.NewSymbol("glojure.core/shortArray")
	sym_glojure_DOT_core_SLASH_shorts := lang.NewSymbol("glojure.core/shorts")
	sym_glojure_DOT_core_SLASH_str := lang.NewSymbol("glojure.core/str")
	sym_glojure_DOT_core_SLASH_swap_BANG_ := lang.NewSymbol("glojure.core/swap!")
	sym_glojure_DOT_core_SLASH_sync := lang.NewSymbol("glojure.core/sync")
	sym_glojure_DOT_core_SLASH_to_DASH_array := lang.NewSymbol("glojure.core/to-array")
	sym_glojure_DOT_core_SLASH_unchecked_DASH_inc := lang.NewSymbol("glojure.core/unchecked-inc")
	sym_glojure_DOT_core_SLASH_unchecked_DASH_inc_DASH_int := lang.NewSymbol("glojure.core/unchecked-inc-int")
	sym_glojure_DOT_core_SLASH_unchecked_add := lang.NewSymbol("glojure.core/unchecked_add")
	sym_glojure_DOT_core_SLASH_unchecked_dec := lang.NewSymbol("glojure.core/unchecked_dec")
	sym_glojure_DOT_core_SLASH_unchecked_inc := lang.NewSymbol("glojure.core/unchecked_inc")
	sym_glojure_DOT_core_SLASH_unchecked_int_add := lang.NewSymbol("glojure.core/unchecked_int_add")
	sym_glojure_DOT_core_SLASH_unchecked_int_dec := lang.NewSymbol("glojure.core/unchecked_int_dec")
	sym_glojure_DOT_core_SLASH_unchecked_int_divide := lang.NewSymbol("glojure.core/unchecked_int_divide")
	sym_glojure_DOT_core_SLASH_unchecked_int_inc := lang.NewSymbol("glojure.core/unchecked_int_inc")
	sym_glojure_DOT_core_SLASH_unchecked_int_multiply := lang.NewSymbol("glojure.core/unchecked_int_multiply")
	sym_glojure_DOT_core_SLASH_unchecked_int_negate := lang.NewSymbol("glojure.core/unchecked_int_negate")
	sym_glojure_DOT_core_SLASH_unchecked_int_remainder := lang.NewSymbol("glojure.core/unchecked_int_remainder")
	sym_glojure_DOT_core_SLASH_unchecked_int_subtract := lang.NewSymbol("glojure.core/unchecked_int_subtract")
	sym_glojure_DOT_core_SLASH_unchecked_minus := lang.NewSymbol("glojure.core/unchecked_minus")
	sym_glojure_DOT_core_SLASH_unchecked_multiply := lang.NewSymbol("glojure.core/unchecked_multiply")
	sym_glojure_DOT_core_SLASH_unquote := lang.NewSymbol("glojure.core/unquote")
	sym_glojure_DOT_core_SLASH_unquote_DASH_splicing := lang.NewSymbol("glojure.core/unquote-splicing")
	sym_glojure_DOT_core_SLASH_unsignedShiftRight := lang.NewSymbol("glojure.core/unsignedShiftRight")
	sym_glojure_DOT_core_SLASH_when := lang.NewSymbol("glojure.core/when")
	sym_glojure_DOT_core_SLASH_when_DASH_first := lang.NewSymbol("glojure.core/when-first")
	sym_glojure_DOT_core_SLASH_when_DASH_let := lang.NewSymbol("glojure.core/when-let")
	sym_glojure_DOT_core_SLASH_when_DASH_not := lang.NewSymbol("glojure.core/when-not")
	sym_glojure_DOT_core_SLASH_with_DASH_bindings_STAR_ := lang.NewSymbol("glojure.core/with-bindings*")
	sym_glojure_DOT_core_SLASH_with_DASH_loading_DASH_context := lang.NewSymbol("glojure.core/with-loading-context")
	sym_glojure_DOT_core_SLASH_with_DASH_open := lang.NewSymbol("glojure.core/with-open")
	sym_glojure_DOT_core_SLASH_with_DASH_redefs_DASH_fn := lang.NewSymbol("glojure.core/with-redefs-fn")
	sym_glojure_DOT_go_DOT_io := lang.NewSymbol("glojure.go.io")
	sym_glojure_DOT_lang_DOT_Delay := lang.NewSymbol("glojure.lang.Delay")
	sym_glojure_DOT_lang_DOT_IChunk := lang.NewSymbol("glojure.lang.IChunk")
	sym_glojure_DOT_lang_DOT_LineNumberingPushbackReader_DOT_ := lang.NewSymbol("glojure.lang.LineNumberingPushbackReader.")
	sym_glojure_DOT_lang_DOT_LockingTransaction_SLASH_isRunning := lang.NewSymbol("glojure.lang.LockingTransaction/isRunning")
	sym_glojure_DOT_lang_DOT_PersistentArrayMap_SLASH_EMPTY := lang.NewSymbol("glojure.lang.PersistentArrayMap/EMPTY")
	sym_glojure_DOT_lang_DOT_Util := lang.NewSymbol("glojure.lang.Util")
	sym_glojure_DOT_string := lang.NewSymbol("glojure.string")
	sym_group_DASH_by := lang.NewSymbol("group-by")
	sym_h := lang.NewSymbol("h")
	sym_halt_DASH_when := lang.NewSymbol("halt-when")
	sym_handler_DASH_fn := lang.NewSymbol("handler-fn")
	sym_hash := lang.NewSymbol("hash")
	sym_hash_DASH_basis := lang.NewSymbol("hash-basis")
	sym_hash_DASH_map := lang.NewSymbol("hash-map")
	sym_hash_DASH_ordered_DASH_coll := lang.NewSymbol("hash-ordered-coll")
	sym_hash_DASH_set := lang.NewSymbol("hash-set")
	sym_hash_DASH_unordered_DASH_coll := lang.NewSymbol("hash-unordered-coll")
	sym_hashes := lang.NewSymbol("hashes")
	sym_ident_QMARK_ := lang.NewSymbol("ident?")
	sym_identical_QMARK_ := lang.NewSymbol("identical?")
	sym_identity := lang.NewSymbol("identity")
	sym_idx := lang.NewSymbol("idx")
	sym_idx2 := lang.NewSymbol("idx2")
	sym_idx2__3__auto__ := lang.NewSymbol("idx2__3__auto__")
	sym_idx__1__auto__ := lang.NewSymbol("idx__1__auto__")
	sym_idxs := lang.NewSymbol("idxs")
	sym_idxv := lang.NewSymbol("idxv")
	sym_idxv__4__auto__ := lang.NewSymbol("idxv__4__auto__")
	sym_if := lang.NewSymbol("if")
	sym_if_DASH_let := lang.NewSymbol("if-let")
	sym_if_DASH_not := lang.NewSymbol("if-not")
	sym_if_DASH_some := lang.NewSymbol("if-some")
	sym_ifn_QMARK_ := lang.NewSymbol("ifn?")
	sym_import := lang.NewSymbol("import")
	sym_import_DASH_symbols_DASH_or_DASH_lists := lang.NewSymbol("import-symbols-or-lists")
	sym_inc := lang.NewSymbol("inc")
	sym_inc_TICK_ := lang.NewSymbol("inc'")
	sym_index := lang.NewSymbol("index")
	sym_indexed_QMARK_ := lang.NewSymbol("indexed?")
	sym_infinite_QMARK_ := lang.NewSymbol("infinite?")
	sym_init := lang.NewSymbol("init")
	sym_init_DASH_val_DASH_or_DASH_seq := lang.NewSymbol("init-val-or-seq")
	sym_initk := lang.NewSymbol("initk")
	sym_inits := lang.NewSymbol("inits")
	sym_inst := lang.NewSymbol("inst")
	sym_inst_DASH_ms := lang.NewSymbol("inst-ms")
	sym_inst_QMARK_ := lang.NewSymbol("inst?")
	sym_instance_QMARK_ := lang.NewSymbol("instance?")
	sym_int := lang.NewSymbol("int")
	sym_int_DASH_array := lang.NewSymbol("int-array")
	sym_int_QMARK_ := lang.NewSymbol("int?")
	sym_intCast := lang.NewSymbol("intCast")
	sym_integer_QMARK_ := lang.NewSymbol("integer?")
	sym_interface_DASH_or_DASH_naive_DASH_reduce := lang.NewSymbol("interface-or-naive-reduce")
	sym_interleave := lang.NewSymbol("interleave")
	sym_intern := lang.NewSymbol("intern")
	sym_internal_DASH_reduce := lang.NewSymbol("internal-reduce")
	sym_interpose := lang.NewSymbol("interpose")
	sym_into := lang.NewSymbol("into")
	sym_into_DASH_array := lang.NewSymbol("into-array")
	sym_into1 := lang.NewSymbol("into1")
	sym_ints := lang.NewSymbol("ints")
	sym_io_BANG_ := lang.NewSymbol("io!")
	sym_iref := lang.NewSymbol("iref")
	sym_isa_QMARK_ := lang.NewSymbol("isa?")
	sym_items := lang.NewSymbol("items")
	sym_iter := lang.NewSymbol("iter")
	sym_iter__0__auto__ := lang.NewSymbol("iter__0__auto__")
	sym_iterate := lang.NewSymbol("iterate")
	sym_iteration := lang.NewSymbol("iteration")
	sym_iterator_DASH_seq := lang.NewSymbol("iterator-seq")
	sym_iterys__0__auto__ := lang.NewSymbol("iterys__0__auto__")
	sym_java_DOT_io_DOT_StringReader_DOT_ := lang.NewSymbol("java.io.StringReader.")
	sym_java_DOT_math_DOT_MathContext_DOT_ := lang.NewSymbol("java.math.MathContext.")
	sym_java_DOT_math_DOT_RoundingMode := lang.NewSymbol("java.math.RoundingMode")
	sym_juxt := lang.NewSymbol("juxt")
	sym_k := lang.NewSymbol("k")
	sym_keep := lang.NewSymbol("keep")
	sym_keep_DASH_indexed := lang.NewSymbol("keep-indexed")
	sym_key := lang.NewSymbol("key")
	sym_keyfn := lang.NewSymbol("keyfn")
	sym_keys := lang.NewSymbol("keys")
	sym_keyseq := lang.NewSymbol("keyseq")
	sym_keyvals := lang.NewSymbol("keyvals")
	sym_keyword := lang.NewSymbol("keyword")
	sym_keyword_QMARK_ := lang.NewSymbol("keyword?")
	sym_kf := lang.NewSymbol("kf")
	sym_ks := lang.NewSymbol("ks")
	sym_kv_DASH_reduce := lang.NewSymbol("kv-reduce")
	sym_kvs := lang.NewSymbol("kvs")
	sym_l__1__auto__ := lang.NewSymbol("l__1__auto__")
	sym_last := lang.NewSymbol("last")
	sym_lazy_DASH_cat := lang.NewSymbol("lazy-cat")
	sym_lazy_DASH_seq := lang.NewSymbol("lazy-seq")
	sym_len := lang.NewSymbol("len")
	sym_let := lang.NewSymbol("let")
	sym_let_STAR_ := lang.NewSymbol("let*")
	sym_letfn := lang.NewSymbol("letfn")
	sym_letfn_STAR_ := lang.NewSymbol("letfn*")
	sym_lib := lang.NewSymbol("lib")
	sym_libspec_QMARK_ := lang.NewSymbol("libspec?")
	sym_lift_DASH_ns := lang.NewSymbol("lift-ns")
	sym_line_DASH_seq := lang.NewSymbol("line-seq")
	sym_list := lang.NewSymbol("list")
	sym_list_STAR_ := lang.NewSymbol("list*")
	sym_list_QMARK_ := lang.NewSymbol("list?")
	sym_load := lang.NewSymbol("load")
	sym_load_DASH_all := lang.NewSymbol("load-all")
	sym_load_DASH_data_DASH_reader_DASH_file := lang.NewSymbol("load-data-reader-file")
	sym_load_DASH_data_DASH_readers := lang.NewSymbol("load-data-readers")
	sym_load_DASH_file := lang.NewSymbol("load-file")
	sym_load_DASH_lib := lang.NewSymbol("load-lib")
	sym_load_DASH_libs := lang.NewSymbol("load-libs")
	sym_load_DASH_one := lang.NewSymbol("load-one")
	sym_load_DASH_reader := lang.NewSymbol("load-reader")
	sym_load_DASH_string := lang.NewSymbol("load-string")
	sym_loaded_DASH_libs := lang.NewSymbol("loaded-libs")
	sym_loading__0__auto__ := lang.NewSymbol("loading__0__auto__")
	sym_lockee__0__auto__ := lang.NewSymbol("lockee__0__auto__")
	sym_locking := lang.NewSymbol("locking")
	sym_locklocal__1__auto__ := lang.NewSymbol("locklocal__1__auto__")
	sym_long := lang.NewSymbol("long")
	sym_long_DASH_array := lang.NewSymbol("long-array")
	sym_longs := lang.NewSymbol("longs")
	sym_loop := lang.NewSymbol("loop")
	sym_loop_STAR_ := lang.NewSymbol("loop*")
	sym_m := lang.NewSymbol("m")
	sym_macroexpand := lang.NewSymbol("macroexpand")
	sym_macroexpand_DASH_1 := lang.NewSymbol("macroexpand-1")
	sym_make_DASH_array := lang.NewSymbol("make-array")
	sym_make_DASH_hierarchy := lang.NewSymbol("make-hierarchy")
	sym_make_DASH_input_DASH_stream := lang.NewSymbol("make-input-stream")
	sym_make_DASH_output_DASH_stream := lang.NewSymbol("make-output-stream")
	sym_make_DASH_reader := lang.NewSymbol("make-reader")
	sym_make_DASH_writer := lang.NewSymbol("make-writer")
	sym_map := lang.NewSymbol("map")
	sym_map_DASH_entry_QMARK_ := lang.NewSymbol("map-entry?")
	sym_map_DASH_indexed := lang.NewSymbol("map-indexed")
	sym_map_QMARK_ := lang.NewSymbol("map?")
	sym_mapcat := lang.NewSymbol("mapcat")
	sym_mappings := lang.NewSymbol("mappings")
	sym_maps := lang.NewSymbol("maps")
	sym_mapv := lang.NewSymbol("mapv")
	sym_mask := lang.NewSymbol("mask")
	sym_math_DOT_IsNaN := lang.NewSymbol("math.IsNaN")
	sym_max := lang.NewSymbol("max")
	sym_max_DASH_key := lang.NewSymbol("max-key")
	sym_max_DASH_mask_DASH_bits := lang.NewSymbol("max-mask-bits")
	sym_max_DASH_switch_DASH_table_DASH_size := lang.NewSymbol("max-switch-table-size")
	sym_maybe_DASH_destructured := lang.NewSymbol("maybe-destructured")
	sym_maybe_DASH_min_DASH_hash := lang.NewSymbol("maybe-min-hash")
	sym_maybe_DASH_p := lang.NewSymbol("maybe-p")
	sym_memfn := lang.NewSymbol("memfn")
	sym_memoize := lang.NewSymbol("memoize")
	sym_merge := lang.NewSymbol("merge")
	sym_merge_DASH_hash_DASH_collisions := lang.NewSymbol("merge-hash-collisions")
	sym_merge_DASH_with := lang.NewSymbol("merge-with")
	sym_message := lang.NewSymbol("message")
	sym_meta := lang.NewSymbol("meta")
	sym_metadata_DASH_map := lang.NewSymbol("metadata-map")
	sym_method := lang.NewSymbol("method")
	sym_methods := lang.NewSymbol("methods")
	sym_min := lang.NewSymbol("min")
	sym_min_DASH_key := lang.NewSymbol("min-key")
	sym_minus := lang.NewSymbol("minus")
	sym_minusP := lang.NewSymbol("minusP")
	sym_mix_DASH_collection_DASH_hash := lang.NewSymbol("mix-collection-hash")
	sym_mk_DASH_bound_DASH_fn := lang.NewSymbol("mk-bound-fn")
	sym_mod := lang.NewSymbol("mod")
	sym_mode_DASH_keyword := lang.NewSymbol("mode-keyword")
	sym_monitor_DASH_enter := lang.NewSymbol("monitor-enter")
	sym_monitor_DASH_exit := lang.NewSymbol("monitor-exit")
	sym_more := lang.NewSymbol("more")
	sym_more_DASH_dims := lang.NewSymbol("more-dims")
	sym_msg := lang.NewSymbol("msg")
	sym_multifn := lang.NewSymbol("multifn")
	sym_multiply := lang.NewSymbol("multiply")
	sym_multiplyP := lang.NewSymbol("multiplyP")
	sym_n := lang.NewSymbol("n")
	sym_n_DASH_or_DASH_q := lang.NewSymbol("n-or-q")
	sym_n__0__auto__ := lang.NewSymbol("n__0__auto__")
	sym_name := lang.NewSymbol("name")
	sym_name_DASH_vals_DASH_vec := lang.NewSymbol("name-vals-vec")
	sym_name_QMARK_ := lang.NewSymbol("name?")
	sym_named := lang.NewSymbol("named")
	sym_names := lang.NewSymbol("names")
	sym_namespace := lang.NewSymbol("namespace")
	sym_namespace_DASH_sym := lang.NewSymbol("namespace-sym")
	sym_nary_DASH_inline := lang.NewSymbol("nary-inline")
	sym_nat_DASH_int_QMARK_ := lang.NewSymbol("nat-int?")
	sym_nav := lang.NewSymbol("nav")
	sym_need_DASH_ns := lang.NewSymbol("need-ns")
	sym_neg_DASH_int_QMARK_ := lang.NewSymbol("neg-int?")
	sym_neg_QMARK_ := lang.NewSymbol("neg?")
	sym_new := lang.NewSymbol("new")
	sym_new_DASH_state := lang.NewSymbol("new-state")
	sym_newline := lang.NewSymbol("newline")
	sym_newval := lang.NewSymbol("newval")
	sym_next := lang.NewSymbol("next")
	sym_nfirst := lang.NewSymbol("nfirst")
	sym_nil_QMARK_ := lang.NewSymbol("nil?")
	sym_nnext := lang.NewSymbol("nnext")
	sym_normalize_DASH_slurp_DASH_opts := lang.NewSymbol("normalize-slurp-opts")
	sym_not := lang.NewSymbol("not")
	sym_not_DASH_any_QMARK_ := lang.NewSymbol("not-any?")
	sym_not_DASH_empty := lang.NewSymbol("not-empty")
	sym_not_DASH_every_QMARK_ := lang.NewSymbol("not-every?")
	sym_not_DASH_found := lang.NewSymbol("not-found")
	sym_not_EQ_ := lang.NewSymbol("not=")
	sym_ns := lang.NewSymbol("ns")
	sym_ns_DASH_aliases := lang.NewSymbol("ns-aliases")
	sym_ns_DASH_imports := lang.NewSymbol("ns-imports")
	sym_ns_DASH_interns := lang.NewSymbol("ns-interns")
	sym_ns_DASH_map := lang.NewSymbol("ns-map")
	sym_ns_DASH_name := lang.NewSymbol("ns-name")
	sym_ns_DASH_publics := lang.NewSymbol("ns-publics")
	sym_ns_DASH_refers := lang.NewSymbol("ns-refers")
	sym_ns_DASH_resolve := lang.NewSymbol("ns-resolve")
	sym_ns_DASH_sym := lang.NewSymbol("ns-sym")
	sym_ns_DASH_unalias := lang.NewSymbol("ns-unalias")
	sym_ns_DASH_unmap := lang.NewSymbol("ns-unmap")
	sym_nth := lang.NewSymbol("nth")
	sym_nthnext := lang.NewSymbol("nthnext")
	sym_nthrest := lang.NewSymbol("nthrest")
	sym_num := lang.NewSymbol("num")
	sym_number_QMARK_ := lang.NewSymbol("number?")
	sym_numerator := lang.NewSymbol("numerator")
	sym_o := lang.NewSymbol("o")
	sym_obj := lang.NewSymbol("obj")
	sym_object_DASH_array := lang.NewSymbol("object-array")
	sym_odd_QMARK_ := lang.NewSymbol("odd?")
	sym_oldform := lang.NewSymbol("oldform")
	sym_oldval := lang.NewSymbol("oldval")
	sym_op := lang.NewSymbol("op")
	sym_options := lang.NewSymbol("options")
	sym_opts := lang.NewSymbol("opts")
	sym_opts_PLUS_sigs := lang.NewSymbol("opts+sigs")
	sym_or := lang.NewSymbol("or")
	sym_or__0__auto__ := lang.NewSymbol("or__0__auto__")
	sym_p := lang.NewSymbol("p")
	sym_p1 := lang.NewSymbol("p1")
	sym_p2 := lang.NewSymbol("p2")
	sym_p3 := lang.NewSymbol("p3")
	sym_p__0__auto__ := lang.NewSymbol("p__0__auto__")
	sym_pad := lang.NewSymbol("pad")
	sym_pairs := lang.NewSymbol("pairs")
	sym_params := lang.NewSymbol("params")
	sym_params_STAR_ := lang.NewSymbol("params*")
	sym_parent := lang.NewSymbol("parent")
	sym_parents := lang.NewSymbol("parents")
	sym_parse_DASH_boolean := lang.NewSymbol("parse-boolean")
	sym_parse_DASH_double := lang.NewSymbol("parse-double")
	sym_parse_DASH_impls := lang.NewSymbol("parse-impls")
	sym_parse_DASH_long := lang.NewSymbol("parse-long")
	sym_parse_DASH_uuid := lang.NewSymbol("parse-uuid")
	sym_parsing_DASH_err := lang.NewSymbol("parsing-err")
	sym_partial := lang.NewSymbol("partial")
	sym_partition := lang.NewSymbol("partition")
	sym_partition_DASH_all := lang.NewSymbol("partition-all")
	sym_partition_DASH_by := lang.NewSymbol("partition-by")
	sym_partitionv := lang.NewSymbol("partitionv")
	sym_partitionv_DASH_all := lang.NewSymbol("partitionv-all")
	sym_path := lang.NewSymbol("path")
	sym_paths := lang.NewSymbol("paths")
	sym_pcalls := lang.NewSymbol("pcalls")
	sym_peek := lang.NewSymbol("peek")
	sym_persistent_BANG_ := lang.NewSymbol("persistent!")
	sym_pmap := lang.NewSymbol("pmap")
	sym_pop := lang.NewSymbol("pop")
	sym_pop_BANG_ := lang.NewSymbol("pop!")
	sym_pop_DASH_thread_DASH_bindings := lang.NewSymbol("pop-thread-bindings")
	sym_pos_DASH_int_QMARK_ := lang.NewSymbol("pos-int?")
	sym_pos_QMARK_ := lang.NewSymbol("pos?")
	sym_pr := lang.NewSymbol("pr")
	sym_pr_DASH_on := lang.NewSymbol("pr-on")
	sym_pr_DASH_str := lang.NewSymbol("pr-str")
	sym_precision := lang.NewSymbol("precision")
	sym_pred := lang.NewSymbol("pred")
	sym_prefer_DASH_method := lang.NewSymbol("prefer-method")
	sym_prefers := lang.NewSymbol("prefers")
	sym_prefix := lang.NewSymbol("prefix")
	sym_prefix_DASH_string := lang.NewSymbol("prefix-string")
	sym_prep_DASH_hashes := lang.NewSymbol("prep-hashes")
	sym_prep_DASH_ints := lang.NewSymbol("prep-ints")
	sym_prependss := lang.NewSymbol("prependss")
	sym_prepost_DASH_map_QMARK_ := lang.NewSymbol("prepost-map?")
	sym_preserving_DASH_reduced := lang.NewSymbol("preserving-reduced")
	sym_print := lang.NewSymbol("print")
	sym_print_DASH_args := lang.NewSymbol("print-args")
	sym_print_DASH_ctor := lang.NewSymbol("print-ctor")
	sym_print_DASH_dup := lang.NewSymbol("print-dup")
	sym_print_DASH_initialized := lang.NewSymbol("print-initialized")
	sym_print_DASH_map := lang.NewSymbol("print-map")
	sym_print_DASH_meta := lang.NewSymbol("print-meta")
	sym_print_DASH_method := lang.NewSymbol("print-method")
	sym_print_DASH_object := lang.NewSymbol("print-object")
	sym_print_DASH_one := lang.NewSymbol("print-one")
	sym_print_DASH_prefix_DASH_map := lang.NewSymbol("print-prefix-map")
	sym_print_DASH_sequential := lang.NewSymbol("print-sequential")
	sym_print_DASH_simple := lang.NewSymbol("print-simple")
	sym_print_DASH_str := lang.NewSymbol("print-str")
	sym_print_DASH_tagged_DASH_object := lang.NewSymbol("print-tagged-object")
	sym_print_DASH_throwable := lang.NewSymbol("print-throwable")
	sym_printf := lang.NewSymbol("printf")
	sym_println := lang.NewSymbol("println")
	sym_println_DASH_str := lang.NewSymbol("println-str")
	sym_prn := lang.NewSymbol("prn")
	sym_prn_DASH_str := lang.NewSymbol("prn-str")
	sym_prob := lang.NewSymbol("prob")
	sym_proc := lang.NewSymbol("proc")
	sym_promise := lang.NewSymbol("promise")
	sym_proto_PLUS_mmaps := lang.NewSymbol("proto+mmaps")
	sym_protocol_QMARK_ := lang.NewSymbol("protocol?")
	sym_ps := lang.NewSymbol("ps")
	sym_push_DASH_thread_DASH_bindings := lang.NewSymbol("push-thread-bindings")
	sym_pvalues := lang.NewSymbol("pvalues")
	sym_qualified_DASH_ident_QMARK_ := lang.NewSymbol("qualified-ident?")
	sym_qualified_DASH_keyword_QMARK_ := lang.NewSymbol("qualified-keyword?")
	sym_qualified_DASH_symbol_QMARK_ := lang.NewSymbol("qualified-symbol?")
	sym_quot := lang.NewSymbol("quot")
	sym_quote := lang.NewSymbol("quote")
	sym_r := lang.NewSymbol("r")
	sym_rand := lang.NewSymbol("rand")
	sym_rand_DASH_int := lang.NewSymbol("rand-int")
	sym_rand_DASH_nth := lang.NewSymbol("rand-nth")
	sym_random_DASH_sample := lang.NewSymbol("random-sample")
	sym_random_DASH_uuid := lang.NewSymbol("random-uuid")
	sym_range := lang.NewSymbol("range")
	sym_ratio_QMARK_ := lang.NewSymbol("ratio?")
	sym_rational_QMARK_ := lang.NewSymbol("rational?")
	sym_rationalize := lang.NewSymbol("rationalize")
	sym_rdr := lang.NewSymbol("rdr")
	sym_re := lang.NewSymbol("re")
	sym_re_DASH_find := lang.NewSymbol("re-find")
	sym_re_DASH_groups := lang.NewSymbol("re-groups")
	sym_re_DASH_matcher := lang.NewSymbol("re-matcher")
	sym_re_DASH_matches := lang.NewSymbol("re-matches")
	sym_re_DASH_pattern := lang.NewSymbol("re-pattern")
	sym_re_DASH_seq := lang.NewSymbol("re-seq")
	sym_read := lang.NewSymbol("read")
	sym_read_PLUS_string := lang.NewSymbol("read+string")
	sym_read_DASH_line := lang.NewSymbol("read-line")
	sym_read_DASH_string := lang.NewSymbol("read-string")
	sym_reader := lang.NewSymbol("reader")
	sym_reader_DASH_conditional := lang.NewSymbol("reader-conditional")
	sym_reader_DASH_conditional_QMARK_ := lang.NewSymbol("reader-conditional?")
	sym_realized_QMARK_ := lang.NewSymbol("realized?")
	sym_recur := lang.NewSymbol("recur")
	sym_recursive_QMARK_ := lang.NewSymbol("recursive?")
	sym_reduce := lang.NewSymbol("reduce")
	sym_reduce_DASH_kv := lang.NewSymbol("reduce-kv")
	sym_reduce1 := lang.NewSymbol("reduce1")
	sym_reduced := lang.NewSymbol("reduced")
	sym_reduced_QMARK_ := lang.NewSymbol("reduced?")
	sym_reductions := lang.NewSymbol("reductions")
	sym_ref := lang.NewSymbol("ref")
	sym_ref_DASH_history_DASH_count := lang.NewSymbol("ref-history-count")
	sym_ref_DASH_max_DASH_history := lang.NewSymbol("ref-max-history")
	sym_ref_DASH_min_DASH_history := lang.NewSymbol("ref-min-history")
	sym_ref_DASH_set := lang.NewSymbol("ref-set")
	sym_refer := lang.NewSymbol("refer")
	sym_refer_DASH_glojure := lang.NewSymbol("refer-glojure")
	sym_reference := lang.NewSymbol("reference")
	sym_references_STAR_ := lang.NewSymbol("references*")
	sym_release_DASH_pending_DASH_sends := lang.NewSymbol("release-pending-sends")
	sym_rem := lang.NewSymbol("rem")
	sym_remove := lang.NewSymbol("remove")
	sym_remove_DASH_all_DASH_methods := lang.NewSymbol("remove-all-methods")
	sym_remove_DASH_method := lang.NewSymbol("remove-method")
	sym_remove_DASH_ns := lang.NewSymbol("remove-ns")
	sym_remove_DASH_tap := lang.NewSymbol("remove-tap")
	sym_remove_DASH_watch := lang.NewSymbol("remove-watch")
	sym_rep := lang.NewSymbol("rep")
	sym_repeat := lang.NewSymbol("repeat")
	sym_repeatedly := lang.NewSymbol("repeatedly")
	sym_replace := lang.NewSymbol("replace")
	sym_replicate := lang.NewSymbol("replicate")
	sym_require := lang.NewSymbol("require")
	sym_requiring_DASH_resolve := lang.NewSymbol("requiring-resolve")
	sym_reset_BANG_ := lang.NewSymbol("reset!")
	sym_reset_DASH_meta_BANG_ := lang.NewSymbol("reset-meta!")
	sym_reset_DASH_vals_BANG_ := lang.NewSymbol("reset-vals!")
	sym_resolve := lang.NewSymbol("resolve")
	sym_rest := lang.NewSymbol("rest")
	sym_restart_DASH_agent := lang.NewSymbol("restart-agent")
	sym_resultset_DASH_seq := lang.NewSymbol("resultset-seq")
	sym_ret := lang.NewSymbol("ret")
	sym_ret__1__auto__ := lang.NewSymbol("ret__1__auto__")
	sym_retf := lang.NewSymbol("retf")
	sym_rev := lang.NewSymbol("rev")
	sym_reverse := lang.NewSymbol("reverse")
	sym_reversible_QMARK_ := lang.NewSymbol("reversible?")
	sym_rf := lang.NewSymbol("rf")
	sym_root := lang.NewSymbol("root")
	sym_root_DASH_directory := lang.NewSymbol("root-directory")
	sym_root_DASH_resource := lang.NewSymbol("root-resource")
	sym_rs := lang.NewSymbol("rs")
	sym_rseq := lang.NewSymbol("rseq")
	sym_rsubseq := lang.NewSymbol("rsubseq")
	sym_run_BANG_ := lang.NewSymbol("run!")
	sym_s := lang.NewSymbol("s")
	sym_s__0__auto__ := lang.NewSymbol("s__0__auto__")
	sym_sc := lang.NewSymbol("sc")
	sym_second := lang.NewSymbol("second")
	sym_select_DASH_keys := lang.NewSymbol("select-keys")
	sym_send := lang.NewSymbol("send")
	sym_send_DASH_off := lang.NewSymbol("send-off")
	sym_send_DASH_via := lang.NewSymbol("send-via")
	sym_sep := lang.NewSymbol("sep")
	sym_seq := lang.NewSymbol("seq")
	sym_seq_DASH_exprs := lang.NewSymbol("seq-exprs")
	sym_seq_DASH_reduce := lang.NewSymbol("seq-reduce")
	sym_seq_DASH_to_DASH_map_DASH_for_DASH_destructuring := lang.NewSymbol("seq-to-map-for-destructuring")
	sym_seq_QMARK_ := lang.NewSymbol("seq?")
	sym_seqable_QMARK_ := lang.NewSymbol("seqable?")
	sym_seque := lang.NewSymbol("seque")
	sym_sequence := lang.NewSymbol("sequence")
	sym_sequential_QMARK_ := lang.NewSymbol("sequential?")
	sym_serialized_DASH_require := lang.NewSymbol("serialized-require")
	sym_set := lang.NewSymbol("set")
	sym_set_DASH_agent_DASH_send_DASH_executor_BANG_ := lang.NewSymbol("set-agent-send-executor!")
	sym_set_DASH_agent_DASH_send_DASH_off_DASH_executor_BANG_ := lang.NewSymbol("set-agent-send-off-executor!")
	sym_set_DASH_error_DASH_handler_BANG_ := lang.NewSymbol("set-error-handler!")
	sym_set_DASH_error_DASH_mode_BANG_ := lang.NewSymbol("set-error-mode!")
	sym_set_DASH_validator_BANG_ := lang.NewSymbol("set-validator!")
	sym_set_QMARK_ := lang.NewSymbol("set?")
	sym_setDynamic := lang.NewSymbol("setDynamic")
	sym_setup_DASH_reference := lang.NewSymbol("setup-reference")
	sym_shift := lang.NewSymbol("shift")
	sym_shift_DASH_mask := lang.NewSymbol("shift-mask")
	sym_short := lang.NewSymbol("short")
	sym_short_DASH_array := lang.NewSymbol("short-array")
	sym_shortCast := lang.NewSymbol("shortCast")
	sym_shorts := lang.NewSymbol("shorts")
	sym_shuffle := lang.NewSymbol("shuffle")
	sym_shutdown_DASH_agents := lang.NewSymbol("shutdown-agents")
	sym_sigs := lang.NewSymbol("sigs")
	sym_simple_DASH_ident_QMARK_ := lang.NewSymbol("simple-ident?")
	sym_simple_DASH_keyword_QMARK_ := lang.NewSymbol("simple-keyword?")
	sym_simple_DASH_symbol_QMARK_ := lang.NewSymbol("simple-symbol?")
	sym_size := lang.NewSymbol("size")
	sym_size_DASH_or_DASH_seq := lang.NewSymbol("size-or-seq")
	sym_size__1__auto__ := lang.NewSymbol("size__1__auto__")
	sym_slurp := lang.NewSymbol("slurp")
	sym_smap := lang.NewSymbol("smap")
	sym_some := lang.NewSymbol("some")
	sym_some_DASH__GT_ := lang.NewSymbol("some->")
	sym_some_DASH__GT__GT_ := lang.NewSymbol("some->>")
	sym_some_DASH_fn := lang.NewSymbol("some-fn")
	sym_some_QMARK_ := lang.NewSymbol("some?")
	sym_somef := lang.NewSymbol("somef")
	sym_sort := lang.NewSymbol("sort")
	sym_sort_DASH_by := lang.NewSymbol("sort-by")
	sym_sorted_DASH_map := lang.NewSymbol("sorted-map")
	sym_sorted_DASH_map_DASH_by := lang.NewSymbol("sorted-map-by")
	sym_sorted_DASH_set := lang.NewSymbol("sorted-set")
	sym_sorted_DASH_set_DASH_by := lang.NewSymbol("sorted-set-by")
	sym_sorted_QMARK_ := lang.NewSymbol("sorted?")
	sym_special_DASH_symbol_QMARK_ := lang.NewSymbol("special-symbol?")
	sym_specs := lang.NewSymbol("specs")
	sym_spit := lang.NewSymbol("spit")
	sym_splicing_QMARK_ := lang.NewSymbol("splicing?")
	sym_split_DASH_at := lang.NewSymbol("split-at")
	sym_split_DASH_with := lang.NewSymbol("split-with")
	sym_splitv_DASH_at := lang.NewSymbol("splitv-at")
	sym_spread := lang.NewSymbol("spread")
	sym_start := lang.NewSymbol("start")
	sym_start_DASH_key := lang.NewSymbol("start-key")
	sym_start_DASH_test := lang.NewSymbol("start-test")
	sym_start__0__auto__ := lang.NewSymbol("start__0__auto__")
	sym_state := lang.NewSymbol("state")
	sym_step := lang.NewSymbol("step")
	sym_str := lang.NewSymbol("str")
	sym_stream := lang.NewSymbol("stream")
	sym_stream_DASH_into_BANG_ := lang.NewSymbol("stream-into!")
	sym_stream_DASH_reduce_BANG_ := lang.NewSymbol("stream-reduce!")
	sym_stream_DASH_seq_BANG_ := lang.NewSymbol("stream-seq!")
	sym_stream_DASH_transduce_BANG_ := lang.NewSymbol("stream-transduce!")
	sym_string_QMARK_ := lang.NewSymbol("string?")
	sym_strings_DOT_Builder := lang.NewSymbol("strings.Builder")
	sym_strip_DASH_ns := lang.NewSymbol("strip-ns")
	sym_struct := lang.NewSymbol("struct")
	sym_struct_DASH_map := lang.NewSymbol("struct-map")
	sym_subs := lang.NewSymbol("subs")
	sym_subseq := lang.NewSymbol("subseq")
	sym_subvec := lang.NewSymbol("subvec")
	sym_supers := lang.NewSymbol("supers")
	sym_swap_BANG_ := lang.NewSymbol("swap!")
	sym_swap_DASH_vals_BANG_ := lang.NewSymbol("swap-vals!")
	sym_sym := lang.NewSymbol("sym")
	sym_symbol := lang.NewSymbol("symbol")
	sym_symbol_QMARK_ := lang.NewSymbol("symbol?")
	sym_sync := lang.NewSymbol("sync")
	sym_system_DASH_newline := lang.NewSymbol("system-newline")
	sym_t := lang.NewSymbol("t")
	sym_tag := lang.NewSymbol("tag")
	sym_tagged_DASH_literal := lang.NewSymbol("tagged-literal")
	sym_tagged_DASH_literal_QMARK_ := lang.NewSymbol("tagged-literal?")
	sym_take := lang.NewSymbol("take")
	sym_take_DASH_last := lang.NewSymbol("take-last")
	sym_take_DASH_nth := lang.NewSymbol("take-nth")
	sym_take_DASH_while := lang.NewSymbol("take-while")
	sym_tapset := lang.NewSymbol("tapset")
	sym_temp__0__auto__ := lang.NewSymbol("temp__0__auto__")
	sym_test := lang.NewSymbol("test")
	sym_test_DASH_f := lang.NewSymbol("test-f")
	sym_tests := lang.NewSymbol("tests")
	sym_the_DASH_ns := lang.NewSymbol("the-ns")
	sym_then := lang.NewSymbol("then")
	sym_thens := lang.NewSymbol("thens")
	sym_this := lang.NewSymbol("this")
	sym_thread_DASH_bound_QMARK_ := lang.NewSymbol("thread-bound?")
	sym_throw := lang.NewSymbol("throw")
	sym_throw_DASH_if := lang.NewSymbol("throw-if")
	sym_time := lang.NewSymbol("time")
	sym_time_DOT_Now := lang.NewSymbol("time.Now")
	sym_timeout_DASH_ms := lang.NewSymbol("timeout-ms")
	sym_timeout_DASH_val := lang.NewSymbol("timeout-val")
	sym_to := lang.NewSymbol("to")
	sym_to_DASH_array := lang.NewSymbol("to-array")
	sym_to_DASH_array_DASH_2d := lang.NewSymbol("to-array-2d")
	sym_trampoline := lang.NewSymbol("trampoline")
	sym_transduce := lang.NewSymbol("transduce")
	sym_transient := lang.NewSymbol("transient")
	sym_tree_DASH_seq := lang.NewSymbol("tree-seq")
	sym_true_QMARK_ := lang.NewSymbol("true?")
	sym_try := lang.NewSymbol("try")
	sym_type := lang.NewSymbol("type")
	sym_unchecked_DASH_add := lang.NewSymbol("unchecked-add")
	sym_unchecked_DASH_add_DASH_int := lang.NewSymbol("unchecked-add-int")
	sym_unchecked_DASH_byte := lang.NewSymbol("unchecked-byte")
	sym_unchecked_DASH_char := lang.NewSymbol("unchecked-char")
	sym_unchecked_DASH_dec := lang.NewSymbol("unchecked-dec")
	sym_unchecked_DASH_dec_DASH_int := lang.NewSymbol("unchecked-dec-int")
	sym_unchecked_DASH_divide_DASH_int := lang.NewSymbol("unchecked-divide-int")
	sym_unchecked_DASH_double := lang.NewSymbol("unchecked-double")
	sym_unchecked_DASH_float := lang.NewSymbol("unchecked-float")
	sym_unchecked_DASH_inc := lang.NewSymbol("unchecked-inc")
	sym_unchecked_DASH_inc_DASH_int := lang.NewSymbol("unchecked-inc-int")
	sym_unchecked_DASH_int := lang.NewSymbol("unchecked-int")
	sym_unchecked_DASH_long := lang.NewSymbol("unchecked-long")
	sym_unchecked_DASH_multiply := lang.NewSymbol("unchecked-multiply")
	sym_unchecked_DASH_multiply_DASH_int := lang.NewSymbol("unchecked-multiply-int")
	sym_unchecked_DASH_negate := lang.NewSymbol("unchecked-negate")
	sym_unchecked_DASH_negate_DASH_int := lang.NewSymbol("unchecked-negate-int")
	sym_unchecked_DASH_op := lang.NewSymbol("unchecked-op")
	sym_unchecked_DASH_remainder_DASH_int := lang.NewSymbol("unchecked-remainder-int")
	sym_unchecked_DASH_short := lang.NewSymbol("unchecked-short")
	sym_unchecked_DASH_subtract := lang.NewSymbol("unchecked-subtract")
	sym_unchecked_DASH_subtract_DASH_int := lang.NewSymbol("unchecked-subtract-int")
	sym_uncheckedByteCast := lang.NewSymbol("uncheckedByteCast")
	sym_uncheckedCharCast := lang.NewSymbol("uncheckedCharCast")
	sym_uncheckedFloatCast := lang.NewSymbol("uncheckedFloatCast")
	sym_uncheckedIntCast := lang.NewSymbol("uncheckedIntCast")
	sym_uncheckedShortCast := lang.NewSymbol("uncheckedShortCast")
	sym_unchecked_add := lang.NewSymbol("unchecked_add")
	sym_unchecked_dec := lang.NewSymbol("unchecked_dec")
	sym_unchecked_inc := lang.NewSymbol("unchecked_inc")
	sym_unchecked_minus := lang.NewSymbol("unchecked_minus")
	sym_unchecked_multiply := lang.NewSymbol("unchecked_multiply")
	sym_underive := lang.NewSymbol("underive")
	sym_unquote := lang.NewSymbol("unquote")
	sym_unquote_DASH_splicing := lang.NewSymbol("unquote-splicing")
	sym_unreduced := lang.NewSymbol("unreduced")
	sym_unsigned_DASH_bit_DASH_shift_DASH_right := lang.NewSymbol("unsigned-bit-shift-right")
	sym_update := lang.NewSymbol("update")
	sym_update_DASH_in := lang.NewSymbol("update-in")
	sym_update_DASH_keys := lang.NewSymbol("update-keys")
	sym_update_DASH_vals := lang.NewSymbol("update-vals")
	sym_uri_QMARK_ := lang.NewSymbol("uri?")
	sym_url := lang.NewSymbol("url")
	sym_use := lang.NewSymbol("use")
	sym_uuid_QMARK_ := lang.NewSymbol("uuid?")
	sym_v := lang.NewSymbol("v")
	sym_v__0__auto__ := lang.NewSymbol("v__0__auto__")
	sym_val := lang.NewSymbol("val")
	sym_val__2__auto__ := lang.NewSymbol("val__2__auto__")
	sym_valid_DASH_keys := lang.NewSymbol("valid-keys")
	sym_validator_DASH_fn := lang.NewSymbol("validator-fn")
	sym_vals := lang.NewSymbol("vals")
	sym_value := lang.NewSymbol("value")
	sym_var := lang.NewSymbol("var")
	sym_var_DASH_get := lang.NewSymbol("var-get")
	sym_var_DASH_set := lang.NewSymbol("var-set")
	sym_var_QMARK_ := lang.NewSymbol("var?")
	sym_vars := lang.NewSymbol("vars")
	sym_vary_DASH_meta := lang.NewSymbol("vary-meta")
	sym_vec := lang.NewSymbol("vec")
	sym_vector := lang.NewSymbol("vector")
	sym_vector_QMARK_ := lang.NewSymbol("vector?")
	sym_vf := lang.NewSymbol("vf")
	sym_vol := lang.NewSymbol("vol")
	sym_volatile_BANG_ := lang.NewSymbol("volatile!")
	sym_volatile_QMARK_ := lang.NewSymbol("volatile?")
	sym_vreset_BANG_ := lang.NewSymbol("vreset!")
	sym_vswap_BANG_ := lang.NewSymbol("vswap!")
	sym_w := lang.NewSymbol("w")
	sym_when := lang.NewSymbol("when")
	sym_when_DASH_first := lang.NewSymbol("when-first")
	sym_when_DASH_let := lang.NewSymbol("when-let")
	sym_when_DASH_not := lang.NewSymbol("when-not")
	sym_when_DASH_some := lang.NewSymbol("when-some")
	sym_while := lang.NewSymbol("while")
	sym_with_DASH_bindings := lang.NewSymbol("with-bindings")
	sym_with_DASH_bindings_STAR_ := lang.NewSymbol("with-bindings*")
	sym_with_DASH_in_DASH_str := lang.NewSymbol("with-in-str")
	sym_with_DASH_loading_DASH_context := lang.NewSymbol("with-loading-context")
	sym_with_DASH_local_DASH_vars := lang.NewSymbol("with-local-vars")
	sym_with_DASH_meta := lang.NewSymbol("with-meta")
	sym_with_DASH_open := lang.NewSymbol("with-open")
	sym_with_DASH_out_DASH_str := lang.NewSymbol("with-out-str")
	sym_with_DASH_precision := lang.NewSymbol("with-precision")
	sym_with_DASH_redefs := lang.NewSymbol("with-redefs")
	sym_with_DASH_redefs_DASH_fn := lang.NewSymbol("with-redefs-fn")
	sym_x := lang.NewSymbol("x")
	sym_xform := lang.NewSymbol("xform")
	sym_xml_DASH_seq := lang.NewSymbol("xml-seq")
	sym_xor := lang.NewSymbol("xor")
	sym_xs := lang.NewSymbol("xs")
	sym_xs__0__auto__ := lang.NewSymbol("xs__0__auto__")
	sym_y := lang.NewSymbol("y")
	sym_ys := lang.NewSymbol("ys")
	sym_z := lang.NewSymbol("z")
	sym_zero_QMARK_ := lang.NewSymbol("zero?")
	sym_zipmap := lang.NewSymbol("zipmap")
	sym_zs := lang.NewSymbol("zs")
	kw__GT__GT_ := lang.NewKeyword(">>")
	kw_added := lang.NewKeyword("added")
	kw_all := lang.NewKeyword("all")
	kw_allow := lang.NewKeyword("allow")
	kw_ancestors := lang.NewKeyword("ancestors")
	kw_arglists := lang.NewKeyword("arglists")
	kw_as := lang.NewKeyword("as")
	kw_as_DASH_alias := lang.NewKeyword("as-alias")
	kw_at := lang.NewKeyword("at")
	kw_cause := lang.NewKeyword("cause")
	kw_clear_DASH_actions := lang.NewKeyword("clear-actions")
	kw_coll_DASH_reduce := lang.NewKeyword("coll-reduce")
	kw_column := lang.NewKeyword("column")
	kw_compact := lang.NewKeyword("compact")
	kw_conflict := lang.NewKeyword("conflict")
	kw_content := lang.NewKeyword("content")
	kw_continue := lang.NewKeyword("continue")
	kw_data := lang.NewKeyword("data")
	kw_datafy := lang.NewKeyword("datafy")
	kw_declared := lang.NewKeyword("declared")
	kw_default := lang.NewKeyword("default")
	kw_deprecated := lang.NewKeyword("deprecated")
	kw_descendants := lang.NewKeyword("descendants")
	kw_doc := lang.NewKeyword("doc")
	kw_dynamic := lang.NewKeyword("dynamic")
	kw_else := lang.NewKeyword("else")
	kw_encoding := lang.NewKeyword("encoding")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_eof := lang.NewKeyword("eof")
	kw_error_DASH_handler := lang.NewKeyword("error-handler")
	kw_error_DASH_mode := lang.NewKeyword("error-mode")
	kw_exclude := lang.NewKeyword("exclude")
	kw_fail := lang.NewKeyword("fail")
	kw_failed := lang.NewKeyword("failed")
	kw_file := lang.NewKeyword("file")
	kw_form := lang.NewKeyword("form")
	kw_forms := lang.NewKeyword("forms")
	kw_gen_DASH_class := lang.NewKeyword("gen-class")
	kw_glojure_DOT_core_SLASH_halt := lang.NewKeyword("glojure.core/halt")
	kw_glojure_DOT_core_SLASH_none := lang.NewKeyword("glojure.core/none")
	kw_glojure_DOT_error_SLASH_phase := lang.NewKeyword("glojure.error/phase")
	kw_hash_DASH_equiv := lang.NewKeyword("hash-equiv")
	kw_hash_DASH_identity := lang.NewKeyword("hash-identity")
	kw_hashes := lang.NewKeyword("hashes")
	kw_hierarchy := lang.NewKeyword("hierarchy")
	kw_identity := lang.NewKeyword("identity")
	kw_impl_DASH_ns := lang.NewKeyword("impl-ns")
	kw_initk := lang.NewKeyword("initk")
	kw_inline := lang.NewKeyword("inline")
	kw_inline_DASH_arities := lang.NewKeyword("inline-arities")
	kw_int := lang.NewKeyword("int")
	kw_internal_DASH_reduce := lang.NewKeyword("internal-reduce")
	kw_ints := lang.NewKeyword("ints")
	kw_keys := lang.NewKeyword("keys")
	kw_kf := lang.NewKeyword("kf")
	kw_kv_DASH_reduce := lang.NewKeyword("kv-reduce")
	kw_let := lang.NewKeyword("let")
	kw_line := lang.NewKeyword("line")
	kw_macro := lang.NewKeyword("macro")
	kw_main := lang.NewKeyword("main")
	kw_make_DASH_input_DASH_stream := lang.NewKeyword("make-input-stream")
	kw_make_DASH_output_DASH_stream := lang.NewKeyword("make-output-stream")
	kw_make_DASH_reader := lang.NewKeyword("make-reader")
	kw_make_DASH_writer := lang.NewKeyword("make-writer")
	kw_mappings := lang.NewKeyword("mappings")
	kw_max_DASH_history := lang.NewKeyword("max-history")
	kw_message := lang.NewKeyword("message")
	kw_meta := lang.NewKeyword("meta")
	kw_min_DASH_history := lang.NewKeyword("min-history")
	kw_multis := lang.NewKeyword("multis")
	kw_name := lang.NewKeyword("name")
	kw_nav := lang.NewKeyword("nav")
	kw_no_DASH_test := lang.NewKeyword("no-test")
	kw_ns := lang.NewKeyword("ns")
	kw_ok := lang.NewKeyword("ok")
	kw_on_DASH_interface := lang.NewKeyword("on-interface")
	kw_only := lang.NewKeyword("only")
	kw_or := lang.NewKeyword("or")
	kw_parents := lang.NewKeyword("parents")
	kw_pending := lang.NewKeyword("pending")
	kw_phase := lang.NewKeyword("phase")
	kw_post := lang.NewKeyword("post")
	kw_pre := lang.NewKeyword("pre")
	kw_private := lang.NewKeyword("private")
	kw_read_DASH_cond := lang.NewKeyword("read-cond")
	kw_ready := lang.NewKeyword("ready")
	kw_redef := lang.NewKeyword("redef")
	kw_refer := lang.NewKeyword("refer")
	kw_refer_DASH_glojure := lang.NewKeyword("refer-glojure")
	kw_reload := lang.NewKeyword("reload")
	kw_reload_DASH_all := lang.NewKeyword("reload-all")
	kw_rename := lang.NewKeyword("rename")
	kw_require := lang.NewKeyword("require")
	kw_rettag := lang.NewKeyword("rettag")
	kw_rounding := lang.NewKeyword("rounding")
	kw_sigs := lang.NewKeyword("sigs")
	kw_somef := lang.NewKeyword("somef")
	kw_sparse := lang.NewKeyword("sparse")
	kw_special_DASH_form := lang.NewKeyword("special-form")
	kw_static := lang.NewKeyword("static")
	kw_status := lang.NewKeyword("status")
	kw_tag := lang.NewKeyword("tag")
	kw_test := lang.NewKeyword("test")
	kw_trace := lang.NewKeyword("trace")
	kw_type := lang.NewKeyword("type")
	kw_url := lang.NewKeyword("url")
	kw_use := lang.NewKeyword("use")
	kw_val := lang.NewKeyword("val")
	kw_validator := lang.NewKeyword("validator")
	kw_verbose := lang.NewKeyword("verbose")
	kw_vf := lang.NewKeyword("vf")
	kw_via := lang.NewKeyword("via")
	kw_when := lang.NewKeyword("when")
	kw_while := lang.NewKeyword("while")
	// var glojure.core.protocols/coll-reduce
	var_glojure_DOT_core_DOT_protocols_coll_DASH_reduce := lang.InternVarName(sym_glojure_DOT_core_DOT_protocols, sym_coll_DASH_reduce)
	// var glojure.core.protocols/interface-or-naive-reduce
	var_glojure_DOT_core_DOT_protocols_interface_DASH_or_DASH_naive_DASH_reduce := lang.InternVarName(sym_glojure_DOT_core_DOT_protocols, sym_interface_DASH_or_DASH_naive_DASH_reduce)
	// var glojure.core.protocols/kv-reduce
	var_glojure_DOT_core_DOT_protocols_kv_DASH_reduce := lang.InternVarName(sym_glojure_DOT_core_DOT_protocols, sym_kv_DASH_reduce)
	// var glojure.core.protocols/seq-reduce
	var_glojure_DOT_core_DOT_protocols_seq_DASH_reduce := lang.InternVarName(sym_glojure_DOT_core_DOT_protocols, sym_seq_DASH_reduce)
	// var glojure.core/NaN?
	var_glojure_DOT_core_NaN_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_NaN_QMARK_)
	// var glojure.core/StackTraceElement->vec
	var_glojure_DOT_core_StackTraceElement_DASH__GT_vec := lang.InternVarName(sym_glojure_DOT_core, sym_StackTraceElement_DASH__GT_vec)
	// var glojure.core/Throwable->map
	var_glojure_DOT_core_Throwable_DASH__GT_map := lang.InternVarName(sym_glojure_DOT_core, sym_Throwable_DASH__GT_map)
	// var glojure.core/-
	var_glojure_DOT_core__DASH_ := lang.InternVarName(sym_glojure_DOT_core, sym__DASH_)
	// var glojure.core/->
	var_glojure_DOT_core__DASH__GT_ := lang.InternVarName(sym_glojure_DOT_core, sym__DASH__GT_)
	// var glojure.core/->>
	var_glojure_DOT_core__DASH__GT__GT_ := lang.InternVarName(sym_glojure_DOT_core, sym__DASH__GT__GT_)
	// var glojure.core/-'
	var_glojure_DOT_core__DASH__TICK_ := lang.InternVarName(sym_glojure_DOT_core, sym__DASH__TICK_)
	// var glojure.core/-protocols
	var_glojure_DOT_core__DASH_protocols := lang.InternVarName(sym_glojure_DOT_core, sym__DASH_protocols)
	// var glojure.core/..
	var_glojure_DOT_core__DOT__DOT_ := lang.InternVarName(sym_glojure_DOT_core, sym__DOT__DOT_)
	// var glojure.core/=
	var_glojure_DOT_core__EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym__EQ_)
	// var glojure.core/==
	var_glojure_DOT_core__EQ__EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym__EQ__EQ_)
	// var glojure.core/>
	var_glojure_DOT_core__GT_ := lang.InternVarName(sym_glojure_DOT_core, sym__GT_)
	// var glojure.core/>0?
	var_glojure_DOT_core__GT_0_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym__GT_0_QMARK_)
	// var glojure.core/>1?
	var_glojure_DOT_core__GT_1_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym__GT_1_QMARK_)
	// var glojure.core/>=
	var_glojure_DOT_core__GT__EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym__GT__EQ_)
	// var glojure.core/<
	var_glojure_DOT_core__LT_ := lang.InternVarName(sym_glojure_DOT_core, sym__LT_)
	// var glojure.core/<=
	var_glojure_DOT_core__LT__EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym__LT__EQ_)
	// var glojure.core/+
	var_glojure_DOT_core__PLUS_ := lang.InternVarName(sym_glojure_DOT_core, sym__PLUS_)
	// var glojure.core/+'
	var_glojure_DOT_core__PLUS__TICK_ := lang.InternVarName(sym_glojure_DOT_core, sym__PLUS__TICK_)
	// var glojure.core//
	var_glojure_DOT_core__SLASH_ := lang.InternVarName(sym_glojure_DOT_core, sym__SLASH_)
	// var glojure.core/*
	var_glojure_DOT_core__STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_)
	// var glojure.core/*1
	var_glojure_DOT_core__STAR_1 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_1)
	// var glojure.core/*2
	var_glojure_DOT_core__STAR_2 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_2)
	// var glojure.core/*3
	var_glojure_DOT_core__STAR_3 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_3)
	// var glojure.core/*'
	var_glojure_DOT_core__STAR__TICK_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR__TICK_)
	// var glojure.core/*agent*
	var_glojure_DOT_core__STAR_agent_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_agent_STAR_)
	// var glojure.core/*assert*
	var_glojure_DOT_core__STAR_assert_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_assert_STAR_)
	// var glojure.core/*command-line-args*
	var_glojure_DOT_core__STAR_command_DASH_line_DASH_args_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_command_DASH_line_DASH_args_STAR_)
	// var glojure.core/*compile-files*
	var_glojure_DOT_core__STAR_compile_DASH_files_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_compile_DASH_files_STAR_)
	// var glojure.core/*compile-path*
	var_glojure_DOT_core__STAR_compile_DASH_path_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_compile_DASH_path_STAR_)
	// var glojure.core/*compiler-options*
	var_glojure_DOT_core__STAR_compiler_DASH_options_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_compiler_DASH_options_STAR_)
	// var glojure.core/*data-readers*
	var_glojure_DOT_core__STAR_data_DASH_readers_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_data_DASH_readers_STAR_)
	// var glojure.core/*default-data-reader-fn*
	var_glojure_DOT_core__STAR_default_DASH_data_DASH_reader_DASH_fn_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_default_DASH_data_DASH_reader_DASH_fn_STAR_)
	// var glojure.core/*e
	var_glojure_DOT_core__STAR_e := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_e)
	// var glojure.core/*err*
	var_glojure_DOT_core__STAR_err_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_err_STAR_)
	// var glojure.core/*file*
	var_glojure_DOT_core__STAR_file_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_file_STAR_)
	// var glojure.core/*flush-on-newline*
	var_glojure_DOT_core__STAR_flush_DASH_on_DASH_newline_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_flush_DASH_on_DASH_newline_STAR_)
	// var glojure.core/*in*
	var_glojure_DOT_core__STAR_in_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_in_STAR_)
	// var glojure.core/*loaded-libs*
	var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_loaded_DASH_libs_STAR_)
	// var glojure.core/*loading-verbosely*
	var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_loading_DASH_verbosely_STAR_)
	// var glojure.core/*ns*
	var_glojure_DOT_core__STAR_ns_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_ns_STAR_)
	// var glojure.core/*out*
	var_glojure_DOT_core__STAR_out_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_out_STAR_)
	// var glojure.core/*pending-paths*
	var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_pending_DASH_paths_STAR_)
	// var glojure.core/*print-dup*
	var_glojure_DOT_core__STAR_print_DASH_dup_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_dup_STAR_)
	// var glojure.core/*print-length*
	var_glojure_DOT_core__STAR_print_DASH_length_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_length_STAR_)
	// var glojure.core/*print-level*
	var_glojure_DOT_core__STAR_print_DASH_level_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_level_STAR_)
	// var glojure.core/*print-meta*
	var_glojure_DOT_core__STAR_print_DASH_meta_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_meta_STAR_)
	// var glojure.core/*print-namespace-maps*
	var_glojure_DOT_core__STAR_print_DASH_namespace_DASH_maps_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_namespace_DASH_maps_STAR_)
	// var glojure.core/*print-readably*
	var_glojure_DOT_core__STAR_print_DASH_readably_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_readably_STAR_)
	// var glojure.core/*read-eval*
	var_glojure_DOT_core__STAR_read_DASH_eval_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_read_DASH_eval_STAR_)
	// var glojure.core/*repl*
	var_glojure_DOT_core__STAR_repl_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_repl_STAR_)
	// var glojure.core/*unchecked-math*
	var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_unchecked_DASH_math_STAR_)
	// var glojure.core/*verbose-defrecords*
	var_glojure_DOT_core__STAR_verbose_DASH_defrecords_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_verbose_DASH_defrecords_STAR_)
	// var glojure.core/*warn-on-reflection*
	var_glojure_DOT_core__STAR_warn_DASH_on_DASH_reflection_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_warn_DASH_on_DASH_reflection_STAR_)
	// var glojure.core/abs
	var_glojure_DOT_core_abs := lang.InternVarName(sym_glojure_DOT_core, sym_abs)
	// var glojure.core/accessor
	var_glojure_DOT_core_accessor := lang.InternVarName(sym_glojure_DOT_core, sym_accessor)
	// var glojure.core/aclone
	var_glojure_DOT_core_aclone := lang.InternVarName(sym_glojure_DOT_core, sym_aclone)
	// var glojure.core/add-classpath
	var_glojure_DOT_core_add_DASH_classpath := lang.InternVarName(sym_glojure_DOT_core, sym_add_DASH_classpath)
	// var glojure.core/add-doc-and-meta
	var_glojure_DOT_core_add_DASH_doc_DASH_and_DASH_meta := lang.InternVarName(sym_glojure_DOT_core, sym_add_DASH_doc_DASH_and_DASH_meta)
	// var glojure.core/add-watch
	var_glojure_DOT_core_add_DASH_watch := lang.InternVarName(sym_glojure_DOT_core, sym_add_DASH_watch)
	// var glojure.core/agent
	var_glojure_DOT_core_agent := lang.InternVarName(sym_glojure_DOT_core, sym_agent)
	// var glojure.core/agent-error
	var_glojure_DOT_core_agent_DASH_error := lang.InternVarName(sym_glojure_DOT_core, sym_agent_DASH_error)
	// var glojure.core/agent-errors
	var_glojure_DOT_core_agent_DASH_errors := lang.InternVarName(sym_glojure_DOT_core, sym_agent_DASH_errors)
	// var glojure.core/aget
	var_glojure_DOT_core_aget := lang.InternVarName(sym_glojure_DOT_core, sym_aget)
	// var glojure.core/alength
	var_glojure_DOT_core_alength := lang.InternVarName(sym_glojure_DOT_core, sym_alength)
	// var glojure.core/alias
	var_glojure_DOT_core_alias := lang.InternVarName(sym_glojure_DOT_core, sym_alias)
	// var glojure.core/all-ns
	var_glojure_DOT_core_all_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_all_DASH_ns)
	// var glojure.core/alter
	var_glojure_DOT_core_alter := lang.InternVarName(sym_glojure_DOT_core, sym_alter)
	// var glojure.core/alter-meta!
	var_glojure_DOT_core_alter_DASH_meta_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_alter_DASH_meta_BANG_)
	// var glojure.core/alter-var-root
	var_glojure_DOT_core_alter_DASH_var_DASH_root := lang.InternVarName(sym_glojure_DOT_core, sym_alter_DASH_var_DASH_root)
	// var glojure.core/amap
	var_glojure_DOT_core_amap := lang.InternVarName(sym_glojure_DOT_core, sym_amap)
	// var glojure.core/ancestors
	var_glojure_DOT_core_ancestors := lang.InternVarName(sym_glojure_DOT_core, sym_ancestors)
	// var glojure.core/and
	var_glojure_DOT_core_and := lang.InternVarName(sym_glojure_DOT_core, sym_and)
	// var glojure.core/any?
	var_glojure_DOT_core_any_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_any_QMARK_)
	// var glojure.core/apply
	var_glojure_DOT_core_apply := lang.InternVarName(sym_glojure_DOT_core, sym_apply)
	// var glojure.core/areduce
	var_glojure_DOT_core_areduce := lang.InternVarName(sym_glojure_DOT_core, sym_areduce)
	// var glojure.core/array
	var_glojure_DOT_core_array := lang.InternVarName(sym_glojure_DOT_core, sym_array)
	// var glojure.core/array-map
	var_glojure_DOT_core_array_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_array_DASH_map)
	// var glojure.core/as->
	var_glojure_DOT_core_as_DASH__GT_ := lang.InternVarName(sym_glojure_DOT_core, sym_as_DASH__GT_)
	// var glojure.core/aset
	var_glojure_DOT_core_aset := lang.InternVarName(sym_glojure_DOT_core, sym_aset)
	// var glojure.core/aset-boolean
	var_glojure_DOT_core_aset_DASH_boolean := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_boolean)
	// var glojure.core/aset-byte
	var_glojure_DOT_core_aset_DASH_byte := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_byte)
	// var glojure.core/aset-char
	var_glojure_DOT_core_aset_DASH_char := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_char)
	// var glojure.core/aset-double
	var_glojure_DOT_core_aset_DASH_double := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_double)
	// var glojure.core/aset-float
	var_glojure_DOT_core_aset_DASH_float := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_float)
	// var glojure.core/aset-int
	var_glojure_DOT_core_aset_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_int)
	// var glojure.core/aset-long
	var_glojure_DOT_core_aset_DASH_long := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_long)
	// var glojure.core/aset-short
	var_glojure_DOT_core_aset_DASH_short := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_short)
	// var glojure.core/assert
	var_glojure_DOT_core_assert := lang.InternVarName(sym_glojure_DOT_core, sym_assert)
	// var glojure.core/assert-args
	var_glojure_DOT_core_assert_DASH_args := lang.InternVarName(sym_glojure_DOT_core, sym_assert_DASH_args)
	// var glojure.core/assert-valid-fdecl
	var_glojure_DOT_core_assert_DASH_valid_DASH_fdecl := lang.InternVarName(sym_glojure_DOT_core, sym_assert_DASH_valid_DASH_fdecl)
	// var glojure.core/assoc
	var_glojure_DOT_core_assoc := lang.InternVarName(sym_glojure_DOT_core, sym_assoc)
	// var glojure.core/assoc!
	var_glojure_DOT_core_assoc_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_assoc_BANG_)
	// var glojure.core/assoc-in
	var_glojure_DOT_core_assoc_DASH_in := lang.InternVarName(sym_glojure_DOT_core, sym_assoc_DASH_in)
	// var glojure.core/associative?
	var_glojure_DOT_core_associative_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_associative_QMARK_)
	// var glojure.core/atom
	var_glojure_DOT_core_atom := lang.InternVarName(sym_glojure_DOT_core, sym_atom)
	// var glojure.core/await
	var_glojure_DOT_core_await := lang.InternVarName(sym_glojure_DOT_core, sym_await)
	// var glojure.core/await1
	var_glojure_DOT_core_await1 := lang.InternVarName(sym_glojure_DOT_core, sym_await1)
	// var glojure.core/await-for
	var_glojure_DOT_core_await_DASH_for := lang.InternVarName(sym_glojure_DOT_core, sym_await_DASH_for)
	// var glojure.core/bases
	var_glojure_DOT_core_bases := lang.InternVarName(sym_glojure_DOT_core, sym_bases)
	// var glojure.core/bigdec
	var_glojure_DOT_core_bigdec := lang.InternVarName(sym_glojure_DOT_core, sym_bigdec)
	// var glojure.core/bigint
	var_glojure_DOT_core_bigint := lang.InternVarName(sym_glojure_DOT_core, sym_bigint)
	// var glojure.core/biginteger
	var_glojure_DOT_core_biginteger := lang.InternVarName(sym_glojure_DOT_core, sym_biginteger)
	// var glojure.core/binding
	var_glojure_DOT_core_binding := lang.InternVarName(sym_glojure_DOT_core, sym_binding)
	// var glojure.core/binding-conveyor-fn
	var_glojure_DOT_core_binding_DASH_conveyor_DASH_fn := lang.InternVarName(sym_glojure_DOT_core, sym_binding_DASH_conveyor_DASH_fn)
	// var glojure.core/bit-and
	var_glojure_DOT_core_bit_DASH_and := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_and)
	// var glojure.core/bit-and-not
	var_glojure_DOT_core_bit_DASH_and_DASH_not := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_and_DASH_not)
	// var glojure.core/bit-clear
	var_glojure_DOT_core_bit_DASH_clear := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_clear)
	// var glojure.core/bit-flip
	var_glojure_DOT_core_bit_DASH_flip := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_flip)
	// var glojure.core/bit-not
	var_glojure_DOT_core_bit_DASH_not := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_not)
	// var glojure.core/bit-or
	var_glojure_DOT_core_bit_DASH_or := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_or)
	// var glojure.core/bit-set
	var_glojure_DOT_core_bit_DASH_set := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_set)
	// var glojure.core/bit-shift-left
	var_glojure_DOT_core_bit_DASH_shift_DASH_left := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_shift_DASH_left)
	// var glojure.core/bit-shift-right
	var_glojure_DOT_core_bit_DASH_shift_DASH_right := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_shift_DASH_right)
	// var glojure.core/bit-test
	var_glojure_DOT_core_bit_DASH_test := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_test)
	// var glojure.core/bit-xor
	var_glojure_DOT_core_bit_DASH_xor := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_xor)
	// var glojure.core/boolean
	var_glojure_DOT_core_boolean := lang.InternVarName(sym_glojure_DOT_core, sym_boolean)
	// var glojure.core/boolean-array
	var_glojure_DOT_core_boolean_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_boolean_DASH_array)
	// var glojure.core/boolean?
	var_glojure_DOT_core_boolean_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_boolean_QMARK_)
	// var glojure.core/booleans
	var_glojure_DOT_core_booleans := lang.InternVarName(sym_glojure_DOT_core, sym_booleans)
	// var glojure.core/bound-fn
	var_glojure_DOT_core_bound_DASH_fn := lang.InternVarName(sym_glojure_DOT_core, sym_bound_DASH_fn)
	// var glojure.core/bound-fn*
	var_glojure_DOT_core_bound_DASH_fn_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym_bound_DASH_fn_STAR_)
	// var glojure.core/bound?
	var_glojure_DOT_core_bound_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_bound_QMARK_)
	// var glojure.core/bounded-count
	var_glojure_DOT_core_bounded_DASH_count := lang.InternVarName(sym_glojure_DOT_core, sym_bounded_DASH_count)
	// var glojure.core/butlast
	var_glojure_DOT_core_butlast := lang.InternVarName(sym_glojure_DOT_core, sym_butlast)
	// var glojure.core/byte
	var_glojure_DOT_core_byte := lang.InternVarName(sym_glojure_DOT_core, sym_byte)
	// var glojure.core/byte-array
	var_glojure_DOT_core_byte_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_byte_DASH_array)
	// var glojure.core/bytes
	var_glojure_DOT_core_bytes := lang.InternVarName(sym_glojure_DOT_core, sym_bytes)
	// var glojure.core/bytes?
	var_glojure_DOT_core_bytes_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_bytes_QMARK_)
	// var glojure.core/case
	var_glojure_DOT_core_case := lang.InternVarName(sym_glojure_DOT_core, sym_case)
	// var glojure.core/case-map
	var_glojure_DOT_core_case_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_case_DASH_map)
	// var glojure.core/cast
	var_glojure_DOT_core_cast := lang.InternVarName(sym_glojure_DOT_core, sym_cast)
	// var glojure.core/cat
	var_glojure_DOT_core_cat := lang.InternVarName(sym_glojure_DOT_core, sym_cat)
	// var glojure.core/char
	var_glojure_DOT_core_char := lang.InternVarName(sym_glojure_DOT_core, sym_char)
	// var glojure.core/char-array
	var_glojure_DOT_core_char_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_char_DASH_array)
	// var glojure.core/char-escape-string
	var_glojure_DOT_core_char_DASH_escape_DASH_string := lang.InternVarName(sym_glojure_DOT_core, sym_char_DASH_escape_DASH_string)
	// var glojure.core/char-name-string
	var_glojure_DOT_core_char_DASH_name_DASH_string := lang.InternVarName(sym_glojure_DOT_core, sym_char_DASH_name_DASH_string)
	// var glojure.core/char?
	var_glojure_DOT_core_char_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_char_QMARK_)
	// var glojure.core/chars
	var_glojure_DOT_core_chars := lang.InternVarName(sym_glojure_DOT_core, sym_chars)
	// var glojure.core/check-cyclic-dependency
	var_glojure_DOT_core_check_DASH_cyclic_DASH_dependency := lang.InternVarName(sym_glojure_DOT_core, sym_check_DASH_cyclic_DASH_dependency)
	// var glojure.core/check-valid-options
	var_glojure_DOT_core_check_DASH_valid_DASH_options := lang.InternVarName(sym_glojure_DOT_core, sym_check_DASH_valid_DASH_options)
	// var glojure.core/chunk
	var_glojure_DOT_core_chunk := lang.InternVarName(sym_glojure_DOT_core, sym_chunk)
	// var glojure.core/chunk-append
	var_glojure_DOT_core_chunk_DASH_append := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_append)
	// var glojure.core/chunk-buffer
	var_glojure_DOT_core_chunk_DASH_buffer := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_buffer)
	// var glojure.core/chunk-cons
	var_glojure_DOT_core_chunk_DASH_cons := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_cons)
	// var glojure.core/chunk-first
	var_glojure_DOT_core_chunk_DASH_first := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_first)
	// var glojure.core/chunk-next
	var_glojure_DOT_core_chunk_DASH_next := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_next)
	// var glojure.core/chunk-rest
	var_glojure_DOT_core_chunk_DASH_rest := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_rest)
	// var glojure.core/chunked-seq?
	var_glojure_DOT_core_chunked_DASH_seq_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_chunked_DASH_seq_QMARK_)
	// var glojure.core/class
	var_glojure_DOT_core_class := lang.InternVarName(sym_glojure_DOT_core, sym_class)
	// var glojure.core/class?
	var_glojure_DOT_core_class_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_class_QMARK_)
	// var glojure.core/clear-agent-errors
	var_glojure_DOT_core_clear_DASH_agent_DASH_errors := lang.InternVarName(sym_glojure_DOT_core, sym_clear_DASH_agent_DASH_errors)
	// var glojure.core/coll?
	var_glojure_DOT_core_coll_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_coll_QMARK_)
	// var glojure.core/comment
	var_glojure_DOT_core_comment := lang.InternVarName(sym_glojure_DOT_core, sym_comment)
	// var glojure.core/commute
	var_glojure_DOT_core_commute := lang.InternVarName(sym_glojure_DOT_core, sym_commute)
	// var glojure.core/comp
	var_glojure_DOT_core_comp := lang.InternVarName(sym_glojure_DOT_core, sym_comp)
	// var glojure.core/comparator
	var_glojure_DOT_core_comparator := lang.InternVarName(sym_glojure_DOT_core, sym_comparator)
	// var glojure.core/compare
	var_glojure_DOT_core_compare := lang.InternVarName(sym_glojure_DOT_core, sym_compare)
	// var glojure.core/compare-and-set!
	var_glojure_DOT_core_compare_DASH_and_DASH_set_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_compare_DASH_and_DASH_set_BANG_)
	// var glojure.core/compile
	var_glojure_DOT_core_compile := lang.InternVarName(sym_glojure_DOT_core, sym_compile)
	// var glojure.core/complement
	var_glojure_DOT_core_complement := lang.InternVarName(sym_glojure_DOT_core, sym_complement)
	// var glojure.core/completing
	var_glojure_DOT_core_completing := lang.InternVarName(sym_glojure_DOT_core, sym_completing)
	// var glojure.core/concat
	var_glojure_DOT_core_concat := lang.InternVarName(sym_glojure_DOT_core, sym_concat)
	// var glojure.core/cond
	var_glojure_DOT_core_cond := lang.InternVarName(sym_glojure_DOT_core, sym_cond)
	// var glojure.core/cond->
	var_glojure_DOT_core_cond_DASH__GT_ := lang.InternVarName(sym_glojure_DOT_core, sym_cond_DASH__GT_)
	// var glojure.core/cond->>
	var_glojure_DOT_core_cond_DASH__GT__GT_ := lang.InternVarName(sym_glojure_DOT_core, sym_cond_DASH__GT__GT_)
	// var glojure.core/condp
	var_glojure_DOT_core_condp := lang.InternVarName(sym_glojure_DOT_core, sym_condp)
	// var glojure.core/conj
	var_glojure_DOT_core_conj := lang.InternVarName(sym_glojure_DOT_core, sym_conj)
	// var glojure.core/conj!
	var_glojure_DOT_core_conj_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_conj_BANG_)
	// var glojure.core/cons
	var_glojure_DOT_core_cons := lang.InternVarName(sym_glojure_DOT_core, sym_cons)
	// var glojure.core/constantly
	var_glojure_DOT_core_constantly := lang.InternVarName(sym_glojure_DOT_core, sym_constantly)
	// var glojure.core/contains?
	var_glojure_DOT_core_contains_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_contains_QMARK_)
	// var glojure.core/count
	var_glojure_DOT_core_count := lang.InternVarName(sym_glojure_DOT_core, sym_count)
	// var glojure.core/counted?
	var_glojure_DOT_core_counted_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_counted_QMARK_)
	// var glojure.core/create-ns
	var_glojure_DOT_core_create_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_create_DASH_ns)
	// var glojure.core/create-struct
	var_glojure_DOT_core_create_DASH_struct := lang.InternVarName(sym_glojure_DOT_core, sym_create_DASH_struct)
	// var glojure.core/cycle
	var_glojure_DOT_core_cycle := lang.InternVarName(sym_glojure_DOT_core, sym_cycle)
	// var glojure.core/data-reader-urls
	var_glojure_DOT_core_data_DASH_reader_DASH_urls := lang.InternVarName(sym_glojure_DOT_core, sym_data_DASH_reader_DASH_urls)
	// var glojure.core/data-reader-var
	var_glojure_DOT_core_data_DASH_reader_DASH_var := lang.InternVarName(sym_glojure_DOT_core, sym_data_DASH_reader_DASH_var)
	// var glojure.core/dec
	var_glojure_DOT_core_dec := lang.InternVarName(sym_glojure_DOT_core, sym_dec)
	// var glojure.core/dec'
	var_glojure_DOT_core_dec_TICK_ := lang.InternVarName(sym_glojure_DOT_core, sym_dec_TICK_)
	// var glojure.core/decimal?
	var_glojure_DOT_core_decimal_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_decimal_QMARK_)
	// var glojure.core/declare
	var_glojure_DOT_core_declare := lang.InternVarName(sym_glojure_DOT_core, sym_declare)
	// var glojure.core/dedupe
	var_glojure_DOT_core_dedupe := lang.InternVarName(sym_glojure_DOT_core, sym_dedupe)
	// var glojure.core/def-aset
	var_glojure_DOT_core_def_DASH_aset := lang.InternVarName(sym_glojure_DOT_core, sym_def_DASH_aset)
	// var glojure.core/definline
	var_glojure_DOT_core_definline := lang.InternVarName(sym_glojure_DOT_core, sym_definline)
	// var glojure.core/defmacro
	var_glojure_DOT_core_defmacro := lang.InternVarName(sym_glojure_DOT_core, sym_defmacro)
	// var glojure.core/defmethod
	var_glojure_DOT_core_defmethod := lang.InternVarName(sym_glojure_DOT_core, sym_defmethod)
	// var glojure.core/defmulti
	var_glojure_DOT_core_defmulti := lang.InternVarName(sym_glojure_DOT_core, sym_defmulti)
	// var glojure.core/defn
	var_glojure_DOT_core_defn := lang.InternVarName(sym_glojure_DOT_core, sym_defn)
	// var glojure.core/defn-
	var_glojure_DOT_core_defn_DASH_ := lang.InternVarName(sym_glojure_DOT_core, sym_defn_DASH_)
	// var glojure.core/defonce
	var_glojure_DOT_core_defonce := lang.InternVarName(sym_glojure_DOT_core, sym_defonce)
	// var glojure.core/defprotocol
	var_glojure_DOT_core_defprotocol := lang.InternVarName(sym_glojure_DOT_core, sym_defprotocol)
	// var glojure.core/defstruct
	var_glojure_DOT_core_defstruct := lang.InternVarName(sym_glojure_DOT_core, sym_defstruct)
	// var glojure.core/delay
	var_glojure_DOT_core_delay := lang.InternVarName(sym_glojure_DOT_core, sym_delay)
	// var glojure.core/delay?
	var_glojure_DOT_core_delay_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_delay_QMARK_)
	// var glojure.core/deliver
	var_glojure_DOT_core_deliver := lang.InternVarName(sym_glojure_DOT_core, sym_deliver)
	// var glojure.core/denominator
	var_glojure_DOT_core_denominator := lang.InternVarName(sym_glojure_DOT_core, sym_denominator)
	// var glojure.core/deref
	var_glojure_DOT_core_deref := lang.InternVarName(sym_glojure_DOT_core, sym_deref)
	// var glojure.core/deref-as-map
	var_glojure_DOT_core_deref_DASH_as_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_deref_DASH_as_DASH_map)
	// var glojure.core/deref-future
	var_glojure_DOT_core_deref_DASH_future := lang.InternVarName(sym_glojure_DOT_core, sym_deref_DASH_future)
	// var glojure.core/derive
	var_glojure_DOT_core_derive := lang.InternVarName(sym_glojure_DOT_core, sym_derive)
	// var glojure.core/descendants
	var_glojure_DOT_core_descendants := lang.InternVarName(sym_glojure_DOT_core, sym_descendants)
	// var glojure.core/destructure
	var_glojure_DOT_core_destructure := lang.InternVarName(sym_glojure_DOT_core, sym_destructure)
	// var glojure.core/disj
	var_glojure_DOT_core_disj := lang.InternVarName(sym_glojure_DOT_core, sym_disj)
	// var glojure.core/disj!
	var_glojure_DOT_core_disj_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_disj_BANG_)
	// var glojure.core/dissoc
	var_glojure_DOT_core_dissoc := lang.InternVarName(sym_glojure_DOT_core, sym_dissoc)
	// var glojure.core/dissoc!
	var_glojure_DOT_core_dissoc_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_dissoc_BANG_)
	// var glojure.core/distinct
	var_glojure_DOT_core_distinct := lang.InternVarName(sym_glojure_DOT_core, sym_distinct)
	// var glojure.core/distinct?
	var_glojure_DOT_core_distinct_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_distinct_QMARK_)
	// var glojure.core/doall
	var_glojure_DOT_core_doall := lang.InternVarName(sym_glojure_DOT_core, sym_doall)
	// var glojure.core/dorun
	var_glojure_DOT_core_dorun := lang.InternVarName(sym_glojure_DOT_core, sym_dorun)
	// var glojure.core/doseq
	var_glojure_DOT_core_doseq := lang.InternVarName(sym_glojure_DOT_core, sym_doseq)
	// var glojure.core/dosync
	var_glojure_DOT_core_dosync := lang.InternVarName(sym_glojure_DOT_core, sym_dosync)
	// var glojure.core/dotimes
	var_glojure_DOT_core_dotimes := lang.InternVarName(sym_glojure_DOT_core, sym_dotimes)
	// var glojure.core/doto
	var_glojure_DOT_core_doto := lang.InternVarName(sym_glojure_DOT_core, sym_doto)
	// var glojure.core/double
	var_glojure_DOT_core_double := lang.InternVarName(sym_glojure_DOT_core, sym_double)
	// var glojure.core/double-array
	var_glojure_DOT_core_double_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_double_DASH_array)
	// var glojure.core/double?
	var_glojure_DOT_core_double_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_double_QMARK_)
	// var glojure.core/doubles
	var_glojure_DOT_core_doubles := lang.InternVarName(sym_glojure_DOT_core, sym_doubles)
	// var glojure.core/drop
	var_glojure_DOT_core_drop := lang.InternVarName(sym_glojure_DOT_core, sym_drop)
	// var glojure.core/drop-last
	var_glojure_DOT_core_drop_DASH_last := lang.InternVarName(sym_glojure_DOT_core, sym_drop_DASH_last)
	// var glojure.core/drop-while
	var_glojure_DOT_core_drop_DASH_while := lang.InternVarName(sym_glojure_DOT_core, sym_drop_DASH_while)
	// var glojure.core/elide-top-frames
	var_glojure_DOT_core_elide_DASH_top_DASH_frames := lang.InternVarName(sym_glojure_DOT_core, sym_elide_DASH_top_DASH_frames)
	// var glojure.core/emit-extend-protocol
	var_glojure_DOT_core_emit_DASH_extend_DASH_protocol := lang.InternVarName(sym_glojure_DOT_core, sym_emit_DASH_extend_DASH_protocol)
	// var glojure.core/emit-extend-type
	var_glojure_DOT_core_emit_DASH_extend_DASH_type := lang.InternVarName(sym_glojure_DOT_core, sym_emit_DASH_extend_DASH_type)
	// var glojure.core/emit-hinted-impl
	var_glojure_DOT_core_emit_DASH_hinted_DASH_impl := lang.InternVarName(sym_glojure_DOT_core, sym_emit_DASH_hinted_DASH_impl)
	// var glojure.core/empty
	var_glojure_DOT_core_empty := lang.InternVarName(sym_glojure_DOT_core, sym_empty)
	// var glojure.core/empty?
	var_glojure_DOT_core_empty_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_empty_QMARK_)
	// var glojure.core/ensure
	var_glojure_DOT_core_ensure := lang.InternVarName(sym_glojure_DOT_core, sym_ensure)
	// var glojure.core/ensure-reduced
	var_glojure_DOT_core_ensure_DASH_reduced := lang.InternVarName(sym_glojure_DOT_core, sym_ensure_DASH_reduced)
	// var glojure.core/enumeration-seq
	var_glojure_DOT_core_enumeration_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_enumeration_DASH_seq)
	// var glojure.core/error-handler
	var_glojure_DOT_core_error_DASH_handler := lang.InternVarName(sym_glojure_DOT_core, sym_error_DASH_handler)
	// var glojure.core/error-mode
	var_glojure_DOT_core_error_DASH_mode := lang.InternVarName(sym_glojure_DOT_core, sym_error_DASH_mode)
	// var glojure.core/eval
	var_glojure_DOT_core_eval := lang.InternVarName(sym_glojure_DOT_core, sym_eval)
	// var glojure.core/even?
	var_glojure_DOT_core_even_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_even_QMARK_)
	// var glojure.core/every-pred
	var_glojure_DOT_core_every_DASH_pred := lang.InternVarName(sym_glojure_DOT_core, sym_every_DASH_pred)
	// var glojure.core/every?
	var_glojure_DOT_core_every_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_every_QMARK_)
	// var glojure.core/ex-cause
	var_glojure_DOT_core_ex_DASH_cause := lang.InternVarName(sym_glojure_DOT_core, sym_ex_DASH_cause)
	// var glojure.core/ex-data
	var_glojure_DOT_core_ex_DASH_data := lang.InternVarName(sym_glojure_DOT_core, sym_ex_DASH_data)
	// var glojure.core/ex-info
	var_glojure_DOT_core_ex_DASH_info := lang.InternVarName(sym_glojure_DOT_core, sym_ex_DASH_info)
	// var glojure.core/ex-message
	var_glojure_DOT_core_ex_DASH_message := lang.InternVarName(sym_glojure_DOT_core, sym_ex_DASH_message)
	// var glojure.core/extend
	var_glojure_DOT_core_extend := lang.InternVarName(sym_glojure_DOT_core, sym_extend)
	// var glojure.core/extend-protocol
	var_glojure_DOT_core_extend_DASH_protocol := lang.InternVarName(sym_glojure_DOT_core, sym_extend_DASH_protocol)
	// var glojure.core/extend-type
	var_glojure_DOT_core_extend_DASH_type := lang.InternVarName(sym_glojure_DOT_core, sym_extend_DASH_type)
	// var glojure.core/false?
	var_glojure_DOT_core_false_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_false_QMARK_)
	// var glojure.core/ffirst
	var_glojure_DOT_core_ffirst := lang.InternVarName(sym_glojure_DOT_core, sym_ffirst)
	// var glojure.core/file-seq
	var_glojure_DOT_core_file_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_file_DASH_seq)
	// var glojure.core/filter
	var_glojure_DOT_core_filter := lang.InternVarName(sym_glojure_DOT_core, sym_filter)
	// var glojure.core/filter-key
	var_glojure_DOT_core_filter_DASH_key := lang.InternVarName(sym_glojure_DOT_core, sym_filter_DASH_key)
	// var glojure.core/filterv
	var_glojure_DOT_core_filterv := lang.InternVarName(sym_glojure_DOT_core, sym_filterv)
	// var glojure.core/find
	var_glojure_DOT_core_find := lang.InternVarName(sym_glojure_DOT_core, sym_find)
	// var glojure.core/find-keyword
	var_glojure_DOT_core_find_DASH_keyword := lang.InternVarName(sym_glojure_DOT_core, sym_find_DASH_keyword)
	// var glojure.core/find-ns
	var_glojure_DOT_core_find_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_find_DASH_ns)
	// var glojure.core/find-var
	var_glojure_DOT_core_find_DASH_var := lang.InternVarName(sym_glojure_DOT_core, sym_find_DASH_var)
	// var glojure.core/first
	var_glojure_DOT_core_first := lang.InternVarName(sym_glojure_DOT_core, sym_first)
	// var glojure.core/fits-table?
	var_glojure_DOT_core_fits_DASH_table_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_fits_DASH_table_QMARK_)
	// var glojure.core/flatten
	var_glojure_DOT_core_flatten := lang.InternVarName(sym_glojure_DOT_core, sym_flatten)
	// var glojure.core/float
	var_glojure_DOT_core_float := lang.InternVarName(sym_glojure_DOT_core, sym_float)
	// var glojure.core/float-array
	var_glojure_DOT_core_float_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_float_DASH_array)
	// var glojure.core/float?
	var_glojure_DOT_core_float_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_float_QMARK_)
	// var glojure.core/floats
	var_glojure_DOT_core_floats := lang.InternVarName(sym_glojure_DOT_core, sym_floats)
	// var glojure.core/flush
	var_glojure_DOT_core_flush := lang.InternVarName(sym_glojure_DOT_core, sym_flush)
	// var glojure.core/fn
	var_glojure_DOT_core_fn := lang.InternVarName(sym_glojure_DOT_core, sym_fn)
	// var glojure.core/fn?
	var_glojure_DOT_core_fn_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_fn_QMARK_)
	// var glojure.core/fnext
	var_glojure_DOT_core_fnext := lang.InternVarName(sym_glojure_DOT_core, sym_fnext)
	// var glojure.core/fnil
	var_glojure_DOT_core_fnil := lang.InternVarName(sym_glojure_DOT_core, sym_fnil)
	// var glojure.core/for
	var_glojure_DOT_core_for := lang.InternVarName(sym_glojure_DOT_core, sym_for)
	// var glojure.core/force
	var_glojure_DOT_core_force := lang.InternVarName(sym_glojure_DOT_core, sym_force)
	// var glojure.core/format
	var_glojure_DOT_core_format := lang.InternVarName(sym_glojure_DOT_core, sym_format)
	// var glojure.core/frequencies
	var_glojure_DOT_core_frequencies := lang.InternVarName(sym_glojure_DOT_core, sym_frequencies)
	// var glojure.core/future
	var_glojure_DOT_core_future := lang.InternVarName(sym_glojure_DOT_core, sym_future)
	// var glojure.core/future-call
	var_glojure_DOT_core_future_DASH_call := lang.InternVarName(sym_glojure_DOT_core, sym_future_DASH_call)
	// var glojure.core/future-cancel
	var_glojure_DOT_core_future_DASH_cancel := lang.InternVarName(sym_glojure_DOT_core, sym_future_DASH_cancel)
	// var glojure.core/future-cancelled?
	var_glojure_DOT_core_future_DASH_cancelled_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_future_DASH_cancelled_QMARK_)
	// var glojure.core/future-done?
	var_glojure_DOT_core_future_DASH_done_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_future_DASH_done_QMARK_)
	// var glojure.core/future?
	var_glojure_DOT_core_future_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_future_QMARK_)
	// var glojure.core/gen-class
	var_glojure_DOT_core_gen_DASH_class := lang.InternVarName(sym_glojure_DOT_core, sym_gen_DASH_class)
	// var glojure.core/gensym
	var_glojure_DOT_core_gensym := lang.InternVarName(sym_glojure_DOT_core, sym_gensym)
	// var glojure.core/get
	var_glojure_DOT_core_get := lang.InternVarName(sym_glojure_DOT_core, sym_get)
	// var glojure.core/get-in
	var_glojure_DOT_core_get_DASH_in := lang.InternVarName(sym_glojure_DOT_core, sym_get_DASH_in)
	// var glojure.core/get-method
	var_glojure_DOT_core_get_DASH_method := lang.InternVarName(sym_glojure_DOT_core, sym_get_DASH_method)
	// var glojure.core/get-thread-bindings
	var_glojure_DOT_core_get_DASH_thread_DASH_bindings := lang.InternVarName(sym_glojure_DOT_core, sym_get_DASH_thread_DASH_bindings)
	// var glojure.core/get-validator
	var_glojure_DOT_core_get_DASH_validator := lang.InternVarName(sym_glojure_DOT_core, sym_get_DASH_validator)
	// var glojure.core/global-hierarchy
	var_glojure_DOT_core_global_DASH_hierarchy := lang.InternVarName(sym_glojure_DOT_core, sym_global_DASH_hierarchy)
	// var glojure.core/group-by
	var_glojure_DOT_core_group_DASH_by := lang.InternVarName(sym_glojure_DOT_core, sym_group_DASH_by)
	// var glojure.core/halt-when
	var_glojure_DOT_core_halt_DASH_when := lang.InternVarName(sym_glojure_DOT_core, sym_halt_DASH_when)
	// var glojure.core/hash
	var_glojure_DOT_core_hash := lang.InternVarName(sym_glojure_DOT_core, sym_hash)
	// var glojure.core/hash-map
	var_glojure_DOT_core_hash_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_hash_DASH_map)
	// var glojure.core/hash-ordered-coll
	var_glojure_DOT_core_hash_DASH_ordered_DASH_coll := lang.InternVarName(sym_glojure_DOT_core, sym_hash_DASH_ordered_DASH_coll)
	// var glojure.core/hash-set
	var_glojure_DOT_core_hash_DASH_set := lang.InternVarName(sym_glojure_DOT_core, sym_hash_DASH_set)
	// var glojure.core/hash-unordered-coll
	var_glojure_DOT_core_hash_DASH_unordered_DASH_coll := lang.InternVarName(sym_glojure_DOT_core, sym_hash_DASH_unordered_DASH_coll)
	// var glojure.core/ident?
	var_glojure_DOT_core_ident_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_ident_QMARK_)
	// var glojure.core/identical?
	var_glojure_DOT_core_identical_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_identical_QMARK_)
	// var glojure.core/identity
	var_glojure_DOT_core_identity := lang.InternVarName(sym_glojure_DOT_core, sym_identity)
	// var glojure.core/if-let
	var_glojure_DOT_core_if_DASH_let := lang.InternVarName(sym_glojure_DOT_core, sym_if_DASH_let)
	// var glojure.core/if-not
	var_glojure_DOT_core_if_DASH_not := lang.InternVarName(sym_glojure_DOT_core, sym_if_DASH_not)
	// var glojure.core/if-some
	var_glojure_DOT_core_if_DASH_some := lang.InternVarName(sym_glojure_DOT_core, sym_if_DASH_some)
	// var glojure.core/ifn?
	var_glojure_DOT_core_ifn_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_ifn_QMARK_)
	// var glojure.core/import
	var_glojure_DOT_core_import := lang.InternVarName(sym_glojure_DOT_core, sym_import)
	// var glojure.core/inc
	var_glojure_DOT_core_inc := lang.InternVarName(sym_glojure_DOT_core, sym_inc)
	// var glojure.core/inc'
	var_glojure_DOT_core_inc_TICK_ := lang.InternVarName(sym_glojure_DOT_core, sym_inc_TICK_)
	// var glojure.core/indexed?
	var_glojure_DOT_core_indexed_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_indexed_QMARK_)
	// var glojure.core/infinite?
	var_glojure_DOT_core_infinite_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_infinite_QMARK_)
	// var glojure.core/inst-ms
	var_glojure_DOT_core_inst_DASH_ms := lang.InternVarName(sym_glojure_DOT_core, sym_inst_DASH_ms)
	// var glojure.core/inst?
	var_glojure_DOT_core_inst_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_inst_QMARK_)
	// var glojure.core/instance?
	var_glojure_DOT_core_instance_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_instance_QMARK_)
	// var glojure.core/int
	var_glojure_DOT_core_int := lang.InternVarName(sym_glojure_DOT_core, sym_int)
	// var glojure.core/int-array
	var_glojure_DOT_core_int_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_int_DASH_array)
	// var glojure.core/int?
	var_glojure_DOT_core_int_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_int_QMARK_)
	// var glojure.core/integer?
	var_glojure_DOT_core_integer_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_integer_QMARK_)
	// var glojure.core/interleave
	var_glojure_DOT_core_interleave := lang.InternVarName(sym_glojure_DOT_core, sym_interleave)
	// var glojure.core/intern
	var_glojure_DOT_core_intern := lang.InternVarName(sym_glojure_DOT_core, sym_intern)
	// var glojure.core/interpose
	var_glojure_DOT_core_interpose := lang.InternVarName(sym_glojure_DOT_core, sym_interpose)
	// var glojure.core/into
	var_glojure_DOT_core_into := lang.InternVarName(sym_glojure_DOT_core, sym_into)
	// var glojure.core/into1
	var_glojure_DOT_core_into1 := lang.InternVarName(sym_glojure_DOT_core, sym_into1)
	// var glojure.core/into-array
	var_glojure_DOT_core_into_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_into_DASH_array)
	// var glojure.core/ints
	var_glojure_DOT_core_ints := lang.InternVarName(sym_glojure_DOT_core, sym_ints)
	// var glojure.core/io!
	var_glojure_DOT_core_io_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_io_BANG_)
	// var glojure.core/isa?
	var_glojure_DOT_core_isa_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_isa_QMARK_)
	// var glojure.core/iterate
	var_glojure_DOT_core_iterate := lang.InternVarName(sym_glojure_DOT_core, sym_iterate)
	// var glojure.core/iteration
	var_glojure_DOT_core_iteration := lang.InternVarName(sym_glojure_DOT_core, sym_iteration)
	// var glojure.core/iterator-seq
	var_glojure_DOT_core_iterator_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_iterator_DASH_seq)
	// var glojure.core/juxt
	var_glojure_DOT_core_juxt := lang.InternVarName(sym_glojure_DOT_core, sym_juxt)
	// var glojure.core/keep
	var_glojure_DOT_core_keep := lang.InternVarName(sym_glojure_DOT_core, sym_keep)
	// var glojure.core/keep-indexed
	var_glojure_DOT_core_keep_DASH_indexed := lang.InternVarName(sym_glojure_DOT_core, sym_keep_DASH_indexed)
	// var glojure.core/key
	var_glojure_DOT_core_key := lang.InternVarName(sym_glojure_DOT_core, sym_key)
	// var glojure.core/keys
	var_glojure_DOT_core_keys := lang.InternVarName(sym_glojure_DOT_core, sym_keys)
	// var glojure.core/keyword
	var_glojure_DOT_core_keyword := lang.InternVarName(sym_glojure_DOT_core, sym_keyword)
	// var glojure.core/keyword?
	var_glojure_DOT_core_keyword_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_keyword_QMARK_)
	// var glojure.core/last
	var_glojure_DOT_core_last := lang.InternVarName(sym_glojure_DOT_core, sym_last)
	// var glojure.core/lazy-cat
	var_glojure_DOT_core_lazy_DASH_cat := lang.InternVarName(sym_glojure_DOT_core, sym_lazy_DASH_cat)
	// var glojure.core/lazy-seq
	var_glojure_DOT_core_lazy_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_lazy_DASH_seq)
	// var glojure.core/let
	var_glojure_DOT_core_let := lang.InternVarName(sym_glojure_DOT_core, sym_let)
	// var glojure.core/letfn
	var_glojure_DOT_core_letfn := lang.InternVarName(sym_glojure_DOT_core, sym_letfn)
	// var glojure.core/libspec?
	var_glojure_DOT_core_libspec_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_libspec_QMARK_)
	// var glojure.core/lift-ns
	var_glojure_DOT_core_lift_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_lift_DASH_ns)
	// var glojure.core/line-seq
	var_glojure_DOT_core_line_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_line_DASH_seq)
	// var glojure.core/list
	var_glojure_DOT_core_list := lang.InternVarName(sym_glojure_DOT_core, sym_list)
	// var glojure.core/list?
	var_glojure_DOT_core_list_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_list_QMARK_)
	// var glojure.core/list*
	var_glojure_DOT_core_list_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym_list_STAR_)
	// var glojure.core/load
	var_glojure_DOT_core_load := lang.InternVarName(sym_glojure_DOT_core, sym_load)
	// var glojure.core/load-all
	var_glojure_DOT_core_load_DASH_all := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_all)
	// var glojure.core/load-data-reader-file
	var_glojure_DOT_core_load_DASH_data_DASH_reader_DASH_file := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_data_DASH_reader_DASH_file)
	// var glojure.core/load-data-readers
	var_glojure_DOT_core_load_DASH_data_DASH_readers := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_data_DASH_readers)
	// var glojure.core/load-file
	var_glojure_DOT_core_load_DASH_file := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_file)
	// var glojure.core/load-lib
	var_glojure_DOT_core_load_DASH_lib := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_lib)
	// var glojure.core/load-libs
	var_glojure_DOT_core_load_DASH_libs := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_libs)
	// var glojure.core/load-one
	var_glojure_DOT_core_load_DASH_one := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_one)
	// var glojure.core/load-reader
	var_glojure_DOT_core_load_DASH_reader := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_reader)
	// var glojure.core/load-string
	var_glojure_DOT_core_load_DASH_string := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_string)
	// var glojure.core/loaded-libs
	var_glojure_DOT_core_loaded_DASH_libs := lang.InternVarName(sym_glojure_DOT_core, sym_loaded_DASH_libs)
	// var glojure.core/locking
	var_glojure_DOT_core_locking := lang.InternVarName(sym_glojure_DOT_core, sym_locking)
	// var glojure.core/long
	var_glojure_DOT_core_long := lang.InternVarName(sym_glojure_DOT_core, sym_long)
	// var glojure.core/long-array
	var_glojure_DOT_core_long_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_long_DASH_array)
	// var glojure.core/longs
	var_glojure_DOT_core_longs := lang.InternVarName(sym_glojure_DOT_core, sym_longs)
	// var glojure.core/loop
	var_glojure_DOT_core_loop := lang.InternVarName(sym_glojure_DOT_core, sym_loop)
	// var glojure.core/macroexpand
	var_glojure_DOT_core_macroexpand := lang.InternVarName(sym_glojure_DOT_core, sym_macroexpand)
	// var glojure.core/macroexpand-1
	var_glojure_DOT_core_macroexpand_DASH_1 := lang.InternVarName(sym_glojure_DOT_core, sym_macroexpand_DASH_1)
	// var glojure.core/make-array
	var_glojure_DOT_core_make_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_make_DASH_array)
	// var glojure.core/make-hierarchy
	var_glojure_DOT_core_make_DASH_hierarchy := lang.InternVarName(sym_glojure_DOT_core, sym_make_DASH_hierarchy)
	// var glojure.core/map
	var_glojure_DOT_core_map := lang.InternVarName(sym_glojure_DOT_core, sym_map)
	// var glojure.core/map-entry?
	var_glojure_DOT_core_map_DASH_entry_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_map_DASH_entry_QMARK_)
	// var glojure.core/map-indexed
	var_glojure_DOT_core_map_DASH_indexed := lang.InternVarName(sym_glojure_DOT_core, sym_map_DASH_indexed)
	// var glojure.core/map?
	var_glojure_DOT_core_map_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_map_QMARK_)
	// var glojure.core/mapcat
	var_glojure_DOT_core_mapcat := lang.InternVarName(sym_glojure_DOT_core, sym_mapcat)
	// var glojure.core/mapv
	var_glojure_DOT_core_mapv := lang.InternVarName(sym_glojure_DOT_core, sym_mapv)
	// var glojure.core/max
	var_glojure_DOT_core_max := lang.InternVarName(sym_glojure_DOT_core, sym_max)
	// var glojure.core/max-key
	var_glojure_DOT_core_max_DASH_key := lang.InternVarName(sym_glojure_DOT_core, sym_max_DASH_key)
	// var glojure.core/max-mask-bits
	var_glojure_DOT_core_max_DASH_mask_DASH_bits := lang.InternVarName(sym_glojure_DOT_core, sym_max_DASH_mask_DASH_bits)
	// var glojure.core/max-switch-table-size
	var_glojure_DOT_core_max_DASH_switch_DASH_table_DASH_size := lang.InternVarName(sym_glojure_DOT_core, sym_max_DASH_switch_DASH_table_DASH_size)
	// var glojure.core/maybe-destructured
	var_glojure_DOT_core_maybe_DASH_destructured := lang.InternVarName(sym_glojure_DOT_core, sym_maybe_DASH_destructured)
	// var glojure.core/maybe-min-hash
	var_glojure_DOT_core_maybe_DASH_min_DASH_hash := lang.InternVarName(sym_glojure_DOT_core, sym_maybe_DASH_min_DASH_hash)
	// var glojure.core/memfn
	var_glojure_DOT_core_memfn := lang.InternVarName(sym_glojure_DOT_core, sym_memfn)
	// var glojure.core/memoize
	var_glojure_DOT_core_memoize := lang.InternVarName(sym_glojure_DOT_core, sym_memoize)
	// var glojure.core/merge
	var_glojure_DOT_core_merge := lang.InternVarName(sym_glojure_DOT_core, sym_merge)
	// var glojure.core/merge-hash-collisions
	var_glojure_DOT_core_merge_DASH_hash_DASH_collisions := lang.InternVarName(sym_glojure_DOT_core, sym_merge_DASH_hash_DASH_collisions)
	// var glojure.core/merge-with
	var_glojure_DOT_core_merge_DASH_with := lang.InternVarName(sym_glojure_DOT_core, sym_merge_DASH_with)
	// var glojure.core/meta
	var_glojure_DOT_core_meta := lang.InternVarName(sym_glojure_DOT_core, sym_meta)
	// var glojure.core/methods
	var_glojure_DOT_core_methods := lang.InternVarName(sym_glojure_DOT_core, sym_methods)
	// var glojure.core/min
	var_glojure_DOT_core_min := lang.InternVarName(sym_glojure_DOT_core, sym_min)
	// var glojure.core/min-key
	var_glojure_DOT_core_min_DASH_key := lang.InternVarName(sym_glojure_DOT_core, sym_min_DASH_key)
	// var glojure.core/mix-collection-hash
	var_glojure_DOT_core_mix_DASH_collection_DASH_hash := lang.InternVarName(sym_glojure_DOT_core, sym_mix_DASH_collection_DASH_hash)
	// var glojure.core/mk-bound-fn
	var_glojure_DOT_core_mk_DASH_bound_DASH_fn := lang.InternVarName(sym_glojure_DOT_core, sym_mk_DASH_bound_DASH_fn)
	// var glojure.core/mod
	var_glojure_DOT_core_mod := lang.InternVarName(sym_glojure_DOT_core, sym_mod)
	// var glojure.core/name
	var_glojure_DOT_core_name := lang.InternVarName(sym_glojure_DOT_core, sym_name)
	// var glojure.core/namespace
	var_glojure_DOT_core_namespace := lang.InternVarName(sym_glojure_DOT_core, sym_namespace)
	// var glojure.core/nary-inline
	var_glojure_DOT_core_nary_DASH_inline := lang.InternVarName(sym_glojure_DOT_core, sym_nary_DASH_inline)
	// var glojure.core/nat-int?
	var_glojure_DOT_core_nat_DASH_int_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_nat_DASH_int_QMARK_)
	// var glojure.core/neg-int?
	var_glojure_DOT_core_neg_DASH_int_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_neg_DASH_int_QMARK_)
	// var glojure.core/neg?
	var_glojure_DOT_core_neg_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_neg_QMARK_)
	// var glojure.core/newline
	var_glojure_DOT_core_newline := lang.InternVarName(sym_glojure_DOT_core, sym_newline)
	// var glojure.core/next
	var_glojure_DOT_core_next := lang.InternVarName(sym_glojure_DOT_core, sym_next)
	// var glojure.core/nfirst
	var_glojure_DOT_core_nfirst := lang.InternVarName(sym_glojure_DOT_core, sym_nfirst)
	// var glojure.core/nil?
	var_glojure_DOT_core_nil_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_nil_QMARK_)
	// var glojure.core/nnext
	var_glojure_DOT_core_nnext := lang.InternVarName(sym_glojure_DOT_core, sym_nnext)
	// var glojure.core/normalize-slurp-opts
	var_glojure_DOT_core_normalize_DASH_slurp_DASH_opts := lang.InternVarName(sym_glojure_DOT_core, sym_normalize_DASH_slurp_DASH_opts)
	// var glojure.core/not
	var_glojure_DOT_core_not := lang.InternVarName(sym_glojure_DOT_core, sym_not)
	// var glojure.core/not-any?
	var_glojure_DOT_core_not_DASH_any_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_not_DASH_any_QMARK_)
	// var glojure.core/not-empty
	var_glojure_DOT_core_not_DASH_empty := lang.InternVarName(sym_glojure_DOT_core, sym_not_DASH_empty)
	// var glojure.core/not-every?
	var_glojure_DOT_core_not_DASH_every_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_not_DASH_every_QMARK_)
	// var glojure.core/not=
	var_glojure_DOT_core_not_EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym_not_EQ_)
	// var glojure.core/ns
	var_glojure_DOT_core_ns := lang.InternVarName(sym_glojure_DOT_core, sym_ns)
	// var glojure.core/ns-aliases
	var_glojure_DOT_core_ns_DASH_aliases := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_aliases)
	// var glojure.core/ns-imports
	var_glojure_DOT_core_ns_DASH_imports := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_imports)
	// var glojure.core/ns-interns
	var_glojure_DOT_core_ns_DASH_interns := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_interns)
	// var glojure.core/ns-map
	var_glojure_DOT_core_ns_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_map)
	// var glojure.core/ns-name
	var_glojure_DOT_core_ns_DASH_name := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_name)
	// var glojure.core/ns-publics
	var_glojure_DOT_core_ns_DASH_publics := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_publics)
	// var glojure.core/ns-refers
	var_glojure_DOT_core_ns_DASH_refers := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_refers)
	// var glojure.core/ns-resolve
	var_glojure_DOT_core_ns_DASH_resolve := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_resolve)
	// var glojure.core/ns-unalias
	var_glojure_DOT_core_ns_DASH_unalias := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_unalias)
	// var glojure.core/ns-unmap
	var_glojure_DOT_core_ns_DASH_unmap := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_unmap)
	// var glojure.core/nth
	var_glojure_DOT_core_nth := lang.InternVarName(sym_glojure_DOT_core, sym_nth)
	// var glojure.core/nthnext
	var_glojure_DOT_core_nthnext := lang.InternVarName(sym_glojure_DOT_core, sym_nthnext)
	// var glojure.core/nthrest
	var_glojure_DOT_core_nthrest := lang.InternVarName(sym_glojure_DOT_core, sym_nthrest)
	// var glojure.core/num
	var_glojure_DOT_core_num := lang.InternVarName(sym_glojure_DOT_core, sym_num)
	// var glojure.core/number?
	var_glojure_DOT_core_number_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_number_QMARK_)
	// var glojure.core/numerator
	var_glojure_DOT_core_numerator := lang.InternVarName(sym_glojure_DOT_core, sym_numerator)
	// var glojure.core/object-array
	var_glojure_DOT_core_object_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_object_DASH_array)
	// var glojure.core/odd?
	var_glojure_DOT_core_odd_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_odd_QMARK_)
	// var glojure.core/or
	var_glojure_DOT_core_or := lang.InternVarName(sym_glojure_DOT_core, sym_or)
	// var glojure.core/parents
	var_glojure_DOT_core_parents := lang.InternVarName(sym_glojure_DOT_core, sym_parents)
	// var glojure.core/parse-boolean
	var_glojure_DOT_core_parse_DASH_boolean := lang.InternVarName(sym_glojure_DOT_core, sym_parse_DASH_boolean)
	// var glojure.core/parse-double
	var_glojure_DOT_core_parse_DASH_double := lang.InternVarName(sym_glojure_DOT_core, sym_parse_DASH_double)
	// var glojure.core/parse-impls
	var_glojure_DOT_core_parse_DASH_impls := lang.InternVarName(sym_glojure_DOT_core, sym_parse_DASH_impls)
	// var glojure.core/parse-long
	var_glojure_DOT_core_parse_DASH_long := lang.InternVarName(sym_glojure_DOT_core, sym_parse_DASH_long)
	// var glojure.core/parse-uuid
	var_glojure_DOT_core_parse_DASH_uuid := lang.InternVarName(sym_glojure_DOT_core, sym_parse_DASH_uuid)
	// var glojure.core/parsing-err
	var_glojure_DOT_core_parsing_DASH_err := lang.InternVarName(sym_glojure_DOT_core, sym_parsing_DASH_err)
	// var glojure.core/partial
	var_glojure_DOT_core_partial := lang.InternVarName(sym_glojure_DOT_core, sym_partial)
	// var glojure.core/partition
	var_glojure_DOT_core_partition := lang.InternVarName(sym_glojure_DOT_core, sym_partition)
	// var glojure.core/partition-all
	var_glojure_DOT_core_partition_DASH_all := lang.InternVarName(sym_glojure_DOT_core, sym_partition_DASH_all)
	// var glojure.core/partition-by
	var_glojure_DOT_core_partition_DASH_by := lang.InternVarName(sym_glojure_DOT_core, sym_partition_DASH_by)
	// var glojure.core/partitionv
	var_glojure_DOT_core_partitionv := lang.InternVarName(sym_glojure_DOT_core, sym_partitionv)
	// var glojure.core/partitionv-all
	var_glojure_DOT_core_partitionv_DASH_all := lang.InternVarName(sym_glojure_DOT_core, sym_partitionv_DASH_all)
	// var glojure.core/pcalls
	var_glojure_DOT_core_pcalls := lang.InternVarName(sym_glojure_DOT_core, sym_pcalls)
	// var glojure.core/peek
	var_glojure_DOT_core_peek := lang.InternVarName(sym_glojure_DOT_core, sym_peek)
	// var glojure.core/persistent!
	var_glojure_DOT_core_persistent_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_persistent_BANG_)
	// var glojure.core/pmap
	var_glojure_DOT_core_pmap := lang.InternVarName(sym_glojure_DOT_core, sym_pmap)
	// var glojure.core/pop
	var_glojure_DOT_core_pop := lang.InternVarName(sym_glojure_DOT_core, sym_pop)
	// var glojure.core/pop!
	var_glojure_DOT_core_pop_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_pop_BANG_)
	// var glojure.core/pop-thread-bindings
	var_glojure_DOT_core_pop_DASH_thread_DASH_bindings := lang.InternVarName(sym_glojure_DOT_core, sym_pop_DASH_thread_DASH_bindings)
	// var glojure.core/pos-int?
	var_glojure_DOT_core_pos_DASH_int_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_pos_DASH_int_QMARK_)
	// var glojure.core/pos?
	var_glojure_DOT_core_pos_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_pos_QMARK_)
	// var glojure.core/pr
	var_glojure_DOT_core_pr := lang.InternVarName(sym_glojure_DOT_core, sym_pr)
	// var glojure.core/pr-on
	var_glojure_DOT_core_pr_DASH_on := lang.InternVarName(sym_glojure_DOT_core, sym_pr_DASH_on)
	// var glojure.core/pr-str
	var_glojure_DOT_core_pr_DASH_str := lang.InternVarName(sym_glojure_DOT_core, sym_pr_DASH_str)
	// var glojure.core/prefer-method
	var_glojure_DOT_core_prefer_DASH_method := lang.InternVarName(sym_glojure_DOT_core, sym_prefer_DASH_method)
	// var glojure.core/prefers
	var_glojure_DOT_core_prefers := lang.InternVarName(sym_glojure_DOT_core, sym_prefers)
	// var glojure.core/prep-hashes
	var_glojure_DOT_core_prep_DASH_hashes := lang.InternVarName(sym_glojure_DOT_core, sym_prep_DASH_hashes)
	// var glojure.core/prep-ints
	var_glojure_DOT_core_prep_DASH_ints := lang.InternVarName(sym_glojure_DOT_core, sym_prep_DASH_ints)
	// var glojure.core/prependss
	var_glojure_DOT_core_prependss := lang.InternVarName(sym_glojure_DOT_core, sym_prependss)
	// var glojure.core/preserving-reduced
	var_glojure_DOT_core_preserving_DASH_reduced := lang.InternVarName(sym_glojure_DOT_core, sym_preserving_DASH_reduced)
	// var glojure.core/print
	var_glojure_DOT_core_print := lang.InternVarName(sym_glojure_DOT_core, sym_print)
	// var glojure.core/print-ctor
	var_glojure_DOT_core_print_DASH_ctor := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_ctor)
	// var glojure.core/print-dup
	var_glojure_DOT_core_print_DASH_dup := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_dup)
	// var glojure.core/print-initialized
	var_glojure_DOT_core_print_DASH_initialized := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_initialized)
	// var glojure.core/print-map
	var_glojure_DOT_core_print_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_map)
	// var glojure.core/print-meta
	var_glojure_DOT_core_print_DASH_meta := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_meta)
	// var glojure.core/print-method
	var_glojure_DOT_core_print_DASH_method := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_method)
	// var glojure.core/print-object
	var_glojure_DOT_core_print_DASH_object := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_object)
	// var glojure.core/print-prefix-map
	var_glojure_DOT_core_print_DASH_prefix_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_prefix_DASH_map)
	// var glojure.core/print-sequential
	var_glojure_DOT_core_print_DASH_sequential := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_sequential)
	// var glojure.core/print-simple
	var_glojure_DOT_core_print_DASH_simple := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_simple)
	// var glojure.core/print-str
	var_glojure_DOT_core_print_DASH_str := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_str)
	// var glojure.core/print-tagged-object
	var_glojure_DOT_core_print_DASH_tagged_DASH_object := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_tagged_DASH_object)
	// var glojure.core/print-throwable
	var_glojure_DOT_core_print_DASH_throwable := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_throwable)
	// var glojure.core/printf
	var_glojure_DOT_core_printf := lang.InternVarName(sym_glojure_DOT_core, sym_printf)
	// var glojure.core/println
	var_glojure_DOT_core_println := lang.InternVarName(sym_glojure_DOT_core, sym_println)
	// var glojure.core/println-str
	var_glojure_DOT_core_println_DASH_str := lang.InternVarName(sym_glojure_DOT_core, sym_println_DASH_str)
	// var glojure.core/prn
	var_glojure_DOT_core_prn := lang.InternVarName(sym_glojure_DOT_core, sym_prn)
	// var glojure.core/prn-str
	var_glojure_DOT_core_prn_DASH_str := lang.InternVarName(sym_glojure_DOT_core, sym_prn_DASH_str)
	// var glojure.core/promise
	var_glojure_DOT_core_promise := lang.InternVarName(sym_glojure_DOT_core, sym_promise)
	// var glojure.core/protocol?
	var_glojure_DOT_core_protocol_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_protocol_QMARK_)
	// var glojure.core/push-thread-bindings
	var_glojure_DOT_core_push_DASH_thread_DASH_bindings := lang.InternVarName(sym_glojure_DOT_core, sym_push_DASH_thread_DASH_bindings)
	// var glojure.core/pvalues
	var_glojure_DOT_core_pvalues := lang.InternVarName(sym_glojure_DOT_core, sym_pvalues)
	// var glojure.core/qualified-ident?
	var_glojure_DOT_core_qualified_DASH_ident_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_qualified_DASH_ident_QMARK_)
	// var glojure.core/qualified-keyword?
	var_glojure_DOT_core_qualified_DASH_keyword_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_qualified_DASH_keyword_QMARK_)
	// var glojure.core/qualified-symbol?
	var_glojure_DOT_core_qualified_DASH_symbol_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_qualified_DASH_symbol_QMARK_)
	// var glojure.core/quot
	var_glojure_DOT_core_quot := lang.InternVarName(sym_glojure_DOT_core, sym_quot)
	// var glojure.core/rand
	var_glojure_DOT_core_rand := lang.InternVarName(sym_glojure_DOT_core, sym_rand)
	// var glojure.core/rand-int
	var_glojure_DOT_core_rand_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_rand_DASH_int)
	// var glojure.core/rand-nth
	var_glojure_DOT_core_rand_DASH_nth := lang.InternVarName(sym_glojure_DOT_core, sym_rand_DASH_nth)
	// var glojure.core/random-sample
	var_glojure_DOT_core_random_DASH_sample := lang.InternVarName(sym_glojure_DOT_core, sym_random_DASH_sample)
	// var glojure.core/random-uuid
	var_glojure_DOT_core_random_DASH_uuid := lang.InternVarName(sym_glojure_DOT_core, sym_random_DASH_uuid)
	// var glojure.core/range
	var_glojure_DOT_core_range := lang.InternVarName(sym_glojure_DOT_core, sym_range)
	// var glojure.core/ratio?
	var_glojure_DOT_core_ratio_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_ratio_QMARK_)
	// var glojure.core/rational?
	var_glojure_DOT_core_rational_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_rational_QMARK_)
	// var glojure.core/rationalize
	var_glojure_DOT_core_rationalize := lang.InternVarName(sym_glojure_DOT_core, sym_rationalize)
	// var glojure.core/re-find
	var_glojure_DOT_core_re_DASH_find := lang.InternVarName(sym_glojure_DOT_core, sym_re_DASH_find)
	// var glojure.core/re-groups
	var_glojure_DOT_core_re_DASH_groups := lang.InternVarName(sym_glojure_DOT_core, sym_re_DASH_groups)
	// var glojure.core/re-matcher
	var_glojure_DOT_core_re_DASH_matcher := lang.InternVarName(sym_glojure_DOT_core, sym_re_DASH_matcher)
	// var glojure.core/re-matches
	var_glojure_DOT_core_re_DASH_matches := lang.InternVarName(sym_glojure_DOT_core, sym_re_DASH_matches)
	// var glojure.core/re-pattern
	var_glojure_DOT_core_re_DASH_pattern := lang.InternVarName(sym_glojure_DOT_core, sym_re_DASH_pattern)
	// var glojure.core/re-seq
	var_glojure_DOT_core_re_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_re_DASH_seq)
	// var glojure.core/read
	var_glojure_DOT_core_read := lang.InternVarName(sym_glojure_DOT_core, sym_read)
	// var glojure.core/read-line
	var_glojure_DOT_core_read_DASH_line := lang.InternVarName(sym_glojure_DOT_core, sym_read_DASH_line)
	// var glojure.core/read-string
	var_glojure_DOT_core_read_DASH_string := lang.InternVarName(sym_glojure_DOT_core, sym_read_DASH_string)
	// var glojure.core/read+string
	var_glojure_DOT_core_read_PLUS_string := lang.InternVarName(sym_glojure_DOT_core, sym_read_PLUS_string)
	// var glojure.core/reader-conditional
	var_glojure_DOT_core_reader_DASH_conditional := lang.InternVarName(sym_glojure_DOT_core, sym_reader_DASH_conditional)
	// var glojure.core/reader-conditional?
	var_glojure_DOT_core_reader_DASH_conditional_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_reader_DASH_conditional_QMARK_)
	// var glojure.core/realized?
	var_glojure_DOT_core_realized_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_realized_QMARK_)
	// var glojure.core/reduce
	var_glojure_DOT_core_reduce := lang.InternVarName(sym_glojure_DOT_core, sym_reduce)
	// var glojure.core/reduce1
	var_glojure_DOT_core_reduce1 := lang.InternVarName(sym_glojure_DOT_core, sym_reduce1)
	// var glojure.core/reduce-kv
	var_glojure_DOT_core_reduce_DASH_kv := lang.InternVarName(sym_glojure_DOT_core, sym_reduce_DASH_kv)
	// var glojure.core/reduced
	var_glojure_DOT_core_reduced := lang.InternVarName(sym_glojure_DOT_core, sym_reduced)
	// var glojure.core/reduced?
	var_glojure_DOT_core_reduced_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_reduced_QMARK_)
	// var glojure.core/reductions
	var_glojure_DOT_core_reductions := lang.InternVarName(sym_glojure_DOT_core, sym_reductions)
	// var glojure.core/ref
	var_glojure_DOT_core_ref := lang.InternVarName(sym_glojure_DOT_core, sym_ref)
	// var glojure.core/ref-history-count
	var_glojure_DOT_core_ref_DASH_history_DASH_count := lang.InternVarName(sym_glojure_DOT_core, sym_ref_DASH_history_DASH_count)
	// var glojure.core/ref-max-history
	var_glojure_DOT_core_ref_DASH_max_DASH_history := lang.InternVarName(sym_glojure_DOT_core, sym_ref_DASH_max_DASH_history)
	// var glojure.core/ref-min-history
	var_glojure_DOT_core_ref_DASH_min_DASH_history := lang.InternVarName(sym_glojure_DOT_core, sym_ref_DASH_min_DASH_history)
	// var glojure.core/ref-set
	var_glojure_DOT_core_ref_DASH_set := lang.InternVarName(sym_glojure_DOT_core, sym_ref_DASH_set)
	// var glojure.core/refer
	var_glojure_DOT_core_refer := lang.InternVarName(sym_glojure_DOT_core, sym_refer)
	// var glojure.core/refer-glojure
	var_glojure_DOT_core_refer_DASH_glojure := lang.InternVarName(sym_glojure_DOT_core, sym_refer_DASH_glojure)
	// var glojure.core/release-pending-sends
	var_glojure_DOT_core_release_DASH_pending_DASH_sends := lang.InternVarName(sym_glojure_DOT_core, sym_release_DASH_pending_DASH_sends)
	// var glojure.core/rem
	var_glojure_DOT_core_rem := lang.InternVarName(sym_glojure_DOT_core, sym_rem)
	// var glojure.core/remove
	var_glojure_DOT_core_remove := lang.InternVarName(sym_glojure_DOT_core, sym_remove)
	// var glojure.core/remove-all-methods
	var_glojure_DOT_core_remove_DASH_all_DASH_methods := lang.InternVarName(sym_glojure_DOT_core, sym_remove_DASH_all_DASH_methods)
	// var glojure.core/remove-method
	var_glojure_DOT_core_remove_DASH_method := lang.InternVarName(sym_glojure_DOT_core, sym_remove_DASH_method)
	// var glojure.core/remove-ns
	var_glojure_DOT_core_remove_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_remove_DASH_ns)
	// var glojure.core/remove-tap
	var_glojure_DOT_core_remove_DASH_tap := lang.InternVarName(sym_glojure_DOT_core, sym_remove_DASH_tap)
	// var glojure.core/remove-watch
	var_glojure_DOT_core_remove_DASH_watch := lang.InternVarName(sym_glojure_DOT_core, sym_remove_DASH_watch)
	// var glojure.core/repeat
	var_glojure_DOT_core_repeat := lang.InternVarName(sym_glojure_DOT_core, sym_repeat)
	// var glojure.core/repeatedly
	var_glojure_DOT_core_repeatedly := lang.InternVarName(sym_glojure_DOT_core, sym_repeatedly)
	// var glojure.core/replace
	var_glojure_DOT_core_replace := lang.InternVarName(sym_glojure_DOT_core, sym_replace)
	// var glojure.core/replicate
	var_glojure_DOT_core_replicate := lang.InternVarName(sym_glojure_DOT_core, sym_replicate)
	// var glojure.core/require
	var_glojure_DOT_core_require := lang.InternVarName(sym_glojure_DOT_core, sym_require)
	// var glojure.core/requiring-resolve
	var_glojure_DOT_core_requiring_DASH_resolve := lang.InternVarName(sym_glojure_DOT_core, sym_requiring_DASH_resolve)
	// var glojure.core/reset!
	var_glojure_DOT_core_reset_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_reset_BANG_)
	// var glojure.core/reset-meta!
	var_glojure_DOT_core_reset_DASH_meta_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_reset_DASH_meta_BANG_)
	// var glojure.core/reset-vals!
	var_glojure_DOT_core_reset_DASH_vals_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_reset_DASH_vals_BANG_)
	// var glojure.core/resolve
	var_glojure_DOT_core_resolve := lang.InternVarName(sym_glojure_DOT_core, sym_resolve)
	// var glojure.core/rest
	var_glojure_DOT_core_rest := lang.InternVarName(sym_glojure_DOT_core, sym_rest)
	// var glojure.core/restart-agent
	var_glojure_DOT_core_restart_DASH_agent := lang.InternVarName(sym_glojure_DOT_core, sym_restart_DASH_agent)
	// var glojure.core/resultset-seq
	var_glojure_DOT_core_resultset_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_resultset_DASH_seq)
	// var glojure.core/reverse
	var_glojure_DOT_core_reverse := lang.InternVarName(sym_glojure_DOT_core, sym_reverse)
	// var glojure.core/reversible?
	var_glojure_DOT_core_reversible_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_reversible_QMARK_)
	// var glojure.core/root-directory
	var_glojure_DOT_core_root_DASH_directory := lang.InternVarName(sym_glojure_DOT_core, sym_root_DASH_directory)
	// var glojure.core/root-resource
	var_glojure_DOT_core_root_DASH_resource := lang.InternVarName(sym_glojure_DOT_core, sym_root_DASH_resource)
	// var glojure.core/rseq
	var_glojure_DOT_core_rseq := lang.InternVarName(sym_glojure_DOT_core, sym_rseq)
	// var glojure.core/rsubseq
	var_glojure_DOT_core_rsubseq := lang.InternVarName(sym_glojure_DOT_core, sym_rsubseq)
	// var glojure.core/run!
	var_glojure_DOT_core_run_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_run_BANG_)
	// var glojure.core/second
	var_glojure_DOT_core_second := lang.InternVarName(sym_glojure_DOT_core, sym_second)
	// var glojure.core/select-keys
	var_glojure_DOT_core_select_DASH_keys := lang.InternVarName(sym_glojure_DOT_core, sym_select_DASH_keys)
	// var glojure.core/send
	var_glojure_DOT_core_send := lang.InternVarName(sym_glojure_DOT_core, sym_send)
	// var glojure.core/send-off
	var_glojure_DOT_core_send_DASH_off := lang.InternVarName(sym_glojure_DOT_core, sym_send_DASH_off)
	// var glojure.core/send-via
	var_glojure_DOT_core_send_DASH_via := lang.InternVarName(sym_glojure_DOT_core, sym_send_DASH_via)
	// var glojure.core/seq
	var_glojure_DOT_core_seq := lang.InternVarName(sym_glojure_DOT_core, sym_seq)
	// var glojure.core/seq-to-map-for-destructuring
	var_glojure_DOT_core_seq_DASH_to_DASH_map_DASH_for_DASH_destructuring := lang.InternVarName(sym_glojure_DOT_core, sym_seq_DASH_to_DASH_map_DASH_for_DASH_destructuring)
	// var glojure.core/seq?
	var_glojure_DOT_core_seq_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_seq_QMARK_)
	// var glojure.core/seqable?
	var_glojure_DOT_core_seqable_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_seqable_QMARK_)
	// var glojure.core/seque
	var_glojure_DOT_core_seque := lang.InternVarName(sym_glojure_DOT_core, sym_seque)
	// var glojure.core/sequence
	var_glojure_DOT_core_sequence := lang.InternVarName(sym_glojure_DOT_core, sym_sequence)
	// var glojure.core/sequential?
	var_glojure_DOT_core_sequential_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_sequential_QMARK_)
	// var glojure.core/serialized-require
	var_glojure_DOT_core_serialized_DASH_require := lang.InternVarName(sym_glojure_DOT_core, sym_serialized_DASH_require)
	// var glojure.core/set
	var_glojure_DOT_core_set := lang.InternVarName(sym_glojure_DOT_core, sym_set)
	// var glojure.core/set-agent-send-executor!
	var_glojure_DOT_core_set_DASH_agent_DASH_send_DASH_executor_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_set_DASH_agent_DASH_send_DASH_executor_BANG_)
	// var glojure.core/set-agent-send-off-executor!
	var_glojure_DOT_core_set_DASH_agent_DASH_send_DASH_off_DASH_executor_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_set_DASH_agent_DASH_send_DASH_off_DASH_executor_BANG_)
	// var glojure.core/set-error-handler!
	var_glojure_DOT_core_set_DASH_error_DASH_handler_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_set_DASH_error_DASH_handler_BANG_)
	// var glojure.core/set-error-mode!
	var_glojure_DOT_core_set_DASH_error_DASH_mode_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_set_DASH_error_DASH_mode_BANG_)
	// var glojure.core/set-validator!
	var_glojure_DOT_core_set_DASH_validator_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_set_DASH_validator_BANG_)
	// var glojure.core/set?
	var_glojure_DOT_core_set_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_set_QMARK_)
	// var glojure.core/setup-reference
	var_glojure_DOT_core_setup_DASH_reference := lang.InternVarName(sym_glojure_DOT_core, sym_setup_DASH_reference)
	// var glojure.core/shift-mask
	var_glojure_DOT_core_shift_DASH_mask := lang.InternVarName(sym_glojure_DOT_core, sym_shift_DASH_mask)
	// var glojure.core/short
	var_glojure_DOT_core_short := lang.InternVarName(sym_glojure_DOT_core, sym_short)
	// var glojure.core/short-array
	var_glojure_DOT_core_short_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_short_DASH_array)
	// var glojure.core/shorts
	var_glojure_DOT_core_shorts := lang.InternVarName(sym_glojure_DOT_core, sym_shorts)
	// var glojure.core/shuffle
	var_glojure_DOT_core_shuffle := lang.InternVarName(sym_glojure_DOT_core, sym_shuffle)
	// var glojure.core/shutdown-agents
	var_glojure_DOT_core_shutdown_DASH_agents := lang.InternVarName(sym_glojure_DOT_core, sym_shutdown_DASH_agents)
	// var glojure.core/sigs
	var_glojure_DOT_core_sigs := lang.InternVarName(sym_glojure_DOT_core, sym_sigs)
	// var glojure.core/simple-ident?
	var_glojure_DOT_core_simple_DASH_ident_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_simple_DASH_ident_QMARK_)
	// var glojure.core/simple-keyword?
	var_glojure_DOT_core_simple_DASH_keyword_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_simple_DASH_keyword_QMARK_)
	// var glojure.core/simple-symbol?
	var_glojure_DOT_core_simple_DASH_symbol_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_simple_DASH_symbol_QMARK_)
	// var glojure.core/slurp
	var_glojure_DOT_core_slurp := lang.InternVarName(sym_glojure_DOT_core, sym_slurp)
	// var glojure.core/some
	var_glojure_DOT_core_some := lang.InternVarName(sym_glojure_DOT_core, sym_some)
	// var glojure.core/some->
	var_glojure_DOT_core_some_DASH__GT_ := lang.InternVarName(sym_glojure_DOT_core, sym_some_DASH__GT_)
	// var glojure.core/some->>
	var_glojure_DOT_core_some_DASH__GT__GT_ := lang.InternVarName(sym_glojure_DOT_core, sym_some_DASH__GT__GT_)
	// var glojure.core/some-fn
	var_glojure_DOT_core_some_DASH_fn := lang.InternVarName(sym_glojure_DOT_core, sym_some_DASH_fn)
	// var glojure.core/some?
	var_glojure_DOT_core_some_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_some_QMARK_)
	// var glojure.core/sort
	var_glojure_DOT_core_sort := lang.InternVarName(sym_glojure_DOT_core, sym_sort)
	// var glojure.core/sort-by
	var_glojure_DOT_core_sort_DASH_by := lang.InternVarName(sym_glojure_DOT_core, sym_sort_DASH_by)
	// var glojure.core/sorted-map
	var_glojure_DOT_core_sorted_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_sorted_DASH_map)
	// var glojure.core/sorted-map-by
	var_glojure_DOT_core_sorted_DASH_map_DASH_by := lang.InternVarName(sym_glojure_DOT_core, sym_sorted_DASH_map_DASH_by)
	// var glojure.core/sorted-set
	var_glojure_DOT_core_sorted_DASH_set := lang.InternVarName(sym_glojure_DOT_core, sym_sorted_DASH_set)
	// var glojure.core/sorted-set-by
	var_glojure_DOT_core_sorted_DASH_set_DASH_by := lang.InternVarName(sym_glojure_DOT_core, sym_sorted_DASH_set_DASH_by)
	// var glojure.core/sorted?
	var_glojure_DOT_core_sorted_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_sorted_QMARK_)
	// var glojure.core/special-symbol?
	var_glojure_DOT_core_special_DASH_symbol_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_special_DASH_symbol_QMARK_)
	// var glojure.core/spit
	var_glojure_DOT_core_spit := lang.InternVarName(sym_glojure_DOT_core, sym_spit)
	// var glojure.core/split-at
	var_glojure_DOT_core_split_DASH_at := lang.InternVarName(sym_glojure_DOT_core, sym_split_DASH_at)
	// var glojure.core/split-with
	var_glojure_DOT_core_split_DASH_with := lang.InternVarName(sym_glojure_DOT_core, sym_split_DASH_with)
	// var glojure.core/splitv-at
	var_glojure_DOT_core_splitv_DASH_at := lang.InternVarName(sym_glojure_DOT_core, sym_splitv_DASH_at)
	// var glojure.core/spread
	var_glojure_DOT_core_spread := lang.InternVarName(sym_glojure_DOT_core, sym_spread)
	// var glojure.core/str
	var_glojure_DOT_core_str := lang.InternVarName(sym_glojure_DOT_core, sym_str)
	// var glojure.core/stream-into!
	var_glojure_DOT_core_stream_DASH_into_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_stream_DASH_into_BANG_)
	// var glojure.core/stream-reduce!
	var_glojure_DOT_core_stream_DASH_reduce_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_stream_DASH_reduce_BANG_)
	// var glojure.core/stream-seq!
	var_glojure_DOT_core_stream_DASH_seq_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_stream_DASH_seq_BANG_)
	// var glojure.core/stream-transduce!
	var_glojure_DOT_core_stream_DASH_transduce_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_stream_DASH_transduce_BANG_)
	// var glojure.core/string?
	var_glojure_DOT_core_string_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_string_QMARK_)
	// var glojure.core/strip-ns
	var_glojure_DOT_core_strip_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_strip_DASH_ns)
	// var glojure.core/struct
	var_glojure_DOT_core_struct := lang.InternVarName(sym_glojure_DOT_core, sym_struct)
	// var glojure.core/struct-map
	var_glojure_DOT_core_struct_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_struct_DASH_map)
	// var glojure.core/subs
	var_glojure_DOT_core_subs := lang.InternVarName(sym_glojure_DOT_core, sym_subs)
	// var glojure.core/subseq
	var_glojure_DOT_core_subseq := lang.InternVarName(sym_glojure_DOT_core, sym_subseq)
	// var glojure.core/subvec
	var_glojure_DOT_core_subvec := lang.InternVarName(sym_glojure_DOT_core, sym_subvec)
	// var glojure.core/supers
	var_glojure_DOT_core_supers := lang.InternVarName(sym_glojure_DOT_core, sym_supers)
	// var glojure.core/swap!
	var_glojure_DOT_core_swap_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_swap_BANG_)
	// var glojure.core/swap-vals!
	var_glojure_DOT_core_swap_DASH_vals_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_swap_DASH_vals_BANG_)
	// var glojure.core/symbol
	var_glojure_DOT_core_symbol := lang.InternVarName(sym_glojure_DOT_core, sym_symbol)
	// var glojure.core/symbol?
	var_glojure_DOT_core_symbol_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_symbol_QMARK_)
	// var glojure.core/sync
	var_glojure_DOT_core_sync := lang.InternVarName(sym_glojure_DOT_core, sym_sync)
	// var glojure.core/system-newline
	var_glojure_DOT_core_system_DASH_newline := lang.InternVarName(sym_glojure_DOT_core, sym_system_DASH_newline)
	// var glojure.core/tagged-literal
	var_glojure_DOT_core_tagged_DASH_literal := lang.InternVarName(sym_glojure_DOT_core, sym_tagged_DASH_literal)
	// var glojure.core/tagged-literal?
	var_glojure_DOT_core_tagged_DASH_literal_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_tagged_DASH_literal_QMARK_)
	// var glojure.core/take
	var_glojure_DOT_core_take := lang.InternVarName(sym_glojure_DOT_core, sym_take)
	// var glojure.core/take-last
	var_glojure_DOT_core_take_DASH_last := lang.InternVarName(sym_glojure_DOT_core, sym_take_DASH_last)
	// var glojure.core/take-nth
	var_glojure_DOT_core_take_DASH_nth := lang.InternVarName(sym_glojure_DOT_core, sym_take_DASH_nth)
	// var glojure.core/take-while
	var_glojure_DOT_core_take_DASH_while := lang.InternVarName(sym_glojure_DOT_core, sym_take_DASH_while)
	// var glojure.core/tapset
	var_glojure_DOT_core_tapset := lang.InternVarName(sym_glojure_DOT_core, sym_tapset)
	// var glojure.core/test
	var_glojure_DOT_core_test := lang.InternVarName(sym_glojure_DOT_core, sym_test)
	// var glojure.core/the-ns
	var_glojure_DOT_core_the_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_the_DASH_ns)
	// var glojure.core/thread-bound?
	var_glojure_DOT_core_thread_DASH_bound_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_thread_DASH_bound_QMARK_)
	// var glojure.core/throw-if
	var_glojure_DOT_core_throw_DASH_if := lang.InternVarName(sym_glojure_DOT_core, sym_throw_DASH_if)
	// var glojure.core/time
	var_glojure_DOT_core_time := lang.InternVarName(sym_glojure_DOT_core, sym_time)
	// var glojure.core/to-array
	var_glojure_DOT_core_to_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_to_DASH_array)
	// var glojure.core/to-array-2d
	var_glojure_DOT_core_to_DASH_array_DASH_2d := lang.InternVarName(sym_glojure_DOT_core, sym_to_DASH_array_DASH_2d)
	// var glojure.core/trampoline
	var_glojure_DOT_core_trampoline := lang.InternVarName(sym_glojure_DOT_core, sym_trampoline)
	// var glojure.core/transduce
	var_glojure_DOT_core_transduce := lang.InternVarName(sym_glojure_DOT_core, sym_transduce)
	// var glojure.core/transient
	var_glojure_DOT_core_transient := lang.InternVarName(sym_glojure_DOT_core, sym_transient)
	// var glojure.core/tree-seq
	var_glojure_DOT_core_tree_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_tree_DASH_seq)
	// var glojure.core/true?
	var_glojure_DOT_core_true_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_true_QMARK_)
	// var glojure.core/type
	var_glojure_DOT_core_type := lang.InternVarName(sym_glojure_DOT_core, sym_type)
	// var glojure.core/unchecked-add
	var_glojure_DOT_core_unchecked_DASH_add := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_add)
	// var glojure.core/unchecked-add-int
	var_glojure_DOT_core_unchecked_DASH_add_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_add_DASH_int)
	// var glojure.core/unchecked-byte
	var_glojure_DOT_core_unchecked_DASH_byte := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_byte)
	// var glojure.core/unchecked-char
	var_glojure_DOT_core_unchecked_DASH_char := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_char)
	// var glojure.core/unchecked-dec
	var_glojure_DOT_core_unchecked_DASH_dec := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_dec)
	// var glojure.core/unchecked-dec-int
	var_glojure_DOT_core_unchecked_DASH_dec_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_dec_DASH_int)
	// var glojure.core/unchecked-divide-int
	var_glojure_DOT_core_unchecked_DASH_divide_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_divide_DASH_int)
	// var glojure.core/unchecked-double
	var_glojure_DOT_core_unchecked_DASH_double := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_double)
	// var glojure.core/unchecked-float
	var_glojure_DOT_core_unchecked_DASH_float := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_float)
	// var glojure.core/unchecked-inc
	var_glojure_DOT_core_unchecked_DASH_inc := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_inc)
	// var glojure.core/unchecked-inc-int
	var_glojure_DOT_core_unchecked_DASH_inc_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_inc_DASH_int)
	// var glojure.core/unchecked-int
	var_glojure_DOT_core_unchecked_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_int)
	// var glojure.core/unchecked-long
	var_glojure_DOT_core_unchecked_DASH_long := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_long)
	// var glojure.core/unchecked-multiply
	var_glojure_DOT_core_unchecked_DASH_multiply := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_multiply)
	// var glojure.core/unchecked-multiply-int
	var_glojure_DOT_core_unchecked_DASH_multiply_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_multiply_DASH_int)
	// var glojure.core/unchecked-negate
	var_glojure_DOT_core_unchecked_DASH_negate := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_negate)
	// var glojure.core/unchecked-negate-int
	var_glojure_DOT_core_unchecked_DASH_negate_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_negate_DASH_int)
	// var glojure.core/unchecked-remainder-int
	var_glojure_DOT_core_unchecked_DASH_remainder_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_remainder_DASH_int)
	// var glojure.core/unchecked-short
	var_glojure_DOT_core_unchecked_DASH_short := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_short)
	// var glojure.core/unchecked-subtract
	var_glojure_DOT_core_unchecked_DASH_subtract := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_subtract)
	// var glojure.core/unchecked-subtract-int
	var_glojure_DOT_core_unchecked_DASH_subtract_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_subtract_DASH_int)
	// var glojure.core/underive
	var_glojure_DOT_core_underive := lang.InternVarName(sym_glojure_DOT_core, sym_underive)
	// var glojure.core/unquote
	var_glojure_DOT_core_unquote := lang.InternVarName(sym_glojure_DOT_core, sym_unquote)
	// var glojure.core/unquote-splicing
	var_glojure_DOT_core_unquote_DASH_splicing := lang.InternVarName(sym_glojure_DOT_core, sym_unquote_DASH_splicing)
	// var glojure.core/unreduced
	var_glojure_DOT_core_unreduced := lang.InternVarName(sym_glojure_DOT_core, sym_unreduced)
	// var glojure.core/unsigned-bit-shift-right
	var_glojure_DOT_core_unsigned_DASH_bit_DASH_shift_DASH_right := lang.InternVarName(sym_glojure_DOT_core, sym_unsigned_DASH_bit_DASH_shift_DASH_right)
	// var glojure.core/update
	var_glojure_DOT_core_update := lang.InternVarName(sym_glojure_DOT_core, sym_update)
	// var glojure.core/update-in
	var_glojure_DOT_core_update_DASH_in := lang.InternVarName(sym_glojure_DOT_core, sym_update_DASH_in)
	// var glojure.core/update-keys
	var_glojure_DOT_core_update_DASH_keys := lang.InternVarName(sym_glojure_DOT_core, sym_update_DASH_keys)
	// var glojure.core/update-vals
	var_glojure_DOT_core_update_DASH_vals := lang.InternVarName(sym_glojure_DOT_core, sym_update_DASH_vals)
	// var glojure.core/uri?
	var_glojure_DOT_core_uri_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_uri_QMARK_)
	// var glojure.core/use
	var_glojure_DOT_core_use := lang.InternVarName(sym_glojure_DOT_core, sym_use)
	// var glojure.core/uuid?
	var_glojure_DOT_core_uuid_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_uuid_QMARK_)
	// var glojure.core/val
	var_glojure_DOT_core_val := lang.InternVarName(sym_glojure_DOT_core, sym_val)
	// var glojure.core/vals
	var_glojure_DOT_core_vals := lang.InternVarName(sym_glojure_DOT_core, sym_vals)
	// var glojure.core/var-get
	var_glojure_DOT_core_var_DASH_get := lang.InternVarName(sym_glojure_DOT_core, sym_var_DASH_get)
	// var glojure.core/var-set
	var_glojure_DOT_core_var_DASH_set := lang.InternVarName(sym_glojure_DOT_core, sym_var_DASH_set)
	// var glojure.core/var?
	var_glojure_DOT_core_var_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_var_QMARK_)
	// var glojure.core/vary-meta
	var_glojure_DOT_core_vary_DASH_meta := lang.InternVarName(sym_glojure_DOT_core, sym_vary_DASH_meta)
	// var glojure.core/vec
	var_glojure_DOT_core_vec := lang.InternVarName(sym_glojure_DOT_core, sym_vec)
	// var glojure.core/vector
	var_glojure_DOT_core_vector := lang.InternVarName(sym_glojure_DOT_core, sym_vector)
	// var glojure.core/vector?
	var_glojure_DOT_core_vector_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_vector_QMARK_)
	// var glojure.core/volatile!
	var_glojure_DOT_core_volatile_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_volatile_BANG_)
	// var glojure.core/volatile?
	var_glojure_DOT_core_volatile_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_volatile_QMARK_)
	// var glojure.core/vreset!
	var_glojure_DOT_core_vreset_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_vreset_BANG_)
	// var glojure.core/vswap!
	var_glojure_DOT_core_vswap_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_vswap_BANG_)
	// var glojure.core/when
	var_glojure_DOT_core_when := lang.InternVarName(sym_glojure_DOT_core, sym_when)
	// var glojure.core/when-first
	var_glojure_DOT_core_when_DASH_first := lang.InternVarName(sym_glojure_DOT_core, sym_when_DASH_first)
	// var glojure.core/when-let
	var_glojure_DOT_core_when_DASH_let := lang.InternVarName(sym_glojure_DOT_core, sym_when_DASH_let)
	// var glojure.core/when-not
	var_glojure_DOT_core_when_DASH_not := lang.InternVarName(sym_glojure_DOT_core, sym_when_DASH_not)
	// var glojure.core/when-some
	var_glojure_DOT_core_when_DASH_some := lang.InternVarName(sym_glojure_DOT_core, sym_when_DASH_some)
	// var glojure.core/while
	var_glojure_DOT_core_while := lang.InternVarName(sym_glojure_DOT_core, sym_while)
	// var glojure.core/with-bindings
	var_glojure_DOT_core_with_DASH_bindings := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_bindings)
	// var glojure.core/with-bindings*
	var_glojure_DOT_core_with_DASH_bindings_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_bindings_STAR_)
	// var glojure.core/with-in-str
	var_glojure_DOT_core_with_DASH_in_DASH_str := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_in_DASH_str)
	// var glojure.core/with-loading-context
	var_glojure_DOT_core_with_DASH_loading_DASH_context := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_loading_DASH_context)
	// var glojure.core/with-local-vars
	var_glojure_DOT_core_with_DASH_local_DASH_vars := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_local_DASH_vars)
	// var glojure.core/with-meta
	var_glojure_DOT_core_with_DASH_meta := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_meta)
	// var glojure.core/with-open
	var_glojure_DOT_core_with_DASH_open := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_open)
	// var glojure.core/with-out-str
	var_glojure_DOT_core_with_DASH_out_DASH_str := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_out_DASH_str)
	// var glojure.core/with-precision
	var_glojure_DOT_core_with_DASH_precision := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_precision)
	// var glojure.core/with-redefs
	var_glojure_DOT_core_with_DASH_redefs := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_redefs)
	// var glojure.core/with-redefs-fn
	var_glojure_DOT_core_with_DASH_redefs_DASH_fn := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_redefs_DASH_fn)
	// var glojure.core/xml-seq
	var_glojure_DOT_core_xml_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_xml_DASH_seq)
	// var glojure.core/zero?
	var_glojure_DOT_core_zero_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_zero_QMARK_)
	// var glojure.core/zipmap
	var_glojure_DOT_core_zipmap := lang.InternVarName(sym_glojure_DOT_core, sym_zipmap)
	// var glojure.go.io/copy
	var_glojure_DOT_go_DOT_io_copy := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_copy)
	// var glojure.go.io/make-input-stream
	var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_make_DASH_input_DASH_stream)
	// var glojure.go.io/make-output-stream
	var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_make_DASH_output_DASH_stream)
	// var glojure.go.io/make-writer
	var_glojure_DOT_go_DOT_io_make_DASH_writer := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_make_DASH_writer)
	// var glojure.go.io/reader
	var_glojure_DOT_go_DOT_io_reader := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_reader)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_glojure_DOT_core)
	_ = ns
	var closed0 any
	{
		closed0 = sym_unchecked_multiply
	}
	var closed1 any
	{
		closed1 = sym_multiply
	}
	var closed10 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3, _ := lang.FieldOrMethod(v1, "Reduce")
				if reflect.TypeOf(tmp3).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Reduce is not a function")))
				}
				tmp4 := lang.Apply(tmp3, []any{v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(v1, "ReduceInit")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed10 = tmp0
	}
	var closed13 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
			return v3
		})
		closed13 = tmp0
	}
	var closed16 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			return nil
		})
		closed16 = tmp0
	}
	var closed17 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(188), kw_column, int(18), kw_end_DASH_line, int(188), kw_end_DASH_column, int(32))).(lang.FnFunc)
		closed17 = tmp0
	}
	var closed2 any
	{
		closed2 = sym_multiplyP
	}
	var closed20 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(187), kw_column, int(24), kw_end_DASH_line, int(187), kw_end_DASH_column, int(38))).(lang.FnFunc)
		closed20 = tmp0
	}
	var closed21 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(226), kw_column, int(24), kw_end_DASH_line, int(226), kw_end_DASH_column, int(48))).(lang.FnFunc)
		closed21 = tmp0
	}
	var closed25 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(227), kw_column, int(25), kw_end_DASH_line, int(227), kw_end_DASH_column, int(49))).(lang.FnFunc)
		closed25 = tmp0
	}
	var closed28 any
	{
		closed28 = sym_divide
	}
	var closed29 any
	{
		closed29 = sym_and
	}
	var closed3 any
	{
		closed3 = sym_unchecked_add
	}
	var closed30 any
	{
		closed30 = sym_andNot
	}
	var closed31 any
	{
		closed31 = sym_or
	}
	var closed32 any
	{
		closed32 = sym_xor
	}
	var closed33 any
	{
		closed33 = sym_max
	}
	var closed34 any
	{
		closed34 = sym_min
	}
	var closed35 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			var tmp2 any
			if lang.IsTruthy(v1) {
				tmp2 = false
			} else {
				tmp2 = true
			}
			return tmp2
		})
		tmp1 := reflect.TypeOf(false)
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, tmp1)).(lang.FnFunc)
		closed35 = tmp0
	}
	var closed4 any
	{
		closed4 = sym_add
	}
	var closed5 any
	{
		closed5 = sym_addP
	}
	var closed6 any
	{
		closed6 = sym_unchecked_minus
	}
	var closed7 any
	{
		closed7 = sym_minus
	}
	var closed8 any
	{
		closed8 = sym_minusP
	}
	var closed9 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := lang.Apply(v2, nil)
				return tmp3
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				return v3
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed9 = tmp0
	}
	// >0?
	{
		tmp0 := sym__GT_0_QMARK_.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(963), kw_column, int(7), kw_end_DASH_line, int(963), kw_end_DASH_column, int(19), kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{v2, int64(0)})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__GT_0_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__GT_0_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >1?
	{
		tmp0 := sym__GT_1_QMARK_.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(962), kw_column, int(7), kw_end_DASH_line, int(962), kw_end_DASH_column, int(19), kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{v2, int64(1)})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__GT_1_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__GT_1_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *1
	{
		tmp0 := sym__STAR_1.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(6268), kw_column, int(6), kw_end_DASH_line, int(6271), kw_end_DASH_column, int(3), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_1 = ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_1.SetDynamic()
	}
	// *2
	{
		tmp0 := sym__STAR_2.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(6273), kw_column, int(6), kw_end_DASH_line, int(6276), kw_end_DASH_column, int(3), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_2 = ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_2.SetDynamic()
	}
	// *3
	{
		tmp0 := sym__STAR_3.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(6278), kw_column, int(6), kw_end_DASH_line, int(6281), kw_end_DASH_column, int(3), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_3 = ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_3.SetDynamic()
	}
	// *agent*
	{
		tmp0 := sym__STAR_agent_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_agent_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_agent_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *assert*
	{
		tmp0 := sym__STAR_assert_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "When set to logical false, 'assert' will omit assertion checks in\n  compiled code. Defaults to true.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_assert_STAR_ = ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_assert_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *command-line-args*
	{
		tmp0 := sym__STAR_command_DASH_line_DASH_args_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "A sequence of the supplied command line arguments, or nil if\n  none were supplied", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_command_DASH_line_DASH_args_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_command_DASH_line_DASH_args_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compile-files*
	{
		tmp0 := sym__STAR_compile_DASH_files_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "Set to true when compiling files, false otherwise.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_compile_DASH_files_STAR_ = ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_compile_DASH_files_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compile-path*
	{
		tmp0 := sym__STAR_compile_DASH_path_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "Specifies the directory where 'compile' will write out .class\n  files. This directory must be in the classpath for 'compile' to\n  work.\n\n  Defaults to \"classes\"", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_compile_DASH_path_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_compile_DASH_path_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compiler-options*
	{
		tmp0 := sym__STAR_compiler_DASH_options_STAR_.WithMeta(lang.NewMap(kw_added, "1.4", kw_doc, "A map of keys to options.\n  Note, when binding dynamically make sure to merge with previous value.\n  Supported options:\n  :elide-meta - a collection of metadata keys to elide during compilation.\n  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger\n  :direct-linking - set to true to use direct static invocation of functions, rather than vars\n    Note that call sites compiled with direct linking will not be affected by var redefinition.\n    Use ^:redef (or ^:dynamic) on a var to prevent direct linking and allow redefinition.\n  See https://glojure.org/reference/compilation for more information.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_compiler_DASH_options_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_compiler_DASH_options_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *data-readers*
	{
		tmp0 := sym__STAR_data_DASH_readers_STAR_.WithMeta(lang.NewMap(kw_doc, "Map from reader tag symbols to data reader Vars.\n\n  When Clojure starts, it searches for files named 'data_readers.clj'\n  and 'data_readers.cljc' at the root of the classpath. Each such file\n  must contain a literal map of symbols, like this:\n\n      {foo/bar my.project.foo/bar\n       foo/baz my.project/baz}\n\n  The first symbol in each pair is a tag that will be recognized by\n  the Clojure reader. The second symbol in the pair is the\n  fully-qualified name of a Var which will be invoked by the reader to\n  parse the form following the tag. For example, given the\n  data_readers.clj file above, the Clojure reader would parse this\n  form:\n\n      #foo/bar [1 2 3]\n\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\n  data reader function is invoked on the form AFTER it has been read\n  as a normal Clojure data structure by the reader.\n\n  Reader tags without namespace qualifiers are reserved for\n  Clojure. Default reader tags are defined in\n  glojure.core/default-data-readers but may be overridden in\n  data_readers.clj, data_readers.cljc, or by rebinding this Var.", kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(49), kw_column, int(6), kw_line, int(7794), kw_end_DASH_line, int(7794), kw_dynamic, true)).(*lang.Symbol)
		var_glojure_DOT_core__STAR_data_DASH_readers_STAR_ = ns.InternWithValue(tmp0, lang.NewMap(), true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_data_DASH_readers_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_data_DASH_readers_STAR_.SetDynamic()
	}
	// *default-data-reader-fn*
	{
		tmp0 := sym__STAR_default_DASH_data_DASH_reader_DASH_fn_STAR_.WithMeta(lang.NewMap(kw_doc, "When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments,\n  the tag and the value.  If *default-data-reader-fn* is nil (the\n  default), an exception will be thrown for the unknown tag.", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(59), kw_column, int(6), kw_line, int(7823), kw_end_DASH_line, int(7823), kw_dynamic, true)).(*lang.Symbol)
		var_glojure_DOT_core__STAR_default_DASH_data_DASH_reader_DASH_fn_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_default_DASH_data_DASH_reader_DASH_fn_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_default_DASH_data_DASH_reader_DASH_fn_STAR_.SetDynamic()
	}
	// *e
	{
		tmp0 := sym__STAR_e.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(6283), kw_column, int(6), kw_end_DASH_line, int(6286), kw_end_DASH_column, int(3), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_e = ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_e.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_e.SetDynamic()
	}
	// *err*
	{
		tmp0 := sym__STAR_err_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "A java.io.Writer object representing standard error for print operations.\n\n  Defaults to System/err, wrapped in a PrintWriter", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_err_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_err_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *file*
	{
		tmp0 := sym__STAR_file_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "The path of the file being evaluated, as a String.\n\n  When there is no file, e.g. in the REPL, the value is not defined.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_file_STAR_ = ns.InternWithValue(tmp0, "NO_SOURCE_FILE", true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_file_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *flush-on-newline*
	{
		tmp0 := sym__STAR_flush_DASH_on_DASH_newline_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_flush_DASH_on_DASH_newline_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_flush_DASH_on_DASH_newline_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *loaded-libs*
	{
		tmp0 := sym__STAR_loaded_DASH_libs_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(5817), kw_column, int(10), kw_end_DASH_line, int(5820), kw_end_DASH_column, int(15), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := lang.NewRef(lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{sym_glojure_DOT_core_DOT_protocols, sym_glojure_DOT_string, sym_glojure_DOT_go_DOT_io, sym_codegen_DOT_test_DOT_case_DASH_switch, sym_codegen_DOT_test_DOT_const_DASH_keyword, sym_codegen_DOT_test_DOT_const_DASH_number, sym_codegen_DOT_test_DOT_const_DASH_string, sym_codegen_DOT_test_DOT_def_DASH_simple, sym_codegen_DOT_test_DOT_fn_DASH_closure, sym_codegen_DOT_test_DOT_fn_DASH_recur, sym_codegen_DOT_test_DOT_goroutine, sym_codegen_DOT_test_DOT_loop_DASH_simple, sym_codegen_DOT_test_DOT_maybe_DASH_class, sym_codegen_DOT_test_DOT_multifn, sym_codegen_DOT_test_DOT_ns_DASH_skip, sym_codegen_DOT_test_DOT_quote_DASH_simple, sym_codegen_DOT_test_DOT_ref, sym_codegen_DOT_test_DOT_set_DASH_bang, sym_codegen_DOT_test_DOT_the_DASH_var, sym_codegen_DOT_test_DOT_throw_DASH_simple, sym_codegen_DOT_test_DOT_try_DASH_advanced, sym_codegen_DOT_test_DOT_try_DASH_basic, sym_codegen_DOT_test_DOT_values, sym_codegen_DOT_test_DOT_with_DASH_meta})))
		var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_.SetDynamic()
	}
	// *loading-verbosely*
	{
		tmp0 := sym__STAR_loading_DASH_verbosely_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(5827), kw_column, int(10), kw_end_DASH_line, int(5830), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_ = ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_.SetDynamic()
	}
	// *ns*
	{
		tmp0 := sym__STAR_ns_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "A glojure.lang.Namespace object representing the current namespace.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_ns_STAR_ = ns.InternWithValue(tmp0, lang.FindOrCreateNamespace(sym_glojure_DOT_core), true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_ns_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *pending-paths*
	{
		tmp0 := sym__STAR_pending_DASH_paths_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(5822), kw_column, int(10), kw_end_DASH_line, int(5825), kw_end_DASH_column, int(17), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_ = ns.InternWithValue(tmp0, lang.NewList(), true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_.SetDynamic()
	}
	// *print-dup*
	{
		tmp0 := sym__STAR_print_DASH_dup_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_print_DASH_dup_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_print_DASH_dup_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-length*
	{
		tmp0 := sym__STAR_print_DASH_length_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core_print.glj", kw_line, int(14), kw_column, int(6), kw_end_DASH_line, int(23), kw_end_DASH_column, int(15), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_print_DASH_length_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_print_DASH_length_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_print_DASH_length_STAR_.SetDynamic()
	}
	// *print-level*
	{
		tmp0 := sym__STAR_print_DASH_level_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core_print.glj", kw_line, int(25), kw_column, int(6), kw_end_DASH_line, int(35), kw_end_DASH_column, int(14), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_print_DASH_level_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_print_DASH_level_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_print_DASH_level_STAR_.SetDynamic()
	}
	// *print-meta*
	{
		tmp0 := sym__STAR_print_DASH_meta_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_print_DASH_meta_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_print_DASH_meta_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-namespace-maps*
	{
		tmp0 := sym__STAR_print_DASH_namespace_DASH_maps_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core_print.glj", kw_line, int(39), kw_column, int(6), kw_end_DASH_line, int(44), kw_end_DASH_column, int(23), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_print_DASH_namespace_DASH_maps_STAR_ = ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_print_DASH_namespace_DASH_maps_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_print_DASH_namespace_DASH_maps_STAR_.SetDynamic()
	}
	// *print-readably*
	{
		tmp0 := sym__STAR_print_DASH_readably_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_print_DASH_readably_STAR_ = ns.InternWithValue(tmp0, true, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_print_DASH_readably_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *read-eval*
	{
		tmp0 := sym__STAR_read_DASH_eval_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "Defaults to true (or value specified by system property, see below)\n  ***This setting implies that the full power of the reader is in play,\n  including syntax that can cause code to execute. It should never be\n  used with untrusted sources. See also: glojure.edn/read.***\n\n  When set to logical false in the thread-local binding,\n  the eval reader (#=) and record/type literal syntax are disabled in read/load.\n  Example (will fail): (binding [*read-eval* false] (read-string \"#=(* 2 21)\"))\n\n  The default binding can be controlled by the system property\n  'glojure.read.eval' System properties can be set on the command line\n  like this:\n\n  java -Dglojure.read.eval=false ...\n\n  The system property can also be set to 'unknown' via\n  -Dglojure.read.eval=unknown, in which case the default binding\n  is :unknown and all reads will fail in contexts where *read-eval*\n  has not been explicitly bound to either true or false. This setting\n  can be a useful diagnostic tool to ensure that all of your reads\n  occur in considered contexts. You can also accomplish this in a\n  particular scope by binding *read-eval* to :unknown\n  ", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_read_DASH_eval_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_read_DASH_eval_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *repl*
	{
		tmp0 := sym__STAR_repl_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(6288), kw_column, int(6), kw_end_DASH_line, int(6291), kw_end_DASH_column, int(8), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_repl_STAR_ = ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_repl_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_repl_STAR_.SetDynamic()
	}
	// *unchecked-math*
	{
		tmp0 := sym__STAR_unchecked_DASH_math_STAR_.WithMeta(lang.NewMap(kw_added, "1.3", kw_doc, "While bound to true, compilations of +, -, *, inc, dec and the\n  coercions will be done without overflow checks. While bound\n  to :warn-on-boxed, same behavior as true, and a warning is emitted\n  when compilation uses boxed math. Default: false.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *verbose-defrecords*
	{
		tmp0 := sym__STAR_verbose_DASH_defrecords_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core_print.glj", kw_line, int(37), kw_column, int(6), kw_end_DASH_line, int(37), kw_end_DASH_column, int(35), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_verbose_DASH_defrecords_STAR_ = ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_verbose_DASH_defrecords_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core__STAR_verbose_DASH_defrecords_STAR_.SetDynamic()
	}
	// *warn-on-reflection*
	{
		tmp0 := sym__STAR_warn_DASH_on_DASH_reflection_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "When set to true, the compiler will emit warnings when reflection is\n  needed to resolve Java method calls or field accesses.\n\n  Defaults to false.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core__STAR_warn_DASH_on_DASH_reflection_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_warn_DASH_on_DASH_reflection_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// accessor
	{
		tmp0 := sym_accessor.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_key)), kw_doc, "Returns a fn that, given an instance of a structmap with the basis,\n  returns the value at the key.  The key must be in the basis. The\n  returned function should be (slightly) more efficient than using\n  get, but such use of accessors should be limited to known\n  performance-critical areas.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4070), kw_end_DASH_line, int(4070))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(lang.GetPersistentStructMapAccessor, []any{v2, v3})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_accessor = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_accessor.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-watch
	{
		tmp0 := sym_add_DASH_watch.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_reference, sym_key, sym_fn)), kw_doc, "Adds a watch function to an agent/atom/var/ref reference. The watch\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch fn\n  will be called synchronously, on the agent's thread if an agent,\n  before any pending sends if agent or ref. Note that an atom's or\n  ref's state may have changed again prior to the fn call, so use\n  old/new-state rather than derefing the reference. Note also that watch\n  fns may be called from multiple threads simultaneously. Var watchers\n  are triggered only by root binding changes, not thread-local\n  set!s. Keys must be unique per reference, and can be used to remove\n  the watch with remove-watch, but are otherwise considered opaque by\n  the watch mechanism.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2142), kw_end_DASH_line, int(2142))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v2, "addWatch")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("addWatch is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_add_DASH_watch = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_add_DASH_watch.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// agent-error
	{
		tmp0 := sym_agent_DASH_error.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_doc, "Returns the exception thrown during an asynchronous action of the\n  agent if the agent is failed.  Returns nil if the agent is not\n  failed.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(2167), kw_end_DASH_line, int(2167))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "getError")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getError")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_agent_DASH_error = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_agent_DASH_error.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// all-ns
	{
		tmp0 := sym_all_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a sequence of all namespaces.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4146), kw_end_DASH_line, int(4146))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := lang.Apply(nil, nil)
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_all_DASH_ns = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_all_DASH_ns.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter
	{
		tmp0 := sym_alter.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref, sym_fun, sym__AMP_, sym_args)), kw_doc, "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(2435), kw_end_DASH_line, int(2435))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v2, "alter")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("alter is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_alter = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_alter.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter-meta!
	{
		tmp0 := sym_alter_DASH_meta_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_iref, sym_f, sym__AMP_, sym_args)), kw_doc, "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(2398), kw_end_DASH_line, int(2398))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v2, "AlterMeta")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("AlterMeta is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_alter_DASH_meta_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_alter_DASH_meta_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter-var-root
	{
		tmp0 := sym_alter_DASH_var_DASH_root.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_v, sym_f, sym__AMP_, sym_args)), kw_doc, "Atomically alters the root binding of var v by applying f to its\n  current value plus any args", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(5484), kw_end_DASH_line, int(5484))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v2, "alterRoot")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("alterRoot is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_alter_DASH_var_DASH_root = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_alter_DASH_var_DASH_root.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// any?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_any_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true given any argument.", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(537), kw_end_DASH_line, int(537))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			return true
		})
		tmp3 := reflect.TypeOf(false)
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_any_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_any_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-clear
	{
		tmp0 := sym_bit_DASH_clear.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_doc, "Clear bit at index n", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(1336), kw_end_DASH_line, int(1336))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "clearBit")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("clearBit is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bit_DASH_clear = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bit_DASH_clear.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-flip
	{
		tmp0 := sym_bit_DASH_flip.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_doc, "Flip bit at index n", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1348), kw_end_DASH_line, int(1348))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "flipBit")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("flipBit is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bit_DASH_flip = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bit_DASH_flip.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-set
	{
		tmp0 := sym_bit_DASH_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_doc, "Set bit at index n", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1342), kw_end_DASH_line, int(1342))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "setBit")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setBit is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bit_DASH_set = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bit_DASH_set.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-test
	{
		tmp0 := sym_bit_DASH_test.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_doc, "Test bit at index n", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1354), kw_end_DASH_line, int(1354))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "testBit")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("testBit is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bit_DASH_test = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bit_DASH_test.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cast
	{
		tmp0 := sym_cast.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_c, sym_x)), kw_doc, "Throws a ClassCastException if x is not a c, else returns x.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(345), kw_end_DASH_line, int(345))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "cast")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("cast is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_cast = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_cast.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-escape-string
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_char_DASH_escape_DASH_string.WithMeta(lang.NewMap(kw_tag, tmp1, kw_doc, "Returns escape string for char or nil if none", kw_file, "glojure/core_print.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(6), kw_line, int(214), kw_end_DASH_line, int(217))).(*lang.Symbol)
		var_glojure_DOT_core_char_DASH_escape_DASH_string = ns.InternWithValue(tmp0, lang.NewMap(lang.NewChar(10), "\\n", lang.NewChar(9), "\\t", lang.NewChar(13), "\\r", lang.NewChar(34), "\\\"", lang.NewChar(92), "\\\\", lang.NewChar(12), "\\f", lang.NewChar(8), "\\b"), true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_char_DASH_escape_DASH_string.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-name-string
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_char_DASH_name_DASH_string.WithMeta(lang.NewMap(kw_tag, tmp1, kw_doc, "Returns name string for char or nil if none", kw_file, "glojure/core_print.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(6), kw_line, int(335), kw_end_DASH_line, int(338))).(*lang.Symbol)
		var_glojure_DOT_core_char_DASH_name_DASH_string = ns.InternWithValue(tmp0, lang.NewMap(lang.NewChar(10), "newline", lang.NewChar(9), "tab", lang.NewChar(32), "space", lang.NewChar(8), "backspace", lang.NewChar(12), "formfeed", lang.NewChar(13), "return"), true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_char_DASH_name_DASH_string.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk
	{
		tmp0 := sym_chunk.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(691), kw_column, int(7), kw_end_DASH_line, int(691), kw_end_DASH_column, int(41), kw_arglists, lang.NewList(lang.NewVector(sym_b)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "chunk")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "chunk")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_chunk = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_chunk.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-append
	{
		tmp0 := sym_chunk_DASH_append.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(688), kw_column, int(7), kw_end_DASH_line, int(688), kw_end_DASH_column, int(27), kw_arglists, lang.NewList(lang.NewVector(sym_b, sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "add")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_chunk_DASH_append = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_chunk_DASH_append.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-buffer
	{
		tmp0 := sym_chunk_DASH_buffer.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(685), kw_column, int(7), kw_end_DASH_line, int(685), kw_end_DASH_column, int(53), kw_arglists, lang.NewList(lang.NewVector(sym_capacity)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(lang.NewChunkBuffer, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_chunk_DASH_buffer = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_chunk_DASH_buffer.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-cons
	{
		tmp0 := sym_chunk_DASH_cons.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(703), kw_column, int(7), kw_end_DASH_line, int(703), kw_end_DASH_column, int(25), kw_arglists, lang.NewList(lang.NewVector(sym_chunk, sym_rest)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := lang.Apply(lang.Count, []any{v2})
			tmp6 := lang.Apply(lang.IsZero, []any{tmp5})
			if lang.IsTruthy(tmp6) {
				tmp4 = v3
			} else {
				tmp7 := lang.Apply(lang.NewChunkedCons, []any{v2, v3})
				tmp4 = tmp7
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_chunk_DASH_cons = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_chunk_DASH_cons.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-first
	{
		tmp0 := sym_chunk_DASH_first.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(694), kw_column, int(7), kw_end_DASH_line, int(694), kw_end_DASH_column, int(48), kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "chunkedFirst")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "chunkedFirst")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_chunk_DASH_first = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_chunk_DASH_first.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-next
	{
		tmp0 := sym_chunk_DASH_next.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(700), kw_column, int(7), kw_end_DASH_line, int(700), kw_end_DASH_column, int(71), kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "chunkedNext")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "chunkedNext")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_chunk_DASH_next = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_chunk_DASH_next.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-rest
	{
		tmp0 := sym_chunk_DASH_rest.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(697), kw_column, int(7), kw_end_DASH_line, int(697), kw_end_DASH_column, int(71), kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "chunkedMore")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "chunkedMore")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_chunk_DASH_rest = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_chunk_DASH_rest.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comment
	{
		tmp0 := sym_comment.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Ignores body, yields nil", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(4733), kw_end_DASH_line, int(4733))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				return nil
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_comment = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_comment.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// commute
	{
		tmp0 := sym_commute.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref, sym_fun, sym__AMP_, sym_args)), kw_doc, "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(2414), kw_end_DASH_line, int(2414))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v2, "Commute")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Commute is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_commute = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_commute.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comparator
	{
		tmp0 := sym_comparator.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred)), kw_doc, "Returns an implementation of java.util.Comparator based upon pred.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(3077), kw_end_DASH_line, int(3077))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var tmp6 any
				tmp7 := lang.Apply(v2, []any{v4, v5})
				if lang.IsTruthy(tmp7) {
					tmp6 = int64(-1)
				} else {
					var tmp8 any
					tmp9 := lang.Apply(v2, []any{v5, v4})
					if lang.IsTruthy(tmp9) {
						tmp8 = int64(1)
					} else {
						var tmp10 any
						if lang.IsTruthy(kw_else) {
							tmp10 = int64(0)
						} else {
						}
						tmp8 = tmp10
					}
					tmp6 = tmp8
				}
				return tmp6
			})
			tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3082), kw_column, int(5), kw_end_DASH_line, int(3083), kw_end_DASH_column, int(48))
			tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_comparator = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_comparator.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compare-and-set!
	{
		tmp0 := sym_compare_DASH_and_DASH_set_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atom, sym_oldval, sym_newval)), kw_doc, "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(2360), kw_end_DASH_line, int(2360))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v2, "compareAndSet")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("compareAndSet is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_compare_DASH_and_DASH_set_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_compare_DASH_and_DASH_set_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cons
	{
		tmp0 := sym_cons.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_seq)), kw_doc, "Returns a new seq where x is the first element and seq is\n    the rest.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(21), kw_end_DASH_line, int(27))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function cons
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.NewCons, []any{v3, v4})
				return tmp5
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(27), kw_column, int(7), kw_end_DASH_line, int(27), kw_end_DASH_column, int(89))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_cons = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_cons.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// constantly
	{
		tmp0 := sym_constantly.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns a function that takes any number of arguments and returns x.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(1440), kw_end_DASH_line, int(1440))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 0)
					var v4 any = lang.NewList(args[0:]...)
					_ = v4
					return v2
				}
			})
			tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1444), kw_column, int(7), kw_end_DASH_line, int(1444), kw_end_DASH_column, int(21))
			tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_constantly = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_constantly.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// contains?
	{
		tmp0 := sym_contains_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_key)), kw_doc, "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and Java arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(1479), kw_end_DASH_line, int(1479))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "Contains")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Contains is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_contains_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_contains_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// create-ns
	{
		tmp0 := sym_create_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_doc, "Create a new namespace named by the symbol if one doesn't already\n  exist, returns it or the already-existing namespace of the same\n  name.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4131), kw_end_DASH_line, int(4131))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(nil, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_create_DASH_ns = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_create_DASH_ns.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// create-struct
	{
		tmp0 := sym_create_DASH_struct.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_keys)), kw_doc, "Returns a structure basis object.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(4037), kw_end_DASH_line, int(4037))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := lang.Apply(lang.CreatePersistentStructMapSlotMap, []any{v2})
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_create_DASH_struct = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_create_DASH_struct.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// data-reader-urls
	{
		tmp0 := sym_data_DASH_reader_DASH_urls.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7830), kw_column, int(8), kw_end_DASH_line, int(7830), kw_end_DASH_column, int(23), kw_private, true, kw_arglists, lang.NewList(lang.NewVector()), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			return lang.NewList()
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_data_DASH_reader_DASH_urls = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_data_DASH_reader_DASH_urls.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deliver
	{
		tmp0 := sym_deliver.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_promise, sym_val)), kw_doc, "Delivers the supplied value to the promise, releasing any pending\n  derefs. A subsequent call to deliver on a promise will have no effect.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(7109), kw_end_DASH_line, int(7109))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(v2, []any{v3})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_deliver = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_deliver.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// denominator
	{
		tmp1 := reflect.TypeOf((*big9.Int)(nil))
		tmp0 := sym_denominator.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_r)), kw_doc, "Returns the denominator part of a Ratio.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(3591), kw_end_DASH_line, int(3591))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "denominator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "denominator")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp3 := reflect.TypeOf((*big9.Int)(nil))
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_denominator = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_denominator.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref-future
	{
		tmp0 := sym_deref_DASH_future.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(2296), kw_column, int(7), kw_end_DASH_line, int(2296), kw_end_DASH_column, int(28), kw_arglists, lang.NewList(lang.NewVector(sym_fut), lang.NewVector(sym_fut, sym_timeout_DASH_ms, sym_timeout_DASH_val)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3, ok := lang.FieldOrMethod(v2, "Get")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "Get")))
				}
				var tmp4 any
				switch reflect.TypeOf(tmp3).Kind() {
				case reflect.Func:
					tmp4 = lang.Apply(tmp3, nil)
				default:
					tmp4 = tmp3
				}
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							tmp6 := reflect.TypeOf((*lang.TimeoutError)(nil)).Elem()
							if lang.CatchMatches(r, tmp6) {
								v7 := r
								_ = v7
								tmp5 = v4
							} else {
								panic(r)
							}
						}
					}()
					tmp7, _ := lang.FieldOrMethod(v2, "Get")
					if reflect.TypeOf(tmp7).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Get is not a function")))
					}
					tmp8 := lang.Apply(tmp7, []any{v3, time10.Millisecond})
					tmp5 = tmp8
				}()
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_deref_DASH_future = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_deref_DASH_future.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ensure
	{
		tmp0 := sym_ensure.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref)), kw_doc, "Must be called in a transaction. Protects the ref from modification\n  by other transactions.  Returns the in-transaction-value of\n  ref. Allows for more concurrency than (ref-set ref @ref)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2480), kw_end_DASH_line, int(2480))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(v2, "touch")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("touch is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{})
			_ = tmp4
			tmp5, _ := lang.FieldOrMethod(v2, "deref")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("deref is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ensure = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ensure.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// enumeration-seq
	{
		tmp0 := sym_enumeration_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_e)), kw_doc, "Returns a seq on a java.util.Enumeration", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(5710), kw_end_DASH_line, int(5710))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(nil, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_enumeration_DASH_seq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_enumeration_DASH_seq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// error-handler
	{
		tmp0 := sym_error_DASH_handler.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_doc, "Returns the error-handler of agent a, or nil if there is none.\n  See set-error-handler!", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(2202), kw_end_DASH_line, int(2202))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "getErrorHandler")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getErrorHandler")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_error_DASH_handler = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_error_DASH_handler.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// error-mode
	{
		tmp0 := sym_error_DASH_mode.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_doc, "Returns the error-mode of agent a.  See set-error-mode!", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(2227), kw_end_DASH_line, int(2227))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "getErrorMode")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getErrorMode")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_error_DASH_mode = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_error_DASH_mode.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// eval
	{
		tmp0 := sym_eval.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_form)), kw_doc, "Evaluates the form data structure (not text!) and returns the result.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3203), kw_end_DASH_line, int(3203))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(runtime.Compiler, "Eval")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Eval is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_eval = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_eval.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// false?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_false_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is the value false, false otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(504), kw_end_DASH_line, int(504))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.Identical, []any{v3, false})
			return tmp4
		})
		tmp3 := reflect.TypeOf(false)
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_false_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_false_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find
	{
		tmp0 := sym_find.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map, sym_key)), kw_doc, "Returns the map entry for key, or nil if key not present.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1530), kw_end_DASH_line, int(1530))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "Find")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Find is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_find = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_find.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-ns
	{
		tmp0 := sym_find_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_doc, "Returns the namespace named by the symbol or nil if it doesn't exist.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4125), kw_end_DASH_line, int(4125))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(lang.FindNamespace, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_find_DASH_ns = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_find_DASH_ns.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-var
	{
		tmp0 := sym_find_DASH_var.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_doc, "Returns the global var named by the namespace-qualified symbol, or\n  nil if no var with that name.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2013), kw_end_DASH_line, int(2013))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(runtime.RT, "FindVar")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("FindVar is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_find_DASH_var = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_find_DASH_var.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// first
	{
		tmp0 := sym_first.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns the first item in the collection. Calls seq on its\n    argument. If coll is nil, returns nil.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(47), kw_end_DASH_line, int(52))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function first
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(lang.First, []any{v3})
				return tmp4
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(52), kw_column, int(8), kw_end_DASH_line, int(52), kw_end_DASH_column, int(86))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_first = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_first.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// force
	{
		tmp0 := sym_force.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(754), kw_end_DASH_line, int(754))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(nil, "force")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("force is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_force = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_force.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-cancel
	{
		tmp0 := sym_future_DASH_cancel.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Cancels the future, if possible.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(7019), kw_end_DASH_line, int(7019))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(v2, "cancel")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("cancel is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{true})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_future_DASH_cancel = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_future_DASH_cancel.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-cancelled?
	{
		tmp0 := sym_future_DASH_cancelled_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Returns true if future f is cancelled", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(7025), kw_end_DASH_line, int(7025))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "isCancelled")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "isCancelled")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_future_DASH_cancelled_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_future_DASH_cancelled_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-done?
	{
		tmp0 := sym_future_DASH_done_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Returns true if future f is done", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(6538), kw_end_DASH_line, int(6538))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "isDone")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "isDone")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_future_DASH_done_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_future_DASH_done_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// gen-class
	{
		tmp0 := sym_gen_DASH_class.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5732), kw_column, int(10), kw_end_DASH_line, int(5732), kw_end_DASH_column, int(18), kw_declared, true, kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core_gen_DASH_class = ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_gen_DASH_class.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-method
	{
		tmp0 := sym_get_DASH_method.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn, sym_dispatch_DASH_val)), kw_doc, "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(1815), kw_end_DASH_line, int(1815))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "getMethod")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("getMethod is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_get_DASH_method = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_get_DASH_method.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-thread-bindings
	{
		tmp0 := sym_get_DASH_thread_DASH_bindings.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Get a map with the Var/value pairs which is currently in effect for the\n  current thread.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(1937), kw_end_DASH_line, int(1937))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := lang.Apply(nil, nil)
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_get_DASH_thread_DASH_bindings = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_get_DASH_thread_DASH_bindings.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-validator
	{
		tmp0 := sym_get_DASH_validator.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_iref)), kw_doc, "Gets the validator-fn for a var/ref/agent/atom.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(2392), kw_end_DASH_line, int(2392))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(v2, "getValidator")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("getValidator is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_get_DASH_validator = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_get_DASH_validator.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// global-hierarchy
	{
		tmp0 := sym_global_DASH_hierarchy.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(5513), kw_column, int(6), kw_end_DASH_line, int(5514), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core_global_DASH_hierarchy = ns.InternWithValue(tmp0, lang.NewMap(kw_parents, lang.NewMap(), kw_descendants, lang.NewMap(), kw_ancestors, lang.NewMap()), true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_global_DASH_hierarchy.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash
	{
		tmp0 := sym_hash.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns the hash code of its argument. Note this is the hash code\n  consistent with =, and thus is different than .hashCode for Integer,\n  Short, Byte and Clojure collections.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(5189), kw_end_DASH_line, int(5189))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(lang.HashEq, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_hash = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_hash.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-map
	{
		tmp0 := sym_hash_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym__AMP_, sym_keyvals)), kw_doc, "keyval => key val\n  Returns a new hash map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(378), kw_end_DASH_line, int(378))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := lang.NewMap()
				tmp3 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(384), kw_column, int(7), kw_end_DASH_line, int(384), kw_end_DASH_column, int(8))
				tmp4, err := lang.WithMeta(tmp2, tmp3.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp4
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := lang.Apply(lang.CreatePersistentHashMap, []any{v2})
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_hash_DASH_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_hash_DASH_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-ordered-coll
	{
		tmp0 := sym_hash_DASH_ordered_DASH_coll.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://glojure.org/data_structures#hash for full algorithms.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(5210), kw_end_DASH_line, int(5210))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(nil, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_hash_DASH_ordered_DASH_coll = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_hash_DASH_ordered_DASH_coll.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-set
	{
		tmp0 := sym_hash_DASH_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym__AMP_, sym_keys)), kw_doc, "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(388), kw_end_DASH_line, int(388))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp3 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(393), kw_column, int(7), kw_end_DASH_line, int(393), kw_end_DASH_column, int(9))
				tmp4, err := lang.WithMeta(tmp2, tmp3.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp4
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := lang.Apply(nil, []any{v2})
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_hash_DASH_set = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_hash_DASH_set.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-unordered-coll
	{
		tmp0 := sym_hash_DASH_unordered_DASH_coll.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://glojure.org/data_structures#hash for full algorithms.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(5219), kw_end_DASH_line, int(5219))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(nil, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_hash_DASH_unordered_DASH_coll = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_hash_DASH_unordered_DASH_coll.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// identity
	{
		tmp0 := sym_identity.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns its argument.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1446), kw_end_DASH_line, int(1446))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			return v2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_identity = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_identity.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inst-ms
	{
		tmp0 := sym_inst_DASH_ms.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_inst)), kw_doc, "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6831), kw_end_DASH_line, int(6831))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(nil, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_inst_DASH_ms = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_inst_DASH_ms.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inst?
	{
		tmp0 := sym_inst_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x satisfies Inst", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(6837), kw_end_DASH_line, int(6837))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			return nil
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_inst_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_inst_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// instance?
	{
		tmp0 := sym_instance_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_c, sym_x)), kw_doc, "Evaluates x and tests if it is an instance of the type\n    t. Returns true or false", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(2), kw_line, int(139), kw_end_DASH_line, int(143))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function instance?
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.HasType, []any{v3, v4})
				return tmp5
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(143), kw_column, int(12), kw_end_DASH_line, int(143), kw_end_DASH_column, int(85))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_instance_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_instance_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int?
	{
		tmp0 := sym_int_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a fixed precision integer", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1395), kw_end_DASH_line, int(1395))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "or__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{lang.Builtins["int64"], v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					tmp7 = v6
				} else {
					var tmp8 any
					{ // let
						// let binding "or__0__auto__"
						tmp9 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp10 := lang.Apply(tmp9, []any{nil, v2})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							tmp12 = v11
						} else {
							var tmp13 any
							{ // let
								// let binding "or__0__auto__"
								tmp14 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
								tmp15 := lang.Apply(tmp14, []any{nil, v2})
								var v16 any = tmp15
								_ = v16
								var tmp17 any
								if lang.IsTruthy(v16) {
									tmp17 = v16
								} else {
									tmp18 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
									tmp19 := lang.Apply(tmp18, []any{nil, v2})
									tmp17 = tmp19
								}
								tmp13 = tmp17
							} // end let
							tmp12 = tmp13
						}
						tmp8 = tmp12
					} // end let
					tmp7 = tmp8
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_int_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_int_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// integer?
	{
		tmp0 := sym_integer_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is an integer", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1379), kw_end_DASH_line, int(1379))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(lang.IsInteger, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_integer_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_integer_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iterate
	{
		tmp0 := sym_iterate.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_x)), kw_doc, "Returns a lazy (infinite!) sequence of x, (f x), (f (f x)) etc.\n  f must be free of side-effects", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3011), kw_end_DASH_line, int(3011))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v2, v3})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_iterate = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_iterate.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iterator-seq
	{
		tmp0 := sym_iterator_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_iter)), kw_doc, "Returns a seq on a java.util.Iterator. Note that most collections\n  providing iterators implement Iterable and thus support seq directly.\n  Seqs cache values, thus iterator-seq should not be used on any\n  iterator that repeatedly returns the same mutable object.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(5700), kw_end_DASH_line, int(5700))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(nil, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_iterator_DASH_seq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_iterator_DASH_seq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// key
	{
		tmp0 := sym_key.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_e)), kw_doc, "Returns the key of the map entry.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1563), kw_end_DASH_line, int(1563))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(v2, "GetKey")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("GetKey is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_key = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_key.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keys
	{
		tmp0 := sym_keys.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map)), kw_doc, "Returns a sequence of the map's keys, in the same order as (seq map).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1551), kw_end_DASH_line, int(1551))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(lang.Keys, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_keys = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_keys.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keyword?
	{
		tmp0 := sym_keyword_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a Keyword", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(563), kw_end_DASH_line, int(563))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_keyword_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_keyword_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// line-seq
	{
		tmp0 := sym_line_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_rdr)), kw_doc, "Returns the lines of text from rdr as a lazy sequence of strings.\n  rdr must implement java.io.BufferedReader.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(3068), kw_end_DASH_line, int(3068))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4, ok := lang.FieldOrMethod(v2, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "readLine")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "line"
						var v9 any = v6
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_cons)
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							tmp12 := checkDerefVar(var_glojure_DOT_core_line_DASH_seq)
							tmp13 := lang.Apply(tmp12, []any{v2})
							return tmp13
						})
						tmp12 := lang.Apply(lang.NewLazySeq, []any{tmp11})
						tmp13 := lang.Apply(tmp10, []any{v9, tmp12})
						tmp8 = tmp13
					} // end let
					tmp7 = tmp8
				} else {
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_line_DASH_seq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_line_DASH_seq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list
	{
		tmp0 := sym_list.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_items)), kw_doc, "Creates a new list containing the items.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(15), kw_end_DASH_line, int(18))).(*lang.Symbol)
		var_glojure_DOT_core_list = ns.InternWithValue(tmp0, lang.NewList, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_list.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list?
	{
		tmp0 := sym_list_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x implements IPersistentList", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(6198), kw_end_DASH_line, int(6198))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.IPersistentList)(nil)).Elem()
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_list_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_list_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-file
	{
		tmp0 := sym_load_DASH_file.WithMeta(lang.NewMap(kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core_load_DASH_file = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_load_DASH_file.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-reader
	{
		tmp0 := sym_load_DASH_reader.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_rdr)), kw_doc, "Sequentially read and evaluate the set of forms contained in the\n  stream/file", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(4081), kw_end_DASH_line, int(4081))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(runtime.Compiler, "load")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("load is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_load_DASH_reader = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_load_DASH_reader.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-string
	{
		tmp0 := sym_load_DASH_string.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Sequentially read and evaluate the set of forms contained in the\n  string", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(4088), kw_end_DASH_line, int(4088))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "rdr"
				tmp4 := lang.Apply(nil, []any{v2})
				tmp5 := lang.Apply(nil, []any{tmp4})
				var v6 any = tmp5
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_load_DASH_reader)
				tmp8 := lang.Apply(tmp7, []any{v6})
				tmp3 = tmp8
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_load_DASH_string = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_load_DASH_string.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// macroexpand-1
	{
		tmp0 := sym_macroexpand_DASH_1.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_form)), kw_doc, "If form represents a macro form, returns its expansion,\n  else returns form.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(4017), kw_end_DASH_line, int(4017))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(runtime.Compiler, "macroexpand1")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("macroexpand1 is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_macroexpand_DASH_1 = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_macroexpand_DASH_1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-hierarchy
	{
		tmp0 := sym_make_DASH_hierarchy.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Creates a hierarchy object for use with derive, isa? etc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(5507), kw_end_DASH_line, int(5507))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := lang.NewMap()
			tmp3 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5511), kw_column, int(16), kw_end_DASH_line, int(5511), kw_end_DASH_column, int(17))
			tmp4, err := lang.WithMeta(tmp2, tmp3.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp5 := lang.NewMap()
			tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5511), kw_column, int(32), kw_end_DASH_line, int(5511), kw_end_DASH_column, int(33))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp8 := lang.NewMap()
			tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5511), kw_column, int(46), kw_end_DASH_line, int(5511), kw_end_DASH_column, int(47))
			tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp11 := lang.NewMap(kw_parents, tmp4, kw_descendants, tmp7, kw_ancestors, tmp10)
			tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5511), kw_column, int(6), kw_end_DASH_line, int(5511), kw_end_DASH_column, int(48))
			tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp13
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_make_DASH_hierarchy = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_make_DASH_hierarchy.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map-entry?
	{
		tmp0 := sym_map_DASH_entry_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a map entry", kw_file, "glojure/core.glj", kw_added, "1.8", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(1473), kw_end_DASH_line, int(1473))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.MapEntry)(nil)).Elem()
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_map_DASH_entry_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_map_DASH_entry_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map?
	{
		tmp0 := sym_map_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x implements IPersistentMap", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(167), kw_end_DASH_line, int(171))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function map?
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp5 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(171), kw_column, int(7), kw_end_DASH_line, int(171), kw_end_DASH_column, int(97))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_map_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_map_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-mask-bits
	{
		tmp0 := sym_max_DASH_mask_DASH_bits.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(6601), kw_column, int(6), kw_end_DASH_line, int(6601), kw_end_DASH_column, int(28), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core_max_DASH_mask_DASH_bits = ns.InternWithValue(tmp0, int64(13), true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_max_DASH_mask_DASH_bits.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-switch-table-size
	{
		tmp0 := sym_max_DASH_switch_DASH_table_DASH_size.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(6602), kw_column, int(6), kw_end_DASH_line, int(6602), kw_end_DASH_column, int(36), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core_max_DASH_switch_DASH_table_DASH_size = ns.InternWithValue(tmp0, int64(8192), true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_max_DASH_switch_DASH_table_DASH_size.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// meta
	{
		tmp0 := sym_meta.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_obj)), kw_doc, "Returns the metadata of obj, returns nil if there is no metadata.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(202), kw_end_DASH_line, int(206))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function meta
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.IMeta)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
				if lang.IsTruthy(tmp7) {
					tmp8, ok := lang.FieldOrMethod(v3, "Meta")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Meta")))
					}
					var tmp9 any
					switch reflect.TypeOf(tmp8).Kind() {
					case reflect.Func:
						tmp9 = lang.Apply(tmp8, nil)
					default:
						tmp9 = tmp8
					}
					tmp4 = tmp9
				} else {
				}
				return tmp4
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(206), kw_column, int(7), kw_end_DASH_line, int(208), kw_end_DASH_column, int(21))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_meta = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_meta.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// methods
	{
		tmp0 := sym_methods.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn)), kw_doc, "Given a multimethod, returns a map of dispatch values -> dispatch fns", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1809), kw_end_DASH_line, int(1809))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "getMethodTable")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getMethodTable")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_methods = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_methods.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mix-collection-hash
	{
		tmp0 := sym_mix_DASH_collection_DASH_hash.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_hash_DASH_basis, sym_count)), kw_doc, "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://glojure.org/data_structures#hash for full algorithms.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(5199), kw_end_DASH_line, int(5199))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v2, v3})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_mix_DASH_collection_DASH_hash = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_mix_DASH_collection_DASH_hash.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mk-bound-fn
	{
		tmp0 := sym_mk_DASH_bound_DASH_fn.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5127), kw_column, int(7), kw_end_DASH_line, int(5127), kw_end_DASH_column, int(17), kw_arglists, lang.NewList(lang.NewVector(sym_sc, sym_test, sym_key)), kw_private, true, kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 lang.FnFunc
			tmp5 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v6 := args[0]
				_ = v6
				tmp7, ok := lang.FieldOrMethod(v2, "comparator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "comparator")))
				}
				var tmp8 any
				switch reflect.TypeOf(tmp7).Kind() {
				case reflect.Func:
					tmp8 = lang.Apply(tmp7, nil)
				default:
					tmp8 = tmp7
				}
				tmp9, _ := lang.FieldOrMethod(v2, "entryKey")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("entryKey is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{v6})
				tmp11, _ := lang.FieldOrMethod(tmp8, "compare")
				if reflect.TypeOf(tmp11).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("compare is not a function")))
				}
				tmp12 := lang.Apply(tmp11, []any{tmp10, v4})
				tmp13 := lang.Apply(v3, []any{tmp12, int64(0)})
				return tmp13
			})
			tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5130), kw_column, int(3), kw_end_DASH_line, int(5131), kw_end_DASH_column, int(64))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_mk_DASH_bound_DASH_fn = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_mk_DASH_bound_DASH_fn.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// namespace
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_namespace.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns the namespace String of a symbol or keyword, or nil if not present.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(1593), kw_end_DASH_line, int(1593))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "Namespace")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Namespace is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_namespace = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_namespace.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// next
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := sym_next.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(55), kw_end_DASH_line, int(61))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function next
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(lang.Next, []any{v4})
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(61), kw_column, int(7), kw_end_DASH_line, int(61), kw_end_DASH_column, int(77))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		var_glojure_DOT_core_next = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_next.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nfirst
	{
		tmp0 := sym_nfirst.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Same as (next (first x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(2), kw_line, int(105), kw_end_DASH_line, int(109))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function nfirst
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_next)
				tmp5 := checkDerefVar(var_glojure_DOT_core_first)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(tmp4, []any{tmp6})
				return tmp7
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(109), kw_column, int(9), kw_end_DASH_line, int(109), kw_end_DASH_column, int(49))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_nfirst = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_nfirst.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nil?
	{
		tmp1 := reflect.TypeOf(false)
		var tmp2 lang.FnFunc
		{ // function nil?__inliner
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_list)
				tmp6 := lang.Apply(tmp5, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Identical, v4, nil})
				return tmp6
			})
			v3 = tmp2
			_ = v3
		}
		tmp0 := sym_nil_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp2, kw_doc, "Returns true if x is nil, false otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(435), kw_end_DASH_line, int(435))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.IsNil, []any{v4})
			return tmp5
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		var_glojure_DOT_core_nil_QMARK_ = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_nil_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nnext
	{
		tmp0 := sym_nnext.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Same as (next (next x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(119), kw_end_DASH_line, int(123))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function nnext
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_next)
				tmp5 := checkDerefVar(var_glojure_DOT_core_next)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(tmp4, []any{tmp6})
				return tmp7
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(123), kw_column, int(8), kw_end_DASH_line, int(123), kw_end_DASH_column, int(46))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_nnext = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_nnext.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_not.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is logical false, false otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(523), kw_end_DASH_line, int(523))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			if lang.IsTruthy(v3) {
				tmp4 = false
			} else {
				tmp4 = true
			}
			return tmp4
		})
		tmp3 := reflect.TypeOf(false)
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_not = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_not.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// number?
	{
		tmp0 := sym_number_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is a Number", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3560), kw_end_DASH_line, int(3560))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(lang.IsNumber, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_number_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_number_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// numerator
	{
		tmp1 := reflect.TypeOf((*big9.Int)(nil))
		tmp0 := sym_numerator.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_r)), kw_doc, "Returns the numerator part of a Ratio.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3583), kw_end_DASH_line, int(3583))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "numerator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "numerator")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp3 := reflect.TypeOf((*big9.Int)(nil))
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_numerator = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_numerator.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// peek
	{
		tmp0 := sym_peek.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1455), kw_end_DASH_line, int(1455))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(runtime.RT, "Peek")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Peek is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_peek = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_peek.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// persistent!
	{
		tmp0 := sym_persistent_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(3350), kw_end_DASH_line, int(3350))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "Persistent")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "Persistent")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_persistent_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_persistent_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop
	{
		tmp0 := sym_pop.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item. If\n  the collection is empty, throws an exception.  Note - not the same\n  as next/butlast.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1462), kw_end_DASH_line, int(1462))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(runtime.RT, "Pop")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Pop is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_pop = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_pop.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop!
	{
		tmp0 := sym_pop_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3393), kw_end_DASH_line, int(3393))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "pop")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "pop")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_pop_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_pop_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop-thread-bindings
	{
		tmp0 := sym_pop_DASH_thread_DASH_bindings.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Pop one set of bindings pushed with push-binding before. It is an error to\n  pop bindings without pushing before.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(1929), kw_end_DASH_line, int(1929))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := lang.Apply(lang.PopThreadBindings, nil)
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_pop_DASH_thread_DASH_bindings = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_pop_DASH_thread_DASH_bindings.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prefer-method
	{
		tmp0 := sym_prefer_DASH_method.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn, sym_dispatch_DASH_val_DASH_x, sym_dispatch_DASH_val_DASH_y)), kw_doc, "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \n   when there is a conflict", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1801), kw_end_DASH_line, int(1801))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v2, "PreferMethod")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("PreferMethod is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_prefer_DASH_method = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_prefer_DASH_method.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prefers
	{
		tmp0 := sym_prefers.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn)), kw_doc, "Given a multimethod, returns a map of preferred value -> set of other values", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1822), kw_end_DASH_line, int(1822))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "getPreferTable")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getPreferTable")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_prefers = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_prefers.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-initialized
	{
		tmp0 := sym_print_DASH_initialized.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core_print.glj", kw_line, int(520), kw_column, int(6), kw_end_DASH_line, int(520), kw_end_DASH_column, int(39), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core_print_DASH_initialized = ns.InternWithValue(tmp0, true, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_initialized.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// push-thread-bindings
	{
		tmp0 := sym_push_DASH_thread_DASH_bindings.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_bindings)), kw_doc, "WARNING: This is a low-level function. Prefer high-level macros like\n  binding where ever possible.\n\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\n  the current thread. Each call *MUST* be accompanied by a matching call to\n  pop-thread-bindings wrapped in a try-finally!\n  \n      (push-thread-bindings bindings)\n      (try\n        ...\n        (finally\n          (pop-thread-bindings)))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(26), kw_column, int(7), kw_line, int(1911), kw_end_DASH_line, int(1911))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(lang.PushThreadBindings, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_push_DASH_thread_DASH_bindings = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_push_DASH_thread_DASH_bindings.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// random-uuid
	{
		tmp0 := sym_random_DASH_uuid.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a pseudo-randomly generated java.util.UUID instance (i.e. type 4).\n\n  See: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#randomUUID--", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(6852), kw_end_DASH_line, int(6852))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := lang.Apply(uuid13.NewV7, nil)
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_random_DASH_uuid = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_random_DASH_uuid.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ratio?
	{
		tmp0 := sym_ratio_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is a Ratio", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3577), kw_end_DASH_line, int(3577))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.Ratio)(nil))
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ratio_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ratio_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rationalize
	{
		tmp0 := sym_rationalize.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_doc, "returns the rational value of num", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(1282), kw_end_DASH_line, int(1282))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(lang.Numbers, "rationalize")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("rationalize is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_rationalize = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_rationalize.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-matcher
	{
		tmp1 := reflect.TypeOf((*lang.RegexpMatcher)(nil))
		tmp0 := sym_re_DASH_matcher.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_re, sym_s)), kw_doc, "Returns an instance of java.util.regex.Matcher, for use, e.g. in\n  re-find.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4873), kw_end_DASH_line, int(4873))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(lang.NewRegexpMatcher, []any{v3, v4})
			return tmp5
		})
		tmp3 := reflect.TypeOf((*lang.RegexpMatcher)(nil))
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_re_DASH_matcher = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_re_DASH_matcher.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-pattern
	{
		tmp1 := reflect.TypeOf((*regexp15.Regexp)(nil))
		tmp0 := sym_re_DASH_pattern.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Returns an instance of java.util.regex.Pattern, for use, e.g. in\n  re-matcher.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4863), kw_end_DASH_line, int(4863))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp6 := reflect.TypeOf((*regexp15.Regexp)(nil))
			tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
			if lang.IsTruthy(tmp7) {
				tmp4 = v3
			} else {
				tmp8 := lang.Apply(regexp15.MustCompile, []any{v3})
				tmp4 = tmp8
			}
			return tmp4
		})
		tmp3 := reflect.TypeOf((*regexp15.Regexp)(nil))
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_re_DASH_pattern = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_re_DASH_pattern.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read-string
	{
		tmp0 := sym_read_DASH_string.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s), lang.NewVector(sym_opts, sym_s)), kw_doc, "Reads one object from the string s. Optionally include reader\n  options, as specified in read.\n\n  Note that read-string can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use glojure.edn/read-string", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(3806), kw_end_DASH_line, int(3806))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := lang.Apply(runtime.RTReadString, []any{v2})
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := lang.Apply(runtime.RTReadString, []any{v3, v2})
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_read_DASH_string = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_read_DASH_string.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reader-conditional
	{
		tmp0 := sym_reader_DASH_conditional.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_form, sym_splicing_QMARK_)), kw_doc, "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(7782), kw_end_DASH_line, int(7782))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v2, v3})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reader_DASH_conditional = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reader_DASH_conditional.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reader-conditional?
	{
		tmp0 := sym_reader_DASH_conditional_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_value)), kw_doc, "Return true if the value is the data representation of a reader conditional", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(7776), kw_end_DASH_line, int(7776))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{nil, v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reader_DASH_conditional_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reader_DASH_conditional_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// realized?
	{
		tmp0 := sym_realized_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(7559), kw_end_DASH_line, int(7559))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "isRealized")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "isRealized")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_realized_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_realized_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduced
	{
		tmp0 := sym_reduced.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Wraps x in a way such that a reduce will terminate with the value x", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(2828), kw_end_DASH_line, int(2828))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(lang.NewReduced, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reduced = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reduced.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-history-count
	{
		tmp0 := sym_ref_DASH_history_DASH_count.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref)), kw_doc, "Returns the history count of a ref", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(2455), kw_end_DASH_line, int(2455))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "getHistoryCount")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getHistoryCount")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ref_DASH_history_DASH_count = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ref_DASH_history_DASH_count.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-max-history
	{
		tmp0 := sym_ref_DASH_max_DASH_history.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref), lang.NewVector(sym_ref, sym_n)), kw_doc, "Gets the max-history of a ref, or sets it and returns the ref", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(2471), kw_end_DASH_line, int(2471))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3, ok := lang.FieldOrMethod(v2, "getMaxHistory")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getMaxHistory")))
				}
				var tmp4 any
				switch reflect.TypeOf(tmp3).Kind() {
				case reflect.Func:
					tmp4 = lang.Apply(tmp3, nil)
				default:
					tmp4 = tmp3
				}
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(v2, "setMaxHistory")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMaxHistory is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ref_DASH_max_DASH_history = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ref_DASH_max_DASH_history.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-min-history
	{
		tmp0 := sym_ref_DASH_min_DASH_history.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref), lang.NewVector(sym_ref, sym_n)), kw_doc, "Gets the min-history of a ref, or sets it and returns the ref", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(2462), kw_end_DASH_line, int(2462))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3, ok := lang.FieldOrMethod(v2, "getMinHistory")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getMinHistory")))
				}
				var tmp4 any
				switch reflect.TypeOf(tmp3).Kind() {
				case reflect.Func:
					tmp4 = lang.Apply(tmp3, nil)
				default:
					tmp4 = tmp3
				}
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(v2, "setMinHistory")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMinHistory is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ref_DASH_min_DASH_history = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ref_DASH_min_DASH_history.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-set
	{
		tmp0 := sym_ref_DASH_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref, sym_val)), kw_doc, "Must be called in a transaction. Sets the value of ref.\n  Returns val.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(2447), kw_end_DASH_line, int(2447))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "set")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("set is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ref_DASH_set = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ref_DASH_set.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// release-pending-sends
	{
		tmp0 := sym_release_DASH_pending_DASH_sends.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Normally, actions sent directly or indirectly during another action\n  are held until the action completes (changes the agent's\n  state). This function can be used to dispatch any pending sent\n  actions immediately. This has no impact on actions sent during a\n  transaction, which are still held until commit. If no action is\n  occurring, does nothing. Returns the number of actions dispatched.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(27), kw_column, int(7), kw_line, int(2131), kw_end_DASH_line, int(2131))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := lang.Apply(nil, nil)
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_release_DASH_pending_DASH_sends = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_release_DASH_pending_DASH_sends.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-all-methods
	{
		tmp0 := sym_remove_DASH_all_DASH_methods.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn)), kw_doc, "Removes all of the methods of multimethod.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(1787), kw_end_DASH_line, int(1787))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "reset")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "reset")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_remove_DASH_all_DASH_methods = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_remove_DASH_all_DASH_methods.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-method
	{
		tmp0 := sym_remove_DASH_method.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn, sym_dispatch_DASH_val)), kw_doc, "Removes the method of multimethod associated with dispatch-value.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1794), kw_end_DASH_line, int(1794))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "removeMethod")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeMethod is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_remove_DASH_method = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_remove_DASH_method.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-ns
	{
		tmp0 := sym_remove_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_doc, "Removes the namespace named by the symbol. Use with caution.\n  Cannot be used to remove the glojure namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4139), kw_end_DASH_line, int(4139))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(lang.RemoveNamespace, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_remove_DASH_ns = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_remove_DASH_ns.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-watch
	{
		tmp0 := sym_remove_DASH_watch.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_reference, sym_key)), kw_doc, "Removes a watch (set by add-watch) from a reference", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(2160), kw_end_DASH_line, int(2160))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "removeWatch")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeWatch is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_remove_DASH_watch = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_remove_DASH_watch.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// repeat
	{
		tmp0 := sym_repeat.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_n, sym_x)), kw_doc, "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2997), kw_end_DASH_line, int(2997))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := lang.Apply(lang.NewRepeat, []any{v2})
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := lang.Apply(lang.NewRepeatN, []any{v2, v3})
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_repeat = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_repeat.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset!
	{
		tmp0 := sym_reset_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atom, sym_newval)), kw_doc, "Sets the value of atom to newval without regard for the\n  current value. Returns newval.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2368), kw_end_DASH_line, int(2368))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "reset")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reset_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reset_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset-meta!
	{
		tmp0 := sym_reset_DASH_meta_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_iref, sym_metadata_DASH_map)), kw_doc, "Atomically resets the metadata for a namespace/var/ref/agent/atom", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(2408), kw_end_DASH_line, int(2408))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "ResetMeta")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ResetMeta is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reset_DASH_meta_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reset_DASH_meta_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset-vals!
	{
		tmp0 := sym_reset_DASH_vals_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atom, sym_newval)), kw_doc, "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(2375), kw_end_DASH_line, int(2375))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "resetVals")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("resetVals is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reset_DASH_vals_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reset_DASH_vals_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rest
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := sym_rest.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(64), kw_end_DASH_line, int(70))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function rest
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(lang.Rest, []any{v4})
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(70), kw_column, int(7), kw_end_DASH_line, int(70), kw_end_DASH_column, int(77))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		var_glojure_DOT_core_rest = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_rest.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reversible?
	{
		tmp0 := sym_reversible_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll implements Reversible", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(6257), kw_end_DASH_line, int(6257))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{nil, v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reversible_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reversible_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rseq
	{
		tmp0 := sym_rseq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_rev)), kw_doc, "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1577), kw_end_DASH_line, int(1577))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(v2, "rseq")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("rseq is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_rseq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_rseq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// second
	{
		tmp0 := sym_second.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Same as (first (next x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(2), kw_line, int(91), kw_end_DASH_line, int(95))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function second
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_first)
				tmp5 := checkDerefVar(var_glojure_DOT_core_next)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(tmp4, []any{tmp6})
				return tmp7
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(95), kw_column, int(9), kw_end_DASH_line, int(95), kw_end_DASH_column, int(49))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_second = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_second.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := sym_seq.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a seq on the collection. If the collection is\n    empty, returns nil.  (seq nil) returns nil. seq also works on\n    Strings, native Java arrays (of reference types) and any objects\n    that implement Iterable. Note that seqs cache values, thus seq\n    should not be used on any Iterable whose iterator repeatedly\n    returns the same mutable object.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(4), kw_column, int(2), kw_line, int(126), kw_end_DASH_line, int(136))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function seq
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(lang.Seq, []any{v4})
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(136), kw_column, int(6), kw_end_DASH_line, int(136), kw_end_DASH_column, int(126))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		var_glojure_DOT_core_seq = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_seq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq?
	{
		tmp0 := sym_seq_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x implements ISeq", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(146), kw_end_DASH_line, int(150))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function seq?
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp5 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(150), kw_column, int(7), kw_end_DASH_line, int(150), kw_end_DASH_column, int(87))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_seq_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_seq_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seqable?
	{
		tmp0 := sym_seqable_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if the seq function is supported for x", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(6204), kw_end_DASH_line, int(6204))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(nil, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_seqable_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_seqable_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sequential?
	{
		tmp0 := sym_sequential_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll implements Sequential", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(6229), kw_end_DASH_line, int(6229))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.Sequential)(nil)).Elem()
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_sequential_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_sequential_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-agent-send-executor!
	{
		tmp0 := sym_set_DASH_agent_DASH_send_DASH_executor_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_executor)), kw_doc, "Sets the ExecutorService to be used by send", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(30), kw_column, int(7), kw_line, int(2087), kw_end_DASH_line, int(2087))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			return "unimplemented: set! target type"
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_set_DASH_agent_DASH_send_DASH_executor_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_set_DASH_agent_DASH_send_DASH_executor_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-agent-send-off-executor!
	{
		tmp0 := sym_set_DASH_agent_DASH_send_DASH_off_DASH_executor_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_executor)), kw_doc, "Sets the ExecutorService to be used by send-off", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(34), kw_column, int(7), kw_line, int(2093), kw_end_DASH_line, int(2093))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			return "unimplemented: set! target type"
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_set_DASH_agent_DASH_send_DASH_off_DASH_executor_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_set_DASH_agent_DASH_send_DASH_off_DASH_executor_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-error-handler!
	{
		tmp0 := sym_set_DASH_error_DASH_handler_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_handler_DASH_fn)), kw_doc, "Sets the error-handler of agent a to handler-fn.  If an action\n  being run by the agent throws an exception or doesn't pass the\n  validator fn, handler-fn will be called with two arguments: the\n  agent and the exception.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(2192), kw_end_DASH_line, int(2192))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "setErrorHandler")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorHandler is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_set_DASH_error_DASH_handler_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_set_DASH_error_DASH_handler_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-error-mode!
	{
		tmp0 := sym_set_DASH_error_DASH_mode_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_mode_DASH_keyword)), kw_doc, "Sets the error-mode of agent a to mode-keyword, which must be\n  either :fail or :continue.  If an action being run by the agent\n  throws an exception or doesn't pass the validator fn, an\n  error-handler may be called (see set-error-handler!), after which,\n  if the mode is :continue, the agent will continue as if neither the\n  action that caused the error nor the error itself ever happened.\n  \n  If the mode is :fail, the agent will become failed and will stop\n  accepting new 'send' and 'send-off' actions, and any previously\n  queued actions will be held until a 'restart-agent'.  Deref will\n  still work, returning the state of the agent before the error.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(2210), kw_end_DASH_line, int(2210))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "setErrorMode")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorMode is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_set_DASH_error_DASH_mode_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_set_DASH_error_DASH_mode_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-validator!
	{
		tmp0 := sym_set_DASH_validator_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_iref, sym_validator_DASH_fn)), kw_doc, "Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an exception. If the current state (root\n  value if var) is not acceptable to the new validator, an exception\n  will be thrown and the validator will not be changed.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(2381), kw_end_DASH_line, int(2381))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "setValidator")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setValidator is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_set_DASH_validator_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_set_DASH_validator_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set?
	{
		tmp0 := sym_set_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x implements IPersistentSet", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(4098), kw_end_DASH_line, int(4098))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.IPersistentSet)(nil)).Elem()
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_set_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_set_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shutdown-agents
	{
		tmp0 := sym_shutdown_DASH_agents.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Initiates a shutdown of the thread pools that back the agent\n  system. Running actions will complete, but no new actions will be\n  accepted", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(2252), kw_end_DASH_line, int(2252))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := lang.Apply(lang.ShutdownAgents, nil)
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_shutdown_DASH_agents = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_shutdown_DASH_agents.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-keyword?
	{
		tmp0 := sym_simple_DASH_keyword_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a keyword without a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(1633), kw_end_DASH_line, int(1633))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "and__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
					tmp9 := checkDerefVar(var_glojure_DOT_core_namespace)
					tmp10 := lang.Apply(tmp9, []any{v2})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					tmp7 = tmp11
				} else {
					tmp7 = v6
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_simple_DASH_keyword_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_simple_DASH_keyword_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some
	{
		tmp0 := sym_some.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2684), kw_end_DASH_line, int(2684))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
		recur_loop_481:
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "s"
						var v10 any = v7
						_ = v10
						var tmp11 any
						{ // let
							// let binding "or__0__auto__"
							tmp12 := checkDerefVar(var_glojure_DOT_core_first)
							tmp13 := lang.Apply(tmp12, []any{v10})
							tmp14 := lang.Apply(v2, []any{tmp13})
							var v15 any = tmp14
							_ = v15
							var tmp16 any
							if lang.IsTruthy(v15) {
								tmp16 = v15
							} else {
								var tmp17 any = v2
								tmp19 := checkDerefVar(var_glojure_DOT_core_next)
								tmp20 := lang.Apply(tmp19, []any{v10})
								var tmp18 any = tmp20
								v2 = tmp17
								v3 = tmp18
								goto recur_loop_481
							}
							tmp11 = tmp16
						} // end let
						tmp9 = tmp11
					} // end let
					tmp8 = tmp9
				} else {
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_some = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_some.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_some_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is not nil, false otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(530), kw_end_DASH_line, int(530))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_not)
			tmp5 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			return tmp7
		})
		tmp3 := reflect.TypeOf(false)
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_some_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_some_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-map
	{
		tmp0 := sym_sorted_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_keyvals)), kw_doc, "keyval => key val\n  Returns a new sorted map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(397), kw_end_DASH_line, int(397))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := lang.Apply(lang.CreatePersistentTreeMap, []any{v2})
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_sorted_DASH_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_sorted_DASH_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-map-by
	{
		tmp0 := sym_sorted_DASH_map_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_comparator, sym__AMP_, sym_keyvals)), kw_doc, "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.  If any keys are equal, they are handled as if by\n  repeated uses of assoc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(406), kw_end_DASH_line, int(406))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				tmp4 := lang.Apply(nil, []any{v2, v3})
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_sorted_DASH_map_DASH_by = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_sorted_DASH_map_DASH_by.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-set
	{
		tmp0 := sym_sorted_DASH_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_keys)), kw_doc, "Returns a new sorted set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(416), kw_end_DASH_line, int(416))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := lang.Apply(lang.CreatePersistentTreeSet, []any{v2})
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_sorted_DASH_set = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_sorted_DASH_set.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-set-by
	{
		tmp0 := sym_sorted_DASH_set_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_comparator, sym__AMP_, sym_keys)), kw_doc, "Returns a new sorted set with supplied keys, using the supplied\n  comparator.  Any equal keys are handled as if by repeated uses of\n  conj.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(424), kw_end_DASH_line, int(424))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentTreeSetWithComparator, []any{v2, v3})
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_sorted_DASH_set_DASH_by = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_sorted_DASH_set_DASH_by.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted?
	{
		tmp0 := sym_sorted_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll implements Sorted", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6235), kw_end_DASH_line, int(6235))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{nil, v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_sorted_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_sorted_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// special-symbol?
	{
		tmp0 := sym_special_DASH_symbol_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Returns true if s names a special form", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(4992), kw_end_DASH_line, int(4992))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
			tmp4, ok := lang.FieldOrMethod(runtime.Compiler, "specials")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", runtime.Compiler, "specials")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			tmp6 := lang.Apply(tmp3, []any{tmp5, v2})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_special_DASH_symbol_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_special_DASH_symbol_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// spread
	{
		tmp0 := sym_spread.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_arglist)), kw_static, true, kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(632), kw_end_DASH_line, int(632), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
			} else {
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
				tmp8 := checkDerefVar(var_glojure_DOT_core_next)
				tmp9 := lang.Apply(tmp8, []any{v2})
				tmp10 := lang.Apply(tmp7, []any{tmp9})
				if lang.IsTruthy(tmp10) {
					tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp12 := checkDerefVar(var_glojure_DOT_core_first)
					tmp13 := lang.Apply(tmp12, []any{v2})
					tmp14 := lang.Apply(tmp11, []any{tmp13})
					tmp6 = tmp14
				} else {
					var tmp15 any
					if lang.IsTruthy(kw_else) {
						tmp16 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp17 := checkDerefVar(var_glojure_DOT_core_first)
						tmp18 := lang.Apply(tmp17, []any{v2})
						tmp19 := checkDerefVar(var_glojure_DOT_core_spread)
						tmp20 := checkDerefVar(var_glojure_DOT_core_next)
						tmp21 := lang.Apply(tmp20, []any{v2})
						tmp22 := lang.Apply(tmp19, []any{tmp21})
						tmp23 := lang.Apply(tmp16, []any{tmp18, tmp22})
						tmp15 = tmp23
					} else {
					}
					tmp6 = tmp15
				}
				tmp3 = tmp6
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_spread = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_spread.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_str.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_ys)), kw_doc, "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(543), kw_end_DASH_line, int(543))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return ""
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					tmp4 = ""
				} else {
					tmp7 := lang.Apply(lang.ToString, []any{v3})
					tmp4 = tmp7
				}
				return tmp4
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v6 := args[0]
					_ = v6
					v7 := args[1]
					_ = v7
				recur_loop_74:
					var tmp8 any
					if lang.IsTruthy(v7) {
						tmp10 := checkDerefVar(var_glojure_DOT_core_str)
						tmp11 := checkDerefVar(var_glojure_DOT_core_first)
						tmp12 := lang.Apply(tmp11, []any{v7})
						tmp13 := lang.Apply(tmp10, []any{tmp12})
						tmp14, _ := lang.FieldOrMethod(v6, "WriteString")
						if reflect.TypeOf(tmp14).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("WriteString is not a function")))
						}
						tmp15 := lang.Apply(tmp14, []any{tmp13})
						_ = tmp15
						var tmp9 any = v6
						tmp17 := checkDerefVar(var_glojure_DOT_core_next)
						tmp18 := lang.Apply(tmp17, []any{v7})
						var tmp16 any = tmp18
						v6 = tmp9
						v7 = tmp16
						goto recur_loop_74
					} else {
						tmp19, ok := lang.FieldOrMethod(v6, "String")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "String")))
						}
						var tmp20 any
						switch reflect.TypeOf(tmp19).Kind() {
						case reflect.Func:
							tmp20 = lang.Apply(tmp19, nil)
						default:
							tmp20 = tmp19
						}
						tmp8 = tmp20
					}
					return tmp8
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(554), kw_column, int(7), kw_end_DASH_line, int(554), kw_end_DASH_column, int(127))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := new(strings11.Builder)
				tmp9 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10})
				return tmp11
			}
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_str = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-reduce!
	{
		tmp0 := sym_stream_DASH_reduce_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_s), lang.NewVector(sym_f, sym_init, sym_s)), kw_doc, "Works like reduce but takes a java.util.stream.BaseStream as its source.\n  Honors 'reduced', is a terminal operation on the stream", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(6784), kw_end_DASH_line, int(6784))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4, ok := lang.FieldOrMethod(v3, "iterator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "iterator")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				tmp6 := lang.Apply(nil, []any{tmp5, v2})
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5, ok := lang.FieldOrMethod(v4, "iterator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "iterator")))
				}
				var tmp6 any
				switch reflect.TypeOf(tmp5).Kind() {
				case reflect.Func:
					tmp6 = lang.Apply(tmp5, nil)
				default:
					tmp6 = tmp5
				}
				tmp7 := lang.Apply(nil, []any{tmp6, v2, v3})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_stream_DASH_reduce_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_stream_DASH_reduce_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-seq!
	{
		tmp0 := sym_stream_DASH_seq_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_stream)), kw_doc, "Takes a java.util.stream.BaseStream instance s and returns a seq of its\n  contents. This is a terminal operation on the stream.", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(6793), kw_end_DASH_line, int(6793))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_iterator_DASH_seq)
			tmp4, ok := lang.FieldOrMethod(v2, "iterator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "iterator")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			tmp6 := lang.Apply(tmp3, []any{tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_stream_DASH_seq_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_stream_DASH_seq_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-transduce!
	{
		tmp0 := sym_stream_DASH_transduce_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xform, sym_f, sym_stream), lang.NewVector(sym_xform, sym_f, sym_init, sym_stream)), kw_doc, "Works like transduce but takes a java.util.stream.BaseStream as its source.\n  This is a terminal operation on the stream.", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(6800), kw_end_DASH_line, int(6800))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_stream_DASH_transduce_BANG_)
				tmp6 := lang.Apply(v3, nil)
				tmp7 := lang.Apply(tmp5, []any{v2, v3, tmp6, v4})
				return tmp7
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "f"
					tmp7 := lang.Apply(v2, []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "ret"
					tmp9 := checkDerefVar(var_glojure_DOT_core_stream_DASH_reduce_BANG_)
					tmp10 := lang.Apply(tmp9, []any{v8, v4, v5})
					var v11 any = tmp10
					_ = v11
					tmp12 := lang.Apply(v8, []any{v11})
					tmp6 = tmp12
				} // end let
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_stream_DASH_transduce_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_stream_DASH_transduce_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// string?
	{
		tmp0 := sym_string_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a String", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(2), kw_line, int(160), kw_end_DASH_line, int(164))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function string?
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{lang.Builtins["string"], v3})
				return tmp5
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(164), kw_column, int(10), kw_end_DASH_line, int(164), kw_end_DASH_column, int(58))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_string_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_string_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// struct
	{
		tmp0 := sym_struct.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym__AMP_, sym_vals)), kw_doc, "Returns a new structmap instance with the keys of the\n  structure-basis. vals must be supplied for basis keys in order -\n  where values are not supplied they will default to nil.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4061), kw_end_DASH_line, int(4061))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				tmp4 := lang.Apply(lang.ConstructPersistentStructMap, []any{v2, v3})
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_struct = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_struct.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// struct-map
	{
		tmp0 := sym_struct_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym__AMP_, sym_inits)), kw_doc, "Returns a new structmap instance with the keys of the\n  structure-basis. keyvals may contain all, some or none of the basis\n  keys - where values are not supplied they will default to nil.\n  keyvals can also contain keys not in the basis.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4051), kw_end_DASH_line, int(4051))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentStructMap, []any{v2, v3})
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_struct_DASH_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_struct_DASH_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subs
	{
		tmp0 := sym_subs.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_start), lang.NewVector(sym_s, sym_start, sym_end)), kw_doc, "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(5005), kw_end_DASH_line, int(5005))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := lang.Apply(lang.Builtins["slice"], []any{v2, v3})
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := lang.Apply(lang.Builtins["slice"], []any{v2, v3, v4})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_subs = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_subs.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// swap!
	{
		tmp0 := sym_swap_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atom, sym_f, sym__AMP_, sym_args)), kw_doc, "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(2343), kw_end_DASH_line, int(2343))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v2, "swap")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("swap is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_swap_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_swap_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// swap-vals!
	{
		tmp0 := sym_swap_DASH_vals_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atom, sym_f, sym__AMP_, sym_args)), kw_doc, "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(2352), kw_end_DASH_line, int(2352))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v2, "swapVals")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("swapVals is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_swap_DASH_vals_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_swap_DASH_vals_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// symbol?
	{
		tmp0 := sym_symbol_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a Symbol", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(557), kw_end_DASH_line, int(557))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.Symbol)(nil))
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_symbol_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_symbol_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// system-newline
	{
		tmp0 := sym_system_DASH_newline.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(3695), kw_column, int(6), kw_end_DASH_line, int(3695), kw_end_DASH_column, int(40), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core_system_DASH_newline = ns.InternWithValue(tmp0, "\n", true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_system_DASH_newline.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tagged-literal
	{
		tmp0 := sym_tagged_DASH_literal.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag, sym_form)), kw_doc, "Construct a data representation of a tagged literal from a\n  tag symbol and a form.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(7769), kw_end_DASH_line, int(7769))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v2, v3})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_tagged_DASH_literal = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_tagged_DASH_literal.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tagged-literal?
	{
		tmp0 := sym_tagged_DASH_literal_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_value)), kw_doc, "Return true if the value is the data representation of a tagged literal", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(7763), kw_end_DASH_line, int(7763))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{nil, v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_tagged_DASH_literal_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_tagged_DASH_literal_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-while
	{
		tmp0 := sym_take_DASH_while.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred), lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(2880), kw_end_DASH_line, int(2880))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp6 := lang.Apply(v4, nil)
							return tmp6
						case 1:
							v6 := args[0]
							_ = v6
							tmp7 := lang.Apply(v4, []any{v6})
							return tmp7
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							var tmp8 any
							tmp9 := lang.Apply(v2, []any{v7})
							if lang.IsTruthy(tmp9) {
								tmp10 := lang.Apply(v4, []any{v6, v7})
								tmp8 = tmp10
							} else {
								tmp11 := checkDerefVar(var_glojure_DOT_core_reduced)
								tmp12 := lang.Apply(tmp11, []any{v6})
								tmp8 = tmp12
							}
							return tmp8
						default:
							checkArity(args, -1)
							panic("unreachable")
						}
					})
					tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2888), kw_column, int(8), kw_end_DASH_line, int(2894), kw_end_DASH_column, int(33))
					tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp7
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2887), kw_column, int(6), kw_end_DASH_line, int(2894), kw_end_DASH_column, int(34))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp5 any
					{ // let
						// let binding "temp__0__auto__"
						tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp7 := lang.Apply(tmp6, []any{v3})
						var v8 any = tmp7
						_ = v8
						var tmp9 any
						if lang.IsTruthy(v8) {
							var tmp10 any
							{ // let
								// let binding "s"
								var v11 any = v8
								_ = v11
								var tmp12 any
								tmp13 := checkDerefVar(var_glojure_DOT_core_first)
								tmp14 := lang.Apply(tmp13, []any{v11})
								tmp15 := lang.Apply(v2, []any{tmp14})
								if lang.IsTruthy(tmp15) {
									tmp16 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp17 := checkDerefVar(var_glojure_DOT_core_first)
									tmp18 := lang.Apply(tmp17, []any{v11})
									tmp19 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
									tmp20 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp21 := lang.Apply(tmp20, []any{v11})
									tmp22 := lang.Apply(tmp19, []any{v2, tmp21})
									tmp23 := lang.Apply(tmp16, []any{tmp18, tmp22})
									tmp12 = tmp23
								} else {
								}
								tmp10 = tmp12
							} // end let
							tmp9 = tmp10
						} else {
						}
						tmp5 = tmp9
					} // end let
					return tmp5
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_take_DASH_while = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_take_DASH_while.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tapset
	{
		tmp0 := sym_tapset.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(7882), kw_column, int(10), kw_end_DASH_line, int(7882), kw_end_DASH_column, int(25), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := lang.NewAtom(lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{})))
		var_glojure_DOT_core_tapset = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_tapset.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// test
	{
		tmp0 := sym_test.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_v)), kw_doc, "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(4853), kw_end_DASH_line, int(4853))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "f"
				tmp4 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp5 := lang.Apply(tmp4, []any{v2})
				tmp6 := lang.Apply(kw_test, []any{tmp5})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := lang.Apply(v7, nil)
					_ = tmp9
					tmp8 = kw_ok
				} else {
					tmp8 = kw_no_DASH_test
				}
				tmp3 = tmp8
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_test = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_test.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// the-ns
	{
		tmp0 := sym_the_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "If passed a namespace, returns it. Else, when passed a symbol,\n  returns the namespace named by it, throwing an exception if not\n  found.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4152), kw_end_DASH_line, int(4152))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Namespace)(nil))
			tmp6 := lang.Apply(tmp4, []any{tmp5, v2})
			if lang.IsTruthy(tmp6) {
				tmp3 = v2
			} else {
				var tmp7 any
				{ // let
					// let binding "or__0__auto__"
					tmp8 := checkDerefVar(var_glojure_DOT_core_find_DASH_ns)
					tmp9 := lang.Apply(tmp8, []any{v2})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						tmp11 = v10
					} else {
						tmp12 := checkDerefVar(var_glojure_DOT_core_str)
						tmp13 := lang.Apply(tmp12, []any{"No namespace: ", v2, " found"})
						tmp14 := lang.Apply(lang.NewError, []any{tmp13})
						panic(tmp14)
					}
					tmp7 = tmp11
				} // end let
				tmp3 = tmp7
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_the_DASH_ns = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_the_DASH_ns.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-array
	{
		tmp0 := sym_to_DASH_array.WithMeta(lang.NewMap(kw_tag, "[Ljava.lang.Object;", kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns an array of Objects containing the contents of coll, which\n  can be any Collection.  Maps to java.util.Collection.toArray().", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(337), kw_end_DASH_line, int(337))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(runtime.RT, "ToArray")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ToArray is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, "[Ljava.lang.Object;")).(lang.FnFunc)
		var_glojure_DOT_core_to_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_to_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// transient
	{
		tmp0 := sym_transient.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a new, transient version of the collection, in constant time.\n\n  Transients support a parallel set of 'changing' operations, with similar names\n  followed by ! - assoc!, conj! etc. These do the same things as their persistent\n  counterparts except the return values are themselves transient.\n\n  Note in particular that transients are not designed to be bashed in-place. You\n  must capture and use the return value in the next call. In this way, they support\n  the same code structure as the functional persistent code they replace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3335), kw_end_DASH_line, int(3335))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, ok := lang.FieldOrMethod(v2, "AsTransient")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "AsTransient")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_transient = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_transient.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// true?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_true_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is the value true, false otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(511), kw_end_DASH_line, int(511))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.Identical, []any{v3, true})
			return tmp4
		})
		tmp3 := reflect.TypeOf(false)
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_true_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_true_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unquote
	{
		tmp0 := sym_unquote.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(11), kw_column, int(6), kw_end_DASH_line, int(11), kw_end_DASH_column, int(12), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core_unquote = ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unquote.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unquote-splicing
	{
		tmp0 := sym_unquote_DASH_splicing.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(12), kw_column, int(6), kw_end_DASH_line, int(12), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var_glojure_DOT_core_unquote_DASH_splicing = ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unquote_DASH_splicing.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// uri?
	{
		tmp0 := sym_uri_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a java.net.URI", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(7877), kw_end_DASH_line, int(7877))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*url5.URL)(nil)).Elem()
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_uri_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_uri_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// uuid?
	{
		tmp0 := sym_uuid_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a java.util.UUID", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(6847), kw_end_DASH_line, int(6847))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf([16]uint8{})
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_uuid_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_uuid_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// val
	{
		tmp0 := sym_val.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_e)), kw_doc, "Returns the value in the map entry.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1570), kw_end_DASH_line, int(1570))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(v2, "GetValue")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("GetValue is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_val = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_val.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vals
	{
		tmp0 := sym_vals.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map)), kw_doc, "Returns a sequence of the map's values, in the same order as (seq map).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1557), kw_end_DASH_line, int(1557))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(lang.Vals, []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_vals = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_vals.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var-get
	{
		tmp0 := sym_var_DASH_get.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Gets the value in the var object", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4326), kw_end_DASH_line, int(4326))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3, _ := lang.FieldOrMethod(v2, "Get")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Get is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_var_DASH_get = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_var_DASH_get.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var-set
	{
		tmp0 := sym_var_DASH_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_val)), kw_doc, "Sets the value in the var object to val. The var must be\n thread-locally bound.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4332), kw_end_DASH_line, int(4332))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "Set")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Set is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_var_DASH_set = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_var_DASH_set.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var?
	{
		tmp0 := sym_var_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_v)), kw_doc, "Returns true if v is of type glojure.lang.Var", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(4999), kw_end_DASH_line, int(4999))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.Var)(nil))
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_var_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_var_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vector
	{
		tmp0 := sym_vector.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_a), lang.NewVector(sym_a, sym_b), lang.NewVector(sym_a, sym_b, sym_c), lang.NewVector(sym_a, sym_b, sym_c, sym_d), lang.NewVector(sym_a, sym_b, sym_c, sym_d, sym_e), lang.NewVector(sym_a, sym_b, sym_c, sym_d, sym_e, sym_f), lang.NewVector(sym_a, sym_b, sym_c, sym_d, sym_e, sym_f, sym__AMP_, sym_args)), kw_doc, "Creates a new vector containing the args.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(352), kw_end_DASH_line, int(352))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := lang.NewVector()
				tmp3 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(356), kw_column, int(7), kw_end_DASH_line, int(356), kw_end_DASH_column, int(8))
				tmp4, err := lang.WithMeta(tmp2, tmp3.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := lang.NewVector(v2)
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(357), kw_column, int(8), kw_end_DASH_line, int(357), kw_end_DASH_column, int(10))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := lang.NewVector(v2, v3)
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := lang.NewVector(v2, v3, v4)
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(359), kw_column, int(12), kw_end_DASH_line, int(359), kw_end_DASH_column, int(18))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := lang.NewVector(v2, v3, v4, v5)
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(360), kw_column, int(14), kw_end_DASH_line, int(360), kw_end_DASH_column, int(22))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			case 5:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				tmp7 := lang.NewVector(v2, v3, v4, v5, v6)
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(361), kw_column, int(15), kw_end_DASH_line, int(361), kw_end_DASH_column, int(25))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp9
			case 6:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				v7 := args[5]
				_ = v7
				tmp8 := lang.NewVector(v2, v3, v4, v5, v6, v7)
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(362), kw_column, int(17), kw_end_DASH_line, int(362), kw_end_DASH_column, int(29))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp10
			default:
				checkArityGTE(args, 6)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				v7 := args[5]
				_ = v7
				var v8 any = lang.NewList(args[6:]...)
				_ = v8
				tmp9 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp10 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp11 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp12 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp13 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp14 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp15 := lang.Apply(tmp14, []any{v7, v8})
				tmp16 := lang.Apply(tmp13, []any{v6, tmp15})
				tmp17 := lang.Apply(tmp12, []any{v5, tmp16})
				tmp18 := lang.Apply(tmp11, []any{v4, tmp17})
				tmp19 := lang.Apply(tmp10, []any{v3, tmp18})
				tmp20 := lang.Apply(tmp9, []any{v2, tmp19})
				tmp21 := lang.Apply(lang.CreateLazilyPersistentVector, []any{tmp20})
				return tmp21
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_vector = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_vector.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vector?
	{
		tmp0 := sym_vector_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x implements IPersistentVector", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(2), kw_line, int(174), kw_end_DASH_line, int(178))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function vector?
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp5 := reflect.TypeOf((*lang.IPersistentVector)(nil)).Elem()
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(178), kw_column, int(10), kw_end_DASH_line, int(178), kw_end_DASH_column, int(106))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_vector_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_vector_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// volatile!
	{
		tmp1 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
		tmp0 := sym_volatile_BANG_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_val)), kw_doc, "Creates and returns a Volatile with an initial value of val.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2517), kw_end_DASH_line, int(2517))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.NewVolatile, []any{v3})
			return tmp4
		})
		tmp3 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_volatile_BANG_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_volatile_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// volatile?
	{
		tmp0 := sym_volatile_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is a volatile.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2540), kw_end_DASH_line, int(2540))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_volatile_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_volatile_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vreset!
	{
		tmp0 := sym_vreset_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_vol, sym_newval)), kw_doc, "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(2524), kw_end_DASH_line, int(2524))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v2, "reset")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_vreset_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_vreset_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when
	{
		tmp0 := sym_when.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_test, sym__AMP_, sym_body)), kw_doc, "Evaluates test. If logical true, evaluates body in an implicit do.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(492), kw_end_DASH_line, int(492))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp8 := lang.Apply(tmp7, []any{sym_do, v5})
				tmp9 := lang.Apply(tmp6, []any{sym_if, v4, tmp8})
				return tmp9
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_when = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_when.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-not
	{
		tmp0 := sym_when_DASH_not.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_test, sym__AMP_, sym_body)), kw_doc, "Evaluates test. If logical false, evaluates body in an implicit do.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(498), kw_end_DASH_line, int(498))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp8 := lang.Apply(tmp7, []any{sym_do, v5})
				tmp9 := lang.Apply(tmp6, []any{sym_if, v4, nil, tmp8})
				return tmp9
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_when_DASH_not = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_when_DASH_not.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-meta
	{
		tmp0 := sym_with_DASH_meta.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_obj, sym_m)), kw_doc, "Returns an object of the same type and value as obj, with\n    map m as its metadata.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(2), kw_line, int(211), kw_end_DASH_line, int(216))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function with-meta
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "WithMeta")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("WithMeta is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(216), kw_column, int(12), kw_end_DASH_line, int(217), kw_end_DASH_column, int(32))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_with_DASH_meta = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_with_DASH_meta.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	var closed36 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
		recur_loop_481:
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "s"
						var v9 any = v6
						_ = v9
						var tmp10 any
						{ // let
							// let binding "or__0__auto__"
							tmp11 := checkDerefVar(var_glojure_DOT_core_first)
							tmp12 := lang.Apply(tmp11, []any{v9})
							tmp13 := lang.Apply(v1, []any{tmp12})
							var v14 any = tmp13
							_ = v14
							var tmp15 any
							if lang.IsTruthy(v14) {
								tmp15 = v14
							} else {
								var tmp16 any = v1
								tmp18 := checkDerefVar(var_glojure_DOT_core_next)
								tmp19 := lang.Apply(tmp18, []any{v9})
								var tmp17 any = tmp19
								v1 = tmp16
								v2 = tmp17
								goto recur_loop_481
							}
							tmp10 = tmp15
						} // end let
						tmp8 = tmp10
					} // end let
					tmp7 = tmp8
				} else {
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		closed36 = tmp0
	}
	var closed37 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
		recur_loop_480:
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp6 := lang.Apply(tmp5, []any{v2})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			if lang.IsTruthy(tmp7) {
				tmp3 = true
			} else {
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core_first)
				tmp10 := lang.Apply(tmp9, []any{v2})
				tmp11 := lang.Apply(v1, []any{tmp10})
				if lang.IsTruthy(tmp11) {
					var tmp12 any = v1
					tmp14 := checkDerefVar(var_glojure_DOT_core_next)
					tmp15 := lang.Apply(tmp14, []any{v2})
					var tmp13 any = tmp15
					v1 = tmp12
					v2 = tmp13
					goto recur_loop_480
				} else {
					var tmp16 any
					if lang.IsTruthy(kw_else) {
						tmp16 = false
					} else {
					}
					tmp8 = tmp16
				}
				tmp3 = tmp8
			}
			return tmp3
		})
		tmp1 := reflect.TypeOf(false)
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, tmp1)).(lang.FnFunc)
		closed37 = tmp0
	}
	// agent-errors
	{
		tmp0 := sym_agent_DASH_errors.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_doc, "DEPRECATED: Use 'agent-error' instead.\n  Returns a sequence of the exceptions thrown during asynchronous\n  actions of the agent.", kw_file, "glojure/core.glj", kw_deprecated, "1.2", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(2234), kw_end_DASH_line, int(2234))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_agent_DASH_error)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "e"
						var v9 any = v6
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_list)
						tmp11 := lang.Apply(tmp10, []any{v9})
						tmp8 = tmp11
					} // end let
					tmp7 = tmp8
				} else {
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_agent_DASH_errors = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_agent_DASH_errors.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alias
	{
		tmp0 := sym_alias.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_alias, sym_namespace_DASH_sym)), kw_doc, "Add an alias in the current namespace to another\n  namespace. Arguments are two symbols: the alias to be used, and\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\n  to calling this directly.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(4263), kw_end_DASH_line, int(4263))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
			tmp5 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7, _ := lang.FieldOrMethod(tmp4, "AddAlias")
			if reflect.TypeOf(tmp7).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddAlias is not a function")))
			}
			tmp8 := lang.Apply(tmp7, []any{v2, tmp6})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_alias = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_alias.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc
	{
		tmp0 := sym_assoc.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map, sym_key, sym_val), lang.NewVector(sym_map, sym_key, sym_val, sym__AMP_, sym_kvs)), kw_doc, "assoc[iate]. When applied to a map, returns a new map of the\n    same (hashed/sorted) type, that contains the mapping of key(s) to\n    val(s). When applied to a vector, returns a new vector that\n    contains val at index. Note - index must be <= (count vector).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(181), kw_end_DASH_line, int(188))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function assoc
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 3:
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					v5 := args[2]
					_ = v5
					tmp6 := lang.Apply(lang.Assoc, []any{v3, v4, v5})
					return tmp6
				default:
					checkArityGTE(args, 3)
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					v5 := args[2]
					_ = v5
					var v6 any = lang.NewList(args[3:]...)
					_ = v6
				recur_loop_24:
					var tmp7 any
					{ // let
						// let binding "ret"
						tmp8 := lang.Apply(lang.Assoc, []any{v3, v4, v5})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v6) {
							var tmp11 any
							tmp12 := checkDerefVar(var_glojure_DOT_core_next)
							tmp13 := lang.Apply(tmp12, []any{v6})
							if lang.IsTruthy(tmp13) {
								var tmp14 any = v9
								tmp16 := checkDerefVar(var_glojure_DOT_core_first)
								tmp17 := lang.Apply(tmp16, []any{v6})
								var tmp15 any = tmp17
								tmp19 := checkDerefVar(var_glojure_DOT_core_second)
								tmp20 := lang.Apply(tmp19, []any{v6})
								var tmp18 any = tmp20
								tmp22 := checkDerefVar(var_glojure_DOT_core_nnext)
								tmp23 := lang.Apply(tmp22, []any{v6})
								var tmp21 any = tmp23
								v3 = tmp14
								v4 = tmp15
								v5 = tmp18
								v6 = tmp21
								goto recur_loop_24
							} else {
								tmp24 := lang.Apply(lang.NewIllegalArgumentError, []any{"assoc expects even number of arguments after map/vector, found odd number"})
								panic(tmp24)
							}
							tmp10 = tmp11
						} else {
							tmp10 = v9
						}
						tmp7 = tmp10
					} // end let
					return tmp7
				}
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(189), kw_column, int(2), kw_end_DASH_line, int(198), kw_end_DASH_column, int(15))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_assoc = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_assoc.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc!
	{
		tmp0 := sym_assoc_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_key, sym_val), lang.NewVector(sym_coll, sym_key, sym_val, sym__AMP_, sym_kvs)), kw_doc, "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3369), kw_end_DASH_line, int(3369))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v2, "Assoc")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Assoc is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
			recur_loop_609:
				var tmp6 any
				{ // let
					// let binding "ret"
					tmp7, _ := lang.FieldOrMethod(v2, "Assoc")
					if reflect.TypeOf(tmp7).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Assoc is not a function")))
					}
					tmp8 := lang.Apply(tmp7, []any{v3, v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v5) {
						var tmp11 any = v9
						tmp13 := checkDerefVar(var_glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v5})
						var tmp12 any = tmp14
						tmp16 := checkDerefVar(var_glojure_DOT_core_second)
						tmp17 := lang.Apply(tmp16, []any{v5})
						var tmp15 any = tmp17
						tmp19 := checkDerefVar(var_glojure_DOT_core_nnext)
						tmp20 := lang.Apply(tmp19, []any{v5})
						var tmp18 any = tmp20
						v2 = tmp11
						v3 = tmp12
						v4 = tmp15
						v5 = tmp18
						goto recur_loop_609
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_assoc_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_assoc_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// associative?
	{
		tmp0 := sym_associative_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll implements Associative", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(6223), kw_end_DASH_line, int(6223))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{nil, v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_associative_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_associative_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bases
	{
		tmp0 := sym_bases.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_c)), kw_doc, "Returns the immediate superclass and direct interfaces of c, if any", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(5522), kw_end_DASH_line, int(5522))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			if lang.IsTruthy(v2) {
				var tmp4 any
				{ // let
					// let binding "i"
					tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp6 := lang.Apply(tmp5, []any{nil})
					var v7 any = tmp6
					_ = v7
					// let binding "s"
					var v8 any = nil
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp10 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp11 := lang.Apply(tmp10, []any{v8, v7})
						tmp9 = tmp11
					} else {
						tmp9 = v7
					}
					tmp4 = tmp9
				} // end let
				tmp3 = tmp4
			} else {
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bases = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bases.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean?
	{
		tmp0 := sym_boolean_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a Boolean", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(518), kw_end_DASH_line, int(518))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{lang.Builtins["bool"], v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_boolean_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_boolean_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char?
	{
		tmp0 := sym_char_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a Character", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(153), kw_end_DASH_line, int(157))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function char?
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp5 := reflect.TypeOf(lang.NewChar(0))
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(157), kw_column, int(8), kw_end_DASH_line, int(157), kw_end_DASH_column, int(89))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_char_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_char_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunked-seq?
	{
		tmp0 := sym_chunked_DASH_seq_QMARK_.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(708), kw_column, int(7), kw_end_DASH_line, int(708), kw_end_DASH_column, int(27), kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.IChunkedSeq)(nil)).Elem()
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_chunked_DASH_seq_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_chunked_DASH_seq_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// class
	{
		tmp0 := sym_class.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns the Class of x", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3461), kw_end_DASH_line, int(3461))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp3 = v2
			} else {
				tmp6 := lang.Apply(lang.TypeOf, []any{v2})
				tmp3 = tmp6
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_class = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_class.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// class?
	{
		tmp0 := sym_class_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is an instance of Class", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5465), kw_end_DASH_line, int(5465))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_class_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_class_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// coll?
	{
		tmp0 := sym_coll_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x implements IPersistentCollection", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(6192), kw_end_DASH_line, int(6192))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_coll_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_coll_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// completing
	{
		tmp0 := sym_completing.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_cf)), kw_doc, "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(6893), kw_end_DASH_line, int(6893))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_completing)
				tmp4 := checkDerefVar(var_glojure_DOT_core_identity)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp5 := lang.Apply(v2, nil)
						return tmp5
					case 1:
						v5 := args[0]
						_ = v5
						tmp6 := lang.Apply(v3, []any{v5})
						return tmp6
					case 2:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						tmp7 := lang.Apply(v2, []any{v5, v6})
						return tmp7
					default:
						checkArity(args, -1)
						panic("unreachable")
					}
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6900), kw_column, int(6), kw_end_DASH_line, int(6903), kw_end_DASH_column, int(23))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_completing = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_completing.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// concat
	{
		tmp0 := sym_concat.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_zs)), kw_doc, "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(711), kw_end_DASH_line, int(711))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp2 lang.FnFunc
				tmp2 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					return nil
				})
				tmp3 := lang.Apply(lang.NewLazySeq, []any{tmp2})
				return tmp3
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					return v2
				})
				tmp4 := lang.Apply(lang.NewLazySeq, []any{tmp3})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp5 any
					{ // let
						// let binding "s"
						tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp7 := lang.Apply(tmp6, []any{v2})
						var v8 any = tmp7
						_ = v8
						var tmp9 any
						if lang.IsTruthy(v8) {
							var tmp10 any
							tmp11 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
							tmp12 := lang.Apply(tmp11, []any{v8})
							if lang.IsTruthy(tmp12) {
								tmp13 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
								tmp14 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
								tmp15 := lang.Apply(tmp14, []any{v8})
								tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp17 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
								tmp18 := lang.Apply(tmp17, []any{v8})
								tmp19 := lang.Apply(tmp16, []any{tmp18, v3})
								tmp20 := lang.Apply(tmp13, []any{tmp15, tmp19})
								tmp10 = tmp20
							} else {
								tmp21 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp22 := checkDerefVar(var_glojure_DOT_core_first)
								tmp23 := lang.Apply(tmp22, []any{v8})
								tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp25 := checkDerefVar(var_glojure_DOT_core_rest)
								tmp26 := lang.Apply(tmp25, []any{v8})
								tmp27 := lang.Apply(tmp24, []any{tmp26, v3})
								tmp28 := lang.Apply(tmp21, []any{tmp23, tmp27})
								tmp10 = tmp28
							}
							tmp9 = tmp10
						} else {
							tmp9 = v3
						}
						tmp5 = tmp9
					} // end let
					return tmp5
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "cat"
					var tmp6 lang.FnFunc
					{ // function cat
						var v7 lang.FnFunc
						tmp6 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							var tmp10 lang.FnFunc
							tmp10 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								var tmp11 any
								{ // let
									// let binding "xys"
									tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp13 := lang.Apply(tmp12, []any{v8})
									var v14 any = tmp13
									_ = v14
									var tmp15 any
									if lang.IsTruthy(v14) {
										var tmp16 any
										tmp17 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
										tmp18 := lang.Apply(tmp17, []any{v14})
										if lang.IsTruthy(tmp18) {
											tmp19 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
											tmp20 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
											tmp21 := lang.Apply(tmp20, []any{v14})
											tmp22 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
											tmp23 := lang.Apply(tmp22, []any{v14})
											tmp24 := lang.Apply(v7, []any{tmp23, v9})
											tmp25 := lang.Apply(tmp19, []any{tmp21, tmp24})
											tmp16 = tmp25
										} else {
											tmp26 := checkDerefVar(var_glojure_DOT_core_cons)
											tmp27 := checkDerefVar(var_glojure_DOT_core_first)
											tmp28 := lang.Apply(tmp27, []any{v14})
											tmp29 := checkDerefVar(var_glojure_DOT_core_rest)
											tmp30 := lang.Apply(tmp29, []any{v14})
											tmp31 := lang.Apply(v7, []any{tmp30, v9})
											tmp32 := lang.Apply(tmp26, []any{tmp28, tmp31})
											tmp16 = tmp32
										}
										tmp15 = tmp16
									} else {
										var tmp33 any
										if lang.IsTruthy(v9) {
											tmp34 := checkDerefVar(var_glojure_DOT_core_first)
											tmp35 := lang.Apply(tmp34, []any{v9})
											tmp36 := checkDerefVar(var_glojure_DOT_core_next)
											tmp37 := lang.Apply(tmp36, []any{v9})
											tmp38 := lang.Apply(v7, []any{tmp35, tmp37})
											tmp33 = tmp38
										} else {
										}
										tmp15 = tmp33
									}
									tmp11 = tmp15
								} // end let
								return tmp11
							})
							tmp11 := lang.Apply(lang.NewLazySeq, []any{tmp10})
							return tmp11
						})
						v7 = tmp6
						_ = v7
					}
					tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(726), kw_column, int(16), kw_end_DASH_line, int(735), kw_end_DASH_column, int(56))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v9 any = tmp8
					_ = v9
					tmp10 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp11 := lang.Apply(tmp10, []any{v2, v3})
					tmp12 := lang.Apply(v9, []any{tmp11, v4})
					tmp5 = tmp12
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_concat = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_concat.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond
	{
		tmp0 := sym_cond.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_clauses)), kw_doc, "Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(569), kw_end_DASH_line, int(569))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				if lang.IsTruthy(v4) {
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := checkDerefVar(var_glojure_DOT_core_first)
					tmp8 := lang.Apply(tmp7, []any{v4})
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_next)
					tmp11 := lang.Apply(tmp10, []any{v4})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_second)
						tmp13 := lang.Apply(tmp12, []any{v4})
						tmp9 = tmp13
					} else {
						tmp14 := lang.Apply(lang.NewIllegalArgumentError, []any{"cond requires an even number of forms"})
						panic(tmp14)
					}
					tmp15 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp16 := checkDerefVar(var_glojure_DOT_core_next)
					tmp17 := checkDerefVar(var_glojure_DOT_core_next)
					tmp18 := lang.Apply(tmp17, []any{v4})
					tmp19 := lang.Apply(tmp16, []any{tmp18})
					tmp20 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_cond, tmp19})
					tmp21 := lang.Apply(tmp6, []any{sym_if, tmp8, tmp9, tmp20})
					tmp5 = tmp21
				} else {
				}
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_cond = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_cond.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// conj
	{
		tmp0 := sym_conj.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_coll), lang.NewVector(sym_coll, sym_x), lang.NewVector(sym_coll, sym_x, sym__AMP_, sym_xs)), kw_doc, "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).\n    (conj coll) returns coll. (conj) returns [].\n    The 'addition' may happen at different 'places' depending\n    on the concrete type.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(73), kw_end_DASH_line, int(81))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function conj
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 0:
					tmp3 := lang.NewVector()
					tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(82), kw_column, int(13), kw_end_DASH_line, int(82), kw_end_DASH_column, int(14))
					tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp5
				case 1:
					v3 := args[0]
					_ = v3
					return v3
				case 2:
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					tmp5 := lang.Apply(lang.Conj, []any{v3, v4})
					return tmp5
				default:
					checkArityGTE(args, 2)
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					var v5 any = lang.NewList(args[2:]...)
					_ = v5
				recur_loop_10:
					var tmp6 any
					if lang.IsTruthy(v5) {
						tmp8 := lang.Apply(lang.Conj, []any{v3, v4})
						var tmp7 any = tmp8
						tmp10 := checkDerefVar(var_glojure_DOT_core_first)
						tmp11 := lang.Apply(tmp10, []any{v5})
						var tmp9 any = tmp11
						tmp13 := checkDerefVar(var_glojure_DOT_core_next)
						tmp14 := lang.Apply(tmp13, []any{v5})
						var tmp12 any = tmp14
						v3 = tmp7
						v4 = tmp9
						v5 = tmp12
						goto recur_loop_10
					} else {
						tmp15 := lang.Apply(lang.Conj, []any{v3, v4})
						tmp6 = tmp15
					}
					return tmp6
				}
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(81), kw_column, int(7), kw_end_DASH_line, int(88), kw_end_DASH_column, int(67))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_conj = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_conj.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// conj!
	{
		tmp0 := sym_conj_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_coll), lang.NewVector(sym_coll, sym_x)), kw_doc, "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3359), kw_end_DASH_line, int(3359))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp3 := lang.NewVector()
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3364), kw_column, int(18), kw_end_DASH_line, int(3364), kw_end_DASH_column, int(19))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp6 := lang.Apply(tmp2, []any{tmp5})
				return tmp6
			case 1:
				v2 := args[0]
				_ = v2
				return v2
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(v2, "Conj")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Conj is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_conj_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_conj_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// count
	{
		var tmp1 lang.FnFunc
		{ // function count__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Count})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_count.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_inline, tmp1, kw_doc, "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Java Collections and Maps", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(867), kw_end_DASH_line, int(867))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.Count, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_count = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_count.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// counted?
	{
		tmp0 := sym_counted_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll implements count in constant time", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(6241), kw_end_DASH_line, int(6241))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.Counted)(nil)).Elem()
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_counted_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_counted_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cycle
	{
		tmp0 := sym_cycle.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(2977), kw_end_DASH_line, int(2977))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp4 := lang.Apply(tmp3, []any{v2})
			tmp5 := lang.Apply(lang.NewCycle, []any{tmp4})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_cycle = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_cycle.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dec
	{
		var tmp1 lang.FnFunc
		{ // function dec__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_unchecked_dec
				} else {
					tmp14 = sym_dec
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_dec.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one less than num. Does not auto-promote\n  longs, will throw on overflow. See also: dec'", kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1147), kw_end_DASH_line, int(1147))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "dec")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("dec is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_dec = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_dec.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dec'
	{
		var tmp1 lang.FnFunc
		{ // function dec'__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_decP})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_dec_TICK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one less than num. Supports arbitrary precision.\n  See also: dec", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1140), kw_end_DASH_line, int(1140))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "decP")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("decP is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_dec_TICK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_dec_TICK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// decimal?
	{
		tmp0 := sym_decimal_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is a BigDecimal", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(3599), kw_end_DASH_line, int(3599))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*lang.BigDecimal)(nil))
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_decimal_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_decimal_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmethod
	{
		tmp0 := sym_defmethod.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_multifn, sym_dispatch_DASH_val, sym__AMP_, sym_fn_DASH_tail)), kw_doc, "Creates and installs a new method of multimethod associated with dispatch-value. ", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(1781), kw_end_DASH_line, int(1781))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 4)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var v6 any = lang.NewList(args[4:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
				tmp13 := lang.NewMap(kw_tag, sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT__STAR_MultiFn)
				tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1785), kw_column, int(27), kw_end_DASH_line, int(1785), kw_end_DASH_column, int(82))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp16 := lang.Apply(tmp12, []any{v4, tmp15})
				tmp17 := lang.Apply(tmp11, []any{tmp16})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{sym_glojure_DOT_core_SLASH_AddMethod})
				tmp20 := checkDerefVar(var_glojure_DOT_core_list)
				tmp21 := lang.Apply(tmp20, []any{v5})
				tmp22 := checkDerefVar(var_glojure_DOT_core_list)
				tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp25 := checkDerefVar(var_glojure_DOT_core_list)
				tmp26 := lang.Apply(tmp25, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp27 := lang.Apply(tmp24, []any{tmp26, v6})
				tmp28 := lang.Apply(tmp23, []any{tmp27})
				tmp29 := lang.Apply(tmp22, []any{tmp28})
				tmp30 := lang.Apply(tmp8, []any{tmp10, tmp17, tmp19, tmp21, tmp29})
				tmp31 := lang.Apply(tmp7, []any{tmp30})
				return tmp31
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_defmethod = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_defmethod.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defstruct
	{
		tmp0 := sym_defstruct.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_keys)), kw_doc, "Same as (def name (create-struct keys...))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(4044), kw_end_DASH_line, int(4044))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_def})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_create_DASH_struct})
				tmp17 := lang.Apply(tmp14, []any{tmp16, v5})
				tmp18 := lang.Apply(tmp13, []any{tmp17})
				tmp19 := lang.Apply(tmp12, []any{tmp18})
				tmp20 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp19})
				tmp21 := lang.Apply(tmp6, []any{tmp20})
				return tmp21
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_defstruct = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_defstruct.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// delay?
	{
		tmp0 := sym_delay_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "returns true if x is a Delay created with delay", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(748), kw_end_DASH_line, int(748))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{nil, v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_delay_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_delay_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref
	{
		tmp0 := sym_deref.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref), lang.NewVector(sym_ref, sym_timeout_DASH_ms, sym_timeout_DASH_val)), kw_doc, "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(2304), kw_end_DASH_line, int(2304))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp5 := reflect.TypeOf((*lang.IDeref)(nil)).Elem()
				tmp6 := lang.Apply(tmp4, []any{tmp5, v2})
				if lang.IsTruthy(tmp6) {
					tmp7, ok := lang.FieldOrMethod(v2, "Deref")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "Deref")))
					}
					var tmp8 any
					switch reflect.TypeOf(tmp7).Kind() {
					case reflect.Func:
						tmp8 = lang.Apply(tmp7, nil)
					default:
						tmp8 = tmp7
					}
					tmp3 = tmp8
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_deref_DASH_future)
					tmp10 := lang.Apply(tmp9, []any{v2})
					tmp3 = tmp10
				}
				return tmp3
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IBlockingDeref)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v2})
				if lang.IsTruthy(tmp8) {
					tmp9, _ := lang.FieldOrMethod(v2, "DerefWithTimeout")
					if reflect.TypeOf(tmp9).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("DerefWithTimeout is not a function")))
					}
					tmp10 := lang.Apply(tmp9, []any{v3, v4})
					tmp5 = tmp10
				} else {
					tmp11 := checkDerefVar(var_glojure_DOT_core_deref_DASH_future)
					tmp12 := lang.Apply(tmp11, []any{v2, v3, v4})
					tmp5 = tmp12
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_deref = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_deref.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// disj
	{
		tmp0 := sym_disj.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_set), lang.NewVector(sym_set, sym_key), lang.NewVector(sym_set, sym_key, sym__AMP_, sym_ks)), kw_doc, "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1514), kw_end_DASH_line, int(1514))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				return v2
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				if lang.IsTruthy(v2) {
					tmp5, _ := lang.FieldOrMethod(v2, "Disjoin")
					if reflect.TypeOf(tmp5).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
					}
					tmp6 := lang.Apply(tmp5, []any{v3})
					tmp4 = tmp6
				} else {
				}
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
			recur_loop_304:
				var tmp5 any
				if lang.IsTruthy(v2) {
					var tmp6 any
					{ // let
						// let binding "ret"
						tmp7 := checkDerefVar(var_glojure_DOT_core_disj)
						tmp8 := lang.Apply(tmp7, []any{v2, v3})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v4) {
							var tmp11 any = v9
							tmp13 := checkDerefVar(var_glojure_DOT_core_first)
							tmp14 := lang.Apply(tmp13, []any{v4})
							var tmp12 any = tmp14
							tmp16 := checkDerefVar(var_glojure_DOT_core_next)
							tmp17 := lang.Apply(tmp16, []any{v4})
							var tmp15 any = tmp17
							v2 = tmp11
							v3 = tmp12
							v4 = tmp15
							goto recur_loop_304
						} else {
							tmp10 = v9
						}
						tmp6 = tmp10
					} // end let
					tmp5 = tmp6
				} else {
				}
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_disj = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_disj.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// disj!
	{
		tmp0 := sym_disj_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_set), lang.NewVector(sym_set, sym_key), lang.NewVector(sym_set, sym_key, sym__AMP_, sym_ks)), kw_doc, "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3401), kw_end_DASH_line, int(3401))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				return v2
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(v2, "Disjoin")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
			recur_loop_615:
				var tmp5 any
				{ // let
					// let binding "ret"
					tmp6, _ := lang.FieldOrMethod(v2, "Disjoin")
					if reflect.TypeOf(tmp6).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
					}
					tmp7 := lang.Apply(tmp6, []any{v3})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v4) {
						var tmp10 any = v8
						tmp12 := checkDerefVar(var_glojure_DOT_core_first)
						tmp13 := lang.Apply(tmp12, []any{v4})
						var tmp11 any = tmp13
						tmp15 := checkDerefVar(var_glojure_DOT_core_next)
						tmp16 := lang.Apply(tmp15, []any{v4})
						var tmp14 any = tmp16
						v2 = tmp10
						v3 = tmp11
						v4 = tmp14
						goto recur_loop_615
					} else {
						tmp9 = v8
					}
					tmp5 = tmp9
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_disj_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_disj_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dissoc
	{
		tmp0 := sym_dissoc.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map), lang.NewVector(sym_map, sym_key), lang.NewVector(sym_map, sym_key, sym__AMP_, sym_ks)), kw_doc, "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(1500), kw_end_DASH_line, int(1500))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				return v2
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(runtime.RT, "Dissoc")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Dissoc is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
			recur_loop_301:
				var tmp5 any
				{ // let
					// let binding "ret"
					tmp6 := checkDerefVar(var_glojure_DOT_core_dissoc)
					tmp7 := lang.Apply(tmp6, []any{v2, v3})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v4) {
						var tmp10 any = v8
						tmp12 := checkDerefVar(var_glojure_DOT_core_first)
						tmp13 := lang.Apply(tmp12, []any{v4})
						var tmp11 any = tmp13
						tmp15 := checkDerefVar(var_glojure_DOT_core_next)
						tmp16 := lang.Apply(tmp15, []any{v4})
						var tmp14 any = tmp16
						v2 = tmp10
						v3 = tmp11
						v4 = tmp14
						goto recur_loop_301
					} else {
						tmp9 = v8
					}
					tmp5 = tmp9
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_dissoc = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_dissoc.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dissoc!
	{
		tmp0 := sym_dissoc_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map, sym_key), lang.NewVector(sym_map, sym_key, sym__AMP_, sym_ks)), kw_doc, "Returns a transient map that doesn't contain a mapping for key(s).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3382), kw_end_DASH_line, int(3382))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(v2, "without")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("without is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
			recur_loop_611:
				var tmp5 any
				{ // let
					// let binding "ret"
					tmp6, _ := lang.FieldOrMethod(v2, "without")
					if reflect.TypeOf(tmp6).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("without is not a function")))
					}
					tmp7 := lang.Apply(tmp6, []any{v3})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v4) {
						var tmp10 any = v8
						tmp12 := checkDerefVar(var_glojure_DOT_core_first)
						tmp13 := lang.Apply(tmp12, []any{v4})
						var tmp11 any = tmp13
						tmp15 := checkDerefVar(var_glojure_DOT_core_next)
						tmp16 := lang.Apply(tmp15, []any{v4})
						var tmp14 any = tmp16
						v2 = tmp10
						v3 = tmp11
						v4 = tmp14
						goto recur_loop_611
					} else {
						tmp9 = v8
					}
					tmp5 = tmp9
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_dissoc_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_dissoc_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dosync
	{
		tmp0 := sym_dosync.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_exprs)), kw_doc, "Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of dosync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(5100), kw_end_DASH_line, int(5100))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_glojure_DOT_core_SLASH_sync})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{nil})
				tmp11 := lang.Apply(tmp6, []any{tmp8, tmp10, v4})
				tmp12 := lang.Apply(tmp5, []any{tmp11})
				return tmp12
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_dosync = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_dosync.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double
	{
		var tmp1 lang.FnFunc
		{ // function double__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_DoubleCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_double.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to double", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3493), kw_end_DASH_line, int(3493))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.AsFloat64, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_double = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_double.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double-array
	{
		var tmp1 lang.FnFunc
		{ // function double-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_doubleArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_double_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of doubles", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(5341), kw_end_DASH_line, int(5341))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(lang.Numbers, "doubleArray")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("doubleArray is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "doubleArrayInit")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("doubleArrayInit is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_double_DASH_array = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_double_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double?
	{
		tmp0 := sym_double_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a Double", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1421), kw_end_DASH_line, int(1421))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{lang.Builtins["float64"], v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_double_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_double_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doubles
	{
		var tmp1 lang.FnFunc
		{ // function doubles
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_doubles})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_doubles.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to double[]", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(12), kw_line, int(5402), kw_end_DASH_line, int(5402))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "doubles")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("doubles is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_doubles = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_doubles.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop-while
	{
		tmp0 := sym_drop_DASH_while.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred), lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(2950), kw_end_DASH_line, int(2950))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "dv"
						tmp6 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp7 := lang.Apply(tmp6, []any{true})
						var v8 any = tmp7
						_ = v8
						var tmp9 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp10 := lang.Apply(v4, nil)
								return tmp10
							case 1:
								v10 := args[0]
								_ = v10
								tmp11 := lang.Apply(v4, []any{v10})
								return tmp11
							case 2:
								v10 := args[0]
								_ = v10
								v11 := args[1]
								_ = v11
								var tmp12 any
								{ // let
									// let binding "drop?"
									tmp13 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp14 := lang.Apply(tmp13, []any{v8})
									var v15 any = tmp14
									_ = v15
									var tmp16 any
									var tmp17 any
									{ // let
										// let binding "and__0__auto__"
										var v18 any = v15
										_ = v18
										var tmp19 any
										if lang.IsTruthy(v18) {
											tmp20 := lang.Apply(v2, []any{v11})
											tmp19 = tmp20
										} else {
											tmp19 = v18
										}
										tmp17 = tmp19
									} // end let
									if lang.IsTruthy(tmp17) {
										tmp16 = v10
									} else {
										tmp18 := checkDerefVar(var_glojure_DOT_core_vreset_BANG_)
										tmp19 := lang.Apply(tmp18, []any{v8, nil})
										_ = tmp19
										tmp20 := lang.Apply(v4, []any{v10, v11})
										tmp16 = tmp20
									}
									tmp12 = tmp16
								} // end let
								return tmp12
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2959), kw_column, int(10), kw_end_DASH_line, int(2968), kw_end_DASH_column, int(42))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp11
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2957), kw_column, int(6), kw_end_DASH_line, int(2968), kw_end_DASH_column, int(44))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "step"
					var tmp5 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
					recur_loop_552:
						var tmp8 any
						{ // let
							// let binding "s"
							tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp10 := lang.Apply(tmp9, []any{v7})
							var v11 any = tmp10
							_ = v11
							var tmp12 any
							var tmp13 any
							{ // let
								// let binding "and__0__auto__"
								var v14 any = v11
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									tmp16 := checkDerefVar(var_glojure_DOT_core_first)
									tmp17 := lang.Apply(tmp16, []any{v11})
									tmp18 := lang.Apply(v6, []any{tmp17})
									tmp15 = tmp18
								} else {
									tmp15 = v14
								}
								tmp13 = tmp15
							} // end let
							if lang.IsTruthy(tmp13) {
								var tmp14 any = v6
								tmp16 := checkDerefVar(var_glojure_DOT_core_rest)
								tmp17 := lang.Apply(tmp16, []any{v11})
								var tmp15 any = tmp17
								v6 = tmp14
								v7 = tmp15
								goto recur_loop_552
							} else {
								tmp12 = v11
							}
							tmp8 = tmp12
						} // end let
						return tmp8
					})
					tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2970), kw_column, int(17), kw_end_DASH_line, int(2974), kw_end_DASH_column, int(26))
					tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v8 any = tmp7
					_ = v8
					var tmp9 lang.FnFunc
					tmp9 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						tmp10 := lang.Apply(v8, []any{v2, v3})
						return tmp10
					})
					tmp10 := lang.Apply(lang.NewLazySeq, []any{tmp9})
					tmp4 = tmp10
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_drop_DASH_while = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_drop_DASH_while.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// empty
	{
		tmp0 := sym_empty.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns an empty collection of the same category as coll, or nil", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(5265), kw_end_DASH_line, int(5265))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v2})
			if lang.IsTruthy(tmp6) {
				tmp7, ok := lang.FieldOrMethod(v2, "empty")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "empty")))
				}
				var tmp8 any
				switch reflect.TypeOf(tmp7).Kind() {
				case reflect.Func:
					tmp8 = lang.Apply(tmp7, nil)
				default:
					tmp8 = tmp7
				}
				tmp3 = tmp8
			} else {
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_empty = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_empty.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// every?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_every_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns true if (pred x) is logical true for every x in coll, else\n  false.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2664), kw_end_DASH_line, int(2664))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
		recur_loop_480:
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp8 := lang.Apply(tmp7, []any{v4})
			tmp9 := lang.Apply(tmp6, []any{tmp8})
			if lang.IsTruthy(tmp9) {
				tmp5 = true
			} else {
				var tmp10 any
				tmp11 := checkDerefVar(var_glojure_DOT_core_first)
				tmp12 := lang.Apply(tmp11, []any{v4})
				tmp13 := lang.Apply(v3, []any{tmp12})
				if lang.IsTruthy(tmp13) {
					var tmp14 any = v3
					tmp16 := checkDerefVar(var_glojure_DOT_core_next)
					tmp17 := lang.Apply(tmp16, []any{v4})
					var tmp15 any = tmp17
					v3 = tmp14
					v4 = tmp15
					goto recur_loop_480
				} else {
					var tmp18 any
					if lang.IsTruthy(kw_else) {
						tmp18 = false
					} else {
					}
					tmp10 = tmp18
				}
				tmp5 = tmp10
			}
			return tmp5
		})
		tmp3 := reflect.TypeOf(false)
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_every_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_every_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-cause
	{
		tmp0 := sym_ex_DASH_cause.WithMeta(lang.NewMap(kw_tag, nil, kw_arglists, lang.NewList(lang.NewVector(sym_ex)), kw_doc, "Returns the cause of ex if ex is a Throwable.\n  Otherwise returns nil.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4828), kw_end_DASH_line, int(4828))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{lang.Throwable, v2})
			if lang.IsTruthy(tmp5) {
				tmp6, ok := lang.FieldOrMethod(v2, "getCause")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getCause")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				tmp3 = tmp7
			} else {
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ex_DASH_cause = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ex_DASH_cause.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-data
	{
		tmp0 := sym_ex_DASH_data.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ex)), kw_doc, "Returns exception data (a map) if ex is an IExceptionInfo.\n   Otherwise returns nil.", kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4812), kw_end_DASH_line, int(4812))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v2})
			if lang.IsTruthy(tmp5) {
				tmp6, ok := lang.FieldOrMethod(v2, "getData")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getData")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				tmp3 = tmp7
			} else {
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ex_DASH_data = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ex_DASH_data.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-message
	{
		tmp0 := sym_ex_DASH_message.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ex)), kw_doc, "Returns the message attached to ex if ex is a Throwable.\n  Otherwise returns nil.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4820), kw_end_DASH_line, int(4820))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{lang.Throwable, v2})
			if lang.IsTruthy(tmp5) {
				tmp6, ok := lang.FieldOrMethod(v2, "getMessage")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getMessage")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				tmp3 = tmp7
			} else {
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ex_DASH_message = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ex_DASH_message.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ffirst
	{
		tmp0 := sym_ffirst.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Same as (first (first x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(2), kw_line, int(98), kw_end_DASH_line, int(102))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function ffirst
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_first)
				tmp5 := checkDerefVar(var_glojure_DOT_core_first)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(tmp4, []any{tmp6})
				return tmp7
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(102), kw_column, int(9), kw_end_DASH_line, int(102), kw_end_DASH_column, int(50))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_ffirst = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ffirst.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filter-key
	{
		tmp0 := sym_filter_DASH_key.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_keyfn, sym_pred, sym_amap)), kw_static, true, kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4115), kw_end_DASH_line, int(4117), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "ret"
				tmp6 := lang.NewMap()
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4118), kw_column, int(16), kw_end_DASH_line, int(4118), kw_end_DASH_column, int(17))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v9 any = tmp8
				_ = v9
				// let binding "es"
				tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp11 := lang.Apply(tmp10, []any{v4})
				var v12 any = tmp11
				_ = v12
				for {
					var tmp13 any
					if lang.IsTruthy(v12) {
						var tmp14 any
						tmp15 := checkDerefVar(var_glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v12})
						tmp17 := lang.Apply(v2, []any{tmp16})
						tmp18 := lang.Apply(v3, []any{tmp17})
						if lang.IsTruthy(tmp18) {
							tmp20 := checkDerefVar(var_glojure_DOT_core_assoc)
							tmp21 := checkDerefVar(var_glojure_DOT_core_key)
							tmp22 := checkDerefVar(var_glojure_DOT_core_first)
							tmp23 := lang.Apply(tmp22, []any{v12})
							tmp24 := lang.Apply(tmp21, []any{tmp23})
							tmp25 := checkDerefVar(var_glojure_DOT_core_val)
							tmp26 := checkDerefVar(var_glojure_DOT_core_first)
							tmp27 := lang.Apply(tmp26, []any{v12})
							tmp28 := lang.Apply(tmp25, []any{tmp27})
							tmp29 := lang.Apply(tmp20, []any{v9, tmp24, tmp28})
							var tmp19 any = tmp29
							tmp31 := checkDerefVar(var_glojure_DOT_core_next)
							tmp32 := lang.Apply(tmp31, []any{v12})
							var tmp30 any = tmp32
							v9 = tmp19
							v12 = tmp30
							continue
						} else {
							var tmp33 any = v9
							tmp35 := checkDerefVar(var_glojure_DOT_core_next)
							tmp36 := lang.Apply(tmp35, []any{v12})
							var tmp34 any = tmp36
							v9 = tmp33
							v12 = tmp34
							continue
						}
						tmp13 = tmp14
					} else {
						tmp13 = v9
					}
					tmp5 = tmp13
					break
				}
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_filter_DASH_key = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_filter_DASH_key.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-keyword
	{
		tmp1 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp0 := sym_find_DASH_keyword.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_name), lang.NewVector(sym_ns, sym_name)), kw_doc, "Returns a Keyword with the given namespace and name if one already\n  exists.  This function will not intern a new keyword. If the keyword\n  has not already been interned, it will return nil.  Do not use :\n  in the keyword strings, it will be added automatically.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(618), kw_end_DASH_line, int(618))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					tmp4 = v3
				} else {
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v3})
					if lang.IsTruthy(tmp9) {
						tmp10 := lang.Apply(nil, []any{v3})
						tmp7 = tmp10
					} else {
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v3})
						if lang.IsTruthy(tmp13) {
							tmp14 := lang.Apply(nil, []any{v3})
							tmp11 = tmp14
						} else {
						}
						tmp7 = tmp11
					}
					tmp4 = tmp7
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(nil, []any{v3, v4})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_find_DASH_keyword = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_find_DASH_keyword.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float
	{
		var tmp1 lang.FnFunc
		{ // function float__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_uncheckedFloatCast
				} else {
					tmp14 = sym_floatCast
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_float.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to float", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3487), kw_end_DASH_line, int(3487))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.FloatCast, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_float = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_float.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float-array
	{
		var tmp1 lang.FnFunc
		{ // function float-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_floatArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_float_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of floats", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(5301), kw_end_DASH_line, int(5301))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(lang.Numbers, "floatArray")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("floatArray is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "floatArrayInit")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("floatArrayInit is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_float_DASH_array = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_float_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float?
	{
		tmp0 := sym_float_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is a floating point number", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3605), kw_end_DASH_line, int(3605))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "or__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{lang.Builtins["float64"], v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					tmp7 = v6
				} else {
					tmp8 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{lang.Builtins["float32"], v2})
					tmp7 = tmp9
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_float_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_float_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// floats
	{
		var tmp1 lang.FnFunc
		{ // function floats
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_floats})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_floats.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to float[]", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(12), kw_line, int(5392), kw_end_DASH_line, int(5392))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "floats")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("floats is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_floats = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_floats.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fn?
	{
		tmp0 := sym_fn_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x implements Fn, i.e. is an object created via fn.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(6216), kw_end_DASH_line, int(6216))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := reflect.TypeOf((*runtime.Fn)(nil))
			tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_fn_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_fn_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fnext
	{
		tmp0 := sym_fnext.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Same as (first (next x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(112), kw_end_DASH_line, int(116))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function fnext
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_first)
				tmp5 := checkDerefVar(var_glojure_DOT_core_next)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(tmp4, []any{tmp6})
				return tmp7
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(116), kw_column, int(8), kw_end_DASH_line, int(116), kw_end_DASH_column, int(47))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_fnext = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_fnext.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future?
	{
		tmp0 := sym_future_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is a future", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6532), kw_end_DASH_line, int(6532))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{nil, v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_future_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_future_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// gensym
	{
		tmp0 := sym_gensym.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_prefix_DASH_string)), kw_doc, "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(599), kw_end_DASH_line, int(599))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_glojure_DOT_core_gensym)
				tmp3 := lang.Apply(tmp2, []any{"G__"})
				return tmp3
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_str)
				tmp4 := checkDerefVar(var_glojure_DOT_core_str)
				tmp5, _ := lang.FieldOrMethod(runtime.RT, "NextID")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("NextID is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{})
				tmp7 := lang.Apply(tmp4, []any{tmp6})
				tmp8 := lang.Apply(tmp3, []any{v2, tmp7})
				tmp9 := lang.Apply(lang.NewSymbol, []any{tmp8})
				return tmp9
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_gensym = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_gensym.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get
	{
		var tmp1 lang.FnFunc
		{ // function get__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 2)
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					var v5 any = lang.NewList(args[2:]...)
					_ = v5
					tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym__DOT_})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_Get})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v4})
					tmp21 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp20, v5})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp12, []any{tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp23})
					tmp25 := lang.Apply(tmp6, []any{tmp24})
					return tmp25
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_get.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map, sym_key), lang.NewVector(sym_map, sym_key, sym_not_DASH_found)), kw_inline, tmp1, kw_doc, "Returns the value mapped to key, not-found or nil if key not present\n  in associative collection, set, string, array, or ILookup instance.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2), int64(3)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1489), kw_end_DASH_line, int(1489))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.Get, []any{v3, v4})
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.Apply(lang.GetDefault, []any{v3, v4, v5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_get = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_get.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// halt-when
	{
		tmp0 := sym_halt_DASH_when.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred), lang.NewVector(sym_pred, sym_retf)), kw_doc, "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(7657), kw_end_DASH_line, int(7657))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_halt_DASH_when)
				tmp4 := lang.Apply(tmp3, []any{v2, nil})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							var tmp8 any
							var tmp9 any
							{ // let
								// let binding "and__0__auto__"
								tmp10 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
								tmp11 := lang.Apply(tmp10, []any{v7})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp14 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
									tmp15 := lang.Apply(tmp14, []any{v7, kw_glojure_DOT_core_SLASH_halt})
									tmp13 = tmp15
								} else {
									tmp13 = v12
								}
								tmp9 = tmp13
							} // end let
							if lang.IsTruthy(tmp9) {
								tmp10 := lang.Apply(kw_glojure_DOT_core_SLASH_halt, []any{v7})
								tmp8 = tmp10
							} else {
								tmp11 := lang.Apply(v5, []any{v7})
								tmp8 = tmp11
							}
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							tmp10 := lang.Apply(v2, []any{v8})
							if lang.IsTruthy(tmp10) {
								tmp11 := checkDerefVar(var_glojure_DOT_core_reduced)
								var tmp12 any
								if lang.IsTruthy(v3) {
									tmp13 := lang.Apply(v5, []any{v7})
									tmp14 := lang.Apply(v3, []any{tmp13, v8})
									tmp12 = tmp14
								} else {
									tmp12 = v8
								}
								tmp15 := lang.NewMap(kw_glojure_DOT_core_SLASH_halt, tmp12)
								tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7678), kw_column, int(24), kw_end_DASH_line, int(7678), kw_end_DASH_column, int(72))
								tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp18 := lang.Apply(tmp11, []any{tmp17})
								tmp9 = tmp18
							} else {
								tmp19 := lang.Apply(v5, []any{v7, v8})
								tmp9 = tmp19
							}
							return tmp9
						default:
							checkArity(args, -1)
							panic("unreachable")
						}
					})
					tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7670), kw_column, int(8), kw_end_DASH_line, int(7679), kw_end_DASH_column, int(34))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7669), kw_column, int(6), kw_end_DASH_line, int(7679), kw_end_DASH_column, int(35))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_halt_DASH_when = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_halt_DASH_when.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ident?
	{
		tmp0 := sym_ident_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a symbol or keyword", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(1608), kw_end_DASH_line, int(1608))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "or__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					tmp7 = v6
				} else {
					tmp8 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp7 = tmp9
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ident_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ident_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// identical?
	{
		var tmp1 lang.FnFunc
		{ // function identical?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_lang_DOT_Util})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{sym_glojure_DOT_core_SLASH_identical})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp5, []any{tmp17})
				return tmp18
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_identical_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Tests if 2 arguments are the same object", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(768), kw_end_DASH_line, int(768))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(lang.Identical, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_identical_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_identical_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-not
	{
		tmp0 := sym_if_DASH_not.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_test, sym_then), lang.NewVector(sym_test, sym_then, sym_else)), kw_doc, "Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(760), kw_end_DASH_line, int(760))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_if_DASH_not})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v5})
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{nil})
				tmp16 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp13, tmp15})
				tmp17 := lang.Apply(tmp6, []any{tmp16})
				return tmp17
			case 5:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_if})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_not})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v4})
				tmp18 := lang.Apply(tmp13, []any{tmp15, tmp17})
				tmp19 := lang.Apply(tmp12, []any{tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := checkDerefVar(var_glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := lang.Apply(tmp23, []any{v6})
				tmp25 := lang.Apply(tmp8, []any{tmp10, tmp20, tmp22, tmp24})
				tmp26 := lang.Apply(tmp7, []any{tmp25})
				return tmp26
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_if_DASH_not = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_if_DASH_not.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ifn?
	{
		tmp0 := sym_ifn_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6209), kw_end_DASH_line, int(6209))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{nil, v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ifn_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ifn_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inc
	{
		var tmp1 lang.FnFunc
		{ // function inc__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_unchecked_inc
				} else {
					tmp14 = sym_inc
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_inc.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one greater than num. Does not auto-promote\n  longs, will throw on overflow. See also: inc'", kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(915), kw_end_DASH_line, int(915))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "inc")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("inc is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_inc = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_inc.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inc'
	{
		var tmp1 lang.FnFunc
		{ // function inc'__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_incP})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_inc_TICK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one greater than num. Supports arbitrary precision.\n  See also: inc", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(908), kw_end_DASH_line, int(908))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "incP")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("incP is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_inc_TICK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_inc_TICK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// indexed?
	{
		tmp0 := sym_indexed_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Return true if coll implements Indexed, indicating efficient lookup by index", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(6263), kw_end_DASH_line, int(6263))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := lang.Apply(tmp3, []any{nil, v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_indexed_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_indexed_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// infinite?
	{
		var tmp1 lang.FnFunc
		{ // function infinite?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym_Double_SLASH_isInfinite})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_infinite_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_inline, tmp1, kw_doc, "Returns true if num is negative or positive infinity, else false", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(7977), kw_end_DASH_line, int(7977))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_infinite_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_infinite_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int
	{
		var tmp1 lang.FnFunc
		{ // function int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_uncheckedIntCast
				} else {
					tmp14 = sym_intCast
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to int", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(875), kw_end_DASH_line, int(875))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "IntCast")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IntCast is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_int = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int-array
	{
		var tmp1 lang.FnFunc
		{ // function int-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_intArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_int_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of ints", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(5356), kw_end_DASH_line, int(5356))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(lang.Numbers, "intArray")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("intArray is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "intArrayInit")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("intArrayInit is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_int_DASH_array = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_int_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// intern
	{
		tmp0 := sym_intern.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns, sym_name), lang.NewVector(sym_ns, sym_name, sym_val)), kw_doc, "Finds or creates a var named by the symbol name in the namespace\n  ns (which can be a symbol or a namespace), setting its root binding\n  to val if supplied. The namespace must exist. The var will adopt any\n  metadata from the name symbol.  Returns the var.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6311), kw_end_DASH_line, int(6311))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "v"
					tmp5 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
					tmp6 := lang.Apply(tmp5, []any{v2})
					tmp7 := lang.Apply(nil, []any{tmp6, v3})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp11 := lang.Apply(tmp10, []any{v3})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp13 := lang.Apply(tmp12, []any{v3})
						tmp14, _ := lang.FieldOrMethod(v8, "setMeta")
						if reflect.TypeOf(tmp14).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMeta is not a function")))
						}
						tmp15 := lang.Apply(tmp14, []any{tmp13})
						tmp9 = tmp15
					} else {
					}
					_ = tmp9
					tmp4 = v8
				} // end let
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "v"
					tmp6 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
					tmp7 := lang.Apply(tmp6, []any{v2})
					tmp8 := lang.Apply(nil, []any{tmp7, v3, v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp12 := lang.Apply(tmp11, []any{v3})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp14 := lang.Apply(tmp13, []any{v3})
						tmp15, _ := lang.FieldOrMethod(v9, "setMeta")
						if reflect.TypeOf(tmp15).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMeta is not a function")))
						}
						tmp16 := lang.Apply(tmp15, []any{tmp14})
						tmp10 = tmp16
					} else {
					}
					_ = tmp10
					tmp5 = v9
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_intern = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_intern.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into-array
	{
		tmp0 := sym_into_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_aseq), lang.NewVector(sym_type, sym_aseq)), kw_doc, "Returns an array with components set to the values in aseq. The array's\n  component type is type if provided, or the type of the first value in\n  aseq if present, or Object. All values in aseq must be compatible with\n  the component type. Class objects for the primitive types can be obtained\n  using, e.g., Integer/TYPE.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(3444), kw_end_DASH_line, int(3444))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp4 := lang.Apply(tmp3, []any{v2})
				tmp5 := lang.Apply(nil, []any{tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := lang.Apply(tmp4, []any{v3})
				tmp6 := lang.Apply(nil, []any{v2, tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_into_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_into_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ints
	{
		var tmp1 lang.FnFunc
		{ // function ints
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_ints})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_ints.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to int[]", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(12), kw_line, int(5397), kw_end_DASH_line, int(5397))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "ints")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ints is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ints = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ints.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// io!
	{
		tmp0 := sym_io_BANG_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "If an io! block occurs in a transaction, throws an\n  IllegalStateException, else runs body in an implicit do. If the\n  first expression in body is a literal string, will use that as the\n  exception message.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(11), kw_line, int(2504), kw_end_DASH_line, int(2504))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "message"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
					tmp8 := checkDerefVar(var_glojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v4})
					tmp10 := lang.Apply(tmp7, []any{tmp9})
					if lang.IsTruthy(tmp10) {
						tmp11 := checkDerefVar(var_glojure_DOT_core_first)
						tmp12 := lang.Apply(tmp11, []any{v4})
						tmp6 = tmp12
					} else {
					}
					var v13 any = tmp6
					_ = v13
					// let binding "body"
					var tmp14 any
					if lang.IsTruthy(v13) {
						tmp15 := checkDerefVar(var_glojure_DOT_core_next)
						tmp16 := lang.Apply(tmp15, []any{v4})
						tmp14 = tmp16
					} else {
						tmp14 = v4
					}
					var v17 any = tmp14
					_ = v17
					tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := lang.Apply(tmp20, []any{sym_if})
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp25 := checkDerefVar(var_glojure_DOT_core_list)
					tmp26 := lang.Apply(tmp25, []any{sym_glojure_DOT_lang_DOT_LockingTransaction_SLASH_isRunning})
					tmp27 := lang.Apply(tmp24, []any{tmp26})
					tmp28 := lang.Apply(tmp23, []any{tmp27})
					tmp29 := lang.Apply(tmp22, []any{tmp28})
					tmp30 := checkDerefVar(var_glojure_DOT_core_list)
					tmp31 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp32 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp33 := checkDerefVar(var_glojure_DOT_core_list)
					tmp34 := lang.Apply(tmp33, []any{sym_throw})
					tmp35 := checkDerefVar(var_glojure_DOT_core_list)
					tmp36 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp37 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp38 := checkDerefVar(var_glojure_DOT_core_list)
					tmp39 := lang.Apply(tmp38, []any{sym_new})
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{sym_glojure_DOT_core_SLASH_IllegalStateException})
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					var tmp43 any
					{ // let
						// let binding "or__0__auto__"
						var v44 any = v13
						_ = v44
						var tmp45 any
						if lang.IsTruthy(v44) {
							tmp45 = v44
						} else {
							tmp45 = "I/O in transaction"
						}
						tmp43 = tmp45
					} // end let
					tmp44 := lang.Apply(tmp42, []any{tmp43})
					tmp45 := lang.Apply(tmp37, []any{tmp39, tmp41, tmp44})
					tmp46 := lang.Apply(tmp36, []any{tmp45})
					tmp47 := lang.Apply(tmp35, []any{tmp46})
					tmp48 := lang.Apply(tmp32, []any{tmp34, tmp47})
					tmp49 := lang.Apply(tmp31, []any{tmp48})
					tmp50 := lang.Apply(tmp30, []any{tmp49})
					tmp51 := checkDerefVar(var_glojure_DOT_core_list)
					tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp53 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp54 := checkDerefVar(var_glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{sym_do})
					tmp56 := lang.Apply(tmp53, []any{tmp55, v17})
					tmp57 := lang.Apply(tmp52, []any{tmp56})
					tmp58 := lang.Apply(tmp51, []any{tmp57})
					tmp59 := lang.Apply(tmp19, []any{tmp21, tmp29, tmp50, tmp58})
					tmp60 := lang.Apply(tmp18, []any{tmp59})
					tmp5 = tmp60
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_io_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_io_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keep-indexed
	{
		tmp0 := sym_keep_DASH_indexed.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_coll)), kw_doc, "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(7372), kw_end_DASH_line, int(7372))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "iv"
						tmp6 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp7 := lang.Apply(tmp6, []any{int64(-1)})
						var v8 any = tmp7
						_ = v8
						var tmp9 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp10 := lang.Apply(v4, nil)
								return tmp10
							case 1:
								v10 := args[0]
								_ = v10
								tmp11 := lang.Apply(v4, []any{v10})
								return tmp11
							case 2:
								v10 := args[0]
								_ = v10
								v11 := args[1]
								_ = v11
								var tmp12 any
								{ // let
									// let binding "i"
									tmp13 := checkDerefVar(var_glojure_DOT_core_inc)
									tmp14, ok := lang.FieldOrMethod(v8, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Deref")))
									}
									var tmp15 any
									switch reflect.TypeOf(tmp14).Kind() {
									case reflect.Func:
										tmp15 = lang.Apply(tmp14, nil)
									default:
										tmp15 = tmp14
									}
									tmp16 := lang.Apply(tmp13, []any{tmp15})
									tmp17, _ := lang.FieldOrMethod(v8, "reset")
									if reflect.TypeOf(tmp17).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp18 := lang.Apply(tmp17, []any{tmp16})
									var v19 any = tmp18
									_ = v19
									// let binding "v"
									tmp20 := lang.Apply(v2, []any{v19, v11})
									var v21 any = tmp20
									_ = v21
									var tmp22 any
									tmp23 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
									tmp24 := lang.Apply(tmp23, []any{v21})
									if lang.IsTruthy(tmp24) {
										tmp22 = v10
									} else {
										tmp25 := lang.Apply(v4, []any{v10, v21})
										tmp22 = tmp25
									}
									tmp12 = tmp22
								} // end let
								return tmp12
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7382), kw_column, int(8), kw_end_DASH_line, int(7390), kw_end_DASH_column, int(33))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp11
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7380), kw_column, int(4), kw_end_DASH_line, int(7390), kw_end_DASH_column, int(35))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				return nil
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_keep_DASH_indexed = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_keep_DASH_indexed.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keyword
	{
		tmp1 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp0 := sym_keyword.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_name), lang.NewVector(sym_ns, sym_name)), kw_doc, "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(609), kw_end_DASH_line, int(609))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					tmp4 = v3
				} else {
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v3})
					if lang.IsTruthy(tmp9) {
						tmp10 := lang.Apply(lang.InternKeywordSymbol, []any{v3})
						tmp7 = tmp10
					} else {
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v3})
						if lang.IsTruthy(tmp13) {
							tmp14 := lang.Apply(lang.InternKeywordString, []any{v3})
							tmp11 = tmp14
						} else {
						}
						tmp7 = tmp11
					}
					tmp4 = tmp7
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.InternKeyword, []any{v3, v4})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_keyword = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_keyword.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// last
	{
		tmp0 := sym_last.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Return the last item in coll, in linear time", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(262), kw_end_DASH_line, int(266))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function last
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
			recur_loop_32:
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_next)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_next)
					tmp9 := lang.Apply(tmp8, []any{v3})
					var tmp7 any = tmp9
					v3 = tmp7
					goto recur_loop_32
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp4 = tmp11
				}
				return tmp4
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(266), kw_column, int(7), kw_end_DASH_line, int(269), kw_end_DASH_column, int(21))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_last = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_last.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// libspec?
	{
		tmp0 := sym_libspec_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is a libspec", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(5848), kw_end_DASH_line, int(5848), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "or__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					tmp7 = v6
				} else {
					var tmp8 any
					{ // let
						// let binding "and__0__auto__"
						tmp9 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
						tmp10 := lang.Apply(tmp9, []any{v2})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "or__0__auto__"
								tmp14 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
								tmp15 := checkDerefVar(var_glojure_DOT_core_second)
								tmp16 := lang.Apply(tmp15, []any{v2})
								tmp17 := lang.Apply(tmp14, []any{tmp16})
								var v18 any = tmp17
								_ = v18
								var tmp19 any
								if lang.IsTruthy(v18) {
									tmp19 = v18
								} else {
									tmp20 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
									tmp21 := checkDerefVar(var_glojure_DOT_core_second)
									tmp22 := lang.Apply(tmp21, []any{v2})
									tmp23 := lang.Apply(tmp20, []any{tmp22})
									tmp19 = tmp23
								}
								tmp13 = tmp19
							} // end let
							tmp12 = tmp13
						} else {
							tmp12 = v11
						}
						tmp8 = tmp12
					} // end let
					tmp7 = tmp8
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_libspec_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_libspec_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list*
	{
		tmp0 := sym_list_STAR_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_args), lang.NewVector(sym_a, sym_args), lang.NewVector(sym_a, sym_b, sym_args), lang.NewVector(sym_a, sym_b, sym_c, sym_args), lang.NewVector(sym_a, sym_b, sym_c, sym_d, sym__AMP_, sym_more)), kw_doc, "Creates a new seq containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(641), kw_end_DASH_line, int(641))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp4 := lang.Apply(tmp3, []any{v2})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp6 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp7 := lang.Apply(tmp6, []any{v3, v4})
				tmp8 := lang.Apply(tmp5, []any{v2, tmp7})
				return tmp8
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp7 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp8 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				tmp10 := lang.Apply(tmp7, []any{v3, tmp9})
				tmp11 := lang.Apply(tmp6, []any{v2, tmp10})
				return tmp11
			default:
				checkArityGTE(args, 4)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var v6 any = lang.NewList(args[4:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp8 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp9 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp10 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp11 := checkDerefVar(var_glojure_DOT_core_spread)
				tmp12 := lang.Apply(tmp11, []any{v6})
				tmp13 := lang.Apply(tmp10, []any{v5, tmp12})
				tmp14 := lang.Apply(tmp9, []any{v4, tmp13})
				tmp15 := lang.Apply(tmp8, []any{v3, tmp14})
				tmp16 := lang.Apply(tmp7, []any{v2, tmp15})
				return tmp16
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_list_STAR_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_list_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// loaded-libs
	{
		tmp0 := sym_loaded_DASH_libs.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a sorted set of symbols naming the currently loaded libs", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(6090), kw_end_DASH_line, int(6090))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_glojure_DOT_core_deref)
			tmp3 := checkDerefVar(var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_)
			tmp4 := lang.Apply(tmp2, []any{tmp3})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_loaded_DASH_libs = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_loaded_DASH_libs.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// long
	{
		var tmp1 lang.FnFunc
		{ // function long__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_LongCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_long.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to long", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3481), kw_end_DASH_line, int(3481))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.LongCast, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_long = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_long.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// long-array
	{
		var tmp1 lang.FnFunc
		{ // function long-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_longArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_long_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of longs", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(5364), kw_end_DASH_line, int(5364))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(lang.Numbers, "longArray")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("longArray is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "longArrayInit")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("longArrayInit is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_long_DASH_array = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_long_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// longs
	{
		var tmp1 lang.FnFunc
		{ // function longs
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_longs})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_longs.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to long[]", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(12), kw_line, int(5407), kw_end_DASH_line, int(5407))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "longs")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("longs is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_longs = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_longs.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// macroexpand
	{
		tmp0 := sym_macroexpand.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_form)), kw_doc, "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(4025), kw_end_DASH_line, int(4025))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "ex"
				tmp4 := checkDerefVar(var_glojure_DOT_core_macroexpand_DASH_1)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v6, v2})
				if lang.IsTruthy(tmp9) {
					tmp7 = v2
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_macroexpand)
					tmp11 := lang.Apply(tmp10, []any{v6})
					tmp7 = tmp11
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_macroexpand = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_macroexpand.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map-indexed
	{
		tmp0 := sym_map_DASH_indexed.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_coll)), kw_doc, "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(7309), kw_end_DASH_line, int(7309))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "i"
						tmp6 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp7 := lang.Apply(tmp6, []any{int64(-1)})
						var v8 any = tmp7
						_ = v8
						var tmp9 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp10 := lang.Apply(v4, nil)
								return tmp10
							case 1:
								v10 := args[0]
								_ = v10
								tmp11 := lang.Apply(v4, []any{v10})
								return tmp11
							case 2:
								v10 := args[0]
								_ = v10
								v11 := args[1]
								_ = v11
								tmp12 := checkDerefVar(var_glojure_DOT_core_inc)
								tmp13, ok := lang.FieldOrMethod(v8, "Deref")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Deref")))
								}
								var tmp14 any
								switch reflect.TypeOf(tmp13).Kind() {
								case reflect.Func:
									tmp14 = lang.Apply(tmp13, nil)
								default:
									tmp14 = tmp13
								}
								tmp15 := lang.Apply(tmp12, []any{tmp14})
								tmp16, _ := lang.FieldOrMethod(v8, "reset")
								if reflect.TypeOf(tmp16).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
								}
								tmp17 := lang.Apply(tmp16, []any{tmp15})
								tmp18 := lang.Apply(v2, []any{tmp17, v11})
								tmp19 := lang.Apply(v4, []any{v10, tmp18})
								return tmp19
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7320), kw_column, int(8), kw_end_DASH_line, int(7324), kw_end_DASH_column, int(48))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp11
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7318), kw_column, int(4), kw_end_DASH_line, int(7324), kw_end_DASH_column, int(50))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				return nil
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_map_DASH_indexed = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_map_DASH_indexed.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// maybe-destructured
	{
		tmp0 := sym_maybe_DASH_destructured.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(4514), kw_column, int(7), kw_end_DASH_line, int(4515), kw_end_DASH_column, int(20), kw_arglists, lang.NewList(lang.NewVector(sym_params, sym_body)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
			tmp6 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
			tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp4 = tmp9
			} else {
				var tmp10 any
				{ // let
					// let binding "params"
					var v11 any = v2
					_ = v11
					// let binding "new-params"
					tmp12 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp13 := lang.NewVector()
					tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4520), kw_column, int(34), kw_end_DASH_line, int(4520), kw_end_DASH_column, int(35))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp16 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp17 := lang.Apply(tmp16, []any{v11})
					tmp18 := lang.Apply(tmp12, []any{tmp15, tmp17})
					var v19 any = tmp18
					_ = v19
					// let binding "lets"
					tmp20 := lang.NewVector()
					tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4521), kw_column, int(17), kw_end_DASH_line, int(4521), kw_end_DASH_column, int(18))
					tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v23 any = tmp22
					_ = v23
					for {
						var tmp24 any
						if lang.IsTruthy(v11) {
							var tmp25 any
							tmp26 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
							tmp27 := checkDerefVar(var_glojure_DOT_core_first)
							tmp28 := lang.Apply(tmp27, []any{v11})
							tmp29 := lang.Apply(tmp26, []any{tmp28})
							if lang.IsTruthy(tmp29) {
								tmp31 := checkDerefVar(var_glojure_DOT_core_next)
								tmp32 := lang.Apply(tmp31, []any{v11})
								var tmp30 any = tmp32
								tmp34 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp35 := checkDerefVar(var_glojure_DOT_core_first)
								tmp36 := lang.Apply(tmp35, []any{v11})
								tmp37 := lang.Apply(tmp34, []any{v19, tmp36})
								var tmp33 any = tmp37
								var tmp38 any = v23
								v11 = tmp30
								v19 = tmp33
								v23 = tmp38
								continue
							} else {
								var tmp39 any
								{ // let
									// let binding "gparam"
									tmp40 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp41 := lang.Apply(tmp40, []any{"p__"})
									var v42 any = tmp41
									_ = v42
									tmp44 := checkDerefVar(var_glojure_DOT_core_next)
									tmp45 := lang.Apply(tmp44, []any{v11})
									var tmp43 any = tmp45
									tmp47 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp48 := lang.Apply(tmp47, []any{v19, v42})
									var tmp46 any = tmp48
									tmp50 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp51 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp52 := checkDerefVar(var_glojure_DOT_core_first)
									tmp53 := lang.Apply(tmp52, []any{v11})
									tmp54 := lang.Apply(tmp51, []any{v23, tmp53})
									tmp55 := lang.Apply(tmp50, []any{tmp54, v42})
									var tmp49 any = tmp55
									v11 = tmp43
									v19 = tmp46
									v23 = tmp49
									continue
								} // end let
								tmp25 = tmp39
							}
							tmp24 = tmp25
						} else {
							tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp41 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp42 := checkDerefVar(var_glojure_DOT_core_list)
							tmp43 := lang.Apply(tmp42, []any{v19})
							tmp44 := checkDerefVar(var_glojure_DOT_core_list)
							tmp45 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp46 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp47 := checkDerefVar(var_glojure_DOT_core_list)
							tmp48 := lang.Apply(tmp47, []any{sym_glojure_DOT_core_SLASH_let})
							tmp49 := checkDerefVar(var_glojure_DOT_core_list)
							tmp50 := lang.Apply(tmp49, []any{v23})
							tmp51 := lang.Apply(tmp46, []any{tmp48, tmp50, v3})
							tmp52 := lang.Apply(tmp45, []any{tmp51})
							tmp53 := lang.Apply(tmp44, []any{tmp52})
							tmp54 := lang.Apply(tmp41, []any{tmp43, tmp53})
							tmp55 := lang.Apply(tmp40, []any{tmp54})
							tmp24 = tmp55
						}
						tmp10 = tmp24
						break
					}
				} // end let
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_maybe_DASH_destructured = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_maybe_DASH_destructured.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// name
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_name.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns the name String of a string, symbol or keyword.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1585), kw_end_DASH_line, int(1585))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp4 = v3
			} else {
				tmp7, _ := lang.FieldOrMethod(v3, "Name")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Name is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{})
				tmp4 = tmp8
			}
			return tmp4
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_name = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_name.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// neg?
	{
		var tmp1 lang.FnFunc
		{ // function neg?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_isNeg})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_neg_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_inline, tmp1, kw_doc, "Returns true if num is less than zero, else false", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1259), kw_end_DASH_line, int(1259))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "isNeg")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("isNeg is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_neg_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_neg_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-empty
	{
		tmp0 := sym_not_DASH_empty.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "If coll is empty, returns nil, else coll", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(5516), kw_end_DASH_line, int(5516))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp3 = v2
			} else {
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_not_DASH_empty = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_not_DASH_empty.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-aliases
	{
		tmp0 := sym_ns_DASH_aliases.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of the aliases for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4273), kw_end_DASH_line, int(4273))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp4 := lang.Apply(tmp3, []any{v2})
			tmp5, ok := lang.FieldOrMethod(tmp4, "getAliases")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp4, "getAliases")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ns_DASH_aliases = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ns_DASH_aliases.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-map
	{
		tmp0 := sym_ns_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of all the mappings for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4170), kw_end_DASH_line, int(4170))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp4 := lang.Apply(tmp3, []any{v2})
			tmp5, ok := lang.FieldOrMethod(tmp4, "Mappings")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp4, "Mappings")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ns_DASH_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ns_DASH_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-name
	{
		tmp0 := sym_ns_DASH_name.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns the name of the namespace, a symbol.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4163), kw_end_DASH_line, int(4163))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp4 := lang.Apply(tmp3, []any{v2})
			tmp5, ok := lang.FieldOrMethod(tmp4, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp4, "Name")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ns_DASH_name = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ns_DASH_name.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-resolve
	{
		tmp0 := sym_ns_DASH_resolve.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns, sym_sym), lang.NewVector(sym_ns, sym_env, sym_sym)), kw_doc, "Returns the var or Class to which a symbol will be resolved in the\n  namespace (unless found in the environment), else nil.  Note that\n  if the symbol is fully qualified, the var/Class to which it resolves\n  need not be present in the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4358), kw_end_DASH_line, int(4358))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_ns_DASH_resolve)
				tmp5 := lang.Apply(tmp4, []any{v2, nil, v3})
				return tmp5
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3, v4})
				if lang.IsTruthy(tmp7) {
				} else {
					tmp8 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp10, _ := lang.FieldOrMethod(runtime.Compiler, "maybeResolveIn")
					if reflect.TypeOf(tmp10).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("maybeResolveIn is not a function")))
					}
					tmp11 := lang.Apply(tmp10, []any{tmp9, v4})
					tmp5 = tmp11
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ns_DASH_resolve = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ns_DASH_resolve.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-unalias
	{
		tmp0 := sym_ns_DASH_unalias.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns, sym_sym)), kw_doc, "Removes the alias for the symbol from the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4280), kw_end_DASH_line, int(4280))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp5 := lang.Apply(tmp4, []any{v2})
			tmp6, _ := lang.FieldOrMethod(tmp5, "removeAlias")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeAlias is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v3})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ns_DASH_unalias = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ns_DASH_unalias.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-unmap
	{
		tmp0 := sym_ns_DASH_unmap.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns, sym_sym)), kw_doc, "Removes the mappings for the symbol from the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4177), kw_end_DASH_line, int(4177))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp5 := lang.Apply(tmp4, []any{v2})
			tmp6, _ := lang.FieldOrMethod(tmp5, "unmap")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unmap is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v3})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ns_DASH_unmap = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ns_DASH_unmap.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nth
	{
		var tmp1 lang.FnFunc
		{ // function nth__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 2)
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					var v5 any = lang.NewList(args[2:]...)
					_ = v5
					tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym__DOT_})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_Nth})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := lang.Apply(tmp20, []any{sym_glojure_DOT_core_SLASH_unquote})
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{sym_glojure_DOT_core_SLASH_c})
					tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
					tmp25 := lang.Apply(tmp18, []any{tmp24})
					tmp26 := lang.Apply(tmp17, []any{tmp25})
					tmp27 := checkDerefVar(var_glojure_DOT_core_list)
					tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp29 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp30 := checkDerefVar(var_glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{sym_glojure_DOT_core_SLASH_unquote})
					tmp32 := checkDerefVar(var_glojure_DOT_core_list)
					tmp33 := lang.Apply(tmp32, []any{sym_glojure_DOT_core_SLASH_i})
					tmp34 := lang.Apply(tmp29, []any{tmp31, tmp33})
					tmp35 := lang.Apply(tmp28, []any{tmp34})
					tmp36 := lang.Apply(tmp27, []any{tmp35})
					tmp37 := checkDerefVar(var_glojure_DOT_core_list)
					tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp39 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					tmp43 := lang.Apply(tmp42, []any{sym_glojure_DOT_core_SLASH_nf})
					tmp44 := lang.Apply(tmp39, []any{tmp41, tmp43})
					tmp45 := lang.Apply(tmp38, []any{tmp44})
					tmp46 := lang.Apply(tmp37, []any{tmp45})
					tmp47 := lang.Apply(tmp14, []any{tmp16, tmp26, tmp36, tmp46})
					tmp48 := lang.Apply(tmp13, []any{tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp50 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp49})
					tmp51 := lang.Apply(tmp6, []any{tmp50})
					return tmp51
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_nth.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_index), lang.NewVector(sym_coll, sym_index, sym_not_DASH_found)), kw_inline, tmp1, kw_doc, "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, Java arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2), int64(3)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(882), kw_end_DASH_line, int(882))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(runtime.RT, "Nth")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Nth is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(runtime.RT, "NthDefault")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("NthDefault is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v3, v4, v5})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_nth = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_nth.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// num
	{
		var tmp1 lang.FnFunc
		{ // function num__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_num})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_num.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to Number", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(3474), kw_end_DASH_line, int(3474))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "num")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("num is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_num = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_num.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// object-array
	{
		var tmp1 lang.FnFunc
		{ // function object-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_Object_array})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_object_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of objects", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(5349), kw_end_DASH_line, int(5349))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "Object_array")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Object_array is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_object_DASH_array = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_object_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-impls
	{
		tmp0 := sym_parse_DASH_impls.WithMeta(lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(13), kw_column, int(8), kw_end_DASH_line, int(13), kw_end_DASH_column, int(18), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_specs)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "ret"
				tmp4 := lang.NewMap()
				tmp5 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(14), kw_column, int(14), kw_end_DASH_line, int(14), kw_end_DASH_column, int(15))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v7 any = tmp6
				_ = v7
				// let binding "s"
				var v8 any = v2
				_ = v8
				for {
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp11 := lang.Apply(tmp10, []any{v8})
					if lang.IsTruthy(tmp11) {
						tmp13 := checkDerefVar(var_glojure_DOT_core_assoc)
						tmp14 := checkDerefVar(var_glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v8})
						tmp16 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
						tmp17 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp18 := checkDerefVar(var_glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v8})
						tmp20 := lang.Apply(tmp16, []any{tmp17, tmp19})
						tmp21 := lang.Apply(tmp13, []any{v7, tmp15, tmp20})
						var tmp12 any = tmp21
						tmp23 := checkDerefVar(var_glojure_DOT_core_drop_DASH_while)
						tmp24 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp25 := checkDerefVar(var_glojure_DOT_core_next)
						tmp26 := lang.Apply(tmp25, []any{v8})
						tmp27 := lang.Apply(tmp23, []any{tmp24, tmp26})
						var tmp22 any = tmp27
						v7 = tmp12
						v8 = tmp22
						continue
					} else {
						tmp9 = v7
					}
					tmp3 = tmp9
					break
				}
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_parse_DASH_impls = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_parse_DASH_impls.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-uuid
	{
		tmp0 := sym_parse_DASH_uuid.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Parse a string representing a UUID and return a java.util.UUID instance,\n  or nil if parse fails.\n\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#toString--", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7946), kw_end_DASH_line, int(7946))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						tmp4 := reflect.TypeOf((*lang.IllegalArgumentError)(nil))
						if lang.CatchMatches(r, tmp4) {
							v5 := r
							_ = v5
						} else {
							panic(r)
						}
					}
				}()
				var tmp5 any
				{ // let
					// let binding "vec__362"
					tmp6 := lang.Apply(uuid13.Parse, []any{v2})
					var v7 any = tmp6
					_ = v7
					// let binding "uuid"
					tmp8 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp9 := lang.Apply(tmp8, []any{v7, int64(0), nil})
					var v10 any = tmp9
					_ = v10
					// let binding "err"
					tmp11 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp12 := lang.Apply(tmp11, []any{v7, int64(1), nil})
					var v13 any = tmp12
					_ = v13
					var tmp14 any
					if lang.IsTruthy(v13) {
						tmp15 := checkDerefVar(var_glojure_DOT_core_str)
						tmp16 := lang.Apply(tmp15, []any{"Error parsing UUID: ", v13})
						tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
						panic(tmp17)
					} else {
						tmp14 = v10
					}
					tmp5 = tmp14
				} // end let
				tmp3 = tmp5
			}()
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_parse_DASH_uuid = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_parse_DASH_uuid.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parsing-err
	{
		tmp0 := sym_parsing_DASH_err.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_val)), kw_doc, "Construct message for parsing for non-string parsing error", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(8), kw_line, int(7921), kw_end_DASH_line, int(7921), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_str)
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp4 = "nil"
			} else {
				tmp7 := checkDerefVar(var_glojure_DOT_core_class)
				tmp8 := lang.Apply(tmp7, []any{v2})
				tmp9, ok := lang.FieldOrMethod(tmp8, "Name")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp8, "Name")))
				}
				var tmp10 any
				switch reflect.TypeOf(tmp9).Kind() {
				case reflect.Func:
					tmp10 = lang.Apply(tmp9, nil)
				default:
					tmp10 = tmp9
				}
				tmp4 = tmp10
			}
			tmp11 := lang.Apply(tmp3, []any{"Expected string, got ", tmp4})
			return tmp11
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_parsing_DASH_err = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_parsing_DASH_err.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pos?
	{
		var tmp1 lang.FnFunc
		{ // function pos?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_isPos})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_pos_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_inline, tmp1, kw_doc, "Returns true if num is greater than zero, else false", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1252), kw_end_DASH_line, int(1252))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "isPos")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("isPos is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_pos_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_pos_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prependss
	{
		tmp0 := sym_prependss.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_coll)), kw_doc, "Prepends a symbol or a seq to coll", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(8), kw_line, int(5857), kw_end_DASH_line, int(5857), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp8 := lang.Apply(tmp7, []any{v2, v3})
				tmp4 = tmp8
			} else {
				tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_prependss = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_prependss.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-ctor
	{
		tmp0 := sym_print_DASH_ctor.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(95), kw_column, int(7), kw_end_DASH_line, int(95), kw_end_DASH_column, int(16), kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_print_DASH_args, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5 := lang.Apply(lang.WriteWriter, []any{v4, "#=("})
			_ = tmp5
			tmp6 := checkDerefVar(var_glojure_DOT_core_class)
			tmp7 := lang.Apply(tmp6, []any{v2})
			tmp8, ok := lang.FieldOrMethod(tmp7, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp7, "Name")))
			}
			var tmp9 any
			switch reflect.TypeOf(tmp8).Kind() {
			case reflect.Func:
				tmp9 = lang.Apply(tmp8, nil)
			default:
				tmp9 = tmp8
			}
			tmp10 := lang.Apply(lang.WriteWriter, []any{v4, tmp9})
			_ = tmp10
			tmp11 := lang.Apply(lang.WriteWriter, []any{v4, ". "})
			_ = tmp11
			tmp12 := lang.Apply(v3, []any{v2, v4})
			_ = tmp12
			tmp13 := lang.Apply(lang.WriteWriter, []any{v4, ")"})
			return tmp13
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_print_DASH_ctor = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_ctor.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// quot
	{
		var tmp1 lang.FnFunc
		{ // function quot__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_quotient})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_quot.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num, sym_div)), kw_inline, tmp1, kw_doc, "quot[ient] of dividing numerator by denominator.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1266), kw_end_DASH_line, int(1266))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "quotient")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("quotient is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_quot = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_quot.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// range
	{
		tmp0 := sym_range.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_end), lang.NewVector(sym_start, sym_end), lang.NewVector(sym_start, sym_end, sym_step)), kw_doc, "Returns a lazy seq of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end to\n  infinity. When step is equal to 0, returns an infinite sequence of\n  start. When start is equal to end, returns empty list.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3018), kw_end_DASH_line, int(3018))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_glojure_DOT_core_iterate)
				tmp3 := checkDerefVar(var_glojure_DOT_core_inc_TICK_)
				tmp4 := lang.Apply(tmp2, []any{tmp3, int64(0)})
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				if lang.IsTruthy(tmp5) {
					tmp6 := lang.Apply(lang.NewLongRange, []any{int64(0), v2, int64(1)})
					tmp3 = tmp6
				} else {
					tmp7 := lang.Apply(lang.NewRange, []any{int64(0), v2, int64(1)})
					tmp3 = tmp7
				}
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				var tmp5 any
				{ // let
					// let binding "and__0__auto__"
					tmp6 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
					tmp7 := lang.Apply(tmp6, []any{v2})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp10 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v3})
						tmp9 = tmp11
					} else {
						tmp9 = v8
					}
					tmp5 = tmp9
				} // end let
				if lang.IsTruthy(tmp5) {
					tmp6 := lang.Apply(lang.NewLongRange, []any{v2, v3, int64(1)})
					tmp4 = tmp6
				} else {
					tmp7 := lang.Apply(lang.NewRange, []any{v2, v3, int64(1)})
					tmp4 = tmp7
				}
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				var tmp6 any
				{ // let
					// let binding "and__0__auto__"
					tmp7 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{v2})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						var tmp11 any
						{ // let
							// let binding "and__0__auto__"
							tmp12 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
							tmp13 := lang.Apply(tmp12, []any{v3})
							var v14 any = tmp13
							_ = v14
							var tmp15 any
							if lang.IsTruthy(v14) {
								tmp16 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
								tmp17 := lang.Apply(tmp16, []any{v4})
								tmp15 = tmp17
							} else {
								tmp15 = v14
							}
							tmp11 = tmp15
						} // end let
						tmp10 = tmp11
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				if lang.IsTruthy(tmp6) {
					tmp7 := lang.Apply(lang.NewLongRange, []any{v2, v3, v4})
					tmp5 = tmp7
				} else {
					tmp8 := lang.Apply(lang.NewRange, []any{v2, v3, v4})
					tmp5 = tmp8
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_range = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_range.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rational?
	{
		tmp0 := sym_rational_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is a rational number", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3613), kw_end_DASH_line, int(3613))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "or__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_integer_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					tmp7 = v6
				} else {
					var tmp8 any
					{ // let
						// let binding "or__0__auto__"
						tmp9 := checkDerefVar(var_glojure_DOT_core_ratio_QMARK_)
						tmp10 := lang.Apply(tmp9, []any{v2})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							tmp12 = v11
						} else {
							tmp13 := checkDerefVar(var_glojure_DOT_core_decimal_QMARK_)
							tmp14 := lang.Apply(tmp13, []any{v2})
							tmp12 = tmp14
						}
						tmp8 = tmp12
					} // end let
					tmp7 = tmp8
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_rational_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_rational_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce1
	{
		tmp0 := sym_reduce1.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(923), kw_column, int(7), kw_end_DASH_line, int(924), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_val, sym_coll)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "s"
					tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp6 := lang.Apply(tmp5, []any{v3})
					var v7 any = tmp6
					_ = v7
					var tmp8 any
					if lang.IsTruthy(v7) {
						tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
						tmp10 := checkDerefVar(var_glojure_DOT_core_first)
						tmp11 := lang.Apply(tmp10, []any{v7})
						tmp12 := checkDerefVar(var_glojure_DOT_core_next)
						tmp13 := lang.Apply(tmp12, []any{v7})
						tmp14 := lang.Apply(tmp9, []any{v2, tmp11, tmp13})
						tmp8 = tmp14
					} else {
						tmp15 := lang.Apply(v2, nil)
						tmp8 = tmp15
					}
					tmp4 = tmp8
				} // end let
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
			recur_loop_156:
				var tmp5 any
				{ // let
					// let binding "s"
					tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp7 := lang.Apply(tmp6, []any{v4})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						var tmp10 any
						tmp11 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v8})
						if lang.IsTruthy(tmp12) {
							var tmp13 any = v2
							tmp15 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
							tmp16 := lang.Apply(tmp15, []any{v8})
							tmp17, _ := lang.FieldOrMethod(tmp16, "ReduceInit")
							if reflect.TypeOf(tmp17).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
							}
							tmp18 := lang.Apply(tmp17, []any{v2, v3})
							var tmp14 any = tmp18
							tmp20 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_next)
							tmp21 := lang.Apply(tmp20, []any{v8})
							var tmp19 any = tmp21
							v2 = tmp13
							v3 = tmp14
							v4 = tmp19
							goto recur_loop_156
						} else {
							var tmp22 any = v2
							tmp24 := checkDerefVar(var_glojure_DOT_core_first)
							tmp25 := lang.Apply(tmp24, []any{v8})
							tmp26 := lang.Apply(v2, []any{v3, tmp25})
							var tmp23 any = tmp26
							tmp28 := checkDerefVar(var_glojure_DOT_core_next)
							tmp29 := lang.Apply(tmp28, []any{v8})
							var tmp27 any = tmp29
							v2 = tmp22
							v3 = tmp23
							v4 = tmp27
							goto recur_loop_156
						}
						tmp9 = tmp10
					} else {
						tmp9 = v3
					}
					tmp5 = tmp9
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reduce1 = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reduce1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduced?
	{
		var tmp1 lang.FnFunc
		{ // function reduced?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_IsReduced})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_reduced_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns true if x is the result of a call to reduced", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2834), kw_end_DASH_line, int(2834))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.IsReduced, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reduced_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reduced_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reductions
	{
		tmp0 := sym_reductions.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_init, sym_coll)), kw_doc, "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7196), kw_end_DASH_line, int(7196))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp5 any
					{ // let
						// let binding "temp__0__auto__"
						tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp7 := lang.Apply(tmp6, []any{v3})
						var v8 any = tmp7
						_ = v8
						var tmp9 any
						if lang.IsTruthy(v8) {
							var tmp10 any
							{ // let
								// let binding "s"
								var v11 any = v8
								_ = v11
								tmp12 := checkDerefVar(var_glojure_DOT_core_reductions)
								tmp13 := checkDerefVar(var_glojure_DOT_core_first)
								tmp14 := lang.Apply(tmp13, []any{v11})
								tmp15 := checkDerefVar(var_glojure_DOT_core_rest)
								tmp16 := lang.Apply(tmp15, []any{v11})
								tmp17 := lang.Apply(tmp12, []any{v2, tmp14, tmp16})
								tmp10 = tmp17
							} // end let
							tmp9 = tmp10
						} else {
							tmp11 := checkDerefVar(var_glojure_DOT_core_list)
							tmp12 := lang.Apply(v2, nil)
							tmp13 := lang.Apply(tmp11, []any{tmp12})
							tmp9 = tmp13
						}
						tmp5 = tmp9
					} // end let
					return tmp5
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := checkDerefVar(var_glojure_DOT_core_deref)
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					tmp5 = tmp11
				} else {
					tmp12 := checkDerefVar(var_glojure_DOT_core_cons)
					var tmp13 lang.FnFunc
					tmp13 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						var tmp14 any
						{ // let
							// let binding "temp__0__auto__"
							tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp16 := lang.Apply(tmp15, []any{v4})
							var v17 any = tmp16
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								var tmp19 any
								{ // let
									// let binding "s"
									var v20 any = v17
									_ = v20
									tmp21 := checkDerefVar(var_glojure_DOT_core_reductions)
									tmp22 := checkDerefVar(var_glojure_DOT_core_first)
									tmp23 := lang.Apply(tmp22, []any{v20})
									tmp24 := lang.Apply(v2, []any{v3, tmp23})
									tmp25 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp26 := lang.Apply(tmp25, []any{v20})
									tmp27 := lang.Apply(tmp21, []any{v2, tmp24, tmp26})
									tmp19 = tmp27
								} // end let
								tmp18 = tmp19
							} else {
							}
							tmp14 = tmp18
						} // end let
						return tmp14
					})
					tmp14 := lang.Apply(lang.NewLazySeq, []any{tmp13})
					tmp15 := lang.Apply(tmp12, []any{v3, tmp14})
					tmp5 = tmp15
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reductions = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reductions.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// refer-glojure
	{
		tmp0 := sym_refer_DASH_glojure.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_filters)), kw_doc, "Same as (refer 'glojure.core <filters>)", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(11), kw_line, int(5800), kw_end_DASH_line, int(5800))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_glojure_DOT_core_SLASH_refer})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp11 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{sym_quote})
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core})
				tmp16 := lang.Apply(tmp11, []any{tmp13, tmp15})
				tmp17 := lang.Apply(tmp10, []any{tmp16})
				tmp18 := lang.Apply(tmp9, []any{tmp17})
				tmp19 := lang.Apply(tmp6, []any{tmp8, tmp18, v4})
				tmp20 := lang.Apply(tmp5, []any{tmp19})
				return tmp20
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_refer_DASH_glojure = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_refer_DASH_glojure.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rem
	{
		var tmp1 lang.FnFunc
		{ // function rem__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_remainder})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_rem.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num, sym_div)), kw_inline, tmp1, kw_doc, "remainder of dividing numerator by denominator.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1274), kw_end_DASH_line, int(1274))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "remainder")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("remainder is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_rem = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_rem.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-tap
	{
		tmp0 := sym_remove_DASH_tap.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Remove f from the tap set.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7883), kw_end_DASH_line, int(7883))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_swap_BANG_)
			tmp4 := checkDerefVar(var_glojure_DOT_core_tapset)
			tmp5 := checkDerefVar(var_glojure_DOT_core_disj)
			tmp6 := lang.Apply(tmp3, []any{tmp4, tmp5, v2})
			_ = tmp6
			return nil
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_remove_DASH_tap = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_remove_DASH_tap.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// resolve
	{
		tmp0 := sym_resolve.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym), lang.NewVector(sym_env, sym_sym)), kw_doc, "same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4371), kw_end_DASH_line, int(4371))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_ns_DASH_resolve)
				tmp4 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_ns_DASH_resolve)
				tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v2, v3})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_resolve = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_resolve.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reverse
	{
		tmp0 := sym_reverse.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a seq of the items in coll in reverse order. Not lazy.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(940), kw_end_DASH_line, int(940))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_reduce1)
			tmp4 := checkDerefVar(var_glojure_DOT_core_conj)
			tmp5 := lang.Apply(tmp3, []any{tmp4, lang.NewList(), v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reverse = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reverse.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// root-resource
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_root_DASH_resource.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_lib)), kw_doc, "Returns the root directory path for a lib", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(8), kw_line, int(5864), kw_end_DASH_line, int(5864), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_str)
			tmp5 := checkDerefVar(var_glojure_DOT_core_name)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7 := lang.Apply(strings11.ReplaceAll, []any{tmp6, "-", "_"})
			tmp8 := lang.Apply(strings11.ReplaceAll, []any{tmp7, ".", "/"})
			tmp9 := lang.Apply(tmp4, []any{lang.NewChar(47), tmp8})
			return tmp9
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_root_DASH_resource = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_root_DASH_resource.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// select-keys
	{
		tmp0 := sym_select_DASH_keys.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map, sym_keyseq)), kw_doc, "Returns a map containing only those entries in map whose key is in keys", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(1536), kw_end_DASH_line, int(1536))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := lang.NewMap()
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1541), kw_column, int(16), kw_end_DASH_line, int(1541), kw_end_DASH_column, int(17))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v8 any = tmp7
				_ = v8
				// let binding "keys"
				tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp10 := lang.Apply(tmp9, []any{v3})
				var v11 any = tmp10
				_ = v11
				for {
					var tmp12 any
					if lang.IsTruthy(v11) {
						var tmp13 any
						{ // let
							// let binding "entry"
							tmp14 := checkDerefVar(var_glojure_DOT_core_first)
							tmp15 := lang.Apply(tmp14, []any{v11})
							tmp16, _ := lang.FieldOrMethod(runtime.RT, "Find")
							if reflect.TypeOf(tmp16).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("Find is not a function")))
							}
							tmp17 := lang.Apply(tmp16, []any{v2, tmp15})
							var v18 any = tmp17
							_ = v18
							var tmp20 any
							if lang.IsTruthy(v18) {
								tmp21 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp22 := lang.Apply(tmp21, []any{v8, v18})
								tmp20 = tmp22
							} else {
								tmp20 = v8
							}
							var tmp19 any = tmp20
							tmp24 := checkDerefVar(var_glojure_DOT_core_next)
							tmp25 := lang.Apply(tmp24, []any{v11})
							var tmp23 any = tmp25
							v8 = tmp19
							v11 = tmp23
							continue
						} // end let
						tmp12 = tmp13
					} else {
						tmp14 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
						tmp15 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp16 := lang.Apply(tmp15, []any{v2})
						tmp17 := lang.Apply(tmp14, []any{v8, tmp16})
						tmp12 = tmp17
					}
					tmp4 = tmp12
					break
				}
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_select_DASH_keys = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_select_DASH_keys.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq-to-map-for-destructuring
	{
		tmp0 := sym_seq_DASH_to_DASH_map_DASH_for_DASH_destructuring.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Builds a map from a seq as described in\n  https://glojure.org/reference/special_forms#keyword-arguments", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(34), kw_column, int(7), kw_line, int(4390), kw_end_DASH_line, int(4390))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_next)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp6 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
				tmp7 := lang.Apply(tmp6, []any{v2})
				tmp8 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp7})
				tmp3 = tmp8
			} else {
				var tmp9 any
				tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp11 := lang.Apply(tmp10, []any{v2})
				if lang.IsTruthy(tmp11) {
					tmp12 := checkDerefVar(var_glojure_DOT_core_first)
					tmp13 := lang.Apply(tmp12, []any{v2})
					tmp9 = tmp13
				} else {
				}
				tmp3 = tmp9
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_seq_DASH_to_DASH_map_DASH_for_DASH_destructuring = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_seq_DASH_to_DASH_map_DASH_for_DASH_destructuring.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set
	{
		tmp0 := sym_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a set of the distinct elements of coll.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(4104), kw_end_DASH_line, int(4104))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_set_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp6 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
				tmp7 := lang.Apply(tmp6, []any{v2, nil})
				tmp3 = tmp7
			} else {
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp10 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
				tmp11 := lang.Apply(tmp9, []any{tmp10, v2})
				if lang.IsTruthy(tmp11) {
					tmp12 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_transient)
					tmp15 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4112), kw_column, int(108), kw_end_DASH_line, int(4112), kw_end_DASH_column, int(110))
					tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp18 := lang.Apply(tmp14, []any{tmp17})
					tmp19, _ := lang.FieldOrMethod(v2, "ReduceInit")
					if reflect.TypeOf(tmp19).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
					}
					tmp20 := lang.Apply(tmp19, []any{tmp13, tmp18})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp8 = tmp21
				} else {
					tmp22 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
					tmp23 := checkDerefVar(var_glojure_DOT_core_reduce1)
					tmp24 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp25 := checkDerefVar(var_glojure_DOT_core_transient)
					tmp26 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp27 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4113), kw_column, int(46), kw_end_DASH_line, int(4113), kw_end_DASH_column, int(48))
					tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp29 := lang.Apply(tmp25, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp24, tmp29, v2})
					tmp31 := lang.Apply(tmp22, []any{tmp30})
					tmp8 = tmp31
				}
				tmp3 = tmp8
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_set = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_set.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// short
	{
		var tmp1 lang.FnFunc
		{ // function short__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_uncheckedShortCast
				} else {
					tmp14 = sym_shortCast
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_short.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to short", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3499), kw_end_DASH_line, int(3499))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.ShortCast, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_short = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_short.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// short-array
	{
		var tmp1 lang.FnFunc
		{ // function short-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_shortArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_short_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of shorts", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(5333), kw_end_DASH_line, int(5333))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(lang.Numbers, "shortArray")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("shortArray is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "shortArrayInit")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("shortArrayInit is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_short_DASH_array = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_short_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shorts
	{
		var tmp1 lang.FnFunc
		{ // function shorts
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_shorts})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_shorts.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to shorts[]", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(12), kw_line, int(5387), kw_end_DASH_line, int(5387))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "shorts")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("shorts is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_shorts = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_shorts.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shuffle
	{
		tmp0 := sym_shuffle.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Return a random permutation of coll", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(7300), kw_end_DASH_line, int(7300))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "al"
				tmp4 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
				tmp5 := lang.Apply(tmp4, []any{v2})
				tmp6 := lang.Apply(lang.NewArrayList, []any{tmp5})
				var v7 any = tmp6
				_ = v7
				tmp8 := lang.Apply(nil, []any{v7})
				_ = tmp8
				tmp9, ok := lang.FieldOrMethod(v7, "toArray")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "toArray")))
				}
				var tmp10 any
				switch reflect.TypeOf(tmp9).Kind() {
				case reflect.Func:
					tmp10 = lang.Apply(tmp9, nil)
				default:
					tmp10 = tmp9
				}
				tmp11 := lang.Apply(nil, []any{tmp10})
				tmp3 = tmp11
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_shuffle = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_shuffle.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-ident?
	{
		tmp0 := sym_simple_DASH_ident_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a symbol or keyword without a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1613), kw_end_DASH_line, int(1613))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "and__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_ident_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
					tmp9 := checkDerefVar(var_glojure_DOT_core_namespace)
					tmp10 := lang.Apply(tmp9, []any{v2})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					tmp7 = tmp11
				} else {
					tmp7 = v6
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_simple_DASH_ident_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_simple_DASH_ident_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-symbol?
	{
		tmp0 := sym_simple_DASH_symbol_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a symbol without a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(1623), kw_end_DASH_line, int(1623))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "and__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
					tmp9 := checkDerefVar(var_glojure_DOT_core_namespace)
					tmp10 := lang.Apply(tmp9, []any{v2})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					tmp7 = tmp11
				} else {
					tmp7 = v6
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_simple_DASH_symbol_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_simple_DASH_symbol_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some-fn
	{
		tmp0 := sym_some_DASH_fn.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_p), lang.NewVector(sym_p1, sym_p2), lang.NewVector(sym_p1, sym_p2, sym_p3), lang.NewVector(sym_p1, sym_p2, sym_p3, sym__AMP_, sym_ps)), kw_doc, "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(7462), kw_end_DASH_line, int(7462))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				{ // function sp1
					var v4 lang.FnFunc
					tmp3 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v5 := args[0]
							_ = v5
							tmp6 := lang.Apply(v2, []any{v5})
							return tmp6
						case 2:
							v5 := args[0]
							_ = v5
							v6 := args[1]
							_ = v6
							var tmp7 any
							{ // let
								// let binding "or__0__auto__"
								tmp8 := lang.Apply(v2, []any{v5})
								var v9 any = tmp8
								_ = v9
								var tmp10 any
								if lang.IsTruthy(v9) {
									tmp10 = v9
								} else {
									tmp11 := lang.Apply(v2, []any{v6})
									tmp10 = tmp11
								}
								tmp7 = tmp10
							} // end let
							return tmp7
						case 3:
							v5 := args[0]
							_ = v5
							v6 := args[1]
							_ = v6
							v7 := args[2]
							_ = v7
							var tmp8 any
							{ // let
								// let binding "or__0__auto__"
								tmp9 := lang.Apply(v2, []any{v5})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								if lang.IsTruthy(v10) {
									tmp11 = v10
								} else {
									var tmp12 any
									{ // let
										// let binding "or__0__auto__"
										tmp13 := lang.Apply(v2, []any{v6})
										var v14 any = tmp13
										_ = v14
										var tmp15 any
										if lang.IsTruthy(v14) {
											tmp15 = v14
										} else {
											tmp16 := lang.Apply(v2, []any{v7})
											tmp15 = tmp16
										}
										tmp12 = tmp15
									} // end let
									tmp11 = tmp12
								}
								tmp8 = tmp11
							} // end let
							return tmp8
						default:
							checkArityGTE(args, 3)
							v5 := args[0]
							_ = v5
							v6 := args[1]
							_ = v6
							v7 := args[2]
							_ = v7
							var v8 any = lang.NewList(args[3:]...)
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v4, []any{v5, v6, v7})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									tmp13 := checkDerefVar(var_glojure_DOT_core_some)
									tmp14 := lang.Apply(tmp13, []any{v2, v8})
									tmp12 = tmp14
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						}
					})
					v4 = tmp3
					_ = v4
				}
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7469), kw_column, int(6), kw_end_DASH_line, int(7475), kw_end_DASH_column, int(43))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				{ // function sp2
					var v5 lang.FnFunc
					tmp4 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v6 := args[0]
							_ = v6
							var tmp7 any
							{ // let
								// let binding "or__0__auto__"
								tmp8 := lang.Apply(v2, []any{v6})
								var v9 any = tmp8
								_ = v9
								var tmp10 any
								if lang.IsTruthy(v9) {
									tmp10 = v9
								} else {
									tmp11 := lang.Apply(v3, []any{v6})
									tmp10 = tmp11
								}
								tmp7 = tmp10
							} // end let
							return tmp7
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							var tmp8 any
							{ // let
								// let binding "or__0__auto__"
								tmp9 := lang.Apply(v2, []any{v6})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								if lang.IsTruthy(v10) {
									tmp11 = v10
								} else {
									var tmp12 any
									{ // let
										// let binding "or__0__auto__"
										tmp13 := lang.Apply(v2, []any{v7})
										var v14 any = tmp13
										_ = v14
										var tmp15 any
										if lang.IsTruthy(v14) {
											tmp15 = v14
										} else {
											var tmp16 any
											{ // let
												// let binding "or__0__auto__"
												tmp17 := lang.Apply(v3, []any{v6})
												var v18 any = tmp17
												_ = v18
												var tmp19 any
												if lang.IsTruthy(v18) {
													tmp19 = v18
												} else {
													tmp20 := lang.Apply(v3, []any{v7})
													tmp19 = tmp20
												}
												tmp16 = tmp19
											} // end let
											tmp15 = tmp16
										}
										tmp12 = tmp15
									} // end let
									tmp11 = tmp12
								}
								tmp8 = tmp11
							} // end let
							return tmp8
						case 3:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v2, []any{v6})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									var tmp13 any
									{ // let
										// let binding "or__0__auto__"
										tmp14 := lang.Apply(v2, []any{v7})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp16 = v15
										} else {
											var tmp17 any
											{ // let
												// let binding "or__0__auto__"
												tmp18 := lang.Apply(v2, []any{v8})
												var v19 any = tmp18
												_ = v19
												var tmp20 any
												if lang.IsTruthy(v19) {
													tmp20 = v19
												} else {
													var tmp21 any
													{ // let
														// let binding "or__0__auto__"
														tmp22 := lang.Apply(v3, []any{v6})
														var v23 any = tmp22
														_ = v23
														var tmp24 any
														if lang.IsTruthy(v23) {
															tmp24 = v23
														} else {
															var tmp25 any
															{ // let
																// let binding "or__0__auto__"
																tmp26 := lang.Apply(v3, []any{v7})
																var v27 any = tmp26
																_ = v27
																var tmp28 any
																if lang.IsTruthy(v27) {
																	tmp28 = v27
																} else {
																	tmp29 := lang.Apply(v3, []any{v8})
																	tmp28 = tmp29
																}
																tmp25 = tmp28
															} // end let
															tmp24 = tmp25
														}
														tmp21 = tmp24
													} // end let
													tmp20 = tmp21
												}
												tmp17 = tmp20
											} // end let
											tmp16 = tmp17
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						default:
							checkArityGTE(args, 3)
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var v9 any = lang.NewList(args[3:]...)
							_ = v9
							var tmp10 any
							{ // let
								// let binding "or__0__auto__"
								tmp11 := lang.Apply(v5, []any{v6, v7, v8})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp13 = v12
								} else {
									tmp14 := checkDerefVar(var_glojure_DOT_core_some)
									var tmp15 lang.FnFunc
									tmp15 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v16 := args[0]
										_ = v16
										var tmp17 any
										{ // let
											// let binding "or__0__auto__"
											tmp18 := lang.Apply(v2, []any{v16})
											var v19 any = tmp18
											_ = v19
											var tmp20 any
											if lang.IsTruthy(v19) {
												tmp20 = v19
											} else {
												tmp21 := lang.Apply(v3, []any{v16})
												tmp20 = tmp21
											}
											tmp17 = tmp20
										} // end let
										return tmp17
									})
									tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7483), kw_column, int(34), kw_end_DASH_line, int(7483), kw_end_DASH_column, int(52))
									tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp18 := lang.Apply(tmp14, []any{tmp17, v9})
									tmp13 = tmp18
								}
								tmp10 = tmp13
							} // end let
							return tmp10
						}
					})
					v5 = tmp4
					_ = v5
				}
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7477), kw_column, int(6), kw_end_DASH_line, int(7483), kw_end_DASH_column, int(61))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 lang.FnFunc
				{ // function sp3
					var v6 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v7 := args[0]
							_ = v7
							var tmp8 any
							{ // let
								// let binding "or__0__auto__"
								tmp9 := lang.Apply(v2, []any{v7})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								if lang.IsTruthy(v10) {
									tmp11 = v10
								} else {
									var tmp12 any
									{ // let
										// let binding "or__0__auto__"
										tmp13 := lang.Apply(v3, []any{v7})
										var v14 any = tmp13
										_ = v14
										var tmp15 any
										if lang.IsTruthy(v14) {
											tmp15 = v14
										} else {
											tmp16 := lang.Apply(v4, []any{v7})
											tmp15 = tmp16
										}
										tmp12 = tmp15
									} // end let
									tmp11 = tmp12
								}
								tmp8 = tmp11
							} // end let
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v2, []any{v7})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									var tmp13 any
									{ // let
										// let binding "or__0__auto__"
										tmp14 := lang.Apply(v2, []any{v8})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp16 = v15
										} else {
											var tmp17 any
											{ // let
												// let binding "or__0__auto__"
												tmp18 := lang.Apply(v3, []any{v7})
												var v19 any = tmp18
												_ = v19
												var tmp20 any
												if lang.IsTruthy(v19) {
													tmp20 = v19
												} else {
													var tmp21 any
													{ // let
														// let binding "or__0__auto__"
														tmp22 := lang.Apply(v3, []any{v8})
														var v23 any = tmp22
														_ = v23
														var tmp24 any
														if lang.IsTruthy(v23) {
															tmp24 = v23
														} else {
															var tmp25 any
															{ // let
																// let binding "or__0__auto__"
																tmp26 := lang.Apply(v4, []any{v7})
																var v27 any = tmp26
																_ = v27
																var tmp28 any
																if lang.IsTruthy(v27) {
																	tmp28 = v27
																} else {
																	tmp29 := lang.Apply(v4, []any{v8})
																	tmp28 = tmp29
																}
																tmp25 = tmp28
															} // end let
															tmp24 = tmp25
														}
														tmp21 = tmp24
													} // end let
													tmp20 = tmp21
												}
												tmp17 = tmp20
											} // end let
											tmp16 = tmp17
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						case 3:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var tmp10 any
							{ // let
								// let binding "or__0__auto__"
								tmp11 := lang.Apply(v2, []any{v7})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp13 = v12
								} else {
									var tmp14 any
									{ // let
										// let binding "or__0__auto__"
										tmp15 := lang.Apply(v2, []any{v8})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											tmp17 = v16
										} else {
											var tmp18 any
											{ // let
												// let binding "or__0__auto__"
												tmp19 := lang.Apply(v2, []any{v9})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													tmp21 = v20
												} else {
													var tmp22 any
													{ // let
														// let binding "or__0__auto__"
														tmp23 := lang.Apply(v3, []any{v7})
														var v24 any = tmp23
														_ = v24
														var tmp25 any
														if lang.IsTruthy(v24) {
															tmp25 = v24
														} else {
															var tmp26 any
															{ // let
																// let binding "or__0__auto__"
																tmp27 := lang.Apply(v3, []any{v8})
																var v28 any = tmp27
																_ = v28
																var tmp29 any
																if lang.IsTruthy(v28) {
																	tmp29 = v28
																} else {
																	var tmp30 any
																	{ // let
																		// let binding "or__0__auto__"
																		tmp31 := lang.Apply(v3, []any{v9})
																		var v32 any = tmp31
																		_ = v32
																		var tmp33 any
																		if lang.IsTruthy(v32) {
																			tmp33 = v32
																		} else {
																			var tmp34 any
																			{ // let
																				// let binding "or__0__auto__"
																				tmp35 := lang.Apply(v4, []any{v7})
																				var v36 any = tmp35
																				_ = v36
																				var tmp37 any
																				if lang.IsTruthy(v36) {
																					tmp37 = v36
																				} else {
																					var tmp38 any
																					{ // let
																						// let binding "or__0__auto__"
																						tmp39 := lang.Apply(v4, []any{v8})
																						var v40 any = tmp39
																						_ = v40
																						var tmp41 any
																						if lang.IsTruthy(v40) {
																							tmp41 = v40
																						} else {
																							tmp42 := lang.Apply(v4, []any{v9})
																							tmp41 = tmp42
																						}
																						tmp38 = tmp41
																					} // end let
																					tmp37 = tmp38
																				}
																				tmp34 = tmp37
																			} // end let
																			tmp33 = tmp34
																		}
																		tmp30 = tmp33
																	} // end let
																	tmp29 = tmp30
																}
																tmp26 = tmp29
															} // end let
															tmp25 = tmp26
														}
														tmp22 = tmp25
													} // end let
													tmp21 = tmp22
												}
												tmp18 = tmp21
											} // end let
											tmp17 = tmp18
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								}
								tmp10 = tmp13
							} // end let
							return tmp10
						default:
							checkArityGTE(args, 3)
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var v10 any = lang.NewList(args[3:]...)
							_ = v10
							var tmp11 any
							{ // let
								// let binding "or__0__auto__"
								tmp12 := lang.Apply(v6, []any{v7, v8, v9})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp14 = v13
								} else {
									tmp15 := checkDerefVar(var_glojure_DOT_core_some)
									var tmp16 lang.FnFunc
									tmp16 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v17 := args[0]
										_ = v17
										var tmp18 any
										{ // let
											// let binding "or__0__auto__"
											tmp19 := lang.Apply(v2, []any{v17})
											var v20 any = tmp19
											_ = v20
											var tmp21 any
											if lang.IsTruthy(v20) {
												tmp21 = v20
											} else {
												var tmp22 any
												{ // let
													// let binding "or__0__auto__"
													tmp23 := lang.Apply(v3, []any{v17})
													var v24 any = tmp23
													_ = v24
													var tmp25 any
													if lang.IsTruthy(v24) {
														tmp25 = v24
													} else {
														tmp26 := lang.Apply(v4, []any{v17})
														tmp25 = tmp26
													}
													tmp22 = tmp25
												} // end let
												tmp21 = tmp22
											}
											tmp18 = tmp21
										} // end let
										return tmp18
									})
									tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7491), kw_column, int(34), kw_end_DASH_line, int(7491), kw_end_DASH_column, int(59))
									tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp19 := lang.Apply(tmp15, []any{tmp18, v10})
									tmp14 = tmp19
								}
								tmp11 = tmp14
							} // end let
							return tmp11
						}
					})
					v6 = tmp5
					_ = v6
				}
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7485), kw_column, int(6), kw_end_DASH_line, int(7491), kw_end_DASH_column, int(68))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "ps"
					tmp7 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
					tmp8 := lang.Apply(tmp7, []any{v2, v3, v4, v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 lang.FnFunc
					{ // function spn
						var v11 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								return nil
							case 1:
								v12 := args[0]
								_ = v12
								tmp13 := checkDerefVar(var_glojure_DOT_core_some)
								var tmp14 lang.FnFunc
								tmp14 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v15 := args[0]
									_ = v15
									tmp16 := lang.Apply(v15, []any{v12})
									return tmp16
								})
								tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7496), kw_column, int(21), kw_end_DASH_line, int(7496), kw_end_DASH_column, int(26))
								tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp17 := lang.Apply(tmp13, []any{tmp16, v9})
								return tmp17
							case 2:
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								tmp14 := checkDerefVar(var_glojure_DOT_core_some)
								var tmp15 lang.FnFunc
								tmp15 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v16 := args[0]
									_ = v16
									var tmp17 any
									{ // let
										// let binding "or__0__auto__"
										tmp18 := lang.Apply(v16, []any{v12})
										var v19 any = tmp18
										_ = v19
										var tmp20 any
										if lang.IsTruthy(v19) {
											tmp20 = v19
										} else {
											tmp21 := lang.Apply(v16, []any{v13})
											tmp20 = tmp21
										}
										tmp17 = tmp20
									} // end let
									return tmp17
								})
								tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7497), kw_column, int(23), kw_end_DASH_line, int(7497), kw_end_DASH_column, int(39))
								tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp18 := lang.Apply(tmp14, []any{tmp17, v9})
								return tmp18
							case 3:
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								v14 := args[2]
								_ = v14
								tmp15 := checkDerefVar(var_glojure_DOT_core_some)
								var tmp16 lang.FnFunc
								tmp16 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v17 := args[0]
									_ = v17
									var tmp18 any
									{ // let
										// let binding "or__0__auto__"
										tmp19 := lang.Apply(v17, []any{v12})
										var v20 any = tmp19
										_ = v20
										var tmp21 any
										if lang.IsTruthy(v20) {
											tmp21 = v20
										} else {
											var tmp22 any
											{ // let
												// let binding "or__0__auto__"
												tmp23 := lang.Apply(v17, []any{v13})
												var v24 any = tmp23
												_ = v24
												var tmp25 any
												if lang.IsTruthy(v24) {
													tmp25 = v24
												} else {
													tmp26 := lang.Apply(v17, []any{v14})
													tmp25 = tmp26
												}
												tmp22 = tmp25
											} // end let
											tmp21 = tmp22
										}
										tmp18 = tmp21
									} // end let
									return tmp18
								})
								tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7498), kw_column, int(25), kw_end_DASH_line, int(7498), kw_end_DASH_column, int(47))
								tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp19 := lang.Apply(tmp15, []any{tmp18, v9})
								return tmp19
							default:
								checkArityGTE(args, 3)
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								v14 := args[2]
								_ = v14
								var v15 any = lang.NewList(args[3:]...)
								_ = v15
								var tmp16 any
								{ // let
									// let binding "or__0__auto__"
									tmp17 := lang.Apply(v11, []any{v12, v13, v14})
									var v18 any = tmp17
									_ = v18
									var tmp19 any
									if lang.IsTruthy(v18) {
										tmp19 = v18
									} else {
										tmp20 := checkDerefVar(var_glojure_DOT_core_some)
										var tmp21 lang.FnFunc
										tmp21 = lang.NewFnFunc(func(args ...any) any {
											checkArity(args, 1)
											v22 := args[0]
											_ = v22
											tmp23 := checkDerefVar(var_glojure_DOT_core_some)
											tmp24 := lang.Apply(tmp23, []any{v22, v15})
											return tmp24
										})
										tmp22 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7500), kw_column, int(36), kw_end_DASH_line, int(7500), kw_end_DASH_column, int(49))
										tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp24 := lang.Apply(tmp20, []any{tmp23, v9})
										tmp19 = tmp24
									}
									tmp16 = tmp19
								} // end let
								return tmp16
							}
						})
						v11 = tmp10
						_ = v11
					}
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7494), kw_column, int(8), kw_end_DASH_line, int(7500), kw_end_DASH_column, int(56))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp6 = tmp12
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_some_DASH_fn = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_some_DASH_fn.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// split-with
	{
		tmp0 := sym_split_DASH_with.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(2990), kw_end_DASH_line, int(2990))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			tmp6 := checkDerefVar(var_glojure_DOT_core_drop_DASH_while)
			tmp7 := lang.Apply(tmp6, []any{v2, v3})
			tmp8 := lang.NewVector(tmp5, tmp7)
			tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2995), kw_column, int(5), kw_end_DASH_line, int(2995), kw_end_DASH_column, int(51))
			tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp10
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_split_DASH_with = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_split_DASH_with.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-into!
	{
		tmp0 := sym_stream_DASH_into_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_to, sym_stream), lang.NewVector(sym_to, sym_xform, sym_stream)), kw_doc, "Returns a new coll consisting of coll with all of the items of the\n  stream conjoined. This is a terminal operation on the stream.", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(6810), kw_end_DASH_line, int(6810))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp9 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
					tmp10 := checkDerefVar(var_glojure_DOT_core_stream_DASH_reduce_BANG_)
					tmp11 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp12 := checkDerefVar(var_glojure_DOT_core_transient)
					tmp13 := lang.Apply(tmp12, []any{v2})
					tmp14 := lang.Apply(tmp10, []any{tmp11, tmp13, v3})
					tmp15 := lang.Apply(tmp9, []any{tmp14})
					tmp16 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp17 := lang.Apply(tmp16, []any{v2})
					tmp18 := lang.Apply(tmp8, []any{tmp15, tmp17})
					tmp4 = tmp18
				} else {
					tmp19 := checkDerefVar(var_glojure_DOT_core_stream_DASH_reduce_BANG_)
					tmp20 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp21 := lang.Apply(tmp19, []any{tmp20, v2, v3})
					tmp4 = tmp21
				}
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v2})
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp10 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
					tmp11 := checkDerefVar(var_glojure_DOT_core_stream_DASH_transduce_BANG_)
					tmp12 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_transient)
					tmp14 := lang.Apply(tmp13, []any{v2})
					tmp15 := lang.Apply(tmp11, []any{v3, tmp12, tmp14, v4})
					tmp16 := lang.Apply(tmp10, []any{tmp15})
					tmp17 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp18 := lang.Apply(tmp17, []any{v2})
					tmp19 := lang.Apply(tmp9, []any{tmp16, tmp18})
					tmp5 = tmp19
				} else {
					tmp20 := checkDerefVar(var_glojure_DOT_core_stream_DASH_transduce_BANG_)
					tmp21 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp22 := lang.Apply(tmp20, []any{v3, tmp21, v2, v4})
					tmp5 = tmp22
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_stream_DASH_into_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_stream_DASH_into_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subvec
	{
		tmp0 := sym_subvec.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_v, sym_start), lang.NewVector(sym_v, sym_start, sym_end)), kw_doc, "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3819), kw_end_DASH_line, int(3819))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_subvec)
				tmp5 := checkDerefVar(var_glojure_DOT_core_count)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{v2, v3, tmp6})
				return tmp7
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(runtime.RT, "Subvec")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Subvec is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v2, v3, v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_subvec = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_subvec.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// symbol
	{
		tmp1 := reflect.TypeOf((*lang.Symbol)(nil))
		tmp0 := sym_symbol.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_name), lang.NewVector(sym_ns, sym_name)), kw_doc, "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(584), kw_end_DASH_line, int(584))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					tmp4 = v3
				} else {
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{lang.Builtins["string"], v3})
					if lang.IsTruthy(tmp9) {
						tmp10 := lang.Apply(lang.NewSymbol, []any{v3})
						tmp7 = tmp10
					} else {
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp13 := reflect.TypeOf((*lang.Var)(nil))
						tmp14 := lang.Apply(tmp12, []any{tmp13, v3})
						if lang.IsTruthy(tmp14) {
							tmp15, ok := lang.FieldOrMethod(v3, "toSymbol")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "toSymbol")))
							}
							var tmp16 any
							switch reflect.TypeOf(tmp15).Kind() {
							case reflect.Func:
								tmp16 = lang.Apply(tmp15, nil)
							default:
								tmp16 = tmp15
							}
							tmp11 = tmp16
						} else {
							var tmp17 any
							tmp18 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
							tmp19 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
							tmp20 := lang.Apply(tmp18, []any{tmp19, v3})
							if lang.IsTruthy(tmp20) {
								tmp21, ok := lang.FieldOrMethod(v3, "sym")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "sym")))
								}
								var tmp22 any
								switch reflect.TypeOf(tmp21).Kind() {
								case reflect.Func:
									tmp22 = lang.Apply(tmp21, nil)
								default:
									tmp22 = tmp21
								}
								tmp17 = tmp22
							} else {
								var tmp23 any
								if lang.IsTruthy(kw_else) {
									tmp24 := lang.Apply(lang.NewIllegalArgumentError, []any{"no conversion to symbol"})
									panic(tmp24)
								} else {
								}
								tmp17 = tmp23
							}
							tmp11 = tmp17
						}
						tmp7 = tmp11
					}
					tmp4 = tmp7
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.InternSymbol, []any{v3, v4})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 := reflect.TypeOf((*lang.Symbol)(nil))
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_symbol = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_symbol.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// thread-bound?
	{
		tmp0 := sym_thread_DASH_bound_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_vars)), kw_doc, "Returns true if all of the vars provided as arguments have thread-local bindings.\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(5499), kw_end_DASH_line, int(5499))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					tmp6, ok := lang.FieldOrMethod(v5, "getThreadBinding")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "getThreadBinding")))
					}
					var tmp7 any
					switch reflect.TypeOf(tmp6).Kind() {
					case reflect.Func:
						tmp7 = lang.Apply(tmp6, nil)
					default:
						tmp7 = tmp6
					}
					return tmp7
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5505), kw_column, int(11), kw_end_DASH_line, int(5505), kw_end_DASH_column, int(78))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp7 := lang.Apply(tmp3, []any{tmp6, v2})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_thread_DASH_bound_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_thread_DASH_bound_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// type
	{
		tmp0 := sym_type.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns the :type metadata of x, or its Class if none", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3467), kw_end_DASH_line, int(3467))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "or__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_get)
				tmp5 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{tmp6, kw_type})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					tmp9 = v8
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_class)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp9 = tmp11
				}
				tmp3 = tmp9
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_type = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_type.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-add
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-add__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_unchecked_add})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_add.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the sum of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1203), kw_end_DASH_line, int(1203))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_add")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_add is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_add = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_add.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-add-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-add-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_unchecked_int_add})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_add_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the sum of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(1196), kw_end_DASH_line, int(1196))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_int_add")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_int_add is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_add_DASH_int = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_add_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-byte
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-byte__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedByteCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_byte.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to byte. Subject to rounding or truncation.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(3517), kw_end_DASH_line, int(3517))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.UncheckedByteCast, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_byte = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_byte.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-char
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-char__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedCharCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_char.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to char. Subject to rounding or truncation.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(3529), kw_end_DASH_line, int(3529))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "UncheckedCharCast")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedCharCast is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_char = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_char.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-dec
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-dec__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_unchecked_dec})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_dec.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one less than x, a long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1175), kw_end_DASH_line, int(1175))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_dec")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_dec is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_dec = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_dec.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-dec-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-dec-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_unchecked_int_dec})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_dec_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one less than x, an int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(1168), kw_end_DASH_line, int(1168))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_int_dec")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_int_dec is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_dec_DASH_int = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_dec_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-divide-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-divide-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_unchecked_int_divide})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_divide_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(26), kw_column, int(7), kw_line, int(1238), kw_end_DASH_line, int(1238))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_int_divide")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_int_divide is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_divide_DASH_int = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_divide_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-double
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-double__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedDoubleCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_double.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to double. Subject to rounding.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(3553), kw_end_DASH_line, int(3553))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.AsFloat64, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_double = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_double.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-float
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-float__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedFloatCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_float.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to float. Subject to rounding.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(3547), kw_end_DASH_line, int(3547))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.UncheckedFloatCast, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_float = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_float.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-inc
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-inc__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_unchecked_inc})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_inc.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one greater than x, a long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1161), kw_end_DASH_line, int(1161))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_inc")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_inc is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_inc = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_inc.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-inc-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-inc-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_unchecked_int_inc})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_inc_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one greater than x, an int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(1154), kw_end_DASH_line, int(1154))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_int_inc")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_int_inc is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_inc_DASH_int = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_inc_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedIntCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to int. Subject to rounding or truncation.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(3535), kw_end_DASH_line, int(3535))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.UncheckedIntCast, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_int = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-long
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-long__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedLongCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_long.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to long. Subject to rounding or truncation.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(3541), kw_end_DASH_line, int(3541))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.UncheckedLongCast, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_long = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_long.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-multiply
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-multiply__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_unchecked_multiply})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_multiply.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the product of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(1231), kw_end_DASH_line, int(1231))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_multiply")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_multiply is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_multiply = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_multiply.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-multiply-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-multiply-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_unchecked_int_multiply})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_multiply_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the product of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(28), kw_column, int(7), kw_line, int(1224), kw_end_DASH_line, int(1224))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_int_multiply")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_int_multiply is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_multiply_DASH_int = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_multiply_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-negate
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-negate__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_unchecked_minus})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_negate.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns the negation of x, a long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(1189), kw_end_DASH_line, int(1189))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_negate")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_negate is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_negate = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_negate.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-negate-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-negate-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_unchecked_int_negate})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_negate_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns the negation of x, an int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(26), kw_column, int(7), kw_line, int(1182), kw_end_DASH_line, int(1182))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_int_negate")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_int_negate is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_negate_DASH_int = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_negate_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-remainder-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-remainder-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_unchecked_int_remainder})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_remainder_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the remainder of division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(29), kw_column, int(7), kw_line, int(1245), kw_end_DASH_line, int(1245))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_int_remainder")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_int_remainder is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_remainder_DASH_int = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_remainder_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-short
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-short__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedShortCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_short.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to short. Subject to rounding or truncation.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(3523), kw_end_DASH_line, int(3523))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.UncheckedShortCast, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_short = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_short.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-subtract
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-subtract__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_unchecked_minus})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_subtract.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the difference of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(1217), kw_end_DASH_line, int(1217))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_minus")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_minus is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_subtract = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_subtract.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-subtract-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-subtract-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_unchecked_int_subtract})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_subtract_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the difference of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(28), kw_column, int(7), kw_line, int(1210), kw_end_DASH_line, int(1210))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "unchecked_int_subtract")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unchecked_int_subtract is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unchecked_DASH_subtract_DASH_int = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unchecked_DASH_subtract_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unreduced
	{
		tmp0 := sym_unreduced.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "If x is reduced?, returns (deref x), else returns x", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2847), kw_end_DASH_line, int(2847))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp6 := checkDerefVar(var_glojure_DOT_core_deref)
				tmp7 := lang.Apply(tmp6, []any{v2})
				tmp3 = tmp7
			} else {
				tmp3 = v2
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unreduced = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unreduced.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unsigned-bit-shift-right
	{
		var tmp1 lang.FnFunc
		{ // function unsigned-bit-shift-right__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_unsignedShiftRight})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unsigned_DASH_bit_DASH_shift_DASH_right.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_inline, tmp1, kw_doc, "Bitwise shift right, without sign-extension.", kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(30), kw_column, int(7), kw_line, int(1373), kw_end_DASH_line, int(1373))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "unsignedShiftRight")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unsignedShiftRight is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_unsigned_DASH_bit_DASH_shift_DASH_right = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_unsigned_DASH_bit_DASH_shift_DASH_right.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vec
	{
		tmp0 := sym_vec.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Creates a new vector containing the contents of coll. Java arrays\n  will be aliased and should not be modified.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(366), kw_end_DASH_line, int(366))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp8 := reflect.TypeOf((*lang.IObj)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v2})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp11 := lang.Apply(tmp10, []any{v2, nil})
					tmp6 = tmp11
				} else {
					tmp12 := lang.Apply(lang.CreateLazilyPersistentVector, []any{v2})
					tmp6 = tmp12
				}
				tmp3 = tmp6
			} else {
				tmp13 := lang.Apply(lang.CreateLazilyPersistentVector, []any{v2})
				tmp3 = tmp13
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_vec = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_vec.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vswap!
	{
		tmp0 := sym_vswap_BANG_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_vol, sym_f, sym__AMP_, sym_args)), kw_doc, "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(2531), kw_end_DASH_line, int(2531))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 4)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var v6 any = lang.NewList(args[4:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "v"
					tmp8 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp9 := lang.NewMap(kw_tag, sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Volatile)
					tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2537), kw_column, int(26), kw_end_DASH_line, int(2537), kw_end_DASH_column, int(81))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 := lang.Apply(tmp8, []any{v4, tmp11})
					var v13 any = tmp12
					_ = v13
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{sym__DOT_reset})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v13})
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp22 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp23 := checkDerefVar(var_glojure_DOT_core_list)
					tmp24 := lang.Apply(tmp23, []any{v5})
					tmp25 := checkDerefVar(var_glojure_DOT_core_list)
					tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp27 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp28 := checkDerefVar(var_glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{sym__DOT_Deref})
					tmp30 := checkDerefVar(var_glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{v13})
					tmp32 := lang.Apply(tmp27, []any{tmp29, tmp31})
					tmp33 := lang.Apply(tmp26, []any{tmp32})
					tmp34 := lang.Apply(tmp25, []any{tmp33})
					tmp35 := lang.Apply(tmp22, []any{tmp24, tmp34, v6})
					tmp36 := lang.Apply(tmp21, []any{tmp35})
					tmp37 := lang.Apply(tmp20, []any{tmp36})
					tmp38 := lang.Apply(tmp15, []any{tmp17, tmp19, tmp37})
					tmp39 := lang.Apply(tmp14, []any{tmp38})
					tmp7 = tmp39
				} // end let
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_vswap_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_vswap_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// zero?
	{
		var tmp1 lang.FnFunc
		{ // function zero?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_isZero})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_zero_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_inline, tmp1, kw_doc, "Returns true if num is zero, else false", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(860), kw_end_DASH_line, int(860))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "isZero")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("isZero is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_zero_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_zero_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// zipmap
	{
		tmp0 := sym_zipmap.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_keys, sym_vals)), kw_doc, "Returns a map with the keys mapped to the corresponding vals.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6583), kw_end_DASH_line, int(6583))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "map"
				tmp5 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp6 := lang.NewMap()
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6588), kw_column, int(27), kw_end_DASH_line, int(6588), kw_end_DASH_column, int(28))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				var v10 any = tmp9
				_ = v10
				// let binding "ks"
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := lang.Apply(tmp11, []any{v2})
				var v13 any = tmp12
				_ = v13
				// let binding "vs"
				tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp15 := lang.Apply(tmp14, []any{v3})
				var v16 any = tmp15
				_ = v16
				for {
					var tmp17 any
					var tmp18 any
					{ // let
						// let binding "and__0__auto__"
						var v19 any = v13
						_ = v19
						var tmp20 any
						if lang.IsTruthy(v19) {
							tmp20 = v16
						} else {
							tmp20 = v19
						}
						tmp18 = tmp20
					} // end let
					if lang.IsTruthy(tmp18) {
						tmp20 := checkDerefVar(var_glojure_DOT_core_assoc_BANG_)
						tmp21 := checkDerefVar(var_glojure_DOT_core_first)
						tmp22 := lang.Apply(tmp21, []any{v13})
						tmp23 := checkDerefVar(var_glojure_DOT_core_first)
						tmp24 := lang.Apply(tmp23, []any{v16})
						tmp25 := lang.Apply(tmp20, []any{v10, tmp22, tmp24})
						var tmp19 any = tmp25
						tmp27 := checkDerefVar(var_glojure_DOT_core_next)
						tmp28 := lang.Apply(tmp27, []any{v13})
						var tmp26 any = tmp28
						tmp30 := checkDerefVar(var_glojure_DOT_core_next)
						tmp31 := lang.Apply(tmp30, []any{v16})
						var tmp29 any = tmp31
						v10 = tmp19
						v13 = tmp26
						v16 = tmp29
						continue
					} else {
						tmp32 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
						tmp33 := lang.Apply(tmp32, []any{v10})
						tmp17 = tmp33
					}
					tmp4 = tmp17
					break
				}
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_zipmap = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_zipmap.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// NaN?
	{
		var tmp1 lang.FnFunc
		{ // function NaN?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym_math_DOT_IsNaN})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_NaN_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_inline, tmp1, kw_doc, "Returns true if num is NaN, else false", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(7968), kw_end_DASH_line, int(7968))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(math7.IsNaN, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_NaN_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_NaN_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// StackTraceElement->vec
	{
		tmp0 := sym_StackTraceElement_DASH__GT_vec.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_o)), kw_doc, "Constructs a data representation for a StackTraceElement: [class method file line]", kw_file, "glojure/core_print.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(28), kw_column, int(7), kw_line, int(436), kw_end_DASH_line, int(436))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_symbol)
			tmp4, ok := lang.FieldOrMethod(v2, "getClassName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getClassName")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			tmp6 := lang.Apply(tmp3, []any{tmp5})
			tmp7 := checkDerefVar(var_glojure_DOT_core_symbol)
			tmp8, ok := lang.FieldOrMethod(v2, "getMethodName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getMethodName")))
			}
			var tmp9 any
			switch reflect.TypeOf(tmp8).Kind() {
			case reflect.Func:
				tmp9 = lang.Apply(tmp8, nil)
			default:
				tmp9 = tmp8
			}
			tmp10 := lang.Apply(tmp7, []any{tmp9})
			tmp11, ok := lang.FieldOrMethod(v2, "getFileName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getFileName")))
			}
			var tmp12 any
			switch reflect.TypeOf(tmp11).Kind() {
			case reflect.Func:
				tmp12 = lang.Apply(tmp11, nil)
			default:
				tmp12 = tmp11
			}
			tmp13, ok := lang.FieldOrMethod(v2, "getLineNumber")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getLineNumber")))
			}
			var tmp14 any
			switch reflect.TypeOf(tmp13).Kind() {
			case reflect.Func:
				tmp14 = lang.Apply(tmp13, nil)
			default:
				tmp14 = tmp13
			}
			tmp15 := lang.NewVector(tmp6, tmp10, tmp12, tmp14)
			tmp16 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(440), kw_column, int(3), kw_end_DASH_line, int(440), kw_end_DASH_column, int(94))
			tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp17
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_StackTraceElement_DASH__GT_vec = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_StackTraceElement_DASH__GT_vec.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ->
	{
		tmp0 := sym__DASH__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_forms)), kw_doc, "Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(1675), kw_end_DASH_line, int(1675))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "x"
					var v7 any = v4
					_ = v7
					// let binding "forms"
					var v8 any = v5
					_ = v8
					for {
						var tmp9 any
						if lang.IsTruthy(v8) {
							var tmp10 any
							{ // let
								// let binding "form"
								tmp11 := checkDerefVar(var_glojure_DOT_core_first)
								tmp12 := lang.Apply(tmp11, []any{v8})
								var v13 any = tmp12
								_ = v13
								// let binding "threaded"
								var tmp14 any
								tmp15 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
								tmp16 := lang.Apply(tmp15, []any{v13})
								if lang.IsTruthy(tmp16) {
									tmp17 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
									tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp20 := checkDerefVar(var_glojure_DOT_core_list)
									tmp21 := checkDerefVar(var_glojure_DOT_core_first)
									tmp22 := lang.Apply(tmp21, []any{v13})
									tmp23 := lang.Apply(tmp20, []any{tmp22})
									tmp24 := checkDerefVar(var_glojure_DOT_core_list)
									tmp25 := lang.Apply(tmp24, []any{v7})
									tmp26 := checkDerefVar(var_glojure_DOT_core_next)
									tmp27 := lang.Apply(tmp26, []any{v13})
									tmp28 := lang.Apply(tmp19, []any{tmp23, tmp25, tmp27})
									tmp29 := lang.Apply(tmp18, []any{tmp28})
									tmp30 := checkDerefVar(var_glojure_DOT_core_meta)
									tmp31 := lang.Apply(tmp30, []any{v13})
									tmp32 := lang.Apply(tmp17, []any{tmp29, tmp31})
									tmp14 = tmp32
								} else {
									tmp33 := checkDerefVar(var_glojure_DOT_core_list)
									tmp34 := lang.Apply(tmp33, []any{v13, v7})
									tmp14 = tmp34
								}
								var v35 any = tmp14
								_ = v35
								var tmp36 any = v35
								tmp38 := checkDerefVar(var_glojure_DOT_core_next)
								tmp39 := lang.Apply(tmp38, []any{v8})
								var tmp37 any = tmp39
								v7 = tmp36
								v8 = tmp37
								continue
							} // end let
							tmp9 = tmp10
						} else {
							tmp9 = v7
						}
						tmp6 = tmp9
						break
					}
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__DASH__GT_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__DASH__GT_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ->>
	{
		tmp0 := sym__DASH__GT__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_forms)), kw_doc, "Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc.", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(11), kw_line, int(1691), kw_end_DASH_line, int(1691))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "x"
					var v7 any = v4
					_ = v7
					// let binding "forms"
					var v8 any = v5
					_ = v8
					for {
						var tmp9 any
						if lang.IsTruthy(v8) {
							var tmp10 any
							{ // let
								// let binding "form"
								tmp11 := checkDerefVar(var_glojure_DOT_core_first)
								tmp12 := lang.Apply(tmp11, []any{v8})
								var v13 any = tmp12
								_ = v13
								// let binding "threaded"
								var tmp14 any
								tmp15 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
								tmp16 := lang.Apply(tmp15, []any{v13})
								if lang.IsTruthy(tmp16) {
									tmp17 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
									tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp20 := checkDerefVar(var_glojure_DOT_core_list)
									tmp21 := checkDerefVar(var_glojure_DOT_core_first)
									tmp22 := lang.Apply(tmp21, []any{v13})
									tmp23 := lang.Apply(tmp20, []any{tmp22})
									tmp24 := checkDerefVar(var_glojure_DOT_core_next)
									tmp25 := lang.Apply(tmp24, []any{v13})
									tmp26 := checkDerefVar(var_glojure_DOT_core_list)
									tmp27 := lang.Apply(tmp26, []any{v7})
									tmp28 := lang.Apply(tmp19, []any{tmp23, tmp25, tmp27})
									tmp29 := lang.Apply(tmp18, []any{tmp28})
									tmp30 := checkDerefVar(var_glojure_DOT_core_meta)
									tmp31 := lang.Apply(tmp30, []any{v13})
									tmp32 := lang.Apply(tmp17, []any{tmp29, tmp31})
									tmp14 = tmp32
								} else {
									tmp33 := checkDerefVar(var_glojure_DOT_core_list)
									tmp34 := lang.Apply(tmp33, []any{v13, v7})
									tmp14 = tmp34
								}
								var v35 any = tmp14
								_ = v35
								var tmp36 any = v35
								tmp38 := checkDerefVar(var_glojure_DOT_core_next)
								tmp39 := lang.Apply(tmp38, []any{v8})
								var tmp37 any = tmp39
								v7 = tmp36
								v8 = tmp37
								continue
							} // end let
							tmp9 = tmp10
						} else {
							tmp9 = v7
						}
						tmp6 = tmp9
						break
					}
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__DASH__GT__GT_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__DASH__GT__GT_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ..
	{
		tmp0 := sym__DOT__DOT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_form), lang.NewVector(sym_x, sym_form, sym__AMP_, sym_more)), kw_doc, "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \"os.name\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \"os.name\"))\n\n  but is easier to write, read, and understand.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(1657), kw_end_DASH_line, int(1657))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym__DOT_})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v5})
				tmp14 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp6, []any{tmp14})
				return tmp15
			default:
				checkArityGTE(args, 4)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var v6 any = lang.NewList(args[4:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym__DOT__DOT_})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym__DOT_})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v4})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v5})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp8, []any{tmp10, tmp22, v6})
				tmp24 := lang.Apply(tmp7, []any{tmp23})
				return tmp24
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__DOT__DOT_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__DOT__DOT_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// =
	{
		var tmp1 lang.FnFunc
		{ // function =__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_lang_DOT_Util})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{sym_glojure_DOT_core_SLASH_equiv})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp5, []any{tmp17})
				return tmp18
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__EQ_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Equality. Returns true if x equals y, false if not. Same as\n  Java x.equals(y) except it also works for nil, and compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define equals() (and thus =) as a value, not an identity,\n  comparison.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(776), kw_end_DASH_line, int(776))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return true
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.Equiv, []any{v3, v4})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_126:
				var tmp6 any
				tmp7 := lang.Apply(lang.Equiv, []any{v3, v4})
				if lang.IsTruthy(tmp7) {
					var tmp8 any
					tmp9 := checkDerefVar(var_glojure_DOT_core_next)
					tmp10 := lang.Apply(tmp9, []any{v5})
					if lang.IsTruthy(tmp10) {
						var tmp11 any = v4
						tmp13 := checkDerefVar(var_glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v5})
						var tmp12 any = tmp14
						tmp16 := checkDerefVar(var_glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v5})
						var tmp15 any = tmp17
						v3 = tmp11
						v4 = tmp12
						v5 = tmp15
						goto recur_loop_126
					} else {
						tmp18 := checkDerefVar(var_glojure_DOT_core_first)
						tmp19 := lang.Apply(tmp18, []any{v5})
						tmp20 := lang.Apply(lang.Equiv, []any{v4, tmp19})
						tmp8 = tmp20
					}
					tmp6 = tmp8
				} else {
					tmp6 = false
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__EQ_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__EQ_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ==
	{
		var tmp1 lang.FnFunc
		{ // function ==__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_equiv})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__EQ__EQ_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns non-nil if nums all have the equivalent\n  value (type-independent), otherwise false", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(1093), kw_end_DASH_line, int(1093))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return true
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "equiv")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("equiv is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArityGTE(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_206:
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core__EQ__EQ_)
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_next)
					tmp11 := lang.Apply(tmp10, []any{v5})
					if lang.IsTruthy(tmp11) {
						var tmp12 any = v4
						tmp14 := checkDerefVar(var_glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v5})
						var tmp13 any = tmp15
						tmp17 := checkDerefVar(var_glojure_DOT_core_next)
						tmp18 := lang.Apply(tmp17, []any{v5})
						var tmp16 any = tmp18
						v3 = tmp12
						v4 = tmp13
						v5 = tmp16
						goto recur_loop_206
					} else {
						tmp19 := checkDerefVar(var_glojure_DOT_core__EQ__EQ_)
						tmp20 := checkDerefVar(var_glojure_DOT_core_first)
						tmp21 := lang.Apply(tmp20, []any{v5})
						tmp22 := lang.Apply(tmp19, []any{v4, tmp21})
						tmp9 = tmp22
					}
					tmp6 = tmp9
				} else {
					tmp6 = false
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__EQ__EQ_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__EQ__EQ_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >
	{
		var tmp1 lang.FnFunc
		{ // function >__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_gt})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__GT_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(1063), kw_end_DASH_line, int(1063))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return true
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "gt")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("gt is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArityGTE(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_198:
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core__GT_)
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_next)
					tmp11 := lang.Apply(tmp10, []any{v5})
					if lang.IsTruthy(tmp11) {
						var tmp12 any = v4
						tmp14 := checkDerefVar(var_glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v5})
						var tmp13 any = tmp15
						tmp17 := checkDerefVar(var_glojure_DOT_core_next)
						tmp18 := lang.Apply(tmp17, []any{v5})
						var tmp16 any = tmp18
						v3 = tmp12
						v4 = tmp13
						v5 = tmp16
						goto recur_loop_198
					} else {
						tmp19 := checkDerefVar(var_glojure_DOT_core__GT_)
						tmp20 := checkDerefVar(var_glojure_DOT_core_first)
						tmp21 := lang.Apply(tmp20, []any{v5})
						tmp22 := lang.Apply(tmp19, []any{v4, tmp21})
						tmp9 = tmp22
					}
					tmp6 = tmp9
				} else {
					tmp6 = false
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__GT_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__GT_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >=
	{
		var tmp1 lang.FnFunc
		{ // function >=__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_gte})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__GT__EQ_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(1078), kw_end_DASH_line, int(1078))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return true
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "gte")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("gte is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArityGTE(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_202:
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core__GT__EQ_)
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_next)
					tmp11 := lang.Apply(tmp10, []any{v5})
					if lang.IsTruthy(tmp11) {
						var tmp12 any = v4
						tmp14 := checkDerefVar(var_glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v5})
						var tmp13 any = tmp15
						tmp17 := checkDerefVar(var_glojure_DOT_core_next)
						tmp18 := lang.Apply(tmp17, []any{v5})
						var tmp16 any = tmp18
						v3 = tmp12
						v4 = tmp13
						v5 = tmp16
						goto recur_loop_202
					} else {
						tmp19 := checkDerefVar(var_glojure_DOT_core__GT__EQ_)
						tmp20 := checkDerefVar(var_glojure_DOT_core_first)
						tmp21 := lang.Apply(tmp20, []any{v5})
						tmp22 := lang.Apply(tmp19, []any{v4, tmp21})
						tmp9 = tmp22
					}
					tmp6 = tmp9
				} else {
					tmp6 = false
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__GT__EQ_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__GT__EQ_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// <
	{
		var tmp1 lang.FnFunc
		{ // function <__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_lt})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__LT_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(893), kw_end_DASH_line, int(893))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return true
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "lt")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("lt is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArityGTE(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_150:
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core__LT_)
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_next)
					tmp11 := lang.Apply(tmp10, []any{v5})
					if lang.IsTruthy(tmp11) {
						var tmp12 any = v4
						tmp14 := checkDerefVar(var_glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v5})
						var tmp13 any = tmp15
						tmp17 := checkDerefVar(var_glojure_DOT_core_next)
						tmp18 := lang.Apply(tmp17, []any{v5})
						var tmp16 any = tmp18
						v3 = tmp12
						v4 = tmp13
						v5 = tmp16
						goto recur_loop_150
					} else {
						tmp19 := checkDerefVar(var_glojure_DOT_core__LT_)
						tmp20 := checkDerefVar(var_glojure_DOT_core_first)
						tmp21 := lang.Apply(tmp20, []any{v5})
						tmp22 := lang.Apply(tmp19, []any{v4, tmp21})
						tmp9 = tmp22
					}
					tmp6 = tmp9
				} else {
					tmp6 = false
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__LT_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__LT_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// <=
	{
		var tmp1 lang.FnFunc
		{ // function <=__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_lte})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__LT__EQ_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(1048), kw_end_DASH_line, int(1048))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return true
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "lte")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("lte is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArityGTE(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_194:
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_next)
					tmp11 := lang.Apply(tmp10, []any{v5})
					if lang.IsTruthy(tmp11) {
						var tmp12 any = v4
						tmp14 := checkDerefVar(var_glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v5})
						var tmp13 any = tmp15
						tmp17 := checkDerefVar(var_glojure_DOT_core_next)
						tmp18 := lang.Apply(tmp17, []any{v5})
						var tmp16 any = tmp18
						v3 = tmp12
						v4 = tmp13
						v5 = tmp16
						goto recur_loop_194
					} else {
						tmp19 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
						tmp20 := checkDerefVar(var_glojure_DOT_core_first)
						tmp21 := lang.Apply(tmp20, []any{v5})
						tmp22 := lang.Apply(tmp19, []any{v4, tmp21})
						tmp9 = tmp22
					}
					tmp6 = tmp9
				} else {
					tmp6 = false
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__LT__EQ_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__LT__EQ_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed3
					} else {
						tmp4 = closed4
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed3
					} else {
						tmp5 = closed4
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed3
					} else {
						tmp6 = closed4
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__PLUS_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(977), kw_end_DASH_line, int(977))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(0)
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(lang.MustAsNumber, []any{v4})
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "add")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core__PLUS_)
				tmp9 := checkDerefVar(var_glojure_DOT_core__PLUS_)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__PLUS_ = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__PLUS_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed5
					} else {
						tmp4 = closed5
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed5
					} else {
						tmp5 = closed5
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed5
					} else {
						tmp6 = closed5
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__PLUS__TICK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the sum of nums. (+') returns 0. Supports arbitrary precision.\n  See also: +", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(965), kw_end_DASH_line, int(965))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(0)
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(lang.MustAsNumber, []any{v4})
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "addP")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("addP is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core__PLUS__TICK_)
				tmp9 := checkDerefVar(var_glojure_DOT_core__PLUS__TICK_)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__PLUS__TICK_ = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__PLUS__TICK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// /
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed28
					} else {
						tmp4 = closed28
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed28
					} else {
						tmp5 = closed28
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed28
					} else {
						tmp6 = closed28
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__SLASH_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(1013), kw_end_DASH_line, int(1013))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core__SLASH_)
				tmp6 := lang.Apply(tmp5, []any{int64(1), v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "divide")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("divide is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core__SLASH_)
				tmp9 := checkDerefVar(var_glojure_DOT_core__SLASH_)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__SLASH_ = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__SLASH_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed0
					} else {
						tmp4 = closed1
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed0
					} else {
						tmp5 = closed1
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed0
					} else {
						tmp6 = closed1
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__STAR_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the product of nums. (*) returns 1. Does not auto-promote\n  longs, will throw on overflow. See also: *'", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(1001), kw_end_DASH_line, int(1001))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(1)
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(lang.MustAsNumber, []any{v4})
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "multiply")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("multiply is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core__STAR_)
				tmp9 := checkDerefVar(var_glojure_DOT_core__STAR_)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__STAR_ = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed2
					} else {
						tmp4 = closed2
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed2
					} else {
						tmp5 = closed2
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed2
					} else {
						tmp6 = closed2
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__STAR__TICK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the product of nums. (*') returns 1. Supports arbitrary precision.\n  See also: *", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(989), kw_end_DASH_line, int(989))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(1)
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(lang.MustAsNumber, []any{v4})
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "multiplyP")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("multiplyP is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core__STAR__TICK_)
				tmp9 := checkDerefVar(var_glojure_DOT_core__STAR__TICK_)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__STAR__TICK_ = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__STAR__TICK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// abs
	{
		var tmp1 lang.FnFunc
		{ // function abs__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Abs})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_abs.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_inline, tmp1, kw_doc, "Returns the absolute value of a.\n  If a is Long/MIN_VALUE => Long/MIN_VALUE\n  If a is a double and zero => +0.0\n  If a is a double and ##Inf or ##-Inf => ##Inf\n  If a is a double and ##NaN => ##NaN", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1128), kw_end_DASH_line, int(1128))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.Abs, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_abs = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_abs.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aclone
	{
		var tmp1 lang.FnFunc
		{ // function aclone__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Aclone})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_aclone.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array)), kw_inline, tmp1, kw_doc, "Returns a clone of the Java array. Works on arrays of known\n  types.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3904), kw_end_DASH_line, int(3904))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "Aclone")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Aclone is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_aclone = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_aclone.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-doc-and-meta
	{
		tmp0 := sym_add_DASH_doc_DASH_and_DASH_meta.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_docstring, sym_meta)), kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(26), kw_column, int(11), kw_line, int(6400), kw_end_DASH_line, int(6400), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 5)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			v6 := args[4]
			_ = v6
			tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp9 := checkDerefVar(var_glojure_DOT_core_list)
			tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_alter_DASH_meta_BANG_})
			tmp11 := checkDerefVar(var_glojure_DOT_core_list)
			tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp14 := checkDerefVar(var_glojure_DOT_core_list)
			tmp15 := lang.Apply(tmp14, []any{sym_var})
			tmp16 := checkDerefVar(var_glojure_DOT_core_list)
			tmp17 := lang.Apply(tmp16, []any{v4})
			tmp18 := lang.Apply(tmp13, []any{tmp15, tmp17})
			tmp19 := lang.Apply(tmp12, []any{tmp18})
			tmp20 := lang.Apply(tmp11, []any{tmp19})
			tmp21 := checkDerefVar(var_glojure_DOT_core_list)
			tmp22 := lang.Apply(tmp21, []any{sym_glojure_DOT_core_SLASH_merge})
			tmp23 := checkDerefVar(var_glojure_DOT_core_list)
			tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp26 := checkDerefVar(var_glojure_DOT_core_list)
			tmp27 := lang.Apply(tmp26, []any{sym_glojure_DOT_core_SLASH_assoc})
			tmp28 := checkDerefVar(var_glojure_DOT_core_list)
			tmp29 := lang.Apply(tmp28, []any{v6})
			tmp30 := checkDerefVar(var_glojure_DOT_core_list)
			tmp31 := lang.Apply(tmp30, []any{kw_doc})
			tmp32 := checkDerefVar(var_glojure_DOT_core_list)
			tmp33 := lang.Apply(tmp32, []any{v5})
			tmp34 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp31, tmp33})
			tmp35 := lang.Apply(tmp24, []any{tmp34})
			tmp36 := lang.Apply(tmp23, []any{tmp35})
			tmp37 := lang.Apply(tmp8, []any{tmp10, tmp20, tmp22, tmp36})
			tmp38 := lang.Apply(tmp7, []any{tmp37})
			return tmp38
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_add_DASH_doc_DASH_and_DASH_meta = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_add_DASH_doc_DASH_and_DASH_meta.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alength
	{
		var tmp1 lang.FnFunc
		{ // function alength__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Alength})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_alength.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array)), kw_inline, tmp1, kw_doc, "Returns the length of the Java array. Works on arrays of all\n  types.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3897), kw_end_DASH_line, int(3897))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "Alength")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Alength is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_alength = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_alength.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// apply
	{
		tmp0 := sym_apply.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_args), lang.NewVector(sym_f, sym_x, sym_args), lang.NewVector(sym_f, sym_x, sym_y, sym_args), lang.NewVector(sym_f, sym_x, sym_y, sym_z, sym_args), lang.NewVector(sym_f, sym_a, sym_b, sym_c, sym_d, sym__AMP_, sym_args)), kw_doc, "Applies fn f to the argument list formed by prepending intervening arguments to args.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(653), kw_end_DASH_line, int(653))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := lang.Apply(tmp4, []any{v3})
				tmp6 := lang.Apply(lang.Apply, []any{v2, tmp5})
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				tmp7 := lang.Apply(lang.Apply, []any{v2, tmp6})
				return tmp7
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp7 := lang.Apply(tmp6, []any{v3, v4, v5})
				tmp8 := lang.Apply(lang.Apply, []any{v2, tmp7})
				return tmp8
			case 5:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp8 := lang.Apply(tmp7, []any{v3, v4, v5, v6})
				tmp9 := lang.Apply(lang.Apply, []any{v2, tmp8})
				return tmp9
			default:
				checkArityGTE(args, 5)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				var v7 any = lang.NewList(args[5:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp9 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp10 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp11 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp12 := checkDerefVar(var_glojure_DOT_core_spread)
				tmp13 := lang.Apply(tmp12, []any{v7})
				tmp14 := lang.Apply(tmp11, []any{v6, tmp13})
				tmp15 := lang.Apply(tmp10, []any{v5, tmp14})
				tmp16 := lang.Apply(tmp9, []any{v4, tmp15})
				tmp17 := lang.Apply(tmp8, []any{v3, tmp16})
				tmp18 := lang.Apply(lang.Apply, []any{v2, tmp17})
				return tmp18
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_apply = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_apply.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// areduce
	{
		tmp0 := sym_areduce.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_idx, sym_ret, sym_init, sym_expr)), kw_doc, "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the \n  evaluation of expr at each step, returning ret.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(5289), kw_end_DASH_line, int(5289))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 7)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			v6 := args[4]
			_ = v6
			v7 := args[5]
			_ = v7
			v8 := args[6]
			_ = v8
			tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp10 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp11 := checkDerefVar(var_glojure_DOT_core_list)
			tmp12 := lang.Apply(tmp11, []any{sym_glojure_DOT_core_SLASH_let})
			tmp13 := checkDerefVar(var_glojure_DOT_core_list)
			tmp14 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp15 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp17 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp18 := checkDerefVar(var_glojure_DOT_core_list)
			tmp19 := lang.Apply(tmp18, []any{sym_a__0__auto__})
			tmp20 := checkDerefVar(var_glojure_DOT_core_list)
			tmp21 := lang.Apply(tmp20, []any{v4})
			tmp22 := checkDerefVar(var_glojure_DOT_core_list)
			tmp23 := lang.Apply(tmp22, []any{sym_l__1__auto__})
			tmp24 := checkDerefVar(var_glojure_DOT_core_list)
			tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp27 := checkDerefVar(var_glojure_DOT_core_list)
			tmp28 := lang.Apply(tmp27, []any{sym_glojure_DOT_core_SLASH_alength})
			tmp29 := checkDerefVar(var_glojure_DOT_core_list)
			tmp30 := lang.Apply(tmp29, []any{sym_a__0__auto__})
			tmp31 := lang.Apply(tmp26, []any{tmp28, tmp30})
			tmp32 := lang.Apply(tmp25, []any{tmp31})
			tmp33 := lang.Apply(tmp24, []any{tmp32})
			tmp34 := lang.Apply(tmp17, []any{tmp19, tmp21, tmp23, tmp33})
			tmp35 := lang.Apply(tmp16, []any{tmp34})
			tmp36 := lang.Apply(tmp14, []any{tmp15, tmp35})
			tmp37 := lang.Apply(tmp13, []any{tmp36})
			tmp38 := checkDerefVar(var_glojure_DOT_core_list)
			tmp39 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp40 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp41 := checkDerefVar(var_glojure_DOT_core_list)
			tmp42 := lang.Apply(tmp41, []any{sym_glojure_DOT_core_SLASH_loop})
			tmp43 := checkDerefVar(var_glojure_DOT_core_list)
			tmp44 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp45 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp46 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp47 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp48 := checkDerefVar(var_glojure_DOT_core_list)
			tmp49 := lang.Apply(tmp48, []any{v5})
			tmp50 := checkDerefVar(var_glojure_DOT_core_list)
			tmp51 := lang.Apply(tmp50, []any{int64(0)})
			tmp52 := checkDerefVar(var_glojure_DOT_core_list)
			tmp53 := lang.Apply(tmp52, []any{v6})
			tmp54 := checkDerefVar(var_glojure_DOT_core_list)
			tmp55 := lang.Apply(tmp54, []any{v7})
			tmp56 := lang.Apply(tmp47, []any{tmp49, tmp51, tmp53, tmp55})
			tmp57 := lang.Apply(tmp46, []any{tmp56})
			tmp58 := lang.Apply(tmp44, []any{tmp45, tmp57})
			tmp59 := lang.Apply(tmp43, []any{tmp58})
			tmp60 := checkDerefVar(var_glojure_DOT_core_list)
			tmp61 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp62 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp63 := checkDerefVar(var_glojure_DOT_core_list)
			tmp64 := lang.Apply(tmp63, []any{sym_if})
			tmp65 := checkDerefVar(var_glojure_DOT_core_list)
			tmp66 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp67 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp68 := checkDerefVar(var_glojure_DOT_core_list)
			tmp69 := lang.Apply(tmp68, []any{sym_glojure_DOT_core_SLASH__LT_})
			tmp70 := checkDerefVar(var_glojure_DOT_core_list)
			tmp71 := lang.Apply(tmp70, []any{v5})
			tmp72 := checkDerefVar(var_glojure_DOT_core_list)
			tmp73 := lang.Apply(tmp72, []any{sym_l__1__auto__})
			tmp74 := lang.Apply(tmp67, []any{tmp69, tmp71, tmp73})
			tmp75 := lang.Apply(tmp66, []any{tmp74})
			tmp76 := lang.Apply(tmp65, []any{tmp75})
			tmp77 := checkDerefVar(var_glojure_DOT_core_list)
			tmp78 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp79 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp80 := checkDerefVar(var_glojure_DOT_core_list)
			tmp81 := lang.Apply(tmp80, []any{sym_recur})
			tmp82 := checkDerefVar(var_glojure_DOT_core_list)
			tmp83 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp84 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp85 := checkDerefVar(var_glojure_DOT_core_list)
			tmp86 := lang.Apply(tmp85, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc_DASH_int})
			tmp87 := checkDerefVar(var_glojure_DOT_core_list)
			tmp88 := lang.Apply(tmp87, []any{v5})
			tmp89 := lang.Apply(tmp84, []any{tmp86, tmp88})
			tmp90 := lang.Apply(tmp83, []any{tmp89})
			tmp91 := lang.Apply(tmp82, []any{tmp90})
			tmp92 := checkDerefVar(var_glojure_DOT_core_list)
			tmp93 := lang.Apply(tmp92, []any{v8})
			tmp94 := lang.Apply(tmp79, []any{tmp81, tmp91, tmp93})
			tmp95 := lang.Apply(tmp78, []any{tmp94})
			tmp96 := lang.Apply(tmp77, []any{tmp95})
			tmp97 := checkDerefVar(var_glojure_DOT_core_list)
			tmp98 := lang.Apply(tmp97, []any{v6})
			tmp99 := lang.Apply(tmp62, []any{tmp64, tmp76, tmp96, tmp98})
			tmp100 := lang.Apply(tmp61, []any{tmp99})
			tmp101 := lang.Apply(tmp60, []any{tmp100})
			tmp102 := lang.Apply(tmp40, []any{tmp42, tmp59, tmp101})
			tmp103 := lang.Apply(tmp39, []any{tmp102})
			tmp104 := lang.Apply(tmp38, []any{tmp103})
			tmp105 := lang.Apply(tmp10, []any{tmp12, tmp37, tmp104})
			tmp106 := lang.Apply(tmp9, []any{tmp105})
			return tmp106
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_areduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_areduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// array
	{
		tmp0 := sym_array.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(3457), kw_column, int(7), kw_end_DASH_line, int(3458), kw_end_DASH_column, int(7), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_items)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_into_DASH_array)
				tmp4 := lang.Apply(tmp3, []any{v2})
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert
	{
		tmp0 := sym_assert.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_message)), kw_doc, "Evaluates expression x and throws an AssertionError with optional\n  message if x does not evaluate to logical true.\n\n  Assertion checks are omitted from compiled code if '*assert*' is\n  false.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(4837), kw_end_DASH_line, int(4837))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_assert_STAR_)
				if lang.IsTruthy(tmp6) {
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_when_DASH_not})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{v4})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{sym_throw})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{sym_new})
					tmp23 := checkDerefVar(var_glojure_DOT_core_list)
					tmp24 := lang.Apply(tmp23, []any{sym_glojure_DOT_core_SLASH_AssertionError})
					tmp25 := checkDerefVar(var_glojure_DOT_core_list)
					tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp27 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp28 := checkDerefVar(var_glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{sym_glojure_DOT_core_SLASH_str})
					tmp30 := checkDerefVar(var_glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{"Assert failed: "})
					tmp32 := checkDerefVar(var_glojure_DOT_core_list)
					tmp33 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp34 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp35 := checkDerefVar(var_glojure_DOT_core_list)
					tmp36 := lang.Apply(tmp35, []any{sym_glojure_DOT_core_SLASH_pr_DASH_str})
					tmp37 := checkDerefVar(var_glojure_DOT_core_list)
					tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp39 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{sym_quote})
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					tmp43 := lang.Apply(tmp42, []any{v4})
					tmp44 := lang.Apply(tmp39, []any{tmp41, tmp43})
					tmp45 := lang.Apply(tmp38, []any{tmp44})
					tmp46 := lang.Apply(tmp37, []any{tmp45})
					tmp47 := lang.Apply(tmp34, []any{tmp36, tmp46})
					tmp48 := lang.Apply(tmp33, []any{tmp47})
					tmp49 := lang.Apply(tmp32, []any{tmp48})
					tmp50 := lang.Apply(tmp27, []any{tmp29, tmp31, tmp49})
					tmp51 := lang.Apply(tmp26, []any{tmp50})
					tmp52 := lang.Apply(tmp25, []any{tmp51})
					tmp53 := lang.Apply(tmp20, []any{tmp22, tmp24, tmp52})
					tmp54 := lang.Apply(tmp19, []any{tmp53})
					tmp55 := lang.Apply(tmp18, []any{tmp54})
					tmp56 := lang.Apply(tmp15, []any{tmp17, tmp55})
					tmp57 := lang.Apply(tmp14, []any{tmp56})
					tmp58 := lang.Apply(tmp13, []any{tmp57})
					tmp59 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp58})
					tmp60 := lang.Apply(tmp7, []any{tmp59})
					tmp5 = tmp60
				} else {
				}
				return tmp5
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_assert_STAR_)
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_when_DASH_not})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{v4})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_throw})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{sym_new})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{sym_glojure_DOT_core_SLASH_AssertionError})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp28 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp29 := checkDerefVar(var_glojure_DOT_core_list)
					tmp30 := lang.Apply(tmp29, []any{sym_glojure_DOT_core_SLASH_str})
					tmp31 := checkDerefVar(var_glojure_DOT_core_list)
					tmp32 := lang.Apply(tmp31, []any{"Assert failed: "})
					tmp33 := checkDerefVar(var_glojure_DOT_core_list)
					tmp34 := lang.Apply(tmp33, []any{v5})
					tmp35 := checkDerefVar(var_glojure_DOT_core_list)
					tmp36 := lang.Apply(tmp35, []any{"\n"})
					tmp37 := checkDerefVar(var_glojure_DOT_core_list)
					tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp39 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{sym_glojure_DOT_core_SLASH_pr_DASH_str})
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					tmp43 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp44 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp45 := checkDerefVar(var_glojure_DOT_core_list)
					tmp46 := lang.Apply(tmp45, []any{sym_quote})
					tmp47 := checkDerefVar(var_glojure_DOT_core_list)
					tmp48 := lang.Apply(tmp47, []any{v4})
					tmp49 := lang.Apply(tmp44, []any{tmp46, tmp48})
					tmp50 := lang.Apply(tmp43, []any{tmp49})
					tmp51 := lang.Apply(tmp42, []any{tmp50})
					tmp52 := lang.Apply(tmp39, []any{tmp41, tmp51})
					tmp53 := lang.Apply(tmp38, []any{tmp52})
					tmp54 := lang.Apply(tmp37, []any{tmp53})
					tmp55 := lang.Apply(tmp28, []any{tmp30, tmp32, tmp34, tmp36, tmp54})
					tmp56 := lang.Apply(tmp27, []any{tmp55})
					tmp57 := lang.Apply(tmp26, []any{tmp56})
					tmp58 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp57})
					tmp59 := lang.Apply(tmp20, []any{tmp58})
					tmp60 := lang.Apply(tmp19, []any{tmp59})
					tmp61 := lang.Apply(tmp16, []any{tmp18, tmp60})
					tmp62 := lang.Apply(tmp15, []any{tmp61})
					tmp63 := lang.Apply(tmp14, []any{tmp62})
					tmp64 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp63})
					tmp65 := lang.Apply(tmp8, []any{tmp64})
					tmp6 = tmp65
				} else {
				}
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_assert = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_assert.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert-args
	{
		tmp0 := sym_assert_DASH_args.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_pairs)), kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(38), kw_column, int(11), kw_line, int(1830), kw_end_DASH_line, int(1830), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_do})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp11 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{sym_glojure_DOT_core_SLASH_when_DASH_not})
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := checkDerefVar(var_glojure_DOT_core_first)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp14, []any{tmp16})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp21 := checkDerefVar(var_glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{sym_throw})
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp26 := checkDerefVar(var_glojure_DOT_core_list)
				tmp27 := lang.Apply(tmp26, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewIllegalArgumentError})
				tmp28 := checkDerefVar(var_glojure_DOT_core_list)
				tmp29 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp30 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp31 := checkDerefVar(var_glojure_DOT_core_list)
				tmp32 := lang.Apply(tmp31, []any{sym_glojure_DOT_core_SLASH_str})
				tmp33 := checkDerefVar(var_glojure_DOT_core_list)
				tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp35 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp36 := checkDerefVar(var_glojure_DOT_core_list)
				tmp37 := lang.Apply(tmp36, []any{sym_glojure_DOT_core_SLASH_first})
				tmp38 := checkDerefVar(var_glojure_DOT_core_list)
				tmp39 := lang.Apply(tmp38, []any{sym__AMP_form})
				tmp40 := lang.Apply(tmp35, []any{tmp37, tmp39})
				tmp41 := lang.Apply(tmp34, []any{tmp40})
				tmp42 := lang.Apply(tmp33, []any{tmp41})
				tmp43 := checkDerefVar(var_glojure_DOT_core_list)
				tmp44 := lang.Apply(tmp43, []any{" requires "})
				tmp45 := checkDerefVar(var_glojure_DOT_core_list)
				tmp46 := checkDerefVar(var_glojure_DOT_core_second)
				tmp47 := lang.Apply(tmp46, []any{v4})
				tmp48 := lang.Apply(tmp45, []any{tmp47})
				tmp49 := checkDerefVar(var_glojure_DOT_core_list)
				tmp50 := lang.Apply(tmp49, []any{" in "})
				tmp51 := checkDerefVar(var_glojure_DOT_core_list)
				tmp52 := lang.Apply(tmp51, []any{sym__STAR_ns_STAR_})
				tmp53 := checkDerefVar(var_glojure_DOT_core_list)
				tmp54 := lang.Apply(tmp53, []any{":"})
				tmp55 := checkDerefVar(var_glojure_DOT_core_list)
				tmp56 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp57 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp58 := checkDerefVar(var_glojure_DOT_core_list)
				tmp59 := lang.Apply(tmp58, []any{kw_line})
				tmp60 := checkDerefVar(var_glojure_DOT_core_list)
				tmp61 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp62 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp63 := checkDerefVar(var_glojure_DOT_core_list)
				tmp64 := lang.Apply(tmp63, []any{sym_glojure_DOT_core_SLASH_meta})
				tmp65 := checkDerefVar(var_glojure_DOT_core_list)
				tmp66 := lang.Apply(tmp65, []any{sym__AMP_form})
				tmp67 := lang.Apply(tmp62, []any{tmp64, tmp66})
				tmp68 := lang.Apply(tmp61, []any{tmp67})
				tmp69 := lang.Apply(tmp60, []any{tmp68})
				tmp70 := lang.Apply(tmp57, []any{tmp59, tmp69})
				tmp71 := lang.Apply(tmp56, []any{tmp70})
				tmp72 := lang.Apply(tmp55, []any{tmp71})
				tmp73 := lang.Apply(tmp30, []any{tmp32, tmp42, tmp44, tmp48, tmp50, tmp52, tmp54, tmp72})
				tmp74 := lang.Apply(tmp29, []any{tmp73})
				tmp75 := lang.Apply(tmp28, []any{tmp74})
				tmp76 := lang.Apply(tmp25, []any{tmp27, tmp75})
				tmp77 := lang.Apply(tmp24, []any{tmp76})
				tmp78 := lang.Apply(tmp23, []any{tmp77})
				tmp79 := lang.Apply(tmp20, []any{tmp22, tmp78})
				tmp80 := lang.Apply(tmp19, []any{tmp79})
				tmp81 := lang.Apply(tmp18, []any{tmp80})
				tmp82 := lang.Apply(tmp11, []any{tmp13, tmp17, tmp81})
				tmp83 := lang.Apply(tmp10, []any{tmp82})
				tmp84 := lang.Apply(tmp9, []any{tmp83})
				tmp85 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp86 any
				{ // let
					// let binding "more"
					tmp87 := checkDerefVar(var_glojure_DOT_core_nnext)
					tmp88 := lang.Apply(tmp87, []any{v4})
					var v89 any = tmp88
					_ = v89
					var tmp90 any
					if lang.IsTruthy(v89) {
						tmp91 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
						tmp92 := lang.Apply(tmp91, []any{sym_glojure_DOT_core_SLASH_assert_DASH_args, v89})
						tmp90 = tmp92
					} else {
					}
					tmp86 = tmp90
				} // end let
				tmp87 := lang.Apply(tmp85, []any{tmp86})
				tmp88 := lang.Apply(tmp6, []any{tmp8, tmp84, tmp87})
				tmp89 := lang.Apply(tmp5, []any{tmp88})
				return tmp89
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_assert_DASH_args = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_assert_DASH_args.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc-in
	{
		tmp0 := sym_assoc_DASH_in.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, lang.NewVector(sym_k, sym__AMP_, sym_ks), sym_v)), kw_doc, "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(6147), kw_end_DASH_line, int(6147))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "vec__138"
				var v6 any = v3
				_ = v6
				// let binding "seq__139"
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := lang.Apply(tmp7, []any{v6})
				var v9 any = tmp8
				_ = v9
				// let binding "first__140"
				tmp10 := checkDerefVar(var_glojure_DOT_core_first)
				tmp11 := lang.Apply(tmp10, []any{v9})
				var v12 any = tmp11
				_ = v12
				// let binding "seq__139"
				tmp13 := checkDerefVar(var_glojure_DOT_core_next)
				tmp14 := lang.Apply(tmp13, []any{v9})
				var v15 any = tmp14
				_ = v15
				// let binding "k"
				var v16 any = v12
				_ = v16
				// let binding "ks"
				var v17 any = v15
				_ = v17
				var tmp18 any
				if lang.IsTruthy(v17) {
					tmp19 := checkDerefVar(var_glojure_DOT_core_assoc)
					tmp20 := checkDerefVar(var_glojure_DOT_core_assoc_DASH_in)
					tmp21 := checkDerefVar(var_glojure_DOT_core_get)
					tmp22 := lang.Apply(tmp21, []any{v2, v16})
					tmp23 := lang.Apply(tmp20, []any{tmp22, v17, v4})
					tmp24 := lang.Apply(tmp19, []any{v2, v16, tmp23})
					tmp18 = tmp24
				} else {
					tmp25 := checkDerefVar(var_glojure_DOT_core_assoc)
					tmp26 := lang.Apply(tmp25, []any{v2, v16, v4})
					tmp18 = tmp26
				}
				tmp5 = tmp18
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_assoc_DASH_in = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_assoc_DASH_in.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bigdec
	{
		tmp1 := reflect.TypeOf((*lang.BigDecimal)(nil))
		tmp0 := sym_bigdec.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Coerce to BigDecimal", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3648), kw_end_DASH_line, int(3648))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_decimal_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp4 = v3
			} else {
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_float_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v3})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_glojure_DOT_core_double)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp12 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp11})
					tmp7 = tmp12
				} else {
					var tmp13 any
					tmp14 := checkDerefVar(var_glojure_DOT_core_ratio_QMARK_)
					tmp15 := lang.Apply(tmp14, []any{v3})
					if lang.IsTruthy(tmp15) {
						tmp16 := checkDerefVar(var_glojure_DOT_core__SLASH_)
						tmp17 := lang.Apply(lang.NewBigDecimalFromRatio, []any{v3})
						tmp18, ok := lang.FieldOrMethod(v3, "denominator")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "denominator")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						tmp20 := lang.Apply(tmp16, []any{tmp17, tmp19})
						tmp13 = tmp20
					} else {
						var tmp21 any
						tmp22 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp23 := reflect.TypeOf((*lang.BigInt)(nil))
						tmp24 := lang.Apply(tmp22, []any{tmp23, v3})
						if lang.IsTruthy(tmp24) {
							tmp25, ok := lang.FieldOrMethod(v3, "toBigDecimal")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "toBigDecimal")))
							}
							var tmp26 any
							switch reflect.TypeOf(tmp25).Kind() {
							case reflect.Func:
								tmp26 = lang.Apply(tmp25, nil)
							default:
								tmp26 = tmp25
							}
							tmp21 = tmp26
						} else {
							var tmp27 any
							tmp28 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
							tmp29 := reflect.TypeOf((*big9.Int)(nil))
							tmp30 := lang.Apply(tmp28, []any{tmp29, v3})
							if lang.IsTruthy(tmp30) {
								tmp31 := lang.Apply(lang.NewBigDecimal, []any{v3})
								tmp27 = tmp31
							} else {
								var tmp32 any
								tmp33 := checkDerefVar(var_glojure_DOT_core_number_QMARK_)
								tmp34 := lang.Apply(tmp33, []any{v3})
								if lang.IsTruthy(tmp34) {
									tmp35 := checkDerefVar(var_glojure_DOT_core_long)
									tmp36 := lang.Apply(tmp35, []any{v3})
									tmp37 := lang.Apply(lang.NewBigDecimalFromInt64, []any{tmp36})
									tmp32 = tmp37
								} else {
									var tmp38 any
									if lang.IsTruthy(kw_else) {
										tmp39 := lang.Apply(lang.NewBigDecimal, []any{v3})
										tmp38 = tmp39
									} else {
									}
									tmp32 = tmp38
								}
								tmp27 = tmp32
							}
							tmp21 = tmp27
						}
						tmp13 = tmp21
					}
					tmp7 = tmp13
				}
				tmp4 = tmp7
			}
			return tmp4
		})
		tmp3 := reflect.TypeOf((*lang.BigDecimal)(nil))
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_bigdec = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bigdec.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bigint
	{
		tmp1 := reflect.TypeOf((*lang.BigInt)(nil))
		tmp0 := sym_bigint.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Coerce to BigInt", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3620), kw_end_DASH_line, int(3620))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp6 := reflect.TypeOf((*lang.BigInt)(nil))
			tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
			if lang.IsTruthy(tmp7) {
				tmp4 = v3
			} else {
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp10 := reflect.TypeOf((*big9.Int)(nil))
				tmp11 := lang.Apply(tmp9, []any{tmp10, v3})
				if lang.IsTruthy(tmp11) {
					tmp12 := lang.Apply(lang.NewBigIntFromGoBigInt, []any{v3})
					tmp8 = tmp12
				} else {
					var tmp13 any
					tmp14 := checkDerefVar(var_glojure_DOT_core_decimal_QMARK_)
					tmp15 := lang.Apply(tmp14, []any{v3})
					if lang.IsTruthy(tmp15) {
						tmp16 := checkDerefVar(var_glojure_DOT_core_bigint)
						tmp17, ok := lang.FieldOrMethod(v3, "toBigInteger")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "toBigInteger")))
						}
						var tmp18 any
						switch reflect.TypeOf(tmp17).Kind() {
						case reflect.Func:
							tmp18 = lang.Apply(tmp17, nil)
						default:
							tmp18 = tmp17
						}
						tmp19 := lang.Apply(tmp16, []any{tmp18})
						tmp13 = tmp19
					} else {
						var tmp20 any
						tmp21 := checkDerefVar(var_glojure_DOT_core_float_QMARK_)
						tmp22 := lang.Apply(tmp21, []any{v3})
						if lang.IsTruthy(tmp22) {
							tmp23 := checkDerefVar(var_glojure_DOT_core_bigint)
							tmp24 := checkDerefVar(var_glojure_DOT_core_double)
							tmp25 := lang.Apply(tmp24, []any{v3})
							tmp26 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp25})
							tmp27 := lang.Apply(tmp23, []any{tmp26})
							tmp20 = tmp27
						} else {
							var tmp28 any
							tmp29 := checkDerefVar(var_glojure_DOT_core_ratio_QMARK_)
							tmp30 := lang.Apply(tmp29, []any{v3})
							if lang.IsTruthy(tmp30) {
								tmp31 := checkDerefVar(var_glojure_DOT_core_bigint)
								tmp32, ok := lang.FieldOrMethod(v3, "bigIntegerValue")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "bigIntegerValue")))
								}
								var tmp33 any
								switch reflect.TypeOf(tmp32).Kind() {
								case reflect.Func:
									tmp33 = lang.Apply(tmp32, nil)
								default:
									tmp33 = tmp32
								}
								tmp34 := lang.Apply(tmp31, []any{tmp33})
								tmp28 = tmp34
							} else {
								var tmp35 any
								tmp36 := checkDerefVar(var_glojure_DOT_core_number_QMARK_)
								tmp37 := lang.Apply(tmp36, []any{v3})
								if lang.IsTruthy(tmp37) {
									tmp38 := checkDerefVar(var_glojure_DOT_core_long)
									tmp39 := lang.Apply(tmp38, []any{v3})
									tmp40 := lang.Apply(lang.NewBigIntFromInt64, []any{tmp39})
									tmp35 = tmp40
								} else {
									var tmp41 any
									if lang.IsTruthy(kw_else) {
										tmp42 := checkDerefVar(var_glojure_DOT_core_bigint)
										tmp43 := lang.Apply(lang.NewBigInt, []any{v3})
										tmp44 := lang.Apply(tmp42, []any{tmp43})
										tmp41 = tmp44
									} else {
									}
									tmp35 = tmp41
								}
								tmp28 = tmp35
							}
							tmp20 = tmp28
						}
						tmp13 = tmp20
					}
					tmp8 = tmp13
				}
				tmp4 = tmp8
			}
			return tmp4
		})
		tmp3 := reflect.TypeOf((*lang.BigInt)(nil))
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_bigint = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bigint.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// biginteger
	{
		tmp1 := reflect.TypeOf((*big9.Int)(nil))
		tmp0 := sym_biginteger.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Coerce to BigInteger", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(3634), kw_end_DASH_line, int(3634))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp6 := reflect.TypeOf((*big9.Int)(nil))
			tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
			if lang.IsTruthy(tmp7) {
				tmp4 = v3
			} else {
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp10 := reflect.TypeOf((*lang.BigInt)(nil))
				tmp11 := lang.Apply(tmp9, []any{tmp10, v3})
				if lang.IsTruthy(tmp11) {
					tmp12, ok := lang.FieldOrMethod(v3, "toBigInteger")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "toBigInteger")))
					}
					var tmp13 any
					switch reflect.TypeOf(tmp12).Kind() {
					case reflect.Func:
						tmp13 = lang.Apply(tmp12, nil)
					default:
						tmp13 = tmp12
					}
					tmp8 = tmp13
				} else {
					var tmp14 any
					tmp15 := checkDerefVar(var_glojure_DOT_core_decimal_QMARK_)
					tmp16 := lang.Apply(tmp15, []any{v3})
					if lang.IsTruthy(tmp16) {
						tmp17, ok := lang.FieldOrMethod(v3, "toBigInteger")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "toBigInteger")))
						}
						var tmp18 any
						switch reflect.TypeOf(tmp17).Kind() {
						case reflect.Func:
							tmp18 = lang.Apply(tmp17, nil)
						default:
							tmp18 = tmp17
						}
						tmp14 = tmp18
					} else {
						var tmp19 any
						tmp20 := checkDerefVar(var_glojure_DOT_core_float_QMARK_)
						tmp21 := lang.Apply(tmp20, []any{v3})
						if lang.IsTruthy(tmp21) {
							tmp22 := checkDerefVar(var_glojure_DOT_core_double)
							tmp23 := lang.Apply(tmp22, []any{v3})
							tmp24 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp23})
							tmp25, ok := lang.FieldOrMethod(tmp24, "toBigInteger")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp24, "toBigInteger")))
							}
							var tmp26 any
							switch reflect.TypeOf(tmp25).Kind() {
							case reflect.Func:
								tmp26 = lang.Apply(tmp25, nil)
							default:
								tmp26 = tmp25
							}
							tmp19 = tmp26
						} else {
							var tmp27 any
							tmp28 := checkDerefVar(var_glojure_DOT_core_ratio_QMARK_)
							tmp29 := lang.Apply(tmp28, []any{v3})
							if lang.IsTruthy(tmp29) {
								tmp30, ok := lang.FieldOrMethod(v3, "bigIntegerValue")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "bigIntegerValue")))
								}
								var tmp31 any
								switch reflect.TypeOf(tmp30).Kind() {
								case reflect.Func:
									tmp31 = lang.Apply(tmp30, nil)
								default:
									tmp31 = tmp30
								}
								tmp27 = tmp31
							} else {
								var tmp32 any
								tmp33 := checkDerefVar(var_glojure_DOT_core_number_QMARK_)
								tmp34 := lang.Apply(tmp33, []any{v3})
								if lang.IsTruthy(tmp34) {
									tmp35 := checkDerefVar(var_glojure_DOT_core_long)
									tmp36 := lang.Apply(tmp35, []any{v3})
									tmp37 := lang.Apply(big9.NewInt, []any{tmp36})
									tmp32 = tmp37
								} else {
									var tmp38 any
									if lang.IsTruthy(kw_else) {
										tmp39 := lang.Apply(lang.NewBigInt, []any{v3})
										tmp38 = tmp39
									} else {
									}
									tmp32 = tmp38
								}
								tmp27 = tmp32
							}
							tmp19 = tmp27
						}
						tmp14 = tmp19
					}
					tmp8 = tmp14
				}
				tmp4 = tmp8
			}
			return tmp4
		})
		tmp3 := reflect.TypeOf((*big9.Int)(nil))
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_biginteger = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_biginteger.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// binding-conveyor-fn
	{
		tmp0 := sym_binding_DASH_conveyor_DASH_fn.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(2020), kw_end_DASH_line, int(2020), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "frame"
				tmp4 := lang.Apply(lang.CloneThreadBindingFrame, nil)
				var v5 any = tmp4
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp7 := lang.Apply(lang.ResetThreadBindingFrame, []any{v5})
						_ = tmp7
						tmp8 := lang.Apply(v2, nil)
						return tmp8
					case 1:
						v7 := args[0]
						_ = v7
						tmp8 := lang.Apply(lang.ResetThreadBindingFrame, []any{v5})
						_ = tmp8
						tmp9 := lang.Apply(v2, []any{v7})
						return tmp9
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						tmp9 := lang.Apply(lang.ResetThreadBindingFrame, []any{v5})
						_ = tmp9
						tmp10 := lang.Apply(v2, []any{v7, v8})
						return tmp10
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						tmp10 := lang.Apply(lang.ResetThreadBindingFrame, []any{v5})
						_ = tmp10
						tmp11 := lang.Apply(v2, []any{v7, v8, v9})
						return tmp11
					default:
						checkArityGTE(args, 3)
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := lang.Apply(lang.ResetThreadBindingFrame, []any{v5})
						_ = tmp11
						tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp13 := lang.Apply(tmp12, []any{v2, v7, v8, v9, v10})
						return tmp13
					}
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2025), kw_column, int(5), kw_end_DASH_line, int(2040), kw_end_DASH_column, int(31))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp3 = tmp8
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_binding_DASH_conveyor_DASH_fn = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_binding_DASH_conveyor_DASH_fn.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-and
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed29
					} else {
						tmp4 = closed29
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed29
					} else {
						tmp5 = closed29
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed29
					} else {
						tmp6 = closed29
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_bit_DASH_and.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Bitwise and", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1298), kw_end_DASH_line, int(1298))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "and")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("and is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and)
				tmp9 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bit_DASH_and = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bit_DASH_and.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-and-not
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed30
					} else {
						tmp4 = closed30
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed30
					} else {
						tmp5 = closed30
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed30
					} else {
						tmp6 = closed30
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_bit_DASH_and_DASH_not.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Bitwise and with complement", kw_static, true, kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(1325), kw_end_DASH_line, int(1325))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "andNot")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("andNot is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and_DASH_not)
				tmp9 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and_DASH_not)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bit_DASH_and_DASH_not = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bit_DASH_and_DASH_not.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-not
	{
		var tmp1 lang.FnFunc
		{ // function bit-not__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_not})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_bit_DASH_not.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Bitwise complement", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1291), kw_end_DASH_line, int(1291))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "not")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("not is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bit_DASH_not = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bit_DASH_not.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-or
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed31
					} else {
						tmp4 = closed31
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed31
					} else {
						tmp5 = closed31
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed31
					} else {
						tmp6 = closed31
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_bit_DASH_or.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Bitwise or", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(1307), kw_end_DASH_line, int(1307))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "or")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("or is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core_bit_DASH_or)
				tmp9 := checkDerefVar(var_glojure_DOT_core_bit_DASH_or)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bit_DASH_or = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bit_DASH_or.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-shift-left
	{
		var tmp1 lang.FnFunc
		{ // function bit-shift-left__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_shiftLeft})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_bit_DASH_shift_DASH_left.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_inline, tmp1, kw_doc, "Bitwise shift left", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(1361), kw_end_DASH_line, int(1361))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "shiftLeft")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("shiftLeft is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bit_DASH_shift_DASH_left = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bit_DASH_shift_DASH_left.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-shift-right
	{
		var tmp1 lang.FnFunc
		{ // function bit-shift-right__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_shiftRight})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_bit_DASH_shift_DASH_right.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_inline, tmp1, kw_doc, "Bitwise shift right", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(1367), kw_end_DASH_line, int(1367))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "shiftRight")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("shiftRight is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bit_DASH_shift_DASH_right = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bit_DASH_shift_DASH_right.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-xor
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed32
					} else {
						tmp4 = closed32
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed32
					} else {
						tmp5 = closed32
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed32
					} else {
						tmp6 = closed32
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_bit_DASH_xor.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Bitwise exclusive or", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1316), kw_end_DASH_line, int(1316))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "xor")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("xor is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core_bit_DASH_xor)
				tmp9 := checkDerefVar(var_glojure_DOT_core_bit_DASH_xor)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bit_DASH_xor = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bit_DASH_xor.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean
	{
		var tmp1 lang.FnFunc
		{ // function boolean__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_BooleanCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_boolean.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to boolean", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1601), kw_end_DASH_line, int(1601))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "BooleanCast")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("BooleanCast is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_boolean = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_boolean.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean-array
	{
		var tmp1 lang.FnFunc
		{ // function boolean-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_booleanArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_boolean_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of booleans", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(5309), kw_end_DASH_line, int(5309))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(lang.Numbers, "booleanArray")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("booleanArray is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "booleanArrayInit")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("booleanArrayInit is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_boolean_DASH_array = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_boolean_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// booleans
	{
		var tmp1 lang.FnFunc
		{ // function booleans
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_booleans})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_booleans.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to boolean[]", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(12), kw_line, int(5372), kw_end_DASH_line, int(5372))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "booleans")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("booleans is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_booleans = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_booleans.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound-fn
	{
		tmp0 := sym_bound_DASH_fn.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_fntail)), kw_doc, "Returns a function defined by the given fntail, which will install the\n  same bindings in effect as in the thread at the time bound-fn was called.\n  This may be used to define a helper function which runs on a different\n  thread, but needs the same bindings in place.", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(2004), kw_end_DASH_line, int(2004))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_glojure_DOT_core_SLASH_bound_DASH_fn_STAR_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp11 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp14 := lang.Apply(tmp11, []any{tmp13, v4})
				tmp15 := lang.Apply(tmp10, []any{tmp14})
				tmp16 := lang.Apply(tmp9, []any{tmp15})
				tmp17 := lang.Apply(tmp6, []any{tmp8, tmp16})
				tmp18 := lang.Apply(tmp5, []any{tmp17})
				return tmp18
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bound_DASH_fn = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bound_DASH_fn.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound?
	{
		tmp0 := sym_bound_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_vars)), kw_doc, "Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5491), kw_end_DASH_line, int(5491))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					tmp6, ok := lang.FieldOrMethod(v5, "isBound")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "isBound")))
					}
					var tmp7 any
					switch reflect.TypeOf(tmp6).Kind() {
					case reflect.Func:
						tmp7 = lang.Apply(tmp6, nil)
					default:
						tmp7 = tmp6
					}
					return tmp7
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5497), kw_column, int(11), kw_end_DASH_line, int(5497), kw_end_DASH_column, int(69))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp7 := lang.Apply(tmp3, []any{tmp6, v2})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bound_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bound_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bounded-count
	{
		tmp0 := sym_bounded_DASH_count.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll)), kw_doc, "If coll is counted? returns its count, else will count at most the first n\n  elements of coll using its seq", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(7410), kw_end_DASH_line, int(7410))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_counted_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core_count)
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp4 = tmp8
			} else {
				var tmp9 any
				{ // let
					// let binding "i"
					var v10 any = int64(0)
					_ = v10
					// let binding "s"
					tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp12 := lang.Apply(tmp11, []any{v3})
					var v13 any = tmp12
					_ = v13
					for {
						var tmp14 any
						var tmp15 any
						{ // let
							// let binding "and__0__auto__"
							var v16 any = v13
							_ = v16
							var tmp17 any
							if lang.IsTruthy(v16) {
								tmp18 := checkDerefVar(var_glojure_DOT_core__LT_)
								tmp19 := lang.Apply(tmp18, []any{v10, v2})
								tmp17 = tmp19
							} else {
								tmp17 = v16
							}
							tmp15 = tmp17
						} // end let
						if lang.IsTruthy(tmp15) {
							tmp17 := checkDerefVar(var_glojure_DOT_core_inc)
							tmp18 := lang.Apply(tmp17, []any{v10})
							var tmp16 any = tmp18
							tmp20 := checkDerefVar(var_glojure_DOT_core_next)
							tmp21 := lang.Apply(tmp20, []any{v13})
							var tmp19 any = tmp21
							v10 = tmp16
							v13 = tmp19
							continue
						} else {
							tmp14 = v10
						}
						tmp9 = tmp14
						break
					}
				} // end let
				tmp4 = tmp9
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bounded_DASH_count = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bounded_DASH_count.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// butlast
	{
		tmp0 := sym_butlast.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Return a seq of all but the last item in coll, in linear time", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(2), kw_line, int(272), kw_end_DASH_line, int(276))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function butlast
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "ret"
					tmp5 := lang.NewVector()
					tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(277), kw_column, int(23), kw_end_DASH_line, int(277), kw_end_DASH_column, int(24))
					tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v8 any = tmp7
					_ = v8
					// let binding "s"
					var v9 any = v3
					_ = v9
					for {
						var tmp10 any
						tmp11 := checkDerefVar(var_glojure_DOT_core_next)
						tmp12 := lang.Apply(tmp11, []any{v9})
						if lang.IsTruthy(tmp12) {
							tmp14 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp15 := checkDerefVar(var_glojure_DOT_core_first)
							tmp16 := lang.Apply(tmp15, []any{v9})
							tmp17 := lang.Apply(tmp14, []any{v8, tmp16})
							var tmp13 any = tmp17
							tmp19 := checkDerefVar(var_glojure_DOT_core_next)
							tmp20 := lang.Apply(tmp19, []any{v9})
							var tmp18 any = tmp20
							v8 = tmp13
							v9 = tmp18
							continue
						} else {
							tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp22 := lang.Apply(tmp21, []any{v8})
							tmp10 = tmp22
						}
						tmp4 = tmp10
						break
					}
				} // end let
				return tmp4
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(276), kw_column, int(10), kw_end_DASH_line, int(280), kw_end_DASH_column, int(27))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_butlast = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_butlast.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// byte
	{
		var tmp1 lang.FnFunc
		{ // function byte__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_uncheckedByteCast
				} else {
					tmp14 = sym_byteCast
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_byte.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to byte", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3505), kw_end_DASH_line, int(3505))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.ByteCast, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_byte = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_byte.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// byte-array
	{
		var tmp1 lang.FnFunc
		{ // function byte-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_byteArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_byte_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of bytes", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(5317), kw_end_DASH_line, int(5317))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(lang.Numbers, "byteArray")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("byteArray is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "byteArrayInit")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("byteArrayInit is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_byte_DASH_array = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_byte_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bytes
	{
		var tmp1 lang.FnFunc
		{ // function bytes
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_bytes})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_bytes.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to bytes[]", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(12), kw_line, int(5377), kw_end_DASH_line, int(5377))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "bytes")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("bytes is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bytes = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bytes.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bytes?
	{
		tmp0 := sym_bytes_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a byte array", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5412), kw_end_DASH_line, int(5412))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp3 = false
			} else {
				tmp6 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp7 := checkDerefVar(var_glojure_DOT_core_class)
				tmp8 := lang.Apply(tmp7, []any{v2})
				tmp9, ok := lang.FieldOrMethod(tmp8, "getComponentType")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp8, "getComponentType")))
				}
				var tmp10 any
				switch reflect.TypeOf(tmp9).Kind() {
				case reflect.Func:
					tmp10 = lang.Apply(tmp9, nil)
				default:
					tmp10 = tmp9
				}
				tmp11 := lang.Apply(tmp6, []any{tmp10, nil})
				tmp3 = tmp11
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bytes_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bytes_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char
	{
		var tmp1 lang.FnFunc
		{ // function char__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_uncheckedCharCast
				} else {
					tmp14 = sym_charCast
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_char.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to char", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3511), kw_end_DASH_line, int(3511))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "CharCast")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("CharCast is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_char = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_char.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-array
	{
		var tmp1 lang.FnFunc
		{ // function char-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_charArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_char_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of chars", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(5325), kw_end_DASH_line, int(5325))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(lang.Numbers, "charArray")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("charArray is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "charArrayInit")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("charArrayInit is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_char_DASH_array = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_char_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chars
	{
		var tmp1 lang.FnFunc
		{ // function chars
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_chars})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_chars.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to chars[]", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(12), kw_line, int(5382), kw_end_DASH_line, int(5382))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "chars")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("chars is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_chars = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_chars.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comp
	{
		tmp0 := sym_comp.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_f), lang.NewVector(sym_f, sym_g), lang.NewVector(sym_f, sym_g, sym__AMP_, sym_fs)), kw_doc, "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2549), kw_end_DASH_line, int(2549))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_glojure_DOT_core_identity)
				return tmp2
			case 1:
				v2 := args[0]
				_ = v2
				return v2
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp5 := lang.Apply(v3, nil)
						tmp6 := lang.Apply(v2, []any{tmp5})
						return tmp6
					case 1:
						v5 := args[0]
						_ = v5
						tmp6 := lang.Apply(v3, []any{v5})
						tmp7 := lang.Apply(v2, []any{tmp6})
						return tmp7
					case 2:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						tmp7 := lang.Apply(v3, []any{v5, v6})
						tmp8 := lang.Apply(v2, []any{tmp7})
						return tmp8
					case 3:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v5, v6, v7})
						tmp9 := lang.Apply(v2, []any{tmp8})
						return tmp9
					default:
						checkArityGTE(args, 3)
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						var v8 any = lang.NewList(args[3:]...)
						_ = v8
						tmp9 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp10 := lang.Apply(tmp9, []any{v3, v5, v6, v7, v8})
						tmp11 := lang.Apply(v2, []any{tmp10})
						return tmp11
					}
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2559), kw_column, int(6), kw_end_DASH_line, int(2564), kw_end_DASH_column, int(49))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp6 := checkDerefVar(var_glojure_DOT_core_comp)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp8 := lang.Apply(tmp7, []any{v2, v3, v4})
				tmp9 := lang.Apply(tmp5, []any{tmp6, tmp8})
				return tmp9
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_comp = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_comp.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compare
	{
		var tmp1 lang.FnFunc
		{ // function compare__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_lang_DOT_Util})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{sym_glojure_DOT_core_SLASH_compare})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp5, []any{tmp17})
				return tmp18
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_compare.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Same as Java x.compareTo(y) except it also works for nil, and\n  compares numbers and collections in a type-independent manner. x\n  must implement Comparable", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(824), kw_end_DASH_line, int(824))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(lang.Compare, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_compare = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_compare.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// complement
	{
		tmp0 := sym_complement.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(1428), kw_end_DASH_line, int(1428))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 0:
					tmp4 := checkDerefVar(var_glojure_DOT_core_not)
					tmp5 := lang.Apply(v2, nil)
					tmp6 := lang.Apply(tmp4, []any{tmp5})
					return tmp6
				case 1:
					v4 := args[0]
					_ = v4
					tmp5 := checkDerefVar(var_glojure_DOT_core_not)
					tmp6 := lang.Apply(v2, []any{v4})
					tmp7 := lang.Apply(tmp5, []any{tmp6})
					return tmp7
				case 2:
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					tmp6 := checkDerefVar(var_glojure_DOT_core_not)
					tmp7 := lang.Apply(v2, []any{v4, v5})
					tmp8 := lang.Apply(tmp6, []any{tmp7})
					return tmp8
				default:
					checkArityGTE(args, 2)
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					var v6 any = lang.NewList(args[2:]...)
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_not)
					tmp8 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp9 := lang.Apply(tmp8, []any{v2, v4, v5, v6})
					tmp10 := lang.Apply(tmp7, []any{tmp9})
					return tmp10
				}
			})
			tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1434), kw_column, int(3), kw_end_DASH_line, int(1438), kw_end_DASH_column, int(40))
			tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_complement = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_complement.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// data-reader-var
	{
		tmp0 := sym_data_DASH_reader_DASH_var.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7832), kw_column, int(8), kw_end_DASH_line, int(7832), kw_end_DASH_column, int(22), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_intern)
			tmp4 := checkDerefVar(var_glojure_DOT_core_create_DASH_ns)
			tmp5 := checkDerefVar(var_glojure_DOT_core_symbol)
			tmp6 := checkDerefVar(var_glojure_DOT_core_namespace)
			tmp7 := lang.Apply(tmp6, []any{v2})
			tmp8 := lang.Apply(tmp5, []any{tmp7})
			tmp9 := lang.Apply(tmp4, []any{tmp8})
			tmp10 := checkDerefVar(var_glojure_DOT_core_symbol)
			tmp11 := checkDerefVar(var_glojure_DOT_core_name)
			tmp12 := lang.Apply(tmp11, []any{v2})
			tmp13 := lang.Apply(tmp10, []any{tmp12})
			tmp14 := lang.Apply(tmp3, []any{tmp9, tmp13})
			return tmp14
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_data_DASH_reader_DASH_var = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_data_DASH_reader_DASH_var.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// def-aset
	{
		tmp0 := sym_def_DASH_aset.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_method, sym_coerce)), kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(3), kw_line, int(3935), kw_end_DASH_line, int(3936), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 5)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			v6 := args[4]
			_ = v6
			tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp9 := checkDerefVar(var_glojure_DOT_core_list)
			tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_defn})
			tmp11 := checkDerefVar(var_glojure_DOT_core_list)
			tmp12 := lang.Apply(tmp11, []any{v4})
			tmp13 := checkDerefVar(var_glojure_DOT_core_list)
			tmp14 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp15 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
			tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp17 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp18 := checkDerefVar(var_glojure_DOT_core_list)
			tmp19 := lang.Apply(tmp18, []any{kw_arglists})
			tmp20 := checkDerefVar(var_glojure_DOT_core_list)
			tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp22 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp23 := checkDerefVar(var_glojure_DOT_core_list)
			tmp24 := lang.Apply(tmp23, []any{sym_quote})
			tmp25 := checkDerefVar(var_glojure_DOT_core_list)
			tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp27 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp28 := checkDerefVar(var_glojure_DOT_core_list)
			tmp29 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp30 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp31 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp32 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp33 := checkDerefVar(var_glojure_DOT_core_list)
			tmp34 := lang.Apply(tmp33, []any{sym_array})
			tmp35 := checkDerefVar(var_glojure_DOT_core_list)
			tmp36 := lang.Apply(tmp35, []any{sym_idx})
			tmp37 := checkDerefVar(var_glojure_DOT_core_list)
			tmp38 := lang.Apply(tmp37, []any{sym_val})
			tmp39 := lang.Apply(tmp32, []any{tmp34, tmp36, tmp38})
			tmp40 := lang.Apply(tmp31, []any{tmp39})
			tmp41 := lang.Apply(tmp29, []any{tmp30, tmp40})
			tmp42 := lang.Apply(tmp28, []any{tmp41})
			tmp43 := checkDerefVar(var_glojure_DOT_core_list)
			tmp44 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp45 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp46 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp47 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp48 := checkDerefVar(var_glojure_DOT_core_list)
			tmp49 := lang.Apply(tmp48, []any{sym_array})
			tmp50 := checkDerefVar(var_glojure_DOT_core_list)
			tmp51 := lang.Apply(tmp50, []any{sym_idx})
			tmp52 := checkDerefVar(var_glojure_DOT_core_list)
			tmp53 := lang.Apply(tmp52, []any{sym_idx2})
			tmp54 := checkDerefVar(var_glojure_DOT_core_list)
			tmp55 := lang.Apply(tmp54, []any{sym__AMP_})
			tmp56 := checkDerefVar(var_glojure_DOT_core_list)
			tmp57 := lang.Apply(tmp56, []any{sym_idxv})
			tmp58 := lang.Apply(tmp47, []any{tmp49, tmp51, tmp53, tmp55, tmp57})
			tmp59 := lang.Apply(tmp46, []any{tmp58})
			tmp60 := lang.Apply(tmp44, []any{tmp45, tmp59})
			tmp61 := lang.Apply(tmp43, []any{tmp60})
			tmp62 := lang.Apply(tmp27, []any{tmp42, tmp61})
			tmp63 := lang.Apply(tmp26, []any{tmp62})
			tmp64 := lang.Apply(tmp25, []any{tmp63})
			tmp65 := lang.Apply(tmp22, []any{tmp24, tmp64})
			tmp66 := lang.Apply(tmp21, []any{tmp65})
			tmp67 := lang.Apply(tmp20, []any{tmp66})
			tmp68 := lang.Apply(tmp17, []any{tmp19, tmp67})
			tmp69 := lang.Apply(tmp16, []any{tmp68})
			tmp70 := lang.Apply(tmp14, []any{tmp15, tmp69})
			tmp71 := lang.Apply(tmp13, []any{tmp70})
			tmp72 := checkDerefVar(var_glojure_DOT_core_list)
			tmp73 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp74 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp75 := checkDerefVar(var_glojure_DOT_core_list)
			tmp76 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp77 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp78 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp79 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp80 := checkDerefVar(var_glojure_DOT_core_list)
			tmp81 := lang.Apply(tmp80, []any{sym_array__0__auto__})
			tmp82 := checkDerefVar(var_glojure_DOT_core_list)
			tmp83 := lang.Apply(tmp82, []any{sym_idx__1__auto__})
			tmp84 := checkDerefVar(var_glojure_DOT_core_list)
			tmp85 := lang.Apply(tmp84, []any{sym_val__2__auto__})
			tmp86 := lang.Apply(tmp79, []any{tmp81, tmp83, tmp85})
			tmp87 := lang.Apply(tmp78, []any{tmp86})
			tmp88 := lang.Apply(tmp76, []any{tmp77, tmp87})
			tmp89 := lang.Apply(tmp75, []any{tmp88})
			tmp90 := checkDerefVar(var_glojure_DOT_core_list)
			tmp91 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp92 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp93 := checkDerefVar(var_glojure_DOT_core_list)
			tmp94 := lang.Apply(tmp93, []any{sym__DOT_})
			tmp95 := checkDerefVar(var_glojure_DOT_core_list)
			tmp96 := lang.Apply(tmp95, []any{sym_glojure_DOT_core_SLASH_Array})
			tmp97 := checkDerefVar(var_glojure_DOT_core_list)
			tmp98 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp99 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp100 := checkDerefVar(var_glojure_DOT_core_list)
			tmp101 := lang.Apply(tmp100, []any{v5})
			tmp102 := checkDerefVar(var_glojure_DOT_core_list)
			tmp103 := lang.Apply(tmp102, []any{sym_array__0__auto__})
			tmp104 := checkDerefVar(var_glojure_DOT_core_list)
			tmp105 := lang.Apply(tmp104, []any{sym_idx__1__auto__})
			tmp106 := checkDerefVar(var_glojure_DOT_core_list)
			tmp107 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp108 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp109 := checkDerefVar(var_glojure_DOT_core_list)
			tmp110 := lang.Apply(tmp109, []any{v6})
			tmp111 := checkDerefVar(var_glojure_DOT_core_list)
			tmp112 := lang.Apply(tmp111, []any{sym_val__2__auto__})
			tmp113 := lang.Apply(tmp108, []any{tmp110, tmp112})
			tmp114 := lang.Apply(tmp107, []any{tmp113})
			tmp115 := lang.Apply(tmp106, []any{tmp114})
			tmp116 := lang.Apply(tmp99, []any{tmp101, tmp103, tmp105, tmp115})
			tmp117 := lang.Apply(tmp98, []any{tmp116})
			tmp118 := lang.Apply(tmp97, []any{tmp117})
			tmp119 := lang.Apply(tmp92, []any{tmp94, tmp96, tmp118})
			tmp120 := lang.Apply(tmp91, []any{tmp119})
			tmp121 := lang.Apply(tmp90, []any{tmp120})
			tmp122 := checkDerefVar(var_glojure_DOT_core_list)
			tmp123 := lang.Apply(tmp122, []any{sym_val__2__auto__})
			tmp124 := lang.Apply(tmp74, []any{tmp89, tmp121, tmp123})
			tmp125 := lang.Apply(tmp73, []any{tmp124})
			tmp126 := lang.Apply(tmp72, []any{tmp125})
			tmp127 := checkDerefVar(var_glojure_DOT_core_list)
			tmp128 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp129 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp130 := checkDerefVar(var_glojure_DOT_core_list)
			tmp131 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp132 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp133 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp134 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp135 := checkDerefVar(var_glojure_DOT_core_list)
			tmp136 := lang.Apply(tmp135, []any{sym_array__0__auto__})
			tmp137 := checkDerefVar(var_glojure_DOT_core_list)
			tmp138 := lang.Apply(tmp137, []any{sym_idx__1__auto__})
			tmp139 := checkDerefVar(var_glojure_DOT_core_list)
			tmp140 := lang.Apply(tmp139, []any{sym_idx2__3__auto__})
			tmp141 := checkDerefVar(var_glojure_DOT_core_list)
			tmp142 := lang.Apply(tmp141, []any{sym__AMP_})
			tmp143 := checkDerefVar(var_glojure_DOT_core_list)
			tmp144 := lang.Apply(tmp143, []any{sym_idxv__4__auto__})
			tmp145 := lang.Apply(tmp134, []any{tmp136, tmp138, tmp140, tmp142, tmp144})
			tmp146 := lang.Apply(tmp133, []any{tmp145})
			tmp147 := lang.Apply(tmp131, []any{tmp132, tmp146})
			tmp148 := lang.Apply(tmp130, []any{tmp147})
			tmp149 := checkDerefVar(var_glojure_DOT_core_list)
			tmp150 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp151 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp152 := checkDerefVar(var_glojure_DOT_core_list)
			tmp153 := lang.Apply(tmp152, []any{sym_glojure_DOT_core_SLASH_apply})
			tmp154 := checkDerefVar(var_glojure_DOT_core_list)
			tmp155 := lang.Apply(tmp154, []any{v4})
			tmp156 := checkDerefVar(var_glojure_DOT_core_list)
			tmp157 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp158 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp159 := checkDerefVar(var_glojure_DOT_core_list)
			tmp160 := lang.Apply(tmp159, []any{sym_glojure_DOT_core_SLASH_aget})
			tmp161 := checkDerefVar(var_glojure_DOT_core_list)
			tmp162 := lang.Apply(tmp161, []any{sym_array__0__auto__})
			tmp163 := checkDerefVar(var_glojure_DOT_core_list)
			tmp164 := lang.Apply(tmp163, []any{sym_idx__1__auto__})
			tmp165 := lang.Apply(tmp158, []any{tmp160, tmp162, tmp164})
			tmp166 := lang.Apply(tmp157, []any{tmp165})
			tmp167 := lang.Apply(tmp156, []any{tmp166})
			tmp168 := checkDerefVar(var_glojure_DOT_core_list)
			tmp169 := lang.Apply(tmp168, []any{sym_idx2__3__auto__})
			tmp170 := checkDerefVar(var_glojure_DOT_core_list)
			tmp171 := lang.Apply(tmp170, []any{sym_idxv__4__auto__})
			tmp172 := lang.Apply(tmp151, []any{tmp153, tmp155, tmp167, tmp169, tmp171})
			tmp173 := lang.Apply(tmp150, []any{tmp172})
			tmp174 := lang.Apply(tmp149, []any{tmp173})
			tmp175 := lang.Apply(tmp129, []any{tmp148, tmp174})
			tmp176 := lang.Apply(tmp128, []any{tmp175})
			tmp177 := lang.Apply(tmp127, []any{tmp176})
			tmp178 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp71, tmp126, tmp177})
			tmp179 := lang.Apply(tmp7, []any{tmp178})
			return tmp179
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_def_DASH_aset = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_def_DASH_aset.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// definline
	{
		tmp0 := sym_definline.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_decl)), kw_doc, "Experimental - like defmacro, except defines a named function whose\n  body is the expansion, calls to which may be expanded inline as if\n  it were a macro. Cannot be used with variadic (&) args.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(5253), kw_end_DASH_line, int(5253))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "vec__80"
					tmp7 := checkDerefVar(var_glojure_DOT_core_split_DASH_with)
					tmp8 := checkDerefVar(var_glojure_DOT_core_comp)
					tmp9 := checkDerefVar(var_glojure_DOT_core_not)
					tmp10 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
					tmp11 := lang.Apply(tmp8, []any{tmp9, tmp10})
					tmp12 := lang.Apply(tmp7, []any{tmp11, v5})
					var v13 any = tmp12
					_ = v13
					// let binding "pre-args"
					tmp14 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp15 := lang.Apply(tmp14, []any{v13, int64(0), nil})
					var v16 any = tmp15
					_ = v16
					// let binding "vec__83"
					tmp17 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp18 := lang.Apply(tmp17, []any{v13, int64(1), nil})
					var v19 any = tmp18
					_ = v19
					// let binding "args"
					tmp20 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp21 := lang.Apply(tmp20, []any{v19, int64(0), nil})
					var v22 any = tmp21
					_ = v22
					// let binding "expr"
					tmp23 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp24 := lang.Apply(tmp23, []any{v19, int64(1), nil})
					var v25 any = tmp24
					_ = v25
					tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp27 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp28 := checkDerefVar(var_glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{sym_do})
					tmp30 := checkDerefVar(var_glojure_DOT_core_list)
					tmp31 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp32 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp33 := checkDerefVar(var_glojure_DOT_core_list)
					tmp34 := lang.Apply(tmp33, []any{sym_glojure_DOT_core_SLASH_defn})
					tmp35 := checkDerefVar(var_glojure_DOT_core_list)
					tmp36 := lang.Apply(tmp35, []any{v4})
					tmp37 := checkDerefVar(var_glojure_DOT_core_list)
					tmp38 := lang.Apply(tmp37, []any{v22})
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					tmp40 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp41 := checkDerefVar(var_glojure_DOT_core_eval)
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					tmp43 := lang.Apply(tmp42, []any{sym_glojure_DOT_core_SLASH_fn, v22, v25})
					tmp44 := lang.Apply(tmp41, []any{tmp43})
					tmp45 := lang.Apply(tmp40, []any{tmp44, v22})
					tmp46 := lang.Apply(tmp39, []any{tmp45})
					tmp47 := lang.Apply(tmp32, []any{tmp34, tmp36, v16, tmp38, tmp46})
					tmp48 := lang.Apply(tmp31, []any{tmp47})
					tmp49 := lang.Apply(tmp30, []any{tmp48})
					tmp50 := checkDerefVar(var_glojure_DOT_core_list)
					tmp51 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp52 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp53 := checkDerefVar(var_glojure_DOT_core_list)
					tmp54 := lang.Apply(tmp53, []any{sym_glojure_DOT_core_SLASH_alter_DASH_meta_BANG_})
					tmp55 := checkDerefVar(var_glojure_DOT_core_list)
					tmp56 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp57 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp58 := checkDerefVar(var_glojure_DOT_core_list)
					tmp59 := lang.Apply(tmp58, []any{sym_var})
					tmp60 := checkDerefVar(var_glojure_DOT_core_list)
					tmp61 := lang.Apply(tmp60, []any{v4})
					tmp62 := lang.Apply(tmp57, []any{tmp59, tmp61})
					tmp63 := lang.Apply(tmp56, []any{tmp62})
					tmp64 := lang.Apply(tmp55, []any{tmp63})
					tmp65 := checkDerefVar(var_glojure_DOT_core_list)
					tmp66 := lang.Apply(tmp65, []any{sym_glojure_DOT_core_SLASH_assoc})
					tmp67 := checkDerefVar(var_glojure_DOT_core_list)
					tmp68 := lang.Apply(tmp67, []any{kw_inline})
					tmp69 := checkDerefVar(var_glojure_DOT_core_list)
					tmp70 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp71 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp72 := checkDerefVar(var_glojure_DOT_core_list)
					tmp73 := lang.Apply(tmp72, []any{sym_glojure_DOT_core_SLASH_fn})
					tmp74 := checkDerefVar(var_glojure_DOT_core_list)
					tmp75 := lang.Apply(tmp74, []any{v4})
					tmp76 := checkDerefVar(var_glojure_DOT_core_list)
					tmp77 := lang.Apply(tmp76, []any{v22})
					tmp78 := checkDerefVar(var_glojure_DOT_core_list)
					tmp79 := lang.Apply(tmp78, []any{v25})
					tmp80 := lang.Apply(tmp71, []any{tmp73, tmp75, tmp77, tmp79})
					tmp81 := lang.Apply(tmp70, []any{tmp80})
					tmp82 := lang.Apply(tmp69, []any{tmp81})
					tmp83 := lang.Apply(tmp52, []any{tmp54, tmp64, tmp66, tmp68, tmp82})
					tmp84 := lang.Apply(tmp51, []any{tmp83})
					tmp85 := lang.Apply(tmp50, []any{tmp84})
					tmp86 := checkDerefVar(var_glojure_DOT_core_list)
					tmp87 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp88 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp89 := checkDerefVar(var_glojure_DOT_core_list)
					tmp90 := lang.Apply(tmp89, []any{sym_var})
					tmp91 := checkDerefVar(var_glojure_DOT_core_list)
					tmp92 := lang.Apply(tmp91, []any{v4})
					tmp93 := lang.Apply(tmp88, []any{tmp90, tmp92})
					tmp94 := lang.Apply(tmp87, []any{tmp93})
					tmp95 := lang.Apply(tmp86, []any{tmp94})
					tmp96 := lang.Apply(tmp27, []any{tmp29, tmp49, tmp85, tmp95})
					tmp97 := lang.Apply(tmp26, []any{tmp96})
					tmp6 = tmp97
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_definline = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_definline.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmacro
	{
		tmp0 := sym_defmacro.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_doc_DASH_string_QMARK_, sym_attr_DASH_map_QMARK_, lang.NewVector(sym_params_STAR_), sym_body), lang.NewVector(sym_name, sym_doc_DASH_string_QMARK_, sym_attr_DASH_map_QMARK_, lang.NewList(lang.NewVector(sym_params_STAR_), sym_body), sym__PLUS_, sym_attr_DASH_map_QMARK_)), kw_doc, "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(2), kw_line, int(445), kw_end_DASH_line, int(451))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "prefix"
					var tmp7 any
					{ // let
						// let binding "p"
						tmp8 := checkDerefVar(var_glojure_DOT_core_list)
						tmp9 := lang.Apply(tmp8, []any{v4})
						var v10 any = tmp9
						_ = v10
						// let binding "args"
						var v11 any = v5
						_ = v11
						for {
							var tmp12 any
							{ // let
								// let binding "f"
								tmp13 := checkDerefVar(var_glojure_DOT_core_first)
								tmp14 := lang.Apply(tmp13, []any{v11})
								var v15 any = tmp14
								_ = v15
								var tmp16 any
								tmp17 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
								tmp18 := lang.Apply(tmp17, []any{v15})
								if lang.IsTruthy(tmp18) {
									tmp20 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp21 := lang.Apply(tmp20, []any{v15, v10})
									var tmp19 any = tmp21
									tmp23 := checkDerefVar(var_glojure_DOT_core_next)
									tmp24 := lang.Apply(tmp23, []any{v11})
									var tmp22 any = tmp24
									v10 = tmp19
									v11 = tmp22
									continue
								} else {
									var tmp25 any
									tmp26 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
									tmp27 := lang.Apply(tmp26, []any{v15})
									if lang.IsTruthy(tmp27) {
										tmp29 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp30 := lang.Apply(tmp29, []any{v15, v10})
										var tmp28 any = tmp30
										tmp32 := checkDerefVar(var_glojure_DOT_core_next)
										tmp33 := lang.Apply(tmp32, []any{v11})
										var tmp31 any = tmp33
										v10 = tmp28
										v11 = tmp31
										continue
									} else {
										tmp25 = v10
									}
									tmp16 = tmp25
								}
								tmp12 = tmp16
							} // end let
							tmp7 = tmp12
							break
						}
					} // end let
					var v8 any = tmp7
					_ = v8
					// let binding "fdecl"
					var tmp9 any
					{ // let
						// let binding "fd"
						var v10 any = v5
						_ = v10
						for {
							var tmp11 any
							tmp12 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
							tmp13 := checkDerefVar(var_glojure_DOT_core_first)
							tmp14 := lang.Apply(tmp13, []any{v10})
							tmp15 := lang.Apply(tmp12, []any{tmp14})
							if lang.IsTruthy(tmp15) {
								tmp17 := checkDerefVar(var_glojure_DOT_core_next)
								tmp18 := lang.Apply(tmp17, []any{v10})
								var tmp16 any = tmp18
								v10 = tmp16
								continue
							} else {
								var tmp19 any
								tmp20 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
								tmp21 := checkDerefVar(var_glojure_DOT_core_first)
								tmp22 := lang.Apply(tmp21, []any{v10})
								tmp23 := lang.Apply(tmp20, []any{tmp22})
								if lang.IsTruthy(tmp23) {
									tmp25 := checkDerefVar(var_glojure_DOT_core_next)
									tmp26 := lang.Apply(tmp25, []any{v10})
									var tmp24 any = tmp26
									v10 = tmp24
									continue
								} else {
									tmp19 = v10
								}
								tmp11 = tmp19
							}
							tmp9 = tmp11
							break
						}
					} // end let
					var v10 any = tmp9
					_ = v10
					// let binding "fdecl"
					var tmp11 any
					tmp12 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_first)
					tmp14 := lang.Apply(tmp13, []any{v10})
					tmp15 := lang.Apply(tmp12, []any{tmp14})
					if lang.IsTruthy(tmp15) {
						tmp16 := checkDerefVar(var_glojure_DOT_core_list)
						tmp17 := lang.Apply(tmp16, []any{v10})
						tmp11 = tmp17
					} else {
						tmp11 = v10
					}
					var v18 any = tmp11
					_ = v18
					// let binding "add-implicit-args"
					var tmp19 lang.FnFunc
					tmp19 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v20 := args[0]
						_ = v20
						var tmp21 any
						{ // let
							// let binding "args"
							tmp22 := checkDerefVar(var_glojure_DOT_core_first)
							tmp23 := lang.Apply(tmp22, []any{v20})
							var v24 any = tmp23
							_ = v24
							tmp25 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp26 := checkDerefVar(var_glojure_DOT_core_vec)
							tmp27 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp28 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp29 := lang.Apply(tmp28, []any{sym__AMP_env, v24})
							tmp30 := lang.Apply(tmp27, []any{sym__AMP_form, tmp29})
							tmp31 := lang.Apply(tmp26, []any{tmp30})
							tmp32 := checkDerefVar(var_glojure_DOT_core_next)
							tmp33 := lang.Apply(tmp32, []any{v20})
							tmp34 := lang.Apply(tmp25, []any{tmp31, tmp33})
							tmp21 = tmp34
						} // end let
						return tmp21
					})
					tmp20 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(469), kw_column, int(38), kw_end_DASH_line, int(471), kw_end_DASH_column, int(87))
					tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v22 any = tmp21
					_ = v22
					// let binding "add-args"
					var tmp23 lang.FnFunc
					tmp23 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v24 := args[0]
						_ = v24
						v25 := args[1]
						_ = v25
					recur_loop_61:
						var tmp26 any
						tmp27 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp28 := lang.Apply(tmp27, []any{v25})
						if lang.IsTruthy(tmp28) {
							tmp26 = v24
						} else {
							var tmp29 any
							{ // let
								// let binding "d"
								tmp30 := checkDerefVar(var_glojure_DOT_core_first)
								tmp31 := lang.Apply(tmp30, []any{v25})
								var v32 any = tmp31
								_ = v32
								var tmp33 any
								tmp34 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
								tmp35 := lang.Apply(tmp34, []any{v32})
								if lang.IsTruthy(tmp35) {
									tmp36 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp37 := lang.Apply(tmp36, []any{v24, v32})
									tmp33 = tmp37
								} else {
									tmp39 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp40 := lang.Apply(v22, []any{v32})
									tmp41 := lang.Apply(tmp39, []any{v24, tmp40})
									var tmp38 any = tmp41
									tmp43 := checkDerefVar(var_glojure_DOT_core_next)
									tmp44 := lang.Apply(tmp43, []any{v25})
									var tmp42 any = tmp44
									v24 = tmp38
									v25 = tmp42
									goto recur_loop_61
								}
								tmp29 = tmp33
							} // end let
							tmp26 = tmp29
						}
						return tmp26
					})
					tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(472), kw_column, int(29), kw_end_DASH_line, int(478), kw_end_DASH_column, int(90))
					tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v26 any = tmp25
					_ = v26
					// let binding "fdecl"
					tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp28 := lang.NewVector()
					tmp29 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(479), kw_column, int(41), kw_end_DASH_line, int(479), kw_end_DASH_column, int(42))
					tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp31 := lang.Apply(v26, []any{tmp30, v18})
					tmp32 := lang.Apply(tmp27, []any{tmp31})
					var v33 any = tmp32
					_ = v33
					// let binding "decl"
					var tmp34 any
					{ // let
						// let binding "p"
						var v35 any = v8
						_ = v35
						// let binding "d"
						var v36 any = v33
						_ = v36
						for {
							var tmp37 any
							if lang.IsTruthy(v35) {
								tmp39 := checkDerefVar(var_glojure_DOT_core_next)
								tmp40 := lang.Apply(tmp39, []any{v35})
								var tmp38 any = tmp40
								tmp42 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp43 := checkDerefVar(var_glojure_DOT_core_first)
								tmp44 := lang.Apply(tmp43, []any{v35})
								tmp45 := lang.Apply(tmp42, []any{tmp44, v36})
								var tmp41 any = tmp45
								v35 = tmp38
								v36 = tmp41
								continue
							} else {
								tmp37 = v36
							}
							tmp34 = tmp37
							break
						}
					} // end let
					var v35 any = tmp34
					_ = v35
					tmp36 := checkDerefVar(var_glojure_DOT_core_list)
					tmp37 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp38 := lang.Apply(tmp37, []any{sym_glojure_DOT_core_SLASH_defn, v35})
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{sym_var, v4})
					tmp42 := lang.Apply(tmp39, []any{sym__DOT_, tmp41, lang.NewList(sym_SetMacro)})
					tmp43 := checkDerefVar(var_glojure_DOT_core_list)
					tmp44 := lang.Apply(tmp43, []any{sym_var, v4})
					tmp45 := lang.Apply(tmp36, []any{sym_do, tmp38, tmp42, tmp44})
					tmp6 = tmp45
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(451), kw_column, int(11), kw_end_DASH_line, int(487), kw_end_DASH_column, int(40))).(lang.FnFunc)
		var_glojure_DOT_core_defmacro = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_defmacro.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defn-
	{
		tmp0 := sym_defn_DASH_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_decls)), kw_doc, "same as defn, yielding non-public def", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(4949), kw_end_DASH_line, int(4949))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp7 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
				tmp8 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp9 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp10 := lang.Apply(tmp9, []any{v4})
				tmp11 := lang.Apply(tmp8, []any{tmp10, kw_private, true})
				tmp12 := lang.Apply(tmp7, []any{v4, tmp11})
				tmp13 := lang.Apply(tmp6, []any{sym_glojure_DOT_core_SLASH_defn, tmp12, v5})
				return tmp13
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_defn_DASH_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_defn_DASH_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defonce
	{
		tmp0 := sym_defonce.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_expr)), kw_doc, "defs name to have the root value of the expr iff the named var has no root value,\n  else expr is unevaluated", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(5806), kw_end_DASH_line, int(5806))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp8 := checkDerefVar(var_glojure_DOT_core_list)
			tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_let})
			tmp10 := checkDerefVar(var_glojure_DOT_core_list)
			tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp12 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp15 := checkDerefVar(var_glojure_DOT_core_list)
			tmp16 := lang.Apply(tmp15, []any{sym_v__0__auto__})
			tmp17 := checkDerefVar(var_glojure_DOT_core_list)
			tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp20 := checkDerefVar(var_glojure_DOT_core_list)
			tmp21 := lang.Apply(tmp20, []any{sym_def})
			tmp22 := checkDerefVar(var_glojure_DOT_core_list)
			tmp23 := lang.Apply(tmp22, []any{v4})
			tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
			tmp25 := lang.Apply(tmp18, []any{tmp24})
			tmp26 := lang.Apply(tmp17, []any{tmp25})
			tmp27 := lang.Apply(tmp14, []any{tmp16, tmp26})
			tmp28 := lang.Apply(tmp13, []any{tmp27})
			tmp29 := lang.Apply(tmp11, []any{tmp12, tmp28})
			tmp30 := lang.Apply(tmp10, []any{tmp29})
			tmp31 := checkDerefVar(var_glojure_DOT_core_list)
			tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp33 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp34 := checkDerefVar(var_glojure_DOT_core_list)
			tmp35 := lang.Apply(tmp34, []any{sym_glojure_DOT_core_SLASH_when_DASH_not})
			tmp36 := checkDerefVar(var_glojure_DOT_core_list)
			tmp37 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp38 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp39 := checkDerefVar(var_glojure_DOT_core_list)
			tmp40 := lang.Apply(tmp39, []any{sym__DOT_HasRoot})
			tmp41 := checkDerefVar(var_glojure_DOT_core_list)
			tmp42 := lang.Apply(tmp41, []any{sym_v__0__auto__})
			tmp43 := lang.Apply(tmp38, []any{tmp40, tmp42})
			tmp44 := lang.Apply(tmp37, []any{tmp43})
			tmp45 := lang.Apply(tmp36, []any{tmp44})
			tmp46 := checkDerefVar(var_glojure_DOT_core_list)
			tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp49 := checkDerefVar(var_glojure_DOT_core_list)
			tmp50 := lang.Apply(tmp49, []any{sym_def})
			tmp51 := checkDerefVar(var_glojure_DOT_core_list)
			tmp52 := lang.Apply(tmp51, []any{v4})
			tmp53 := checkDerefVar(var_glojure_DOT_core_list)
			tmp54 := lang.Apply(tmp53, []any{v5})
			tmp55 := lang.Apply(tmp48, []any{tmp50, tmp52, tmp54})
			tmp56 := lang.Apply(tmp47, []any{tmp55})
			tmp57 := lang.Apply(tmp46, []any{tmp56})
			tmp58 := lang.Apply(tmp33, []any{tmp35, tmp45, tmp57})
			tmp59 := lang.Apply(tmp32, []any{tmp58})
			tmp60 := lang.Apply(tmp31, []any{tmp59})
			tmp61 := lang.Apply(tmp7, []any{tmp9, tmp30, tmp60})
			tmp62 := lang.Apply(tmp6, []any{tmp61})
			return tmp62
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_defonce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_defonce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// delay
	{
		tmp0 := sym_delay.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls. See also - realized?", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(739), kw_end_DASH_line, int(739))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_list)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp7 := lang.NewVector()
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(746), kw_column, int(62), kw_end_DASH_line, int(746), kw_end_DASH_column, int(63))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := lang.Apply(tmp6, []any{sym_fn_STAR_, tmp9, v4})
				tmp11 := lang.Apply(tmp5, []any{sym_new, sym_glojure_DOT_lang_DOT_Delay, tmp10})
				return tmp11
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_delay = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_delay.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref-as-map
	{
		tmp0 := sym_deref_DASH_as_DASH_map.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(408), kw_column, int(8), kw_end_DASH_line, int(408), kw_end_DASH_column, int(19), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_o)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "pending"
				var tmp4 any
				{ // let
					// let binding "and__0__auto__"
					tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp6 := reflect.TypeOf((*lang.IPending)(nil)).Elem()
					tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp10 := checkDerefVar(var_glojure_DOT_core_not)
						tmp11, ok := lang.FieldOrMethod(v2, "isRealized")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "isRealized")))
						}
						var tmp12 any
						switch reflect.TypeOf(tmp11).Kind() {
						case reflect.Func:
							tmp12 = lang.Apply(tmp11, nil)
						default:
							tmp12 = tmp11
						}
						tmp13 := lang.Apply(tmp10, []any{tmp12})
						tmp9 = tmp13
					} else {
						tmp9 = v8
					}
					tmp4 = tmp9
				} // end let
				var v5 any = tmp4
				_ = v5
				// let binding "vec__250"
				var tmp6 any
				if lang.IsTruthy(v5) {
				} else {
					var tmp7 any
					func() {
						defer func() {
							if r := recover(); r != nil {
								if lang.CatchMatches(r, lang.Throwable) {
									v8 := r
									_ = v8
									tmp9 := lang.NewVector(true, v8)
									tmp10 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(415), kw_column, int(18), kw_end_DASH_line, int(415), kw_end_DASH_column, int(25))
									tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp7 = tmp11
								} else {
									panic(r)
								}
							}
						}()
						tmp8 := checkDerefVar(var_glojure_DOT_core_deref)
						tmp9 := lang.Apply(tmp8, []any{v2})
						tmp10 := lang.NewVector(false, tmp9)
						tmp11 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(413), kw_column, int(16), kw_end_DASH_line, int(413), kw_end_DASH_column, int(32))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp7 = tmp12
					}()
					tmp6 = tmp7
				}
				var v13 any = tmp6
				_ = v13
				// let binding "ex"
				tmp14 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp15 := lang.Apply(tmp14, []any{v13, int64(0), nil})
				var v16 any = tmp15
				_ = v16
				// let binding "val"
				tmp17 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp18 := lang.Apply(tmp17, []any{v13, int64(1), nil})
				var v19 any = tmp18
				_ = v19
				var tmp20 any
				var tmp21 any
				{ // let
					// let binding "or__0__auto__"
					var v22 any = v16
					_ = v22
					var tmp23 any
					if lang.IsTruthy(v22) {
						tmp23 = v22
					} else {
						var tmp24 any
						{ // let
							// let binding "and__0__auto__"
							tmp25 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
							tmp26 := reflect.TypeOf((*lang.Agent)(nil))
							tmp27 := lang.Apply(tmp25, []any{tmp26, v2})
							var v28 any = tmp27
							_ = v28
							var tmp29 any
							if lang.IsTruthy(v28) {
								tmp30 := checkDerefVar(var_glojure_DOT_core_agent_DASH_error)
								tmp31 := lang.Apply(tmp30, []any{v2})
								tmp29 = tmp31
							} else {
								tmp29 = v28
							}
							tmp24 = tmp29
						} // end let
						tmp23 = tmp24
					}
					tmp21 = tmp23
				} // end let
				if lang.IsTruthy(tmp21) {
					tmp20 = kw_failed
				} else {
					var tmp22 any
					if lang.IsTruthy(v5) {
						tmp22 = kw_pending
					} else {
						var tmp23 any
						if lang.IsTruthy(kw_else) {
							tmp23 = kw_ready
						} else {
						}
						tmp22 = tmp23
					}
					tmp20 = tmp22
				}
				tmp24 := lang.NewMap(kw_status, tmp20, kw_val, v19)
				tmp25 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(416), kw_column, int(5), kw_end_DASH_line, int(429), kw_end_DASH_column, int(14))
				tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp3 = tmp26
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_deref_DASH_as_DASH_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_deref_DASH_as_DASH_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// descendants
	{
		tmp0 := sym_descendants.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag), lang.NewVector(sym_h, sym_tag)), kw_doc, "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on Java type inheritance\n  relationships.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(5593), kw_end_DASH_line, int(5593))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_descendants)
				tmp4 := checkDerefVar(var_glojure_DOT_core_global_DASH_hierarchy)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					tmp7 := lang.Apply(lang.NewUnsupportedOperationError, []any{"Can't get descendants of classes"})
					panic(tmp7)
				} else {
					tmp8 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
					tmp9 := checkDerefVar(var_glojure_DOT_core_get)
					tmp10 := lang.Apply(kw_descendants, []any{v2})
					tmp11 := lang.Apply(tmp9, []any{tmp10, v3})
					tmp12 := lang.Apply(tmp8, []any{tmp11})
					tmp4 = tmp12
				}
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_descendants = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_descendants.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// distinct
	{
		tmp0 := sym_distinct.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_coll)), kw_doc, "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(5053), kw_end_DASH_line, int(5053))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp2 lang.FnFunc
				tmp2 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v3 := args[0]
					_ = v3
					var tmp4 any
					{ // let
						// let binding "seen"
						tmp5 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp6 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
						tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5060), kw_column, int(28), kw_end_DASH_line, int(5060), kw_end_DASH_column, int(30))
						tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 := lang.Apply(tmp5, []any{tmp8})
						var v10 any = tmp9
						_ = v10
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp12 := lang.Apply(v3, nil)
								return tmp12
							case 1:
								v12 := args[0]
								_ = v12
								tmp13 := lang.Apply(v3, []any{v12})
								return tmp13
							case 2:
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								var tmp14 any
								tmp15 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
								tmp16 := checkDerefVar(var_glojure_DOT_core_deref)
								tmp17 := lang.Apply(tmp16, []any{v10})
								tmp18 := lang.Apply(tmp15, []any{tmp17, v13})
								if lang.IsTruthy(tmp18) {
									tmp14 = v12
								} else {
									tmp19 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp20, ok := lang.FieldOrMethod(v10, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "Deref")))
									}
									var tmp21 any
									switch reflect.TypeOf(tmp20).Kind() {
									case reflect.Func:
										tmp21 = lang.Apply(tmp20, nil)
									default:
										tmp21 = tmp20
									}
									tmp22 := lang.Apply(tmp19, []any{tmp21, v13})
									tmp23, _ := lang.FieldOrMethod(v10, "reset")
									if reflect.TypeOf(tmp23).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp24 := lang.Apply(tmp23, []any{tmp22})
									_ = tmp24
									tmp25 := lang.Apply(v3, []any{v12, v13})
									tmp14 = tmp25
								}
								return tmp14
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5061), kw_column, int(8), kw_end_DASH_line, int(5068), kw_end_DASH_column, int(37))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp4 = tmp13
					} // end let
					return tmp4
				})
				tmp3 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5059), kw_column, int(4), kw_end_DASH_line, int(5068), kw_end_DASH_column, int(39))
				tmp4, err := lang.WithMeta(tmp2, tmp3.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "step"
					var tmp4 lang.FnFunc
					{ // function step
						var v5 lang.FnFunc
						tmp4 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							var tmp8 lang.FnFunc
							tmp8 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								var tmp9 lang.FnFunc
								tmp9 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 2)
									v10 := args[0]
									_ = v10
									v11 := args[1]
									_ = v11
								recur_loop_877:
									var tmp12 any
									{ // let
										// let binding "vec__62"
										var v13 any = v10
										_ = v13
										// let binding "f"
										tmp14 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp15 := lang.Apply(tmp14, []any{v13, int64(0), nil})
										var v16 any = tmp15
										_ = v16
										// let binding "xs"
										var v17 any = v13
										_ = v17
										var tmp18 any
										{ // let
											// let binding "temp__0__auto__"
											tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp20 := lang.Apply(tmp19, []any{v17})
											var v21 any = tmp20
											_ = v21
											var tmp22 any
											if lang.IsTruthy(v21) {
												var tmp23 any
												{ // let
													// let binding "s"
													var v24 any = v21
													_ = v24
													var tmp25 any
													tmp26 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
													tmp27 := lang.Apply(tmp26, []any{v11, v16})
													if lang.IsTruthy(tmp27) {
														tmp29 := checkDerefVar(var_glojure_DOT_core_rest)
														tmp30 := lang.Apply(tmp29, []any{v24})
														var tmp28 any = tmp30
														var tmp31 any = v11
														v10 = tmp28
														v11 = tmp31
														goto recur_loop_877
													} else {
														tmp32 := checkDerefVar(var_glojure_DOT_core_cons)
														tmp33 := checkDerefVar(var_glojure_DOT_core_rest)
														tmp34 := lang.Apply(tmp33, []any{v24})
														tmp35 := checkDerefVar(var_glojure_DOT_core_conj)
														tmp36 := lang.Apply(tmp35, []any{v11, v16})
														tmp37 := lang.Apply(v5, []any{tmp34, tmp36})
														tmp38 := lang.Apply(tmp32, []any{v16, tmp37})
														tmp25 = tmp38
													}
													tmp23 = tmp25
												} // end let
												tmp22 = tmp23
											} else {
											}
											tmp18 = tmp22
										} // end let
										tmp12 = tmp18
									} // end let
									return tmp12
								})
								tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5072), kw_column, int(20), kw_end_DASH_line, int(5076), kw_end_DASH_column, int(66))
								tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp12 := lang.Apply(tmp11, []any{v6, v7})
								return tmp12
							})
							tmp9 := lang.Apply(lang.NewLazySeq, []any{tmp8})
							return tmp9
						})
						v5 = tmp4
						_ = v5
					}
					tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5070), kw_column, int(15), kw_end_DASH_line, int(5077), kw_end_DASH_column, int(29))
					tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v7 any = tmp6
					_ = v7
					tmp8 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5078), kw_column, int(17), kw_end_DASH_line, int(5078), kw_end_DASH_column, int(19))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp11 := lang.Apply(v7, []any{v2, tmp10})
					tmp3 = tmp11
				} // end let
				return tmp3
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_distinct = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_distinct.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dorun
	{
		tmp0 := sym_dorun.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll), lang.NewVector(sym_n, sym_coll)), kw_doc, "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3116), kw_end_DASH_line, int(3116))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
			recur_loop_579:
				var tmp3 any
				{ // let
					// let binding "temp__0__auto__"
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := lang.Apply(tmp4, []any{v2})
					var v6 any = tmp5
					_ = v6
					var tmp7 any
					if lang.IsTruthy(v6) {
						var tmp8 any
						{ // let
							// let binding "s"
							var v9 any = v6
							_ = v9
							tmp11 := checkDerefVar(var_glojure_DOT_core_next)
							tmp12 := lang.Apply(tmp11, []any{v9})
							var tmp10 any = tmp12
							v2 = tmp10
							goto recur_loop_579
						} // end let
						tmp7 = tmp8
					} else {
					}
					tmp3 = tmp7
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
			recur_loop_580:
				var tmp4 any
				var tmp5 any
				{ // let
					// let binding "and__0__auto__"
					tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp7 := lang.Apply(tmp6, []any{v3})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp10 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v2})
						tmp9 = tmp11
					} else {
						tmp9 = v8
					}
					tmp5 = tmp9
				} // end let
				if lang.IsTruthy(tmp5) {
					tmp7 := checkDerefVar(var_glojure_DOT_core_dec)
					tmp8 := lang.Apply(tmp7, []any{v2})
					var tmp6 any = tmp8
					tmp10 := checkDerefVar(var_glojure_DOT_core_next)
					tmp11 := lang.Apply(tmp10, []any{v3})
					var tmp9 any = tmp11
					v2 = tmp6
					v3 = tmp9
					goto recur_loop_580
				} else {
				}
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_dorun = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_dorun.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dotimes
	{
		tmp0 := sym_dotimes.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(3306), kw_end_DASH_line, int(3306))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_str)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp12 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp14 := lang.Apply(tmp13, []any{v2})
					tmp15 := lang.Apply(kw_line, []any{tmp14})
					tmp16 := lang.Apply(tmp9, []any{tmp11, " requires ", "a vector for its binding", " in ", tmp12, ":", tmp15})
					tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
					panic(tmp17)
				}
				_ = tmp6
				var tmp18 any
				tmp19 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp20 := checkDerefVar(var_glojure_DOT_core_count)
				tmp21 := lang.Apply(tmp20, []any{v4})
				tmp22 := lang.Apply(tmp19, []any{int64(2), tmp21})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "exactly 2 forms in binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp18
				var tmp32 any
				{ // let
					// let binding "i"
					tmp33 := checkDerefVar(var_glojure_DOT_core_first)
					tmp34 := lang.Apply(tmp33, []any{v4})
					var v35 any = tmp34
					_ = v35
					// let binding "n"
					tmp36 := checkDerefVar(var_glojure_DOT_core_second)
					tmp37 := lang.Apply(tmp36, []any{v4})
					var v38 any = tmp37
					_ = v38
					tmp39 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp40 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp41 := checkDerefVar(var_glojure_DOT_core_list)
					tmp42 := lang.Apply(tmp41, []any{sym_glojure_DOT_core_SLASH_let})
					tmp43 := checkDerefVar(var_glojure_DOT_core_list)
					tmp44 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp45 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp46 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp47 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp48 := checkDerefVar(var_glojure_DOT_core_list)
					tmp49 := lang.Apply(tmp48, []any{sym_n__0__auto__})
					tmp50 := checkDerefVar(var_glojure_DOT_core_list)
					tmp51 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp52 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp53 := checkDerefVar(var_glojure_DOT_core_list)
					tmp54 := lang.Apply(tmp53, []any{sym_glojure_DOT_core_SLASH_long})
					tmp55 := checkDerefVar(var_glojure_DOT_core_list)
					tmp56 := lang.Apply(tmp55, []any{v38})
					tmp57 := lang.Apply(tmp52, []any{tmp54, tmp56})
					tmp58 := lang.Apply(tmp51, []any{tmp57})
					tmp59 := lang.Apply(tmp50, []any{tmp58})
					tmp60 := lang.Apply(tmp47, []any{tmp49, tmp59})
					tmp61 := lang.Apply(tmp46, []any{tmp60})
					tmp62 := lang.Apply(tmp44, []any{tmp45, tmp61})
					tmp63 := lang.Apply(tmp43, []any{tmp62})
					tmp64 := checkDerefVar(var_glojure_DOT_core_list)
					tmp65 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp66 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp67 := checkDerefVar(var_glojure_DOT_core_list)
					tmp68 := lang.Apply(tmp67, []any{sym_glojure_DOT_core_SLASH_loop})
					tmp69 := checkDerefVar(var_glojure_DOT_core_list)
					tmp70 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp71 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp72 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp73 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp74 := checkDerefVar(var_glojure_DOT_core_list)
					tmp75 := lang.Apply(tmp74, []any{v35})
					tmp76 := checkDerefVar(var_glojure_DOT_core_list)
					tmp77 := lang.Apply(tmp76, []any{int64(0)})
					tmp78 := lang.Apply(tmp73, []any{tmp75, tmp77})
					tmp79 := lang.Apply(tmp72, []any{tmp78})
					tmp80 := lang.Apply(tmp70, []any{tmp71, tmp79})
					tmp81 := lang.Apply(tmp69, []any{tmp80})
					tmp82 := checkDerefVar(var_glojure_DOT_core_list)
					tmp83 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp84 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp85 := checkDerefVar(var_glojure_DOT_core_list)
					tmp86 := lang.Apply(tmp85, []any{sym_glojure_DOT_core_SLASH_when})
					tmp87 := checkDerefVar(var_glojure_DOT_core_list)
					tmp88 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp89 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp90 := checkDerefVar(var_glojure_DOT_core_list)
					tmp91 := lang.Apply(tmp90, []any{sym_glojure_DOT_core_SLASH__LT_})
					tmp92 := checkDerefVar(var_glojure_DOT_core_list)
					tmp93 := lang.Apply(tmp92, []any{v35})
					tmp94 := checkDerefVar(var_glojure_DOT_core_list)
					tmp95 := lang.Apply(tmp94, []any{sym_n__0__auto__})
					tmp96 := lang.Apply(tmp89, []any{tmp91, tmp93, tmp95})
					tmp97 := lang.Apply(tmp88, []any{tmp96})
					tmp98 := lang.Apply(tmp87, []any{tmp97})
					tmp99 := checkDerefVar(var_glojure_DOT_core_list)
					tmp100 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp101 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp102 := checkDerefVar(var_glojure_DOT_core_list)
					tmp103 := lang.Apply(tmp102, []any{sym_recur})
					tmp104 := checkDerefVar(var_glojure_DOT_core_list)
					tmp105 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp106 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp107 := checkDerefVar(var_glojure_DOT_core_list)
					tmp108 := lang.Apply(tmp107, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc})
					tmp109 := checkDerefVar(var_glojure_DOT_core_list)
					tmp110 := lang.Apply(tmp109, []any{v35})
					tmp111 := lang.Apply(tmp106, []any{tmp108, tmp110})
					tmp112 := lang.Apply(tmp105, []any{tmp111})
					tmp113 := lang.Apply(tmp104, []any{tmp112})
					tmp114 := lang.Apply(tmp101, []any{tmp103, tmp113})
					tmp115 := lang.Apply(tmp100, []any{tmp114})
					tmp116 := lang.Apply(tmp99, []any{tmp115})
					tmp117 := lang.Apply(tmp84, []any{tmp86, tmp98, v5, tmp116})
					tmp118 := lang.Apply(tmp83, []any{tmp117})
					tmp119 := lang.Apply(tmp82, []any{tmp118})
					tmp120 := lang.Apply(tmp66, []any{tmp68, tmp81, tmp119})
					tmp121 := lang.Apply(tmp65, []any{tmp120})
					tmp122 := lang.Apply(tmp64, []any{tmp121})
					tmp123 := lang.Apply(tmp40, []any{tmp42, tmp63, tmp122})
					tmp124 := lang.Apply(tmp39, []any{tmp123})
					tmp32 = tmp124
				} // end let
				return tmp32
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_dotimes = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_dotimes.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop
	{
		tmp0 := sym_drop.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n), lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a laziness-preserving sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2901), kw_end_DASH_line, int(2901))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "nv"
						tmp6 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp7 := lang.Apply(tmp6, []any{v2})
						var v8 any = tmp7
						_ = v8
						var tmp9 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp10 := lang.Apply(v4, nil)
								return tmp10
							case 1:
								v10 := args[0]
								_ = v10
								tmp11 := lang.Apply(v4, []any{v10})
								return tmp11
							case 2:
								v10 := args[0]
								_ = v10
								v11 := args[1]
								_ = v11
								var tmp12 any
								{ // let
									// let binding "n"
									tmp13 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp14 := lang.Apply(tmp13, []any{v8})
									var v15 any = tmp14
									_ = v15
									tmp16 := checkDerefVar(var_glojure_DOT_core_dec)
									tmp17, ok := lang.FieldOrMethod(v8, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Deref")))
									}
									var tmp18 any
									switch reflect.TypeOf(tmp17).Kind() {
									case reflect.Func:
										tmp18 = lang.Apply(tmp17, nil)
									default:
										tmp18 = tmp17
									}
									tmp19 := lang.Apply(tmp16, []any{tmp18})
									tmp20, _ := lang.FieldOrMethod(v8, "reset")
									if reflect.TypeOf(tmp20).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp21 := lang.Apply(tmp20, []any{tmp19})
									_ = tmp21
									var tmp22 any
									tmp23 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
									tmp24 := lang.Apply(tmp23, []any{v15})
									if lang.IsTruthy(tmp24) {
										tmp22 = v10
									} else {
										tmp25 := lang.Apply(v4, []any{v10, v11})
										tmp22 = tmp25
									}
									tmp12 = tmp22
								} // end let
								return tmp12
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2909), kw_column, int(10), kw_end_DASH_line, int(2917), kw_end_DASH_column, int(39))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp11
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2907), kw_column, int(6), kw_end_DASH_line, int(2917), kw_end_DASH_column, int(41))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
				if lang.IsTruthy(tmp7) {
					var tmp8 any
					{ // let
						// let binding "or__0__auto__"
						var tmp9 any
						tmp10 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v2})
						if lang.IsTruthy(tmp11) {
							var tmp12 any
							tmp13 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
							tmp14 := lang.Apply(tmp13, []any{v2})
							if lang.IsTruthy(tmp14) {
								tmp12 = v2
							} else {
								tmp15 := lang.Apply(nil, []any{v2})
								tmp12 = tmp15
							}
							tmp16, _ := lang.FieldOrMethod(v3, "drop")
							if reflect.TypeOf(tmp16).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
							}
							tmp17 := lang.Apply(tmp16, []any{tmp12})
							tmp9 = tmp17
						} else {
							tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp19 := lang.Apply(tmp18, []any{v3})
							tmp9 = tmp19
						}
						var v20 any = tmp9
						_ = v20
						var tmp21 any
						if lang.IsTruthy(v20) {
							tmp21 = v20
						} else {
							tmp21 = lang.NewList()
						}
						tmp8 = tmp21
					} // end let
					tmp4 = tmp8
				} else {
					var tmp9 any
					{ // let
						// let binding "step"
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v11 := args[0]
							_ = v11
							v12 := args[1]
							_ = v12
						recur_loop_539:
							var tmp13 any
							{ // let
								// let binding "s"
								tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp15 := lang.Apply(tmp14, []any{v12})
								var v16 any = tmp15
								_ = v16
								var tmp17 any
								var tmp18 any
								{ // let
									// let binding "and__0__auto__"
									tmp19 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
									tmp20 := lang.Apply(tmp19, []any{v11})
									var v21 any = tmp20
									_ = v21
									var tmp22 any
									if lang.IsTruthy(v21) {
										tmp22 = v16
									} else {
										tmp22 = v21
									}
									tmp18 = tmp22
								} // end let
								if lang.IsTruthy(tmp18) {
									tmp20 := checkDerefVar(var_glojure_DOT_core_dec)
									tmp21 := lang.Apply(tmp20, []any{v11})
									var tmp19 any = tmp21
									tmp23 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp24 := lang.Apply(tmp23, []any{v16})
									var tmp22 any = tmp24
									v11 = tmp19
									v12 = tmp22
									goto recur_loop_539
								} else {
									tmp17 = v16
								}
								tmp13 = tmp17
							} // end let
							return tmp13
						})
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2925), kw_column, int(19), kw_end_DASH_line, int(2929), kw_end_DASH_column, int(28))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v13 any = tmp12
						_ = v13
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							tmp15 := lang.Apply(v13, []any{v2, v3})
							return tmp15
						})
						tmp15 := lang.Apply(lang.NewLazySeq, []any{tmp14})
						tmp9 = tmp15
					} // end let
					tmp4 = tmp9
				}
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_drop = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_drop.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// elide-top-frames
	{
		tmp0 := sym_elide_DASH_top_DASH_frames.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(4794), kw_column, int(7), kw_end_DASH_line, int(4794), kw_end_DASH_column, int(32), kw_arglists, lang.NewList(lang.NewVector(sym_ex, sym_class_DASH_name)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "tr"
				tmp5, ok := lang.FieldOrMethod(v2, "getStackTrace")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getStackTrace")))
				}
				var tmp6 any
				switch reflect.TypeOf(tmp5).Kind() {
				case reflect.Func:
					tmp6 = lang.Apply(tmp5, nil)
				default:
					tmp6 = tmp5
				}
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				{ // let
					// let binding "G__54"
					var v9 any = v2
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v7) {
						tmp11 := checkDerefVar(var_glojure_DOT_core_into_DASH_array)
						tmp12 := checkDerefVar(var_glojure_DOT_core_drop_DASH_while)
						var tmp13 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v14 := args[0]
							_ = v14
							tmp15 := checkDerefVar(var_glojure_DOT_core__EQ_)
							tmp16, ok := lang.FieldOrMethod(v14, "getClassName")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "getClassName")))
							}
							var tmp17 any
							switch reflect.TypeOf(tmp16).Kind() {
							case reflect.Func:
								tmp17 = lang.Apply(tmp16, nil)
							default:
								tmp17 = tmp16
							}
							tmp18 := lang.Apply(tmp15, []any{v3, tmp17})
							return tmp18
						})
						tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4801), kw_column, int(25), kw_end_DASH_line, int(4801), kw_end_DASH_column, int(77))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp16 := lang.Apply(tmp12, []any{tmp15, v7})
						tmp17 := lang.Apply(tmp11, []any{nil, tmp16})
						tmp10 = tmp17
					} else {
					}
					tmp18, _ := lang.FieldOrMethod(v9, "setStackTrace")
					if reflect.TypeOf(tmp18).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setStackTrace is not a function")))
					}
					tmp19 := lang.Apply(tmp18, []any{tmp10})
					_ = tmp19
					tmp8 = v9
				} // end let
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_elide_DASH_top_DASH_frames = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_elide_DASH_top_DASH_frames.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// empty?
	{
		tmp0 := sym_empty_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll has no items. To check the emptiness of a seq,\n  please use the idiom (seq x) rather than (not (empty? x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6247), kw_end_DASH_line, int(6247))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_counted_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp6 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
				tmp7 := checkDerefVar(var_glojure_DOT_core_count)
				tmp8 := lang.Apply(tmp7, []any{v2})
				tmp9 := lang.Apply(tmp6, []any{tmp8})
				tmp3 = tmp9
			} else {
				tmp10 := checkDerefVar(var_glojure_DOT_core_not)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := lang.Apply(tmp11, []any{v2})
				tmp13 := lang.Apply(tmp10, []any{tmp12})
				tmp3 = tmp13
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_empty_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_empty_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ensure-reduced
	{
		tmp0 := sym_ensure_DASH_reduced.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "If x is already reduced?, returns it, else returns (reduced x)", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(2841), kw_end_DASH_line, int(2841))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp3 = v2
			} else {
				tmp6 := checkDerefVar(var_glojure_DOT_core_reduced)
				tmp7 := lang.Apply(tmp6, []any{v2})
				tmp3 = tmp7
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ensure_DASH_reduced = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ensure_DASH_reduced.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// even?
	{
		tmp0 := sym_even_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is even, throws an exception if n is not an integer", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(1381), kw_end_DASH_line, int(1381))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_integer_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp6 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
				tmp7 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and)
				tmp8 := lang.Apply(lang.UncheckedLongCast, []any{v2})
				tmp9 := lang.Apply(tmp7, []any{tmp8, int64(1)})
				tmp10 := lang.Apply(tmp6, []any{tmp9})
				tmp3 = tmp10
			} else {
				tmp11 := checkDerefVar(var_glojure_DOT_core_str)
				tmp12 := lang.Apply(tmp11, []any{"Argument must be an integer: ", v2})
				tmp13 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp12})
				panic(tmp13)
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_even_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_even_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// every-pred
	{
		tmp0 := sym_every_DASH_pred.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_p), lang.NewVector(sym_p1, sym_p2), lang.NewVector(sym_p1, sym_p2, sym_p3), lang.NewVector(sym_p1, sym_p2, sym_p3, sym__AMP_, sym_ps)), kw_doc, "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7422), kw_end_DASH_line, int(7422))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				{ // function ep1
					var v4 lang.FnFunc
					tmp3 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v5 := args[0]
							_ = v5
							tmp6 := checkDerefVar(var_glojure_DOT_core_boolean)
							tmp7 := lang.Apply(v2, []any{v5})
							tmp8 := lang.Apply(tmp6, []any{tmp7})
							return tmp8
						case 2:
							v5 := args[0]
							_ = v5
							v6 := args[1]
							_ = v6
							tmp7 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp8 any
							{ // let
								// let binding "and__0__auto__"
								tmp9 := lang.Apply(v2, []any{v5})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								if lang.IsTruthy(v10) {
									tmp12 := lang.Apply(v2, []any{v6})
									tmp11 = tmp12
								} else {
									tmp11 = v10
								}
								tmp8 = tmp11
							} // end let
							tmp9 := lang.Apply(tmp7, []any{tmp8})
							return tmp9
						case 3:
							v5 := args[0]
							_ = v5
							v6 := args[1]
							_ = v6
							v7 := args[2]
							_ = v7
							tmp8 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp9 any
							{ // let
								// let binding "and__0__auto__"
								tmp10 := lang.Apply(v2, []any{v5})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									var tmp13 any
									{ // let
										// let binding "and__0__auto__"
										tmp14 := lang.Apply(v2, []any{v6})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp17 := lang.Apply(v2, []any{v7})
											tmp16 = tmp17
										} else {
											tmp16 = v15
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								} else {
									tmp12 = v11
								}
								tmp9 = tmp12
							} // end let
							tmp10 := lang.Apply(tmp8, []any{tmp9})
							return tmp10
						default:
							checkArityGTE(args, 3)
							v5 := args[0]
							_ = v5
							v6 := args[1]
							_ = v6
							v7 := args[2]
							_ = v7
							var v8 any = lang.NewList(args[3:]...)
							_ = v8
							tmp9 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := lang.Apply(v4, []any{v5, v6, v7})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp14 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
									tmp15 := lang.Apply(tmp14, []any{v2, v8})
									tmp13 = tmp15
								} else {
									tmp13 = v12
								}
								tmp10 = tmp13
							} // end let
							tmp11 := lang.Apply(tmp9, []any{tmp10})
							return tmp11
						}
					})
					v4 = tmp3
					_ = v4
				}
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7429), kw_column, int(6), kw_end_DASH_line, int(7435), kw_end_DASH_column, int(56))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				{ // function ep2
					var v5 lang.FnFunc
					tmp4 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v6 := args[0]
							_ = v6
							tmp7 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp8 any
							{ // let
								// let binding "and__0__auto__"
								tmp9 := lang.Apply(v2, []any{v6})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								if lang.IsTruthy(v10) {
									tmp12 := lang.Apply(v3, []any{v6})
									tmp11 = tmp12
								} else {
									tmp11 = v10
								}
								tmp8 = tmp11
							} // end let
							tmp9 := lang.Apply(tmp7, []any{tmp8})
							return tmp9
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							tmp8 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp9 any
							{ // let
								// let binding "and__0__auto__"
								tmp10 := lang.Apply(v2, []any{v6})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									var tmp13 any
									{ // let
										// let binding "and__0__auto__"
										tmp14 := lang.Apply(v2, []any{v7})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											var tmp17 any
											{ // let
												// let binding "and__0__auto__"
												tmp18 := lang.Apply(v3, []any{v6})
												var v19 any = tmp18
												_ = v19
												var tmp20 any
												if lang.IsTruthy(v19) {
													tmp21 := lang.Apply(v3, []any{v7})
													tmp20 = tmp21
												} else {
													tmp20 = v19
												}
												tmp17 = tmp20
											} // end let
											tmp16 = tmp17
										} else {
											tmp16 = v15
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								} else {
									tmp12 = v11
								}
								tmp9 = tmp12
							} // end let
							tmp10 := lang.Apply(tmp8, []any{tmp9})
							return tmp10
						case 3:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							tmp9 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := lang.Apply(v2, []any{v6})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									var tmp14 any
									{ // let
										// let binding "and__0__auto__"
										tmp15 := lang.Apply(v2, []any{v7})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											var tmp18 any
											{ // let
												// let binding "and__0__auto__"
												tmp19 := lang.Apply(v2, []any{v8})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													var tmp22 any
													{ // let
														// let binding "and__0__auto__"
														tmp23 := lang.Apply(v3, []any{v6})
														var v24 any = tmp23
														_ = v24
														var tmp25 any
														if lang.IsTruthy(v24) {
															var tmp26 any
															{ // let
																// let binding "and__0__auto__"
																tmp27 := lang.Apply(v3, []any{v7})
																var v28 any = tmp27
																_ = v28
																var tmp29 any
																if lang.IsTruthy(v28) {
																	tmp30 := lang.Apply(v3, []any{v8})
																	tmp29 = tmp30
																} else {
																	tmp29 = v28
																}
																tmp26 = tmp29
															} // end let
															tmp25 = tmp26
														} else {
															tmp25 = v24
														}
														tmp22 = tmp25
													} // end let
													tmp21 = tmp22
												} else {
													tmp21 = v20
												}
												tmp18 = tmp21
											} // end let
											tmp17 = tmp18
										} else {
											tmp17 = v16
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								} else {
									tmp13 = v12
								}
								tmp10 = tmp13
							} // end let
							tmp11 := lang.Apply(tmp9, []any{tmp10})
							return tmp11
						default:
							checkArityGTE(args, 3)
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var v9 any = lang.NewList(args[3:]...)
							_ = v9
							tmp10 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp11 any
							{ // let
								// let binding "and__0__auto__"
								tmp12 := lang.Apply(v5, []any{v6, v7, v8})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp15 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
									var tmp16 lang.FnFunc
									tmp16 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v17 := args[0]
										_ = v17
										var tmp18 any
										{ // let
											// let binding "and__0__auto__"
											tmp19 := lang.Apply(v2, []any{v17})
											var v20 any = tmp19
											_ = v20
											var tmp21 any
											if lang.IsTruthy(v20) {
												tmp22 := lang.Apply(v3, []any{v17})
												tmp21 = tmp22
											} else {
												tmp21 = v20
											}
											tmp18 = tmp21
										} // end let
										return tmp18
									})
									tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7443), kw_column, int(46), kw_end_DASH_line, int(7443), kw_end_DASH_column, int(65))
									tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp19 := lang.Apply(tmp15, []any{tmp18, v9})
									tmp14 = tmp19
								} else {
									tmp14 = v13
								}
								tmp11 = tmp14
							} // end let
							tmp12 := lang.Apply(tmp10, []any{tmp11})
							return tmp12
						}
					})
					v5 = tmp4
					_ = v5
				}
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7437), kw_column, int(6), kw_end_DASH_line, int(7443), kw_end_DASH_column, int(75))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 lang.FnFunc
				{ // function ep3
					var v6 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp9 any
							{ // let
								// let binding "and__0__auto__"
								tmp10 := lang.Apply(v2, []any{v7})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									var tmp13 any
									{ // let
										// let binding "and__0__auto__"
										tmp14 := lang.Apply(v3, []any{v7})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp17 := lang.Apply(v4, []any{v7})
											tmp16 = tmp17
										} else {
											tmp16 = v15
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								} else {
									tmp12 = v11
								}
								tmp9 = tmp12
							} // end let
							tmp10 := lang.Apply(tmp8, []any{tmp9})
							return tmp10
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							tmp9 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := lang.Apply(v2, []any{v7})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									var tmp14 any
									{ // let
										// let binding "and__0__auto__"
										tmp15 := lang.Apply(v2, []any{v8})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											var tmp18 any
											{ // let
												// let binding "and__0__auto__"
												tmp19 := lang.Apply(v3, []any{v7})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													var tmp22 any
													{ // let
														// let binding "and__0__auto__"
														tmp23 := lang.Apply(v3, []any{v8})
														var v24 any = tmp23
														_ = v24
														var tmp25 any
														if lang.IsTruthy(v24) {
															var tmp26 any
															{ // let
																// let binding "and__0__auto__"
																tmp27 := lang.Apply(v4, []any{v7})
																var v28 any = tmp27
																_ = v28
																var tmp29 any
																if lang.IsTruthy(v28) {
																	tmp30 := lang.Apply(v4, []any{v8})
																	tmp29 = tmp30
																} else {
																	tmp29 = v28
																}
																tmp26 = tmp29
															} // end let
															tmp25 = tmp26
														} else {
															tmp25 = v24
														}
														tmp22 = tmp25
													} // end let
													tmp21 = tmp22
												} else {
													tmp21 = v20
												}
												tmp18 = tmp21
											} // end let
											tmp17 = tmp18
										} else {
											tmp17 = v16
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								} else {
									tmp13 = v12
								}
								tmp10 = tmp13
							} // end let
							tmp11 := lang.Apply(tmp9, []any{tmp10})
							return tmp11
						case 3:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							tmp10 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp11 any
							{ // let
								// let binding "and__0__auto__"
								tmp12 := lang.Apply(v2, []any{v7})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									var tmp15 any
									{ // let
										// let binding "and__0__auto__"
										tmp16 := lang.Apply(v2, []any{v8})
										var v17 any = tmp16
										_ = v17
										var tmp18 any
										if lang.IsTruthy(v17) {
											var tmp19 any
											{ // let
												// let binding "and__0__auto__"
												tmp20 := lang.Apply(v2, []any{v9})
												var v21 any = tmp20
												_ = v21
												var tmp22 any
												if lang.IsTruthy(v21) {
													var tmp23 any
													{ // let
														// let binding "and__0__auto__"
														tmp24 := lang.Apply(v3, []any{v7})
														var v25 any = tmp24
														_ = v25
														var tmp26 any
														if lang.IsTruthy(v25) {
															var tmp27 any
															{ // let
																// let binding "and__0__auto__"
																tmp28 := lang.Apply(v3, []any{v8})
																var v29 any = tmp28
																_ = v29
																var tmp30 any
																if lang.IsTruthy(v29) {
																	var tmp31 any
																	{ // let
																		// let binding "and__0__auto__"
																		tmp32 := lang.Apply(v3, []any{v9})
																		var v33 any = tmp32
																		_ = v33
																		var tmp34 any
																		if lang.IsTruthy(v33) {
																			var tmp35 any
																			{ // let
																				// let binding "and__0__auto__"
																				tmp36 := lang.Apply(v4, []any{v7})
																				var v37 any = tmp36
																				_ = v37
																				var tmp38 any
																				if lang.IsTruthy(v37) {
																					var tmp39 any
																					{ // let
																						// let binding "and__0__auto__"
																						tmp40 := lang.Apply(v4, []any{v8})
																						var v41 any = tmp40
																						_ = v41
																						var tmp42 any
																						if lang.IsTruthy(v41) {
																							tmp43 := lang.Apply(v4, []any{v9})
																							tmp42 = tmp43
																						} else {
																							tmp42 = v41
																						}
																						tmp39 = tmp42
																					} // end let
																					tmp38 = tmp39
																				} else {
																					tmp38 = v37
																				}
																				tmp35 = tmp38
																			} // end let
																			tmp34 = tmp35
																		} else {
																			tmp34 = v33
																		}
																		tmp31 = tmp34
																	} // end let
																	tmp30 = tmp31
																} else {
																	tmp30 = v29
																}
																tmp27 = tmp30
															} // end let
															tmp26 = tmp27
														} else {
															tmp26 = v25
														}
														tmp23 = tmp26
													} // end let
													tmp22 = tmp23
												} else {
													tmp22 = v21
												}
												tmp19 = tmp22
											} // end let
											tmp18 = tmp19
										} else {
											tmp18 = v17
										}
										tmp15 = tmp18
									} // end let
									tmp14 = tmp15
								} else {
									tmp14 = v13
								}
								tmp11 = tmp14
							} // end let
							tmp12 := lang.Apply(tmp10, []any{tmp11})
							return tmp12
						default:
							checkArityGTE(args, 3)
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var v10 any = lang.NewList(args[3:]...)
							_ = v10
							tmp11 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp12 any
							{ // let
								// let binding "and__0__auto__"
								tmp13 := lang.Apply(v6, []any{v7, v8, v9})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									tmp16 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
									var tmp17 lang.FnFunc
									tmp17 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v18 := args[0]
										_ = v18
										var tmp19 any
										{ // let
											// let binding "and__0__auto__"
											tmp20 := lang.Apply(v2, []any{v18})
											var v21 any = tmp20
											_ = v21
											var tmp22 any
											if lang.IsTruthy(v21) {
												var tmp23 any
												{ // let
													// let binding "and__0__auto__"
													tmp24 := lang.Apply(v3, []any{v18})
													var v25 any = tmp24
													_ = v25
													var tmp26 any
													if lang.IsTruthy(v25) {
														tmp27 := lang.Apply(v4, []any{v18})
														tmp26 = tmp27
													} else {
														tmp26 = v25
													}
													tmp23 = tmp26
												} // end let
												tmp22 = tmp23
											} else {
												tmp22 = v21
											}
											tmp19 = tmp22
										} // end let
										return tmp19
									})
									tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7451), kw_column, int(46), kw_end_DASH_line, int(7451), kw_end_DASH_column, int(72))
									tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp20 := lang.Apply(tmp16, []any{tmp19, v10})
									tmp15 = tmp20
								} else {
									tmp15 = v14
								}
								tmp12 = tmp15
							} // end let
							tmp13 := lang.Apply(tmp11, []any{tmp12})
							return tmp13
						}
					})
					v6 = tmp5
					_ = v6
				}
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7445), kw_column, int(6), kw_end_DASH_line, int(7451), kw_end_DASH_column, int(82))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "ps"
					tmp7 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
					tmp8 := lang.Apply(tmp7, []any{v2, v3, v4, v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 lang.FnFunc
					{ // function epn
						var v11 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								return true
							case 1:
								v12 := args[0]
								_ = v12
								tmp13 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
								var tmp14 lang.FnFunc
								tmp14 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v15 := args[0]
									_ = v15
									tmp16 := lang.Apply(v15, []any{v12})
									return tmp16
								})
								tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7456), kw_column, int(23), kw_end_DASH_line, int(7456), kw_end_DASH_column, int(28))
								tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp17 := lang.Apply(tmp13, []any{tmp16, v9})
								return tmp17
							case 2:
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								tmp14 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
								var tmp15 lang.FnFunc
								tmp15 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v16 := args[0]
									_ = v16
									var tmp17 any
									{ // let
										// let binding "and__0__auto__"
										tmp18 := lang.Apply(v16, []any{v12})
										var v19 any = tmp18
										_ = v19
										var tmp20 any
										if lang.IsTruthy(v19) {
											tmp21 := lang.Apply(v16, []any{v13})
											tmp20 = tmp21
										} else {
											tmp20 = v19
										}
										tmp17 = tmp20
									} // end let
									return tmp17
								})
								tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7457), kw_column, int(25), kw_end_DASH_line, int(7457), kw_end_DASH_column, int(42))
								tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp18 := lang.Apply(tmp14, []any{tmp17, v9})
								return tmp18
							case 3:
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								v14 := args[2]
								_ = v14
								tmp15 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
								var tmp16 lang.FnFunc
								tmp16 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v17 := args[0]
									_ = v17
									var tmp18 any
									{ // let
										// let binding "and__0__auto__"
										tmp19 := lang.Apply(v17, []any{v12})
										var v20 any = tmp19
										_ = v20
										var tmp21 any
										if lang.IsTruthy(v20) {
											var tmp22 any
											{ // let
												// let binding "and__0__auto__"
												tmp23 := lang.Apply(v17, []any{v13})
												var v24 any = tmp23
												_ = v24
												var tmp25 any
												if lang.IsTruthy(v24) {
													tmp26 := lang.Apply(v17, []any{v14})
													tmp25 = tmp26
												} else {
													tmp25 = v24
												}
												tmp22 = tmp25
											} // end let
											tmp21 = tmp22
										} else {
											tmp21 = v20
										}
										tmp18 = tmp21
									} // end let
									return tmp18
								})
								tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7458), kw_column, int(27), kw_end_DASH_line, int(7458), kw_end_DASH_column, int(50))
								tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp19 := lang.Apply(tmp15, []any{tmp18, v9})
								return tmp19
							default:
								checkArityGTE(args, 3)
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								v14 := args[2]
								_ = v14
								var v15 any = lang.NewList(args[3:]...)
								_ = v15
								tmp16 := checkDerefVar(var_glojure_DOT_core_boolean)
								var tmp17 any
								{ // let
									// let binding "and__0__auto__"
									tmp18 := lang.Apply(v11, []any{v12, v13, v14})
									var v19 any = tmp18
									_ = v19
									var tmp20 any
									if lang.IsTruthy(v19) {
										tmp21 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
										var tmp22 lang.FnFunc
										tmp22 = lang.NewFnFunc(func(args ...any) any {
											checkArity(args, 1)
											v23 := args[0]
											_ = v23
											tmp24 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
											tmp25 := lang.Apply(tmp24, []any{v23, v15})
											return tmp25
										})
										tmp23 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7460), kw_column, int(48), kw_end_DASH_line, int(7460), kw_end_DASH_column, int(63))
										tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp25 := lang.Apply(tmp21, []any{tmp24, v9})
										tmp20 = tmp25
									} else {
										tmp20 = v19
									}
									tmp17 = tmp20
								} // end let
								tmp18 := lang.Apply(tmp16, []any{tmp17})
								return tmp18
							}
						})
						v11 = tmp10
						_ = v11
					}
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7454), kw_column, int(8), kw_end_DASH_line, int(7460), kw_end_DASH_column, int(71))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp6 = tmp12
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_every_DASH_pred = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_every_DASH_pred.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-info
	{
		tmp0 := sym_ex_DASH_info.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_msg, sym_map), lang.NewVector(sym_msg, sym_map, sym_cause)), kw_doc, "Create an instance of ExceptionInfo, a RuntimeException subclass\n   that carries a map of additional data.", kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4803), kw_end_DASH_line, int(4803))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_elide_DASH_top_DASH_frames)
				tmp5 := lang.Apply(nil, []any{v2, v3})
				tmp6 := lang.Apply(tmp4, []any{tmp5, "glojure.core$ex_info"})
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_elide_DASH_top_DASH_frames)
				tmp6 := lang.Apply(nil, []any{v2, v3, v4})
				tmp7 := lang.Apply(tmp5, []any{tmp6, "glojure.core$ex_info"})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ex_DASH_info = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ex_DASH_info.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filter
	{
		tmp0 := sym_filter.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred), lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2785), kw_end_DASH_line, int(2785))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp6 := lang.Apply(v4, nil)
							return tmp6
						case 1:
							v6 := args[0]
							_ = v6
							tmp7 := lang.Apply(v4, []any{v6})
							return tmp7
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							var tmp8 any
							tmp9 := lang.Apply(v2, []any{v7})
							if lang.IsTruthy(tmp9) {
								tmp10 := lang.Apply(v4, []any{v6, v7})
								tmp8 = tmp10
							} else {
								tmp8 = v6
							}
							return tmp8
						default:
							checkArity(args, -1)
							panic("unreachable")
						}
					})
					tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2793), kw_column, int(7), kw_end_DASH_line, int(2799), kw_end_DASH_column, int(22))
					tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp7
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2792), kw_column, int(5), kw_end_DASH_line, int(2799), kw_end_DASH_column, int(23))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp5 any
					{ // let
						// let binding "temp__0__auto__"
						tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp7 := lang.Apply(tmp6, []any{v3})
						var v8 any = tmp7
						_ = v8
						var tmp9 any
						if lang.IsTruthy(v8) {
							var tmp10 any
							{ // let
								// let binding "s"
								var v11 any = v8
								_ = v11
								var tmp12 any
								tmp13 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
								tmp14 := lang.Apply(tmp13, []any{v11})
								if lang.IsTruthy(tmp14) {
									var tmp15 any
									{ // let
										// let binding "c"
										tmp16 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
										tmp17 := lang.Apply(tmp16, []any{v11})
										var v18 any = tmp17
										_ = v18
										// let binding "size"
										tmp19 := checkDerefVar(var_glojure_DOT_core_count)
										tmp20 := lang.Apply(tmp19, []any{v18})
										var v21 any = tmp20
										_ = v21
										// let binding "b"
										tmp22 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_buffer)
										tmp23 := lang.Apply(tmp22, []any{v21})
										var v24 any = tmp23
										_ = v24
										var tmp25 any
										{ // let
											// let binding "n__0__auto__"
											tmp26 := lang.Apply(lang.LongCast, []any{v21})
											var v27 any = tmp26
											_ = v27
											var tmp28 any
											{ // let
												// let binding "i"
												var v29 any = int64(0)
												_ = v29
												for {
													var tmp30 any
													tmp31 := checkDerefVar(var_glojure_DOT_core__LT_)
													tmp32 := lang.Apply(tmp31, []any{v29, v27})
													if lang.IsTruthy(tmp32) {
														var tmp33 any
														{ // let
															// let binding "v"
															tmp34, _ := lang.FieldOrMethod(v18, "nth")
															if reflect.TypeOf(tmp34).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp35 := lang.Apply(tmp34, []any{v29})
															var v36 any = tmp35
															_ = v36
															var tmp37 any
															tmp38 := lang.Apply(v2, []any{v36})
															if lang.IsTruthy(tmp38) {
																tmp39 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_append)
																tmp40 := lang.Apply(tmp39, []any{v24, v36})
																tmp37 = tmp40
															} else {
															}
															tmp33 = tmp37
														} // end let
														_ = tmp33
														tmp35 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
														tmp36 := lang.Apply(tmp35, []any{v29})
														var tmp34 any = tmp36
														v29 = tmp34
														continue
													} else {
													}
													tmp28 = tmp30
													break
												}
											} // end let
											tmp25 = tmp28
										} // end let
										_ = tmp25
										tmp26 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
										tmp27 := checkDerefVar(var_glojure_DOT_core_chunk)
										tmp28 := lang.Apply(tmp27, []any{v24})
										tmp29 := checkDerefVar(var_glojure_DOT_core_filter)
										tmp30 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
										tmp31 := lang.Apply(tmp30, []any{v11})
										tmp32 := lang.Apply(tmp29, []any{v2, tmp31})
										tmp33 := lang.Apply(tmp26, []any{tmp28, tmp32})
										tmp15 = tmp33
									} // end let
									tmp12 = tmp15
								} else {
									var tmp16 any
									{ // let
										// let binding "f"
										tmp17 := checkDerefVar(var_glojure_DOT_core_first)
										tmp18 := lang.Apply(tmp17, []any{v11})
										var v19 any = tmp18
										_ = v19
										// let binding "r"
										tmp20 := checkDerefVar(var_glojure_DOT_core_rest)
										tmp21 := lang.Apply(tmp20, []any{v11})
										var v22 any = tmp21
										_ = v22
										var tmp23 any
										tmp24 := lang.Apply(v2, []any{v19})
										if lang.IsTruthy(tmp24) {
											tmp25 := checkDerefVar(var_glojure_DOT_core_cons)
											tmp26 := checkDerefVar(var_glojure_DOT_core_filter)
											tmp27 := lang.Apply(tmp26, []any{v2, v22})
											tmp28 := lang.Apply(tmp25, []any{v19, tmp27})
											tmp23 = tmp28
										} else {
											tmp29 := checkDerefVar(var_glojure_DOT_core_filter)
											tmp30 := lang.Apply(tmp29, []any{v2, v22})
											tmp23 = tmp30
										}
										tmp16 = tmp23
									} // end let
									tmp12 = tmp16
								}
								tmp10 = tmp12
							} // end let
							tmp9 = tmp10
						} else {
						}
						tmp5 = tmp9
					} // end let
					return tmp5
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_filter = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_filter.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fnil
	{
		tmp0 := sym_fnil.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_x), lang.NewVector(sym_f, sym_x, sym_y), lang.NewVector(sym_f, sym_x, sym_y, sym_z)), kw_doc, "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6558), kw_end_DASH_line, int(6558))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 1:
						v5 := args[0]
						_ = v5
						var tmp6 any
						tmp7 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp8 := lang.Apply(tmp7, []any{v5})
						if lang.IsTruthy(tmp8) {
							tmp6 = v3
						} else {
							tmp6 = v5
						}
						tmp9 := lang.Apply(v2, []any{tmp6})
						return tmp9
					case 2:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						var tmp7 any
						tmp8 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp9 := lang.Apply(tmp8, []any{v5})
						if lang.IsTruthy(tmp9) {
							tmp7 = v3
						} else {
							tmp7 = v5
						}
						tmp10 := lang.Apply(v2, []any{tmp7, v6})
						return tmp10
					case 3:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						var tmp8 any
						tmp9 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp10 := lang.Apply(tmp9, []any{v5})
						if lang.IsTruthy(tmp10) {
							tmp8 = v3
						} else {
							tmp8 = v5
						}
						tmp11 := lang.Apply(v2, []any{tmp8, v6, v7})
						return tmp11
					default:
						checkArityGTE(args, 3)
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						var v8 any = lang.NewList(args[3:]...)
						_ = v8
						tmp9 := checkDerefVar(var_glojure_DOT_core_apply)
						var tmp10 any
						tmp11 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v5})
						if lang.IsTruthy(tmp12) {
							tmp10 = v3
						} else {
							tmp10 = v5
						}
						tmp13 := lang.Apply(tmp9, []any{v2, tmp10, v6, v7, v8})
						return tmp13
					}
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6567), kw_column, int(4), kw_end_DASH_line, int(6571), kw_end_DASH_column, int(55))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						var tmp8 any
						tmp9 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp10 := lang.Apply(tmp9, []any{v6})
						if lang.IsTruthy(tmp10) {
							tmp8 = v3
						} else {
							tmp8 = v6
						}
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v7})
						if lang.IsTruthy(tmp13) {
							tmp11 = v4
						} else {
							tmp11 = v7
						}
						tmp14 := lang.Apply(v2, []any{tmp8, tmp11})
						return tmp14
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var tmp9 any
						tmp10 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v6})
						if lang.IsTruthy(tmp11) {
							tmp9 = v3
						} else {
							tmp9 = v6
						}
						var tmp12 any
						tmp13 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v7})
						if lang.IsTruthy(tmp14) {
							tmp12 = v4
						} else {
							tmp12 = v7
						}
						tmp15 := lang.Apply(v2, []any{tmp9, tmp12, v8})
						return tmp15
					default:
						checkArityGTE(args, 3)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v6})
						if lang.IsTruthy(tmp13) {
							tmp11 = v3
						} else {
							tmp11 = v6
						}
						var tmp14 any
						tmp15 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp16 := lang.Apply(tmp15, []any{v7})
						if lang.IsTruthy(tmp16) {
							tmp14 = v4
						} else {
							tmp14 = v7
						}
						tmp17 := lang.Apply(tmp10, []any{v2, tmp11, tmp14, v8, v9})
						return tmp17
					}
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6573), kw_column, int(4), kw_end_DASH_line, int(6576), kw_end_DASH_column, int(71))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						var tmp9 any
						tmp10 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v7})
						if lang.IsTruthy(tmp11) {
							tmp9 = v3
						} else {
							tmp9 = v7
						}
						var tmp12 any
						tmp13 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v8})
						if lang.IsTruthy(tmp14) {
							tmp12 = v4
						} else {
							tmp12 = v8
						}
						tmp15 := lang.Apply(v2, []any{tmp9, tmp12})
						return tmp15
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var tmp10 any
						tmp11 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v7})
						if lang.IsTruthy(tmp12) {
							tmp10 = v3
						} else {
							tmp10 = v7
						}
						var tmp13 any
						tmp14 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp15 := lang.Apply(tmp14, []any{v8})
						if lang.IsTruthy(tmp15) {
							tmp13 = v4
						} else {
							tmp13 = v8
						}
						var tmp16 any
						tmp17 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp18 := lang.Apply(tmp17, []any{v9})
						if lang.IsTruthy(tmp18) {
							tmp16 = v5
						} else {
							tmp16 = v9
						}
						tmp19 := lang.Apply(v2, []any{tmp10, tmp13, tmp16})
						return tmp19
					default:
						checkArityGTE(args, 3)
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
						var tmp12 any
						tmp13 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v7})
						if lang.IsTruthy(tmp14) {
							tmp12 = v3
						} else {
							tmp12 = v7
						}
						var tmp15 any
						tmp16 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp17 := lang.Apply(tmp16, []any{v8})
						if lang.IsTruthy(tmp17) {
							tmp15 = v4
						} else {
							tmp15 = v8
						}
						var tmp18 any
						tmp19 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp20 := lang.Apply(tmp19, []any{v9})
						if lang.IsTruthy(tmp20) {
							tmp18 = v5
						} else {
							tmp18 = v9
						}
						tmp21 := lang.Apply(tmp11, []any{v2, tmp12, tmp15, tmp18, v10})
						return tmp21
					}
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6578), kw_column, int(4), kw_end_DASH_line, int(6581), kw_end_DASH_column, int(87))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_fnil = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_fnil.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// format
	{
		tmp0 := sym_format.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_fmt, sym__AMP_, sym_args)), kw_doc, "Formats a string using java.lang.String.format, see java.util.Formatter for format\n  string syntax", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5717), kw_end_DASH_line, int(5717))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp5 := lang.Apply(tmp4, []any{fmt.Sprintf, v2, v3})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_format = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_format.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future
	{
		tmp0 := sym_future.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Takes a body of expressions and yields a future object that will\n  invoke the body in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant of\n  deref with timeout is used. See also - realized?.", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(7009), kw_end_DASH_line, int(7009))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_glojure_DOT_core_SLASH_future_DASH_call})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp11 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{sym_fn_STAR_})
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp16 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp19 := lang.Apply(tmp18, nil)
				tmp20 := lang.Apply(tmp17, []any{tmp19})
				tmp21 := lang.Apply(tmp15, []any{tmp16, tmp20})
				tmp22 := lang.Apply(tmp14, []any{tmp21})
				tmp23 := lang.Apply(tmp11, []any{tmp13, tmp22, v4})
				tmp24 := lang.Apply(tmp10, []any{tmp23})
				tmp25 := lang.Apply(tmp9, []any{tmp24})
				tmp26 := lang.Apply(tmp6, []any{tmp8, tmp25})
				tmp27 := lang.Apply(tmp5, []any{tmp26})
				return tmp27
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_future = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_future.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-call
	{
		tmp0 := sym_future_DASH_call.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Takes a function of no args and yields a future object that will\n  invoke the function in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant\n  of deref with timeout is used. See also - realized?.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(7003), kw_end_DASH_line, int(7003))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "f"
				tmp4 := checkDerefVar(var_glojure_DOT_core_binding_DASH_conveyor_DASH_fn)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				// let binding "fut"
				tmp7 := lang.Apply(lang.AgentSubmit, []any{v6})
				var v8 any = tmp7
				_ = v8
				tmp3 = v8
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_future_DASH_call = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_future_DASH_call.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-in
	{
		tmp0 := sym_get_DASH_in.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_ks), lang.NewVector(sym_m, sym_ks, sym_not_DASH_found)), kw_doc, "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key\n  is not present, or the not-found value if supplied.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6128), kw_end_DASH_line, int(6128))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp5 := checkDerefVar(var_glojure_DOT_core_get)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v2, v3})
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "sentinel"
					tmp6 := lang.Apply(reflect.StructOf, []any{nil})
					tmp7 := lang.Apply(reflect.New, []any{tmp6})
					tmp8, ok := lang.FieldOrMethod(tmp7, "Interface")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp7, "Interface")))
					}
					var tmp9 any
					switch reflect.TypeOf(tmp8).Kind() {
					case reflect.Func:
						tmp9 = lang.Apply(tmp8, nil)
					default:
						tmp9 = tmp8
					}
					var v10 any = tmp9
					_ = v10
					// let binding "m"
					var v11 any = v2
					_ = v11
					// let binding "ks"
					tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp13 := lang.Apply(tmp12, []any{v3})
					var v14 any = tmp13
					_ = v14
					for {
						var tmp15 any
						if lang.IsTruthy(v14) {
							var tmp16 any
							{ // let
								// let binding "m"
								tmp17 := checkDerefVar(var_glojure_DOT_core_get)
								tmp18 := checkDerefVar(var_glojure_DOT_core_first)
								tmp19 := lang.Apply(tmp18, []any{v14})
								tmp20 := lang.Apply(tmp17, []any{v11, tmp19, v10})
								var v21 any = tmp20
								_ = v21
								var tmp22 any
								tmp23 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
								tmp24 := lang.Apply(tmp23, []any{v10, v21})
								if lang.IsTruthy(tmp24) {
									tmp22 = v4
								} else {
									var tmp25 any = v10
									var tmp26 any = v21
									tmp28 := checkDerefVar(var_glojure_DOT_core_next)
									tmp29 := lang.Apply(tmp28, []any{v14})
									var tmp27 any = tmp29
									v10 = tmp25
									v11 = tmp26
									v14 = tmp27
									continue
								}
								tmp16 = tmp22
							} // end let
							tmp15 = tmp16
						} else {
							tmp15 = v11
						}
						tmp5 = tmp15
						break
					}
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_get_DASH_in = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_get_DASH_in.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-let
	{
		tmp0 := sym_if_DASH_let.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym_then), lang.NewVector(sym_bindings, sym_then, sym_else, sym__AMP_, sym_oldform)), kw_doc, "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(1839), kw_end_DASH_line, int(1839))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_if_DASH_let})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v5})
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{nil})
				tmp16 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp13, tmp15})
				tmp17 := lang.Apply(tmp6, []any{tmp16})
				return tmp17
			default:
				checkArityGTE(args, 5)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				var v7 any = lang.NewList(args[5:]...)
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v4})
				if lang.IsTruthy(tmp10) {
				} else {
					tmp11 := checkDerefVar(var_glojure_DOT_core_str)
					tmp12 := checkDerefVar(var_glojure_DOT_core_first)
					tmp13 := lang.Apply(tmp12, []any{v2})
					tmp14 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp15 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp16 := lang.Apply(tmp15, []any{v2})
					tmp17 := lang.Apply(kw_line, []any{tmp16})
					tmp18 := lang.Apply(tmp11, []any{tmp13, " requires ", "a vector for its binding", " in ", tmp14, ":", tmp17})
					tmp19 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp18})
					panic(tmp19)
				}
				_ = tmp8
				var tmp20 any
				tmp21 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
				tmp22 := lang.Apply(tmp21, []any{v7})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "1 or 2 forms after binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp20
				var tmp32 any
				tmp33 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp34 := checkDerefVar(var_glojure_DOT_core_count)
				tmp35 := lang.Apply(tmp34, []any{v4})
				tmp36 := lang.Apply(tmp33, []any{int64(2), tmp35})
				if lang.IsTruthy(tmp36) {
				} else {
					tmp37 := checkDerefVar(var_glojure_DOT_core_str)
					tmp38 := checkDerefVar(var_glojure_DOT_core_first)
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp41 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp42 := lang.Apply(tmp41, []any{v2})
					tmp43 := lang.Apply(kw_line, []any{tmp42})
					tmp44 := lang.Apply(tmp37, []any{tmp39, " requires ", "exactly 2 forms in binding vector", " in ", tmp40, ":", tmp43})
					tmp45 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp44})
					panic(tmp45)
				}
				_ = tmp32
				var tmp46 any
				{ // let
					// let binding "form"
					tmp47 := lang.Apply(v4, []any{int64(0)})
					var v48 any = tmp47
					_ = v48
					// let binding "tst"
					tmp49 := lang.Apply(v4, []any{int64(1)})
					var v50 any = tmp49
					_ = v50
					tmp51 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp52 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp53 := checkDerefVar(var_glojure_DOT_core_list)
					tmp54 := lang.Apply(tmp53, []any{sym_glojure_DOT_core_SLASH_let})
					tmp55 := checkDerefVar(var_glojure_DOT_core_list)
					tmp56 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp57 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp58 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp59 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp60 := checkDerefVar(var_glojure_DOT_core_list)
					tmp61 := lang.Apply(tmp60, []any{sym_temp__0__auto__})
					tmp62 := checkDerefVar(var_glojure_DOT_core_list)
					tmp63 := lang.Apply(tmp62, []any{v50})
					tmp64 := lang.Apply(tmp59, []any{tmp61, tmp63})
					tmp65 := lang.Apply(tmp58, []any{tmp64})
					tmp66 := lang.Apply(tmp56, []any{tmp57, tmp65})
					tmp67 := lang.Apply(tmp55, []any{tmp66})
					tmp68 := checkDerefVar(var_glojure_DOT_core_list)
					tmp69 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp70 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp71 := checkDerefVar(var_glojure_DOT_core_list)
					tmp72 := lang.Apply(tmp71, []any{sym_if})
					tmp73 := checkDerefVar(var_glojure_DOT_core_list)
					tmp74 := lang.Apply(tmp73, []any{sym_temp__0__auto__})
					tmp75 := checkDerefVar(var_glojure_DOT_core_list)
					tmp76 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp77 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp78 := checkDerefVar(var_glojure_DOT_core_list)
					tmp79 := lang.Apply(tmp78, []any{sym_glojure_DOT_core_SLASH_let})
					tmp80 := checkDerefVar(var_glojure_DOT_core_list)
					tmp81 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp82 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp83 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp84 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp85 := checkDerefVar(var_glojure_DOT_core_list)
					tmp86 := lang.Apply(tmp85, []any{v48})
					tmp87 := checkDerefVar(var_glojure_DOT_core_list)
					tmp88 := lang.Apply(tmp87, []any{sym_temp__0__auto__})
					tmp89 := lang.Apply(tmp84, []any{tmp86, tmp88})
					tmp90 := lang.Apply(tmp83, []any{tmp89})
					tmp91 := lang.Apply(tmp81, []any{tmp82, tmp90})
					tmp92 := lang.Apply(tmp80, []any{tmp91})
					tmp93 := checkDerefVar(var_glojure_DOT_core_list)
					tmp94 := lang.Apply(tmp93, []any{v5})
					tmp95 := lang.Apply(tmp77, []any{tmp79, tmp92, tmp94})
					tmp96 := lang.Apply(tmp76, []any{tmp95})
					tmp97 := lang.Apply(tmp75, []any{tmp96})
					tmp98 := checkDerefVar(var_glojure_DOT_core_list)
					tmp99 := lang.Apply(tmp98, []any{v6})
					tmp100 := lang.Apply(tmp70, []any{tmp72, tmp74, tmp97, tmp99})
					tmp101 := lang.Apply(tmp69, []any{tmp100})
					tmp102 := lang.Apply(tmp68, []any{tmp101})
					tmp103 := lang.Apply(tmp52, []any{tmp54, tmp67, tmp102})
					tmp104 := lang.Apply(tmp51, []any{tmp103})
					tmp46 = tmp104
				} // end let
				return tmp46
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_if_DASH_let = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_if_DASH_let.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-some
	{
		tmp0 := sym_if_DASH_some.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym_then), lang.NewVector(sym_bindings, sym_then, sym_else, sym__AMP_, sym_oldform)), kw_doc, "bindings => binding-form test\n\n   If test is not nil, evaluates then with binding-form bound to the\n   value of test, if not, yields else", kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(1874), kw_end_DASH_line, int(1874))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_if_DASH_some})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v5})
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{nil})
				tmp16 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp13, tmp15})
				tmp17 := lang.Apply(tmp6, []any{tmp16})
				return tmp17
			default:
				checkArityGTE(args, 5)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				var v7 any = lang.NewList(args[5:]...)
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v4})
				if lang.IsTruthy(tmp10) {
				} else {
					tmp11 := checkDerefVar(var_glojure_DOT_core_str)
					tmp12 := checkDerefVar(var_glojure_DOT_core_first)
					tmp13 := lang.Apply(tmp12, []any{v2})
					tmp14 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp15 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp16 := lang.Apply(tmp15, []any{v2})
					tmp17 := lang.Apply(kw_line, []any{tmp16})
					tmp18 := lang.Apply(tmp11, []any{tmp13, " requires ", "a vector for its binding", " in ", tmp14, ":", tmp17})
					tmp19 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp18})
					panic(tmp19)
				}
				_ = tmp8
				var tmp20 any
				tmp21 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
				tmp22 := lang.Apply(tmp21, []any{v7})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "1 or 2 forms after binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp20
				var tmp32 any
				tmp33 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp34 := checkDerefVar(var_glojure_DOT_core_count)
				tmp35 := lang.Apply(tmp34, []any{v4})
				tmp36 := lang.Apply(tmp33, []any{int64(2), tmp35})
				if lang.IsTruthy(tmp36) {
				} else {
					tmp37 := checkDerefVar(var_glojure_DOT_core_str)
					tmp38 := checkDerefVar(var_glojure_DOT_core_first)
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp41 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp42 := lang.Apply(tmp41, []any{v2})
					tmp43 := lang.Apply(kw_line, []any{tmp42})
					tmp44 := lang.Apply(tmp37, []any{tmp39, " requires ", "exactly 2 forms in binding vector", " in ", tmp40, ":", tmp43})
					tmp45 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp44})
					panic(tmp45)
				}
				_ = tmp32
				var tmp46 any
				{ // let
					// let binding "form"
					tmp47 := lang.Apply(v4, []any{int64(0)})
					var v48 any = tmp47
					_ = v48
					// let binding "tst"
					tmp49 := lang.Apply(v4, []any{int64(1)})
					var v50 any = tmp49
					_ = v50
					tmp51 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp52 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp53 := checkDerefVar(var_glojure_DOT_core_list)
					tmp54 := lang.Apply(tmp53, []any{sym_glojure_DOT_core_SLASH_let})
					tmp55 := checkDerefVar(var_glojure_DOT_core_list)
					tmp56 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp57 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp58 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp59 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp60 := checkDerefVar(var_glojure_DOT_core_list)
					tmp61 := lang.Apply(tmp60, []any{sym_temp__0__auto__})
					tmp62 := checkDerefVar(var_glojure_DOT_core_list)
					tmp63 := lang.Apply(tmp62, []any{v50})
					tmp64 := lang.Apply(tmp59, []any{tmp61, tmp63})
					tmp65 := lang.Apply(tmp58, []any{tmp64})
					tmp66 := lang.Apply(tmp56, []any{tmp57, tmp65})
					tmp67 := lang.Apply(tmp55, []any{tmp66})
					tmp68 := checkDerefVar(var_glojure_DOT_core_list)
					tmp69 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp70 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp71 := checkDerefVar(var_glojure_DOT_core_list)
					tmp72 := lang.Apply(tmp71, []any{sym_if})
					tmp73 := checkDerefVar(var_glojure_DOT_core_list)
					tmp74 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp75 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp76 := checkDerefVar(var_glojure_DOT_core_list)
					tmp77 := lang.Apply(tmp76, []any{sym_glojure_DOT_core_SLASH_nil_QMARK_})
					tmp78 := checkDerefVar(var_glojure_DOT_core_list)
					tmp79 := lang.Apply(tmp78, []any{sym_temp__0__auto__})
					tmp80 := lang.Apply(tmp75, []any{tmp77, tmp79})
					tmp81 := lang.Apply(tmp74, []any{tmp80})
					tmp82 := lang.Apply(tmp73, []any{tmp81})
					tmp83 := checkDerefVar(var_glojure_DOT_core_list)
					tmp84 := lang.Apply(tmp83, []any{v6})
					tmp85 := checkDerefVar(var_glojure_DOT_core_list)
					tmp86 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp87 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp88 := checkDerefVar(var_glojure_DOT_core_list)
					tmp89 := lang.Apply(tmp88, []any{sym_glojure_DOT_core_SLASH_let})
					tmp90 := checkDerefVar(var_glojure_DOT_core_list)
					tmp91 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp92 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp93 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp94 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp95 := checkDerefVar(var_glojure_DOT_core_list)
					tmp96 := lang.Apply(tmp95, []any{v48})
					tmp97 := checkDerefVar(var_glojure_DOT_core_list)
					tmp98 := lang.Apply(tmp97, []any{sym_temp__0__auto__})
					tmp99 := lang.Apply(tmp94, []any{tmp96, tmp98})
					tmp100 := lang.Apply(tmp93, []any{tmp99})
					tmp101 := lang.Apply(tmp91, []any{tmp92, tmp100})
					tmp102 := lang.Apply(tmp90, []any{tmp101})
					tmp103 := checkDerefVar(var_glojure_DOT_core_list)
					tmp104 := lang.Apply(tmp103, []any{v5})
					tmp105 := lang.Apply(tmp87, []any{tmp89, tmp102, tmp104})
					tmp106 := lang.Apply(tmp86, []any{tmp105})
					tmp107 := lang.Apply(tmp85, []any{tmp106})
					tmp108 := lang.Apply(tmp70, []any{tmp72, tmp82, tmp84, tmp107})
					tmp109 := lang.Apply(tmp69, []any{tmp108})
					tmp110 := lang.Apply(tmp68, []any{tmp109})
					tmp111 := lang.Apply(tmp52, []any{tmp54, tmp67, tmp110})
					tmp112 := lang.Apply(tmp51, []any{tmp111})
					tmp46 = tmp112
				} // end let
				return tmp46
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_if_DASH_some = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_if_DASH_some.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into1
	{
		tmp0 := sym_into1.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_to, sym_from)), kw_doc, "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(3416), kw_end_DASH_line, int(3416), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp6 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
			tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
				tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp10 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
				tmp11 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp12 := lang.Apply(tmp11, []any{v2})
				tmp13 := lang.Apply(tmp9, []any{tmp10, tmp12, v3})
				tmp14 := lang.Apply(tmp8, []any{tmp13})
				tmp4 = tmp14
			} else {
				tmp15 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp16 := checkDerefVar(var_glojure_DOT_core_conj)
				tmp17 := lang.Apply(tmp15, []any{tmp16, v2, v3})
				tmp4 = tmp17
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_into1 = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_into1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// juxt
	{
		tmp0 := sym_juxt.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_g), lang.NewVector(sym_f, sym_g, sym_h), lang.NewVector(sym_f, sym_g, sym_h, sym__AMP_, sym_fs)), kw_doc, "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2568), kw_end_DASH_line, int(2568))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp4 := lang.Apply(v2, nil)
						tmp5 := lang.NewVector(tmp4)
						tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2578), kw_column, int(12), kw_end_DASH_line, int(2578), kw_end_DASH_column, int(16))
						tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp7
					case 1:
						v4 := args[0]
						_ = v4
						tmp5 := lang.Apply(v2, []any{v4})
						tmp6 := lang.NewVector(tmp5)
						tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2579), kw_column, int(13), kw_end_DASH_line, int(2579), kw_end_DASH_column, int(19))
						tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp8
					case 2:
						v4 := args[0]
						_ = v4
						v5 := args[1]
						_ = v5
						tmp6 := lang.Apply(v2, []any{v4, v5})
						tmp7 := lang.NewVector(tmp6)
						tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2580), kw_column, int(15), kw_end_DASH_line, int(2580), kw_end_DASH_column, int(23))
						tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp9
					case 3:
						v4 := args[0]
						_ = v4
						v5 := args[1]
						_ = v5
						v6 := args[2]
						_ = v6
						tmp7 := lang.Apply(v2, []any{v4, v5, v6})
						tmp8 := lang.NewVector(tmp7)
						tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2581), kw_column, int(17), kw_end_DASH_line, int(2581), kw_end_DASH_column, int(27))
						tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp10
					default:
						checkArityGTE(args, 3)
						v4 := args[0]
						_ = v4
						v5 := args[1]
						_ = v5
						v6 := args[2]
						_ = v6
						var v7 any = lang.NewList(args[3:]...)
						_ = v7
						tmp8 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp9 := lang.Apply(tmp8, []any{v2, v4, v5, v6, v7})
						tmp10 := lang.NewVector(tmp9)
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2582), kw_column, int(24), kw_end_DASH_line, int(2582), kw_end_DASH_column, int(45))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp12
					}
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2577), kw_column, int(6), kw_end_DASH_line, int(2582), kw_end_DASH_column, int(47))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp5 := lang.Apply(v2, nil)
						tmp6 := lang.Apply(v3, nil)
						tmp7 := lang.NewVector(tmp5, tmp6)
						tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2585), kw_column, int(12), kw_end_DASH_line, int(2585), kw_end_DASH_column, int(20))
						tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp9
					case 1:
						v5 := args[0]
						_ = v5
						tmp6 := lang.Apply(v2, []any{v5})
						tmp7 := lang.Apply(v3, []any{v5})
						tmp8 := lang.NewVector(tmp6, tmp7)
						tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2586), kw_column, int(13), kw_end_DASH_line, int(2586), kw_end_DASH_column, int(25))
						tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp10
					case 2:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						tmp7 := lang.Apply(v2, []any{v5, v6})
						tmp8 := lang.Apply(v3, []any{v5, v6})
						tmp9 := lang.NewVector(tmp7, tmp8)
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2587), kw_column, int(15), kw_end_DASH_line, int(2587), kw_end_DASH_column, int(31))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp11
					case 3:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						tmp8 := lang.Apply(v2, []any{v5, v6, v7})
						tmp9 := lang.Apply(v3, []any{v5, v6, v7})
						tmp10 := lang.NewVector(tmp8, tmp9)
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2588), kw_column, int(17), kw_end_DASH_line, int(2588), kw_end_DASH_column, int(37))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp12
					default:
						checkArityGTE(args, 3)
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						var v8 any = lang.NewList(args[3:]...)
						_ = v8
						tmp9 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp10 := lang.Apply(tmp9, []any{v2, v5, v6, v7, v8})
						tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp12 := lang.Apply(tmp11, []any{v3, v5, v6, v7, v8})
						tmp13 := lang.NewVector(tmp10, tmp12)
						tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2589), kw_column, int(24), kw_end_DASH_line, int(2589), kw_end_DASH_column, int(66))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp15
					}
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2584), kw_column, int(6), kw_end_DASH_line, int(2589), kw_end_DASH_column, int(68))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v2, nil)
						tmp7 := lang.Apply(v3, nil)
						tmp8 := lang.Apply(v4, nil)
						tmp9 := lang.NewVector(tmp6, tmp7, tmp8)
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2592), kw_column, int(12), kw_end_DASH_line, int(2592), kw_end_DASH_column, int(24))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp11
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v2, []any{v6})
						tmp8 := lang.Apply(v3, []any{v6})
						tmp9 := lang.Apply(v4, []any{v6})
						tmp10 := lang.NewVector(tmp7, tmp8, tmp9)
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2593), kw_column, int(13), kw_end_DASH_line, int(2593), kw_end_DASH_column, int(31))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp12
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v2, []any{v6, v7})
						tmp9 := lang.Apply(v3, []any{v6, v7})
						tmp10 := lang.Apply(v4, []any{v6, v7})
						tmp11 := lang.NewVector(tmp8, tmp9, tmp10)
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2594), kw_column, int(15), kw_end_DASH_line, int(2594), kw_end_DASH_column, int(39))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp13
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						tmp9 := lang.Apply(v2, []any{v6, v7, v8})
						tmp10 := lang.Apply(v3, []any{v6, v7, v8})
						tmp11 := lang.Apply(v4, []any{v6, v7, v8})
						tmp12 := lang.NewVector(tmp9, tmp10, tmp11)
						tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2595), kw_column, int(17), kw_end_DASH_line, int(2595), kw_end_DASH_column, int(47))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp14
					default:
						checkArityGTE(args, 3)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp11 := lang.Apply(tmp10, []any{v2, v6, v7, v8, v9})
						tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp13 := lang.Apply(tmp12, []any{v3, v6, v7, v8, v9})
						tmp14 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp15 := lang.Apply(tmp14, []any{v4, v6, v7, v8, v9})
						tmp16 := lang.NewVector(tmp11, tmp13, tmp15)
						tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2596), kw_column, int(24), kw_end_DASH_line, int(2596), kw_end_DASH_column, int(87))
						tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp18
					}
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2591), kw_column, int(6), kw_end_DASH_line, int(2596), kw_end_DASH_column, int(89))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "fs"
					tmp7 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
					tmp8 := lang.Apply(tmp7, []any{v2, v3, v4, v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp11 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp12 lang.FnFunc
							tmp12 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								tmp15 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp16 := lang.Apply(v14, nil)
								tmp17 := lang.Apply(tmp15, []any{v13, tmp16})
								return tmp17
							})
							tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2600), kw_column, int(23), kw_end_DASH_line, int(2600), kw_end_DASH_column, int(37))
							tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp15 := lang.NewVector()
							tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2600), kw_column, int(39), kw_end_DASH_line, int(2600), kw_end_DASH_column, int(40))
							tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp18 := lang.Apply(tmp11, []any{tmp14, tmp17, v9})
							return tmp18
						case 1:
							v11 := args[0]
							_ = v11
							tmp12 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp13 lang.FnFunc
							tmp13 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v14 := args[0]
								_ = v14
								v15 := args[1]
								_ = v15
								tmp16 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp17 := lang.Apply(v15, []any{v11})
								tmp18 := lang.Apply(tmp16, []any{v14, tmp17})
								return tmp18
							})
							tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2601), kw_column, int(24), kw_end_DASH_line, int(2601), kw_end_DASH_column, int(40))
							tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 := lang.NewVector()
							tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2601), kw_column, int(42), kw_end_DASH_line, int(2601), kw_end_DASH_column, int(43))
							tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp19 := lang.Apply(tmp12, []any{tmp15, tmp18, v9})
							return tmp19
						case 2:
							v11 := args[0]
							_ = v11
							v12 := args[1]
							_ = v12
							tmp13 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp14 lang.FnFunc
							tmp14 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								tmp17 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp18 := lang.Apply(v16, []any{v11, v12})
								tmp19 := lang.Apply(tmp17, []any{v15, tmp18})
								return tmp19
							})
							tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2602), kw_column, int(26), kw_end_DASH_line, int(2602), kw_end_DASH_column, int(44))
							tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 := lang.NewVector()
							tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2602), kw_column, int(46), kw_end_DASH_line, int(2602), kw_end_DASH_column, int(47))
							tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp20 := lang.Apply(tmp13, []any{tmp16, tmp19, v9})
							return tmp20
						case 3:
							v11 := args[0]
							_ = v11
							v12 := args[1]
							_ = v12
							v13 := args[2]
							_ = v13
							tmp14 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp15 lang.FnFunc
							tmp15 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v16 := args[0]
								_ = v16
								v17 := args[1]
								_ = v17
								tmp18 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp19 := lang.Apply(v17, []any{v11, v12, v13})
								tmp20 := lang.Apply(tmp18, []any{v16, tmp19})
								return tmp20
							})
							tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2603), kw_column, int(28), kw_end_DASH_line, int(2603), kw_end_DASH_column, int(48))
							tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp18 := lang.NewVector()
							tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2603), kw_column, int(50), kw_end_DASH_line, int(2603), kw_end_DASH_column, int(51))
							tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp21 := lang.Apply(tmp14, []any{tmp17, tmp20, v9})
							return tmp21
						default:
							checkArityGTE(args, 3)
							v11 := args[0]
							_ = v11
							v12 := args[1]
							_ = v12
							v13 := args[2]
							_ = v13
							var v14 any = lang.NewList(args[3:]...)
							_ = v14
							tmp15 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp16 lang.FnFunc
							tmp16 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v17 := args[0]
								_ = v17
								v18 := args[1]
								_ = v18
								tmp19 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp20 := checkDerefVar(var_glojure_DOT_core_apply)
								tmp21 := lang.Apply(tmp20, []any{v18, v11, v12, v13, v14})
								tmp22 := lang.Apply(tmp19, []any{v17, tmp21})
								return tmp22
							})
							tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2604), kw_column, int(35), kw_end_DASH_line, int(2604), kw_end_DASH_column, int(66))
							tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp19 := lang.NewVector()
							tmp20 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2604), kw_column, int(68), kw_end_DASH_line, int(2604), kw_end_DASH_column, int(69))
							tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp22 := lang.Apply(tmp15, []any{tmp18, tmp21, v9})
							return tmp22
						}
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2599), kw_column, int(8), kw_end_DASH_line, int(2604), kw_end_DASH_column, int(75))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp6 = tmp12
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_juxt = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_juxt.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keep
	{
		tmp0 := sym_keep.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_coll)), kw_doc, "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(7339), kw_end_DASH_line, int(7339))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp6 := lang.Apply(v4, nil)
							return tmp6
						case 1:
							v6 := args[0]
							_ = v6
							tmp7 := lang.Apply(v4, []any{v6})
							return tmp7
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							var tmp8 any
							{ // let
								// let binding "v"
								tmp9 := lang.Apply(v2, []any{v7})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								tmp12 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
								tmp13 := lang.Apply(tmp12, []any{v10})
								if lang.IsTruthy(tmp13) {
									tmp11 = v6
								} else {
									tmp14 := lang.Apply(v4, []any{v6, v10})
									tmp11 = tmp14
								}
								tmp8 = tmp11
							} // end let
							return tmp8
						default:
							checkArity(args, -1)
							panic("unreachable")
						}
					})
					tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7347), kw_column, int(6), kw_end_DASH_line, int(7354), kw_end_DASH_column, int(31))
					tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp7
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7346), kw_column, int(4), kw_end_DASH_line, int(7354), kw_end_DASH_column, int(32))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp5 any
					{ // let
						// let binding "temp__0__auto__"
						tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp7 := lang.Apply(tmp6, []any{v3})
						var v8 any = tmp7
						_ = v8
						var tmp9 any
						if lang.IsTruthy(v8) {
							var tmp10 any
							{ // let
								// let binding "s"
								var v11 any = v8
								_ = v11
								var tmp12 any
								tmp13 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
								tmp14 := lang.Apply(tmp13, []any{v11})
								if lang.IsTruthy(tmp14) {
									var tmp15 any
									{ // let
										// let binding "c"
										tmp16 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
										tmp17 := lang.Apply(tmp16, []any{v11})
										var v18 any = tmp17
										_ = v18
										// let binding "size"
										tmp19 := checkDerefVar(var_glojure_DOT_core_count)
										tmp20 := lang.Apply(tmp19, []any{v18})
										var v21 any = tmp20
										_ = v21
										// let binding "b"
										tmp22 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_buffer)
										tmp23 := lang.Apply(tmp22, []any{v21})
										var v24 any = tmp23
										_ = v24
										var tmp25 any
										{ // let
											// let binding "n__0__auto__"
											tmp26 := checkDerefVar(var_glojure_DOT_core_long)
											tmp27 := lang.Apply(tmp26, []any{v21})
											var v28 any = tmp27
											_ = v28
											var tmp29 any
											{ // let
												// let binding "i"
												var v30 any = int64(0)
												_ = v30
												for {
													var tmp31 any
													tmp32 := checkDerefVar(var_glojure_DOT_core__LT_)
													tmp33 := lang.Apply(tmp32, []any{v30, v28})
													if lang.IsTruthy(tmp33) {
														var tmp34 any
														{ // let
															// let binding "x"
															tmp35, _ := lang.FieldOrMethod(v18, "nth")
															if reflect.TypeOf(tmp35).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp36 := lang.Apply(tmp35, []any{v30})
															tmp37 := lang.Apply(v2, []any{tmp36})
															var v38 any = tmp37
															_ = v38
															var tmp39 any
															tmp40 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
															tmp41 := lang.Apply(tmp40, []any{v38})
															if lang.IsTruthy(tmp41) {
															} else {
																tmp42 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_append)
																tmp43 := lang.Apply(tmp42, []any{v24, v38})
																tmp39 = tmp43
															}
															tmp34 = tmp39
														} // end let
														_ = tmp34
														tmp36 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
														tmp37 := lang.Apply(tmp36, []any{v30})
														var tmp35 any = tmp37
														v30 = tmp35
														continue
													} else {
													}
													tmp29 = tmp31
													break
												}
											} // end let
											tmp25 = tmp29
										} // end let
										_ = tmp25
										tmp26 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
										tmp27 := checkDerefVar(var_glojure_DOT_core_chunk)
										tmp28 := lang.Apply(tmp27, []any{v24})
										tmp29 := checkDerefVar(var_glojure_DOT_core_keep)
										tmp30 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
										tmp31 := lang.Apply(tmp30, []any{v11})
										tmp32 := lang.Apply(tmp29, []any{v2, tmp31})
										tmp33 := lang.Apply(tmp26, []any{tmp28, tmp32})
										tmp15 = tmp33
									} // end let
									tmp12 = tmp15
								} else {
									var tmp16 any
									{ // let
										// let binding "x"
										tmp17 := checkDerefVar(var_glojure_DOT_core_first)
										tmp18 := lang.Apply(tmp17, []any{v11})
										tmp19 := lang.Apply(v2, []any{tmp18})
										var v20 any = tmp19
										_ = v20
										var tmp21 any
										tmp22 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
										tmp23 := lang.Apply(tmp22, []any{v20})
										if lang.IsTruthy(tmp23) {
											tmp24 := checkDerefVar(var_glojure_DOT_core_keep)
											tmp25 := checkDerefVar(var_glojure_DOT_core_rest)
											tmp26 := lang.Apply(tmp25, []any{v11})
											tmp27 := lang.Apply(tmp24, []any{v2, tmp26})
											tmp21 = tmp27
										} else {
											tmp28 := checkDerefVar(var_glojure_DOT_core_cons)
											tmp29 := checkDerefVar(var_glojure_DOT_core_keep)
											tmp30 := checkDerefVar(var_glojure_DOT_core_rest)
											tmp31 := lang.Apply(tmp30, []any{v11})
											tmp32 := lang.Apply(tmp29, []any{v2, tmp31})
											tmp33 := lang.Apply(tmp28, []any{v20, tmp32})
											tmp21 = tmp33
										}
										tmp16 = tmp21
									} // end let
									tmp12 = tmp16
								}
								tmp10 = tmp12
							} // end let
							tmp9 = tmp10
						} else {
						}
						tmp5 = tmp9
					} // end let
					return tmp5
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_keep = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_keep.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lazy-seq
	{
		tmp0 := sym_lazy_DASH_seq.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Takes a body of expressions that returns an ISeq or nil, and yields\n  a Seqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls. See also - realized?", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(676), kw_end_DASH_line, int(676))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_list)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp7 := lang.NewVector()
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(683), kw_column, int(101), kw_end_DASH_line, int(683), kw_end_DASH_column, int(102))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := lang.Apply(tmp6, []any{sym_fn_STAR_, tmp9, v4})
				tmp11 := lang.Apply(tmp5, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewLazySeq, tmp10})
				return tmp11
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_lazy_DASH_seq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_lazy_DASH_seq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// locking
	{
		tmp0 := sym_locking.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_body)), kw_doc, "Executes exprs in an implicit do, while holding the monitor of x.\n  Will release the monitor of x in all circumstances.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(1643), kw_end_DASH_line, int(1643))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_let})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_lockee__0__auto__})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v4})
				tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp13, []any{tmp19})
				tmp21 := lang.Apply(tmp11, []any{tmp12, tmp20})
				tmp22 := lang.Apply(tmp10, []any{tmp21})
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp26 := checkDerefVar(var_glojure_DOT_core_list)
				tmp27 := lang.Apply(tmp26, []any{sym_try})
				tmp28 := checkDerefVar(var_glojure_DOT_core_list)
				tmp29 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp30 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp31 := checkDerefVar(var_glojure_DOT_core_list)
				tmp32 := lang.Apply(tmp31, []any{sym_glojure_DOT_core_SLASH_let})
				tmp33 := checkDerefVar(var_glojure_DOT_core_list)
				tmp34 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp35 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp36 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp37 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp38 := checkDerefVar(var_glojure_DOT_core_list)
				tmp39 := lang.Apply(tmp38, []any{sym_locklocal__1__auto__})
				tmp40 := checkDerefVar(var_glojure_DOT_core_list)
				tmp41 := lang.Apply(tmp40, []any{sym_lockee__0__auto__})
				tmp42 := lang.Apply(tmp37, []any{tmp39, tmp41})
				tmp43 := lang.Apply(tmp36, []any{tmp42})
				tmp44 := lang.Apply(tmp34, []any{tmp35, tmp43})
				tmp45 := lang.Apply(tmp33, []any{tmp44})
				tmp46 := checkDerefVar(var_glojure_DOT_core_list)
				tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp49 := checkDerefVar(var_glojure_DOT_core_list)
				tmp50 := lang.Apply(tmp49, []any{sym_monitor_DASH_enter})
				tmp51 := checkDerefVar(var_glojure_DOT_core_list)
				tmp52 := lang.Apply(tmp51, []any{sym_locklocal__1__auto__})
				tmp53 := lang.Apply(tmp48, []any{tmp50, tmp52})
				tmp54 := lang.Apply(tmp47, []any{tmp53})
				tmp55 := lang.Apply(tmp46, []any{tmp54})
				tmp56 := checkDerefVar(var_glojure_DOT_core_list)
				tmp57 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp58 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp59 := checkDerefVar(var_glojure_DOT_core_list)
				tmp60 := lang.Apply(tmp59, []any{sym_try})
				tmp61 := checkDerefVar(var_glojure_DOT_core_list)
				tmp62 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp63 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp64 := checkDerefVar(var_glojure_DOT_core_list)
				tmp65 := lang.Apply(tmp64, []any{sym_finally})
				tmp66 := checkDerefVar(var_glojure_DOT_core_list)
				tmp67 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp68 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp69 := checkDerefVar(var_glojure_DOT_core_list)
				tmp70 := lang.Apply(tmp69, []any{sym_monitor_DASH_exit})
				tmp71 := checkDerefVar(var_glojure_DOT_core_list)
				tmp72 := lang.Apply(tmp71, []any{sym_locklocal__1__auto__})
				tmp73 := lang.Apply(tmp68, []any{tmp70, tmp72})
				tmp74 := lang.Apply(tmp67, []any{tmp73})
				tmp75 := lang.Apply(tmp66, []any{tmp74})
				tmp76 := lang.Apply(tmp63, []any{tmp65, tmp75})
				tmp77 := lang.Apply(tmp62, []any{tmp76})
				tmp78 := lang.Apply(tmp61, []any{tmp77})
				tmp79 := lang.Apply(tmp58, []any{tmp60, v5, tmp78})
				tmp80 := lang.Apply(tmp57, []any{tmp79})
				tmp81 := lang.Apply(tmp56, []any{tmp80})
				tmp82 := lang.Apply(tmp30, []any{tmp32, tmp45, tmp55, tmp81})
				tmp83 := lang.Apply(tmp29, []any{tmp82})
				tmp84 := lang.Apply(tmp28, []any{tmp83})
				tmp85 := lang.Apply(tmp25, []any{tmp27, tmp84})
				tmp86 := lang.Apply(tmp24, []any{tmp85})
				tmp87 := lang.Apply(tmp23, []any{tmp86})
				tmp88 := lang.Apply(tmp7, []any{tmp9, tmp22, tmp87})
				tmp89 := lang.Apply(tmp6, []any{tmp88})
				return tmp89
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_locking = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_locking.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map
	{
		tmp0 := sym_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_c1, sym_c2), lang.NewVector(sym_f, sym_c1, sym_c2, sym_c3), lang.NewVector(sym_f, sym_c1, sym_c2, sym_c3, sym__AMP_, sym_colls)), kw_doc, "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(2719), kw_end_DASH_line, int(2719))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp6 := lang.Apply(v4, nil)
							return tmp6
						case 1:
							v6 := args[0]
							_ = v6
							tmp7 := lang.Apply(v4, []any{v6})
							return tmp7
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							tmp8 := lang.Apply(v2, []any{v7})
							tmp9 := lang.Apply(v4, []any{v6, tmp8})
							return tmp9
						default:
							checkArityGTE(args, 2)
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							var v8 any = lang.NewList(args[2:]...)
							_ = v8
							tmp9 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp10 := lang.Apply(tmp9, []any{v2, v7, v8})
							tmp11 := lang.Apply(v4, []any{v6, tmp10})
							return tmp11
						}
					})
					tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2730), kw_column, int(7), kw_end_DASH_line, int(2736), kw_end_DASH_column, int(47))
					tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp7
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2729), kw_column, int(5), kw_end_DASH_line, int(2736), kw_end_DASH_column, int(48))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp5 any
					{ // let
						// let binding "temp__0__auto__"
						tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp7 := lang.Apply(tmp6, []any{v3})
						var v8 any = tmp7
						_ = v8
						var tmp9 any
						if lang.IsTruthy(v8) {
							var tmp10 any
							{ // let
								// let binding "s"
								var v11 any = v8
								_ = v11
								var tmp12 any
								tmp13 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
								tmp14 := lang.Apply(tmp13, []any{v11})
								if lang.IsTruthy(tmp14) {
									var tmp15 any
									{ // let
										// let binding "c"
										tmp16 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
										tmp17 := lang.Apply(tmp16, []any{v11})
										var v18 any = tmp17
										_ = v18
										// let binding "size"
										tmp19 := checkDerefVar(var_glojure_DOT_core_int)
										tmp20 := checkDerefVar(var_glojure_DOT_core_count)
										tmp21 := lang.Apply(tmp20, []any{v18})
										tmp22 := lang.Apply(tmp19, []any{tmp21})
										var v23 any = tmp22
										_ = v23
										// let binding "b"
										tmp24 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_buffer)
										tmp25 := lang.Apply(tmp24, []any{v23})
										var v26 any = tmp25
										_ = v26
										var tmp27 any
										{ // let
											// let binding "n__0__auto__"
											tmp28 := lang.Apply(lang.LongCast, []any{v23})
											var v29 any = tmp28
											_ = v29
											var tmp30 any
											{ // let
												// let binding "i"
												var v31 any = int64(0)
												_ = v31
												for {
													var tmp32 any
													tmp33 := checkDerefVar(var_glojure_DOT_core__LT_)
													tmp34 := lang.Apply(tmp33, []any{v31, v29})
													if lang.IsTruthy(tmp34) {
														tmp35 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_append)
														tmp36, _ := lang.FieldOrMethod(v18, "nth")
														if reflect.TypeOf(tmp36).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
														}
														tmp37 := lang.Apply(tmp36, []any{v31})
														tmp38 := lang.Apply(v2, []any{tmp37})
														tmp39 := lang.Apply(tmp35, []any{v26, tmp38})
														_ = tmp39
														tmp41 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
														tmp42 := lang.Apply(tmp41, []any{v31})
														var tmp40 any = tmp42
														v31 = tmp40
														continue
													} else {
													}
													tmp30 = tmp32
													break
												}
											} // end let
											tmp27 = tmp30
										} // end let
										_ = tmp27
										tmp28 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
										tmp29 := checkDerefVar(var_glojure_DOT_core_chunk)
										tmp30 := lang.Apply(tmp29, []any{v26})
										tmp31 := checkDerefVar(var_glojure_DOT_core_map)
										tmp32 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
										tmp33 := lang.Apply(tmp32, []any{v11})
										tmp34 := lang.Apply(tmp31, []any{v2, tmp33})
										tmp35 := lang.Apply(tmp28, []any{tmp30, tmp34})
										tmp15 = tmp35
									} // end let
									tmp12 = tmp15
								} else {
									tmp16 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp17 := checkDerefVar(var_glojure_DOT_core_first)
									tmp18 := lang.Apply(tmp17, []any{v11})
									tmp19 := lang.Apply(v2, []any{tmp18})
									tmp20 := checkDerefVar(var_glojure_DOT_core_map)
									tmp21 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp22 := lang.Apply(tmp21, []any{v11})
									tmp23 := lang.Apply(tmp20, []any{v2, tmp22})
									tmp24 := lang.Apply(tmp16, []any{tmp19, tmp23})
									tmp12 = tmp24
								}
								tmp10 = tmp12
							} // end let
							tmp9 = tmp10
						} else {
						}
						tmp5 = tmp9
					} // end let
					return tmp5
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "s1"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v3})
						var v9 any = tmp8
						_ = v9
						// let binding "s2"
						tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp11 := lang.Apply(tmp10, []any{v4})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						var tmp14 any
						{ // let
							// let binding "and__0__auto__"
							var v15 any = v9
							_ = v15
							var tmp16 any
							if lang.IsTruthy(v15) {
								tmp16 = v12
							} else {
								tmp16 = v15
							}
							tmp14 = tmp16
						} // end let
						if lang.IsTruthy(tmp14) {
							tmp15 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp16 := checkDerefVar(var_glojure_DOT_core_first)
							tmp17 := lang.Apply(tmp16, []any{v9})
							tmp18 := checkDerefVar(var_glojure_DOT_core_first)
							tmp19 := lang.Apply(tmp18, []any{v12})
							tmp20 := lang.Apply(v2, []any{tmp17, tmp19})
							tmp21 := checkDerefVar(var_glojure_DOT_core_map)
							tmp22 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp23 := lang.Apply(tmp22, []any{v9})
							tmp24 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp25 := lang.Apply(tmp24, []any{v12})
							tmp26 := lang.Apply(tmp21, []any{v2, tmp23, tmp25})
							tmp27 := lang.Apply(tmp15, []any{tmp20, tmp26})
							tmp13 = tmp27
						} else {
						}
						tmp6 = tmp13
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp7 any
					{ // let
						// let binding "s1"
						tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v3})
						var v10 any = tmp9
						_ = v10
						// let binding "s2"
						tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp12 := lang.Apply(tmp11, []any{v4})
						var v13 any = tmp12
						_ = v13
						// let binding "s3"
						tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp15 := lang.Apply(tmp14, []any{v5})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						var tmp18 any
						{ // let
							// let binding "and__0__auto__"
							var v19 any = v10
							_ = v19
							var tmp20 any
							if lang.IsTruthy(v19) {
								var tmp21 any
								{ // let
									// let binding "and__0__auto__"
									var v22 any = v13
									_ = v22
									var tmp23 any
									if lang.IsTruthy(v22) {
										tmp23 = v16
									} else {
										tmp23 = v22
									}
									tmp21 = tmp23
								} // end let
								tmp20 = tmp21
							} else {
								tmp20 = v19
							}
							tmp18 = tmp20
						} // end let
						if lang.IsTruthy(tmp18) {
							tmp19 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp20 := checkDerefVar(var_glojure_DOT_core_first)
							tmp21 := lang.Apply(tmp20, []any{v10})
							tmp22 := checkDerefVar(var_glojure_DOT_core_first)
							tmp23 := lang.Apply(tmp22, []any{v13})
							tmp24 := checkDerefVar(var_glojure_DOT_core_first)
							tmp25 := lang.Apply(tmp24, []any{v16})
							tmp26 := lang.Apply(v2, []any{tmp21, tmp23, tmp25})
							tmp27 := checkDerefVar(var_glojure_DOT_core_map)
							tmp28 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp29 := lang.Apply(tmp28, []any{v10})
							tmp30 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp31 := lang.Apply(tmp30, []any{v13})
							tmp32 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp33 := lang.Apply(tmp32, []any{v16})
							tmp34 := lang.Apply(tmp27, []any{v2, tmp29, tmp31, tmp33})
							tmp35 := lang.Apply(tmp19, []any{tmp26, tmp34})
							tmp17 = tmp35
						} else {
						}
						tmp7 = tmp17
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			default:
				checkArityGTE(args, 4)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var v6 any = lang.NewList(args[4:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "step"
					var tmp8 lang.FnFunc
					{ // function step
						var v9 lang.FnFunc
						tmp8 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v10 := args[0]
							_ = v10
							var tmp11 lang.FnFunc
							tmp11 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								var tmp12 any
								{ // let
									// let binding "ss"
									tmp13 := checkDerefVar(var_glojure_DOT_core_map)
									tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp15 := lang.Apply(tmp13, []any{tmp14, v10})
									var v16 any = tmp15
									_ = v16
									var tmp17 any
									tmp18 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
									tmp19 := checkDerefVar(var_glojure_DOT_core_identity)
									tmp20 := lang.Apply(tmp18, []any{tmp19, v16})
									if lang.IsTruthy(tmp20) {
										tmp21 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp22 := checkDerefVar(var_glojure_DOT_core_map)
										tmp23 := checkDerefVar(var_glojure_DOT_core_first)
										tmp24 := lang.Apply(tmp22, []any{tmp23, v16})
										tmp25 := checkDerefVar(var_glojure_DOT_core_map)
										tmp26 := checkDerefVar(var_glojure_DOT_core_rest)
										tmp27 := lang.Apply(tmp25, []any{tmp26, v16})
										tmp28 := lang.Apply(v9, []any{tmp27})
										tmp29 := lang.Apply(tmp21, []any{tmp24, tmp28})
										tmp17 = tmp29
									} else {
									}
									tmp12 = tmp17
								} // end let
								return tmp12
							})
							tmp12 := lang.Apply(lang.NewLazySeq, []any{tmp11})
							return tmp12
						})
						v9 = tmp8
						_ = v9
					}
					tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2761), kw_column, int(15), kw_end_DASH_line, int(2765), kw_end_DASH_column, int(68))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v11 any = tmp10
					_ = v11
					tmp12 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp13 lang.FnFunc
					tmp13 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v14 := args[0]
						_ = v14
						tmp15 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp16 := lang.Apply(tmp15, []any{v2, v14})
						return tmp16
					})
					tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2766), kw_column, int(11), kw_end_DASH_line, int(2766), kw_end_DASH_column, int(22))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp16 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp17 := lang.Apply(tmp16, []any{v6, v5, v4, v3})
					tmp18 := lang.Apply(v11, []any{tmp17})
					tmp19 := lang.Apply(tmp12, []any{tmp15, tmp18})
					tmp7 = tmp19
				} // end let
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed33
					} else {
						tmp4 = closed33
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed33
					} else {
						tmp5 = closed33
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed33
					} else {
						tmp6 = closed33
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_max.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the greatest of the nums.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1108), kw_end_DASH_line, int(1108))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return v4
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "max")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("max is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core_max)
				tmp9 := checkDerefVar(var_glojure_DOT_core_max)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_max = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_max.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-key
	{
		tmp0 := sym_max_DASH_key.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_k, sym_x), lang.NewVector(sym_k, sym_x, sym_y), lang.NewVector(sym_k, sym_x, sym_y, sym__AMP_, sym_more)), kw_doc, "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5013), kw_end_DASH_line, int(5013))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				return v3
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core__GT_)
				tmp7 := lang.Apply(v2, []any{v3})
				tmp8 := lang.Apply(v2, []any{v4})
				tmp9 := lang.Apply(tmp6, []any{tmp7, tmp8})
				if lang.IsTruthy(tmp9) {
					tmp5 = v3
				} else {
					tmp5 = v4
				}
				return tmp5
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "kx"
					tmp7 := lang.Apply(v2, []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "ky"
					tmp9 := lang.Apply(v2, []any{v4})
					var v10 any = tmp9
					_ = v10
					// let binding "vec__55"
					var tmp11 any
					tmp12 := checkDerefVar(var_glojure_DOT_core__GT_)
					tmp13 := lang.Apply(tmp12, []any{v8, v10})
					if lang.IsTruthy(tmp13) {
						tmp14 := lang.NewVector(v3, v8)
						tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5023), kw_column, int(31), kw_end_DASH_line, int(5023), kw_end_DASH_column, int(36))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp11 = tmp16
					} else {
						tmp17 := lang.NewVector(v4, v10)
						tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5023), kw_column, int(38), kw_end_DASH_line, int(5023), kw_end_DASH_column, int(43))
						tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp11 = tmp19
					}
					var v20 any = tmp11
					_ = v20
					// let binding "v"
					tmp21 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp22 := lang.Apply(tmp21, []any{v20, int64(0), nil})
					var v23 any = tmp22
					_ = v23
					// let binding "kv"
					tmp24 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp25 := lang.Apply(tmp24, []any{v20, int64(1), nil})
					var v26 any = tmp25
					_ = v26
					var tmp27 any
					{ // let
						// let binding "v"
						var v28 any = v23
						_ = v28
						// let binding "kv"
						var v29 any = v26
						_ = v29
						// let binding "more"
						var v30 any = v5
						_ = v30
						for {
							var tmp31 any
							if lang.IsTruthy(v30) {
								var tmp32 any
								{ // let
									// let binding "w"
									tmp33 := checkDerefVar(var_glojure_DOT_core_first)
									tmp34 := lang.Apply(tmp33, []any{v30})
									var v35 any = tmp34
									_ = v35
									// let binding "kw"
									tmp36 := lang.Apply(v2, []any{v35})
									var v37 any = tmp36
									_ = v37
									var tmp38 any
									tmp39 := checkDerefVar(var_glojure_DOT_core__GT__EQ_)
									tmp40 := lang.Apply(tmp39, []any{v37, v29})
									if lang.IsTruthy(tmp40) {
										var tmp41 any = v35
										var tmp42 any = v37
										tmp44 := checkDerefVar(var_glojure_DOT_core_next)
										tmp45 := lang.Apply(tmp44, []any{v30})
										var tmp43 any = tmp45
										v28 = tmp41
										v29 = tmp42
										v30 = tmp43
										continue
									} else {
										var tmp46 any = v28
										var tmp47 any = v29
										tmp49 := checkDerefVar(var_glojure_DOT_core_next)
										tmp50 := lang.Apply(tmp49, []any{v30})
										var tmp48 any = tmp50
										v28 = tmp46
										v29 = tmp47
										v30 = tmp48
										continue
									}
									tmp32 = tmp38
								} // end let
								tmp31 = tmp32
							} else {
								tmp31 = v28
							}
							tmp27 = tmp31
							break
						}
					} // end let
					tmp6 = tmp27
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_max_DASH_key = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_max_DASH_key.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// memfn
	{
		tmp0 := sym_memfn.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_args)), kw_doc, "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(3872), kw_end_DASH_line, int(3872))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "t"
					tmp7 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp8 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, []any{"target"})
					tmp10 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp11 := lang.Apply(tmp10, []any{v4})
					tmp12 := lang.Apply(tmp7, []any{tmp9, tmp11})
					var v13 any = tmp12
					_ = v13
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{sym_glojure_DOT_core_SLASH_fn})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp20 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp22 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp23 := checkDerefVar(var_glojure_DOT_core_list)
					tmp24 := lang.Apply(tmp23, []any{v13})
					tmp25 := lang.Apply(tmp22, []any{tmp24, v5})
					tmp26 := lang.Apply(tmp21, []any{tmp25})
					tmp27 := lang.Apply(tmp19, []any{tmp20, tmp26})
					tmp28 := lang.Apply(tmp18, []any{tmp27})
					tmp29 := checkDerefVar(var_glojure_DOT_core_list)
					tmp30 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp31 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp32 := checkDerefVar(var_glojure_DOT_core_list)
					tmp33 := lang.Apply(tmp32, []any{sym__DOT_})
					tmp34 := checkDerefVar(var_glojure_DOT_core_list)
					tmp35 := lang.Apply(tmp34, []any{v13})
					tmp36 := checkDerefVar(var_glojure_DOT_core_list)
					tmp37 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp38 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					tmp40 := lang.Apply(tmp39, []any{v4})
					tmp41 := lang.Apply(tmp38, []any{tmp40, v5})
					tmp42 := lang.Apply(tmp37, []any{tmp41})
					tmp43 := lang.Apply(tmp36, []any{tmp42})
					tmp44 := lang.Apply(tmp31, []any{tmp33, tmp35, tmp43})
					tmp45 := lang.Apply(tmp30, []any{tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp15, []any{tmp17, tmp28, tmp46})
					tmp48 := lang.Apply(tmp14, []any{tmp47})
					tmp6 = tmp48
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_memfn = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_memfn.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge
	{
		tmp0 := sym_merge.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_maps)), kw_doc, "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3040), kw_end_DASH_line, int(3040))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_glojure_DOT_core_some)
				tmp5 := checkDerefVar(var_glojure_DOT_core_identity)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v2})
				if lang.IsTruthy(tmp6) {
					tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp8 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v9 := args[0]
						_ = v9
						v10 := args[1]
						_ = v10
						tmp11 := checkDerefVar(var_glojure_DOT_core_conj)
						var tmp12 any
						{ // let
							// let binding "or__0__auto__"
							var v13 any = v9
							_ = v13
							var tmp14 any
							if lang.IsTruthy(v13) {
								tmp14 = v13
							} else {
								tmp15 := lang.NewMap()
								tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3048), kw_column, int(28), kw_end_DASH_line, int(3048), kw_end_DASH_column, int(29))
								tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp14 = tmp17
							}
							tmp12 = tmp14
						} // end let
						tmp13 := lang.Apply(tmp11, []any{tmp12, v10})
						return tmp13
					})
					tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3048), kw_column, int(14), kw_end_DASH_line, int(3048), kw_end_DASH_column, int(34))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp11 := lang.Apply(tmp7, []any{tmp10, v2})
					tmp3 = tmp11
				} else {
				}
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_merge = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_merge.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge-with
	{
		tmp0 := sym_merge_DASH_with.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym__AMP_, sym_maps)), kw_doc, "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(3050), kw_end_DASH_line, int(3050))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_some)
				tmp6 := checkDerefVar(var_glojure_DOT_core_identity)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
				if lang.IsTruthy(tmp7) {
					var tmp8 any
					{ // let
						// let binding "merge-entry"
						var tmp9 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v10 := args[0]
							_ = v10
							v11 := args[1]
							_ = v11
							var tmp12 any
							{ // let
								// let binding "k"
								tmp13 := checkDerefVar(var_glojure_DOT_core_key)
								tmp14 := lang.Apply(tmp13, []any{v11})
								var v15 any = tmp14
								_ = v15
								// let binding "v"
								tmp16 := checkDerefVar(var_glojure_DOT_core_val)
								tmp17 := lang.Apply(tmp16, []any{v11})
								var v18 any = tmp17
								_ = v18
								var tmp19 any
								tmp20 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
								tmp21 := lang.Apply(tmp20, []any{v10, v15})
								if lang.IsTruthy(tmp21) {
									tmp22 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp23 := checkDerefVar(var_glojure_DOT_core_get)
									tmp24 := lang.Apply(tmp23, []any{v10, v15})
									tmp25 := lang.Apply(v2, []any{tmp24, v18})
									tmp26 := lang.Apply(tmp22, []any{v10, v15, tmp25})
									tmp19 = tmp26
								} else {
									tmp27 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp28 := lang.Apply(tmp27, []any{v10, v15, v18})
									tmp19 = tmp28
								}
								tmp12 = tmp19
							} // end let
							return tmp12
						})
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3059), kw_column, int(23), kw_end_DASH_line, int(3063), kw_end_DASH_column, int(23))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v12 any = tmp11
						_ = v12
						// let binding "merge2"
						var tmp13 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v14 := args[0]
							_ = v14
							v15 := args[1]
							_ = v15
							tmp16 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp17 any
							{ // let
								// let binding "or__0__auto__"
								var v18 any = v14
								_ = v18
								var tmp19 any
								if lang.IsTruthy(v18) {
									tmp19 = v18
								} else {
									tmp20 := lang.NewMap()
									tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3065), kw_column, int(34), kw_end_DASH_line, int(3065), kw_end_DASH_column, int(35))
									tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp19 = tmp22
								}
								tmp17 = tmp19
							} // end let
							tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp19 := lang.Apply(tmp18, []any{v15})
							tmp20 := lang.Apply(tmp16, []any{v12, tmp17, tmp19})
							return tmp20
						})
						tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3064), kw_column, int(18), kw_end_DASH_line, int(3065), kw_end_DASH_column, int(47))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v16 any = tmp15
						_ = v16
						tmp17 := checkDerefVar(var_glojure_DOT_core_reduce1)
						tmp18 := lang.Apply(tmp17, []any{v16, v3})
						tmp8 = tmp18
					} // end let
					tmp4 = tmp8
				} else {
				}
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_merge_DASH_with = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_merge_DASH_with.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// min
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed34
					} else {
						tmp4 = closed34
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed34
					} else {
						tmp5 = closed34
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed34
					} else {
						tmp6 = closed34
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_min.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the least of the nums.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1118), kw_end_DASH_line, int(1118))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return v4
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "min")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("min is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core_min)
				tmp9 := checkDerefVar(var_glojure_DOT_core_min)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_min = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_min.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// min-key
	{
		tmp0 := sym_min_DASH_key.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_k, sym_x), lang.NewVector(sym_k, sym_x, sym_y), lang.NewVector(sym_k, sym_x, sym_y, sym__AMP_, sym_more)), kw_doc, "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5033), kw_end_DASH_line, int(5033))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				return v3
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core__LT_)
				tmp7 := lang.Apply(v2, []any{v3})
				tmp8 := lang.Apply(v2, []any{v4})
				tmp9 := lang.Apply(tmp6, []any{tmp7, tmp8})
				if lang.IsTruthy(tmp9) {
					tmp5 = v3
				} else {
					tmp5 = v4
				}
				return tmp5
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "kx"
					tmp7 := lang.Apply(v2, []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "ky"
					tmp9 := lang.Apply(v2, []any{v4})
					var v10 any = tmp9
					_ = v10
					// let binding "vec__58"
					var tmp11 any
					tmp12 := checkDerefVar(var_glojure_DOT_core__LT_)
					tmp13 := lang.Apply(tmp12, []any{v8, v10})
					if lang.IsTruthy(tmp13) {
						tmp14 := lang.NewVector(v3, v8)
						tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5043), kw_column, int(31), kw_end_DASH_line, int(5043), kw_end_DASH_column, int(36))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp11 = tmp16
					} else {
						tmp17 := lang.NewVector(v4, v10)
						tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5043), kw_column, int(38), kw_end_DASH_line, int(5043), kw_end_DASH_column, int(43))
						tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp11 = tmp19
					}
					var v20 any = tmp11
					_ = v20
					// let binding "v"
					tmp21 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp22 := lang.Apply(tmp21, []any{v20, int64(0), nil})
					var v23 any = tmp22
					_ = v23
					// let binding "kv"
					tmp24 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp25 := lang.Apply(tmp24, []any{v20, int64(1), nil})
					var v26 any = tmp25
					_ = v26
					var tmp27 any
					{ // let
						// let binding "v"
						var v28 any = v23
						_ = v28
						// let binding "kv"
						var v29 any = v26
						_ = v29
						// let binding "more"
						var v30 any = v5
						_ = v30
						for {
							var tmp31 any
							if lang.IsTruthy(v30) {
								var tmp32 any
								{ // let
									// let binding "w"
									tmp33 := checkDerefVar(var_glojure_DOT_core_first)
									tmp34 := lang.Apply(tmp33, []any{v30})
									var v35 any = tmp34
									_ = v35
									// let binding "kw"
									tmp36 := lang.Apply(v2, []any{v35})
									var v37 any = tmp36
									_ = v37
									var tmp38 any
									tmp39 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
									tmp40 := lang.Apply(tmp39, []any{v37, v29})
									if lang.IsTruthy(tmp40) {
										var tmp41 any = v35
										var tmp42 any = v37
										tmp44 := checkDerefVar(var_glojure_DOT_core_next)
										tmp45 := lang.Apply(tmp44, []any{v30})
										var tmp43 any = tmp45
										v28 = tmp41
										v29 = tmp42
										v30 = tmp43
										continue
									} else {
										var tmp46 any = v28
										var tmp47 any = v29
										tmp49 := checkDerefVar(var_glojure_DOT_core_next)
										tmp50 := lang.Apply(tmp49, []any{v30})
										var tmp48 any = tmp50
										v28 = tmp46
										v29 = tmp47
										v30 = tmp48
										continue
									}
									tmp32 = tmp38
								} // end let
								tmp31 = tmp32
							} else {
								tmp31 = v28
							}
							tmp27 = tmp31
							break
						}
					} // end let
					tmp6 = tmp27
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_min_DASH_key = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_min_DASH_key.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mod
	{
		tmp0 := sym_mod.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num, sym_div)), kw_doc, "Modulus of num and div. Truncates toward negative infinity.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(3567), kw_end_DASH_line, int(3567))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "m"
				tmp5 := checkDerefVar(var_glojure_DOT_core_rem)
				tmp6 := lang.Apply(tmp5, []any{v2, v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				var tmp9 any
				{ // let
					// let binding "or__0__auto__"
					tmp10 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
					tmp11 := lang.Apply(tmp10, []any{v7})
					var v12 any = tmp11
					_ = v12
					var tmp13 any
					if lang.IsTruthy(v12) {
						tmp13 = v12
					} else {
						tmp14 := checkDerefVar(var_glojure_DOT_core__EQ_)
						tmp15 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp16 := lang.Apply(tmp15, []any{v2})
						tmp17 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp18 := lang.Apply(tmp17, []any{v3})
						tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
						tmp13 = tmp19
					}
					tmp9 = tmp13
				} // end let
				if lang.IsTruthy(tmp9) {
					tmp8 = v7
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core__PLUS_)
					tmp11 := lang.Apply(tmp10, []any{v7, v3})
					tmp8 = tmp11
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_mod = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_mod.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nary-inline
	{
		tmp0 := sym_nary_DASH_inline.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(948), kw_column, int(7), kw_end_DASH_line, int(948), kw_end_DASH_column, int(27), kw_arglists, lang.NewList(lang.NewVector(sym_op), lang.NewVector(sym_op, sym_unchecked_DASH_op)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_nary_DASH_inline)
				tmp4 := lang.Apply(tmp3, []any{v2, v2})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 1:
						v5 := args[0]
						_ = v5
						var tmp6 any
						{ // let
							// let binding "op"
							var tmp7 any
							tmp8 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
							if lang.IsTruthy(tmp8) {
								tmp7 = v3
							} else {
								tmp7 = v2
							}
							var v9 any = tmp7
							_ = v9
							tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp11 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp12 := checkDerefVar(var_glojure_DOT_core_list)
							tmp13 := lang.Apply(tmp12, []any{sym__DOT_})
							tmp14 := checkDerefVar(var_glojure_DOT_core_list)
							tmp15 := lang.Apply(tmp14, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
							tmp16 := checkDerefVar(var_glojure_DOT_core_list)
							tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp19 := checkDerefVar(var_glojure_DOT_core_list)
							tmp20 := lang.Apply(tmp19, []any{v9})
							tmp21 := checkDerefVar(var_glojure_DOT_core_list)
							tmp22 := lang.Apply(tmp21, []any{v5})
							tmp23 := lang.Apply(tmp18, []any{tmp20, tmp22})
							tmp24 := lang.Apply(tmp17, []any{tmp23})
							tmp25 := lang.Apply(tmp16, []any{tmp24})
							tmp26 := lang.Apply(tmp11, []any{tmp13, tmp15, tmp25})
							tmp27 := lang.Apply(tmp10, []any{tmp26})
							tmp6 = tmp27
						} // end let
						return tmp6
					case 2:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						var tmp7 any
						{ // let
							// let binding "op"
							var tmp8 any
							tmp9 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
							if lang.IsTruthy(tmp9) {
								tmp8 = v3
							} else {
								tmp8 = v2
							}
							var v10 any = tmp8
							_ = v10
							tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp13 := checkDerefVar(var_glojure_DOT_core_list)
							tmp14 := lang.Apply(tmp13, []any{sym__DOT_})
							tmp15 := checkDerefVar(var_glojure_DOT_core_list)
							tmp16 := lang.Apply(tmp15, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
							tmp17 := checkDerefVar(var_glojure_DOT_core_list)
							tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp20 := checkDerefVar(var_glojure_DOT_core_list)
							tmp21 := lang.Apply(tmp20, []any{v10})
							tmp22 := checkDerefVar(var_glojure_DOT_core_list)
							tmp23 := lang.Apply(tmp22, []any{v5})
							tmp24 := checkDerefVar(var_glojure_DOT_core_list)
							tmp25 := lang.Apply(tmp24, []any{v6})
							tmp26 := lang.Apply(tmp19, []any{tmp21, tmp23, tmp25})
							tmp27 := lang.Apply(tmp18, []any{tmp26})
							tmp28 := lang.Apply(tmp17, []any{tmp27})
							tmp29 := lang.Apply(tmp12, []any{tmp14, tmp16, tmp28})
							tmp30 := lang.Apply(tmp11, []any{tmp29})
							tmp7 = tmp30
						} // end let
						return tmp7
					default:
						checkArityGTE(args, 2)
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						var v7 any = lang.NewList(args[2:]...)
						_ = v7
						var tmp8 any
						{ // let
							// let binding "op"
							var tmp9 any
							tmp10 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
							if lang.IsTruthy(tmp10) {
								tmp9 = v3
							} else {
								tmp9 = v2
							}
							var v11 any = tmp9
							_ = v11
							tmp12 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp13 lang.FnFunc
							tmp13 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v14 := args[0]
								_ = v14
								v15 := args[1]
								_ = v15
								tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp17 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp18 := checkDerefVar(var_glojure_DOT_core_list)
								tmp19 := lang.Apply(tmp18, []any{sym__DOT_})
								tmp20 := checkDerefVar(var_glojure_DOT_core_list)
								tmp21 := lang.Apply(tmp20, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
								tmp22 := checkDerefVar(var_glojure_DOT_core_list)
								tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp25 := checkDerefVar(var_glojure_DOT_core_list)
								tmp26 := lang.Apply(tmp25, []any{v11})
								tmp27 := checkDerefVar(var_glojure_DOT_core_list)
								tmp28 := lang.Apply(tmp27, []any{v14})
								tmp29 := checkDerefVar(var_glojure_DOT_core_list)
								tmp30 := lang.Apply(tmp29, []any{v15})
								tmp31 := lang.Apply(tmp24, []any{tmp26, tmp28, tmp30})
								tmp32 := lang.Apply(tmp23, []any{tmp31})
								tmp33 := lang.Apply(tmp22, []any{tmp32})
								tmp34 := lang.Apply(tmp17, []any{tmp19, tmp21, tmp33})
								tmp35 := lang.Apply(tmp16, []any{tmp34})
								return tmp35
							})
							tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
							tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp17 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp18 := checkDerefVar(var_glojure_DOT_core_list)
							tmp19 := lang.Apply(tmp18, []any{sym__DOT_})
							tmp20 := checkDerefVar(var_glojure_DOT_core_list)
							tmp21 := lang.Apply(tmp20, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
							tmp22 := checkDerefVar(var_glojure_DOT_core_list)
							tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp25 := checkDerefVar(var_glojure_DOT_core_list)
							tmp26 := lang.Apply(tmp25, []any{v11})
							tmp27 := checkDerefVar(var_glojure_DOT_core_list)
							tmp28 := lang.Apply(tmp27, []any{v5})
							tmp29 := checkDerefVar(var_glojure_DOT_core_list)
							tmp30 := lang.Apply(tmp29, []any{v6})
							tmp31 := lang.Apply(tmp24, []any{tmp26, tmp28, tmp30})
							tmp32 := lang.Apply(tmp23, []any{tmp31})
							tmp33 := lang.Apply(tmp22, []any{tmp32})
							tmp34 := lang.Apply(tmp17, []any{tmp19, tmp21, tmp33})
							tmp35 := lang.Apply(tmp16, []any{tmp34})
							tmp36 := lang.Apply(tmp12, []any{tmp15, tmp35, v7})
							tmp8 = tmp36
						} // end let
						return tmp8
					}
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_nary_DASH_inline = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_nary_DASH_inline.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nat-int?
	{
		tmp0 := sym_nat_DASH_int_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a non-negative fixed precision integer", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1415), kw_end_DASH_line, int(1415))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "and__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_not)
					tmp9 := checkDerefVar(var_glojure_DOT_core_neg_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v2})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					tmp7 = tmp11
				} else {
					tmp7 = v6
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_nat_DASH_int_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_nat_DASH_int_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// neg-int?
	{
		tmp0 := sym_neg_DASH_int_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a negative fixed precision integer", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1409), kw_end_DASH_line, int(1409))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "and__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_neg_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp7 = tmp9
				} else {
					tmp7 = v6
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_neg_DASH_int_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_neg_DASH_int_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-any?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_not_DASH_any_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns false if (pred x) is logical true for any x in coll,\n  else true.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(2), kw_line, int(2696), kw_end_DASH_line, int(2701))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.Apply(closed36, nil)
				tmp4 := lang.Apply(closed35, []any{tmp3})
				return tmp4
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(closed36, []any{v3})
				tmp5 := lang.Apply(closed35, []any{tmp4})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(closed36, []any{v3, v4})
				tmp6 := lang.Apply(closed35, []any{tmp5})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.Apply(closed36, []any{v3, v4, v5})
				tmp7 := lang.Apply(closed35, []any{tmp6})
				return tmp7
			default:
				checkArityGTE(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := lang.Apply(tmp7, []any{closed36, v3, v4, v5, v6})
				tmp9 := lang.Apply(closed35, []any{tmp8})
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2559), kw_column, int(6), kw_end_DASH_line, int(2564), kw_end_DASH_column, int(49))).(lang.FnFunc)
		var_glojure_DOT_core_not_DASH_any_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_not_DASH_any_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-every?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_not_DASH_every_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns false if (pred x) is logical true for every x in\n  coll, else true.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(2), kw_line, int(2677), kw_end_DASH_line, int(2682))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.Apply(closed37, nil)
				tmp4 := lang.Apply(closed35, []any{tmp3})
				return tmp4
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(closed37, []any{v3})
				tmp5 := lang.Apply(closed35, []any{tmp4})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(closed37, []any{v3, v4})
				tmp6 := lang.Apply(closed35, []any{tmp5})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.Apply(closed37, []any{v3, v4, v5})
				tmp7 := lang.Apply(closed35, []any{tmp6})
				return tmp7
			default:
				checkArityGTE(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := lang.Apply(tmp7, []any{closed37, v3, v4, v5, v6})
				tmp9 := lang.Apply(closed35, []any{tmp8})
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2559), kw_column, int(6), kw_end_DASH_line, int(2564), kw_end_DASH_column, int(49))).(lang.FnFunc)
		var_glojure_DOT_core_not_DASH_every_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_not_DASH_every_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not=
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_not_EQ_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_doc, "Same as (not (= obj1 obj2))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(812), kw_end_DASH_line, int(812))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return false
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_not)
				tmp6 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp7 := lang.Apply(tmp6, []any{v3, v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			default:
				checkArityGTE(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_not)
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp9 := lang.Apply(tmp7, []any{tmp8, v3, v4, v5})
				tmp10 := lang.Apply(tmp6, []any{tmp9})
				return tmp10
			}
		})
		tmp3 := reflect.TypeOf(false)
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_not_EQ_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_not_EQ_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-interns
	{
		tmp0 := sym_ns_DASH_interns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of the intern mappings for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4206), kw_end_DASH_line, int(4206))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "ns"
				tmp4 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_filter_DASH_key)
				tmp8 := checkDerefVar(var_glojure_DOT_core_val)
				var tmp9 lang.FnFunc
				tmp9 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v10 := args[0]
					_ = v10
					var tmp11 any
					{ // let
						// let binding "and__0__auto__"
						tmp12 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp13 := reflect.TypeOf((*lang.Var)(nil))
						tmp14 := lang.Apply(tmp12, []any{tmp13, v10})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						if lang.IsTruthy(v15) {
							tmp17 := checkDerefVar(var_glojure_DOT_core__EQ_)
							tmp18, ok := lang.FieldOrMethod(v10, "Namespace")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "Namespace")))
							}
							var tmp19 any
							switch reflect.TypeOf(tmp18).Kind() {
							case reflect.Func:
								tmp19 = lang.Apply(tmp18, nil)
							default:
								tmp19 = tmp18
							}
							tmp20 := lang.Apply(tmp17, []any{v6, tmp19})
							tmp16 = tmp20
						} else {
							tmp16 = v15
						}
						tmp11 = tmp16
					} // end let
					return tmp11
				})
				tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4212), kw_column, int(21), kw_end_DASH_line, int(4213), kw_end_DASH_column, int(56))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := checkDerefVar(var_glojure_DOT_core_ns_DASH_map)
				tmp13 := lang.Apply(tmp12, []any{v6})
				tmp14 := lang.Apply(tmp7, []any{tmp8, tmp11, tmp13})
				tmp3 = tmp14
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ns_DASH_interns = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ns_DASH_interns.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-publics
	{
		tmp0 := sym_ns_DASH_publics.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of the public intern mappings for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4188), kw_end_DASH_line, int(4188))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "ns"
				tmp4 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_filter_DASH_key)
				tmp8 := checkDerefVar(var_glojure_DOT_core_val)
				var tmp9 lang.FnFunc
				tmp9 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v10 := args[0]
					_ = v10
					var tmp11 any
					{ // let
						// let binding "and__0__auto__"
						tmp12 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp13 := reflect.TypeOf((*lang.Var)(nil))
						tmp14 := lang.Apply(tmp12, []any{tmp13, v10})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						if lang.IsTruthy(v15) {
							var tmp17 any
							{ // let
								// let binding "and__0__auto__"
								tmp18 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp19, ok := lang.FieldOrMethod(v10, "Namespace")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "Namespace")))
								}
								var tmp20 any
								switch reflect.TypeOf(tmp19).Kind() {
								case reflect.Func:
									tmp20 = lang.Apply(tmp19, nil)
								default:
									tmp20 = tmp19
								}
								tmp21 := lang.Apply(tmp18, []any{v6, tmp20})
								var v22 any = tmp21
								_ = v22
								var tmp23 any
								if lang.IsTruthy(v22) {
									tmp24, ok := lang.FieldOrMethod(v10, "IsPublic")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "IsPublic")))
									}
									var tmp25 any
									switch reflect.TypeOf(tmp24).Kind() {
									case reflect.Func:
										tmp25 = lang.Apply(tmp24, nil)
									default:
										tmp25 = tmp24
									}
									tmp23 = tmp25
								} else {
									tmp23 = v22
								}
								tmp17 = tmp23
							} // end let
							tmp16 = tmp17
						} else {
							tmp16 = v15
						}
						tmp11 = tmp16
					} // end let
					return tmp11
				})
				tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4194), kw_column, int(21), kw_end_DASH_line, int(4196), kw_end_DASH_column, int(48))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := checkDerefVar(var_glojure_DOT_core_ns_DASH_map)
				tmp13 := lang.Apply(tmp12, []any{v6})
				tmp14 := lang.Apply(tmp7, []any{tmp8, tmp11, tmp13})
				tmp3 = tmp14
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ns_DASH_publics = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ns_DASH_publics.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-refers
	{
		tmp0 := sym_ns_DASH_refers.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of the refer mappings for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4253), kw_end_DASH_line, int(4253))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "ns"
				tmp4 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_filter_DASH_key)
				tmp8 := checkDerefVar(var_glojure_DOT_core_val)
				var tmp9 lang.FnFunc
				tmp9 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v10 := args[0]
					_ = v10
					var tmp11 any
					{ // let
						// let binding "and__0__auto__"
						tmp12 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp13 := reflect.TypeOf((*lang.Var)(nil))
						tmp14 := lang.Apply(tmp12, []any{tmp13, v10})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						if lang.IsTruthy(v15) {
							tmp17 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
							tmp18, ok := lang.FieldOrMethod(v10, "Namespace")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "Namespace")))
							}
							var tmp19 any
							switch reflect.TypeOf(tmp18).Kind() {
							case reflect.Func:
								tmp19 = lang.Apply(tmp18, nil)
							default:
								tmp19 = tmp18
							}
							tmp20 := lang.Apply(tmp17, []any{v6, tmp19})
							tmp16 = tmp20
						} else {
							tmp16 = v15
						}
						tmp11 = tmp16
					} // end let
					return tmp11
				})
				tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4259), kw_column, int(21), kw_end_DASH_line, int(4260), kw_end_DASH_column, int(59))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := checkDerefVar(var_glojure_DOT_core_ns_DASH_map)
				tmp13 := lang.Apply(tmp12, []any{v6})
				tmp14 := lang.Apply(tmp7, []any{tmp8, tmp11, tmp13})
				tmp3 = tmp14
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ns_DASH_refers = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ns_DASH_refers.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nthnext
	{
		tmp0 := sym_nthnext.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_n)), kw_doc, "Returns the nth next of coll, (seq coll) when n is 0.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3147), kw_end_DASH_line, int(3147))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp6 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
			tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
			if lang.IsTruthy(tmp7) {
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v3})
				if lang.IsTruthy(tmp10) {
					var tmp11 any
					tmp12 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
					tmp13 := lang.Apply(tmp12, []any{v3})
					if lang.IsTruthy(tmp13) {
						tmp11 = v3
					} else {
						tmp14 := lang.Apply(nil, []any{v3})
						tmp11 = tmp14
					}
					tmp15, _ := lang.FieldOrMethod(v2, "drop")
					if reflect.TypeOf(tmp15).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
					}
					tmp16 := lang.Apply(tmp15, []any{tmp11})
					tmp8 = tmp16
				} else {
					tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp18 := lang.Apply(tmp17, []any{v2})
					tmp8 = tmp18
				}
				tmp4 = tmp8
			} else {
				var tmp19 any
				{ // let
					// let binding "n"
					var v20 any = v3
					_ = v20
					// let binding "xs"
					tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp22 := lang.Apply(tmp21, []any{v2})
					var v23 any = tmp22
					_ = v23
					for {
						var tmp24 any
						var tmp25 any
						{ // let
							// let binding "and__0__auto__"
							var v26 any = v23
							_ = v26
							var tmp27 any
							if lang.IsTruthy(v26) {
								tmp28 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
								tmp29 := lang.Apply(tmp28, []any{v20})
								tmp27 = tmp29
							} else {
								tmp27 = v26
							}
							tmp25 = tmp27
						} // end let
						if lang.IsTruthy(tmp25) {
							tmp27 := checkDerefVar(var_glojure_DOT_core_dec)
							tmp28 := lang.Apply(tmp27, []any{v20})
							var tmp26 any = tmp28
							tmp30 := checkDerefVar(var_glojure_DOT_core_next)
							tmp31 := lang.Apply(tmp30, []any{v23})
							var tmp29 any = tmp31
							v20 = tmp26
							v23 = tmp29
							continue
						} else {
							tmp24 = v23
						}
						tmp19 = tmp24
						break
					}
				} // end let
				tmp4 = tmp19
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_nthnext = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_nthnext.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nthrest
	{
		tmp0 := sym_nthrest.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_n)), kw_doc, "Returns the nth rest of coll, coll when n is 0.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3161), kw_end_DASH_line, int(3161))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				var tmp7 any
				{ // let
					// let binding "or__0__auto__"
					var tmp8 any
					tmp9 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp10 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
					tmp11 := lang.Apply(tmp9, []any{tmp10, v2})
					if lang.IsTruthy(tmp11) {
						var tmp12 any
						tmp13 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v3})
						if lang.IsTruthy(tmp14) {
							tmp12 = v3
						} else {
							tmp15 := lang.Apply(nil, []any{v3})
							tmp12 = tmp15
						}
						tmp16, _ := lang.FieldOrMethod(v2, "drop")
						if reflect.TypeOf(tmp16).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
						}
						tmp17 := lang.Apply(tmp16, []any{tmp12})
						tmp8 = tmp17
					} else {
						var tmp18 any
						{ // let
							// let binding "n"
							var v19 any = v3
							_ = v19
							// let binding "xs"
							var v20 any = v2
							_ = v20
							for {
								var tmp21 any
								{ // let
									// let binding "temp__0__auto__"
									var tmp22 any
									{ // let
										// let binding "and__0__auto__"
										tmp23 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
										tmp24 := lang.Apply(tmp23, []any{v19})
										var v25 any = tmp24
										_ = v25
										var tmp26 any
										if lang.IsTruthy(v25) {
											tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp28 := lang.Apply(tmp27, []any{v20})
											tmp26 = tmp28
										} else {
											tmp26 = v25
										}
										tmp22 = tmp26
									} // end let
									var v23 any = tmp22
									_ = v23
									var tmp24 any
									if lang.IsTruthy(v23) {
										var tmp25 any
										{ // let
											// let binding "xs"
											var v26 any = v23
											_ = v26
											tmp28 := checkDerefVar(var_glojure_DOT_core_dec)
											tmp29 := lang.Apply(tmp28, []any{v19})
											var tmp27 any = tmp29
											tmp31 := checkDerefVar(var_glojure_DOT_core_rest)
											tmp32 := lang.Apply(tmp31, []any{v26})
											var tmp30 any = tmp32
											v19 = tmp27
											v20 = tmp30
											continue
										} // end let
										tmp24 = tmp25
									} else {
										tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp27 := lang.Apply(tmp26, []any{v20})
										tmp24 = tmp27
									}
									tmp21 = tmp24
								} // end let
								tmp18 = tmp21
								break
							}
						} // end let
						tmp8 = tmp18
					}
					var v19 any = tmp8
					_ = v19
					var tmp20 any
					if lang.IsTruthy(v19) {
						tmp20 = v19
					} else {
						tmp20 = lang.NewList()
					}
					tmp7 = tmp20
				} // end let
				tmp4 = tmp7
			} else {
				tmp4 = v2
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_nthrest = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_nthrest.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// odd?
	{
		tmp0 := sym_odd_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is odd, throws an exception if n is not an integer", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1389), kw_end_DASH_line, int(1389))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_not)
			tmp4 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			tmp6 := lang.Apply(tmp3, []any{tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_odd_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_odd_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// or
	{
		tmp0 := sym_or.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_next)), kw_doc, "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(847), kw_end_DASH_line, int(847))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				return nil
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				return v4
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_let})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_or__0__auto__})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v4})
				tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp13, []any{tmp19})
				tmp21 := lang.Apply(tmp11, []any{tmp12, tmp20})
				tmp22 := lang.Apply(tmp10, []any{tmp21})
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp26 := checkDerefVar(var_glojure_DOT_core_list)
				tmp27 := lang.Apply(tmp26, []any{sym_if})
				tmp28 := checkDerefVar(var_glojure_DOT_core_list)
				tmp29 := lang.Apply(tmp28, []any{sym_or__0__auto__})
				tmp30 := checkDerefVar(var_glojure_DOT_core_list)
				tmp31 := lang.Apply(tmp30, []any{sym_or__0__auto__})
				tmp32 := checkDerefVar(var_glojure_DOT_core_list)
				tmp33 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp34 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp35 := checkDerefVar(var_glojure_DOT_core_list)
				tmp36 := lang.Apply(tmp35, []any{sym_glojure_DOT_core_SLASH_or})
				tmp37 := lang.Apply(tmp34, []any{tmp36, v5})
				tmp38 := lang.Apply(tmp33, []any{tmp37})
				tmp39 := lang.Apply(tmp32, []any{tmp38})
				tmp40 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp31, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp23, []any{tmp41})
				tmp43 := lang.Apply(tmp7, []any{tmp9, tmp22, tmp42})
				tmp44 := lang.Apply(tmp6, []any{tmp43})
				return tmp44
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_or = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_or.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parents
	{
		tmp0 := sym_parents.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag), lang.NewVector(sym_h, sym_tag)), kw_doc, "Returns the immediate parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5564), kw_end_DASH_line, int(5564))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_parents)
				tmp4 := checkDerefVar(var_glojure_DOT_core_global_DASH_hierarchy)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
				var tmp5 any
				{ // let
					// let binding "tp"
					tmp6 := checkDerefVar(var_glojure_DOT_core_get)
					tmp7 := lang.Apply(kw_parents, []any{v2})
					tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
					tmp12 := lang.Apply(tmp11, []any{v3})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(var_glojure_DOT_core_into1)
						tmp14 := checkDerefVar(var_glojure_DOT_core_set)
						tmp15 := checkDerefVar(var_glojure_DOT_core_bases)
						tmp16 := lang.Apply(tmp15, []any{v3})
						tmp17 := lang.Apply(tmp14, []any{tmp16})
						tmp18 := lang.Apply(tmp13, []any{tmp17, v9})
						tmp10 = tmp18
					} else {
						tmp10 = v9
					}
					tmp5 = tmp10
				} // end let
				tmp6 := lang.Apply(tmp4, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_parents = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_parents.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-boolean
	{
		tmp0 := sym_parse_DASH_boolean.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Parse strings \"true\" or \"false\" and return a boolean, or nil if invalid", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(7957), kw_end_DASH_line, int(7957))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				var tmp6 any
				{ // let
					// let binding "G__365"
					var v7 any = v2
					_ = v7
					// case
					var tmp8 any
					// case clause 0
					if lang.Equals(v7, "true") {
						tmp8 = true
						// case clause 1
					} else if lang.Equals(v7, "false") {
						tmp8 = false
					} else {
					}
					tmp6 = tmp8
				} // end let
				tmp3 = tmp6
			} else {
				tmp7 := checkDerefVar(var_glojure_DOT_core_parsing_DASH_err)
				tmp8 := lang.Apply(tmp7, []any{v2})
				tmp9 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp8})
				panic(tmp9)
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_parse_DASH_boolean = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_parse_DASH_boolean.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-double
	{
		tmp0 := sym_parse_DASH_double.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Parse string with floating point components and return a Double value,\n  or nil if parse fails.\n\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(7935), kw_end_DASH_line, int(7935))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				var tmp6 any
				{ // let
					// let binding "result__3649__auto__"
					tmp7 := lang.Apply(strconv12.ParseFloat, []any{v2, int64(64)})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					tmp10 := lang.Apply(v8, []any{int64(1)})
					if lang.IsTruthy(tmp10) {
					} else {
						tmp11 := lang.Apply(v8, []any{int64(0)})
						tmp9 = tmp11
					}
					tmp6 = tmp9
				} // end let
				tmp3 = tmp6
			} else {
				tmp7 := checkDerefVar(var_glojure_DOT_core_parsing_DASH_err)
				tmp8 := lang.Apply(tmp7, []any{v2})
				tmp9 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp8})
				panic(tmp9)
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_parse_DASH_double = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_parse_DASH_double.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-long
	{
		tmp0 := sym_parse_DASH_long.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Parse string of decimal digits with optional leading -/+ and return a\n  Long value, or nil if parse fails", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7926), kw_end_DASH_line, int(7926))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				var tmp6 any
				{ // let
					// let binding "result__3648__auto__"
					tmp7 := lang.Apply(strconv12.ParseInt, []any{v2, int64(10), int64(64)})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					tmp10 := lang.Apply(v8, []any{int64(1)})
					if lang.IsTruthy(tmp10) {
					} else {
						tmp11 := lang.Apply(v8, []any{int64(0)})
						tmp9 = tmp11
					}
					tmp6 = tmp9
				} // end let
				tmp3 = tmp6
			} else {
				tmp7 := checkDerefVar(var_glojure_DOT_core_parsing_DASH_err)
				tmp8 := lang.Apply(tmp7, []any{v2})
				tmp9 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp8})
				panic(tmp9)
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_parse_DASH_long = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_parse_DASH_long.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partial
	{
		tmp0 := sym_partial.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_arg1), lang.NewVector(sym_f, sym_arg1, sym_arg2), lang.NewVector(sym_f, sym_arg1, sym_arg2, sym_arg3), lang.NewVector(sym_f, sym_arg1, sym_arg2, sym_arg3, sym__AMP_, sym_more)), kw_doc, "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(2606), kw_end_DASH_line, int(2606))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				return v2
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp5 := lang.Apply(v2, []any{v3})
						return tmp5
					case 1:
						v5 := args[0]
						_ = v5
						tmp6 := lang.Apply(v2, []any{v3, v5})
						return tmp6
					case 2:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						tmp7 := lang.Apply(v2, []any{v3, v5, v6})
						return tmp7
					case 3:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						tmp8 := lang.Apply(v2, []any{v3, v5, v6, v7})
						return tmp8
					default:
						checkArityGTE(args, 3)
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						var v8 any = lang.NewList(args[3:]...)
						_ = v8
						tmp9 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp10 := lang.Apply(tmp9, []any{v2, v3, v5, v6, v7, v8})
						return tmp10
					}
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2614), kw_column, int(4), kw_end_DASH_line, int(2619), kw_end_DASH_column, int(48))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v2, []any{v3, v4})
						return tmp6
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v2, []any{v3, v4, v6})
						return tmp7
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v2, []any{v3, v4, v6, v7})
						return tmp8
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						tmp9 := lang.Apply(v2, []any{v3, v4, v6, v7, v8})
						return tmp9
					default:
						checkArityGTE(args, 3)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp11 := lang.Apply(tmp10, []any{v2, v3, v4, v6, v7, v8, v9})
						return tmp11
					}
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2621), kw_column, int(4), kw_end_DASH_line, int(2626), kw_end_DASH_column, int(53))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp7 := lang.Apply(v2, []any{v3, v4, v5})
						return tmp7
					case 1:
						v7 := args[0]
						_ = v7
						tmp8 := lang.Apply(v2, []any{v3, v4, v5, v7})
						return tmp8
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						tmp9 := lang.Apply(v2, []any{v3, v4, v5, v7, v8})
						return tmp9
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						tmp10 := lang.Apply(v2, []any{v3, v4, v5, v7, v8, v9})
						return tmp10
					default:
						checkArityGTE(args, 3)
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp12 := lang.Apply(tmp11, []any{v2, v3, v4, v5, v7, v8, v9, v10})
						return tmp12
					}
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2628), kw_column, int(4), kw_end_DASH_line, int(2633), kw_end_DASH_column, int(58))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			default:
				checkArityGTE(args, 4)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var v6 any = lang.NewList(args[4:]...)
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						checkArityGTE(args, 0)
						var v8 any = lang.NewList(args[0:]...)
						_ = v8
						tmp9 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp10 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp11 := lang.Apply(tmp10, []any{v6, v8})
						tmp12 := lang.Apply(tmp9, []any{v2, v3, v4, v5, tmp11})
						return tmp12
					}
				})
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2635), kw_column, int(4), kw_end_DASH_line, int(2635), kw_end_DASH_column, int(60))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp9
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_partial = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_partial.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition-by
	{
		tmp0 := sym_partition_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_coll)), kw_doc, "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(7142), kw_end_DASH_line, int(7142))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "a"
						tmp6 := new(lang.ArrayList)
						var v7 any = tmp6
						_ = v7
						// let binding "pv"
						tmp8 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp9 := lang.Apply(tmp8, []any{kw_glojure_DOT_core_SLASH_none})
						var v10 any = tmp9
						_ = v10
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp12 := lang.Apply(v4, nil)
								return tmp12
							case 1:
								v12 := args[0]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "result"
									var tmp14 any
									tmp15, ok := lang.FieldOrMethod(v7, "isEmpty")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "isEmpty")))
									}
									var tmp16 any
									switch reflect.TypeOf(tmp15).Kind() {
									case reflect.Func:
										tmp16 = lang.Apply(tmp15, nil)
									default:
										tmp16 = tmp15
									}
									if lang.IsTruthy(tmp16) {
										tmp14 = v12
									} else {
										var tmp17 any
										{ // let
											// let binding "v"
											tmp18 := checkDerefVar(var_glojure_DOT_core_vec)
											tmp19, ok := lang.FieldOrMethod(v7, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "toArray")))
											}
											var tmp20 any
											switch reflect.TypeOf(tmp19).Kind() {
											case reflect.Func:
												tmp20 = lang.Apply(tmp19, nil)
											default:
												tmp20 = tmp19
											}
											tmp21 := lang.Apply(tmp18, []any{tmp20})
											var v22 any = tmp21
											_ = v22
											tmp23, ok := lang.FieldOrMethod(v7, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "clear")))
											}
											var tmp24 any
											switch reflect.TypeOf(tmp23).Kind() {
											case reflect.Func:
												tmp24 = lang.Apply(tmp23, nil)
											default:
												tmp24 = tmp23
											}
											_ = tmp24
											tmp25 := checkDerefVar(var_glojure_DOT_core_unreduced)
											tmp26 := lang.Apply(v4, []any{v12, v22})
											tmp27 := lang.Apply(tmp25, []any{tmp26})
											tmp17 = tmp27
										} // end let
										tmp14 = tmp17
									}
									var v18 any = tmp14
									_ = v18
									tmp19 := lang.Apply(v4, []any{v18})
									tmp13 = tmp19
								} // end let
								return tmp13
							case 2:
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								var tmp14 any
								{ // let
									// let binding "pval"
									tmp15 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp16 := lang.Apply(tmp15, []any{v10})
									var v17 any = tmp16
									_ = v17
									// let binding "val"
									tmp18 := lang.Apply(v2, []any{v13})
									var v19 any = tmp18
									_ = v19
									tmp20 := checkDerefVar(var_glojure_DOT_core_vreset_BANG_)
									tmp21 := lang.Apply(tmp20, []any{v10, v19})
									_ = tmp21
									var tmp22 any
									var tmp23 any
									{ // let
										// let binding "or__0__auto__"
										tmp24 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
										tmp25 := lang.Apply(tmp24, []any{v17, kw_glojure_DOT_core_SLASH_none})
										var v26 any = tmp25
										_ = v26
										var tmp27 any
										if lang.IsTruthy(v26) {
											tmp27 = v26
										} else {
											tmp28 := checkDerefVar(var_glojure_DOT_core__EQ_)
											tmp29 := lang.Apply(tmp28, []any{v19, v17})
											tmp27 = tmp29
										}
										tmp23 = tmp27
									} // end let
									if lang.IsTruthy(tmp23) {
										tmp24, _ := lang.FieldOrMethod(v7, "add")
										if reflect.TypeOf(tmp24).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
										}
										tmp25 := lang.Apply(tmp24, []any{v13})
										_ = tmp25
										tmp22 = v12
									} else {
										var tmp26 any
										{ // let
											// let binding "v"
											tmp27 := checkDerefVar(var_glojure_DOT_core_vec)
											tmp28, ok := lang.FieldOrMethod(v7, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "toArray")))
											}
											var tmp29 any
											switch reflect.TypeOf(tmp28).Kind() {
											case reflect.Func:
												tmp29 = lang.Apply(tmp28, nil)
											default:
												tmp29 = tmp28
											}
											tmp30 := lang.Apply(tmp27, []any{tmp29})
											var v31 any = tmp30
											_ = v31
											tmp32, ok := lang.FieldOrMethod(v7, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "clear")))
											}
											var tmp33 any
											switch reflect.TypeOf(tmp32).Kind() {
											case reflect.Func:
												tmp33 = lang.Apply(tmp32, nil)
											default:
												tmp33 = tmp32
											}
											_ = tmp33
											var tmp34 any
											{ // let
												// let binding "ret"
												tmp35 := lang.Apply(v4, []any{v12, v31})
												var v36 any = tmp35
												_ = v36
												var tmp37 any
												tmp38 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
												tmp39 := lang.Apply(tmp38, []any{v36})
												if lang.IsTruthy(tmp39) {
												} else {
													tmp40, _ := lang.FieldOrMethod(v7, "add")
													if reflect.TypeOf(tmp40).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
													}
													tmp41 := lang.Apply(tmp40, []any{v13})
													tmp37 = tmp41
												}
												_ = tmp37
												tmp34 = v36
											} // end let
											tmp26 = tmp34
										} // end let
										tmp22 = tmp26
									}
									tmp14 = tmp22
								} // end let
								return tmp14
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7152), kw_column, int(7), kw_end_DASH_line, int(7176), kw_end_DASH_column, int(28))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp13
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7149), kw_column, int(3), kw_end_DASH_line, int(7176), kw_end_DASH_column, int(30))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp5 any
					{ // let
						// let binding "temp__0__auto__"
						tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp7 := lang.Apply(tmp6, []any{v3})
						var v8 any = tmp7
						_ = v8
						var tmp9 any
						if lang.IsTruthy(v8) {
							var tmp10 any
							{ // let
								// let binding "s"
								var v11 any = v8
								_ = v11
								var tmp12 any
								{ // let
									// let binding "fst"
									tmp13 := checkDerefVar(var_glojure_DOT_core_first)
									tmp14 := lang.Apply(tmp13, []any{v11})
									var v15 any = tmp14
									_ = v15
									// let binding "fv"
									tmp16 := lang.Apply(v2, []any{v15})
									var v17 any = tmp16
									_ = v17
									// let binding "run"
									tmp18 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp19 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
									var tmp20 lang.FnFunc
									tmp20 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v21 := args[0]
										_ = v21
										tmp22 := checkDerefVar(var_glojure_DOT_core__EQ_)
										tmp23 := lang.Apply(v2, []any{v21})
										tmp24 := lang.Apply(tmp22, []any{v17, tmp23})
										return tmp24
									})
									tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7182), kw_column, int(41), kw_end_DASH_line, int(7182), kw_end_DASH_column, int(53))
									tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp23 := checkDerefVar(var_glojure_DOT_core_next)
									tmp24 := lang.Apply(tmp23, []any{v11})
									tmp25 := lang.Apply(tmp19, []any{tmp22, tmp24})
									tmp26 := lang.Apply(tmp18, []any{v15, tmp25})
									var v27 any = tmp26
									_ = v27
									tmp28 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp29 := checkDerefVar(var_glojure_DOT_core_partition_DASH_by)
									var tmp30 lang.FnFunc
									tmp30 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 0)
										tmp31 := checkDerefVar(var_glojure_DOT_core_drop)
										tmp32 := checkDerefVar(var_glojure_DOT_core_count)
										tmp33 := lang.Apply(tmp32, []any{v27})
										tmp34 := lang.Apply(tmp31, []any{tmp33, v11})
										return tmp34
									})
									tmp31 := lang.Apply(lang.NewLazySeq, []any{tmp30})
									tmp32 := lang.Apply(tmp29, []any{v2, tmp31})
									tmp33 := lang.Apply(tmp28, []any{v27, tmp32})
									tmp12 = tmp33
								} // end let
								tmp10 = tmp12
							} // end let
							tmp9 = tmp10
						} else {
						}
						tmp5 = tmp9
					} // end let
					return tmp5
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_partition_DASH_by = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_partition_DASH_by.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pmap
	{
		tmp0 := sym_pmap.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_coll, sym__AMP_, sym_colls)), kw_doc, "Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(7031), kw_end_DASH_line, int(7031))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "n"
					tmp5 := checkDerefVar(var_glojure_DOT_core__PLUS_)
					tmp6 := lang.Apply(runtime14.NumCPU, nil)
					tmp7 := lang.Apply(tmp5, []any{int64(2), tmp6})
					var v8 any = tmp7
					_ = v8
					// let binding "rets"
					tmp9 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v11 := args[0]
						_ = v11
						tmp12 := checkDerefVar(var_glojure_DOT_core_future_DASH_call)
						var tmp13 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							tmp14 := lang.Apply(v2, []any{v11})
							return tmp14
						})
						tmp14 := lang.Apply(tmp12, []any{tmp13})
						return tmp14
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7041), kw_column, int(20), kw_end_DASH_line, int(7041), kw_end_DASH_column, int(34))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := lang.Apply(tmp9, []any{tmp12, v3})
					var v14 any = tmp13
					_ = v14
					// let binding "step"
					var tmp15 lang.FnFunc
					{ // function step
						var v16 lang.FnFunc
						tmp15 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v17 := args[0]
							_ = v17
							v18 := args[1]
							_ = v18
							var tmp19 any
							{ // let
								// let binding "vec__335"
								var v20 any = v17
								_ = v20
								// let binding "seq__336"
								tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp22 := lang.Apply(tmp21, []any{v20})
								var v23 any = tmp22
								_ = v23
								// let binding "first__337"
								tmp24 := checkDerefVar(var_glojure_DOT_core_first)
								tmp25 := lang.Apply(tmp24, []any{v23})
								var v26 any = tmp25
								_ = v26
								// let binding "seq__336"
								tmp27 := checkDerefVar(var_glojure_DOT_core_next)
								tmp28 := lang.Apply(tmp27, []any{v23})
								var v29 any = tmp28
								_ = v29
								// let binding "x"
								var v30 any = v26
								_ = v30
								// let binding "xs"
								var v31 any = v29
								_ = v31
								// let binding "vs"
								var v32 any = v20
								_ = v32
								var tmp33 lang.FnFunc
								tmp33 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 0)
									var tmp34 any
									{ // let
										// let binding "temp__0__auto__"
										tmp35 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp36 := lang.Apply(tmp35, []any{v18})
										var v37 any = tmp36
										_ = v37
										var tmp38 any
										if lang.IsTruthy(v37) {
											var tmp39 any
											{ // let
												// let binding "s"
												var v40 any = v37
												_ = v40
												tmp41 := checkDerefVar(var_glojure_DOT_core_cons)
												tmp42 := checkDerefVar(var_glojure_DOT_core_deref)
												tmp43 := lang.Apply(tmp42, []any{v30})
												tmp44 := checkDerefVar(var_glojure_DOT_core_rest)
												tmp45 := lang.Apply(tmp44, []any{v40})
												tmp46 := lang.Apply(v16, []any{v31, tmp45})
												tmp47 := lang.Apply(tmp41, []any{tmp43, tmp46})
												tmp39 = tmp47
											} // end let
											tmp38 = tmp39
										} else {
											tmp40 := checkDerefVar(var_glojure_DOT_core_map)
											tmp41 := checkDerefVar(var_glojure_DOT_core_deref)
											tmp42 := lang.Apply(tmp40, []any{tmp41, v32})
											tmp38 = tmp42
										}
										tmp34 = tmp38
									} // end let
									return tmp34
								})
								tmp34 := lang.Apply(lang.NewLazySeq, []any{tmp33})
								tmp19 = tmp34
							} // end let
							return tmp19
						})
						v16 = tmp15
						_ = v16
					}
					tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7042), kw_column, int(15), kw_end_DASH_line, int(7046), kw_end_DASH_column, int(36))
					tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v18 any = tmp17
					_ = v18
					tmp19 := checkDerefVar(var_glojure_DOT_core_drop)
					tmp20 := lang.Apply(tmp19, []any{v8, v14})
					tmp21 := lang.Apply(v18, []any{v14, tmp20})
					tmp4 = tmp21
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "step"
					var tmp6 lang.FnFunc
					{ // function step
						var v7 lang.FnFunc
						tmp6 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v8 := args[0]
							_ = v8
							var tmp9 lang.FnFunc
							tmp9 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								var tmp10 any
								{ // let
									// let binding "ss"
									tmp11 := checkDerefVar(var_glojure_DOT_core_map)
									tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp13 := lang.Apply(tmp11, []any{tmp12, v8})
									var v14 any = tmp13
									_ = v14
									var tmp15 any
									tmp16 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
									tmp17 := checkDerefVar(var_glojure_DOT_core_identity)
									tmp18 := lang.Apply(tmp16, []any{tmp17, v14})
									if lang.IsTruthy(tmp18) {
										tmp19 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp20 := checkDerefVar(var_glojure_DOT_core_map)
										tmp21 := checkDerefVar(var_glojure_DOT_core_first)
										tmp22 := lang.Apply(tmp20, []any{tmp21, v14})
										tmp23 := checkDerefVar(var_glojure_DOT_core_map)
										tmp24 := checkDerefVar(var_glojure_DOT_core_rest)
										tmp25 := lang.Apply(tmp23, []any{tmp24, v14})
										tmp26 := lang.Apply(v7, []any{tmp25})
										tmp27 := lang.Apply(tmp19, []any{tmp22, tmp26})
										tmp15 = tmp27
									} else {
									}
									tmp10 = tmp15
								} // end let
								return tmp10
							})
							tmp10 := lang.Apply(lang.NewLazySeq, []any{tmp9})
							return tmp10
						})
						v7 = tmp6
						_ = v7
					}
					tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7049), kw_column, int(15), kw_end_DASH_line, int(7053), kw_end_DASH_column, int(67))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v9 any = tmp8
					_ = v9
					tmp10 := checkDerefVar(var_glojure_DOT_core_pmap)
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v12 := args[0]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp14 := lang.Apply(tmp13, []any{v2, v12})
						return tmp14
					})
					tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7054), kw_column, int(12), kw_end_DASH_line, int(7054), kw_end_DASH_column, int(23))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp14 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp15 := lang.Apply(tmp14, []any{v3, v4})
					tmp16 := lang.Apply(v9, []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp13, tmp16})
					tmp5 = tmp17
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_pmap = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_pmap.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pos-int?
	{
		tmp0 := sym_pos_DASH_int_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a positive fixed precision integer", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1403), kw_end_DASH_line, int(1403))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "and__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp7 = tmp9
				} else {
					tmp7 = v6
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_pos_DASH_int_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_pos_DASH_int_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// preserving-reduced
	{
		tmp0 := sym_preserving_DASH_reduced.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(7638), kw_column, int(7), kw_end_DASH_line, int(7638), kw_end_DASH_column, int(34), kw_arglists, lang.NewList(lang.NewVector(sym_rf)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "ret"
					tmp7 := lang.Apply(v2, []any{v4, v5})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
					tmp11 := lang.Apply(tmp10, []any{v8})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_reduced)
						tmp13 := lang.Apply(tmp12, []any{v8})
						tmp9 = tmp13
					} else {
						tmp9 = v8
					}
					tmp6 = tmp9
				} // end let
				return tmp6
			})
			tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7640), kw_column, int(3), kw_end_DASH_line, int(7643), kw_end_DASH_column, int(12))
			tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_preserving_DASH_reduced = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_preserving_DASH_reduced.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-sequential
	{
		tmp0 := sym_print_DASH_sequential.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(46), kw_column, int(8), kw_end_DASH_line, int(46), kw_end_DASH_column, int(23), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_begin, sym_print_DASH_one, sym_sep, sym_end, sym_sequence, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 6)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			v6 := args[4]
			_ = v6
			v7 := args[5]
			_ = v7
			var tmp8 any
			{ // let
				tmp9 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp10 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
				tmp11 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_level_STAR_)
				var tmp12 any
				{ // let
					// let binding "and__0__auto__"
					tmp13 := checkDerefVar(var_glojure_DOT_core_not)
					tmp14 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
					tmp15 := lang.Apply(tmp13, []any{tmp14})
					var v16 any = tmp15
					_ = v16
					var tmp17 any
					if lang.IsTruthy(v16) {
						var tmp18 any
						{ // let
							// let binding "and__0__auto__"
							tmp19 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_level_STAR_)
							var v20 any = tmp19
							_ = v20
							var tmp21 any
							if lang.IsTruthy(v20) {
								tmp22 := checkDerefVar(var_glojure_DOT_core_dec)
								tmp23 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_level_STAR_)
								tmp24 := lang.Apply(tmp22, []any{tmp23})
								tmp21 = tmp24
							} else {
								tmp21 = v20
							}
							tmp18 = tmp21
						} // end let
						tmp17 = tmp18
					} else {
						tmp17 = v16
					}
					tmp12 = tmp17
				} // end let
				tmp13 := lang.Apply(tmp10, []any{tmp11, tmp12})
				tmp14 := lang.Apply(tmp9, []any{tmp13})
				_ = tmp14
				var tmp15 any
				func() {
					defer func() {
						tmp16 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp17 := lang.Apply(tmp16, nil)
						_ = tmp17
					}()
					var tmp18 any
					var tmp19 any
					{ // let
						// let binding "and__0__auto__"
						tmp20 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_level_STAR_)
						var v21 any = tmp20
						_ = v21
						var tmp22 any
						if lang.IsTruthy(v21) {
							tmp23 := checkDerefVar(var_glojure_DOT_core_neg_QMARK_)
							tmp24 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_level_STAR_)
							tmp25 := lang.Apply(tmp23, []any{tmp24})
							tmp22 = tmp25
						} else {
							tmp22 = v21
						}
						tmp19 = tmp22
					} // end let
					if lang.IsTruthy(tmp19) {
						tmp20 := lang.Apply(lang.WriteWriter, []any{v7, "#"})
						tmp18 = tmp20
					} else {
						tmp21 := lang.Apply(lang.WriteWriter, []any{v7, v2})
						_ = tmp21
						var tmp22 any
						{ // let
							// let binding "temp__0__auto__"
							tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp24 := lang.Apply(tmp23, []any{v6})
							var v25 any = tmp24
							_ = v25
							var tmp26 any
							if lang.IsTruthy(v25) {
								var tmp27 any
								{ // let
									// let binding "xs"
									var v28 any = v25
									_ = v28
									var tmp29 any
									var tmp30 any
									{ // let
										// let binding "and__0__auto__"
										tmp31 := checkDerefVar(var_glojure_DOT_core_not)
										tmp32 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
										tmp33 := lang.Apply(tmp31, []any{tmp32})
										var v34 any = tmp33
										_ = v34
										var tmp35 any
										if lang.IsTruthy(v34) {
											tmp36 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_length_STAR_)
											tmp35 = tmp36
										} else {
											tmp35 = v34
										}
										tmp30 = tmp35
									} // end let
									if lang.IsTruthy(tmp30) {
										var tmp31 any
										{ // let
											// let binding "G__194"
											var v32 any = v28
											_ = v32
											// let binding "vec__195"
											var v33 any = v32
											_ = v33
											// let binding "seq__196"
											tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp35 := lang.Apply(tmp34, []any{v33})
											var v36 any = tmp35
											_ = v36
											// let binding "first__197"
											tmp37 := checkDerefVar(var_glojure_DOT_core_first)
											tmp38 := lang.Apply(tmp37, []any{v36})
											var v39 any = tmp38
											_ = v39
											// let binding "seq__196"
											tmp40 := checkDerefVar(var_glojure_DOT_core_next)
											tmp41 := lang.Apply(tmp40, []any{v36})
											var v42 any = tmp41
											_ = v42
											// let binding "x"
											var v43 any = v39
											_ = v43
											// let binding "xs"
											var v44 any = v42
											_ = v44
											// let binding "print-length"
											tmp45 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_length_STAR_)
											var v46 any = tmp45
											_ = v46
											var tmp47 any
											{ // let
												// let binding "G__194"
												var v48 any = v32
												_ = v48
												// let binding "print-length"
												var v49 any = v46
												_ = v49
												for {
													var tmp50 any
													{ // let
														// let binding "vec__198"
														var v51 any = v48
														_ = v51
														// let binding "seq__199"
														tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp53 := lang.Apply(tmp52, []any{v51})
														var v54 any = tmp53
														_ = v54
														// let binding "first__200"
														tmp55 := checkDerefVar(var_glojure_DOT_core_first)
														tmp56 := lang.Apply(tmp55, []any{v54})
														var v57 any = tmp56
														_ = v57
														// let binding "seq__199"
														tmp58 := checkDerefVar(var_glojure_DOT_core_next)
														tmp59 := lang.Apply(tmp58, []any{v54})
														var v60 any = tmp59
														_ = v60
														// let binding "x"
														var v61 any = v57
														_ = v61
														// let binding "xs"
														var v62 any = v60
														_ = v62
														// let binding "print-length"
														var v63 any = v49
														_ = v63
														var tmp64 any
														tmp65 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
														tmp66 := lang.Apply(tmp65, []any{v63})
														if lang.IsTruthy(tmp66) {
															tmp67 := lang.Apply(lang.WriteWriter, []any{v7, "..."})
															tmp64 = tmp67
														} else {
															tmp68 := lang.Apply(v3, []any{v61, v7})
															_ = tmp68
															var tmp69 any
															if lang.IsTruthy(v62) {
																tmp70 := lang.Apply(lang.WriteWriter, []any{v7, v4})
																_ = tmp70
																var tmp71 any = v62
																tmp73 := checkDerefVar(var_glojure_DOT_core_dec)
																tmp74 := lang.Apply(tmp73, []any{v63})
																var tmp72 any = tmp74
																v48 = tmp71
																v49 = tmp72
																continue
															} else {
															}
															tmp64 = tmp69
														}
														tmp50 = tmp64
													} // end let
													tmp47 = tmp50
													break
												}
											} // end let
											tmp31 = tmp47
										} // end let
										tmp29 = tmp31
									} else {
										var tmp32 any
										{ // let
											// let binding "G__204"
											var v33 any = v28
											_ = v33
											// let binding "vec__205"
											var v34 any = v33
											_ = v34
											// let binding "seq__206"
											tmp35 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp36 := lang.Apply(tmp35, []any{v34})
											var v37 any = tmp36
											_ = v37
											// let binding "first__207"
											tmp38 := checkDerefVar(var_glojure_DOT_core_first)
											tmp39 := lang.Apply(tmp38, []any{v37})
											var v40 any = tmp39
											_ = v40
											// let binding "seq__206"
											tmp41 := checkDerefVar(var_glojure_DOT_core_next)
											tmp42 := lang.Apply(tmp41, []any{v37})
											var v43 any = tmp42
											_ = v43
											// let binding "x"
											var v44 any = v40
											_ = v44
											// let binding "xs"
											var v45 any = v43
											_ = v45
											var tmp46 any
											{ // let
												// let binding "G__204"
												var v47 any = v33
												_ = v47
												for {
													var tmp48 any
													{ // let
														// let binding "vec__208"
														var v49 any = v47
														_ = v49
														// let binding "seq__209"
														tmp50 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp51 := lang.Apply(tmp50, []any{v49})
														var v52 any = tmp51
														_ = v52
														// let binding "first__210"
														tmp53 := checkDerefVar(var_glojure_DOT_core_first)
														tmp54 := lang.Apply(tmp53, []any{v52})
														var v55 any = tmp54
														_ = v55
														// let binding "seq__209"
														tmp56 := checkDerefVar(var_glojure_DOT_core_next)
														tmp57 := lang.Apply(tmp56, []any{v52})
														var v58 any = tmp57
														_ = v58
														// let binding "x"
														var v59 any = v55
														_ = v59
														// let binding "xs"
														var v60 any = v58
														_ = v60
														tmp61 := lang.Apply(v3, []any{v59, v7})
														_ = tmp61
														var tmp62 any
														if lang.IsTruthy(v60) {
															tmp63 := lang.Apply(lang.WriteWriter, []any{v7, v4})
															_ = tmp63
															var tmp64 any = v60
															v47 = tmp64
															continue
														} else {
														}
														tmp48 = tmp62
													} // end let
													tmp46 = tmp48
													break
												}
											} // end let
											tmp32 = tmp46
										} // end let
										tmp29 = tmp32
									}
									tmp27 = tmp29
								} // end let
								tmp26 = tmp27
							} else {
							}
							tmp22 = tmp26
						} // end let
						_ = tmp22
						tmp23 := lang.Apply(lang.WriteWriter, []any{v7, v5})
						tmp18 = tmp23
					}
					tmp15 = tmp18
				}()
				tmp8 = tmp15
			} // end let
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_print_DASH_sequential = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_sequential.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// protocol?
	{
		tmp0 := sym_protocol_QMARK_.WithMeta(lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(110), kw_column, int(8), kw_end_DASH_line, int(110), kw_end_DASH_column, int(16), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_maybe_DASH_p)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.IAtom)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core_boolean)
				tmp8 := checkDerefVar(var_glojure_DOT_core_deref)
				tmp9 := lang.Apply(tmp8, []any{v2})
				tmp10 := lang.Apply(kw_on_DASH_interface, []any{tmp9})
				tmp11 := lang.Apply(tmp7, []any{tmp10})
				tmp3 = tmp11
			} else {
				tmp3 = false
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_protocol_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_protocol_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pvalues
	{
		tmp0 := sym_pvalues.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_exprs)), kw_doc, "Returns a lazy sequence of the values of the exprs, which are\n  evaluated in parallel", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(7063), kw_end_DASH_line, int(7063))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_glojure_DOT_core_SLASH_pcalls})
				tmp9 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v11 := args[0]
					_ = v11
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.NewVector()
					tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7069), kw_column, int(30), kw_end_DASH_line, int(7069), kw_end_DASH_column, int(31))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp16 := lang.Apply(tmp12, []any{sym_glojure_DOT_core_SLASH_fn, tmp15, v11})
					return tmp16
				})
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7069), kw_column, int(19), kw_end_DASH_line, int(7069), kw_end_DASH_column, int(34))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := lang.Apply(tmp9, []any{tmp12, v4})
				tmp14 := lang.Apply(tmp6, []any{tmp8, tmp13})
				tmp15 := lang.Apply(tmp5, []any{tmp14})
				return tmp15
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_pvalues = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_pvalues.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-ident?
	{
		tmp0 := sym_qualified_DASH_ident_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a symbol or keyword with a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(1618), kw_end_DASH_line, int(1618))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_boolean)
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_ident_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v2})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "and__0__auto__"
						tmp10 := checkDerefVar(var_glojure_DOT_core_namespace)
						tmp11 := lang.Apply(tmp10, []any{v2})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							tmp13 = true
						} else {
							tmp13 = v12
						}
						tmp9 = tmp13
					} // end let
					tmp8 = tmp9
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			tmp5 := lang.Apply(tmp3, []any{tmp4})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_qualified_DASH_ident_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_qualified_DASH_ident_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-keyword?
	{
		tmp0 := sym_qualified_DASH_keyword_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a keyword with a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(1638), kw_end_DASH_line, int(1638))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_boolean)
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v2})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "and__0__auto__"
						tmp10 := checkDerefVar(var_glojure_DOT_core_namespace)
						tmp11 := lang.Apply(tmp10, []any{v2})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							tmp13 = true
						} else {
							tmp13 = v12
						}
						tmp9 = tmp13
					} // end let
					tmp8 = tmp9
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			tmp5 := lang.Apply(tmp3, []any{tmp4})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_qualified_DASH_keyword_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_qualified_DASH_keyword_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-symbol?
	{
		tmp0 := sym_qualified_DASH_symbol_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a symbol with a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(1628), kw_end_DASH_line, int(1628))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_boolean)
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v2})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "and__0__auto__"
						tmp10 := checkDerefVar(var_glojure_DOT_core_namespace)
						tmp11 := lang.Apply(tmp10, []any{v2})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							tmp13 = true
						} else {
							tmp13 = v12
						}
						tmp9 = tmp13
					} // end let
					tmp8 = tmp9
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			tmp5 := lang.Apply(tmp3, []any{tmp4})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_qualified_DASH_symbol_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_qualified_DASH_symbol_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand
	{
		tmp0 := sym_rand.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_n)), kw_doc, "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(4935), kw_end_DASH_line, int(4935))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := lang.Apply(rand16.Float64, nil)
				return tmp2
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core__STAR_)
				tmp4 := checkDerefVar(var_glojure_DOT_core_rand)
				tmp5 := lang.Apply(tmp4, nil)
				tmp6 := lang.Apply(tmp3, []any{v2, tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_rand = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_rand.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand-int
	{
		tmp0 := sym_rand_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns a random integer between 0 (inclusive) and n (exclusive).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4943), kw_end_DASH_line, int(4943))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_int)
			tmp4 := checkDerefVar(var_glojure_DOT_core_rand)
			tmp5 := lang.Apply(tmp4, []any{v2})
			tmp6 := lang.Apply(tmp3, []any{tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_rand_DASH_int = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_rand_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand-nth
	{
		tmp0 := sym_rand_DASH_nth.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(7213), kw_end_DASH_line, int(7213))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_nth)
			tmp4 := checkDerefVar(var_glojure_DOT_core_rand_DASH_int)
			tmp5 := checkDerefVar(var_glojure_DOT_core_count)
			tmp6 := lang.Apply(tmp5, []any{v2})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			tmp8 := lang.Apply(tmp3, []any{v2, tmp7})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_rand_DASH_nth = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_rand_DASH_nth.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// random-sample
	{
		tmp0 := sym_random_DASH_sample.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_prob), lang.NewVector(sym_prob, sym_coll)), kw_doc, "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(7699), kw_end_DASH_line, int(7699))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_filter)
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					tmp6 := checkDerefVar(var_glojure_DOT_core__LT_)
					tmp7 := checkDerefVar(var_glojure_DOT_core_rand)
					tmp8 := lang.Apply(tmp7, nil)
					tmp9 := lang.Apply(tmp6, []any{tmp8, v2})
					return tmp9
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7704), kw_column, int(14), kw_end_DASH_line, int(7704), kw_end_DASH_column, int(37))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp7 := lang.Apply(tmp3, []any{tmp6})
				return tmp7
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_filter)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v6 := args[0]
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core__LT_)
					tmp8 := checkDerefVar(var_glojure_DOT_core_rand)
					tmp9 := lang.Apply(tmp8, nil)
					tmp10 := lang.Apply(tmp7, []any{tmp9, v2})
					return tmp10
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7706), kw_column, int(14), kw_end_DASH_line, int(7706), kw_end_DASH_column, int(37))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7, v3})
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_random_DASH_sample = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_random_DASH_sample.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-groups
	{
		tmp0 := sym_re_DASH_groups.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m)), kw_doc, "Returns the groups from the most recent match/find. If there are no\n  nested groups, returns a string of the entire match. If there are\n  nested groups, returns a vector of the groups, the first element\n  being the entire match.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4882), kw_end_DASH_line, int(4882))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "gc"
				tmp4, _ := lang.FieldOrMethod(v2, "groupCount")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("groupCount is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v6})
				if lang.IsTruthy(tmp9) {
					tmp10, _ := lang.FieldOrMethod(v2, "group")
					if reflect.TypeOf(tmp10).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("group is not a function")))
					}
					tmp11 := lang.Apply(tmp10, []any{})
					tmp7 = tmp11
				} else {
					var tmp12 any
					{ // let
						// let binding "ret"
						tmp13 := lang.NewVector()
						tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4893), kw_column, int(20), kw_end_DASH_line, int(4893), kw_end_DASH_column, int(21))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v16 any = tmp15
						_ = v16
						// let binding "c"
						var v17 any = int64(0)
						_ = v17
						for {
							var tmp18 any
							tmp19 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
							tmp20 := lang.Apply(tmp19, []any{v17, v6})
							if lang.IsTruthy(tmp20) {
								tmp22 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp23, _ := lang.FieldOrMethod(v2, "groupInt")
								if reflect.TypeOf(tmp23).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("groupInt is not a function")))
								}
								tmp24 := lang.Apply(tmp23, []any{v17})
								tmp25 := lang.Apply(tmp22, []any{v16, tmp24})
								var tmp21 any = tmp25
								tmp27 := checkDerefVar(var_glojure_DOT_core_inc)
								tmp28 := lang.Apply(tmp27, []any{v17})
								var tmp26 any = tmp28
								v16 = tmp21
								v17 = tmp26
								continue
							} else {
								tmp18 = v16
							}
							tmp12 = tmp18
							break
						}
					} // end let
					tmp7 = tmp12
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_re_DASH_groups = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_re_DASH_groups.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-matches
	{
		tmp0 := sym_re_DASH_matches.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_re, sym_s)), kw_doc, "Returns the match, if any, of string to pattern, using\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\n  groups.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4910), kw_end_DASH_line, int(4910))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "m"
				tmp5 := checkDerefVar(var_glojure_DOT_core_re_DASH_matcher)
				tmp6 := lang.Apply(tmp5, []any{v2, v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				tmp9, _ := lang.FieldOrMethod(v7, "matches")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("matches is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{})
				if lang.IsTruthy(tmp10) {
					tmp11 := checkDerefVar(var_glojure_DOT_core_re_DASH_groups)
					tmp12 := lang.Apply(tmp11, []any{v7})
					tmp8 = tmp12
				} else {
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_re_DASH_matches = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_re_DASH_matches.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-seq
	{
		tmp0 := sym_re_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_re, sym_s)), kw_doc, "Returns a lazy sequence of successive matches of pattern in string,\n  using java.util.regex.Matcher.find(), each such match processed with\n  re-groups.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4898), kw_end_DASH_line, int(4898))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "m"
				tmp5 := checkDerefVar(var_glojure_DOT_core_re_DASH_matcher)
				tmp6 := lang.Apply(tmp5, []any{v2, v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 lang.FnFunc
				{ // function step
					var v9 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						var tmp10 any
						tmp11, _ := lang.FieldOrMethod(v7, "find")
						if reflect.TypeOf(tmp11).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("find is not a function")))
						}
						tmp12 := lang.Apply(tmp11, []any{})
						if lang.IsTruthy(tmp12) {
							tmp13 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp14 := checkDerefVar(var_glojure_DOT_core_re_DASH_groups)
							tmp15 := lang.Apply(tmp14, []any{v7})
							var tmp16 lang.FnFunc
							tmp16 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								tmp17 := lang.Apply(v9, nil)
								return tmp17
							})
							tmp17 := lang.Apply(lang.NewLazySeq, []any{tmp16})
							tmp18 := lang.Apply(tmp13, []any{tmp15, tmp17})
							tmp10 = tmp18
						} else {
						}
						return tmp10
					})
					v9 = tmp8
					_ = v9
				}
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4906), kw_column, int(6), kw_end_DASH_line, int(4908), kw_end_DASH_column, int(49))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := lang.Apply(tmp10, nil)
				tmp4 = tmp11
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_re_DASH_seq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_re_DASH_seq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// refer
	{
		tmp0 := sym_refer.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns_DASH_sym, sym__AMP_, sym_filters)), kw_doc, "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(4216), kw_end_DASH_line, int(4216))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "ns"
					var tmp5 any
					{ // let
						// let binding "or__0__auto__"
						tmp6 := checkDerefVar(var_glojure_DOT_core_find_DASH_ns)
						tmp7 := lang.Apply(tmp6, []any{v2})
						var v8 any = tmp7
						_ = v8
						var tmp9 any
						if lang.IsTruthy(v8) {
							tmp9 = v8
						} else {
							tmp10 := checkDerefVar(var_glojure_DOT_core_str)
							tmp11 := lang.Apply(tmp10, []any{"No namespace: ", v2})
							tmp12 := lang.Apply(errors8.New, []any{tmp11})
							panic(tmp12)
						}
						tmp5 = tmp9
					} // end let
					var v6 any = tmp5
					_ = v6
					// let binding "fs"
					tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp8 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
					var v10 any = tmp9
					_ = v10
					// let binding "nspublics"
					tmp11 := checkDerefVar(var_glojure_DOT_core_ns_DASH_publics)
					tmp12 := lang.Apply(tmp11, []any{v6})
					var v13 any = tmp12
					_ = v13
					// let binding "rename"
					var tmp14 any
					{ // let
						// let binding "or__0__auto__"
						tmp15 := lang.Apply(kw_rename, []any{v10})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						if lang.IsTruthy(v16) {
							tmp17 = v16
						} else {
							tmp18 := lang.NewMap()
							tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4236), kw_column, int(35), kw_end_DASH_line, int(4236), kw_end_DASH_column, int(36))
							tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp20
						}
						tmp14 = tmp17
					} // end let
					var v15 any = tmp14
					_ = v15
					// let binding "exclude"
					tmp16 := checkDerefVar(var_glojure_DOT_core_set)
					tmp17 := lang.Apply(kw_exclude, []any{v10})
					tmp18 := lang.Apply(tmp16, []any{tmp17})
					var v19 any = tmp18
					_ = v19
					// let binding "to-do"
					var tmp20 any
					tmp21 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp22 := lang.Apply(kw_refer, []any{v10})
					tmp23 := lang.Apply(tmp21, []any{kw_all, tmp22})
					if lang.IsTruthy(tmp23) {
						tmp24 := checkDerefVar(var_glojure_DOT_core_keys)
						tmp25 := lang.Apply(tmp24, []any{v13})
						tmp20 = tmp25
					} else {
						var tmp26 any
						{ // let
							// let binding "or__0__auto__"
							tmp27 := lang.Apply(kw_refer, []any{v10})
							var v28 any = tmp27
							_ = v28
							var tmp29 any
							if lang.IsTruthy(v28) {
								tmp29 = v28
							} else {
								var tmp30 any
								{ // let
									// let binding "or__0__auto__"
									tmp31 := lang.Apply(kw_only, []any{v10})
									var v32 any = tmp31
									_ = v32
									var tmp33 any
									if lang.IsTruthy(v32) {
										tmp33 = v32
									} else {
										tmp34 := checkDerefVar(var_glojure_DOT_core_keys)
										tmp35 := lang.Apply(tmp34, []any{v13})
										tmp33 = tmp35
									}
									tmp30 = tmp33
								} // end let
								tmp29 = tmp30
							}
							tmp26 = tmp29
						} // end let
						tmp20 = tmp26
					}
					var v27 any = tmp20
					_ = v27
					var tmp28 any
					var tmp29 any
					{ // let
						// let binding "and__0__auto__"
						var v30 any = v27
						_ = v30
						var tmp31 any
						if lang.IsTruthy(v30) {
							tmp32 := checkDerefVar(var_glojure_DOT_core_not)
							tmp33 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
							tmp34 := reflect.TypeOf((*lang.Sequential)(nil)).Elem()
							tmp35 := lang.Apply(tmp33, []any{tmp34, v27})
							tmp36 := lang.Apply(tmp32, []any{tmp35})
							tmp31 = tmp36
						} else {
							tmp31 = v30
						}
						tmp29 = tmp31
					} // end let
					if lang.IsTruthy(tmp29) {
						tmp30 := lang.Apply(errors8.New, []any{":only/:refer value must be a sequential collection of symbols"})
						panic(tmp30)
					} else {
					}
					_ = tmp28
					var tmp31 any
					{ // let
						// let binding "seq_9"
						tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp33 := lang.Apply(tmp32, []any{v27})
						var v34 any = tmp33
						_ = v34
						// let binding "chunk_10"
						var v35 any = nil
						_ = v35
						// let binding "count_11"
						var v36 any = int64(0)
						_ = v36
						// let binding "i_12"
						var v37 any = int64(0)
						_ = v37
						for {
							var tmp38 any
							tmp39 := checkDerefVar(var_glojure_DOT_core__LT_)
							tmp40 := lang.Apply(tmp39, []any{v37, v36})
							if lang.IsTruthy(tmp40) {
								var tmp41 any
								{ // let
									// let binding "sym"
									tmp42, _ := lang.FieldOrMethod(v35, "nth")
									if reflect.TypeOf(tmp42).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp43 := lang.Apply(tmp42, []any{v37})
									var v44 any = tmp43
									_ = v44
									var tmp45 any
									tmp46 := lang.Apply(v19, []any{v44})
									if lang.IsTruthy(tmp46) {
									} else {
										var tmp47 any
										{ // let
											// let binding "v"
											tmp48 := lang.Apply(v13, []any{v44})
											var v49 any = tmp48
											_ = v49
											var tmp50 any
											if lang.IsTruthy(v49) {
											} else {
												panic(nil)
											}
											_ = tmp50
											tmp52 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
											var tmp53 any
											{ // let
												// let binding "or__0__auto__"
												tmp54 := lang.Apply(v15, []any{v44})
												var v55 any = tmp54
												_ = v55
												var tmp56 any
												if lang.IsTruthy(v55) {
													tmp56 = v55
												} else {
													tmp56 = v44
												}
												tmp53 = tmp56
											} // end let
											tmp54, _ := lang.FieldOrMethod(tmp52, "Refer")
											if reflect.TypeOf(tmp54).Kind() != reflect.Func {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("Refer is not a function")))
											}
											tmp55 := lang.Apply(tmp54, []any{tmp53, v49})
											tmp47 = tmp55
										} // end let
										tmp45 = tmp47
									}
									_ = tmp45
									var tmp48 any = v34
									var tmp49 any = v35
									var tmp50 any = v36
									tmp52 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
									tmp53 := lang.Apply(tmp52, []any{v37})
									var tmp51 any = tmp53
									v34 = tmp48
									v35 = tmp49
									v36 = tmp50
									v37 = tmp51
									continue
								} // end let
								tmp38 = tmp41
							} else {
								var tmp42 any
								{ // let
									// let binding "temp__0__auto__"
									tmp43 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp44 := lang.Apply(tmp43, []any{v34})
									var v45 any = tmp44
									_ = v45
									var tmp46 any
									if lang.IsTruthy(v45) {
										var tmp47 any
										{ // let
											// let binding "seq_9"
											var v48 any = v45
											_ = v48
											var tmp49 any
											tmp50 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
											tmp51 := lang.Apply(tmp50, []any{v48})
											if lang.IsTruthy(tmp51) {
												var tmp52 any
												{ // let
													// let binding "c__0__auto__"
													tmp53 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
													tmp54 := lang.Apply(tmp53, []any{v48})
													var v55 any = tmp54
													_ = v55
													tmp57 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
													tmp58 := lang.Apply(tmp57, []any{v48})
													var tmp56 any = tmp58
													var tmp59 any = v55
													tmp61 := checkDerefVar(var_glojure_DOT_core_int)
													tmp62 := checkDerefVar(var_glojure_DOT_core_count)
													tmp63 := lang.Apply(tmp62, []any{v55})
													tmp64 := lang.Apply(tmp61, []any{tmp63})
													var tmp60 any = tmp64
													tmp66 := checkDerefVar(var_glojure_DOT_core_int)
													tmp67 := lang.Apply(tmp66, []any{int64(0)})
													var tmp65 any = tmp67
													v34 = tmp56
													v35 = tmp59
													v36 = tmp60
													v37 = tmp65
													continue
												} // end let
												tmp49 = tmp52
											} else {
												var tmp53 any
												{ // let
													// let binding "sym"
													tmp54 := checkDerefVar(var_glojure_DOT_core_first)
													tmp55 := lang.Apply(tmp54, []any{v48})
													var v56 any = tmp55
													_ = v56
													var tmp57 any
													tmp58 := lang.Apply(v19, []any{v56})
													if lang.IsTruthy(tmp58) {
													} else {
														var tmp59 any
														{ // let
															// let binding "v"
															tmp60 := lang.Apply(v13, []any{v56})
															var v61 any = tmp60
															_ = v61
															var tmp62 any
															if lang.IsTruthy(v61) {
															} else {
																panic(nil)
															}
															_ = tmp62
															tmp64 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
															var tmp65 any
															{ // let
																// let binding "or__0__auto__"
																tmp66 := lang.Apply(v15, []any{v56})
																var v67 any = tmp66
																_ = v67
																var tmp68 any
																if lang.IsTruthy(v67) {
																	tmp68 = v67
																} else {
																	tmp68 = v56
																}
																tmp65 = tmp68
															} // end let
															tmp66, _ := lang.FieldOrMethod(tmp64, "Refer")
															if reflect.TypeOf(tmp66).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("Refer is not a function")))
															}
															tmp67 := lang.Apply(tmp66, []any{tmp65, v61})
															tmp59 = tmp67
														} // end let
														tmp57 = tmp59
													}
													_ = tmp57
													tmp61 := checkDerefVar(var_glojure_DOT_core_next)
													tmp62 := lang.Apply(tmp61, []any{v48})
													var tmp60 any = tmp62
													var tmp63 any = nil
													var tmp64 any = int64(0)
													var tmp65 any = int64(0)
													v34 = tmp60
													v35 = tmp63
													v36 = tmp64
													v37 = tmp65
													continue
												} // end let
												tmp49 = tmp53
											}
											tmp47 = tmp49
										} // end let
										tmp46 = tmp47
									} else {
									}
									tmp42 = tmp46
								} // end let
								tmp38 = tmp42
							}
							tmp31 = tmp38
							break
						}
					} // end let
					tmp4 = tmp31
				} // end let
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_refer = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_refer.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove
	{
		tmp0 := sym_remove.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred), lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2818), kw_end_DASH_line, int(2818))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_filter)
				tmp4 := checkDerefVar(var_glojure_DOT_core_complement)
				tmp5 := lang.Apply(tmp4, []any{v2})
				tmp6 := lang.Apply(tmp3, []any{tmp5})
				return tmp6
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_filter)
				tmp5 := checkDerefVar(var_glojure_DOT_core_complement)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{tmp6, v3})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_remove = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_remove.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace
	{
		tmp0 := sym_replace.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_smap), lang.NewVector(sym_smap, sym_coll)), kw_doc, "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5082), kw_end_DASH_line, int(5082))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_find)
						tmp8 := lang.Apply(tmp7, []any{v2, v5})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "e"
								var v12 any = v9
								_ = v12
								tmp13 := checkDerefVar(var_glojure_DOT_core_val)
								tmp14 := lang.Apply(tmp13, []any{v12})
								tmp11 = tmp14
							} // end let
							tmp10 = tmp11
						} else {
							tmp10 = v5
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5090), kw_column, int(11), kw_end_DASH_line, int(5090), kw_end_DASH_column, int(47))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp7 := lang.Apply(tmp3, []any{tmp6})
				return tmp7
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp8 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v9 := args[0]
						_ = v9
						v10 := args[1]
						_ = v10
						var tmp11 any
						{ // let
							// let binding "temp__0__auto__"
							tmp12 := checkDerefVar(var_glojure_DOT_core_find)
							tmp13 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp14 := lang.Apply(tmp13, []any{v9, v10})
							tmp15 := lang.Apply(tmp12, []any{v2, tmp14})
							var v16 any = tmp15
							_ = v16
							var tmp17 any
							if lang.IsTruthy(v16) {
								var tmp18 any
								{ // let
									// let binding "e"
									var v19 any = v16
									_ = v19
									tmp20 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp21 := checkDerefVar(var_glojure_DOT_core_val)
									tmp22 := lang.Apply(tmp21, []any{v19})
									tmp23 := lang.Apply(tmp20, []any{v9, v10, tmp22})
									tmp18 = tmp23
								} // end let
								tmp17 = tmp18
							} else {
								tmp17 = v9
							}
							tmp11 = tmp17
						} // end let
						return tmp11
					})
					tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5093), kw_column, int(17), kw_end_DASH_line, int(5096), kw_end_DASH_column, int(23))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp11 := checkDerefVar(var_glojure_DOT_core_range)
					tmp12 := checkDerefVar(var_glojure_DOT_core_count)
					tmp13 := lang.Apply(tmp12, []any{v3})
					tmp14 := lang.Apply(tmp11, []any{tmp13})
					tmp15 := lang.Apply(tmp7, []any{tmp10, v3, tmp14})
					tmp4 = tmp15
				} else {
					tmp16 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp17 lang.FnFunc
					tmp17 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v18 := args[0]
						_ = v18
						var tmp19 any
						{ // let
							// let binding "temp__0__auto__"
							tmp20 := checkDerefVar(var_glojure_DOT_core_find)
							tmp21 := lang.Apply(tmp20, []any{v2, v18})
							var v22 any = tmp21
							_ = v22
							var tmp23 any
							if lang.IsTruthy(v22) {
								var tmp24 any
								{ // let
									// let binding "e"
									var v25 any = v22
									_ = v25
									tmp26 := checkDerefVar(var_glojure_DOT_core_val)
									tmp27 := lang.Apply(tmp26, []any{v25})
									tmp24 = tmp27
								} // end let
								tmp23 = tmp24
							} else {
								tmp23 = v18
							}
							tmp19 = tmp23
						} // end let
						return tmp19
					})
					tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5098), kw_column, int(13), kw_end_DASH_line, int(5098), kw_end_DASH_column, int(49))
					tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp20 := lang.Apply(tmp16, []any{tmp19, v3})
					tmp4 = tmp20
				}
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_replace = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_replace.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// restart-agent
	{
		tmp0 := sym_restart_DASH_agent.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_new_DASH_state, sym__AMP_, sym_options)), kw_doc, "When an agent is failed, changes the agent state to new-state and\n  then un-fails the agent so that sends are allowed again.  If\n  a :clear-actions true option is given, any actions queued on the\n  agent that were being held while it was failed will be discarded,\n  otherwise those held actions will proceed.  The new-state must pass\n  the validator if any, or restart will throw an exception and the\n  agent will remain failed with its old state and error.  Watchers, if\n  any, will NOT be notified of the new state.  Throws an exception if\n  the agent is not failed.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(2175), kw_end_DASH_line, int(2175))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "opts"
					tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp7 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := lang.Apply(kw_clear_DASH_actions, []any{v9})
					if lang.IsTruthy(tmp11) {
						tmp10 = true
					} else {
						tmp10 = false
					}
					tmp12, _ := lang.FieldOrMethod(v2, "restart")
					if reflect.TypeOf(tmp12).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("restart is not a function")))
					}
					tmp13 := lang.Apply(tmp12, []any{v3, tmp10})
					tmp5 = tmp13
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_restart_DASH_agent = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_restart_DASH_agent.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// root-directory
	{
		tmp0 := sym_root_DASH_directory.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_lib)), kw_doc, "Returns the root resource path for a lib", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(8), kw_line, int(5871), kw_end_DASH_line, int(5871), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "d"
				tmp4 := checkDerefVar(var_glojure_DOT_core_root_DASH_resource)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_subs)
				tmp8 := lang.Apply(strings11.LastIndex, []any{v6, "/"})
				tmp9 := lang.Apply(tmp7, []any{v6, int64(0), tmp8})
				tmp3 = tmp9
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_root_DASH_directory = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_root_DASH_directory.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rsubseq
	{
		tmp0 := sym_rsubseq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sc, sym_test, sym_key), lang.NewVector(sym_sc, sym_start_DASH_test, sym_start_DASH_key, sym_end_DASH_test, sym_end_DASH_key)), kw_doc, "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5150), kw_end_DASH_line, int(5150))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "include"
					tmp6 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
					tmp7 := lang.Apply(tmp6, []any{v2, v3, v4})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core__LT_)
					tmp11 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
					tmp12 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{tmp10, tmp11}))
					tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5158), kw_column, int(11), kw_end_DASH_line, int(5158), kw_end_DASH_column, int(17))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := lang.Apply(tmp14, []any{v3})
					if lang.IsTruthy(tmp15) {
						var tmp16 any
						{ // let
							// let binding "temp__0__auto__"
							tmp17, _ := lang.FieldOrMethod(v2, "seqFrom")
							if reflect.TypeOf(tmp17).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
							}
							tmp18 := lang.Apply(tmp17, []any{v4, false})
							var v19 any = tmp18
							_ = v19
							var tmp20 any
							if lang.IsTruthy(v19) {
								var tmp21 any
								{ // let
									// let binding "vec__74"
									var v22 any = v19
									_ = v22
									// let binding "e"
									tmp23 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp24 := lang.Apply(tmp23, []any{v22, int64(0), nil})
									var v25 any = tmp24
									_ = v25
									// let binding "s"
									var v26 any = v22
									_ = v26
									var tmp27 any
									tmp28 := lang.Apply(v8, []any{v25})
									if lang.IsTruthy(tmp28) {
										tmp27 = v26
									} else {
										tmp29 := checkDerefVar(var_glojure_DOT_core_next)
										tmp30 := lang.Apply(tmp29, []any{v26})
										tmp27 = tmp30
									}
									tmp21 = tmp27
								} // end let
								tmp20 = tmp21
							} else {
							}
							tmp16 = tmp20
						} // end let
						tmp9 = tmp16
					} else {
						tmp17 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
						tmp18, _ := lang.FieldOrMethod(v2, "seq")
						if reflect.TypeOf(tmp18).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("seq is not a function")))
						}
						tmp19 := lang.Apply(tmp18, []any{false})
						tmp20 := lang.Apply(tmp17, []any{v8, tmp19})
						tmp9 = tmp20
					}
					tmp5 = tmp9
				} // end let
				return tmp5
			case 5:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "temp__0__auto__"
					tmp8, _ := lang.FieldOrMethod(v2, "seqFrom")
					if reflect.TypeOf(tmp8).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
					}
					tmp9 := lang.Apply(tmp8, []any{v6, false})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						var tmp12 any
						{ // let
							// let binding "vec__77"
							var v13 any = v10
							_ = v13
							// let binding "e"
							tmp14 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp15 := lang.Apply(tmp14, []any{v13, int64(0), nil})
							var v16 any = tmp15
							_ = v16
							// let binding "s"
							var v17 any = v13
							_ = v17
							tmp18 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
							tmp19 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
							tmp20 := lang.Apply(tmp19, []any{v2, v3, v4})
							var tmp21 any
							tmp22 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
							tmp23 := lang.Apply(tmp22, []any{v2, v5, v6})
							tmp24 := lang.Apply(tmp23, []any{v16})
							if lang.IsTruthy(tmp24) {
								tmp21 = v17
							} else {
								tmp25 := checkDerefVar(var_glojure_DOT_core_next)
								tmp26 := lang.Apply(tmp25, []any{v17})
								tmp21 = tmp26
							}
							tmp27 := lang.Apply(tmp18, []any{tmp20, tmp21})
							tmp12 = tmp27
						} // end let
						tmp11 = tmp12
					} else {
					}
					tmp7 = tmp11
				} // end let
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_rsubseq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_rsubseq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send-via
	{
		tmp0 := sym_send_DASH_via.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_executor, sym_a, sym_f, sym__AMP_, sym_args)), kw_doc, "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread supplied by executor, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2099), kw_end_DASH_line, int(2099))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					tmp7 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
					tmp8 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp9 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_agent_STAR_)
					tmp10 := lang.Apply(tmp8, []any{tmp9, v3})
					tmp11 := lang.Apply(tmp7, []any{tmp10})
					_ = tmp11
					var tmp12 any
					func() {
						defer func() {
							tmp13 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
							tmp14 := lang.Apply(tmp13, nil)
							_ = tmp14
						}()
						tmp15 := checkDerefVar(var_glojure_DOT_core_binding_DASH_conveyor_DASH_fn)
						tmp16 := lang.Apply(tmp15, []any{v4})
						tmp12 = tmp16
					}()
					tmp6 = tmp12
				} // end let
				tmp7, _ := lang.FieldOrMethod(v3, "dispatch")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("dispatch is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{tmp6, v5, v2})
				return tmp8
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_send_DASH_via = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_send_DASH_via.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sequence
	{
		tmp0 := sym_sequence.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll), lang.NewVector(sym_xform, sym_coll), lang.NewVector(sym_xform, sym_coll, sym__AMP_, sym_colls)), kw_doc, "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2639), kw_end_DASH_line, int(2639))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
				tmp5 := lang.Apply(tmp4, []any{v2})
				if lang.IsTruthy(tmp5) {
					tmp3 = v2
				} else {
					var tmp6 any
					{ // let
						// let binding "or__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v2})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							tmp10 = v9
						} else {
							tmp10 = lang.NewList()
						}
						tmp6 = tmp10
					} // end let
					tmp3 = tmp6
				}
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "or__0__auto__"
					tmp5 := lang.Apply(nil, []any{v3})
					tmp6 := lang.Apply(nil, []any{v2, tmp5})
					tmp7 := lang.Apply(nil, []any{tmp6})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp9 = v8
					} else {
						tmp9 = lang.NewList()
					}
					tmp4 = tmp9
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "or__0__auto__"
					tmp6 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp7 lang.FnFunc
					tmp7 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v8 := args[0]
						_ = v8
						tmp9 := lang.Apply(nil, []any{v8})
						return tmp9
					})
					tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2661), kw_column, int(17), kw_end_DASH_line, int(2661), kw_end_DASH_column, int(41))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp10 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp11 := lang.Apply(tmp10, []any{v3, v4})
					tmp12 := lang.Apply(tmp6, []any{tmp9, tmp11})
					tmp13 := lang.Apply(nil, []any{v2, tmp12})
					tmp14 := lang.Apply(nil, []any{tmp13})
					var v15 any = tmp14
					_ = v15
					var tmp16 any
					if lang.IsTruthy(v15) {
						tmp16 = v15
					} else {
						tmp16 = lang.NewList()
					}
					tmp5 = tmp16
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_sequence = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_sequence.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// setup-reference
	{
		tmp0 := sym_setup_DASH_reference.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(2043), kw_column, int(7), kw_end_DASH_line, int(2044), kw_end_DASH_column, int(17), kw_arglists, lang.NewList(lang.NewVector(sym_r, sym_options)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "opts"
				tmp5 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				tmp10 := lang.Apply(kw_meta, []any{v8})
				if lang.IsTruthy(tmp10) {
					tmp11 := lang.Apply(kw_meta, []any{v8})
					tmp12, _ := lang.FieldOrMethod(v2, "ResetMeta")
					if reflect.TypeOf(tmp12).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ResetMeta is not a function")))
					}
					tmp13 := lang.Apply(tmp12, []any{tmp11})
					tmp9 = tmp13
				} else {
				}
				_ = tmp9
				var tmp14 any
				tmp15 := lang.Apply(kw_validator, []any{v8})
				if lang.IsTruthy(tmp15) {
					tmp16 := lang.Apply(kw_validator, []any{v8})
					tmp17, _ := lang.FieldOrMethod(v2, "setValidator")
					if reflect.TypeOf(tmp17).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setValidator is not a function")))
					}
					tmp18 := lang.Apply(tmp17, []any{tmp16})
					tmp14 = tmp18
				} else {
				}
				_ = tmp14
				tmp4 = v2
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_setup_DASH_reference = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_setup_DASH_reference.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shift-mask
	{
		tmp0 := sym_shift_DASH_mask.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6598), kw_column, int(8), kw_end_DASH_line, int(6598), kw_end_DASH_column, int(17), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_shift, sym_mask, sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and)
			tmp6 := checkDerefVar(var_glojure_DOT_core_bit_DASH_shift_DASH_right)
			tmp7 := lang.Apply(tmp6, []any{v4, v2})
			tmp8 := lang.Apply(tmp5, []any{tmp7, v3})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_shift_DASH_mask = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_shift_DASH_mask.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sort
	{
		tmp0 := sym_sort.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll), lang.NewVector(sym_comp, sym_coll)), kw_doc, "Returns a sorted sequence of the items in coll. If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3085), kw_end_DASH_line, int(3085))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_sort)
				tmp4 := checkDerefVar(var_glojure_DOT_core_compare)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					var tmp7 any
					{ // let
						// let binding "a"
						tmp8 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
						tmp9 := lang.Apply(tmp8, []any{v3})
						var v10 any = tmp9
						_ = v10
						tmp11 := lang.Apply(lang.SortSlice, []any{v10, v2})
						_ = tmp11
						tmp12 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := lang.Apply(tmp13, []any{v10})
						tmp15 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp16 := lang.Apply(tmp15, []any{v3})
						tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
						tmp7 = tmp17
					} // end let
					tmp4 = tmp7
				} else {
					tmp4 = lang.NewList()
				}
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_sort = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_sort.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sort-by
	{
		tmp0 := sym_sort_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_keyfn, sym_coll), lang.NewVector(sym_keyfn, sym_comp, sym_coll)), kw_doc, "Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn item).  If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3102), kw_end_DASH_line, int(3102))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_sort_DASH_by)
				tmp5 := checkDerefVar(var_glojure_DOT_core_compare)
				tmp6 := lang.Apply(tmp4, []any{v2, tmp5, v3})
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_sort)
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v7 := args[0]
					_ = v7
					v8 := args[1]
					_ = v8
					tmp9 := lang.Apply(v2, []any{v7})
					tmp10 := lang.Apply(v2, []any{v8})
					tmp11 := lang.Apply(v3, []any{tmp9, tmp10})
					return tmp11
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3114), kw_column, int(10), kw_end_DASH_line, int(3114), kw_end_DASH_column, int(46))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(tmp5, []any{tmp8, v4})
				return tmp9
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_sort_DASH_by = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_sort_DASH_by.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// spit
	{
		tmp0 := sym_spit.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_content, sym__AMP_, sym_options)), kw_doc, "Opposite of slurp.  Opens f with writer, writes content, then\n  closes f. Options passed to glojure.java.io/writer.", kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6994), kw_end_DASH_line, int(6994))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "w"
					tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp7 := lang.Apply(tmp6, []any{nil, v2, v4})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					func() {
						defer func() {
							tmp10, ok := lang.FieldOrMethod(v8, "close")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "close")))
							}
							var tmp11 any
							switch reflect.TypeOf(tmp10).Kind() {
							case reflect.Func:
								tmp11 = lang.Apply(tmp10, nil)
							default:
								tmp11 = tmp10
							}
							_ = tmp11
						}()
						tmp12 := checkDerefVar(var_glojure_DOT_core_str)
						tmp13 := lang.Apply(tmp12, []any{v3})
						tmp14 := lang.Apply(lang.WriteWriter, []any{v8, tmp13})
						tmp9 = tmp14
					}()
					tmp5 = tmp9
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_spit = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_spit.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// strip-ns
	{
		tmp0 := sym_strip_DASH_ns.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(255), kw_column, int(8), kw_end_DASH_line, int(255), kw_end_DASH_column, int(15), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_named)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp6 := checkDerefVar(var_glojure_DOT_core_symbol)
				tmp7 := checkDerefVar(var_glojure_DOT_core_name)
				tmp8 := lang.Apply(tmp7, []any{v2})
				tmp9 := lang.Apply(tmp6, []any{nil, tmp8})
				tmp3 = tmp9
			} else {
				tmp10 := checkDerefVar(var_glojure_DOT_core_keyword)
				tmp11 := checkDerefVar(var_glojure_DOT_core_name)
				tmp12 := lang.Apply(tmp11, []any{v2})
				tmp13 := lang.Apply(tmp10, []any{nil, tmp12})
				tmp3 = tmp13
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_strip_DASH_ns = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_strip_DASH_ns.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subseq
	{
		tmp0 := sym_subseq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sc, sym_test, sym_key), lang.NewVector(sym_sc, sym_start_DASH_test, sym_start_DASH_key, sym_end_DASH_test, sym_end_DASH_key)), kw_doc, "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5133), kw_end_DASH_line, int(5133))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "include"
					tmp6 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
					tmp7 := lang.Apply(tmp6, []any{v2, v3, v4})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core__GT_)
					tmp11 := checkDerefVar(var_glojure_DOT_core__GT__EQ_)
					tmp12 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{tmp10, tmp11}))
					tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5141), kw_column, int(11), kw_end_DASH_line, int(5141), kw_end_DASH_column, int(17))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := lang.Apply(tmp14, []any{v3})
					if lang.IsTruthy(tmp15) {
						var tmp16 any
						{ // let
							// let binding "temp__0__auto__"
							tmp17, _ := lang.FieldOrMethod(v2, "seqFrom")
							if reflect.TypeOf(tmp17).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
							}
							tmp18 := lang.Apply(tmp17, []any{v4, true})
							var v19 any = tmp18
							_ = v19
							var tmp20 any
							if lang.IsTruthy(v19) {
								var tmp21 any
								{ // let
									// let binding "vec__68"
									var v22 any = v19
									_ = v22
									// let binding "e"
									tmp23 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp24 := lang.Apply(tmp23, []any{v22, int64(0), nil})
									var v25 any = tmp24
									_ = v25
									// let binding "s"
									var v26 any = v22
									_ = v26
									var tmp27 any
									tmp28 := lang.Apply(v8, []any{v25})
									if lang.IsTruthy(tmp28) {
										tmp27 = v26
									} else {
										tmp29 := checkDerefVar(var_glojure_DOT_core_next)
										tmp30 := lang.Apply(tmp29, []any{v26})
										tmp27 = tmp30
									}
									tmp21 = tmp27
								} // end let
								tmp20 = tmp21
							} else {
							}
							tmp16 = tmp20
						} // end let
						tmp9 = tmp16
					} else {
						tmp17 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
						tmp18, _ := lang.FieldOrMethod(v2, "seq")
						if reflect.TypeOf(tmp18).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("seq is not a function")))
						}
						tmp19 := lang.Apply(tmp18, []any{true})
						tmp20 := lang.Apply(tmp17, []any{v8, tmp19})
						tmp9 = tmp20
					}
					tmp5 = tmp9
				} // end let
				return tmp5
			case 5:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "temp__0__auto__"
					tmp8, _ := lang.FieldOrMethod(v2, "seqFrom")
					if reflect.TypeOf(tmp8).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
					}
					tmp9 := lang.Apply(tmp8, []any{v4, true})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						var tmp12 any
						{ // let
							// let binding "vec__71"
							var v13 any = v10
							_ = v13
							// let binding "e"
							tmp14 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp15 := lang.Apply(tmp14, []any{v13, int64(0), nil})
							var v16 any = tmp15
							_ = v16
							// let binding "s"
							var v17 any = v13
							_ = v17
							tmp18 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
							tmp19 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
							tmp20 := lang.Apply(tmp19, []any{v2, v5, v6})
							var tmp21 any
							tmp22 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
							tmp23 := lang.Apply(tmp22, []any{v2, v3, v4})
							tmp24 := lang.Apply(tmp23, []any{v16})
							if lang.IsTruthy(tmp24) {
								tmp21 = v17
							} else {
								tmp25 := checkDerefVar(var_glojure_DOT_core_next)
								tmp26 := lang.Apply(tmp25, []any{v17})
								tmp21 = tmp26
							}
							tmp27 := lang.Apply(tmp18, []any{tmp20, tmp21})
							tmp12 = tmp27
						} // end let
						tmp11 = tmp12
					} else {
					}
					tmp7 = tmp11
				} // end let
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_subseq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_subseq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// supers
	{
		tmp0 := sym_supers.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_class)), kw_doc, "Returns the immediate and indirect superclasses and interfaces of c, if any", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5532), kw_end_DASH_line, int(5532))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "ret"
				tmp4 := checkDerefVar(var_glojure_DOT_core_set)
				tmp5 := checkDerefVar(var_glojure_DOT_core_bases)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{tmp6})
				var v8 any = tmp7
				_ = v8
				// let binding "cs"
				var v9 any = v8
				_ = v9
				for {
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp12 := lang.Apply(tmp11, []any{v9})
					if lang.IsTruthy(tmp12) {
						var tmp13 any
						{ // let
							// let binding "c"
							tmp14 := checkDerefVar(var_glojure_DOT_core_first)
							tmp15 := lang.Apply(tmp14, []any{v9})
							var v16 any = tmp15
							_ = v16
							// let binding "bs"
							tmp17 := checkDerefVar(var_glojure_DOT_core_bases)
							tmp18 := lang.Apply(tmp17, []any{v16})
							var v19 any = tmp18
							_ = v19
							tmp21 := checkDerefVar(var_glojure_DOT_core_into1)
							tmp22 := lang.Apply(tmp21, []any{v8, v19})
							var tmp20 any = tmp22
							tmp24 := checkDerefVar(var_glojure_DOT_core_into1)
							tmp25 := checkDerefVar(var_glojure_DOT_core_disj)
							tmp26 := lang.Apply(tmp25, []any{v9, v16})
							tmp27 := lang.Apply(tmp24, []any{tmp26, v19})
							var tmp23 any = tmp27
							v8 = tmp20
							v9 = tmp23
							continue
						} // end let
						tmp10 = tmp13
					} else {
						tmp14 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
						tmp15 := lang.Apply(tmp14, []any{v8})
						tmp10 = tmp15
					}
					tmp3 = tmp10
					break
				}
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_supers = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_supers.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sync
	{
		tmp0 := sym_sync.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_flags_DASH_ignored_DASH_for_DASH_now, sym__AMP_, sym_body)), kw_doc, "transaction-flags => TBD, pass nil for now\n\n  Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of sync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(2490), kw_end_DASH_line, int(2490))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym__DOT_})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_LockingTransaction})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_RunInTransaction})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp20 := checkDerefVar(var_glojure_DOT_core_list)
				tmp21 := lang.Apply(tmp20, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp22 := checkDerefVar(var_glojure_DOT_core_list)
				tmp23 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp24 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp27 := lang.Apply(tmp26, nil)
				tmp28 := lang.Apply(tmp25, []any{tmp27})
				tmp29 := lang.Apply(tmp23, []any{tmp24, tmp28})
				tmp30 := lang.Apply(tmp22, []any{tmp29})
				tmp31 := lang.Apply(tmp19, []any{tmp21, tmp30, v5})
				tmp32 := lang.Apply(tmp18, []any{tmp31})
				tmp33 := lang.Apply(tmp17, []any{tmp32})
				tmp34 := lang.Apply(tmp14, []any{tmp16, tmp33})
				tmp35 := lang.Apply(tmp13, []any{tmp34})
				tmp36 := lang.Apply(tmp12, []any{tmp35})
				tmp37 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp36})
				tmp38 := lang.Apply(tmp6, []any{tmp37})
				return tmp38
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_sync = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_sync.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take
	{
		tmp0 := sym_take.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n), lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2853), kw_end_DASH_line, int(2853))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "nv"
						tmp6 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp7 := lang.Apply(tmp6, []any{v2})
						var v8 any = tmp7
						_ = v8
						var tmp9 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp10 := lang.Apply(v4, nil)
								return tmp10
							case 1:
								v10 := args[0]
								_ = v10
								tmp11 := lang.Apply(v4, []any{v10})
								return tmp11
							case 2:
								v10 := args[0]
								_ = v10
								v11 := args[1]
								_ = v11
								var tmp12 any
								{ // let
									// let binding "n"
									tmp13 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp14 := lang.Apply(tmp13, []any{v8})
									var v15 any = tmp14
									_ = v15
									// let binding "nn"
									tmp16 := checkDerefVar(var_glojure_DOT_core_dec)
									tmp17, ok := lang.FieldOrMethod(v8, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Deref")))
									}
									var tmp18 any
									switch reflect.TypeOf(tmp17).Kind() {
									case reflect.Func:
										tmp18 = lang.Apply(tmp17, nil)
									default:
										tmp18 = tmp17
									}
									tmp19 := lang.Apply(tmp16, []any{tmp18})
									tmp20, _ := lang.FieldOrMethod(v8, "reset")
									if reflect.TypeOf(tmp20).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp21 := lang.Apply(tmp20, []any{tmp19})
									var v22 any = tmp21
									_ = v22
									// let binding "result"
									var tmp23 any
									tmp24 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
									tmp25 := lang.Apply(tmp24, []any{v15})
									if lang.IsTruthy(tmp25) {
										tmp26 := lang.Apply(v4, []any{v10, v11})
										tmp23 = tmp26
									} else {
										tmp23 = v10
									}
									var v27 any = tmp23
									_ = v27
									var tmp28 any
									tmp29 := checkDerefVar(var_glojure_DOT_core_not)
									tmp30 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
									tmp31 := lang.Apply(tmp30, []any{v22})
									tmp32 := lang.Apply(tmp29, []any{tmp31})
									if lang.IsTruthy(tmp32) {
										tmp33 := checkDerefVar(var_glojure_DOT_core_ensure_DASH_reduced)
										tmp34 := lang.Apply(tmp33, []any{v27})
										tmp28 = tmp34
									} else {
										tmp28 = v27
									}
									tmp12 = tmp28
								} // end let
								return tmp12
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2862), kw_column, int(10), kw_end_DASH_line, int(2873), kw_end_DASH_column, int(28))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp11
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2860), kw_column, int(6), kw_end_DASH_line, int(2873), kw_end_DASH_column, int(30))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
					tmp7 := lang.Apply(tmp6, []any{v2})
					if lang.IsTruthy(tmp7) {
						var tmp8 any
						{ // let
							// let binding "temp__0__auto__"
							tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp10 := lang.Apply(tmp9, []any{v3})
							var v11 any = tmp10
							_ = v11
							var tmp12 any
							if lang.IsTruthy(v11) {
								var tmp13 any
								{ // let
									// let binding "s"
									var v14 any = v11
									_ = v14
									tmp15 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp16 := checkDerefVar(var_glojure_DOT_core_first)
									tmp17 := lang.Apply(tmp16, []any{v14})
									tmp18 := checkDerefVar(var_glojure_DOT_core_take)
									tmp19 := checkDerefVar(var_glojure_DOT_core_dec)
									tmp20 := lang.Apply(tmp19, []any{v2})
									tmp21 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp22 := lang.Apply(tmp21, []any{v14})
									tmp23 := lang.Apply(tmp18, []any{tmp20, tmp22})
									tmp24 := lang.Apply(tmp15, []any{tmp17, tmp23})
									tmp13 = tmp24
								} // end let
								tmp12 = tmp13
							} else {
							}
							tmp8 = tmp12
						} // end let
						tmp5 = tmp8
					} else {
					}
					return tmp5
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_take = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_take.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-last
	{
		tmp0 := sym_take_DASH_last.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2939), kw_end_DASH_line, int(2939))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "s"
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				// let binding "lead"
				tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp9 := checkDerefVar(var_glojure_DOT_core_drop)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp11 := lang.Apply(tmp8, []any{tmp10})
				var v12 any = tmp11
				_ = v12
				for {
					var tmp13 any
					if lang.IsTruthy(v12) {
						tmp15 := checkDerefVar(var_glojure_DOT_core_next)
						tmp16 := lang.Apply(tmp15, []any{v7})
						var tmp14 any = tmp16
						tmp18 := checkDerefVar(var_glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v12})
						var tmp17 any = tmp19
						v7 = tmp14
						v12 = tmp17
						continue
					} else {
						tmp13 = v7
					}
					tmp4 = tmp13
					break
				}
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_take_DASH_last = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_take_DASH_last.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-nth
	{
		tmp0 := sym_take_DASH_nth.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n), lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4287), kw_end_DASH_line, int(4287))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "iv"
						tmp6 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp7 := lang.Apply(tmp6, []any{int64(-1)})
						var v8 any = tmp7
						_ = v8
						var tmp9 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp10 := lang.Apply(v4, nil)
								return tmp10
							case 1:
								v10 := args[0]
								_ = v10
								tmp11 := lang.Apply(v4, []any{v10})
								return tmp11
							case 2:
								v10 := args[0]
								_ = v10
								v11 := args[1]
								_ = v11
								var tmp12 any
								{ // let
									// let binding "i"
									tmp13 := checkDerefVar(var_glojure_DOT_core_inc)
									tmp14, ok := lang.FieldOrMethod(v8, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "Deref")))
									}
									var tmp15 any
									switch reflect.TypeOf(tmp14).Kind() {
									case reflect.Func:
										tmp15 = lang.Apply(tmp14, nil)
									default:
										tmp15 = tmp14
									}
									tmp16 := lang.Apply(tmp13, []any{tmp15})
									tmp17, _ := lang.FieldOrMethod(v8, "reset")
									if reflect.TypeOf(tmp17).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp18 := lang.Apply(tmp17, []any{tmp16})
									var v19 any = tmp18
									_ = v19
									var tmp20 any
									tmp21 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
									tmp22 := checkDerefVar(var_glojure_DOT_core_rem)
									tmp23 := lang.Apply(tmp22, []any{v19, v2})
									tmp24 := lang.Apply(tmp21, []any{tmp23})
									if lang.IsTruthy(tmp24) {
										tmp25 := lang.Apply(v4, []any{v10, v11})
										tmp20 = tmp25
									} else {
										tmp20 = v10
									}
									tmp12 = tmp20
								} // end let
								return tmp12
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4295), kw_column, int(10), kw_end_DASH_line, int(4302), kw_end_DASH_column, int(28))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp11
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4293), kw_column, int(6), kw_end_DASH_line, int(4302), kw_end_DASH_column, int(30))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp5 any
					{ // let
						// let binding "temp__0__auto__"
						tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp7 := lang.Apply(tmp6, []any{v3})
						var v8 any = tmp7
						_ = v8
						var tmp9 any
						if lang.IsTruthy(v8) {
							var tmp10 any
							{ // let
								// let binding "s"
								var v11 any = v8
								_ = v11
								tmp12 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp13 := checkDerefVar(var_glojure_DOT_core_first)
								tmp14 := lang.Apply(tmp13, []any{v11})
								tmp15 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
								tmp16 := checkDerefVar(var_glojure_DOT_core_drop)
								tmp17 := lang.Apply(tmp16, []any{v2, v11})
								tmp18 := lang.Apply(tmp15, []any{v2, tmp17})
								tmp19 := lang.Apply(tmp12, []any{tmp14, tmp18})
								tmp10 = tmp19
							} // end let
							tmp9 = tmp10
						} else {
						}
						tmp5 = tmp9
					} // end let
					return tmp5
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_take_DASH_nth = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_take_DASH_nth.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// throw-if
	{
		tmp0 := sym_throw_DASH_if.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_fmt, sym__AMP_, sym_args)), kw_doc, "Throws a CompilerException with a message if pred is true", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(5832), kw_end_DASH_line, int(5832), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				if lang.IsTruthy(v2) {
					var tmp6 any
					{ // let
						// let binding "message"
						tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp8 := checkDerefVar(var_glojure_DOT_core_format)
						tmp9 := lang.Apply(tmp7, []any{tmp8, v3, v4})
						var v10 any = tmp9
						_ = v10
						// let binding "exception"
						tmp11 := lang.Apply(lang.NewError, []any{v10})
						var v12 any = tmp11
						_ = v12
						// let binding "raw-trace"
						tmp13, ok := lang.FieldOrMethod(v12, "getStackTrace")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "getStackTrace")))
						}
						var tmp14 any
						switch reflect.TypeOf(tmp13).Kind() {
						case reflect.Func:
							tmp14 = lang.Apply(tmp13, nil)
						default:
							tmp14 = tmp13
						}
						var v15 any = tmp14
						_ = v15
						// let binding "boring?"
						var tmp16 lang.FnFunc
						tmp16 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v17 := args[0]
							_ = v17
							tmp18 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
							tmp19, ok := lang.FieldOrMethod(v17, "getMethodName")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v17, "getMethodName")))
							}
							var tmp20 any
							switch reflect.TypeOf(tmp19).Kind() {
							case reflect.Func:
								tmp20 = lang.Apply(tmp19, nil)
							default:
								tmp20 = tmp19
							}
							tmp21 := lang.Apply(tmp18, []any{tmp20, "doInvoke"})
							return tmp21
						})
						tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5839), kw_column, int(19), kw_end_DASH_line, int(5839), kw_end_DASH_column, int(74))
						tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v19 any = tmp18
						_ = v19
						// let binding "trace"
						tmp20 := checkDerefVar(var_glojure_DOT_core_into_DASH_array)
						tmp21 := checkDerefVar(var_glojure_DOT_core_drop)
						tmp22 := checkDerefVar(var_glojure_DOT_core_drop_DASH_while)
						tmp23 := lang.Apply(tmp22, []any{v19, v15})
						tmp24 := lang.Apply(tmp21, []any{int64(2), tmp23})
						tmp25 := lang.Apply(tmp20, []any{nil, tmp24})
						var v26 any = tmp25
						_ = v26
						tmp27, _ := lang.FieldOrMethod(v12, "setStackTrace")
						if reflect.TypeOf(tmp27).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setStackTrace is not a function")))
						}
						tmp28 := lang.Apply(tmp27, []any{v26})
						_ = tmp28
						tmp29 := checkDerefVar(var_glojure_DOT_core__STAR_file_STAR_)
						tmp30, ok := lang.FieldOrMethod(nil, "Deref")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "Deref")))
						}
						var tmp31 any
						switch reflect.TypeOf(tmp30).Kind() {
						case reflect.Func:
							tmp31 = lang.Apply(tmp30, nil)
						default:
							tmp31 = tmp30
						}
						tmp32, ok := lang.FieldOrMethod(nil, "Deref")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "Deref")))
						}
						var tmp33 any
						switch reflect.TypeOf(tmp32).Kind() {
						case reflect.Func:
							tmp33 = lang.Apply(tmp32, nil)
						default:
							tmp33 = tmp32
						}
						tmp34 := lang.Apply(lang.NewCompilerError, []any{tmp29, tmp31, tmp33, v12})
						panic(tmp34)
					} // end let
					tmp5 = tmp6
				} else {
				}
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_throw_DASH_if = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_throw_DASH_if.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// time
	{
		tmp0 := sym_time.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr)), kw_doc, "Evaluates expr and prints the time it took.  Returns the value of\n expr.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(3885), kw_end_DASH_line, int(3885))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp7 := checkDerefVar(var_glojure_DOT_core_list)
			tmp8 := lang.Apply(tmp7, []any{sym_glojure_DOT_core_SLASH_let})
			tmp9 := checkDerefVar(var_glojure_DOT_core_list)
			tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp11 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp14 := checkDerefVar(var_glojure_DOT_core_list)
			tmp15 := lang.Apply(tmp14, []any{sym_start__0__auto__})
			tmp16 := checkDerefVar(var_glojure_DOT_core_list)
			tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp19 := checkDerefVar(var_glojure_DOT_core_list)
			tmp20 := lang.Apply(tmp19, []any{sym__DOT_UnixNano})
			tmp21 := checkDerefVar(var_glojure_DOT_core_list)
			tmp22 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp23 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp24 := checkDerefVar(var_glojure_DOT_core_list)
			tmp25 := lang.Apply(tmp24, []any{sym_time_DOT_Now})
			tmp26 := lang.Apply(tmp23, []any{tmp25})
			tmp27 := lang.Apply(tmp22, []any{tmp26})
			tmp28 := lang.Apply(tmp21, []any{tmp27})
			tmp29 := lang.Apply(tmp18, []any{tmp20, tmp28})
			tmp30 := lang.Apply(tmp17, []any{tmp29})
			tmp31 := lang.Apply(tmp16, []any{tmp30})
			tmp32 := checkDerefVar(var_glojure_DOT_core_list)
			tmp33 := lang.Apply(tmp32, []any{sym_ret__1__auto__})
			tmp34 := checkDerefVar(var_glojure_DOT_core_list)
			tmp35 := lang.Apply(tmp34, []any{v4})
			tmp36 := lang.Apply(tmp13, []any{tmp15, tmp31, tmp33, tmp35})
			tmp37 := lang.Apply(tmp12, []any{tmp36})
			tmp38 := lang.Apply(tmp10, []any{tmp11, tmp37})
			tmp39 := lang.Apply(tmp9, []any{tmp38})
			tmp40 := checkDerefVar(var_glojure_DOT_core_list)
			tmp41 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp42 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp43 := checkDerefVar(var_glojure_DOT_core_list)
			tmp44 := lang.Apply(tmp43, []any{sym_glojure_DOT_core_SLASH_prn})
			tmp45 := checkDerefVar(var_glojure_DOT_core_list)
			tmp46 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp47 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp48 := checkDerefVar(var_glojure_DOT_core_list)
			tmp49 := lang.Apply(tmp48, []any{sym_glojure_DOT_core_SLASH_str})
			tmp50 := checkDerefVar(var_glojure_DOT_core_list)
			tmp51 := lang.Apply(tmp50, []any{"Elapsed time: "})
			tmp52 := checkDerefVar(var_glojure_DOT_core_list)
			tmp53 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp54 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp55 := checkDerefVar(var_glojure_DOT_core_list)
			tmp56 := lang.Apply(tmp55, []any{sym_glojure_DOT_core_SLASH__SLASH_})
			tmp57 := checkDerefVar(var_glojure_DOT_core_list)
			tmp58 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp59 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp60 := checkDerefVar(var_glojure_DOT_core_list)
			tmp61 := lang.Apply(tmp60, []any{sym_glojure_DOT_core_SLASH_double})
			tmp62 := checkDerefVar(var_glojure_DOT_core_list)
			tmp63 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp64 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp65 := checkDerefVar(var_glojure_DOT_core_list)
			tmp66 := lang.Apply(tmp65, []any{sym_glojure_DOT_core_SLASH__DASH_})
			tmp67 := checkDerefVar(var_glojure_DOT_core_list)
			tmp68 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp69 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp70 := checkDerefVar(var_glojure_DOT_core_list)
			tmp71 := lang.Apply(tmp70, []any{sym__DOT_UnixNano})
			tmp72 := checkDerefVar(var_glojure_DOT_core_list)
			tmp73 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp74 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp75 := checkDerefVar(var_glojure_DOT_core_list)
			tmp76 := lang.Apply(tmp75, []any{sym_time_DOT_Now})
			tmp77 := lang.Apply(tmp74, []any{tmp76})
			tmp78 := lang.Apply(tmp73, []any{tmp77})
			tmp79 := lang.Apply(tmp72, []any{tmp78})
			tmp80 := lang.Apply(tmp69, []any{tmp71, tmp79})
			tmp81 := lang.Apply(tmp68, []any{tmp80})
			tmp82 := lang.Apply(tmp67, []any{tmp81})
			tmp83 := checkDerefVar(var_glojure_DOT_core_list)
			tmp84 := lang.Apply(tmp83, []any{sym_start__0__auto__})
			tmp85 := lang.Apply(tmp64, []any{tmp66, tmp82, tmp84})
			tmp86 := lang.Apply(tmp63, []any{tmp85})
			tmp87 := lang.Apply(tmp62, []any{tmp86})
			tmp88 := lang.Apply(tmp59, []any{tmp61, tmp87})
			tmp89 := lang.Apply(tmp58, []any{tmp88})
			tmp90 := lang.Apply(tmp57, []any{tmp89})
			tmp91 := checkDerefVar(var_glojure_DOT_core_list)
			tmp92 := lang.Apply(tmp91, []any{float64(1e+06)})
			tmp93 := lang.Apply(tmp54, []any{tmp56, tmp90, tmp92})
			tmp94 := lang.Apply(tmp53, []any{tmp93})
			tmp95 := lang.Apply(tmp52, []any{tmp94})
			tmp96 := checkDerefVar(var_glojure_DOT_core_list)
			tmp97 := lang.Apply(tmp96, []any{" msecs"})
			tmp98 := lang.Apply(tmp47, []any{tmp49, tmp51, tmp95, tmp97})
			tmp99 := lang.Apply(tmp46, []any{tmp98})
			tmp100 := lang.Apply(tmp45, []any{tmp99})
			tmp101 := lang.Apply(tmp42, []any{tmp44, tmp100})
			tmp102 := lang.Apply(tmp41, []any{tmp101})
			tmp103 := lang.Apply(tmp40, []any{tmp102})
			tmp104 := checkDerefVar(var_glojure_DOT_core_list)
			tmp105 := lang.Apply(tmp104, []any{sym_ret__1__auto__})
			tmp106 := lang.Apply(tmp6, []any{tmp8, tmp39, tmp103, tmp105})
			tmp107 := lang.Apply(tmp5, []any{tmp106})
			return tmp107
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_time = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_time.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// trampoline
	{
		tmp0 := sym_trampoline.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym__AMP_, sym_args)), kw_doc, "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(6293), kw_end_DASH_line, int(6293))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
			recur_loop_1073:
				var tmp3 any
				{ // let
					// let binding "ret"
					tmp4 := lang.Apply(v2, nil)
					var v5 any = tmp4
					_ = v5
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core_fn_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{v5})
					if lang.IsTruthy(tmp8) {
						var tmp9 any = v5
						v2 = tmp9
						goto recur_loop_1073
					} else {
						tmp6 = v5
					}
					tmp3 = tmp6
				} // end let
				return tmp3
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_trampoline)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp7 := lang.Apply(tmp6, []any{v2, v3})
					return tmp7
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6309), kw_column, int(18), kw_end_DASH_line, int(6309), kw_end_DASH_column, int(32))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7})
				return tmp8
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_trampoline = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_trampoline.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update
	{
		tmp0 := sym_update.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_k, sym_f), lang.NewVector(sym_m, sym_k, sym_f, sym_x), lang.NewVector(sym_m, sym_k, sym_f, sym_x, sym_y), lang.NewVector(sym_m, sym_k, sym_f, sym_x, sym_y, sym_z), lang.NewVector(sym_m, sym_k, sym_f, sym_x, sym_y, sym_z, sym__AMP_, sym_more)), kw_doc, "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6174), kw_end_DASH_line, int(6174))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp6 := checkDerefVar(var_glojure_DOT_core_get)
				tmp7 := lang.Apply(tmp6, []any{v2, v3})
				tmp8 := lang.Apply(v4, []any{tmp7})
				tmp9 := lang.Apply(tmp5, []any{v2, v3, tmp8})
				return tmp9
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp7 := checkDerefVar(var_glojure_DOT_core_get)
				tmp8 := lang.Apply(tmp7, []any{v2, v3})
				tmp9 := lang.Apply(v4, []any{tmp8, v5})
				tmp10 := lang.Apply(tmp6, []any{v2, v3, tmp9})
				return tmp10
			case 5:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp8 := checkDerefVar(var_glojure_DOT_core_get)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp10 := lang.Apply(v4, []any{tmp9, v5, v6})
				tmp11 := lang.Apply(tmp7, []any{v2, v3, tmp10})
				return tmp11
			case 6:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				v7 := args[5]
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp9 := checkDerefVar(var_glojure_DOT_core_get)
				tmp10 := lang.Apply(tmp9, []any{v2, v3})
				tmp11 := lang.Apply(v4, []any{tmp10, v5, v6, v7})
				tmp12 := lang.Apply(tmp8, []any{v2, v3, tmp11})
				return tmp12
			default:
				checkArityGTE(args, 6)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				v6 := args[4]
				_ = v6
				v7 := args[5]
				_ = v7
				var v8 any = lang.NewList(args[6:]...)
				_ = v8
				tmp9 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp11 := checkDerefVar(var_glojure_DOT_core_get)
				tmp12 := lang.Apply(tmp11, []any{v2, v3})
				tmp13 := lang.Apply(tmp10, []any{v4, tmp12, v5, v6, v7, v8})
				tmp14 := lang.Apply(tmp9, []any{v2, v3, tmp13})
				return tmp14
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_update = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_update.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-in
	{
		tmp0 := sym_update_DASH_in.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_ks, sym_f, sym__AMP_, sym_args)), kw_doc, "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(6158), kw_end_DASH_line, int(6158))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "up"
					var tmp7 lang.FnFunc
					{ // function up
						var v8 lang.FnFunc
						tmp7 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 4)
							v9 := args[0]
							_ = v9
							v10 := args[1]
							_ = v10
							v11 := args[2]
							_ = v11
							v12 := args[3]
							_ = v12
							var tmp13 any
							{ // let
								// let binding "vec__141"
								var v14 any = v10
								_ = v14
								// let binding "seq__142"
								tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp16 := lang.Apply(tmp15, []any{v14})
								var v17 any = tmp16
								_ = v17
								// let binding "first__143"
								tmp18 := checkDerefVar(var_glojure_DOT_core_first)
								tmp19 := lang.Apply(tmp18, []any{v17})
								var v20 any = tmp19
								_ = v20
								// let binding "seq__142"
								tmp21 := checkDerefVar(var_glojure_DOT_core_next)
								tmp22 := lang.Apply(tmp21, []any{v17})
								var v23 any = tmp22
								_ = v23
								// let binding "k"
								var v24 any = v20
								_ = v24
								// let binding "ks"
								var v25 any = v23
								_ = v25
								var tmp26 any
								if lang.IsTruthy(v25) {
									tmp27 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp28 := checkDerefVar(var_glojure_DOT_core_get)
									tmp29 := lang.Apply(tmp28, []any{v9, v24})
									tmp30 := lang.Apply(v8, []any{tmp29, v25, v11, v12})
									tmp31 := lang.Apply(tmp27, []any{v9, v24, tmp30})
									tmp26 = tmp31
								} else {
									tmp32 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp33 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp34 := checkDerefVar(var_glojure_DOT_core_get)
									tmp35 := lang.Apply(tmp34, []any{v9, v24})
									tmp36 := lang.Apply(tmp33, []any{v11, tmp35, v12})
									tmp37 := lang.Apply(tmp32, []any{v9, v24, tmp36})
									tmp26 = tmp37
								}
								tmp13 = tmp26
							} // end let
							return tmp13
						})
						v8 = tmp7
						_ = v8
					}
					tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6167), kw_column, int(15), kw_end_DASH_line, int(6171), kw_end_DASH_column, int(59))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v10 any = tmp9
					_ = v10
					tmp11 := lang.Apply(v10, []any{v2, v3, v4, v5})
					tmp6 = tmp11
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_update_DASH_in = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_update_DASH_in.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vary-meta
	{
		tmp0 := sym_vary_DASH_meta.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_obj, sym_f, sym__AMP_, sym_args)), kw_doc, "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(668), kw_end_DASH_line, int(668))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp8 := lang.Apply(tmp7, []any{v2})
				tmp9 := lang.Apply(tmp6, []any{v3, tmp8, v4})
				tmp10 := lang.Apply(tmp5, []any{v2, tmp9})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_vary_DASH_meta = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_vary_DASH_meta.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-first
	{
		tmp0 := sym_when_DASH_first.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(11), kw_line, int(4622), kw_end_DASH_line, int(4622))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_str)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp12 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp14 := lang.Apply(tmp13, []any{v2})
					tmp15 := lang.Apply(kw_line, []any{tmp14})
					tmp16 := lang.Apply(tmp9, []any{tmp11, " requires ", "a vector for its binding", " in ", tmp12, ":", tmp15})
					tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
					panic(tmp17)
				}
				_ = tmp6
				var tmp18 any
				tmp19 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp20 := checkDerefVar(var_glojure_DOT_core_count)
				tmp21 := lang.Apply(tmp20, []any{v4})
				tmp22 := lang.Apply(tmp19, []any{int64(2), tmp21})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "exactly 2 forms in binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp18
				var tmp32 any
				{ // let
					// let binding "vec__20"
					var v33 any = v4
					_ = v33
					// let binding "x"
					tmp34 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp35 := lang.Apply(tmp34, []any{v33, int64(0), nil})
					var v36 any = tmp35
					_ = v36
					// let binding "xs"
					tmp37 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp38 := lang.Apply(tmp37, []any{v33, int64(1), nil})
					var v39 any = tmp38
					_ = v39
					tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp41 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					tmp43 := lang.Apply(tmp42, []any{sym_glojure_DOT_core_SLASH_when_DASH_let})
					tmp44 := checkDerefVar(var_glojure_DOT_core_list)
					tmp45 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp46 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp49 := checkDerefVar(var_glojure_DOT_core_list)
					tmp50 := lang.Apply(tmp49, []any{sym_xs__0__auto__})
					tmp51 := checkDerefVar(var_glojure_DOT_core_list)
					tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp53 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp54 := checkDerefVar(var_glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{sym_glojure_DOT_core_SLASH_seq})
					tmp56 := checkDerefVar(var_glojure_DOT_core_list)
					tmp57 := lang.Apply(tmp56, []any{v39})
					tmp58 := lang.Apply(tmp53, []any{tmp55, tmp57})
					tmp59 := lang.Apply(tmp52, []any{tmp58})
					tmp60 := lang.Apply(tmp51, []any{tmp59})
					tmp61 := lang.Apply(tmp48, []any{tmp50, tmp60})
					tmp62 := lang.Apply(tmp47, []any{tmp61})
					tmp63 := lang.Apply(tmp45, []any{tmp46, tmp62})
					tmp64 := lang.Apply(tmp44, []any{tmp63})
					tmp65 := checkDerefVar(var_glojure_DOT_core_list)
					tmp66 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp67 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp68 := checkDerefVar(var_glojure_DOT_core_list)
					tmp69 := lang.Apply(tmp68, []any{sym_glojure_DOT_core_SLASH_let})
					tmp70 := checkDerefVar(var_glojure_DOT_core_list)
					tmp71 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp72 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp73 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp74 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp75 := checkDerefVar(var_glojure_DOT_core_list)
					tmp76 := lang.Apply(tmp75, []any{v36})
					tmp77 := checkDerefVar(var_glojure_DOT_core_list)
					tmp78 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp79 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp80 := checkDerefVar(var_glojure_DOT_core_list)
					tmp81 := lang.Apply(tmp80, []any{sym_glojure_DOT_core_SLASH_first})
					tmp82 := checkDerefVar(var_glojure_DOT_core_list)
					tmp83 := lang.Apply(tmp82, []any{sym_xs__0__auto__})
					tmp84 := lang.Apply(tmp79, []any{tmp81, tmp83})
					tmp85 := lang.Apply(tmp78, []any{tmp84})
					tmp86 := lang.Apply(tmp77, []any{tmp85})
					tmp87 := lang.Apply(tmp74, []any{tmp76, tmp86})
					tmp88 := lang.Apply(tmp73, []any{tmp87})
					tmp89 := lang.Apply(tmp71, []any{tmp72, tmp88})
					tmp90 := lang.Apply(tmp70, []any{tmp89})
					tmp91 := lang.Apply(tmp67, []any{tmp69, tmp90, v5})
					tmp92 := lang.Apply(tmp66, []any{tmp91})
					tmp93 := lang.Apply(tmp65, []any{tmp92})
					tmp94 := lang.Apply(tmp41, []any{tmp43, tmp64, tmp93})
					tmp95 := lang.Apply(tmp40, []any{tmp94})
					tmp32 = tmp95
				} // end let
				return tmp32
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_when_DASH_first = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_when_DASH_first.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-let
	{
		tmp0 := sym_when_DASH_let.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(1859), kw_end_DASH_line, int(1859))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_str)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp12 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp14 := lang.Apply(tmp13, []any{v2})
					tmp15 := lang.Apply(kw_line, []any{tmp14})
					tmp16 := lang.Apply(tmp9, []any{tmp11, " requires ", "a vector for its binding", " in ", tmp12, ":", tmp15})
					tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
					panic(tmp17)
				}
				_ = tmp6
				var tmp18 any
				tmp19 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp20 := checkDerefVar(var_glojure_DOT_core_count)
				tmp21 := lang.Apply(tmp20, []any{v4})
				tmp22 := lang.Apply(tmp19, []any{int64(2), tmp21})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "exactly 2 forms in binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp18
				var tmp32 any
				{ // let
					// let binding "form"
					tmp33 := lang.Apply(v4, []any{int64(0)})
					var v34 any = tmp33
					_ = v34
					// let binding "tst"
					tmp35 := lang.Apply(v4, []any{int64(1)})
					var v36 any = tmp35
					_ = v36
					tmp37 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp38 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					tmp40 := lang.Apply(tmp39, []any{sym_glojure_DOT_core_SLASH_let})
					tmp41 := checkDerefVar(var_glojure_DOT_core_list)
					tmp42 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp43 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp44 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp45 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp46 := checkDerefVar(var_glojure_DOT_core_list)
					tmp47 := lang.Apply(tmp46, []any{sym_temp__0__auto__})
					tmp48 := checkDerefVar(var_glojure_DOT_core_list)
					tmp49 := lang.Apply(tmp48, []any{v36})
					tmp50 := lang.Apply(tmp45, []any{tmp47, tmp49})
					tmp51 := lang.Apply(tmp44, []any{tmp50})
					tmp52 := lang.Apply(tmp42, []any{tmp43, tmp51})
					tmp53 := lang.Apply(tmp41, []any{tmp52})
					tmp54 := checkDerefVar(var_glojure_DOT_core_list)
					tmp55 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp56 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp57 := checkDerefVar(var_glojure_DOT_core_list)
					tmp58 := lang.Apply(tmp57, []any{sym_glojure_DOT_core_SLASH_when})
					tmp59 := checkDerefVar(var_glojure_DOT_core_list)
					tmp60 := lang.Apply(tmp59, []any{sym_temp__0__auto__})
					tmp61 := checkDerefVar(var_glojure_DOT_core_list)
					tmp62 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp63 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp64 := checkDerefVar(var_glojure_DOT_core_list)
					tmp65 := lang.Apply(tmp64, []any{sym_glojure_DOT_core_SLASH_let})
					tmp66 := checkDerefVar(var_glojure_DOT_core_list)
					tmp67 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp68 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp69 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp70 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp71 := checkDerefVar(var_glojure_DOT_core_list)
					tmp72 := lang.Apply(tmp71, []any{v34})
					tmp73 := checkDerefVar(var_glojure_DOT_core_list)
					tmp74 := lang.Apply(tmp73, []any{sym_temp__0__auto__})
					tmp75 := lang.Apply(tmp70, []any{tmp72, tmp74})
					tmp76 := lang.Apply(tmp69, []any{tmp75})
					tmp77 := lang.Apply(tmp67, []any{tmp68, tmp76})
					tmp78 := lang.Apply(tmp66, []any{tmp77})
					tmp79 := lang.Apply(tmp63, []any{tmp65, tmp78, v5})
					tmp80 := lang.Apply(tmp62, []any{tmp79})
					tmp81 := lang.Apply(tmp61, []any{tmp80})
					tmp82 := lang.Apply(tmp56, []any{tmp58, tmp60, tmp81})
					tmp83 := lang.Apply(tmp55, []any{tmp82})
					tmp84 := lang.Apply(tmp54, []any{tmp83})
					tmp85 := lang.Apply(tmp38, []any{tmp40, tmp53, tmp84})
					tmp86 := lang.Apply(tmp37, []any{tmp85})
					tmp32 = tmp86
				} // end let
				return tmp32
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_when_DASH_let = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_when_DASH_let.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-some
	{
		tmp0 := sym_when_DASH_some.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "bindings => binding-form test\n\n   When test is not nil, evaluates body with binding-form bound to the\n   value of test", kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(1894), kw_end_DASH_line, int(1894))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_str)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp12 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp14 := lang.Apply(tmp13, []any{v2})
					tmp15 := lang.Apply(kw_line, []any{tmp14})
					tmp16 := lang.Apply(tmp9, []any{tmp11, " requires ", "a vector for its binding", " in ", tmp12, ":", tmp15})
					tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
					panic(tmp17)
				}
				_ = tmp6
				var tmp18 any
				tmp19 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp20 := checkDerefVar(var_glojure_DOT_core_count)
				tmp21 := lang.Apply(tmp20, []any{v4})
				tmp22 := lang.Apply(tmp19, []any{int64(2), tmp21})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "exactly 2 forms in binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp18
				var tmp32 any
				{ // let
					// let binding "form"
					tmp33 := lang.Apply(v4, []any{int64(0)})
					var v34 any = tmp33
					_ = v34
					// let binding "tst"
					tmp35 := lang.Apply(v4, []any{int64(1)})
					var v36 any = tmp35
					_ = v36
					tmp37 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp38 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					tmp40 := lang.Apply(tmp39, []any{sym_glojure_DOT_core_SLASH_let})
					tmp41 := checkDerefVar(var_glojure_DOT_core_list)
					tmp42 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp43 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp44 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp45 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp46 := checkDerefVar(var_glojure_DOT_core_list)
					tmp47 := lang.Apply(tmp46, []any{sym_temp__0__auto__})
					tmp48 := checkDerefVar(var_glojure_DOT_core_list)
					tmp49 := lang.Apply(tmp48, []any{v36})
					tmp50 := lang.Apply(tmp45, []any{tmp47, tmp49})
					tmp51 := lang.Apply(tmp44, []any{tmp50})
					tmp52 := lang.Apply(tmp42, []any{tmp43, tmp51})
					tmp53 := lang.Apply(tmp41, []any{tmp52})
					tmp54 := checkDerefVar(var_glojure_DOT_core_list)
					tmp55 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp56 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp57 := checkDerefVar(var_glojure_DOT_core_list)
					tmp58 := lang.Apply(tmp57, []any{sym_if})
					tmp59 := checkDerefVar(var_glojure_DOT_core_list)
					tmp60 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp61 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp62 := checkDerefVar(var_glojure_DOT_core_list)
					tmp63 := lang.Apply(tmp62, []any{sym_glojure_DOT_core_SLASH_nil_QMARK_})
					tmp64 := checkDerefVar(var_glojure_DOT_core_list)
					tmp65 := lang.Apply(tmp64, []any{sym_temp__0__auto__})
					tmp66 := lang.Apply(tmp61, []any{tmp63, tmp65})
					tmp67 := lang.Apply(tmp60, []any{tmp66})
					tmp68 := lang.Apply(tmp59, []any{tmp67})
					tmp69 := checkDerefVar(var_glojure_DOT_core_list)
					tmp70 := lang.Apply(tmp69, []any{nil})
					tmp71 := checkDerefVar(var_glojure_DOT_core_list)
					tmp72 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp73 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp74 := checkDerefVar(var_glojure_DOT_core_list)
					tmp75 := lang.Apply(tmp74, []any{sym_glojure_DOT_core_SLASH_let})
					tmp76 := checkDerefVar(var_glojure_DOT_core_list)
					tmp77 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp78 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp79 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp80 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp81 := checkDerefVar(var_glojure_DOT_core_list)
					tmp82 := lang.Apply(tmp81, []any{v34})
					tmp83 := checkDerefVar(var_glojure_DOT_core_list)
					tmp84 := lang.Apply(tmp83, []any{sym_temp__0__auto__})
					tmp85 := lang.Apply(tmp80, []any{tmp82, tmp84})
					tmp86 := lang.Apply(tmp79, []any{tmp85})
					tmp87 := lang.Apply(tmp77, []any{tmp78, tmp86})
					tmp88 := lang.Apply(tmp76, []any{tmp87})
					tmp89 := lang.Apply(tmp73, []any{tmp75, tmp88, v5})
					tmp90 := lang.Apply(tmp72, []any{tmp89})
					tmp91 := lang.Apply(tmp71, []any{tmp90})
					tmp92 := lang.Apply(tmp56, []any{tmp58, tmp68, tmp70, tmp91})
					tmp93 := lang.Apply(tmp55, []any{tmp92})
					tmp94 := lang.Apply(tmp54, []any{tmp93})
					tmp95 := lang.Apply(tmp38, []any{tmp40, tmp53, tmp94})
					tmp96 := lang.Apply(tmp37, []any{tmp95})
					tmp32 = tmp96
				} // end let
				return tmp32
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_when_DASH_some = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_when_DASH_some.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// while
	{
		tmp0 := sym_while.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_test, sym__AMP_, sym_body)), kw_doc, "Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(6327), kw_end_DASH_line, int(6327))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_loop})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := lang.Apply(tmp14, nil)
				tmp16 := lang.Apply(tmp13, []any{tmp15})
				tmp17 := lang.Apply(tmp11, []any{tmp12, tmp16})
				tmp18 := lang.Apply(tmp10, []any{tmp17})
				tmp19 := checkDerefVar(var_glojure_DOT_core_list)
				tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp22 := checkDerefVar(var_glojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{sym_glojure_DOT_core_SLASH_when})
				tmp24 := checkDerefVar(var_glojure_DOT_core_list)
				tmp25 := lang.Apply(tmp24, []any{v4})
				tmp26 := checkDerefVar(var_glojure_DOT_core_list)
				tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp28 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp29 := checkDerefVar(var_glojure_DOT_core_list)
				tmp30 := lang.Apply(tmp29, []any{sym_recur})
				tmp31 := lang.Apply(tmp28, []any{tmp30})
				tmp32 := lang.Apply(tmp27, []any{tmp31})
				tmp33 := lang.Apply(tmp26, []any{tmp32})
				tmp34 := lang.Apply(tmp21, []any{tmp23, tmp25, v5, tmp33})
				tmp35 := lang.Apply(tmp20, []any{tmp34})
				tmp36 := lang.Apply(tmp19, []any{tmp35})
				tmp37 := lang.Apply(tmp7, []any{tmp9, tmp18, tmp36})
				tmp38 := lang.Apply(tmp6, []any{tmp37})
				return tmp38
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_while = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_while.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-bindings
	{
		tmp0 := sym_with_DASH_bindings.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_binding_DASH_map, sym__AMP_, sym_body)), kw_doc, "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then executes body. Pops the installed\n  bindings after body was evaluated. Returns the value of body.", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(11), kw_line, int(1984), kw_end_DASH_line, int(1984))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_with_DASH_bindings_STAR_})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp19 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp22 := lang.Apply(tmp21, nil)
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				tmp24 := lang.Apply(tmp18, []any{tmp19, tmp23})
				tmp25 := lang.Apply(tmp17, []any{tmp24})
				tmp26 := lang.Apply(tmp14, []any{tmp16, tmp25, v5})
				tmp27 := lang.Apply(tmp13, []any{tmp26})
				tmp28 := lang.Apply(tmp12, []any{tmp27})
				tmp29 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp28})
				tmp30 := lang.Apply(tmp6, []any{tmp29})
				return tmp30
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_with_DASH_bindings = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_with_DASH_bindings.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-bindings*
	{
		tmp0 := sym_with_DASH_bindings_STAR_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_binding_DASH_map, sym_f, sym__AMP_, sym_args)), kw_doc, "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then calls f with the supplied arguments.\n  Pops the installed bindings after f returned. Returns whatever f returns.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(1971), kw_end_DASH_line, int(1971))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp6 := lang.Apply(tmp5, []any{v2})
				_ = tmp6
				var tmp7 any
				func() {
					defer func() {
						tmp8 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp9 := lang.Apply(tmp8, nil)
						_ = tmp9
					}()
					tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp11 := lang.Apply(tmp10, []any{v3, v4})
					tmp7 = tmp11
				}()
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_with_DASH_bindings_STAR_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_with_DASH_bindings_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-in-str
	{
		tmp0 := sym_with_DASH_in_DASH_str.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_s, sym__AMP_, sym_body)), kw_doc, "Evaluates body in a context in which *in* is bound to a fresh\n  StringReader initialized with the string s.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(11), kw_line, int(4749), kw_end_DASH_line, int(4749))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_with_DASH_open})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_s__0__auto__})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp20 := checkDerefVar(var_glojure_DOT_core_list)
				tmp21 := lang.Apply(tmp20, []any{sym_glojure_DOT_core_SLASH__DASH__GT_})
				tmp22 := checkDerefVar(var_glojure_DOT_core_list)
				tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp25 := checkDerefVar(var_glojure_DOT_core_list)
				tmp26 := lang.Apply(tmp25, []any{sym_java_DOT_io_DOT_StringReader_DOT_})
				tmp27 := checkDerefVar(var_glojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{v4})
				tmp29 := lang.Apply(tmp24, []any{tmp26, tmp28})
				tmp30 := lang.Apply(tmp23, []any{tmp29})
				tmp31 := lang.Apply(tmp22, []any{tmp30})
				tmp32 := checkDerefVar(var_glojure_DOT_core_list)
				tmp33 := lang.Apply(tmp32, []any{sym_glojure_DOT_lang_DOT_LineNumberingPushbackReader_DOT_})
				tmp34 := lang.Apply(tmp19, []any{tmp21, tmp31, tmp33})
				tmp35 := lang.Apply(tmp18, []any{tmp34})
				tmp36 := lang.Apply(tmp17, []any{tmp35})
				tmp37 := lang.Apply(tmp14, []any{tmp16, tmp36})
				tmp38 := lang.Apply(tmp13, []any{tmp37})
				tmp39 := lang.Apply(tmp11, []any{tmp12, tmp38})
				tmp40 := lang.Apply(tmp10, []any{tmp39})
				tmp41 := checkDerefVar(var_glojure_DOT_core_list)
				tmp42 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp43 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp44 := checkDerefVar(var_glojure_DOT_core_list)
				tmp45 := lang.Apply(tmp44, []any{sym_glojure_DOT_core_SLASH_binding})
				tmp46 := checkDerefVar(var_glojure_DOT_core_list)
				tmp47 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp48 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp49 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp50 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp51 := checkDerefVar(var_glojure_DOT_core_list)
				tmp52 := lang.Apply(tmp51, []any{sym_glojure_DOT_core_SLASH__STAR_in_STAR_})
				tmp53 := checkDerefVar(var_glojure_DOT_core_list)
				tmp54 := lang.Apply(tmp53, []any{sym_s__0__auto__})
				tmp55 := lang.Apply(tmp50, []any{tmp52, tmp54})
				tmp56 := lang.Apply(tmp49, []any{tmp55})
				tmp57 := lang.Apply(tmp47, []any{tmp48, tmp56})
				tmp58 := lang.Apply(tmp46, []any{tmp57})
				tmp59 := lang.Apply(tmp43, []any{tmp45, tmp58, v5})
				tmp60 := lang.Apply(tmp42, []any{tmp59})
				tmp61 := lang.Apply(tmp41, []any{tmp60})
				tmp62 := lang.Apply(tmp7, []any{tmp9, tmp40, tmp61})
				tmp63 := lang.Apply(tmp6, []any{tmp62})
				return tmp63
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_with_DASH_in_DASH_str = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_with_DASH_in_DASH_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-loading-context
	{
		tmp0 := sym_with_DASH_loading_DASH_context.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5734), kw_column, int(11), kw_end_DASH_line, int(5734), kw_end_DASH_column, int(30), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{sym_loading__0__auto__})
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp16 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp19 := lang.Apply(tmp18, nil)
				tmp20 := lang.Apply(tmp17, []any{tmp19})
				tmp21 := lang.Apply(tmp15, []any{tmp16, tmp20})
				tmp22 := lang.Apply(tmp14, []any{tmp21})
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp26 := checkDerefVar(var_glojure_DOT_core_list)
				tmp27 := lang.Apply(tmp26, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PushThreadBindings})
				tmp28 := checkDerefVar(var_glojure_DOT_core_list)
				tmp29 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp30 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
				tmp31 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp32 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp33 := lang.Apply(tmp32, nil)
				tmp34 := lang.Apply(tmp31, []any{tmp33})
				tmp35 := lang.Apply(tmp29, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp28, []any{tmp35})
				tmp37 := lang.Apply(tmp25, []any{tmp27, tmp36})
				tmp38 := lang.Apply(tmp24, []any{tmp37})
				tmp39 := lang.Apply(tmp23, []any{tmp38})
				tmp40 := checkDerefVar(var_glojure_DOT_core_list)
				tmp41 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp42 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp43 := checkDerefVar(var_glojure_DOT_core_list)
				tmp44 := lang.Apply(tmp43, []any{sym_try})
				tmp45 := checkDerefVar(var_glojure_DOT_core_list)
				tmp46 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp47 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp48 := checkDerefVar(var_glojure_DOT_core_list)
				tmp49 := lang.Apply(tmp48, []any{sym_finally})
				tmp50 := checkDerefVar(var_glojure_DOT_core_list)
				tmp51 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp52 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp53 := checkDerefVar(var_glojure_DOT_core_list)
				tmp54 := lang.Apply(tmp53, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PopThreadBindings})
				tmp55 := lang.Apply(tmp52, []any{tmp54})
				tmp56 := lang.Apply(tmp51, []any{tmp55})
				tmp57 := lang.Apply(tmp50, []any{tmp56})
				tmp58 := lang.Apply(tmp47, []any{tmp49, tmp57})
				tmp59 := lang.Apply(tmp46, []any{tmp58})
				tmp60 := lang.Apply(tmp45, []any{tmp59})
				tmp61 := lang.Apply(tmp42, []any{tmp44, v4, tmp60})
				tmp62 := lang.Apply(tmp41, []any{tmp61})
				tmp63 := lang.Apply(tmp40, []any{tmp62})
				tmp64 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp22, tmp39, tmp63})
				tmp65 := lang.Apply(tmp8, []any{tmp64})
				tmp66 := lang.Apply(tmp7, []any{tmp65})
				tmp67 := lang.Apply(tmp6, []any{tmp66})
				tmp68 := lang.Apply(tmp5, []any{tmp67})
				return tmp68
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_with_DASH_loading_DASH_context = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_with_DASH_loading_DASH_context.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-open
	{
		tmp0 := sym_with_DASH_open.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "bindings => [name init ...]\n\n  Evaluates body in a try expression with names bound to the values\n  of the inits, and a finally clause that calls (.close name) on each\n  name in reverse order.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(3832), kw_end_DASH_line, int(3832))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_str)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp12 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp14 := lang.Apply(tmp13, []any{v2})
					tmp15 := lang.Apply(kw_line, []any{tmp14})
					tmp16 := lang.Apply(tmp9, []any{tmp11, " requires ", "a vector for its binding", " in ", tmp12, ":", tmp15})
					tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
					panic(tmp17)
				}
				_ = tmp6
				var tmp18 any
				tmp19 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp20 := checkDerefVar(var_glojure_DOT_core_count)
				tmp21 := lang.Apply(tmp20, []any{v4})
				tmp22 := lang.Apply(tmp19, []any{tmp21})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "an even number of forms in binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp18
				var tmp32 any
				tmp33 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp34 := checkDerefVar(var_glojure_DOT_core_count)
				tmp35 := lang.Apply(tmp34, []any{v4})
				tmp36 := lang.Apply(tmp33, []any{tmp35, int64(0)})
				if lang.IsTruthy(tmp36) {
					tmp37 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp38 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					tmp40 := lang.Apply(tmp39, []any{sym_do})
					tmp41 := lang.Apply(tmp38, []any{tmp40, v5})
					tmp42 := lang.Apply(tmp37, []any{tmp41})
					tmp32 = tmp42
				} else {
					var tmp43 any
					tmp44 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
					tmp45 := lang.Apply(v4, []any{int64(0)})
					tmp46 := lang.Apply(tmp44, []any{tmp45})
					if lang.IsTruthy(tmp46) {
						tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp49 := checkDerefVar(var_glojure_DOT_core_list)
						tmp50 := lang.Apply(tmp49, []any{sym_glojure_DOT_core_SLASH_let})
						tmp51 := checkDerefVar(var_glojure_DOT_core_list)
						tmp52 := checkDerefVar(var_glojure_DOT_core_subvec)
						tmp53 := lang.Apply(tmp52, []any{v4, int64(0), int64(2)})
						tmp54 := lang.Apply(tmp51, []any{tmp53})
						tmp55 := checkDerefVar(var_glojure_DOT_core_list)
						tmp56 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp57 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp58 := checkDerefVar(var_glojure_DOT_core_list)
						tmp59 := lang.Apply(tmp58, []any{sym_try})
						tmp60 := checkDerefVar(var_glojure_DOT_core_list)
						tmp61 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp62 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp63 := checkDerefVar(var_glojure_DOT_core_list)
						tmp64 := lang.Apply(tmp63, []any{sym_glojure_DOT_core_SLASH_with_DASH_open})
						tmp65 := checkDerefVar(var_glojure_DOT_core_list)
						tmp66 := checkDerefVar(var_glojure_DOT_core_subvec)
						tmp67 := lang.Apply(tmp66, []any{v4, int64(2)})
						tmp68 := lang.Apply(tmp65, []any{tmp67})
						tmp69 := lang.Apply(tmp62, []any{tmp64, tmp68, v5})
						tmp70 := lang.Apply(tmp61, []any{tmp69})
						tmp71 := lang.Apply(tmp60, []any{tmp70})
						tmp72 := checkDerefVar(var_glojure_DOT_core_list)
						tmp73 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp74 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp75 := checkDerefVar(var_glojure_DOT_core_list)
						tmp76 := lang.Apply(tmp75, []any{sym_finally})
						tmp77 := checkDerefVar(var_glojure_DOT_core_list)
						tmp78 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp79 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp80 := checkDerefVar(var_glojure_DOT_core_list)
						tmp81 := lang.Apply(tmp80, []any{sym__DOT_})
						tmp82 := checkDerefVar(var_glojure_DOT_core_list)
						tmp83 := lang.Apply(v4, []any{int64(0)})
						tmp84 := lang.Apply(tmp82, []any{tmp83})
						tmp85 := checkDerefVar(var_glojure_DOT_core_list)
						tmp86 := lang.Apply(tmp85, []any{sym_close})
						tmp87 := lang.Apply(tmp79, []any{tmp81, tmp84, tmp86})
						tmp88 := lang.Apply(tmp78, []any{tmp87})
						tmp89 := lang.Apply(tmp77, []any{tmp88})
						tmp90 := lang.Apply(tmp74, []any{tmp76, tmp89})
						tmp91 := lang.Apply(tmp73, []any{tmp90})
						tmp92 := lang.Apply(tmp72, []any{tmp91})
						tmp93 := lang.Apply(tmp57, []any{tmp59, tmp71, tmp92})
						tmp94 := lang.Apply(tmp56, []any{tmp93})
						tmp95 := lang.Apply(tmp55, []any{tmp94})
						tmp96 := lang.Apply(tmp48, []any{tmp50, tmp54, tmp95})
						tmp97 := lang.Apply(tmp47, []any{tmp96})
						tmp43 = tmp97
					} else {
						var tmp98 any
						if lang.IsTruthy(kw_else) {
							tmp99 := lang.Apply(lang.NewIllegalArgumentError, []any{"with-open only allows Symbols in bindings"})
							panic(tmp99)
						} else {
						}
						tmp43 = tmp98
					}
					tmp32 = tmp43
				}
				return tmp32
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_with_DASH_open = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_with_DASH_open.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-out-str
	{
		tmp0 := sym_with_DASH_out_DASH_str.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Evaluates exprs in a context in which *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(22), kw_column, int(11), kw_line, int(4738), kw_end_DASH_line, int(4738))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_glojure_DOT_core_SLASH_let})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp11 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_s__0__auto__})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp19 := checkDerefVar(var_glojure_DOT_core_list)
				tmp20 := lang.Apply(tmp19, []any{sym_new})
				tmp21 := checkDerefVar(var_glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{sym_strings_DOT_Builder})
				tmp23 := lang.Apply(tmp18, []any{tmp20, tmp22})
				tmp24 := lang.Apply(tmp17, []any{tmp23})
				tmp25 := lang.Apply(tmp16, []any{tmp24})
				tmp26 := lang.Apply(tmp13, []any{tmp15, tmp25})
				tmp27 := lang.Apply(tmp12, []any{tmp26})
				tmp28 := lang.Apply(tmp10, []any{tmp11, tmp27})
				tmp29 := lang.Apply(tmp9, []any{tmp28})
				tmp30 := checkDerefVar(var_glojure_DOT_core_list)
				tmp31 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp32 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp33 := checkDerefVar(var_glojure_DOT_core_list)
				tmp34 := lang.Apply(tmp33, []any{sym_glojure_DOT_core_SLASH_binding})
				tmp35 := checkDerefVar(var_glojure_DOT_core_list)
				tmp36 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp37 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp39 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp40 := checkDerefVar(var_glojure_DOT_core_list)
				tmp41 := lang.Apply(tmp40, []any{sym_glojure_DOT_core_SLASH__STAR_out_STAR_})
				tmp42 := checkDerefVar(var_glojure_DOT_core_list)
				tmp43 := lang.Apply(tmp42, []any{sym_s__0__auto__})
				tmp44 := lang.Apply(tmp39, []any{tmp41, tmp43})
				tmp45 := lang.Apply(tmp38, []any{tmp44})
				tmp46 := lang.Apply(tmp36, []any{tmp37, tmp45})
				tmp47 := lang.Apply(tmp35, []any{tmp46})
				tmp48 := checkDerefVar(var_glojure_DOT_core_list)
				tmp49 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp50 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp51 := checkDerefVar(var_glojure_DOT_core_list)
				tmp52 := lang.Apply(tmp51, []any{sym_glojure_DOT_core_SLASH_str})
				tmp53 := checkDerefVar(var_glojure_DOT_core_list)
				tmp54 := lang.Apply(tmp53, []any{sym_s__0__auto__})
				tmp55 := lang.Apply(tmp50, []any{tmp52, tmp54})
				tmp56 := lang.Apply(tmp49, []any{tmp55})
				tmp57 := lang.Apply(tmp48, []any{tmp56})
				tmp58 := lang.Apply(tmp32, []any{tmp34, tmp47, v4, tmp57})
				tmp59 := lang.Apply(tmp31, []any{tmp58})
				tmp60 := lang.Apply(tmp30, []any{tmp59})
				tmp61 := lang.Apply(tmp6, []any{tmp8, tmp29, tmp60})
				tmp62 := lang.Apply(tmp5, []any{tmp61})
				return tmp62
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_with_DASH_out_DASH_str = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_with_DASH_out_DASH_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-precision
	{
		tmp0 := sym_with_DASH_precision.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_precision, sym__AMP_, sym_exprs)), kw_doc, "Sets the precision and rounding mode to be used for BigDecimal operations.\n\n  Usage: (with-precision 10 (/ 1M 3))\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\n\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(11), kw_line, int(5110), kw_end_DASH_line, int(5110))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "vec__65"
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp9 := checkDerefVar(var_glojure_DOT_core_first)
					tmp10 := lang.Apply(tmp9, []any{v5})
					tmp11 := lang.Apply(tmp8, []any{tmp10, kw_rounding})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_next)
						tmp13 := checkDerefVar(var_glojure_DOT_core_next)
						tmp14 := lang.Apply(tmp13, []any{v5})
						tmp15 := lang.Apply(tmp12, []any{tmp14})
						tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp17 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp18 := checkDerefVar(var_glojure_DOT_core_list)
						tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp21 := checkDerefVar(var_glojure_DOT_core_list)
						tmp22 := lang.Apply(tmp21, []any{sym__DOT_})
						tmp23 := checkDerefVar(var_glojure_DOT_core_list)
						tmp24 := lang.Apply(tmp23, []any{sym_java_DOT_math_DOT_RoundingMode})
						tmp25 := checkDerefVar(var_glojure_DOT_core_list)
						tmp26 := checkDerefVar(var_glojure_DOT_core_second)
						tmp27 := lang.Apply(tmp26, []any{v5})
						tmp28 := lang.Apply(tmp25, []any{tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp22, tmp24, tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp18, []any{tmp30})
						tmp32 := lang.Apply(tmp17, []any{tmp31})
						tmp33 := lang.Apply(tmp16, []any{tmp32})
						tmp34 := lang.NewVector(tmp15, tmp33)
						tmp35 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5121), kw_column, int(23), kw_end_DASH_line, int(5122), kw_end_DASH_column, int(69))
						tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp7 = tmp36
					} else {
						tmp37 := lang.NewVector(v5, nil)
						tmp38 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5123), kw_column, int(23), kw_end_DASH_line, int(5123), kw_end_DASH_column, int(33))
						tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp7 = tmp39
					}
					var v40 any = tmp7
					_ = v40
					// let binding "body"
					tmp41 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp42 := lang.Apply(tmp41, []any{v40, int64(0), nil})
					var v43 any = tmp42
					_ = v43
					// let binding "rm"
					tmp44 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp45 := lang.Apply(tmp44, []any{v40, int64(1), nil})
					var v46 any = tmp45
					_ = v46
					tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp49 := checkDerefVar(var_glojure_DOT_core_list)
					tmp50 := lang.Apply(tmp49, []any{sym_glojure_DOT_core_SLASH_binding})
					tmp51 := checkDerefVar(var_glojure_DOT_core_list)
					tmp52 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp53 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp54 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp55 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp56 := checkDerefVar(var_glojure_DOT_core_list)
					tmp57 := lang.Apply(tmp56, []any{sym_glojure_DOT_core_SLASH__STAR_math_DASH_context_STAR_})
					tmp58 := checkDerefVar(var_glojure_DOT_core_list)
					tmp59 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp60 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp61 := checkDerefVar(var_glojure_DOT_core_list)
					tmp62 := lang.Apply(tmp61, []any{sym_java_DOT_math_DOT_MathContext_DOT_})
					tmp63 := checkDerefVar(var_glojure_DOT_core_list)
					tmp64 := lang.Apply(tmp63, []any{v4})
					tmp65 := lang.Apply(tmp60, []any{tmp62, tmp64, v46})
					tmp66 := lang.Apply(tmp59, []any{tmp65})
					tmp67 := lang.Apply(tmp58, []any{tmp66})
					tmp68 := lang.Apply(tmp55, []any{tmp57, tmp67})
					tmp69 := lang.Apply(tmp54, []any{tmp68})
					tmp70 := lang.Apply(tmp52, []any{tmp53, tmp69})
					tmp71 := lang.Apply(tmp51, []any{tmp70})
					tmp72 := lang.Apply(tmp48, []any{tmp50, tmp71, v43})
					tmp73 := lang.Apply(tmp47, []any{tmp72})
					tmp6 = tmp73
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_with_DASH_precision = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_with_DASH_precision.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-redefs
	{
		tmp0 := sym_with_DASH_redefs.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "binding => var-symbol temp-value-expr\n\n  Temporarily redefines Vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var.  After the body is\n  executed, the root values of all the Vars will be set back to their\n  old values.  These temporary changes will be visible in all threads.\n  Useful for mocking out functions during testing.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(11), kw_line, int(7544), kw_end_DASH_line, int(7544))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_with_DASH_redefs_DASH_fn})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_zipmap)
				tmp12 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp13 lang.FnFunc
				tmp13 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v14 := args[0]
					_ = v14
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_var, v14})
					return tmp16
				})
				tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7555), kw_column, int(34), kw_end_DASH_line, int(7555), kw_end_DASH_column, int(47))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp16 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
				tmp17 := lang.Apply(tmp16, []any{int64(2), v4})
				tmp18 := lang.Apply(tmp12, []any{tmp15, tmp17})
				tmp19 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
				tmp20 := checkDerefVar(var_glojure_DOT_core_next)
				tmp21 := lang.Apply(tmp20, []any{v4})
				tmp22 := lang.Apply(tmp19, []any{int64(2), tmp21})
				tmp23 := lang.Apply(tmp11, []any{tmp18, tmp22})
				tmp24 := lang.Apply(tmp10, []any{tmp23})
				tmp25 := checkDerefVar(var_glojure_DOT_core_list)
				tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp27 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp28 := checkDerefVar(var_glojure_DOT_core_list)
				tmp29 := lang.Apply(tmp28, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp30 := checkDerefVar(var_glojure_DOT_core_list)
				tmp31 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp32 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp33 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp34 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp35 := lang.Apply(tmp34, nil)
				tmp36 := lang.Apply(tmp33, []any{tmp35})
				tmp37 := lang.Apply(tmp31, []any{tmp32, tmp36})
				tmp38 := lang.Apply(tmp30, []any{tmp37})
				tmp39 := lang.Apply(tmp27, []any{tmp29, tmp38, v5})
				tmp40 := lang.Apply(tmp26, []any{tmp39})
				tmp41 := lang.Apply(tmp25, []any{tmp40})
				tmp42 := lang.Apply(tmp7, []any{tmp9, tmp24, tmp41})
				tmp43 := lang.Apply(tmp6, []any{tmp42})
				return tmp43
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_with_DASH_redefs = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_with_DASH_redefs.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-redefs-fn
	{
		tmp0 := sym_with_DASH_redefs_DASH_fn.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_binding_DASH_map, sym_func)), kw_doc, "Temporarily redefines Vars during a call to func.  Each val of\n  binding-map will replace the root value of its key which must be\n  a Var.  After func is called with no args, the root values of all\n  the Vars will be set back to their old values.  These temporary\n  changes will be visible in all threads.  Useful for mocking out\n  functions during testing.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(7524), kw_end_DASH_line, int(7524))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "root-bind"
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v6 := args[0]
					_ = v6
					var tmp7 any
					{ // let
						// let binding "seq_338"
						tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v6})
						var v10 any = tmp9
						_ = v10
						// let binding "chunk_339"
						var v11 any = nil
						_ = v11
						// let binding "count_340"
						var v12 any = int64(0)
						_ = v12
						// let binding "i_341"
						var v13 any = int64(0)
						_ = v13
						for {
							var tmp14 any
							tmp15 := checkDerefVar(var_glojure_DOT_core__LT_)
							tmp16 := lang.Apply(tmp15, []any{v13, v12})
							if lang.IsTruthy(tmp16) {
								var tmp17 any
								{ // let
									// let binding "vec__342"
									tmp18, _ := lang.FieldOrMethod(v11, "nth")
									if reflect.TypeOf(tmp18).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp19 := lang.Apply(tmp18, []any{v13})
									var v20 any = tmp19
									_ = v20
									// let binding "a-var"
									tmp21 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp22 := lang.Apply(tmp21, []any{v20, int64(0), nil})
									var v23 any = tmp22
									_ = v23
									// let binding "a-val"
									tmp24 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp25 := lang.Apply(tmp24, []any{v20, int64(1), nil})
									var v26 any = tmp25
									_ = v26
									tmp27, _ := lang.FieldOrMethod(v23, "bindRoot")
									if reflect.TypeOf(tmp27).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("bindRoot is not a function")))
									}
									tmp28 := lang.Apply(tmp27, []any{v26})
									_ = tmp28
									var tmp29 any = v10
									var tmp30 any = v11
									var tmp31 any = v12
									tmp33 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
									tmp34 := lang.Apply(tmp33, []any{v13})
									var tmp32 any = tmp34
									v10 = tmp29
									v11 = tmp30
									v12 = tmp31
									v13 = tmp32
									continue
								} // end let
								tmp14 = tmp17
							} else {
								var tmp18 any
								{ // let
									// let binding "temp__0__auto__"
									tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp20 := lang.Apply(tmp19, []any{v10})
									var v21 any = tmp20
									_ = v21
									var tmp22 any
									if lang.IsTruthy(v21) {
										var tmp23 any
										{ // let
											// let binding "seq_338"
											var v24 any = v21
											_ = v24
											var tmp25 any
											tmp26 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
											tmp27 := lang.Apply(tmp26, []any{v24})
											if lang.IsTruthy(tmp27) {
												var tmp28 any
												{ // let
													// let binding "c__0__auto__"
													tmp29 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
													tmp30 := lang.Apply(tmp29, []any{v24})
													var v31 any = tmp30
													_ = v31
													tmp33 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
													tmp34 := lang.Apply(tmp33, []any{v24})
													var tmp32 any = tmp34
													var tmp35 any = v31
													tmp37 := checkDerefVar(var_glojure_DOT_core_int)
													tmp38 := checkDerefVar(var_glojure_DOT_core_count)
													tmp39 := lang.Apply(tmp38, []any{v31})
													tmp40 := lang.Apply(tmp37, []any{tmp39})
													var tmp36 any = tmp40
													tmp42 := checkDerefVar(var_glojure_DOT_core_int)
													tmp43 := lang.Apply(tmp42, []any{int64(0)})
													var tmp41 any = tmp43
													v10 = tmp32
													v11 = tmp35
													v12 = tmp36
													v13 = tmp41
													continue
												} // end let
												tmp25 = tmp28
											} else {
												var tmp29 any
												{ // let
													// let binding "vec__345"
													tmp30 := checkDerefVar(var_glojure_DOT_core_first)
													tmp31 := lang.Apply(tmp30, []any{v24})
													var v32 any = tmp31
													_ = v32
													// let binding "a-var"
													tmp33 := checkDerefVar(var_glojure_DOT_core_nth)
													tmp34 := lang.Apply(tmp33, []any{v32, int64(0), nil})
													var v35 any = tmp34
													_ = v35
													// let binding "a-val"
													tmp36 := checkDerefVar(var_glojure_DOT_core_nth)
													tmp37 := lang.Apply(tmp36, []any{v32, int64(1), nil})
													var v38 any = tmp37
													_ = v38
													tmp39, _ := lang.FieldOrMethod(v35, "bindRoot")
													if reflect.TypeOf(tmp39).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("bindRoot is not a function")))
													}
													tmp40 := lang.Apply(tmp39, []any{v38})
													_ = tmp40
													tmp42 := checkDerefVar(var_glojure_DOT_core_next)
													tmp43 := lang.Apply(tmp42, []any{v24})
													var tmp41 any = tmp43
													var tmp44 any = nil
													var tmp45 any = int64(0)
													var tmp46 any = int64(0)
													v10 = tmp41
													v11 = tmp44
													v12 = tmp45
													v13 = tmp46
													continue
												} // end let
												tmp25 = tmp29
											}
											tmp23 = tmp25
										} // end let
										tmp22 = tmp23
									} else {
									}
									tmp18 = tmp22
								} // end let
								tmp14 = tmp18
							}
							tmp7 = tmp14
							break
						}
					} // end let
					return tmp7
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7533), kw_column, int(19), kw_end_DASH_line, int(7535), kw_end_DASH_column, int(93))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v8 any = tmp7
				_ = v8
				// let binding "old-vals"
				tmp9 := checkDerefVar(var_glojure_DOT_core_zipmap)
				tmp10 := checkDerefVar(var_glojure_DOT_core_keys)
				tmp11 := lang.Apply(tmp10, []any{v2})
				tmp12 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp13 lang.FnFunc
				tmp13 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v14 := args[0]
					_ = v14
					tmp15, ok := lang.FieldOrMethod(v14, "getRawRoot")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "getRawRoot")))
					}
					var tmp16 any
					switch reflect.TypeOf(tmp15).Kind() {
					case reflect.Func:
						tmp16 = lang.Apply(tmp15, nil)
					default:
						tmp16 = tmp15
					}
					return tmp16
				})
				tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7537), kw_column, int(31), kw_end_DASH_line, int(7537), kw_end_DASH_column, int(92))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp16 := checkDerefVar(var_glojure_DOT_core_keys)
				tmp17 := lang.Apply(tmp16, []any{v2})
				tmp18 := lang.Apply(tmp12, []any{tmp15, tmp17})
				tmp19 := lang.Apply(tmp9, []any{tmp11, tmp18})
				var v20 any = tmp19
				_ = v20
				var tmp21 any
				func() {
					defer func() {
						tmp22 := lang.Apply(v8, []any{v20})
						_ = tmp22
					}()
					tmp23 := lang.Apply(v8, []any{v2})
					_ = tmp23
					tmp24 := lang.Apply(v3, nil)
					tmp21 = tmp24
				}()
				tmp4 = tmp21
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_with_DASH_redefs_DASH_fn = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_with_DASH_redefs_DASH_fn.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed6
					} else {
						tmp4 = closed7
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed6
					} else {
						tmp5 = closed7
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed6
					} else {
						tmp6 = closed7
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(0)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__DASH_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Does not auto-promote\n  longs, will throw on overflow. See also: -'", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(1036), kw_end_DASH_line, int(1036))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_)
				tmp6 := lang.Apply(tmp5, []any{int64(-1), v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "minus")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("minus is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core__DASH_)
				tmp9 := checkDerefVar(var_glojure_DOT_core__DASH_)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__DASH_ = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__DASH_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed8
					} else {
						tmp4 = closed8
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed8
					} else {
						tmp5 = closed8
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed8
					} else {
						tmp6 = closed8
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3, int64(0)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__DASH__TICK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Supports arbitrary precision.\n  See also: -", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(1024), kw_end_DASH_line, int(1024))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core__STAR__TICK_)
				tmp6 := lang.Apply(tmp5, []any{int64(-1), v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "minusP")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("minusP is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp8 := checkDerefVar(var_glojure_DOT_core__DASH__TICK_)
				tmp9 := checkDerefVar(var_glojure_DOT_core__DASH__TICK_)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core__DASH__TICK_ = ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__DASH__TICK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// agent
	{
		tmp0 := sym_agent.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_state, sym__AMP_, sym_options)), kw_doc, "Creates and returns an agent with an initial value of state and\n  zero or more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :error-handler handler-fn\n\n  :error-mode mode-keyword\n\n  If metadata-map is supplied, it will become the metadata on the\n  agent. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.  handler-fn is called if an\n  action throws an exception or if validate-fn rejects a new state --\n  see set-error-handler! for details.  The mode-keyword may be either\n  :continue (the default if an error-handler is given) or :fail (the\n  default if no error-handler is given) -- see set-error-mode! for\n  details.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(2052), kw_end_DASH_line, int(2052))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "a"
					tmp5 := new(*lang.Agent)
					var v6 any = tmp5
					_ = v6
					// let binding "opts"
					tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp8 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
					var v10 any = tmp9
					_ = v10
					tmp11 := checkDerefVar(var_glojure_DOT_core_setup_DASH_reference)
					tmp12 := lang.Apply(tmp11, []any{v6, v3})
					_ = tmp12
					var tmp13 any
					tmp14 := lang.Apply(kw_error_DASH_handler, []any{v10})
					if lang.IsTruthy(tmp14) {
						tmp15 := lang.Apply(kw_error_DASH_handler, []any{v10})
						tmp16, _ := lang.FieldOrMethod(v6, "setErrorHandler")
						if reflect.TypeOf(tmp16).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorHandler is not a function")))
						}
						tmp17 := lang.Apply(tmp16, []any{tmp15})
						tmp13 = tmp17
					} else {
					}
					_ = tmp13
					var tmp18 any
					{ // let
						// let binding "or__0__auto__"
						tmp19 := lang.Apply(kw_error_DASH_mode, []any{v10})
						var v20 any = tmp19
						_ = v20
						var tmp21 any
						if lang.IsTruthy(v20) {
							tmp21 = v20
						} else {
							var tmp22 any
							tmp23 := lang.Apply(kw_error_DASH_handler, []any{v10})
							if lang.IsTruthy(tmp23) {
								tmp22 = kw_continue
							} else {
								tmp22 = kw_fail
							}
							tmp21 = tmp22
						}
						tmp18 = tmp21
					} // end let
					tmp19, _ := lang.FieldOrMethod(v6, "setErrorMode")
					if reflect.TypeOf(tmp19).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorMode is not a function")))
					}
					tmp20 := lang.Apply(tmp19, []any{tmp18})
					_ = tmp20
					tmp4 = v6
				} // end let
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_agent = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_agent.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aget
	{
		var tmp1 lang.FnFunc
		{ // function aget__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Aget})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp21 := checkDerefVar(var_glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{sym_glojure_DOT_core_SLASH_int})
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := lang.Apply(tmp23, []any{v4})
				tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
				tmp26 := lang.Apply(tmp19, []any{tmp25})
				tmp27 := lang.Apply(tmp18, []any{tmp26})
				tmp28 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp27})
				tmp29 := lang.Apply(tmp12, []any{tmp28})
				tmp30 := lang.Apply(tmp11, []any{tmp29})
				tmp31 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp30})
				tmp32 := lang.Apply(tmp5, []any{tmp31})
				return tmp32
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_aget.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx), lang.NewVector(sym_array, sym_idx, sym__AMP_, sym_idxs)), kw_inline, tmp1, kw_doc, "Returns the value at the index/indices. Works on Java arrays of all\n  types.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3911), kw_end_DASH_line, int(3911))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.Get, []any{v3, v4})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp9 := lang.Apply(tmp8, []any{v3, v4})
				tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9, v5})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_aget = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_aget.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// amap
	{
		tmp0 := sym_amap.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_idx, sym_ret, sym_expr)), kw_doc, "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting \n  each element of ret to the evaluation of expr, returning the new \n  array ret.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(5273), kw_end_DASH_line, int(5273))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 6)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			v6 := args[4]
			_ = v6
			v7 := args[5]
			_ = v7
			tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp10 := checkDerefVar(var_glojure_DOT_core_list)
			tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_let})
			tmp12 := checkDerefVar(var_glojure_DOT_core_list)
			tmp13 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp14 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp17 := checkDerefVar(var_glojure_DOT_core_list)
			tmp18 := lang.Apply(tmp17, []any{sym_a__0__auto__})
			tmp19 := checkDerefVar(var_glojure_DOT_core_list)
			tmp20 := lang.Apply(tmp19, []any{v4})
			tmp21 := checkDerefVar(var_glojure_DOT_core_list)
			tmp22 := lang.Apply(tmp21, []any{sym_l__1__auto__})
			tmp23 := checkDerefVar(var_glojure_DOT_core_list)
			tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp26 := checkDerefVar(var_glojure_DOT_core_list)
			tmp27 := lang.Apply(tmp26, []any{sym_glojure_DOT_core_SLASH_alength})
			tmp28 := checkDerefVar(var_glojure_DOT_core_list)
			tmp29 := lang.Apply(tmp28, []any{sym_a__0__auto__})
			tmp30 := lang.Apply(tmp25, []any{tmp27, tmp29})
			tmp31 := lang.Apply(tmp24, []any{tmp30})
			tmp32 := lang.Apply(tmp23, []any{tmp31})
			tmp33 := checkDerefVar(var_glojure_DOT_core_list)
			tmp34 := lang.Apply(tmp33, []any{v6})
			tmp35 := checkDerefVar(var_glojure_DOT_core_list)
			tmp36 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp37 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp38 := checkDerefVar(var_glojure_DOT_core_list)
			tmp39 := lang.Apply(tmp38, []any{sym_glojure_DOT_core_SLASH_aclone})
			tmp40 := checkDerefVar(var_glojure_DOT_core_list)
			tmp41 := lang.Apply(tmp40, []any{sym_a__0__auto__})
			tmp42 := lang.Apply(tmp37, []any{tmp39, tmp41})
			tmp43 := lang.Apply(tmp36, []any{tmp42})
			tmp44 := lang.Apply(tmp35, []any{tmp43})
			tmp45 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22, tmp32, tmp34, tmp44})
			tmp46 := lang.Apply(tmp15, []any{tmp45})
			tmp47 := lang.Apply(tmp13, []any{tmp14, tmp46})
			tmp48 := lang.Apply(tmp12, []any{tmp47})
			tmp49 := checkDerefVar(var_glojure_DOT_core_list)
			tmp50 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp51 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp52 := checkDerefVar(var_glojure_DOT_core_list)
			tmp53 := lang.Apply(tmp52, []any{sym_glojure_DOT_core_SLASH_loop})
			tmp54 := checkDerefVar(var_glojure_DOT_core_list)
			tmp55 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp56 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp57 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp58 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp59 := checkDerefVar(var_glojure_DOT_core_list)
			tmp60 := lang.Apply(tmp59, []any{v5})
			tmp61 := checkDerefVar(var_glojure_DOT_core_list)
			tmp62 := lang.Apply(tmp61, []any{int64(0)})
			tmp63 := lang.Apply(tmp58, []any{tmp60, tmp62})
			tmp64 := lang.Apply(tmp57, []any{tmp63})
			tmp65 := lang.Apply(tmp55, []any{tmp56, tmp64})
			tmp66 := lang.Apply(tmp54, []any{tmp65})
			tmp67 := checkDerefVar(var_glojure_DOT_core_list)
			tmp68 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp69 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp70 := checkDerefVar(var_glojure_DOT_core_list)
			tmp71 := lang.Apply(tmp70, []any{sym_if})
			tmp72 := checkDerefVar(var_glojure_DOT_core_list)
			tmp73 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp74 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp75 := checkDerefVar(var_glojure_DOT_core_list)
			tmp76 := lang.Apply(tmp75, []any{sym_glojure_DOT_core_SLASH__LT_})
			tmp77 := checkDerefVar(var_glojure_DOT_core_list)
			tmp78 := lang.Apply(tmp77, []any{v5})
			tmp79 := checkDerefVar(var_glojure_DOT_core_list)
			tmp80 := lang.Apply(tmp79, []any{sym_l__1__auto__})
			tmp81 := lang.Apply(tmp74, []any{tmp76, tmp78, tmp80})
			tmp82 := lang.Apply(tmp73, []any{tmp81})
			tmp83 := lang.Apply(tmp72, []any{tmp82})
			tmp84 := checkDerefVar(var_glojure_DOT_core_list)
			tmp85 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp86 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp87 := checkDerefVar(var_glojure_DOT_core_list)
			tmp88 := lang.Apply(tmp87, []any{sym_do})
			tmp89 := checkDerefVar(var_glojure_DOT_core_list)
			tmp90 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp91 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp92 := checkDerefVar(var_glojure_DOT_core_list)
			tmp93 := lang.Apply(tmp92, []any{sym_glojure_DOT_core_SLASH_aset})
			tmp94 := checkDerefVar(var_glojure_DOT_core_list)
			tmp95 := lang.Apply(tmp94, []any{v6})
			tmp96 := checkDerefVar(var_glojure_DOT_core_list)
			tmp97 := lang.Apply(tmp96, []any{v5})
			tmp98 := checkDerefVar(var_glojure_DOT_core_list)
			tmp99 := lang.Apply(tmp98, []any{v7})
			tmp100 := lang.Apply(tmp91, []any{tmp93, tmp95, tmp97, tmp99})
			tmp101 := lang.Apply(tmp90, []any{tmp100})
			tmp102 := lang.Apply(tmp89, []any{tmp101})
			tmp103 := checkDerefVar(var_glojure_DOT_core_list)
			tmp104 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp105 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp106 := checkDerefVar(var_glojure_DOT_core_list)
			tmp107 := lang.Apply(tmp106, []any{sym_recur})
			tmp108 := checkDerefVar(var_glojure_DOT_core_list)
			tmp109 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp110 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp111 := checkDerefVar(var_glojure_DOT_core_list)
			tmp112 := lang.Apply(tmp111, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc})
			tmp113 := checkDerefVar(var_glojure_DOT_core_list)
			tmp114 := lang.Apply(tmp113, []any{v5})
			tmp115 := lang.Apply(tmp110, []any{tmp112, tmp114})
			tmp116 := lang.Apply(tmp109, []any{tmp115})
			tmp117 := lang.Apply(tmp108, []any{tmp116})
			tmp118 := lang.Apply(tmp105, []any{tmp107, tmp117})
			tmp119 := lang.Apply(tmp104, []any{tmp118})
			tmp120 := lang.Apply(tmp103, []any{tmp119})
			tmp121 := lang.Apply(tmp86, []any{tmp88, tmp102, tmp120})
			tmp122 := lang.Apply(tmp85, []any{tmp121})
			tmp123 := lang.Apply(tmp84, []any{tmp122})
			tmp124 := checkDerefVar(var_glojure_DOT_core_list)
			tmp125 := lang.Apply(tmp124, []any{v6})
			tmp126 := lang.Apply(tmp69, []any{tmp71, tmp83, tmp123, tmp125})
			tmp127 := lang.Apply(tmp68, []any{tmp126})
			tmp128 := lang.Apply(tmp67, []any{tmp127})
			tmp129 := lang.Apply(tmp51, []any{tmp53, tmp66, tmp128})
			tmp130 := lang.Apply(tmp50, []any{tmp129})
			tmp131 := lang.Apply(tmp49, []any{tmp130})
			tmp132 := lang.Apply(tmp9, []any{tmp11, tmp48, tmp131})
			tmp133 := lang.Apply(tmp8, []any{tmp132})
			return tmp133
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_amap = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_amap.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ancestors
	{
		tmp0 := sym_ancestors.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag), lang.NewVector(sym_h, sym_tag)), kw_doc, "Returns the immediate and indirect parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(5577), kw_end_DASH_line, int(5577))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_ancestors)
				tmp4 := checkDerefVar(var_glojure_DOT_core_global_DASH_hierarchy)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
				var tmp5 any
				{ // let
					// let binding "ta"
					tmp6 := checkDerefVar(var_glojure_DOT_core_get)
					tmp7 := lang.Apply(kw_ancestors, []any{v2})
					tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
					tmp12 := lang.Apply(tmp11, []any{v3})
					if lang.IsTruthy(tmp12) {
						var tmp13 any
						{ // let
							// let binding "superclasses"
							tmp14 := checkDerefVar(var_glojure_DOT_core_set)
							tmp15 := checkDerefVar(var_glojure_DOT_core_supers)
							tmp16 := lang.Apply(tmp15, []any{v3})
							tmp17 := lang.Apply(tmp14, []any{tmp16})
							var v18 any = tmp17
							_ = v18
							tmp19 := checkDerefVar(var_glojure_DOT_core_reduce1)
							tmp20 := checkDerefVar(var_glojure_DOT_core_into1)
							tmp21 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp22 := checkDerefVar(var_glojure_DOT_core_map)
							var tmp23 lang.FnFunc
							tmp23 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v24 := args[0]
								_ = v24
								tmp25 := checkDerefVar(var_glojure_DOT_core_get)
								tmp26 := lang.Apply(kw_ancestors, []any{v2})
								tmp27 := lang.Apply(tmp25, []any{tmp26, v24})
								return tmp27
							})
							tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5590), kw_column, int(32), kw_end_DASH_line, int(5590), kw_end_DASH_column, int(54))
							tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp26 := lang.Apply(tmp22, []any{tmp25, v18})
							tmp27 := lang.Apply(tmp21, []any{v9, tmp26})
							tmp28 := lang.Apply(tmp19, []any{tmp20, v18, tmp27})
							tmp13 = tmp28
						} // end let
						tmp10 = tmp13
					} else {
						tmp10 = v9
					}
					tmp5 = tmp10
				} // end let
				tmp6 := lang.Apply(tmp4, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ancestors = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ancestors.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// and
	{
		tmp0 := sym_and.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_next)), kw_doc, "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(11), kw_line, int(835), kw_end_DASH_line, int(835))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				return true
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				return v4
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_let})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_and__0__auto__})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v4})
				tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp13, []any{tmp19})
				tmp21 := lang.Apply(tmp11, []any{tmp12, tmp20})
				tmp22 := lang.Apply(tmp10, []any{tmp21})
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp26 := checkDerefVar(var_glojure_DOT_core_list)
				tmp27 := lang.Apply(tmp26, []any{sym_if})
				tmp28 := checkDerefVar(var_glojure_DOT_core_list)
				tmp29 := lang.Apply(tmp28, []any{sym_and__0__auto__})
				tmp30 := checkDerefVar(var_glojure_DOT_core_list)
				tmp31 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp32 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp33 := checkDerefVar(var_glojure_DOT_core_list)
				tmp34 := lang.Apply(tmp33, []any{sym_glojure_DOT_core_SLASH_and})
				tmp35 := lang.Apply(tmp32, []any{tmp34, v5})
				tmp36 := lang.Apply(tmp31, []any{tmp35})
				tmp37 := lang.Apply(tmp30, []any{tmp36})
				tmp38 := checkDerefVar(var_glojure_DOT_core_list)
				tmp39 := lang.Apply(tmp38, []any{sym_and__0__auto__})
				tmp40 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp37, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp23, []any{tmp41})
				tmp43 := lang.Apply(tmp7, []any{tmp9, tmp22, tmp42})
				tmp44 := lang.Apply(tmp6, []any{tmp43})
				return tmp44
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_and = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_and.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// array-map
	{
		tmp0 := sym_array_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym__AMP_, sym_keyvals)), kw_doc, "Constructs an array-map. If any keys are equal, they are handled as\n  if by repeated uses of assoc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4378), kw_end_DASH_line, int(4378))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2, ok := lang.FieldOrMethod(nil, "EMPTY")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "EMPTY")))
				}
				var tmp3 any
				switch reflect.TypeOf(tmp2).Kind() {
				case reflect.Func:
					tmp3 = lang.Apply(tmp2, nil)
				default:
					tmp3 = tmp2
				}
				return tmp3
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				var tmp3 any
				{ // let
					// let binding "ary"
					tmp4 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
					tmp5 := lang.Apply(tmp4, []any{v2})
					var v6 any = tmp5
					_ = v6
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core_odd_QMARK_)
					tmp9 := checkDerefVar(var_glojure_DOT_core_alength)
					tmp10 := lang.Apply(tmp9, []any{v6})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_str)
						tmp13 := checkDerefVar(var_glojure_DOT_core_last)
						tmp14 := lang.Apply(tmp13, []any{v2})
						tmp15 := lang.Apply(tmp12, []any{"No value supplied for key: ", tmp14})
						tmp16 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp15})
						panic(tmp16)
					} else {
						tmp17 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{v6})
						tmp7 = tmp17
					}
					tmp3 = tmp7
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_array_DASH_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_array_DASH_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset
	{
		var tmp1 lang.FnFunc
		{ // function aset__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym__DOT_})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_Aset})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := checkDerefVar(var_glojure_DOT_core_list)
				tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp22 := checkDerefVar(var_glojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{sym_glojure_DOT_core_SLASH_int})
				tmp24 := checkDerefVar(var_glojure_DOT_core_list)
				tmp25 := lang.Apply(tmp24, []any{v4})
				tmp26 := lang.Apply(tmp21, []any{tmp23, tmp25})
				tmp27 := lang.Apply(tmp20, []any{tmp26})
				tmp28 := lang.Apply(tmp19, []any{tmp27})
				tmp29 := checkDerefVar(var_glojure_DOT_core_list)
				tmp30 := lang.Apply(tmp29, []any{v5})
				tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp28, tmp30})
				tmp32 := lang.Apply(tmp13, []any{tmp31})
				tmp33 := lang.Apply(tmp12, []any{tmp32})
				tmp34 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp33})
				tmp35 := lang.Apply(tmp6, []any{tmp34})
				return tmp35
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_aset.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_inline, tmp1, kw_doc, "Sets the value at the index/indices. Works on Java arrays of\n  reference types. Returns val.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(3)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3922), kw_end_DASH_line, int(3922))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.Apply(lang.SliceSet, []any{v3, v4, v5})
				_ = tmp6
				return v5
			default:
				checkArityGTE(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aset)
				tmp9 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_aset = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_aset.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-boolean
	{
		tmp0 := sym_aset_DASH_boolean.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of boolean. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(3), kw_line, int(3956), kw_end_DASH_line, int(3958))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_boolean)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7, _ := lang.FieldOrMethod(nil, "setBoolean")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setBoolean is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v2, v3, tmp6})
				_ = tmp8
				return v4
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_aset_DASH_boolean)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9, v4, v5})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_aset_DASH_boolean = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_aset_DASH_boolean.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-byte
	{
		tmp0 := sym_aset_DASH_byte.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of byte. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(3), kw_line, int(3976), kw_end_DASH_line, int(3978))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_byte)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7, _ := lang.FieldOrMethod(nil, "setByte")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setByte is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v2, v3, tmp6})
				_ = tmp8
				return v4
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_aset_DASH_byte)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9, v4, v5})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_aset_DASH_byte = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_aset_DASH_byte.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-char
	{
		tmp0 := sym_aset_DASH_char.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of char. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(3), kw_line, int(3981), kw_end_DASH_line, int(3983))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_char)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7, _ := lang.FieldOrMethod(nil, "setChar")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setChar is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v2, v3, tmp6})
				_ = tmp8
				return v4
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_aset_DASH_char)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9, v4, v5})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_aset_DASH_char = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_aset_DASH_char.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-double
	{
		tmp0 := sym_aset_DASH_double.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of double. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(3), kw_line, int(3966), kw_end_DASH_line, int(3968))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_double)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7, _ := lang.FieldOrMethod(nil, "setDouble")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setDouble is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v2, v3, tmp6})
				_ = tmp8
				return v4
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_aset_DASH_double)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9, v4, v5})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_aset_DASH_double = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_aset_DASH_double.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-float
	{
		tmp0 := sym_aset_DASH_float.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of float. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(3), kw_line, int(3961), kw_end_DASH_line, int(3963))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_float)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7, _ := lang.FieldOrMethod(nil, "setFloat")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setFloat is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v2, v3, tmp6})
				_ = tmp8
				return v4
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_aset_DASH_float)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9, v4, v5})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_aset_DASH_float = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_aset_DASH_float.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-int
	{
		tmp0 := sym_aset_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of int. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(3), kw_line, int(3946), kw_end_DASH_line, int(3948))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_int)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7, _ := lang.FieldOrMethod(nil, "setInt")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setInt is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v2, v3, tmp6})
				_ = tmp8
				return v4
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_aset_DASH_int)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9, v4, v5})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_aset_DASH_int = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_aset_DASH_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-long
	{
		tmp0 := sym_aset_DASH_long.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of long. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(3), kw_line, int(3951), kw_end_DASH_line, int(3953))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_long)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7, _ := lang.FieldOrMethod(nil, "setLong")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setLong is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v2, v3, tmp6})
				_ = tmp8
				return v4
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_aset_DASH_long)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9, v4, v5})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_aset_DASH_long = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_aset_DASH_long.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-short
	{
		tmp0 := sym_aset_DASH_short.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of short. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(3), kw_line, int(3971), kw_end_DASH_line, int(3973))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_short)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7, _ := lang.FieldOrMethod(nil, "setShort")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setShort is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v2, v3, tmp6})
				_ = tmp8
				return v4
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_aset_DASH_short)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9, v4, v5})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_aset_DASH_short = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_aset_DASH_short.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert-valid-fdecl
	{
		tmp0 := sym_assert_DASH_valid_DASH_fdecl.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_fdecl)), kw_doc, "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(42), kw_column, int(8), kw_line, int(7502), kw_end_DASH_line, int(7502), kw_private, true, kw_dynamic, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp6 := lang.Apply(lang.NewIllegalArgumentError, []any{"Parameter declaration missing"})
				panic(tmp6)
			} else {
			}
			_ = tmp3
			var tmp7 any
			{ // let
				// let binding "argdecls"
				tmp8 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp9 lang.FnFunc
				tmp9 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v10 := args[0]
					_ = v10
					var tmp11 any
					tmp12 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
					tmp13 := lang.Apply(tmp12, []any{v10})
					if lang.IsTruthy(tmp13) {
						tmp14 := checkDerefVar(var_glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v10})
						tmp11 = tmp15
					} else {
						var tmp16 any
						tmp17 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp18 := checkDerefVar(var_glojure_DOT_core_first)
						tmp19 := lang.Apply(tmp18, []any{v2})
						tmp20 := lang.Apply(tmp17, []any{tmp19})
						if lang.IsTruthy(tmp20) {
							tmp21 := checkDerefVar(var_glojure_DOT_core_str)
							tmp22 := lang.Apply(tmp21, []any{"Invalid signature \"", v10, "\" should be a list"})
							tmp16 = tmp22
						} else {
							tmp23 := checkDerefVar(var_glojure_DOT_core_str)
							tmp24 := lang.Apply(tmp23, []any{"Parameter declaration \"", v10, "\" should be a vector"})
							tmp16 = tmp24
						}
						tmp25 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
						panic(tmp25)
					}
					return tmp11
				})
				tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7508), kw_column, int(20), kw_end_DASH_line, int(7517), kw_end_DASH_column, int(59))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := lang.Apply(tmp8, []any{tmp11, v2})
				var v13 any = tmp12
				_ = v13
				// let binding "bad-args"
				tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp15 := checkDerefVar(var_glojure_DOT_core_remove)
				var tmp16 lang.FnFunc
				tmp16 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v17 := args[0]
					_ = v17
					tmp18 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
					tmp19 := lang.Apply(tmp18, []any{v17})
					return tmp19
				})
				tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7519), kw_column, int(31), kw_end_DASH_line, int(7519), kw_end_DASH_column, int(42))
				tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp19 := lang.Apply(tmp15, []any{tmp18, v13})
				tmp20 := lang.Apply(tmp14, []any{tmp19})
				var v21 any = tmp20
				_ = v21
				var tmp22 any
				if lang.IsTruthy(v21) {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v21})
					tmp26 := lang.Apply(tmp23, []any{"Parameter declaration \"", tmp25, "\" should be a vector"})
					tmp27 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp26})
					panic(tmp27)
				} else {
				}
				tmp7 = tmp22
			} // end let
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_assert_DASH_valid_DASH_fdecl = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_assert_DASH_valid_DASH_fdecl.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core_assert_DASH_valid_DASH_fdecl.SetDynamic()
	}
	// atom
	{
		tmp0 := sym_atom.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_options)), kw_doc, "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2325), kw_end_DASH_line, int(2325))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := lang.Apply(lang.NewAtom, []any{v2})
				return tmp3
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_setup_DASH_reference)
				tmp5 := checkDerefVar(var_glojure_DOT_core_atom)
				tmp6 := lang.Apply(tmp5, []any{v2})
				tmp7 := lang.Apply(tmp4, []any{tmp6, v3})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_atom = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_atom.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// binding
	{
		tmp0 := sym_binding.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(1945), kw_end_DASH_line, int(1945))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_str)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp12 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp14 := lang.Apply(tmp13, []any{v2})
					tmp15 := lang.Apply(kw_line, []any{tmp14})
					tmp16 := lang.Apply(tmp9, []any{tmp11, " requires ", "a vector for its binding", " in ", tmp12, ":", tmp15})
					tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
					panic(tmp17)
				}
				_ = tmp6
				var tmp18 any
				tmp19 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp20 := checkDerefVar(var_glojure_DOT_core_count)
				tmp21 := lang.Apply(tmp20, []any{v4})
				tmp22 := lang.Apply(tmp19, []any{tmp21})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "an even number of forms in binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp18
				var tmp32 any
				{ // let
					// let binding "var-ize"
					var tmp33 lang.FnFunc
					tmp33 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v34 := args[0]
						_ = v34
						var tmp35 any
						{ // let
							// let binding "ret"
							tmp36 := lang.NewVector()
							tmp37 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1959), kw_column, int(30), kw_end_DASH_line, int(1959), kw_end_DASH_column, int(31))
							tmp38, err := lang.WithMeta(tmp36, tmp37.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v39 any = tmp38
							_ = v39
							// let binding "vvs"
							tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp41 := lang.Apply(tmp40, []any{v34})
							var v42 any = tmp41
							_ = v42
							for {
								var tmp43 any
								if lang.IsTruthy(v42) {
									tmp45 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp46 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp49 := checkDerefVar(var_glojure_DOT_core_list)
									tmp50 := lang.Apply(tmp49, []any{sym_var})
									tmp51 := checkDerefVar(var_glojure_DOT_core_list)
									tmp52 := checkDerefVar(var_glojure_DOT_core_first)
									tmp53 := lang.Apply(tmp52, []any{v42})
									tmp54 := lang.Apply(tmp51, []any{tmp53})
									tmp55 := lang.Apply(tmp48, []any{tmp50, tmp54})
									tmp56 := lang.Apply(tmp47, []any{tmp55})
									tmp57 := lang.Apply(tmp46, []any{v39, tmp56})
									tmp58 := checkDerefVar(var_glojure_DOT_core_second)
									tmp59 := lang.Apply(tmp58, []any{v42})
									tmp60 := lang.Apply(tmp45, []any{tmp57, tmp59})
									var tmp44 any = tmp60
									tmp62 := checkDerefVar(var_glojure_DOT_core_next)
									tmp63 := checkDerefVar(var_glojure_DOT_core_next)
									tmp64 := lang.Apply(tmp63, []any{v42})
									tmp65 := lang.Apply(tmp62, []any{tmp64})
									var tmp61 any = tmp65
									v39 = tmp44
									v42 = tmp61
									continue
								} else {
									tmp66 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp67 := lang.Apply(tmp66, []any{v39})
									tmp43 = tmp67
								}
								tmp35 = tmp43
								break
							}
						} // end let
						return tmp35
					})
					tmp34 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1958), kw_column, int(17), kw_end_DASH_line, int(1963), kw_end_DASH_column, int(34))
					tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v36 any = tmp35
					_ = v36
					tmp37 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp38 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					tmp40 := lang.Apply(tmp39, []any{sym_glojure_DOT_core_SLASH_let})
					tmp41 := checkDerefVar(var_glojure_DOT_core_list)
					tmp42 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp43 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp44 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp45 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp46 := lang.Apply(tmp45, nil)
					tmp47 := lang.Apply(tmp44, []any{tmp46})
					tmp48 := lang.Apply(tmp42, []any{tmp43, tmp47})
					tmp49 := lang.Apply(tmp41, []any{tmp48})
					tmp50 := checkDerefVar(var_glojure_DOT_core_list)
					tmp51 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp52 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp53 := checkDerefVar(var_glojure_DOT_core_list)
					tmp54 := lang.Apply(tmp53, []any{sym_glojure_DOT_core_SLASH_push_DASH_thread_DASH_bindings})
					tmp55 := checkDerefVar(var_glojure_DOT_core_list)
					tmp56 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp57 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp58 := checkDerefVar(var_glojure_DOT_core_list)
					tmp59 := lang.Apply(tmp58, []any{sym_glojure_DOT_core_SLASH_hash_DASH_map})
					tmp60 := lang.Apply(v36, []any{v4})
					tmp61 := lang.Apply(tmp57, []any{tmp59, tmp60})
					tmp62 := lang.Apply(tmp56, []any{tmp61})
					tmp63 := lang.Apply(tmp55, []any{tmp62})
					tmp64 := lang.Apply(tmp52, []any{tmp54, tmp63})
					tmp65 := lang.Apply(tmp51, []any{tmp64})
					tmp66 := lang.Apply(tmp50, []any{tmp65})
					tmp67 := checkDerefVar(var_glojure_DOT_core_list)
					tmp68 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp69 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp70 := checkDerefVar(var_glojure_DOT_core_list)
					tmp71 := lang.Apply(tmp70, []any{sym_try})
					tmp72 := checkDerefVar(var_glojure_DOT_core_list)
					tmp73 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp74 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp75 := checkDerefVar(var_glojure_DOT_core_list)
					tmp76 := lang.Apply(tmp75, []any{sym_finally})
					tmp77 := checkDerefVar(var_glojure_DOT_core_list)
					tmp78 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp79 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp80 := checkDerefVar(var_glojure_DOT_core_list)
					tmp81 := lang.Apply(tmp80, []any{sym_glojure_DOT_core_SLASH_pop_DASH_thread_DASH_bindings})
					tmp82 := lang.Apply(tmp79, []any{tmp81})
					tmp83 := lang.Apply(tmp78, []any{tmp82})
					tmp84 := lang.Apply(tmp77, []any{tmp83})
					tmp85 := lang.Apply(tmp74, []any{tmp76, tmp84})
					tmp86 := lang.Apply(tmp73, []any{tmp85})
					tmp87 := lang.Apply(tmp72, []any{tmp86})
					tmp88 := lang.Apply(tmp69, []any{tmp71, v5, tmp87})
					tmp89 := lang.Apply(tmp68, []any{tmp88})
					tmp90 := lang.Apply(tmp67, []any{tmp89})
					tmp91 := lang.Apply(tmp38, []any{tmp40, tmp49, tmp66, tmp90})
					tmp92 := lang.Apply(tmp37, []any{tmp91})
					tmp32 = tmp92
				} // end let
				return tmp32
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_binding = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_binding.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound-fn*
	{
		tmp0 := sym_bound_DASH_fn_STAR_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Returns a function, which will install the same bindings in effect as in\n  the thread at the time bound-fn* was called and then call f with any given\n  arguments. This may be used to define a helper function which runs on a\n  different thread, but needs the same bindings in place.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(1992), kw_end_DASH_line, int(1992))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "bindings"
				tmp4 := checkDerefVar(var_glojure_DOT_core_get_DASH_thread_DASH_bindings)
				tmp5 := lang.Apply(tmp4, nil)
				var v6 any = tmp5
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						checkArityGTE(args, 0)
						var v8 any = lang.NewList(args[0:]...)
						_ = v8
						tmp9 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp10 := checkDerefVar(var_glojure_DOT_core_with_DASH_bindings_STAR_)
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6, v2, v8})
						return tmp11
					}
				})
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2001), kw_column, int(5), kw_end_DASH_line, int(2002), kw_end_DASH_column, int(45))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp3 = tmp9
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_bound_DASH_fn_STAR_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_bound_DASH_fn_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// case-map
	{
		tmp0 := sym_case_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_case_DASH_f, sym_test_DASH_f, sym_tests, sym_thens)), kw_doc, "Transforms a sequence of test constants and a corresponding sequence of then\n  expressions into a sorted map to be consumed by case*. The form of the map\n  entries are {(case-f test) [(test-f test) then]}.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(6614), kw_end_DASH_line, int(6614), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			tmp6 := checkDerefVar(var_glojure_DOT_core_into1)
			tmp7 := checkDerefVar(var_glojure_DOT_core_sorted_DASH_map)
			tmp8 := lang.Apply(tmp7, nil)
			tmp9 := checkDerefVar(var_glojure_DOT_core_zipmap)
			tmp10 := checkDerefVar(var_glojure_DOT_core_map)
			tmp11 := lang.Apply(tmp10, []any{v2, v4})
			tmp12 := checkDerefVar(var_glojure_DOT_core_map)
			tmp13 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp14 := checkDerefVar(var_glojure_DOT_core_map)
			tmp15 := lang.Apply(tmp14, []any{v3, v4})
			tmp16 := lang.Apply(tmp12, []any{tmp13, tmp15, v5})
			tmp17 := lang.Apply(tmp9, []any{tmp11, tmp16})
			tmp18 := lang.Apply(tmp6, []any{tmp8, tmp17})
			return tmp18
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_case_DASH_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_case_DASH_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// check-valid-options
	{
		tmp0 := sym_check_DASH_valid_DASH_options.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_options, sym__AMP_, sym_valid_DASH_keys)), kw_doc, "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(35), kw_column, int(7), kw_line, int(1709), kw_end_DASH_line, int(1709), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_disj)
				tmp8 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp9 := checkDerefVar(var_glojure_DOT_core_hash_DASH_set)
				tmp10 := checkDerefVar(var_glojure_DOT_core_keys)
				tmp11 := lang.Apply(tmp10, []any{v2})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11})
				tmp13 := lang.Apply(tmp6, []any{tmp7, tmp12, v3})
				tmp14 := lang.Apply(tmp5, []any{tmp13})
				if lang.IsTruthy(tmp14) {
					tmp15 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp16 := checkDerefVar(var_glojure_DOT_core_str)
					tmp17 := checkDerefVar(var_glojure_DOT_core_first)
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp20 lang.FnFunc
					tmp20 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v21 := args[0]
						_ = v21
						tmp22 := checkDerefVar(var_glojure_DOT_core_str)
						tmp23 := lang.Apply(tmp22, []any{", ", v21})
						return tmp23
					})
					tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1718), kw_column, int(16), kw_end_DASH_line, int(1718), kw_end_DASH_column, int(28))
					tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp23 := checkDerefVar(var_glojure_DOT_core_rest)
					tmp24 := lang.Apply(tmp23, []any{v3})
					tmp25 := lang.Apply(tmp19, []any{tmp22, tmp24})
					tmp26 := lang.Apply(tmp15, []any{tmp16, "Only these options are valid: ", tmp18, tmp25})
					tmp27 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp26})
					panic(tmp27)
				} else {
				}
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_check_DASH_valid_DASH_options = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_check_DASH_valid_DASH_options.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// clear-agent-errors
	{
		tmp0 := sym_clear_DASH_agent_DASH_errors.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_doc, "DEPRECATED: Use 'restart-agent' instead.\n  Clears any exceptions thrown during asynchronous actions of the\n  agent, allowing subsequent actions to occur.", kw_file, "glojure/core.glj", kw_deprecated, "1.2", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(2244), kw_end_DASH_line, int(2244))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_restart_DASH_agent)
			tmp4, ok := lang.FieldOrMethod(v2, "Deref")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "Deref")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			tmp6 := lang.Apply(tmp3, []any{v2, tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_clear_DASH_agent_DASH_errors = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_clear_DASH_agent_DASH_errors.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// declare
	{
		tmp0 := sym_declare.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_names)), kw_doc, "defs the supplied var names with no bindings, useful for making forward declarations.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(2768), kw_end_DASH_line, int(2768))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_do})
				tmp9 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v11 := args[0]
					_ = v11
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_vary_DASH_meta)
					tmp14 := checkDerefVar(var_glojure_DOT_core_assoc)
					tmp15 := lang.Apply(tmp13, []any{v11, tmp14, kw_declared, true})
					tmp16 := lang.Apply(tmp12, []any{sym_def, tmp15})
					return tmp16
				})
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2771), kw_column, int(25), kw_end_DASH_line, int(2771), kw_end_DASH_column, int(71))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := lang.Apply(tmp9, []any{tmp12, v4})
				tmp14 := lang.Apply(tmp6, []any{tmp8, tmp13})
				tmp15 := lang.Apply(tmp5, []any{tmp14})
				return tmp15
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_declare = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_declare.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dedupe
	{
		tmp0 := sym_dedupe.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_coll)), kw_doc, "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(7681), kw_end_DASH_line, int(7681))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp2 lang.FnFunc
				tmp2 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v3 := args[0]
					_ = v3
					var tmp4 any
					{ // let
						// let binding "pv"
						tmp5 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp6 := lang.Apply(tmp5, []any{kw_glojure_DOT_core_SLASH_none})
						var v7 any = tmp6
						_ = v7
						var tmp8 lang.FnFunc
						tmp8 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp9 := lang.Apply(v3, nil)
								return tmp9
							case 1:
								v9 := args[0]
								_ = v9
								tmp10 := lang.Apply(v3, []any{v9})
								return tmp10
							case 2:
								v9 := args[0]
								_ = v9
								v10 := args[1]
								_ = v10
								var tmp11 any
								{ // let
									// let binding "prior"
									tmp12 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp13 := lang.Apply(tmp12, []any{v7})
									var v14 any = tmp13
									_ = v14
									tmp15 := checkDerefVar(var_glojure_DOT_core_vreset_BANG_)
									tmp16 := lang.Apply(tmp15, []any{v7, v10})
									_ = tmp16
									var tmp17 any
									tmp18 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp19 := lang.Apply(tmp18, []any{v14, v10})
									if lang.IsTruthy(tmp19) {
										tmp17 = v9
									} else {
										tmp20 := lang.Apply(v3, []any{v9, v10})
										tmp17 = tmp20
									}
									tmp11 = tmp17
								} // end let
								return tmp11
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7688), kw_column, int(8), kw_end_DASH_line, int(7696), kw_end_DASH_column, int(37))
						tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp4 = tmp10
					} // end let
					return tmp4
				})
				tmp3 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7686), kw_column, int(4), kw_end_DASH_line, int(7696), kw_end_DASH_column, int(39))
				tmp4, err := lang.WithMeta(tmp2, tmp3.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_sequence)
				tmp4 := checkDerefVar(var_glojure_DOT_core_dedupe)
				tmp5 := lang.Apply(tmp4, nil)
				tmp6 := lang.Apply(tmp3, []any{tmp5, v2})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_dedupe = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_dedupe.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmulti
	{
		tmp0 := sym_defmulti.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_docstring_QMARK_, sym_attr_DASH_map_QMARK_, sym_dispatch_DASH_fn, sym__AMP_, sym_options)), kw_doc, "Creates a new multimethod with the associated dispatch function.\n  The docstring and attr-map are optional.\n\n  Options are key-value pairs and may be one of:\n\n  :default\n\n  The default dispatch value, defaults to :default\n\n  :hierarchy\n\n  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)\n\n  Hierarchies are type-like relationships that do not depend upon type\n  inheritance. By default Clojure's multimethods dispatch off of a\n  global hierarchy map.  However, a hierarchy relationship can be\n  created with the derive function used to augment the root ancestor\n  created with make-hierarchy.\n\n  Multimethods expect the value of the hierarchy option to be supplied as\n  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'\n  or the var special form).", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(1723), kw_end_DASH_line, int(1723))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "docstring"
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
					tmp9 := checkDerefVar(var_glojure_DOT_core_first)
					tmp10 := lang.Apply(tmp9, []any{v5})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_first)
						tmp13 := lang.Apply(tmp12, []any{v5})
						tmp7 = tmp13
					} else {
					}
					var v14 any = tmp7
					_ = v14
					// let binding "options"
					var tmp15 any
					tmp16 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
					tmp17 := checkDerefVar(var_glojure_DOT_core_first)
					tmp18 := lang.Apply(tmp17, []any{v5})
					tmp19 := lang.Apply(tmp16, []any{tmp18})
					if lang.IsTruthy(tmp19) {
						tmp20 := checkDerefVar(var_glojure_DOT_core_next)
						tmp21 := lang.Apply(tmp20, []any{v5})
						tmp15 = tmp21
					} else {
						tmp15 = v5
					}
					var v22 any = tmp15
					_ = v22
					// let binding "m"
					var tmp23 any
					tmp24 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v22})
					tmp27 := lang.Apply(tmp24, []any{tmp26})
					if lang.IsTruthy(tmp27) {
						tmp28 := checkDerefVar(var_glojure_DOT_core_first)
						tmp29 := lang.Apply(tmp28, []any{v22})
						tmp23 = tmp29
					} else {
						tmp30 := lang.NewMap()
						tmp31 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1757), kw_column, int(23), kw_end_DASH_line, int(1757), kw_end_DASH_column, int(24))
						tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp23 = tmp32
					}
					var v33 any = tmp23
					_ = v33
					// let binding "options"
					var tmp34 any
					tmp35 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
					tmp36 := checkDerefVar(var_glojure_DOT_core_first)
					tmp37 := lang.Apply(tmp36, []any{v22})
					tmp38 := lang.Apply(tmp35, []any{tmp37})
					if lang.IsTruthy(tmp38) {
						tmp39 := checkDerefVar(var_glojure_DOT_core_next)
						tmp40 := lang.Apply(tmp39, []any{v22})
						tmp34 = tmp40
					} else {
						tmp34 = v22
					}
					var v41 any = tmp34
					_ = v41
					// let binding "dispatch-fn"
					tmp42 := checkDerefVar(var_glojure_DOT_core_first)
					tmp43 := lang.Apply(tmp42, []any{v41})
					var v44 any = tmp43
					_ = v44
					// let binding "options"
					tmp45 := checkDerefVar(var_glojure_DOT_core_next)
					tmp46 := lang.Apply(tmp45, []any{v41})
					var v47 any = tmp46
					_ = v47
					// let binding "m"
					var tmp48 any
					if lang.IsTruthy(v14) {
						tmp49 := checkDerefVar(var_glojure_DOT_core_assoc)
						tmp50 := lang.Apply(tmp49, []any{v33, kw_doc, v14})
						tmp48 = tmp50
					} else {
						tmp48 = v33
					}
					var v51 any = tmp48
					_ = v51
					// let binding "m"
					var tmp52 any
					tmp53 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp54 := lang.Apply(tmp53, []any{v4})
					if lang.IsTruthy(tmp54) {
						tmp55 := checkDerefVar(var_glojure_DOT_core_conj)
						tmp56 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp57 := lang.Apply(tmp56, []any{v4})
						tmp58 := lang.Apply(tmp55, []any{tmp57, v51})
						tmp52 = tmp58
					} else {
						tmp52 = v51
					}
					var v59 any = tmp52
					_ = v59
					// let binding "mm-name"
					tmp60 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp61 := lang.Apply(tmp60, []any{v4, v59})
					var v62 any = tmp61
					_ = v62
					var tmp63 any
					tmp64 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp65 := checkDerefVar(var_glojure_DOT_core_count)
					tmp66 := lang.Apply(tmp65, []any{v47})
					tmp67 := lang.Apply(tmp64, []any{tmp66, int64(1)})
					if lang.IsTruthy(tmp67) {
						tmp68 := lang.Apply(lang.NewError, []any{"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)"})
						panic(tmp68)
					} else {
					}
					_ = tmp63
					var tmp69 any
					{ // let
						// let binding "options"
						tmp70 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp71 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp72 := lang.Apply(tmp70, []any{tmp71, v47})
						var v73 any = tmp72
						_ = v73
						// let binding "default"
						tmp74 := checkDerefVar(var_glojure_DOT_core_get)
						tmp75 := lang.Apply(tmp74, []any{v73, kw_default, kw_default})
						var v76 any = tmp75
						_ = v76
						// let binding "hierarchy"
						tmp77 := checkDerefVar(var_glojure_DOT_core_get)
						tmp78 := lang.InternVarName(sym_glojure_DOT_core, sym_global_DASH_hierarchy)
						tmp79 := lang.Apply(tmp77, []any{v73, kw_hierarchy, tmp78})
						var v80 any = tmp79
						_ = v80
						tmp81 := checkDerefVar(var_glojure_DOT_core_check_DASH_valid_DASH_options)
						tmp82 := lang.Apply(tmp81, []any{v73, kw_default, kw_hierarchy})
						_ = tmp82
						tmp83 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp84 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp85 := checkDerefVar(var_glojure_DOT_core_list)
						tmp86 := lang.Apply(tmp85, []any{sym_glojure_DOT_core_SLASH_let})
						tmp87 := checkDerefVar(var_glojure_DOT_core_list)
						tmp88 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp89 := checkDerefVar(var_glojure_DOT_core_vector)
						tmp90 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp91 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp92 := checkDerefVar(var_glojure_DOT_core_list)
						tmp93 := lang.Apply(tmp92, []any{sym_v__0__auto__})
						tmp94 := checkDerefVar(var_glojure_DOT_core_list)
						tmp95 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp96 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp97 := checkDerefVar(var_glojure_DOT_core_list)
						tmp98 := lang.Apply(tmp97, []any{sym_def})
						tmp99 := checkDerefVar(var_glojure_DOT_core_list)
						tmp100 := lang.Apply(tmp99, []any{v62})
						tmp101 := lang.Apply(tmp96, []any{tmp98, tmp100})
						tmp102 := lang.Apply(tmp95, []any{tmp101})
						tmp103 := lang.Apply(tmp94, []any{tmp102})
						tmp104 := lang.Apply(tmp91, []any{tmp93, tmp103})
						tmp105 := lang.Apply(tmp90, []any{tmp104})
						tmp106 := lang.Apply(tmp88, []any{tmp89, tmp105})
						tmp107 := lang.Apply(tmp87, []any{tmp106})
						tmp108 := checkDerefVar(var_glojure_DOT_core_list)
						tmp109 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp110 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp111 := checkDerefVar(var_glojure_DOT_core_list)
						tmp112 := lang.Apply(tmp111, []any{sym_glojure_DOT_core_SLASH_when_DASH_not})
						tmp113 := checkDerefVar(var_glojure_DOT_core_list)
						tmp114 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp115 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp116 := checkDerefVar(var_glojure_DOT_core_list)
						tmp117 := lang.Apply(tmp116, []any{sym_glojure_DOT_core_SLASH_and})
						tmp118 := checkDerefVar(var_glojure_DOT_core_list)
						tmp119 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp120 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp121 := checkDerefVar(var_glojure_DOT_core_list)
						tmp122 := lang.Apply(tmp121, []any{sym__DOT_HasRoot})
						tmp123 := checkDerefVar(var_glojure_DOT_core_list)
						tmp124 := lang.Apply(tmp123, []any{sym_v__0__auto__})
						tmp125 := lang.Apply(tmp120, []any{tmp122, tmp124})
						tmp126 := lang.Apply(tmp119, []any{tmp125})
						tmp127 := lang.Apply(tmp118, []any{tmp126})
						tmp128 := checkDerefVar(var_glojure_DOT_core_list)
						tmp129 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp130 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp131 := checkDerefVar(var_glojure_DOT_core_list)
						tmp132 := lang.Apply(tmp131, []any{sym_glojure_DOT_core_SLASH_instance_QMARK_})
						tmp133 := checkDerefVar(var_glojure_DOT_core_list)
						tmp134 := lang.Apply(tmp133, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT__STAR_MultiFn})
						tmp135 := checkDerefVar(var_glojure_DOT_core_list)
						tmp136 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp137 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp138 := checkDerefVar(var_glojure_DOT_core_list)
						tmp139 := lang.Apply(tmp138, []any{sym_glojure_DOT_core_SLASH_deref})
						tmp140 := checkDerefVar(var_glojure_DOT_core_list)
						tmp141 := lang.Apply(tmp140, []any{sym_v__0__auto__})
						tmp142 := lang.Apply(tmp137, []any{tmp139, tmp141})
						tmp143 := lang.Apply(tmp136, []any{tmp142})
						tmp144 := lang.Apply(tmp135, []any{tmp143})
						tmp145 := lang.Apply(tmp130, []any{tmp132, tmp134, tmp144})
						tmp146 := lang.Apply(tmp129, []any{tmp145})
						tmp147 := lang.Apply(tmp128, []any{tmp146})
						tmp148 := lang.Apply(tmp115, []any{tmp117, tmp127, tmp147})
						tmp149 := lang.Apply(tmp114, []any{tmp148})
						tmp150 := lang.Apply(tmp113, []any{tmp149})
						tmp151 := checkDerefVar(var_glojure_DOT_core_list)
						tmp152 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp153 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp154 := checkDerefVar(var_glojure_DOT_core_list)
						tmp155 := lang.Apply(tmp154, []any{sym_def})
						tmp156 := checkDerefVar(var_glojure_DOT_core_list)
						tmp157 := lang.Apply(tmp156, []any{v62})
						tmp158 := checkDerefVar(var_glojure_DOT_core_list)
						tmp159 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp160 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp161 := checkDerefVar(var_glojure_DOT_core_list)
						tmp162 := lang.Apply(tmp161, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewMultiFn})
						tmp163 := checkDerefVar(var_glojure_DOT_core_list)
						tmp164 := checkDerefVar(var_glojure_DOT_core_name)
						tmp165 := lang.Apply(tmp164, []any{v62})
						tmp166 := lang.Apply(tmp163, []any{tmp165})
						tmp167 := checkDerefVar(var_glojure_DOT_core_list)
						tmp168 := lang.Apply(tmp167, []any{v44})
						tmp169 := checkDerefVar(var_glojure_DOT_core_list)
						tmp170 := lang.Apply(tmp169, []any{v76})
						tmp171 := checkDerefVar(var_glojure_DOT_core_list)
						tmp172 := lang.Apply(tmp171, []any{v80})
						tmp173 := lang.Apply(tmp160, []any{tmp162, tmp166, tmp168, tmp170, tmp172})
						tmp174 := lang.Apply(tmp159, []any{tmp173})
						tmp175 := lang.Apply(tmp158, []any{tmp174})
						tmp176 := lang.Apply(tmp153, []any{tmp155, tmp157, tmp175})
						tmp177 := lang.Apply(tmp152, []any{tmp176})
						tmp178 := lang.Apply(tmp151, []any{tmp177})
						tmp179 := lang.Apply(tmp110, []any{tmp112, tmp150, tmp178})
						tmp180 := lang.Apply(tmp109, []any{tmp179})
						tmp181 := lang.Apply(tmp108, []any{tmp180})
						tmp182 := lang.Apply(tmp84, []any{tmp86, tmp107, tmp181})
						tmp183 := lang.Apply(tmp83, []any{tmp182})
						tmp69 = tmp183
					} // end let
					tmp6 = tmp69
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_defmulti = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_defmulti.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defprotocol
	{
		tmp0 := sym_defprotocol.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_opts_PLUS_sigs)), kw_doc, "A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n   ;options\n   :extend-via-metadata true\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in \n  Java parlance). defprotocol is dynamic, has no special compile-time \n  effect, and defines no new types or classes. Implementations of \n  the protocol methods can be provided using extend.\n\n  When :extend-via-metadata is true, values can extend protocols by\n  adding metadata where keys are fully-qualified protocol function\n  symbols and values are function implementations. Protocol\n  implementations are checked first for direct definitions (defrecord,\n  deftype, reify), then metadata definitions, then external\n  extensions (extend, extend-type, extend-protocol)\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P \n    (foo [this]) \n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c] \n   P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n  \n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo \n    (let [x 42]\n      (reify P \n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", kw_file, "glojure/core_deftype.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(11), kw_line, int(28), kw_end_DASH_line, int(28))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "doc"
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
					tmp9 := checkDerefVar(var_glojure_DOT_core_first)
					tmp10 := lang.Apply(tmp9, []any{v5})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_first)
						tmp13 := lang.Apply(tmp12, []any{v5})
						tmp7 = tmp13
					} else {
					}
					var v14 any = tmp7
					_ = v14
					// let binding "opts+sigs"
					var tmp15 any
					if lang.IsTruthy(v14) {
						tmp16 := checkDerefVar(var_glojure_DOT_core_rest)
						tmp17 := lang.Apply(tmp16, []any{v5})
						tmp15 = tmp17
					} else {
						tmp15 = v5
					}
					var v18 any = tmp15
					_ = v18
					// let binding "opts"
					tmp19 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
					var tmp20 lang.FnFunc
					tmp20 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v21 := args[0]
						_ = v21
						tmp22 := checkDerefVar(var_glojure_DOT_core_not)
						tmp23 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp24 := lang.Apply(tmp23, []any{v21})
						tmp25 := lang.Apply(tmp22, []any{tmp24})
						return tmp25
					})
					tmp21 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(92), kw_column, int(26), kw_end_DASH_line, int(92), kw_end_DASH_column, int(40))
					tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp23 := lang.Apply(tmp19, []any{tmp22, v18})
					var v24 any = tmp23
					_ = v24
					// let binding "sigs"
					tmp25 := checkDerefVar(var_glojure_DOT_core_drop_DASH_while)
					var tmp26 lang.FnFunc
					tmp26 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v27 := args[0]
						_ = v27
						tmp28 := checkDerefVar(var_glojure_DOT_core_not)
						tmp29 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp30 := lang.Apply(tmp29, []any{v27})
						tmp31 := lang.Apply(tmp28, []any{tmp30})
						return tmp31
					})
					tmp27 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(93), kw_column, int(26), kw_end_DASH_line, int(93), kw_end_DASH_column, int(40))
					tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp29 := lang.Apply(tmp25, []any{tmp28, v18})
					var v30 any = tmp29
					_ = v30
					// let binding "opts"
					var tmp31 any
					tmp32 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp33 := lang.Apply(tmp32, []any{v30, v24})
					if lang.IsTruthy(tmp33) {
					} else {
						tmp31 = v24
					}
					var v34 any = tmp31
					_ = v34
					tmp35 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp36 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp37 := checkDerefVar(var_glojure_DOT_core_list)
					tmp38 := lang.Apply(tmp37, []any{sym_do})
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp41 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					tmp43 := lang.Apply(tmp42, []any{sym_def})
					tmp44 := checkDerefVar(var_glojure_DOT_core_list)
					tmp45 := lang.Apply(tmp44, []any{v4})
					tmp46 := checkDerefVar(var_glojure_DOT_core_list)
					tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp49 := checkDerefVar(var_glojure_DOT_core_list)
					tmp50 := lang.Apply(tmp49, []any{sym_glojure_DOT_core_SLASH_atom})
					tmp51 := checkDerefVar(var_glojure_DOT_core_list)
					tmp52 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp53 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp54 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp55 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp56 := checkDerefVar(var_glojure_DOT_core_list)
					tmp57 := lang.Apply(tmp56, []any{kw_on_DASH_interface})
					tmp58 := checkDerefVar(var_glojure_DOT_core_list)
					tmp59 := lang.Apply(tmp58, []any{true})
					tmp60 := checkDerefVar(var_glojure_DOT_core_list)
					tmp61 := lang.Apply(tmp60, []any{kw_sigs})
					tmp62 := checkDerefVar(var_glojure_DOT_core_list)
					tmp63 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp64 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp65 := checkDerefVar(var_glojure_DOT_core_list)
					tmp66 := lang.Apply(tmp65, []any{sym_quote})
					tmp67 := checkDerefVar(var_glojure_DOT_core_list)
					tmp68 := lang.Apply(tmp67, []any{v30})
					tmp69 := lang.Apply(tmp64, []any{tmp66, tmp68})
					tmp70 := lang.Apply(tmp63, []any{tmp69})
					tmp71 := lang.Apply(tmp62, []any{tmp70})
					tmp72 := checkDerefVar(var_glojure_DOT_core_list)
					tmp73 := lang.Apply(tmp72, []any{kw_multis})
					tmp74 := checkDerefVar(var_glojure_DOT_core_list)
					tmp75 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp76 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp77 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp78 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp79 := lang.Apply(tmp78, nil)
					tmp80 := lang.Apply(tmp77, []any{tmp79})
					tmp81 := lang.Apply(tmp75, []any{tmp76, tmp80})
					tmp82 := lang.Apply(tmp74, []any{tmp81})
					tmp83 := lang.Apply(tmp55, []any{tmp57, tmp59, tmp61, tmp71, tmp73, tmp82})
					tmp84 := lang.Apply(tmp54, []any{tmp83})
					tmp85 := lang.Apply(tmp52, []any{tmp53, tmp84})
					tmp86 := lang.Apply(tmp51, []any{tmp85})
					tmp87 := lang.Apply(tmp48, []any{tmp50, tmp86})
					tmp88 := lang.Apply(tmp47, []any{tmp87})
					tmp89 := lang.Apply(tmp46, []any{tmp88})
					tmp90 := lang.Apply(tmp41, []any{tmp43, tmp45, tmp89})
					tmp91 := lang.Apply(tmp40, []any{tmp90})
					tmp92 := lang.Apply(tmp39, []any{tmp91})
					tmp93 := checkDerefVar(var_glojure_DOT_core_list)
					tmp94 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp95 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp96 := checkDerefVar(var_glojure_DOT_core_list)
					tmp97 := lang.Apply(tmp96, []any{sym_glojure_DOT_core_SLASH_swap_BANG_})
					tmp98 := checkDerefVar(var_glojure_DOT_core_list)
					tmp99 := lang.Apply(tmp98, []any{sym_glojure_DOT_core_SLASH__DASH_protocols})
					tmp100 := checkDerefVar(var_glojure_DOT_core_list)
					tmp101 := lang.Apply(tmp100, []any{sym_glojure_DOT_core_SLASH_assoc})
					tmp102 := checkDerefVar(var_glojure_DOT_core_list)
					tmp103 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp104 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp105 := checkDerefVar(var_glojure_DOT_core_list)
					tmp106 := lang.Apply(tmp105, []any{sym_quote})
					tmp107 := checkDerefVar(var_glojure_DOT_core_list)
					tmp108 := lang.Apply(tmp107, []any{v4})
					tmp109 := lang.Apply(tmp104, []any{tmp106, tmp108})
					tmp110 := lang.Apply(tmp103, []any{tmp109})
					tmp111 := lang.Apply(tmp102, []any{tmp110})
					tmp112 := checkDerefVar(var_glojure_DOT_core_list)
					tmp113 := lang.Apply(tmp112, []any{v4})
					tmp114 := lang.Apply(tmp95, []any{tmp97, tmp99, tmp101, tmp111, tmp113})
					tmp115 := lang.Apply(tmp94, []any{tmp114})
					tmp116 := lang.Apply(tmp93, []any{tmp115})
					tmp117 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp118 lang.FnFunc
					tmp118 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v119 := args[0]
						_ = v119
						tmp120 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp121 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp122 := checkDerefVar(var_glojure_DOT_core_list)
						tmp123 := lang.Apply(tmp122, []any{sym_do})
						tmp124 := checkDerefVar(var_glojure_DOT_core_list)
						tmp125 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp126 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp127 := checkDerefVar(var_glojure_DOT_core_list)
						tmp128 := lang.Apply(tmp127, []any{sym_glojure_DOT_core_SLASH_defmulti})
						tmp129 := checkDerefVar(var_glojure_DOT_core_list)
						tmp130 := checkDerefVar(var_glojure_DOT_core_first)
						tmp131 := lang.Apply(tmp130, []any{v119})
						tmp132 := lang.Apply(tmp129, []any{tmp131})
						tmp133 := checkDerefVar(var_glojure_DOT_core_list)
						tmp134 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp135 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp136 := checkDerefVar(var_glojure_DOT_core_list)
						tmp137 := lang.Apply(tmp136, []any{sym_glojure_DOT_core_SLASH_fn})
						tmp138 := checkDerefVar(var_glojure_DOT_core_list)
						tmp139 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp140 := checkDerefVar(var_glojure_DOT_core_vector)
						tmp141 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp142 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp143 := checkDerefVar(var_glojure_DOT_core_list)
						tmp144 := lang.Apply(tmp143, []any{sym_this})
						tmp145 := checkDerefVar(var_glojure_DOT_core_list)
						tmp146 := lang.Apply(tmp145, []any{sym__AMP_})
						tmp147 := checkDerefVar(var_glojure_DOT_core_list)
						tmp148 := lang.Apply(tmp147, []any{sym_args})
						tmp149 := lang.Apply(tmp142, []any{tmp144, tmp146, tmp148})
						tmp150 := lang.Apply(tmp141, []any{tmp149})
						tmp151 := lang.Apply(tmp139, []any{tmp140, tmp150})
						tmp152 := lang.Apply(tmp138, []any{tmp151})
						tmp153 := checkDerefVar(var_glojure_DOT_core_list)
						tmp154 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp155 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp156 := checkDerefVar(var_glojure_DOT_core_list)
						tmp157 := lang.Apply(tmp156, []any{sym_glojure_DOT_core_SLASH_class})
						tmp158 := checkDerefVar(var_glojure_DOT_core_list)
						tmp159 := lang.Apply(tmp158, []any{sym_this})
						tmp160 := lang.Apply(tmp155, []any{tmp157, tmp159})
						tmp161 := lang.Apply(tmp154, []any{tmp160})
						tmp162 := lang.Apply(tmp153, []any{tmp161})
						tmp163 := lang.Apply(tmp135, []any{tmp137, tmp152, tmp162})
						tmp164 := lang.Apply(tmp134, []any{tmp163})
						tmp165 := lang.Apply(tmp133, []any{tmp164})
						tmp166 := lang.Apply(tmp126, []any{tmp128, tmp132, tmp165})
						tmp167 := lang.Apply(tmp125, []any{tmp166})
						tmp168 := lang.Apply(tmp124, []any{tmp167})
						tmp169 := checkDerefVar(var_glojure_DOT_core_list)
						tmp170 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp171 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp172 := checkDerefVar(var_glojure_DOT_core_list)
						tmp173 := lang.Apply(tmp172, []any{sym_glojure_DOT_core_SLASH_swap_BANG_})
						tmp174 := checkDerefVar(var_glojure_DOT_core_list)
						tmp175 := lang.Apply(tmp174, []any{v4})
						tmp176 := checkDerefVar(var_glojure_DOT_core_list)
						tmp177 := lang.Apply(tmp176, []any{sym_glojure_DOT_core_SLASH_assoc_DASH_in})
						tmp178 := checkDerefVar(var_glojure_DOT_core_list)
						tmp179 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp180 := checkDerefVar(var_glojure_DOT_core_vector)
						tmp181 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp182 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp183 := checkDerefVar(var_glojure_DOT_core_list)
						tmp184 := lang.Apply(tmp183, []any{kw_multis})
						tmp185 := checkDerefVar(var_glojure_DOT_core_list)
						tmp186 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp187 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp188 := checkDerefVar(var_glojure_DOT_core_list)
						tmp189 := lang.Apply(tmp188, []any{sym_glojure_DOT_core_SLASH_keyword})
						tmp190 := checkDerefVar(var_glojure_DOT_core_list)
						tmp191 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp192 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp193 := checkDerefVar(var_glojure_DOT_core_list)
						tmp194 := lang.Apply(tmp193, []any{sym_quote})
						tmp195 := checkDerefVar(var_glojure_DOT_core_list)
						tmp196 := checkDerefVar(var_glojure_DOT_core_first)
						tmp197 := lang.Apply(tmp196, []any{v119})
						tmp198 := lang.Apply(tmp195, []any{tmp197})
						tmp199 := lang.Apply(tmp192, []any{tmp194, tmp198})
						tmp200 := lang.Apply(tmp191, []any{tmp199})
						tmp201 := lang.Apply(tmp190, []any{tmp200})
						tmp202 := lang.Apply(tmp187, []any{tmp189, tmp201})
						tmp203 := lang.Apply(tmp186, []any{tmp202})
						tmp204 := lang.Apply(tmp185, []any{tmp203})
						tmp205 := lang.Apply(tmp182, []any{tmp184, tmp204})
						tmp206 := lang.Apply(tmp181, []any{tmp205})
						tmp207 := lang.Apply(tmp179, []any{tmp180, tmp206})
						tmp208 := lang.Apply(tmp178, []any{tmp207})
						tmp209 := checkDerefVar(var_glojure_DOT_core_list)
						tmp210 := checkDerefVar(var_glojure_DOT_core_first)
						tmp211 := lang.Apply(tmp210, []any{v119})
						tmp212 := lang.Apply(tmp209, []any{tmp211})
						tmp213 := lang.Apply(tmp171, []any{tmp173, tmp175, tmp177, tmp208, tmp212})
						tmp214 := lang.Apply(tmp170, []any{tmp213})
						tmp215 := lang.Apply(tmp169, []any{tmp214})
						tmp216 := lang.Apply(tmp121, []any{tmp123, tmp168, tmp215})
						tmp217 := lang.Apply(tmp120, []any{tmp216})
						return tmp217
					})
					tmp119 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(102), kw_column, int(13), kw_end_DASH_line, int(104), kw_end_DASH_column, int(90))
					tmp120, err := lang.WithMeta(tmp118, tmp119.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp121 := lang.Apply(tmp117, []any{tmp120, v30})
					tmp122 := checkDerefVar(var_glojure_DOT_core_list)
					tmp123 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp124 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp125 := checkDerefVar(var_glojure_DOT_core_list)
					tmp126 := lang.Apply(tmp125, []any{sym_var})
					tmp127 := checkDerefVar(var_glojure_DOT_core_list)
					tmp128 := lang.Apply(tmp127, []any{v4})
					tmp129 := lang.Apply(tmp124, []any{tmp126, tmp128})
					tmp130 := lang.Apply(tmp123, []any{tmp129})
					tmp131 := lang.Apply(tmp122, []any{tmp130})
					tmp132 := lang.Apply(tmp36, []any{tmp38, tmp92, tmp116, tmp121, tmp131})
					tmp133 := lang.Apply(tmp35, []any{tmp132})
					tmp6 = tmp133
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_defprotocol = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_defprotocol.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// distinct?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_distinct_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_doc, "Returns true if no two of the arguments are =", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(5664), kw_end_DASH_line, int(5664))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return true
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_not)
				tmp6 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp7 := lang.Apply(tmp6, []any{v3, v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			default:
				checkArityGTE(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					{ // let
						// let binding "s"
						tmp10 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{v3, v4}))
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5673), kw_column, int(15), kw_end_DASH_line, int(5673), kw_end_DASH_column, int(20))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v13 any = tmp12
						_ = v13
						// let binding "G__99"
						var v14 any = v5
						_ = v14
						// let binding "vec__100"
						var v15 any = v14
						_ = v15
						// let binding "seq__101"
						tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp17 := lang.Apply(tmp16, []any{v15})
						var v18 any = tmp17
						_ = v18
						// let binding "first__102"
						tmp19 := checkDerefVar(var_glojure_DOT_core_first)
						tmp20 := lang.Apply(tmp19, []any{v18})
						var v21 any = tmp20
						_ = v21
						// let binding "seq__101"
						tmp22 := checkDerefVar(var_glojure_DOT_core_next)
						tmp23 := lang.Apply(tmp22, []any{v18})
						var v24 any = tmp23
						_ = v24
						// let binding "x"
						var v25 any = v21
						_ = v25
						// let binding "etc"
						var v26 any = v24
						_ = v26
						// let binding "xs"
						var v27 any = v15
						_ = v27
						var tmp28 any
						{ // let
							// let binding "s"
							var v29 any = v13
							_ = v29
							// let binding "G__99"
							var v30 any = v14
							_ = v30
							for {
								var tmp31 any
								{ // let
									// let binding "s"
									var v32 any = v29
									_ = v32
									// let binding "vec__103"
									var v33 any = v30
									_ = v33
									// let binding "seq__104"
									tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp35 := lang.Apply(tmp34, []any{v33})
									var v36 any = tmp35
									_ = v36
									// let binding "first__105"
									tmp37 := checkDerefVar(var_glojure_DOT_core_first)
									tmp38 := lang.Apply(tmp37, []any{v36})
									var v39 any = tmp38
									_ = v39
									// let binding "seq__104"
									tmp40 := checkDerefVar(var_glojure_DOT_core_next)
									tmp41 := lang.Apply(tmp40, []any{v36})
									var v42 any = tmp41
									_ = v42
									// let binding "x"
									var v43 any = v39
									_ = v43
									// let binding "etc"
									var v44 any = v42
									_ = v44
									// let binding "xs"
									var v45 any = v33
									_ = v45
									var tmp46 any
									if lang.IsTruthy(v45) {
										var tmp47 any
										tmp48 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
										tmp49 := lang.Apply(tmp48, []any{v32, v43})
										if lang.IsTruthy(tmp49) {
											tmp47 = false
										} else {
											tmp51 := checkDerefVar(var_glojure_DOT_core_conj)
											tmp52 := lang.Apply(tmp51, []any{v32, v43})
											var tmp50 any = tmp52
											var tmp53 any = v44
											v29 = tmp50
											v30 = tmp53
											continue
										}
										tmp46 = tmp47
									} else {
										tmp46 = true
									}
									tmp31 = tmp46
								} // end let
								tmp28 = tmp31
								break
							}
						} // end let
						tmp9 = tmp28
					} // end let
					tmp6 = tmp9
				} else {
					tmp6 = false
				}
				return tmp6
			}
		})
		tmp3 := reflect.TypeOf(false)
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_distinct_QMARK_ = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_distinct_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doall
	{
		tmp0 := sym_doall.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll), lang.NewVector(sym_n, sym_coll)), kw_doc, "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3131), kw_end_DASH_line, int(3131))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_dorun)
				tmp4 := lang.Apply(tmp3, []any{v2})
				_ = tmp4
				return v2
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_dorun)
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				_ = tmp5
				return v3
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_doall = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_doall.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doseq
	{
		tmp0 := sym_doseq.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_seq_DASH_exprs, sym__AMP_, sym_body)), kw_doc, "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(3209), kw_end_DASH_line, int(3209))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_str)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp12 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp14 := lang.Apply(tmp13, []any{v2})
					tmp15 := lang.Apply(kw_line, []any{tmp14})
					tmp16 := lang.Apply(tmp9, []any{tmp11, " requires ", "a vector for its binding", " in ", tmp12, ":", tmp15})
					tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
					panic(tmp17)
				}
				_ = tmp6
				var tmp18 any
				tmp19 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp20 := checkDerefVar(var_glojure_DOT_core_count)
				tmp21 := lang.Apply(tmp20, []any{v4})
				tmp22 := lang.Apply(tmp19, []any{tmp21})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "an even number of forms in binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp18
				var tmp32 any
				{ // let
					// let binding "step"
					var tmp33 lang.FnFunc
					{ // function step
						var v34 lang.FnFunc
						tmp33 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v35 := args[0]
							_ = v35
							v36 := args[1]
							_ = v36
							var tmp37 any
							tmp38 := checkDerefVar(var_glojure_DOT_core_not)
							tmp39 := lang.Apply(tmp38, []any{v36})
							if lang.IsTruthy(tmp39) {
								tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp41 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp42 := checkDerefVar(var_glojure_DOT_core_list)
								tmp43 := lang.Apply(tmp42, []any{sym_do})
								tmp44 := lang.Apply(tmp41, []any{tmp43, v5})
								tmp45 := lang.Apply(tmp40, []any{tmp44})
								tmp46 := lang.NewVector(true, tmp45)
								tmp47 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3220), kw_column, int(18), kw_end_DASH_line, int(3220), kw_end_DASH_column, int(36))
								tmp48, err := lang.WithMeta(tmp46, tmp47.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp37 = tmp48
							} else {
								var tmp49 any
								{ // let
									// let binding "k"
									tmp50 := checkDerefVar(var_glojure_DOT_core_first)
									tmp51 := lang.Apply(tmp50, []any{v36})
									var v52 any = tmp51
									_ = v52
									// let binding "v"
									tmp53 := checkDerefVar(var_glojure_DOT_core_second)
									tmp54 := lang.Apply(tmp53, []any{v36})
									var v55 any = tmp54
									_ = v55
									var tmp56 any
									tmp57 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
									tmp58 := lang.Apply(tmp57, []any{v52})
									if lang.IsTruthy(tmp58) {
										var tmp59 any
										{ // let
											// let binding "steppair"
											tmp60 := checkDerefVar(var_glojure_DOT_core_nnext)
											tmp61 := lang.Apply(tmp60, []any{v36})
											tmp62 := lang.Apply(v34, []any{v35, tmp61})
											var v63 any = tmp62
											_ = v63
											// let binding "needrec"
											tmp64 := lang.Apply(v63, []any{int64(0)})
											var v65 any = tmp64
											_ = v65
											// let binding "subform"
											tmp66 := lang.Apply(v63, []any{int64(1)})
											var v67 any = tmp66
											_ = v67
											var tmp68 any
											tmp69 := checkDerefVar(var_glojure_DOT_core__EQ_)
											tmp70 := lang.Apply(tmp69, []any{v52, kw_let})
											if lang.IsTruthy(tmp70) {
												tmp71 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp72 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp73 := checkDerefVar(var_glojure_DOT_core_list)
												tmp74 := lang.Apply(tmp73, []any{sym_glojure_DOT_core_SLASH_let})
												tmp75 := checkDerefVar(var_glojure_DOT_core_list)
												tmp76 := lang.Apply(tmp75, []any{v55})
												tmp77 := checkDerefVar(var_glojure_DOT_core_list)
												tmp78 := lang.Apply(tmp77, []any{v67})
												tmp79 := lang.Apply(tmp72, []any{tmp74, tmp76, tmp78})
												tmp80 := lang.Apply(tmp71, []any{tmp79})
												tmp81 := lang.NewVector(v65, tmp80)
												tmp82 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3228), kw_column, int(37), kw_end_DASH_line, int(3228), kw_end_DASH_column, int(64))
												tmp83, err := lang.WithMeta(tmp81, tmp82.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp68 = tmp83
											} else {
												var tmp84 any
												tmp85 := checkDerefVar(var_glojure_DOT_core__EQ_)
												tmp86 := lang.Apply(tmp85, []any{v52, kw_while})
												if lang.IsTruthy(tmp86) {
													tmp87 := checkDerefVar(var_glojure_DOT_core_seq)
													tmp88 := checkDerefVar(var_glojure_DOT_core_concat)
													tmp89 := checkDerefVar(var_glojure_DOT_core_list)
													tmp90 := lang.Apply(tmp89, []any{sym_glojure_DOT_core_SLASH_when})
													tmp91 := checkDerefVar(var_glojure_DOT_core_list)
													tmp92 := lang.Apply(tmp91, []any{v55})
													tmp93 := checkDerefVar(var_glojure_DOT_core_list)
													tmp94 := lang.Apply(tmp93, []any{v67})
													var tmp95 any
													if lang.IsTruthy(v65) {
														tmp96 := lang.NewVector(v35)
														tmp97 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3231), kw_column, int(65), kw_end_DASH_line, int(3231), kw_end_DASH_column, int(73))
														tmp98, err := lang.WithMeta(tmp96, tmp97.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp95 = tmp98
													} else {
													}
													tmp99 := lang.Apply(tmp88, []any{tmp90, tmp92, tmp94, tmp95})
													tmp100 := lang.Apply(tmp87, []any{tmp99})
													tmp101 := lang.NewVector(false, tmp100)
													tmp102 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3229), kw_column, int(39), kw_end_DASH_line, int(3231), kw_end_DASH_column, int(76))
													tmp103, err := lang.WithMeta(tmp101, tmp102.(lang.IPersistentMap))
													if err != nil {
														panic(err)
													}
													tmp84 = tmp103
												} else {
													var tmp104 any
													tmp105 := checkDerefVar(var_glojure_DOT_core__EQ_)
													tmp106 := lang.Apply(tmp105, []any{v52, kw_when})
													if lang.IsTruthy(tmp106) {
														tmp107 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp108 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp109 := checkDerefVar(var_glojure_DOT_core_list)
														tmp110 := lang.Apply(tmp109, []any{sym_if})
														tmp111 := checkDerefVar(var_glojure_DOT_core_list)
														tmp112 := lang.Apply(tmp111, []any{v55})
														tmp113 := checkDerefVar(var_glojure_DOT_core_list)
														tmp114 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp115 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp116 := checkDerefVar(var_glojure_DOT_core_list)
														tmp117 := lang.Apply(tmp116, []any{sym_do})
														tmp118 := checkDerefVar(var_glojure_DOT_core_list)
														tmp119 := lang.Apply(tmp118, []any{v67})
														var tmp120 any
														if lang.IsTruthy(v65) {
															tmp121 := lang.NewVector(v35)
															tmp122 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3235), kw_column, int(66), kw_end_DASH_line, int(3235), kw_end_DASH_column, int(74))
															tmp123, err := lang.WithMeta(tmp121, tmp122.(lang.IPersistentMap))
															if err != nil {
																panic(err)
															}
															tmp120 = tmp123
														} else {
														}
														tmp124 := lang.Apply(tmp115, []any{tmp117, tmp119, tmp120})
														tmp125 := lang.Apply(tmp114, []any{tmp124})
														tmp126 := lang.Apply(tmp113, []any{tmp125})
														tmp127 := checkDerefVar(var_glojure_DOT_core_list)
														tmp128 := lang.Apply(tmp127, []any{v35})
														tmp129 := lang.Apply(tmp108, []any{tmp110, tmp112, tmp126, tmp128})
														tmp130 := lang.Apply(tmp107, []any{tmp129})
														tmp131 := lang.NewVector(false, tmp130)
														tmp132 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3232), kw_column, int(38), kw_end_DASH_line, int(3236), kw_end_DASH_column, int(57))
														tmp133, err := lang.WithMeta(tmp131, tmp132.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp104 = tmp133
													} else {
													}
													tmp84 = tmp104
												}
												tmp68 = tmp84
											}
											tmp59 = tmp68
										} // end let
										tmp56 = tmp59
									} else {
										var tmp60 any
										{ // let
											// let binding "seq-"
											tmp61 := checkDerefVar(var_glojure_DOT_core_gensym)
											tmp62 := lang.Apply(tmp61, []any{"seq_"})
											var v63 any = tmp62
											_ = v63
											// let binding "chunk-"
											tmp64 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
											tmp65 := checkDerefVar(var_glojure_DOT_core_gensym)
											tmp66 := lang.Apply(tmp65, []any{"chunk_"})
											tmp67 := lang.NewMap(kw_tag, sym_glojure_DOT_lang_DOT_IChunk)
											tmp68 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3239), kw_column, int(46), kw_end_DASH_line, int(3239), kw_end_DASH_column, int(72))
											tmp69, err := lang.WithMeta(tmp67, tmp68.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp70 := lang.Apply(tmp64, []any{tmp66, tmp69})
											var v71 any = tmp70
											_ = v71
											// let binding "count-"
											tmp72 := checkDerefVar(var_glojure_DOT_core_gensym)
											tmp73 := lang.Apply(tmp72, []any{"count_"})
											var v74 any = tmp73
											_ = v74
											// let binding "i-"
											tmp75 := checkDerefVar(var_glojure_DOT_core_gensym)
											tmp76 := lang.Apply(tmp75, []any{"i_"})
											var v77 any = tmp76
											_ = v77
											// let binding "recform"
											tmp78 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp79 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp80 := checkDerefVar(var_glojure_DOT_core_list)
											tmp81 := lang.Apply(tmp80, []any{sym_recur})
											tmp82 := checkDerefVar(var_glojure_DOT_core_list)
											tmp83 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp84 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp85 := checkDerefVar(var_glojure_DOT_core_list)
											tmp86 := lang.Apply(tmp85, []any{sym_glojure_DOT_core_SLASH_next})
											tmp87 := checkDerefVar(var_glojure_DOT_core_list)
											tmp88 := lang.Apply(tmp87, []any{v63})
											tmp89 := lang.Apply(tmp84, []any{tmp86, tmp88})
											tmp90 := lang.Apply(tmp83, []any{tmp89})
											tmp91 := lang.Apply(tmp82, []any{tmp90})
											tmp92 := checkDerefVar(var_glojure_DOT_core_list)
											tmp93 := lang.Apply(tmp92, []any{nil})
											tmp94 := checkDerefVar(var_glojure_DOT_core_list)
											tmp95 := lang.Apply(tmp94, []any{int64(0)})
											tmp96 := checkDerefVar(var_glojure_DOT_core_list)
											tmp97 := lang.Apply(tmp96, []any{int64(0)})
											tmp98 := lang.Apply(tmp79, []any{tmp81, tmp91, tmp93, tmp95, tmp97})
											tmp99 := lang.Apply(tmp78, []any{tmp98})
											var v100 any = tmp99
											_ = v100
											// let binding "steppair"
											tmp101 := checkDerefVar(var_glojure_DOT_core_nnext)
											tmp102 := lang.Apply(tmp101, []any{v36})
											tmp103 := lang.Apply(v34, []any{v100, tmp102})
											var v104 any = tmp103
											_ = v104
											// let binding "needrec"
											tmp105 := lang.Apply(v104, []any{int64(0)})
											var v106 any = tmp105
											_ = v106
											// let binding "subform"
											tmp107 := lang.Apply(v104, []any{int64(1)})
											var v108 any = tmp107
											_ = v108
											// let binding "recform-chunk"
											tmp109 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp110 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp111 := checkDerefVar(var_glojure_DOT_core_list)
											tmp112 := lang.Apply(tmp111, []any{sym_recur})
											tmp113 := checkDerefVar(var_glojure_DOT_core_list)
											tmp114 := lang.Apply(tmp113, []any{v63})
											tmp115 := checkDerefVar(var_glojure_DOT_core_list)
											tmp116 := lang.Apply(tmp115, []any{v71})
											tmp117 := checkDerefVar(var_glojure_DOT_core_list)
											tmp118 := lang.Apply(tmp117, []any{v74})
											tmp119 := checkDerefVar(var_glojure_DOT_core_list)
											tmp120 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp121 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp122 := checkDerefVar(var_glojure_DOT_core_list)
											tmp123 := lang.Apply(tmp122, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc})
											tmp124 := checkDerefVar(var_glojure_DOT_core_list)
											tmp125 := lang.Apply(tmp124, []any{v77})
											tmp126 := lang.Apply(tmp121, []any{tmp123, tmp125})
											tmp127 := lang.Apply(tmp120, []any{tmp126})
											tmp128 := lang.Apply(tmp119, []any{tmp127})
											tmp129 := lang.Apply(tmp110, []any{tmp112, tmp114, tmp116, tmp118, tmp128})
											tmp130 := lang.Apply(tmp109, []any{tmp129})
											var v131 any = tmp130
											_ = v131
											// let binding "steppair-chunk"
											tmp132 := checkDerefVar(var_glojure_DOT_core_nnext)
											tmp133 := lang.Apply(tmp132, []any{v36})
											tmp134 := lang.Apply(v34, []any{v131, tmp133})
											var v135 any = tmp134
											_ = v135
											// let binding "subform-chunk"
											tmp136 := lang.Apply(v135, []any{int64(1)})
											var v137 any = tmp136
											_ = v137
											tmp138 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp139 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp140 := checkDerefVar(var_glojure_DOT_core_list)
											tmp141 := lang.Apply(tmp140, []any{sym_glojure_DOT_core_SLASH_loop})
											tmp142 := checkDerefVar(var_glojure_DOT_core_list)
											tmp143 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp144 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp145 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp146 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp147 := checkDerefVar(var_glojure_DOT_core_list)
											tmp148 := lang.Apply(tmp147, []any{v63})
											tmp149 := checkDerefVar(var_glojure_DOT_core_list)
											tmp150 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp151 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp152 := checkDerefVar(var_glojure_DOT_core_list)
											tmp153 := lang.Apply(tmp152, []any{sym_glojure_DOT_core_SLASH_seq})
											tmp154 := checkDerefVar(var_glojure_DOT_core_list)
											tmp155 := lang.Apply(tmp154, []any{v55})
											tmp156 := lang.Apply(tmp151, []any{tmp153, tmp155})
											tmp157 := lang.Apply(tmp150, []any{tmp156})
											tmp158 := lang.Apply(tmp149, []any{tmp157})
											tmp159 := checkDerefVar(var_glojure_DOT_core_list)
											tmp160 := lang.Apply(tmp159, []any{v71})
											tmp161 := checkDerefVar(var_glojure_DOT_core_list)
											tmp162 := lang.Apply(tmp161, []any{nil})
											tmp163 := checkDerefVar(var_glojure_DOT_core_list)
											tmp164 := lang.Apply(tmp163, []any{v74})
											tmp165 := checkDerefVar(var_glojure_DOT_core_list)
											tmp166 := lang.Apply(tmp165, []any{int64(0)})
											tmp167 := checkDerefVar(var_glojure_DOT_core_list)
											tmp168 := lang.Apply(tmp167, []any{v77})
											tmp169 := checkDerefVar(var_glojure_DOT_core_list)
											tmp170 := lang.Apply(tmp169, []any{int64(0)})
											tmp171 := lang.Apply(tmp146, []any{tmp148, tmp158, tmp160, tmp162, tmp164, tmp166, tmp168, tmp170})
											tmp172 := lang.Apply(tmp145, []any{tmp171})
											tmp173 := lang.Apply(tmp143, []any{tmp144, tmp172})
											tmp174 := lang.Apply(tmp142, []any{tmp173})
											tmp175 := checkDerefVar(var_glojure_DOT_core_list)
											tmp176 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp177 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp178 := checkDerefVar(var_glojure_DOT_core_list)
											tmp179 := lang.Apply(tmp178, []any{sym_if})
											tmp180 := checkDerefVar(var_glojure_DOT_core_list)
											tmp181 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp182 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp183 := checkDerefVar(var_glojure_DOT_core_list)
											tmp184 := lang.Apply(tmp183, []any{sym_glojure_DOT_core_SLASH__LT_})
											tmp185 := checkDerefVar(var_glojure_DOT_core_list)
											tmp186 := lang.Apply(tmp185, []any{v77})
											tmp187 := checkDerefVar(var_glojure_DOT_core_list)
											tmp188 := lang.Apply(tmp187, []any{v74})
											tmp189 := lang.Apply(tmp182, []any{tmp184, tmp186, tmp188})
											tmp190 := lang.Apply(tmp181, []any{tmp189})
											tmp191 := lang.Apply(tmp180, []any{tmp190})
											tmp192 := checkDerefVar(var_glojure_DOT_core_list)
											tmp193 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp194 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp195 := checkDerefVar(var_glojure_DOT_core_list)
											tmp196 := lang.Apply(tmp195, []any{sym_glojure_DOT_core_SLASH_let})
											tmp197 := checkDerefVar(var_glojure_DOT_core_list)
											tmp198 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp199 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp200 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp201 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp202 := checkDerefVar(var_glojure_DOT_core_list)
											tmp203 := lang.Apply(tmp202, []any{v52})
											tmp204 := checkDerefVar(var_glojure_DOT_core_list)
											tmp205 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp206 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp207 := checkDerefVar(var_glojure_DOT_core_list)
											tmp208 := lang.Apply(tmp207, []any{sym__DOT_nth})
											tmp209 := checkDerefVar(var_glojure_DOT_core_list)
											tmp210 := lang.Apply(tmp209, []any{v71})
											tmp211 := checkDerefVar(var_glojure_DOT_core_list)
											tmp212 := lang.Apply(tmp211, []any{v77})
											tmp213 := lang.Apply(tmp206, []any{tmp208, tmp210, tmp212})
											tmp214 := lang.Apply(tmp205, []any{tmp213})
											tmp215 := lang.Apply(tmp204, []any{tmp214})
											tmp216 := lang.Apply(tmp201, []any{tmp203, tmp215})
											tmp217 := lang.Apply(tmp200, []any{tmp216})
											tmp218 := lang.Apply(tmp198, []any{tmp199, tmp217})
											tmp219 := lang.Apply(tmp197, []any{tmp218})
											tmp220 := checkDerefVar(var_glojure_DOT_core_list)
											tmp221 := lang.Apply(tmp220, []any{v137})
											var tmp222 any
											if lang.IsTruthy(v106) {
												tmp223 := lang.NewVector(v131)
												tmp224 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3256), kw_column, int(48), kw_end_DASH_line, int(3256), kw_end_DASH_column, int(62))
												tmp225, err := lang.WithMeta(tmp223, tmp224.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp222 = tmp225
											} else {
											}
											tmp226 := lang.Apply(tmp194, []any{tmp196, tmp219, tmp221, tmp222})
											tmp227 := lang.Apply(tmp193, []any{tmp226})
											tmp228 := lang.Apply(tmp192, []any{tmp227})
											tmp229 := checkDerefVar(var_glojure_DOT_core_list)
											tmp230 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp231 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp232 := checkDerefVar(var_glojure_DOT_core_list)
											tmp233 := lang.Apply(tmp232, []any{sym_glojure_DOT_core_SLASH_when_DASH_let})
											tmp234 := checkDerefVar(var_glojure_DOT_core_list)
											tmp235 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp236 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp237 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp238 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp239 := checkDerefVar(var_glojure_DOT_core_list)
											tmp240 := lang.Apply(tmp239, []any{v63})
											tmp241 := checkDerefVar(var_glojure_DOT_core_list)
											tmp242 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp243 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp244 := checkDerefVar(var_glojure_DOT_core_list)
											tmp245 := lang.Apply(tmp244, []any{sym_glojure_DOT_core_SLASH_seq})
											tmp246 := checkDerefVar(var_glojure_DOT_core_list)
											tmp247 := lang.Apply(tmp246, []any{v63})
											tmp248 := lang.Apply(tmp243, []any{tmp245, tmp247})
											tmp249 := lang.Apply(tmp242, []any{tmp248})
											tmp250 := lang.Apply(tmp241, []any{tmp249})
											tmp251 := lang.Apply(tmp238, []any{tmp240, tmp250})
											tmp252 := lang.Apply(tmp237, []any{tmp251})
											tmp253 := lang.Apply(tmp235, []any{tmp236, tmp252})
											tmp254 := lang.Apply(tmp234, []any{tmp253})
											tmp255 := checkDerefVar(var_glojure_DOT_core_list)
											tmp256 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp257 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp258 := checkDerefVar(var_glojure_DOT_core_list)
											tmp259 := lang.Apply(tmp258, []any{sym_if})
											tmp260 := checkDerefVar(var_glojure_DOT_core_list)
											tmp261 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp262 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp263 := checkDerefVar(var_glojure_DOT_core_list)
											tmp264 := lang.Apply(tmp263, []any{sym_glojure_DOT_core_SLASH_chunked_DASH_seq_QMARK_})
											tmp265 := checkDerefVar(var_glojure_DOT_core_list)
											tmp266 := lang.Apply(tmp265, []any{v63})
											tmp267 := lang.Apply(tmp262, []any{tmp264, tmp266})
											tmp268 := lang.Apply(tmp261, []any{tmp267})
											tmp269 := lang.Apply(tmp260, []any{tmp268})
											tmp270 := checkDerefVar(var_glojure_DOT_core_list)
											tmp271 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp272 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp273 := checkDerefVar(var_glojure_DOT_core_list)
											tmp274 := lang.Apply(tmp273, []any{sym_glojure_DOT_core_SLASH_let})
											tmp275 := checkDerefVar(var_glojure_DOT_core_list)
											tmp276 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp277 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp278 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp279 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp280 := checkDerefVar(var_glojure_DOT_core_list)
											tmp281 := lang.Apply(tmp280, []any{sym_c__0__auto__})
											tmp282 := checkDerefVar(var_glojure_DOT_core_list)
											tmp283 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp284 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp285 := checkDerefVar(var_glojure_DOT_core_list)
											tmp286 := lang.Apply(tmp285, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_first})
											tmp287 := checkDerefVar(var_glojure_DOT_core_list)
											tmp288 := lang.Apply(tmp287, []any{v63})
											tmp289 := lang.Apply(tmp284, []any{tmp286, tmp288})
											tmp290 := lang.Apply(tmp283, []any{tmp289})
											tmp291 := lang.Apply(tmp282, []any{tmp290})
											tmp292 := lang.Apply(tmp279, []any{tmp281, tmp291})
											tmp293 := lang.Apply(tmp278, []any{tmp292})
											tmp294 := lang.Apply(tmp276, []any{tmp277, tmp293})
											tmp295 := lang.Apply(tmp275, []any{tmp294})
											tmp296 := checkDerefVar(var_glojure_DOT_core_list)
											tmp297 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp298 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp299 := checkDerefVar(var_glojure_DOT_core_list)
											tmp300 := lang.Apply(tmp299, []any{sym_recur})
											tmp301 := checkDerefVar(var_glojure_DOT_core_list)
											tmp302 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp303 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp304 := checkDerefVar(var_glojure_DOT_core_list)
											tmp305 := lang.Apply(tmp304, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_rest})
											tmp306 := checkDerefVar(var_glojure_DOT_core_list)
											tmp307 := lang.Apply(tmp306, []any{v63})
											tmp308 := lang.Apply(tmp303, []any{tmp305, tmp307})
											tmp309 := lang.Apply(tmp302, []any{tmp308})
											tmp310 := lang.Apply(tmp301, []any{tmp309})
											tmp311 := checkDerefVar(var_glojure_DOT_core_list)
											tmp312 := lang.Apply(tmp311, []any{sym_c__0__auto__})
											tmp313 := checkDerefVar(var_glojure_DOT_core_list)
											tmp314 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp315 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp316 := checkDerefVar(var_glojure_DOT_core_list)
											tmp317 := lang.Apply(tmp316, []any{sym_glojure_DOT_core_SLASH_int})
											tmp318 := checkDerefVar(var_glojure_DOT_core_list)
											tmp319 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp320 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp321 := checkDerefVar(var_glojure_DOT_core_list)
											tmp322 := lang.Apply(tmp321, []any{sym_glojure_DOT_core_SLASH_count})
											tmp323 := checkDerefVar(var_glojure_DOT_core_list)
											tmp324 := lang.Apply(tmp323, []any{sym_c__0__auto__})
											tmp325 := lang.Apply(tmp320, []any{tmp322, tmp324})
											tmp326 := lang.Apply(tmp319, []any{tmp325})
											tmp327 := lang.Apply(tmp318, []any{tmp326})
											tmp328 := lang.Apply(tmp315, []any{tmp317, tmp327})
											tmp329 := lang.Apply(tmp314, []any{tmp328})
											tmp330 := lang.Apply(tmp313, []any{tmp329})
											tmp331 := checkDerefVar(var_glojure_DOT_core_list)
											tmp332 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp333 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp334 := checkDerefVar(var_glojure_DOT_core_list)
											tmp335 := lang.Apply(tmp334, []any{sym_glojure_DOT_core_SLASH_int})
											tmp336 := checkDerefVar(var_glojure_DOT_core_list)
											tmp337 := lang.Apply(tmp336, []any{int64(0)})
											tmp338 := lang.Apply(tmp333, []any{tmp335, tmp337})
											tmp339 := lang.Apply(tmp332, []any{tmp338})
											tmp340 := lang.Apply(tmp331, []any{tmp339})
											tmp341 := lang.Apply(tmp298, []any{tmp300, tmp310, tmp312, tmp330, tmp340})
											tmp342 := lang.Apply(tmp297, []any{tmp341})
											tmp343 := lang.Apply(tmp296, []any{tmp342})
											tmp344 := lang.Apply(tmp272, []any{tmp274, tmp295, tmp343})
											tmp345 := lang.Apply(tmp271, []any{tmp344})
											tmp346 := lang.Apply(tmp270, []any{tmp345})
											tmp347 := checkDerefVar(var_glojure_DOT_core_list)
											tmp348 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp349 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp350 := checkDerefVar(var_glojure_DOT_core_list)
											tmp351 := lang.Apply(tmp350, []any{sym_glojure_DOT_core_SLASH_let})
											tmp352 := checkDerefVar(var_glojure_DOT_core_list)
											tmp353 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp354 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp355 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp356 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp357 := checkDerefVar(var_glojure_DOT_core_list)
											tmp358 := lang.Apply(tmp357, []any{v52})
											tmp359 := checkDerefVar(var_glojure_DOT_core_list)
											tmp360 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp361 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp362 := checkDerefVar(var_glojure_DOT_core_list)
											tmp363 := lang.Apply(tmp362, []any{sym_glojure_DOT_core_SLASH_first})
											tmp364 := checkDerefVar(var_glojure_DOT_core_list)
											tmp365 := lang.Apply(tmp364, []any{v63})
											tmp366 := lang.Apply(tmp361, []any{tmp363, tmp365})
											tmp367 := lang.Apply(tmp360, []any{tmp366})
											tmp368 := lang.Apply(tmp359, []any{tmp367})
											tmp369 := lang.Apply(tmp356, []any{tmp358, tmp368})
											tmp370 := lang.Apply(tmp355, []any{tmp369})
											tmp371 := lang.Apply(tmp353, []any{tmp354, tmp370})
											tmp372 := lang.Apply(tmp352, []any{tmp371})
											tmp373 := checkDerefVar(var_glojure_DOT_core_list)
											tmp374 := lang.Apply(tmp373, []any{v108})
											var tmp375 any
											if lang.IsTruthy(v106) {
												tmp376 := lang.NewVector(v100)
												tmp377 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3264), kw_column, int(52), kw_end_DASH_line, int(3264), kw_end_DASH_column, int(60))
												tmp378, err := lang.WithMeta(tmp376, tmp377.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp375 = tmp378
											} else {
											}
											tmp379 := lang.Apply(tmp349, []any{tmp351, tmp372, tmp374, tmp375})
											tmp380 := lang.Apply(tmp348, []any{tmp379})
											tmp381 := lang.Apply(tmp347, []any{tmp380})
											tmp382 := lang.Apply(tmp257, []any{tmp259, tmp269, tmp346, tmp381})
											tmp383 := lang.Apply(tmp256, []any{tmp382})
											tmp384 := lang.Apply(tmp255, []any{tmp383})
											tmp385 := lang.Apply(tmp231, []any{tmp233, tmp254, tmp384})
											tmp386 := lang.Apply(tmp230, []any{tmp385})
											tmp387 := lang.Apply(tmp229, []any{tmp386})
											tmp388 := lang.Apply(tmp177, []any{tmp179, tmp191, tmp228, tmp387})
											tmp389 := lang.Apply(tmp176, []any{tmp388})
											tmp390 := lang.Apply(tmp175, []any{tmp389})
											tmp391 := lang.Apply(tmp139, []any{tmp141, tmp174, tmp390})
											tmp392 := lang.Apply(tmp138, []any{tmp391})
											tmp393 := lang.NewVector(true, tmp392)
											tmp394 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3250), kw_column, int(24), kw_end_DASH_line, int(3264), kw_end_DASH_column, int(67))
											tmp395, err := lang.WithMeta(tmp393, tmp394.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp60 = tmp395
										} // end let
										tmp56 = tmp60
									}
									tmp49 = tmp56
								} // end let
								tmp37 = tmp49
							}
							return tmp37
						})
						v34 = tmp33
						_ = v34
					}
					tmp34 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3218), kw_column, int(14), kw_end_DASH_line, int(3264), kw_end_DASH_column, int(72))
					tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v36 any = tmp35
					_ = v36
					tmp37 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp39 := lang.Apply(tmp38, []any{v4})
					tmp40 := lang.Apply(v36, []any{nil, tmp39})
					tmp41 := lang.Apply(tmp37, []any{tmp40, int64(1)})
					tmp32 = tmp41
				} // end let
				return tmp32
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_doseq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_doseq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doto
	{
		tmp0 := sym_doto.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_forms)), kw_doc, "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(3853), kw_end_DASH_line, int(3853))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "gx"
					tmp7 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp8 := lang.Apply(tmp7, nil)
					var v9 any = tmp8
					_ = v9
					tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp11 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_glojure_DOT_core_SLASH_let})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp16 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v9})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v4})
					tmp23 := lang.Apply(tmp18, []any{tmp20, tmp22})
					tmp24 := lang.Apply(tmp17, []any{tmp23})
					tmp25 := lang.Apply(tmp15, []any{tmp16, tmp24})
					tmp26 := lang.Apply(tmp14, []any{tmp25})
					tmp27 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp28 lang.FnFunc
					tmp28 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v29 := args[0]
						_ = v29
						tmp30 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
						var tmp31 any
						tmp32 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp33 := lang.Apply(tmp32, []any{v29})
						if lang.IsTruthy(tmp33) {
							tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp35 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp36 := checkDerefVar(var_glojure_DOT_core_list)
							tmp37 := checkDerefVar(var_glojure_DOT_core_first)
							tmp38 := lang.Apply(tmp37, []any{v29})
							tmp39 := lang.Apply(tmp36, []any{tmp38})
							tmp40 := checkDerefVar(var_glojure_DOT_core_list)
							tmp41 := lang.Apply(tmp40, []any{v9})
							tmp42 := checkDerefVar(var_glojure_DOT_core_next)
							tmp43 := lang.Apply(tmp42, []any{v29})
							tmp44 := lang.Apply(tmp35, []any{tmp39, tmp41, tmp43})
							tmp45 := lang.Apply(tmp34, []any{tmp44})
							tmp31 = tmp45
						} else {
							tmp46 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp47 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp48 := checkDerefVar(var_glojure_DOT_core_list)
							tmp49 := lang.Apply(tmp48, []any{v29})
							tmp50 := checkDerefVar(var_glojure_DOT_core_list)
							tmp51 := lang.Apply(tmp50, []any{v9})
							tmp52 := lang.Apply(tmp47, []any{tmp49, tmp51})
							tmp53 := lang.Apply(tmp46, []any{tmp52})
							tmp31 = tmp53
						}
						tmp54 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp55 := lang.Apply(tmp54, []any{v29})
						tmp56 := lang.Apply(tmp30, []any{tmp31, tmp55})
						return tmp56
					})
					tmp29 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3863), kw_column, int(17), kw_end_DASH_line, int(3868), kw_end_DASH_column, int(30))
					tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp31 := lang.Apply(tmp27, []any{tmp30, v5})
					tmp32 := checkDerefVar(var_glojure_DOT_core_list)
					tmp33 := lang.Apply(tmp32, []any{v9})
					tmp34 := lang.Apply(tmp11, []any{tmp13, tmp26, tmp31, tmp33})
					tmp35 := lang.Apply(tmp10, []any{tmp34})
					tmp6 = tmp35
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_doto = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_doto.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop-last
	{
		tmp0 := sym_drop_DASH_last.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll), lang.NewVector(sym_n, sym_coll)), kw_doc, "Return a lazy sequence of all but the last n (default 1) items in coll", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2932), kw_end_DASH_line, int(2932))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_drop_DASH_last)
				tmp4 := lang.Apply(tmp3, []any{int64(1), v2})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v6 := args[0]
					_ = v6
					v7 := args[1]
					_ = v7
					return v6
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2937), kw_column, int(18), kw_end_DASH_line, int(2937), kw_end_DASH_column, int(29))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := checkDerefVar(var_glojure_DOT_core_drop)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp10 := lang.Apply(tmp4, []any{tmp7, v3, tmp9})
				return tmp10
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_drop_DASH_last = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_drop_DASH_last.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-extend-protocol
	{
		tmp0 := sym_emit_DASH_extend_DASH_protocol.WithMeta(lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(205), kw_column, int(8), kw_end_DASH_line, int(205), kw_end_DASH_column, int(27), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_p, sym_specs)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "impls"
				tmp5 := checkDerefVar(var_glojure_DOT_core_parse_DASH_impls)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_do})
				tmp12 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp13 lang.FnFunc
				tmp13 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v14 := args[0]
					_ = v14
					var tmp15 any
					{ // let
						// let binding "vec__292"
						var v16 any = v14
						_ = v16
						// let binding "t"
						tmp17 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp18 := lang.Apply(tmp17, []any{v16, int64(0), nil})
						var v19 any = tmp18
						_ = v19
						// let binding "fs"
						tmp20 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp21 := lang.Apply(tmp20, []any{v16, int64(1), nil})
						var v22 any = tmp21
						_ = v22
						tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp25 := checkDerefVar(var_glojure_DOT_core_list)
						tmp26 := lang.Apply(tmp25, []any{sym_glojure_DOT_core_SLASH_extend_DASH_type})
						tmp27 := checkDerefVar(var_glojure_DOT_core_list)
						tmp28 := lang.Apply(tmp27, []any{v19})
						tmp29 := checkDerefVar(var_glojure_DOT_core_list)
						tmp30 := lang.Apply(tmp29, []any{v2})
						tmp31 := lang.Apply(tmp24, []any{tmp26, tmp28, tmp30, v22})
						tmp32 := lang.Apply(tmp23, []any{tmp31})
						tmp15 = tmp32
					} // end let
					return tmp15
				})
				tmp14 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(208), kw_column, int(15), kw_end_DASH_line, int(209), kw_end_DASH_column, int(42))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp16 := lang.Apply(tmp12, []any{tmp15, v7})
				tmp17 := lang.Apply(tmp9, []any{tmp11, tmp16})
				tmp18 := lang.Apply(tmp8, []any{tmp17})
				tmp4 = tmp18
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_emit_DASH_extend_DASH_protocol = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_emit_DASH_extend_DASH_protocol.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-hinted-impl
	{
		tmp0 := sym_emit_DASH_hinted_DASH_impl.WithMeta(lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(163), kw_column, int(8), kw_end_DASH_line, int(163), kw_end_DASH_column, int(23), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_c, lang.NewVector(sym_p, sym_fs))), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "vec__281"
				var v5 any = v3
				_ = v5
				// let binding "p"
				tmp6 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "fs"
				tmp9 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				{ // let
					// let binding "hint"
					var tmp13 lang.FnFunc
					tmp13 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v14 := args[0]
						_ = v14
						var tmp15 any
						{ // let
							// let binding "specs"
							var tmp16 any
							tmp17 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
							tmp18 := checkDerefVar(var_glojure_DOT_core_first)
							tmp19 := lang.Apply(tmp18, []any{v14})
							tmp20 := lang.Apply(tmp17, []any{tmp19})
							if lang.IsTruthy(tmp20) {
								tmp21 := checkDerefVar(var_glojure_DOT_core_list)
								tmp22 := lang.Apply(tmp21, []any{v14})
								tmp16 = tmp22
							} else {
								tmp16 = v14
							}
							var v23 any = tmp16
							_ = v23
							tmp24 := checkDerefVar(var_glojure_DOT_core_map)
							var tmp25 lang.FnFunc
							tmp25 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v26 := args[0]
								_ = v26
								var tmp27 any
								{ // let
									// let binding "vec__285"
									var v28 any = v26
									_ = v28
									// let binding "seq__286"
									tmp29 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp30 := lang.Apply(tmp29, []any{v28})
									var v31 any = tmp30
									_ = v31
									// let binding "first__287"
									tmp32 := checkDerefVar(var_glojure_DOT_core_first)
									tmp33 := lang.Apply(tmp32, []any{v31})
									var v34 any = tmp33
									_ = v34
									// let binding "seq__286"
									tmp35 := checkDerefVar(var_glojure_DOT_core_next)
									tmp36 := lang.Apply(tmp35, []any{v31})
									var v37 any = tmp36
									_ = v37
									// let binding "vec__288"
									var v38 any = v34
									_ = v38
									// let binding "seq__289"
									tmp39 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp40 := lang.Apply(tmp39, []any{v38})
									var v41 any = tmp40
									_ = v41
									// let binding "first__290"
									tmp42 := checkDerefVar(var_glojure_DOT_core_first)
									tmp43 := lang.Apply(tmp42, []any{v41})
									var v44 any = tmp43
									_ = v44
									// let binding "seq__289"
									tmp45 := checkDerefVar(var_glojure_DOT_core_next)
									tmp46 := lang.Apply(tmp45, []any{v41})
									var v47 any = tmp46
									_ = v47
									// let binding "target"
									var v48 any = v44
									_ = v48
									// let binding "args"
									var v49 any = v47
									_ = v49
									// let binding "body"
									var v50 any = v37
									_ = v50
									tmp51 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp52 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp53 := checkDerefVar(var_glojure_DOT_core_vector)
									tmp54 := checkDerefVar(var_glojure_DOT_core_vary_DASH_meta)
									tmp55 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp56 := lang.Apply(tmp54, []any{v48, tmp55, kw_tag, v2})
									tmp57 := lang.Apply(tmp52, []any{tmp53, tmp56, v49})
									tmp58 := lang.Apply(tmp51, []any{tmp57, v50})
									tmp27 = tmp58
								} // end let
								return tmp27
							})
							tmp26 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(168), kw_column, int(23), kw_end_DASH_line, int(170), kw_end_DASH_column, int(36))
							tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp28 := lang.Apply(tmp24, []any{tmp27, v23})
							tmp15 = tmp28
						} // end let
						return tmp15
					})
					tmp14 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(164), kw_column, int(14), kw_end_DASH_line, int(171), kw_end_DASH_column, int(30))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v16 any = tmp15
					_ = v16
					tmp17 := checkDerefVar(var_glojure_DOT_core_zipmap)
					tmp18 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp19 lang.FnFunc
					tmp19 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v20 := args[0]
						_ = v20
						tmp21 := checkDerefVar(var_glojure_DOT_core_keyword)
						tmp22 := checkDerefVar(var_glojure_DOT_core_name)
						tmp23 := checkDerefVar(var_glojure_DOT_core_first)
						tmp24 := lang.Apply(tmp23, []any{v20})
						tmp25 := lang.Apply(tmp22, []any{tmp24})
						tmp26 := lang.Apply(tmp21, []any{tmp25})
						return tmp26
					})
					tmp20 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(172), kw_column, int(21), kw_end_DASH_line, int(172), kw_end_DASH_column, int(46))
					tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp22 := lang.Apply(tmp18, []any{tmp21, v11})
					tmp23 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp24 lang.FnFunc
					tmp24 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v25 := args[0]
						_ = v25
						tmp26 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp27 := checkDerefVar(var_glojure_DOT_core_drop)
						tmp28 := lang.Apply(tmp27, []any{int64(1), v25})
						tmp29 := lang.Apply(v16, []any{tmp28})
						tmp30 := lang.Apply(tmp26, []any{sym_glojure_DOT_core_SLASH_fn, tmp29})
						return tmp30
					})
					tmp25 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(173), kw_column, int(21), kw_end_DASH_line, int(173), kw_end_DASH_column, int(49))
					tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp27 := lang.Apply(tmp23, []any{tmp26, v11})
					tmp28 := lang.Apply(tmp17, []any{tmp22, tmp27})
					tmp29 := lang.NewVector(v8, tmp28)
					tmp30 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(172), kw_column, int(5), kw_end_DASH_line, int(173), kw_end_DASH_column, int(55))
					tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 = tmp31
				} // end let
				tmp4 = tmp12
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_emit_DASH_hinted_DASH_impl = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_emit_DASH_hinted_DASH_impl.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend-protocol
	{
		tmp0 := sym_extend_DASH_protocol.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_p, sym__AMP_, sym_specs)), kw_doc, "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types.\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))", kw_file, "glojure/core_deftype.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(11), kw_line, int(212), kw_end_DASH_line, int(212))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_emit_DASH_extend_DASH_protocol)
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_extend_DASH_protocol = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_extend_DASH_protocol.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fits-table?
	{
		tmp0 := sym_fits_DASH_table_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ints)), kw_doc, "Returns true if the collection of ints can fit within the\n  max-table-switch-size, false otherwise.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(8), kw_line, int(6625), kw_end_DASH_line, int(6625), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core__LT_)
			tmp4 := checkDerefVar(var_glojure_DOT_core__DASH_)
			tmp5 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp6 := checkDerefVar(var_glojure_DOT_core_max)
			tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp8 := lang.Apply(tmp7, []any{v2})
			tmp9 := lang.Apply(tmp5, []any{tmp6, tmp8})
			tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp11 := checkDerefVar(var_glojure_DOT_core_min)
			tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp13 := lang.Apply(tmp12, []any{v2})
			tmp14 := lang.Apply(tmp10, []any{tmp11, tmp13})
			tmp15 := lang.Apply(tmp4, []any{tmp9, tmp14})
			tmp16 := checkDerefVar(var_glojure_DOT_core_max_DASH_switch_DASH_table_DASH_size)
			tmp17 := lang.Apply(tmp3, []any{tmp15, tmp16})
			return tmp17
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_fits_DASH_table_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_fits_DASH_table_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fn
	{
		tmp0 := sym_fn.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_sigs)), kw_doc, "params => positional-params*, or positional-params* & rest-param\n  positional-param => binding-form\n  rest-param => binding-form\n  binding-form => name, or destructuring-form\n\n  Defines a function.\n\n  See https://glojure.org/reference/special_forms#fn for more information", kw_forms, lang.NewVector(lang.NewList(sym_fn, sym_name_QMARK_, lang.NewVector(sym_params_STAR_), sym_exprs_STAR_), lang.NewList(sym_fn, sym_name_QMARK_, lang.NewList(lang.NewVector(sym_params_STAR_), sym_exprs_STAR_), sym__PLUS_)), kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(4533), kw_end_DASH_line, int(4533), kw_special_DASH_form, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "name"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
					tmp8 := checkDerefVar(var_glojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v4})
					tmp10 := lang.Apply(tmp7, []any{tmp9})
					if lang.IsTruthy(tmp10) {
						tmp11 := checkDerefVar(var_glojure_DOT_core_first)
						tmp12 := lang.Apply(tmp11, []any{v4})
						tmp6 = tmp12
					} else {
					}
					var v13 any = tmp6
					_ = v13
					// let binding "sigs"
					var tmp14 any
					if lang.IsTruthy(v13) {
						tmp15 := checkDerefVar(var_glojure_DOT_core_next)
						tmp16 := lang.Apply(tmp15, []any{v4})
						tmp14 = tmp16
					} else {
						tmp14 = v4
					}
					var v17 any = tmp14
					_ = v17
					// let binding "sigs"
					var tmp18 any
					tmp19 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
					tmp20 := checkDerefVar(var_glojure_DOT_core_first)
					tmp21 := lang.Apply(tmp20, []any{v17})
					tmp22 := lang.Apply(tmp19, []any{tmp21})
					if lang.IsTruthy(tmp22) {
						tmp23 := checkDerefVar(var_glojure_DOT_core_list)
						tmp24 := lang.Apply(tmp23, []any{v17})
						tmp18 = tmp24
					} else {
						var tmp25 any
						tmp26 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp27 := checkDerefVar(var_glojure_DOT_core_first)
						tmp28 := lang.Apply(tmp27, []any{v17})
						tmp29 := lang.Apply(tmp26, []any{tmp28})
						if lang.IsTruthy(tmp29) {
							tmp25 = v17
						} else {
							var tmp30 any
							tmp31 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp32 := lang.Apply(tmp31, []any{v17})
							if lang.IsTruthy(tmp32) {
								tmp33 := checkDerefVar(var_glojure_DOT_core_str)
								tmp34 := checkDerefVar(var_glojure_DOT_core_first)
								tmp35 := lang.Apply(tmp34, []any{v17})
								tmp36 := lang.Apply(tmp33, []any{"Parameter declaration ", tmp35, " should be a vector"})
								tmp30 = tmp36
							} else {
								tmp37 := checkDerefVar(var_glojure_DOT_core_str)
								tmp38 := lang.Apply(tmp37, []any{"Parameter declaration missing"})
								tmp30 = tmp38
							}
							tmp39 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
							panic(tmp39)
						}
						tmp18 = tmp25
					}
					var v40 any = tmp18
					_ = v40
					// let binding "psig"
					var tmp41 lang.FnFunc
					tmp41 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v42 := args[0]
						_ = v42
						var tmp43 any
						tmp44 := checkDerefVar(var_glojure_DOT_core_not)
						tmp45 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp46 := lang.Apply(tmp45, []any{v42})
						tmp47 := lang.Apply(tmp44, []any{tmp46})
						if lang.IsTruthy(tmp47) {
							tmp48 := checkDerefVar(var_glojure_DOT_core_str)
							tmp49 := lang.Apply(tmp48, []any{"Invalid signature ", v42, " should be a list"})
							tmp50 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp49})
							panic(tmp50)
						} else {
						}
						_ = tmp43
						var tmp51 any
						{ // let
							// let binding "vec__13"
							var v52 any = v42
							_ = v52
							// let binding "seq__14"
							tmp53 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp54 := lang.Apply(tmp53, []any{v52})
							var v55 any = tmp54
							_ = v55
							// let binding "first__15"
							tmp56 := checkDerefVar(var_glojure_DOT_core_first)
							tmp57 := lang.Apply(tmp56, []any{v55})
							var v58 any = tmp57
							_ = v58
							// let binding "seq__14"
							tmp59 := checkDerefVar(var_glojure_DOT_core_next)
							tmp60 := lang.Apply(tmp59, []any{v55})
							var v61 any = tmp60
							_ = v61
							// let binding "params"
							var v62 any = v58
							_ = v62
							// let binding "body"
							var v63 any = v61
							_ = v63
							// let binding "_"
							var tmp64 any
							tmp65 := checkDerefVar(var_glojure_DOT_core_not)
							tmp66 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
							tmp67 := lang.Apply(tmp66, []any{v62})
							tmp68 := lang.Apply(tmp65, []any{tmp67})
							if lang.IsTruthy(tmp68) {
								var tmp69 any
								tmp70 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
								tmp71 := checkDerefVar(var_glojure_DOT_core_first)
								tmp72 := lang.Apply(tmp71, []any{v40})
								tmp73 := lang.Apply(tmp70, []any{tmp72})
								if lang.IsTruthy(tmp73) {
									tmp74 := checkDerefVar(var_glojure_DOT_core_str)
									tmp75 := lang.Apply(tmp74, []any{"Parameter declaration ", v62, " should be a vector"})
									tmp69 = tmp75
								} else {
									tmp76 := checkDerefVar(var_glojure_DOT_core_str)
									tmp77 := lang.Apply(tmp76, []any{"Invalid signature ", v42, " should be a list"})
									tmp69 = tmp77
								}
								tmp78 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp69})
								panic(tmp78)
							} else {
							}
							var v79 any = tmp64
							_ = v79
							// let binding "conds"
							var tmp80 any
							var tmp81 any
							{ // let
								// let binding "and__0__auto__"
								tmp82 := checkDerefVar(var_glojure_DOT_core_next)
								tmp83 := lang.Apply(tmp82, []any{v63})
								var v84 any = tmp83
								_ = v84
								var tmp85 any
								if lang.IsTruthy(v84) {
									tmp86 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
									tmp87 := checkDerefVar(var_glojure_DOT_core_first)
									tmp88 := lang.Apply(tmp87, []any{v63})
									tmp89 := lang.Apply(tmp86, []any{tmp88})
									tmp85 = tmp89
								} else {
									tmp85 = v84
								}
								tmp81 = tmp85
							} // end let
							if lang.IsTruthy(tmp81) {
								tmp82 := checkDerefVar(var_glojure_DOT_core_first)
								tmp83 := lang.Apply(tmp82, []any{v63})
								tmp80 = tmp83
							} else {
							}
							var v84 any = tmp80
							_ = v84
							// let binding "body"
							var tmp85 any
							if lang.IsTruthy(v84) {
								tmp86 := checkDerefVar(var_glojure_DOT_core_next)
								tmp87 := lang.Apply(tmp86, []any{v63})
								tmp85 = tmp87
							} else {
								tmp85 = v63
							}
							var v88 any = tmp85
							_ = v88
							// let binding "conds"
							var tmp89 any
							{ // let
								// let binding "or__0__auto__"
								var v90 any = v84
								_ = v90
								var tmp91 any
								if lang.IsTruthy(v90) {
									tmp91 = v90
								} else {
									tmp92 := checkDerefVar(var_glojure_DOT_core_meta)
									tmp93 := lang.Apply(tmp92, []any{v62})
									tmp91 = tmp93
								}
								tmp89 = tmp91
							} // end let
							var v90 any = tmp89
							_ = v90
							// let binding "pre"
							tmp91 := lang.Apply(kw_pre, []any{v90})
							var v92 any = tmp91
							_ = v92
							// let binding "post"
							tmp93 := lang.Apply(kw_post, []any{v90})
							var v94 any = tmp93
							_ = v94
							// let binding "body"
							var tmp95 any
							if lang.IsTruthy(v94) {
								tmp96 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp97 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp98 := checkDerefVar(var_glojure_DOT_core_list)
								tmp99 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp100 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp101 := checkDerefVar(var_glojure_DOT_core_list)
								tmp102 := lang.Apply(tmp101, []any{sym_glojure_DOT_core_SLASH_let})
								tmp103 := checkDerefVar(var_glojure_DOT_core_list)
								tmp104 := checkDerefVar(var_glojure_DOT_core_apply)
								tmp105 := checkDerefVar(var_glojure_DOT_core_vector)
								tmp106 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp107 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp108 := checkDerefVar(var_glojure_DOT_core_list)
								tmp109 := lang.Apply(tmp108, []any{sym__PCT_})
								tmp110 := checkDerefVar(var_glojure_DOT_core_list)
								var tmp111 any
								tmp112 := checkDerefVar(var_glojure_DOT_core__LT_)
								tmp113 := checkDerefVar(var_glojure_DOT_core_count)
								tmp114 := lang.Apply(tmp113, []any{v88})
								tmp115 := lang.Apply(tmp112, []any{int64(1), tmp114})
								if lang.IsTruthy(tmp115) {
									tmp116 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp117 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp118 := checkDerefVar(var_glojure_DOT_core_list)
									tmp119 := lang.Apply(tmp118, []any{sym_do})
									tmp120 := lang.Apply(tmp117, []any{tmp119, v88})
									tmp121 := lang.Apply(tmp116, []any{tmp120})
									tmp111 = tmp121
								} else {
									tmp122 := checkDerefVar(var_glojure_DOT_core_first)
									tmp123 := lang.Apply(tmp122, []any{v88})
									tmp111 = tmp123
								}
								tmp124 := lang.Apply(tmp110, []any{tmp111})
								tmp125 := lang.Apply(tmp107, []any{tmp109, tmp124})
								tmp126 := lang.Apply(tmp106, []any{tmp125})
								tmp127 := lang.Apply(tmp104, []any{tmp105, tmp126})
								tmp128 := lang.Apply(tmp103, []any{tmp127})
								tmp129 := checkDerefVar(var_glojure_DOT_core_map)
								var tmp130 lang.FnFunc
								tmp130 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v131 := args[0]
									_ = v131
									tmp132 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp133 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp134 := checkDerefVar(var_glojure_DOT_core_list)
									tmp135 := lang.Apply(tmp134, []any{sym_glojure_DOT_core_SLASH_assert})
									tmp136 := checkDerefVar(var_glojure_DOT_core_list)
									tmp137 := lang.Apply(tmp136, []any{v131})
									tmp138 := lang.Apply(tmp133, []any{tmp135, tmp137})
									tmp139 := lang.Apply(tmp132, []any{tmp138})
									return tmp139
								})
								tmp131 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4582), kw_column, int(41), kw_end_DASH_line, int(4582), kw_end_DASH_column, int(62))
								tmp132, err := lang.WithMeta(tmp130, tmp131.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp133 := lang.Apply(tmp129, []any{tmp132, v94})
								tmp134 := checkDerefVar(var_glojure_DOT_core_list)
								tmp135 := lang.Apply(tmp134, []any{sym__PCT_})
								tmp136 := lang.Apply(tmp100, []any{tmp102, tmp128, tmp133, tmp135})
								tmp137 := lang.Apply(tmp99, []any{tmp136})
								tmp138 := lang.Apply(tmp98, []any{tmp137})
								tmp139 := lang.Apply(tmp97, []any{tmp138})
								tmp140 := lang.Apply(tmp96, []any{tmp139})
								tmp95 = tmp140
							} else {
								tmp95 = v88
							}
							var v141 any = tmp95
							_ = v141
							// let binding "body"
							var tmp142 any
							if lang.IsTruthy(v92) {
								tmp143 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp144 := checkDerefVar(var_glojure_DOT_core_map)
								var tmp145 lang.FnFunc
								tmp145 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v146 := args[0]
									_ = v146
									tmp147 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp148 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp149 := checkDerefVar(var_glojure_DOT_core_list)
									tmp150 := lang.Apply(tmp149, []any{sym_glojure_DOT_core_SLASH_assert})
									tmp151 := checkDerefVar(var_glojure_DOT_core_list)
									tmp152 := lang.Apply(tmp151, []any{v146})
									tmp153 := lang.Apply(tmp148, []any{tmp150, tmp152})
									tmp154 := lang.Apply(tmp147, []any{tmp153})
									return tmp154
								})
								tmp146 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4586), kw_column, int(44), kw_end_DASH_line, int(4586), kw_end_DASH_column, int(65))
								tmp147, err := lang.WithMeta(tmp145, tmp146.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp148 := lang.Apply(tmp144, []any{tmp147, v92})
								tmp149 := lang.Apply(tmp143, []any{tmp148, v141})
								tmp142 = tmp149
							} else {
								tmp142 = v141
							}
							var v150 any = tmp142
							_ = v150
							tmp151 := checkDerefVar(var_glojure_DOT_core_maybe_DASH_destructured)
							tmp152 := lang.Apply(tmp151, []any{v62, v150})
							tmp51 = tmp152
						} // end let
						return tmp51
					})
					tmp42 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4558), kw_column, int(16), kw_end_DASH_line, int(4589), kw_end_DASH_column, int(53))
					tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v44 any = tmp43
					_ = v44
					// let binding "new-sigs"
					tmp45 := checkDerefVar(var_glojure_DOT_core_map)
					tmp46 := lang.Apply(tmp45, []any{v44, v40})
					var v47 any = tmp46
					_ = v47
					tmp48 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					var tmp49 any
					if lang.IsTruthy(v13) {
						tmp50 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
						tmp51 := lang.Apply(tmp50, []any{sym_fn_STAR_, v13, v47})
						tmp49 = tmp51
					} else {
						tmp52 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp53 := lang.Apply(tmp52, []any{sym_fn_STAR_, v47})
						tmp49 = tmp53
					}
					tmp54 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp55 := lang.Apply(tmp54, []any{v2})
					tmp56 := lang.Apply(tmp48, []any{tmp49, tmp55})
					tmp5 = tmp56
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_fn = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_fn.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// import
	{
		tmp0 := sym_import.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_import_DASH_symbols_DASH_or_DASH_lists)), kw_doc, "import-list => (package-symbol class-name-symbols*)\n\n  For each name in class-name-symbols, adds a mapping from name to the\n  class named by package.name to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(3426), kw_end_DASH_line, int(3426))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "specs"
					tmp6 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp7 lang.FnFunc
					tmp7 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v8 := args[0]
						_ = v8
						var tmp9 any
						var tmp10 any
						{ // let
							// let binding "and__0__auto__"
							tmp11 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
							tmp12 := lang.Apply(tmp11, []any{v8})
							var v13 any = tmp12
							_ = v13
							var tmp14 any
							if lang.IsTruthy(v13) {
								tmp15 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp16 := checkDerefVar(var_glojure_DOT_core_first)
								tmp17 := lang.Apply(tmp16, []any{v8})
								tmp18 := lang.Apply(tmp15, []any{sym_quote, tmp17})
								tmp14 = tmp18
							} else {
								tmp14 = v13
							}
							tmp10 = tmp14
						} // end let
						if lang.IsTruthy(tmp10) {
							tmp11 := checkDerefVar(var_glojure_DOT_core_second)
							tmp12 := lang.Apply(tmp11, []any{v8})
							tmp9 = tmp12
						} else {
							tmp9 = v8
						}
						return tmp9
					})
					tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3434), kw_column, int(20), kw_end_DASH_line, int(3434), kw_end_DASH_column, int(73))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp10 := lang.Apply(tmp6, []any{tmp9, v4})
					var v11 any = tmp10
					_ = v11
					tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := lang.Apply(tmp14, []any{sym_do})
					tmp16 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp17 lang.FnFunc
					tmp17 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v18 := args[0]
						_ = v18
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := lang.Apply(tmp19, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Import, v18})
						return tmp20
					})
					tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3436), kw_column, int(17), kw_end_DASH_line, int(3436), kw_end_DASH_column, int(73))
					tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp20 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp21 lang.FnFunc
					tmp21 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v22 := args[0]
						_ = v22
						v23 := args[1]
						_ = v23
						var tmp24 any
						tmp25 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
						tmp26 := lang.Apply(tmp25, []any{v23})
						if lang.IsTruthy(tmp26) {
							tmp27 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp28 := checkDerefVar(var_glojure_DOT_core_name)
							tmp29 := lang.Apply(tmp28, []any{v23})
							tmp30 := lang.Apply(tmp27, []any{v22, tmp29})
							tmp24 = tmp30
						} else {
							var tmp31 any
							{ // let
								// let binding "p"
								tmp32 := checkDerefVar(var_glojure_DOT_core_first)
								tmp33 := lang.Apply(tmp32, []any{v23})
								var v34 any = tmp33
								_ = v34
								// let binding "cs"
								tmp35 := checkDerefVar(var_glojure_DOT_core_rest)
								tmp36 := lang.Apply(tmp35, []any{v23})
								var v37 any = tmp36
								_ = v37
								tmp38 := checkDerefVar(var_glojure_DOT_core_into1)
								tmp39 := checkDerefVar(var_glojure_DOT_core_map)
								var tmp40 lang.FnFunc
								tmp40 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v41 := args[0]
									_ = v41
									tmp42 := checkDerefVar(var_glojure_DOT_core_str)
									tmp43 := lang.Apply(tmp42, []any{v34, ".", v41})
									return tmp43
								})
								tmp41 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3441), kw_column, int(45), kw_end_DASH_line, int(3441), kw_end_DASH_column, int(58))
								tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp43 := lang.Apply(tmp39, []any{tmp42, v37})
								tmp44 := lang.Apply(tmp38, []any{v22, tmp43})
								tmp31 = tmp44
							} // end let
							tmp24 = tmp31
						}
						return tmp24
					})
					tmp22 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3437), kw_column, int(26), kw_end_DASH_line, int(3441), kw_end_DASH_column, int(66))
					tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp24 := lang.NewVector()
					tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3442), kw_column, int(25), kw_end_DASH_line, int(3442), kw_end_DASH_column, int(26))
					tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp27 := lang.Apply(tmp20, []any{tmp23, tmp26, v11})
					tmp28 := lang.Apply(tmp16, []any{tmp19, tmp27})
					tmp29 := lang.Apply(tmp13, []any{tmp15, tmp28})
					tmp30 := lang.Apply(tmp12, []any{tmp29})
					tmp5 = tmp30
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_import = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_import.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// interleave
	{
		tmp0 := sym_interleave.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_c1), lang.NewVector(sym_c1, sym_c2), lang.NewVector(sym_c1, sym_c2, sym__AMP_, sym_colls)), kw_doc, "Returns a lazy seq of the first item in each coll, then the second etc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4308), kw_end_DASH_line, int(4308))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return lang.NewList()
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					return v2
				})
				tmp4 := lang.Apply(lang.NewLazySeq, []any{tmp3})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp5 any
					{ // let
						// let binding "s1"
						tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp7 := lang.Apply(tmp6, []any{v2})
						var v8 any = tmp7
						_ = v8
						// let binding "s2"
						tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp10 := lang.Apply(tmp9, []any{v3})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						var tmp13 any
						{ // let
							// let binding "and__0__auto__"
							var v14 any = v8
							_ = v14
							var tmp15 any
							if lang.IsTruthy(v14) {
								tmp15 = v11
							} else {
								tmp15 = v14
							}
							tmp13 = tmp15
						} // end let
						if lang.IsTruthy(tmp13) {
							tmp14 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp15 := checkDerefVar(var_glojure_DOT_core_first)
							tmp16 := lang.Apply(tmp15, []any{v8})
							tmp17 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp18 := checkDerefVar(var_glojure_DOT_core_first)
							tmp19 := lang.Apply(tmp18, []any{v11})
							tmp20 := checkDerefVar(var_glojure_DOT_core_interleave)
							tmp21 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp22 := lang.Apply(tmp21, []any{v8})
							tmp23 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp24 := lang.Apply(tmp23, []any{v11})
							tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
							tmp26 := lang.Apply(tmp17, []any{tmp19, tmp25})
							tmp27 := lang.Apply(tmp14, []any{tmp16, tmp26})
							tmp12 = tmp27
						} else {
						}
						tmp5 = tmp12
					} // end let
					return tmp5
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "ss"
						tmp7 := checkDerefVar(var_glojure_DOT_core_map)
						tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp9 := checkDerefVar(var_glojure_DOT_core_conj)
						tmp10 := lang.Apply(tmp9, []any{v4, v3, v2})
						tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						tmp14 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
						tmp15 := checkDerefVar(var_glojure_DOT_core_identity)
						tmp16 := lang.Apply(tmp14, []any{tmp15, v12})
						if lang.IsTruthy(tmp16) {
							tmp17 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp18 := checkDerefVar(var_glojure_DOT_core_map)
							tmp19 := checkDerefVar(var_glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp18, []any{tmp19, v12})
							tmp21 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp22 := checkDerefVar(var_glojure_DOT_core_interleave)
							tmp23 := checkDerefVar(var_glojure_DOT_core_map)
							tmp24 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp25 := lang.Apply(tmp23, []any{tmp24, v12})
							tmp26 := lang.Apply(tmp21, []any{tmp22, tmp25})
							tmp27 := lang.Apply(tmp17, []any{tmp20, tmp26})
							tmp13 = tmp27
						} else {
						}
						tmp6 = tmp13
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_interleave = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_interleave.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// interpose
	{
		tmp0 := sym_interpose.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sep), lang.NewVector(sym_sep, sym_coll)), kw_doc, "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(5230), kw_end_DASH_line, int(5230))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "started"
						tmp6 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp7 := lang.Apply(tmp6, []any{false})
						var v8 any = tmp7
						_ = v8
						var tmp9 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp10 := lang.Apply(v4, nil)
								return tmp10
							case 1:
								v10 := args[0]
								_ = v10
								tmp11 := lang.Apply(v4, []any{v10})
								return tmp11
							case 2:
								v10 := args[0]
								_ = v10
								v11 := args[1]
								_ = v11
								var tmp12 any
								tmp13 := checkDerefVar(var_glojure_DOT_core_deref)
								tmp14 := lang.Apply(tmp13, []any{v8})
								if lang.IsTruthy(tmp14) {
									var tmp15 any
									{ // let
										// let binding "sepr"
										tmp16 := lang.Apply(v4, []any{v10, v2})
										var v17 any = tmp16
										_ = v17
										var tmp18 any
										tmp19 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
										tmp20 := lang.Apply(tmp19, []any{v17})
										if lang.IsTruthy(tmp20) {
											tmp18 = v17
										} else {
											tmp21 := lang.Apply(v4, []any{v17, v11})
											tmp18 = tmp21
										}
										tmp15 = tmp18
									} // end let
									tmp12 = tmp15
								} else {
									tmp16 := checkDerefVar(var_glojure_DOT_core_vreset_BANG_)
									tmp17 := lang.Apply(tmp16, []any{v8, true})
									_ = tmp17
									tmp18 := lang.Apply(v4, []any{v10, v11})
									tmp12 = tmp18
								}
								return tmp12
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5238), kw_column, int(8), kw_end_DASH_line, int(5249), kw_end_DASH_column, int(35))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp11
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5236), kw_column, int(4), kw_end_DASH_line, int(5249), kw_end_DASH_column, int(37))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_drop)
				tmp5 := checkDerefVar(var_glojure_DOT_core_interleave)
				tmp6 := checkDerefVar(var_glojure_DOT_core_repeat)
				tmp7 := lang.Apply(tmp6, []any{v2})
				tmp8 := lang.Apply(tmp5, []any{tmp7, v3})
				tmp9 := lang.Apply(tmp4, []any{int64(1), tmp8})
				return tmp9
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_interpose = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_interpose.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// isa?
	{
		tmp0 := sym_isa_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_child, sym_parent), lang.NewVector(sym_h, sym_child, sym_parent)), kw_doc, "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a Java type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(5543), kw_end_DASH_line, int(5543))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_isa_QMARK_)
				tmp5 := checkDerefVar(var_glojure_DOT_core_global_DASH_hierarchy)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v2, v3})
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "or__0__auto__"
					tmp6 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp7 := lang.Apply(tmp6, []any{v3, v4})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp9 = v8
					} else {
						var tmp10 any
						{ // let
							// let binding "or__0__auto__"
							var tmp11 any
							{ // let
								// let binding "and__0__auto__"
								tmp12 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
								tmp13 := lang.Apply(tmp12, []any{v4})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									var tmp16 any
									{ // let
										// let binding "and__0__auto__"
										tmp17 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
										tmp18 := lang.Apply(tmp17, []any{v3})
										var v19 any = tmp18
										_ = v19
										var tmp20 any
										if lang.IsTruthy(v19) {
											tmp21, _ := lang.FieldOrMethod(v3, "AssignableTo")
											if reflect.TypeOf(tmp21).Kind() != reflect.Func {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("AssignableTo is not a function")))
											}
											tmp22 := lang.Apply(tmp21, []any{v4})
											tmp20 = tmp22
										} else {
											tmp20 = v19
										}
										tmp16 = tmp20
									} // end let
									tmp15 = tmp16
								} else {
									tmp15 = v14
								}
								tmp11 = tmp15
							} // end let
							var v12 any = tmp11
							_ = v12
							var tmp13 any
							if lang.IsTruthy(v12) {
								tmp13 = v12
							} else {
								var tmp14 any
								{ // let
									// let binding "or__0__auto__"
									tmp15 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
									tmp16 := lang.Apply(kw_ancestors, []any{v2})
									tmp17 := lang.Apply(tmp16, []any{v3})
									tmp18 := lang.Apply(tmp15, []any{tmp17, v4})
									var v19 any = tmp18
									_ = v19
									var tmp20 any
									if lang.IsTruthy(v19) {
										tmp20 = v19
									} else {
										var tmp21 any
										{ // let
											// let binding "or__0__auto__"
											var tmp22 any
											{ // let
												// let binding "and__0__auto__"
												tmp23 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
												tmp24 := lang.Apply(tmp23, []any{v3})
												var v25 any = tmp24
												_ = v25
												var tmp26 any
												if lang.IsTruthy(v25) {
													tmp27 := checkDerefVar(var_glojure_DOT_core_some)
													var tmp28 lang.FnFunc
													tmp28 = lang.NewFnFunc(func(args ...any) any {
														checkArity(args, 1)
														v29 := args[0]
														_ = v29
														tmp30 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
														tmp31 := lang.Apply(kw_ancestors, []any{v2})
														tmp32 := lang.Apply(tmp31, []any{v29})
														tmp33 := lang.Apply(tmp30, []any{tmp32, v4})
														return tmp33
													})
													tmp29 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5556), kw_column, int(34), kw_end_DASH_line, int(5556), kw_end_DASH_column, int(71))
													tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
													if err != nil {
														panic(err)
													}
													tmp31 := checkDerefVar(var_glojure_DOT_core_supers)
													tmp32 := lang.Apply(tmp31, []any{v3})
													tmp33 := lang.Apply(tmp27, []any{tmp30, tmp32})
													tmp26 = tmp33
												} else {
													tmp26 = v25
												}
												tmp22 = tmp26
											} // end let
											var v23 any = tmp22
											_ = v23
											var tmp24 any
											if lang.IsTruthy(v23) {
												tmp24 = v23
											} else {
												var tmp25 any
												{ // let
													// let binding "and__0__auto__"
													tmp26 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
													tmp27 := lang.Apply(tmp26, []any{v4})
													var v28 any = tmp27
													_ = v28
													var tmp29 any
													if lang.IsTruthy(v28) {
														var tmp30 any
														{ // let
															// let binding "and__0__auto__"
															tmp31 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
															tmp32 := lang.Apply(tmp31, []any{v3})
															var v33 any = tmp32
															_ = v33
															var tmp34 any
															if lang.IsTruthy(v33) {
																var tmp35 any
																{ // let
																	// let binding "and__0__auto__"
																	tmp36 := checkDerefVar(var_glojure_DOT_core__EQ_)
																	tmp37 := checkDerefVar(var_glojure_DOT_core_count)
																	tmp38 := lang.Apply(tmp37, []any{v4})
																	tmp39 := checkDerefVar(var_glojure_DOT_core_count)
																	tmp40 := lang.Apply(tmp39, []any{v3})
																	tmp41 := lang.Apply(tmp36, []any{tmp38, tmp40})
																	var v42 any = tmp41
																	_ = v42
																	var tmp43 any
																	if lang.IsTruthy(v42) {
																		var tmp44 any
																		{ // let
																			// let binding "ret"
																			var v45 any = true
																			_ = v45
																			// let binding "i"
																			var v46 any = int64(0)
																			_ = v46
																			for {
																				var tmp47 any
																				var tmp48 any
																				{ // let
																					// let binding "or__0__auto__"
																					tmp49 := checkDerefVar(var_glojure_DOT_core_not)
																					tmp50 := lang.Apply(tmp49, []any{v45})
																					var v51 any = tmp50
																					_ = v51
																					var tmp52 any
																					if lang.IsTruthy(v51) {
																						tmp52 = v51
																					} else {
																						tmp53 := checkDerefVar(var_glojure_DOT_core__EQ_)
																						tmp54 := checkDerefVar(var_glojure_DOT_core_count)
																						tmp55 := lang.Apply(tmp54, []any{v4})
																						tmp56 := lang.Apply(tmp53, []any{v46, tmp55})
																						tmp52 = tmp56
																					}
																					tmp48 = tmp52
																				} // end let
																				if lang.IsTruthy(tmp48) {
																					tmp47 = v45
																				} else {
																					tmp50 := checkDerefVar(var_glojure_DOT_core_isa_QMARK_)
																					tmp51 := lang.Apply(v3, []any{v46})
																					tmp52 := lang.Apply(v4, []any{v46})
																					tmp53 := lang.Apply(tmp50, []any{v2, tmp51, tmp52})
																					var tmp49 any = tmp53
																					tmp55 := checkDerefVar(var_glojure_DOT_core_inc)
																					tmp56 := lang.Apply(tmp55, []any{v46})
																					var tmp54 any = tmp56
																					v45 = tmp49
																					v46 = tmp54
																					continue
																				}
																				tmp44 = tmp47
																				break
																			}
																		} // end let
																		tmp43 = tmp44
																	} else {
																		tmp43 = v42
																	}
																	tmp35 = tmp43
																} // end let
																tmp34 = tmp35
															} else {
																tmp34 = v33
															}
															tmp30 = tmp34
														} // end let
														tmp29 = tmp30
													} else {
														tmp29 = v28
													}
													tmp25 = tmp29
												} // end let
												tmp24 = tmp25
											}
											tmp21 = tmp24
										} // end let
										tmp20 = tmp21
									}
									tmp14 = tmp20
								} // end let
								tmp13 = tmp14
							}
							tmp10 = tmp13
						} // end let
						tmp9 = tmp10
					}
					tmp5 = tmp9
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_isa_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_isa_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lazy-cat
	{
		tmp0 := sym_lazy_DASH_cat.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_colls)), kw_doc, "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(4636), kw_end_DASH_line, int(4636))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_glojure_DOT_core_SLASH_concat})
				tmp9 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v11 := args[0]
					_ = v11
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_glojure_DOT_core_SLASH_lazy_DASH_seq, v11})
					return tmp13
				})
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4644), kw_column, int(19), kw_end_DASH_line, int(4644), kw_end_DASH_column, int(37))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := lang.Apply(tmp9, []any{tmp12, v4})
				tmp14 := lang.Apply(tmp6, []any{tmp8, tmp13})
				tmp15 := lang.Apply(tmp5, []any{tmp14})
				return tmp15
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_lazy_DASH_cat = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_lazy_DASH_cat.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// letfn
	{
		tmp0 := sym_letfn.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_fnspecs, sym__AMP_, sym_body)), kw_doc, "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body.", kw_forms, lang.NewVector(lang.NewList(sym_letfn, lang.NewVector(sym_fnspecs_STAR_), sym_exprs_STAR_)), kw_url, nil, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(6545), kw_end_DASH_line, int(6545), kw_special_DASH_form, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_letfn_STAR_})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_vec)
				tmp12 := checkDerefVar(var_glojure_DOT_core_interleave)
				tmp13 := checkDerefVar(var_glojure_DOT_core_map)
				tmp14 := checkDerefVar(var_glojure_DOT_core_first)
				tmp15 := lang.Apply(tmp13, []any{tmp14, v4})
				tmp16 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp17 lang.FnFunc
				tmp17 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v18 := args[0]
					_ = v18
					tmp19 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp20 := lang.Apply(tmp19, []any{sym_glojure_DOT_core_SLASH_fn, v18})
					return tmp20
				})
				tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6555), kw_column, int(35), kw_end_DASH_line, int(6555), kw_end_DASH_column, int(47))
				tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp20 := lang.Apply(tmp16, []any{tmp19, v4})
				tmp21 := lang.Apply(tmp12, []any{tmp15, tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp10, []any{tmp22})
				tmp24 := lang.Apply(tmp7, []any{tmp9, tmp23, v5})
				tmp25 := lang.Apply(tmp6, []any{tmp24})
				return tmp25
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_letfn = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_letfn.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lift-ns
	{
		tmp0 := sym_lift_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m)), kw_doc, "Returns [lifted-ns lifted-kvs] or nil if m can't be lifted.", kw_file, "glojure/core_print.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(8), kw_line, int(261), kw_end_DASH_line, int(261), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_namespace_DASH_maps_STAR_)
			if lang.IsTruthy(tmp4) {
				var tmp5 any
				{ // let
					// let binding "ns"
					var v6 any = nil
					_ = v6
					// let binding "G__221"
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := lang.Apply(tmp7, []any{v2})
					var v9 any = tmp8
					_ = v9
					// let binding "vec__222"
					var v10 any = v9
					_ = v10
					// let binding "seq__223"
					tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp12 := lang.Apply(tmp11, []any{v10})
					var v13 any = tmp12
					_ = v13
					// let binding "first__224"
					tmp14 := checkDerefVar(var_glojure_DOT_core_first)
					tmp15 := lang.Apply(tmp14, []any{v13})
					var v16 any = tmp15
					_ = v16
					// let binding "seq__223"
					tmp17 := checkDerefVar(var_glojure_DOT_core_next)
					tmp18 := lang.Apply(tmp17, []any{v13})
					var v19 any = tmp18
					_ = v19
					// let binding "vec__225"
					var v20 any = v16
					_ = v20
					// let binding "k"
					tmp21 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp22 := lang.Apply(tmp21, []any{v20, int64(0), nil})
					var v23 any = tmp22
					_ = v23
					// let binding "v"
					tmp24 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp25 := lang.Apply(tmp24, []any{v20, int64(1), nil})
					var v26 any = tmp25
					_ = v26
					// let binding "entry"
					var v27 any = v20
					_ = v27
					// let binding "entries"
					var v28 any = v19
					_ = v28
					// let binding "kvs"
					tmp29 := lang.NewVector()
					tmp30 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(267), kw_column, int(16), kw_end_DASH_line, int(267), kw_end_DASH_column, int(17))
					tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v32 any = tmp31
					_ = v32
					var tmp33 any
					{ // let
						// let binding "ns"
						var v34 any = v6
						_ = v34
						// let binding "G__221"
						var v35 any = v9
						_ = v35
						// let binding "kvs"
						var v36 any = v32
						_ = v36
						for {
							var tmp37 any
							{ // let
								// let binding "ns"
								var v38 any = v34
								_ = v38
								// let binding "vec__228"
								var v39 any = v35
								_ = v39
								// let binding "seq__229"
								tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp41 := lang.Apply(tmp40, []any{v39})
								var v42 any = tmp41
								_ = v42
								// let binding "first__230"
								tmp43 := checkDerefVar(var_glojure_DOT_core_first)
								tmp44 := lang.Apply(tmp43, []any{v42})
								var v45 any = tmp44
								_ = v45
								// let binding "seq__229"
								tmp46 := checkDerefVar(var_glojure_DOT_core_next)
								tmp47 := lang.Apply(tmp46, []any{v42})
								var v48 any = tmp47
								_ = v48
								// let binding "vec__231"
								var v49 any = v45
								_ = v49
								// let binding "k"
								tmp50 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp51 := lang.Apply(tmp50, []any{v49, int64(0), nil})
								var v52 any = tmp51
								_ = v52
								// let binding "v"
								tmp53 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp54 := lang.Apply(tmp53, []any{v49, int64(1), nil})
								var v55 any = tmp54
								_ = v55
								// let binding "entry"
								var v56 any = v49
								_ = v56
								// let binding "entries"
								var v57 any = v48
								_ = v57
								// let binding "kvs"
								var v58 any = v36
								_ = v58
								var tmp59 any
								if lang.IsTruthy(v56) {
									var tmp60 any
									tmp61 := checkDerefVar(var_glojure_DOT_core_qualified_DASH_ident_QMARK_)
									tmp62 := lang.Apply(tmp61, []any{v52})
									if lang.IsTruthy(tmp62) {
										var tmp63 any
										if lang.IsTruthy(v38) {
											var tmp64 any
											tmp65 := checkDerefVar(var_glojure_DOT_core__EQ_)
											tmp66 := checkDerefVar(var_glojure_DOT_core_namespace)
											tmp67 := lang.Apply(tmp66, []any{v52})
											tmp68 := lang.Apply(tmp65, []any{v38, tmp67})
											if lang.IsTruthy(tmp68) {
												var tmp69 any = v38
												var tmp70 any = v57
												tmp72 := checkDerefVar(var_glojure_DOT_core_conj)
												tmp73 := checkDerefVar(var_glojure_DOT_core_strip_DASH_ns)
												tmp74 := lang.Apply(tmp73, []any{v52})
												tmp75 := lang.NewVector(tmp74, v55)
												tmp76 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(272), kw_column, int(43), kw_end_DASH_line, int(272), kw_end_DASH_column, int(58))
												tmp77, err := lang.WithMeta(tmp75, tmp76.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp78 := lang.Apply(tmp72, []any{v58, tmp77})
												var tmp71 any = tmp78
												v34 = tmp69
												v35 = tmp70
												v36 = tmp71
												continue
											} else {
											}
											tmp63 = tmp64
										} else {
											var tmp79 any
											{ // let
												// let binding "temp__0__auto__"
												tmp80 := checkDerefVar(var_glojure_DOT_core_namespace)
												tmp81 := lang.Apply(tmp80, []any{v52})
												var v82 any = tmp81
												_ = v82
												var tmp83 any
												if lang.IsTruthy(v82) {
													var tmp84 any
													{ // let
														// let binding "new-ns"
														var v85 any = v82
														_ = v85
														var tmp86 any = v85
														var tmp87 any = v57
														tmp89 := checkDerefVar(var_glojure_DOT_core_conj)
														tmp90 := checkDerefVar(var_glojure_DOT_core_strip_DASH_ns)
														tmp91 := lang.Apply(tmp90, []any{v52})
														tmp92 := lang.NewVector(tmp91, v55)
														tmp93 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(274), kw_column, int(47), kw_end_DASH_line, int(274), kw_end_DASH_column, int(62))
														tmp94, err := lang.WithMeta(tmp92, tmp93.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp95 := lang.Apply(tmp89, []any{v58, tmp94})
														var tmp88 any = tmp95
														v34 = tmp86
														v35 = tmp87
														v36 = tmp88
														continue
													} // end let
													tmp83 = tmp84
												} else {
												}
												tmp79 = tmp83
											} // end let
											tmp63 = tmp79
										}
										tmp60 = tmp63
									} else {
									}
									tmp59 = tmp60
								} else {
									tmp80 := lang.NewVector(v38, v58)
									tmp81 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(275), kw_column, int(9), kw_end_DASH_line, int(275), kw_end_DASH_column, int(16))
									tmp82, err := lang.WithMeta(tmp80, tmp81.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp59 = tmp82
								}
								tmp37 = tmp59
							} // end let
							tmp33 = tmp37
							break
						}
					} // end let
					tmp5 = tmp33
				} // end let
				tmp3 = tmp5
			} else {
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_lift_DASH_ns = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_lift_DASH_ns.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-array
	{
		tmp0 := sym_make_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_type, sym_len), lang.NewVector(sym_type, sym_dim, sym__AMP_, sym_more_DASH_dims)), kw_doc, "Creates and returns an array of instances of the specified class of\n  the specified dimension(s).  Note that a class object is required.\n  Class objects can be obtained by using their imported or\n  fully-qualified name.  Class objects for the primitive types can be\n  obtained using, e.g., Integer/TYPE.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(3985), kw_end_DASH_line, int(3985))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_int)
				tmp5 := lang.Apply(tmp4, []any{v3})
				tmp6, _ := lang.FieldOrMethod(nil, "newInstance")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("newInstance is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v2, tmp5})
				return tmp7
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "dims"
					tmp6 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp7 := lang.Apply(tmp6, []any{v3, v4})
					var v8 any = tmp7
					_ = v8
					// let binding "dimarray"
					tmp9 := checkDerefVar(var_glojure_DOT_core_make_DASH_array)
					tmp10, ok := lang.FieldOrMethod(nil, "TYPE")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "TYPE")))
					}
					var tmp11 any
					switch reflect.TypeOf(tmp10).Kind() {
					case reflect.Func:
						tmp11 = lang.Apply(tmp10, nil)
					default:
						tmp11 = tmp10
					}
					tmp12 := checkDerefVar(var_glojure_DOT_core_count)
					tmp13 := lang.Apply(tmp12, []any{v8})
					tmp14 := lang.Apply(tmp9, []any{tmp11, tmp13})
					var v15 any = tmp14
					_ = v15
					var tmp16 any
					{ // let
						// let binding "n__0__auto__"
						tmp17 := checkDerefVar(var_glojure_DOT_core_long)
						tmp18 := checkDerefVar(var_glojure_DOT_core_alength)
						tmp19 := lang.Apply(tmp18, []any{v15})
						tmp20 := lang.Apply(tmp17, []any{tmp19})
						var v21 any = tmp20
						_ = v21
						var tmp22 any
						{ // let
							// let binding "i"
							var v23 any = int64(0)
							_ = v23
							for {
								var tmp24 any
								tmp25 := checkDerefVar(var_glojure_DOT_core__LT_)
								tmp26 := lang.Apply(tmp25, []any{v23, v21})
								if lang.IsTruthy(tmp26) {
									tmp27 := checkDerefVar(var_glojure_DOT_core_aset_DASH_int)
									tmp28 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp29 := lang.Apply(tmp28, []any{v8, v23})
									tmp30 := lang.Apply(tmp27, []any{v15, v23, tmp29})
									_ = tmp30
									tmp32 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
									tmp33 := lang.Apply(tmp32, []any{v23})
									var tmp31 any = tmp33
									v23 = tmp31
									continue
								} else {
								}
								tmp22 = tmp24
								break
							}
						} // end let
						tmp16 = tmp22
					} // end let
					_ = tmp16
					tmp17, _ := lang.FieldOrMethod(nil, "newInstance")
					if reflect.TypeOf(tmp17).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("newInstance is not a function")))
					}
					tmp18 := lang.Apply(tmp17, []any{v2, v15})
					tmp5 = tmp18
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_make_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_make_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// maybe-min-hash
	{
		tmp0 := sym_maybe_DASH_min_DASH_hash.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_hashes)), kw_doc, "takes a collection of hashes and returns [shift mask] or nil if none found", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(8), kw_line, int(6604), kw_end_DASH_line, int(6604), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_first)
			tmp4 := checkDerefVar(var_glojure_DOT_core_filter)
			var tmp5 lang.FnFunc
			tmp5 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v6 := args[0]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "vec__151"
					var v8 any = v6
					_ = v8
					// let binding "s"
					tmp9 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp10 := lang.Apply(tmp9, []any{v8, int64(0), nil})
					var v11 any = tmp10
					_ = v11
					// let binding "m"
					tmp12 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp13 := lang.Apply(tmp12, []any{v8, int64(1), nil})
					var v14 any = tmp13
					_ = v14
					tmp15 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp16 := checkDerefVar(var_glojure_DOT_core_distinct_QMARK_)
					tmp17 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp18 lang.FnFunc
					tmp18 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v19 := args[0]
						_ = v19
						tmp20 := checkDerefVar(var_glojure_DOT_core_shift_DASH_mask)
						tmp21 := lang.Apply(tmp20, []any{v11, v14, v19})
						return tmp21
					})
					tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6609), kw_column, int(37), kw_end_DASH_line, int(6609), kw_end_DASH_column, int(55))
					tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp21 := lang.Apply(tmp17, []any{tmp20, v2})
					tmp22 := lang.Apply(tmp15, []any{tmp16, tmp21})
					tmp7 = tmp22
				} // end let
				return tmp7
			})
			tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6608), kw_column, int(13), kw_end_DASH_line, int(6609), kw_end_DASH_column, int(65))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp8 any
			{ // let
				// let binding "iter__0__auto__"
				var tmp9 lang.FnFunc
				{ // function iter__154
					var v10 lang.FnFunc
					tmp9 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v11 := args[0]
						_ = v11
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							var tmp13 any
							{ // let
								// let binding "s__155"
								var v14 any = v11
								_ = v14
								for {
									var tmp15 any
									{ // let
										// let binding "temp__0__auto__"
										tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp17 := lang.Apply(tmp16, []any{v14})
										var v18 any = tmp17
										_ = v18
										var tmp19 any
										if lang.IsTruthy(v18) {
											var tmp20 any
											{ // let
												// let binding "xs__0__auto__"
												var v21 any = v18
												_ = v21
												var tmp22 any
												{ // let
													// let binding "mask"
													tmp23 := checkDerefVar(var_glojure_DOT_core_first)
													tmp24 := lang.Apply(tmp23, []any{v21})
													var v25 any = tmp24
													_ = v25
													var tmp26 any
													{ // let
														// let binding "iterys__0__auto__"
														var tmp27 lang.FnFunc
														{ // function iter__156
															var v28 lang.FnFunc
															tmp27 = lang.NewFnFunc(func(args ...any) any {
																checkArity(args, 1)
																v29 := args[0]
																_ = v29
																var tmp30 lang.FnFunc
																tmp30 = lang.NewFnFunc(func(args ...any) any {
																	checkArity(args, 0)
																	var tmp31 any
																	{ // let
																		// let binding "s__157"
																		var v32 any = v29
																		_ = v32
																		for {
																			var tmp33 any
																			{ // let
																				// let binding "temp__0__auto__"
																				tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
																				tmp35 := lang.Apply(tmp34, []any{v32})
																				var v36 any = tmp35
																				_ = v36
																				var tmp37 any
																				if lang.IsTruthy(v36) {
																					var tmp38 any
																					{ // let
																						// let binding "s__157"
																						var v39 any = v36
																						_ = v39
																						var tmp40 any
																						tmp41 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
																						tmp42 := lang.Apply(tmp41, []any{v39})
																						if lang.IsTruthy(tmp42) {
																							var tmp43 any
																							{ // let
																								// let binding "c__0__auto__"
																								tmp44 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																								tmp45 := lang.Apply(tmp44, []any{v39})
																								var v46 any = tmp45
																								_ = v46
																								// let binding "size__1__auto__"
																								tmp47 := checkDerefVar(var_glojure_DOT_core_int)
																								tmp48 := checkDerefVar(var_glojure_DOT_core_count)
																								tmp49 := lang.Apply(tmp48, []any{v46})
																								tmp50 := lang.Apply(tmp47, []any{tmp49})
																								var v51 any = tmp50
																								_ = v51
																								// let binding "b__159"
																								tmp52 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_buffer)
																								tmp53 := lang.Apply(tmp52, []any{v51})
																								var v54 any = tmp53
																								_ = v54
																								var tmp55 any
																								var tmp56 any
																								{ // let
																									// let binding "i__158"
																									tmp57 := checkDerefVar(var_glojure_DOT_core_int)
																									tmp58 := lang.Apply(tmp57, []any{int64(0)})
																									var v59 any = tmp58
																									_ = v59
																									for {
																										var tmp60 any
																										tmp61 := checkDerefVar(var_glojure_DOT_core__LT_)
																										tmp62 := lang.Apply(tmp61, []any{v59, v51})
																										if lang.IsTruthy(tmp62) {
																											var tmp63 any
																											{ // let
																												// let binding "shift"
																												tmp64, _ := lang.FieldOrMethod(v46, "nth")
																												if reflect.TypeOf(tmp64).Kind() != reflect.Func {
																													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
																												}
																												tmp65 := lang.Apply(tmp64, []any{v59})
																												var v66 any = tmp65
																												_ = v66
																												tmp67 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_append)
																												tmp68 := lang.NewVector(v66, v25)
																												tmp69 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6612), kw_column, int(15), kw_end_DASH_line, int(6612), kw_end_DASH_column, int(26))
																												tmp70, err := lang.WithMeta(tmp68, tmp69.(lang.IPersistentMap))
																												if err != nil {
																													panic(err)
																												}
																												tmp71 := lang.Apply(tmp67, []any{v54, tmp70})
																												_ = tmp71
																												tmp73 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
																												tmp74 := lang.Apply(tmp73, []any{v59})
																												var tmp72 any = tmp74
																												v59 = tmp72
																												continue
																											} // end let
																											tmp60 = tmp63
																										} else {
																											tmp60 = true
																										}
																										tmp56 = tmp60
																										break
																									}
																								} // end let
																								if lang.IsTruthy(tmp56) {
																									tmp57 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
																									tmp58 := checkDerefVar(var_glojure_DOT_core_chunk)
																									tmp59 := lang.Apply(tmp58, []any{v54})
																									tmp60 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																									tmp61 := lang.Apply(tmp60, []any{v39})
																									tmp62 := lang.Apply(v28, []any{tmp61})
																									tmp63 := lang.Apply(tmp57, []any{tmp59, tmp62})
																									tmp55 = tmp63
																								} else {
																									tmp64 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
																									tmp65 := checkDerefVar(var_glojure_DOT_core_chunk)
																									tmp66 := lang.Apply(tmp65, []any{v54})
																									tmp67 := lang.Apply(tmp64, []any{tmp66, nil})
																									tmp55 = tmp67
																								}
																								tmp43 = tmp55
																							} // end let
																							tmp40 = tmp43
																						} else {
																							var tmp44 any
																							{ // let
																								// let binding "shift"
																								tmp45 := checkDerefVar(var_glojure_DOT_core_first)
																								tmp46 := lang.Apply(tmp45, []any{v39})
																								var v47 any = tmp46
																								_ = v47
																								tmp48 := checkDerefVar(var_glojure_DOT_core_cons)
																								tmp49 := lang.NewVector(v47, v25)
																								tmp50 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6612), kw_column, int(15), kw_end_DASH_line, int(6612), kw_end_DASH_column, int(26))
																								tmp51, err := lang.WithMeta(tmp49, tmp50.(lang.IPersistentMap))
																								if err != nil {
																									panic(err)
																								}
																								tmp52 := checkDerefVar(var_glojure_DOT_core_rest)
																								tmp53 := lang.Apply(tmp52, []any{v39})
																								tmp54 := lang.Apply(v28, []any{tmp53})
																								tmp55 := lang.Apply(tmp48, []any{tmp51, tmp54})
																								tmp44 = tmp55
																							} // end let
																							tmp40 = tmp44
																						}
																						tmp38 = tmp40
																					} // end let
																					tmp37 = tmp38
																				} else {
																				}
																				tmp33 = tmp37
																			} // end let
																			tmp31 = tmp33
																			break
																		}
																	} // end let
																	return tmp31
																})
																tmp31 := lang.Apply(lang.NewLazySeq, []any{tmp30})
																return tmp31
															})
															v28 = tmp27
															_ = v28
														}
														var v28 any = tmp27
														_ = v28
														// let binding "fs__1__auto__"
														tmp29 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp30 := checkDerefVar(var_glojure_DOT_core_range)
														tmp31 := lang.Apply(tmp30, []any{int64(0), int64(31)})
														tmp32 := lang.Apply(v28, []any{tmp31})
														tmp33 := lang.Apply(tmp29, []any{tmp32})
														var v34 any = tmp33
														_ = v34
														var tmp35 any
														if lang.IsTruthy(v34) {
															tmp36 := checkDerefVar(var_glojure_DOT_core_concat)
															tmp37 := checkDerefVar(var_glojure_DOT_core_rest)
															tmp38 := lang.Apply(tmp37, []any{v14})
															tmp39 := lang.Apply(v10, []any{tmp38})
															tmp40 := lang.Apply(tmp36, []any{v34, tmp39})
															tmp35 = tmp40
														} else {
															tmp42 := checkDerefVar(var_glojure_DOT_core_rest)
															tmp43 := lang.Apply(tmp42, []any{v14})
															var tmp41 any = tmp43
															v14 = tmp41
															continue
														}
														tmp26 = tmp35
													} // end let
													tmp22 = tmp26
												} // end let
												tmp20 = tmp22
											} // end let
											tmp19 = tmp20
										} else {
										}
										tmp15 = tmp19
									} // end let
									tmp13 = tmp15
									break
								}
							} // end let
							return tmp13
						})
						tmp13 := lang.Apply(lang.NewLazySeq, []any{tmp12})
						return tmp13
					})
					v10 = tmp9
					_ = v10
				}
				var v10 any = tmp9
				_ = v10
				tmp11 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp12 lang.FnFunc
				tmp12 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v13 := args[0]
					_ = v13
					tmp14 := checkDerefVar(var_glojure_DOT_core_dec)
					tmp15 := checkDerefVar(var_glojure_DOT_core_bit_DASH_shift_DASH_left)
					tmp16 := lang.Apply(tmp15, []any{int64(1), v13})
					tmp17 := lang.Apply(tmp14, []any{tmp16})
					return tmp17
				})
				tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6610), kw_column, int(29), kw_end_DASH_line, int(6610), kw_end_DASH_column, int(55))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp15 := checkDerefVar(var_glojure_DOT_core_range)
				tmp16 := checkDerefVar(var_glojure_DOT_core_inc)
				tmp17 := checkDerefVar(var_glojure_DOT_core_max_DASH_mask_DASH_bits)
				tmp18 := lang.Apply(tmp16, []any{tmp17})
				tmp19 := lang.Apply(tmp15, []any{int64(1), tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp14, tmp19})
				tmp21 := lang.Apply(v10, []any{tmp20})
				tmp8 = tmp21
			} // end let
			tmp9 := lang.Apply(tmp4, []any{tmp7, tmp8})
			tmp10 := lang.Apply(tmp3, []any{tmp9})
			return tmp10
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_maybe_DASH_min_DASH_hash = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_maybe_DASH_min_DASH_hash.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// memoize
	{
		tmp0 := sym_memoize.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6337), kw_end_DASH_line, int(6337))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "mem"
				tmp4 := checkDerefVar(var_glojure_DOT_core_atom)
				tmp5 := lang.NewMap()
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6345), kw_column, int(19), kw_end_DASH_line, int(6345), kw_end_DASH_column, int(20))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7})
				var v9 any = tmp8
				_ = v9
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						checkArityGTE(args, 0)
						var v11 any = lang.NewList(args[0:]...)
						_ = v11
						var tmp12 any
						{ // let
							// let binding "temp__0__auto__"
							tmp13 := checkDerefVar(var_glojure_DOT_core_find)
							tmp14 := checkDerefVar(var_glojure_DOT_core_deref)
							tmp15 := lang.Apply(tmp14, []any{v9})
							tmp16 := lang.Apply(tmp13, []any{tmp15, v11})
							var v17 any = tmp16
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								var tmp19 any
								{ // let
									// let binding "e"
									var v20 any = v17
									_ = v20
									tmp21 := checkDerefVar(var_glojure_DOT_core_val)
									tmp22 := lang.Apply(tmp21, []any{v20})
									tmp19 = tmp22
								} // end let
								tmp18 = tmp19
							} else {
								var tmp20 any
								{ // let
									// let binding "ret"
									tmp21 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp22 := lang.Apply(tmp21, []any{v2, v11})
									var v23 any = tmp22
									_ = v23
									tmp24 := checkDerefVar(var_glojure_DOT_core_swap_BANG_)
									tmp25 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp26 := lang.Apply(tmp24, []any{v9, tmp25, v11, v23})
									_ = tmp26
									tmp20 = v23
								} // end let
								tmp18 = tmp20
							}
							tmp12 = tmp18
						} // end let
						return tmp12
					}
				})
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6346), kw_column, int(5), kw_end_DASH_line, int(6351), kw_end_DASH_column, int(16))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_memoize = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_memoize.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns
	{
		tmp0 := sym_ns.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_docstring_QMARK_, sym_attr_DASH_map_QMARK_, sym_references_STAR_)), kw_doc, "Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-glojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-glojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-glojure is not used, a\n  default (refer 'glojure.core) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-glojure :exclude [ancestors printf])\n    (:require (glojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(5742), kw_end_DASH_line, int(5742))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "process-reference"
					var tmp7 lang.FnFunc
					tmp7 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v8 := args[0]
						_ = v8
						var tmp9 any
						{ // let
							// let binding "vec__107"
							var v10 any = v8
							_ = v10
							// let binding "seq__108"
							tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp12 := lang.Apply(tmp11, []any{v10})
							var v13 any = tmp12
							_ = v13
							// let binding "first__109"
							tmp14 := checkDerefVar(var_glojure_DOT_core_first)
							tmp15 := lang.Apply(tmp14, []any{v13})
							var v16 any = tmp15
							_ = v16
							// let binding "seq__108"
							tmp17 := checkDerefVar(var_glojure_DOT_core_next)
							tmp18 := lang.Apply(tmp17, []any{v13})
							var v19 any = tmp18
							_ = v19
							// let binding "kname"
							var v20 any = v16
							_ = v20
							// let binding "args"
							var v21 any = v19
							_ = v21
							tmp22 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp23 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp24 := checkDerefVar(var_glojure_DOT_core_list)
							tmp25 := checkDerefVar(var_glojure_DOT_core_symbol)
							tmp26 := checkDerefVar(var_glojure_DOT_core_name)
							tmp27 := lang.Apply(tmp26, []any{v20})
							tmp28 := lang.Apply(tmp25, []any{"glojure.core", tmp27})
							tmp29 := lang.Apply(tmp24, []any{tmp28})
							tmp30 := checkDerefVar(var_glojure_DOT_core_map)
							var tmp31 lang.FnFunc
							tmp31 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v32 := args[0]
								_ = v32
								tmp33 := checkDerefVar(var_glojure_DOT_core_list)
								tmp34 := lang.Apply(tmp33, []any{sym_quote, v32})
								return tmp34
							})
							tmp32 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5769), kw_column, int(21), kw_end_DASH_line, int(5769), kw_end_DASH_column, int(36))
							tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp34 := lang.Apply(tmp30, []any{tmp33, v21})
							tmp35 := lang.Apply(tmp23, []any{tmp29, tmp34})
							tmp36 := lang.Apply(tmp22, []any{tmp35})
							tmp9 = tmp36
						} // end let
						return tmp9
					})
					tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5767), kw_column, int(9), kw_end_DASH_line, int(5769), kw_end_DASH_column, int(44))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v10 any = tmp9
					_ = v10
					// let binding "docstring"
					var tmp11 any
					tmp12 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_first)
					tmp14 := lang.Apply(tmp13, []any{v5})
					tmp15 := lang.Apply(tmp12, []any{tmp14})
					if lang.IsTruthy(tmp15) {
						tmp16 := checkDerefVar(var_glojure_DOT_core_first)
						tmp17 := lang.Apply(tmp16, []any{v5})
						tmp11 = tmp17
					} else {
					}
					var v18 any = tmp11
					_ = v18
					// let binding "references"
					var tmp19 any
					if lang.IsTruthy(v18) {
						tmp20 := checkDerefVar(var_glojure_DOT_core_next)
						tmp21 := lang.Apply(tmp20, []any{v5})
						tmp19 = tmp21
					} else {
						tmp19 = v5
					}
					var v22 any = tmp19
					_ = v22
					// let binding "name"
					var tmp23 any
					if lang.IsTruthy(v18) {
						tmp24 := checkDerefVar(var_glojure_DOT_core_vary_DASH_meta)
						tmp25 := checkDerefVar(var_glojure_DOT_core_assoc)
						tmp26 := lang.Apply(tmp24, []any{v4, tmp25, kw_doc, v18})
						tmp23 = tmp26
					} else {
						tmp23 = v4
					}
					var v27 any = tmp23
					_ = v27
					// let binding "metadata"
					var tmp28 any
					tmp29 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
					tmp30 := checkDerefVar(var_glojure_DOT_core_first)
					tmp31 := lang.Apply(tmp30, []any{v22})
					tmp32 := lang.Apply(tmp29, []any{tmp31})
					if lang.IsTruthy(tmp32) {
						tmp33 := checkDerefVar(var_glojure_DOT_core_first)
						tmp34 := lang.Apply(tmp33, []any{v22})
						tmp28 = tmp34
					} else {
					}
					var v35 any = tmp28
					_ = v35
					// let binding "references"
					var tmp36 any
					if lang.IsTruthy(v35) {
						tmp37 := checkDerefVar(var_glojure_DOT_core_next)
						tmp38 := lang.Apply(tmp37, []any{v22})
						tmp36 = tmp38
					} else {
						tmp36 = v22
					}
					var v39 any = tmp36
					_ = v39
					// let binding "name"
					var tmp40 any
					if lang.IsTruthy(v35) {
						tmp41 := checkDerefVar(var_glojure_DOT_core_vary_DASH_meta)
						tmp42 := checkDerefVar(var_glojure_DOT_core_merge)
						tmp43 := lang.Apply(tmp41, []any{v27, tmp42, v35})
						tmp40 = tmp43
					} else {
						tmp40 = v27
					}
					var v44 any = tmp40
					_ = v44
					// let binding "gen-class-clause"
					tmp45 := checkDerefVar(var_glojure_DOT_core_first)
					tmp46 := checkDerefVar(var_glojure_DOT_core_filter)
					var tmp47 lang.FnFunc
					tmp47 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v48 := args[0]
						_ = v48
						tmp49 := checkDerefVar(var_glojure_DOT_core__EQ_)
						tmp50 := checkDerefVar(var_glojure_DOT_core_first)
						tmp51 := lang.Apply(tmp50, []any{v48})
						tmp52 := lang.Apply(tmp49, []any{kw_gen_DASH_class, tmp51})
						return tmp52
					})
					tmp48 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5780), kw_column, int(41), kw_end_DASH_line, int(5780), kw_end_DASH_column, int(65))
					tmp49, err := lang.WithMeta(tmp47, tmp48.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp50 := lang.Apply(tmp46, []any{tmp49, v39})
					tmp51 := lang.Apply(tmp45, []any{tmp50})
					var v52 any = tmp51
					_ = v52
					// let binding "gen-class-call"
					var tmp53 any
					if lang.IsTruthy(v52) {
						tmp54 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
						tmp55 := checkDerefVar(var_glojure_DOT_core_str)
						tmp56 := lang.Apply(tmp55, []any{v44})
						tmp57, _ := lang.FieldOrMethod(tmp56, "replace")
						if reflect.TypeOf(tmp57).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("replace is not a function")))
						}
						tmp58 := lang.Apply(tmp57, []any{lang.NewChar(45), lang.NewChar(95)})
						tmp59 := checkDerefVar(var_glojure_DOT_core_next)
						tmp60 := lang.Apply(tmp59, []any{v52})
						tmp61 := lang.Apply(tmp54, []any{sym_glojure_DOT_core_SLASH_gen_DASH_class, kw_name, tmp58, kw_impl_DASH_ns, v44, kw_main, true, tmp60})
						tmp53 = tmp61
					} else {
					}
					var v62 any = tmp53
					_ = v62
					// let binding "references"
					tmp63 := checkDerefVar(var_glojure_DOT_core_remove)
					var tmp64 lang.FnFunc
					tmp64 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v65 := args[0]
						_ = v65
						tmp66 := checkDerefVar(var_glojure_DOT_core__EQ_)
						tmp67 := checkDerefVar(var_glojure_DOT_core_first)
						tmp68 := lang.Apply(tmp67, []any{v65})
						tmp69 := lang.Apply(tmp66, []any{kw_gen_DASH_class, tmp68})
						return tmp69
					})
					tmp65 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5784), kw_column, int(28), kw_end_DASH_line, int(5784), kw_end_DASH_column, int(52))
					tmp66, err := lang.WithMeta(tmp64, tmp65.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp67 := lang.Apply(tmp63, []any{tmp66, v39})
					var v68 any = tmp67
					_ = v68
					// let binding "name-metadata"
					tmp69 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp70 := lang.Apply(tmp69, []any{v44})
					var v71 any = tmp70
					_ = v71
					tmp72 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp73 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp74 := checkDerefVar(var_glojure_DOT_core_list)
					tmp75 := lang.Apply(tmp74, []any{sym_do})
					tmp76 := checkDerefVar(var_glojure_DOT_core_list)
					tmp77 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp78 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp79 := checkDerefVar(var_glojure_DOT_core_list)
					tmp80 := lang.Apply(tmp79, []any{sym_glojure_DOT_core_SLASH_in_DASH_ns})
					tmp81 := checkDerefVar(var_glojure_DOT_core_list)
					tmp82 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp83 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp84 := checkDerefVar(var_glojure_DOT_core_list)
					tmp85 := lang.Apply(tmp84, []any{sym_quote})
					tmp86 := checkDerefVar(var_glojure_DOT_core_list)
					tmp87 := lang.Apply(tmp86, []any{v44})
					tmp88 := lang.Apply(tmp83, []any{tmp85, tmp87})
					tmp89 := lang.Apply(tmp82, []any{tmp88})
					tmp90 := lang.Apply(tmp81, []any{tmp89})
					tmp91 := lang.Apply(tmp78, []any{tmp80, tmp90})
					tmp92 := lang.Apply(tmp77, []any{tmp91})
					tmp93 := lang.Apply(tmp76, []any{tmp92})
					var tmp94 any
					if lang.IsTruthy(v71) {
						tmp95 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp96 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp97 := checkDerefVar(var_glojure_DOT_core_list)
						tmp98 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp99 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp100 := checkDerefVar(var_glojure_DOT_core_list)
						tmp101 := lang.Apply(tmp100, []any{sym__DOT_ResetMeta})
						tmp102 := checkDerefVar(var_glojure_DOT_core_list)
						tmp103 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp104 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp105 := checkDerefVar(var_glojure_DOT_core_list)
						tmp106 := lang.Apply(tmp105, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_FindNamespace})
						tmp107 := checkDerefVar(var_glojure_DOT_core_list)
						tmp108 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp109 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp110 := checkDerefVar(var_glojure_DOT_core_list)
						tmp111 := lang.Apply(tmp110, []any{sym_quote})
						tmp112 := checkDerefVar(var_glojure_DOT_core_list)
						tmp113 := lang.Apply(tmp112, []any{v44})
						tmp114 := lang.Apply(tmp109, []any{tmp111, tmp113})
						tmp115 := lang.Apply(tmp108, []any{tmp114})
						tmp116 := lang.Apply(tmp107, []any{tmp115})
						tmp117 := lang.Apply(tmp104, []any{tmp106, tmp116})
						tmp118 := lang.Apply(tmp103, []any{tmp117})
						tmp119 := lang.Apply(tmp102, []any{tmp118})
						tmp120 := checkDerefVar(var_glojure_DOT_core_list)
						tmp121 := lang.Apply(tmp120, []any{v71})
						tmp122 := lang.Apply(tmp99, []any{tmp101, tmp119, tmp121})
						tmp123 := lang.Apply(tmp98, []any{tmp122})
						tmp124 := lang.Apply(tmp97, []any{tmp123})
						tmp125 := lang.Apply(tmp96, []any{tmp124})
						tmp126 := lang.Apply(tmp95, []any{tmp125})
						tmp94 = tmp126
					} else {
					}
					tmp127 := checkDerefVar(var_glojure_DOT_core_list)
					tmp128 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp129 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp130 := checkDerefVar(var_glojure_DOT_core_list)
					tmp131 := lang.Apply(tmp130, []any{sym_glojure_DOT_core_SLASH_with_DASH_loading_DASH_context})
					var tmp132 any
					if lang.IsTruthy(v62) {
						tmp133 := checkDerefVar(var_glojure_DOT_core_list)
						tmp134 := lang.Apply(tmp133, []any{v62})
						tmp132 = tmp134
					} else {
					}
					var tmp135 any
					var tmp136 any
					{ // let
						// let binding "and__0__auto__"
						tmp137 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
						tmp138 := lang.Apply(tmp137, []any{v44, sym_glojure_DOT_core})
						var v139 any = tmp138
						_ = v139
						var tmp140 any
						if lang.IsTruthy(v139) {
							tmp141 := checkDerefVar(var_glojure_DOT_core_not_DASH_any_QMARK_)
							var tmp142 lang.FnFunc
							tmp142 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v143 := args[0]
								_ = v143
								tmp144 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp145 := checkDerefVar(var_glojure_DOT_core_first)
								tmp146 := lang.Apply(tmp145, []any{v143})
								tmp147 := lang.Apply(tmp144, []any{kw_refer_DASH_glojure, tmp146})
								return tmp147
							})
							tmp143 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5793), kw_column, int(58), kw_end_DASH_line, int(5793), kw_end_DASH_column, int(86))
							tmp144, err := lang.WithMeta(tmp142, tmp143.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp145 := lang.Apply(tmp141, []any{tmp144, v68})
							tmp140 = tmp145
						} else {
							tmp140 = v139
						}
						tmp136 = tmp140
					} // end let
					if lang.IsTruthy(tmp136) {
						tmp137 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp138 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp139 := checkDerefVar(var_glojure_DOT_core_list)
						tmp140 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp141 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp142 := checkDerefVar(var_glojure_DOT_core_list)
						tmp143 := lang.Apply(tmp142, []any{sym_glojure_DOT_core_SLASH_refer})
						tmp144 := checkDerefVar(var_glojure_DOT_core_list)
						tmp145 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp146 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp147 := checkDerefVar(var_glojure_DOT_core_list)
						tmp148 := lang.Apply(tmp147, []any{sym_quote})
						tmp149 := checkDerefVar(var_glojure_DOT_core_list)
						tmp150 := lang.Apply(tmp149, []any{sym_glojure_DOT_core})
						tmp151 := lang.Apply(tmp146, []any{tmp148, tmp150})
						tmp152 := lang.Apply(tmp145, []any{tmp151})
						tmp153 := lang.Apply(tmp144, []any{tmp152})
						tmp154 := lang.Apply(tmp141, []any{tmp143, tmp153})
						tmp155 := lang.Apply(tmp140, []any{tmp154})
						tmp156 := lang.Apply(tmp139, []any{tmp155})
						tmp157 := lang.Apply(tmp138, []any{tmp156})
						tmp158 := lang.Apply(tmp137, []any{tmp157})
						tmp135 = tmp158
					} else {
					}
					tmp159 := checkDerefVar(var_glojure_DOT_core_map)
					tmp160 := lang.Apply(tmp159, []any{v10, v68})
					tmp161 := lang.Apply(tmp129, []any{tmp131, tmp132, tmp135, tmp160})
					tmp162 := lang.Apply(tmp128, []any{tmp161})
					tmp163 := lang.Apply(tmp127, []any{tmp162})
					tmp164 := checkDerefVar(var_glojure_DOT_core_list)
					tmp165 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp166 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp167 := checkDerefVar(var_glojure_DOT_core_list)
					tmp168 := lang.Apply(tmp167, []any{sym_if})
					tmp169 := checkDerefVar(var_glojure_DOT_core_list)
					tmp170 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp171 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp172 := checkDerefVar(var_glojure_DOT_core_list)
					tmp173 := lang.Apply(tmp172, []any{sym__DOT_Equals})
					tmp174 := checkDerefVar(var_glojure_DOT_core_list)
					tmp175 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp176 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp177 := checkDerefVar(var_glojure_DOT_core_list)
					tmp178 := lang.Apply(tmp177, []any{sym_quote})
					tmp179 := checkDerefVar(var_glojure_DOT_core_list)
					tmp180 := lang.Apply(tmp179, []any{v44})
					tmp181 := lang.Apply(tmp176, []any{tmp178, tmp180})
					tmp182 := lang.Apply(tmp175, []any{tmp181})
					tmp183 := lang.Apply(tmp174, []any{tmp182})
					tmp184 := checkDerefVar(var_glojure_DOT_core_list)
					tmp185 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp186 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp187 := checkDerefVar(var_glojure_DOT_core_list)
					tmp188 := lang.Apply(tmp187, []any{sym_quote})
					tmp189 := checkDerefVar(var_glojure_DOT_core_list)
					tmp190 := lang.Apply(tmp189, []any{sym_glojure_DOT_core})
					tmp191 := lang.Apply(tmp186, []any{tmp188, tmp190})
					tmp192 := lang.Apply(tmp185, []any{tmp191})
					tmp193 := lang.Apply(tmp184, []any{tmp192})
					tmp194 := lang.Apply(tmp171, []any{tmp173, tmp183, tmp193})
					tmp195 := lang.Apply(tmp170, []any{tmp194})
					tmp196 := lang.Apply(tmp169, []any{tmp195})
					tmp197 := checkDerefVar(var_glojure_DOT_core_list)
					tmp198 := lang.Apply(tmp197, []any{nil})
					tmp199 := checkDerefVar(var_glojure_DOT_core_list)
					tmp200 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp201 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp202 := checkDerefVar(var_glojure_DOT_core_list)
					tmp203 := lang.Apply(tmp202, []any{sym_do})
					tmp204 := checkDerefVar(var_glojure_DOT_core_list)
					tmp205 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp206 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp207 := checkDerefVar(var_glojure_DOT_core_list)
					tmp208 := lang.Apply(tmp207, []any{sym_glojure_DOT_core_SLASH_dosync})
					tmp209 := checkDerefVar(var_glojure_DOT_core_list)
					tmp210 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp211 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp212 := checkDerefVar(var_glojure_DOT_core_list)
					tmp213 := lang.Apply(tmp212, []any{sym_glojure_DOT_core_SLASH_commute})
					tmp214 := checkDerefVar(var_glojure_DOT_core_list)
					tmp215 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp216 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp217 := checkDerefVar(var_glojure_DOT_core_list)
					tmp218 := lang.Apply(tmp217, []any{sym_glojure_DOT_core_SLASH_deref})
					tmp219 := checkDerefVar(var_glojure_DOT_core_list)
					tmp220 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp221 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp222 := checkDerefVar(var_glojure_DOT_core_list)
					tmp223 := lang.Apply(tmp222, []any{sym_var})
					tmp224 := checkDerefVar(var_glojure_DOT_core_list)
					tmp225 := lang.Apply(tmp224, []any{sym_glojure_DOT_core_SLASH__STAR_loaded_DASH_libs_STAR_})
					tmp226 := lang.Apply(tmp221, []any{tmp223, tmp225})
					tmp227 := lang.Apply(tmp220, []any{tmp226})
					tmp228 := lang.Apply(tmp219, []any{tmp227})
					tmp229 := lang.Apply(tmp216, []any{tmp218, tmp228})
					tmp230 := lang.Apply(tmp215, []any{tmp229})
					tmp231 := lang.Apply(tmp214, []any{tmp230})
					tmp232 := checkDerefVar(var_glojure_DOT_core_list)
					tmp233 := lang.Apply(tmp232, []any{sym_glojure_DOT_core_SLASH_conj})
					tmp234 := checkDerefVar(var_glojure_DOT_core_list)
					tmp235 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp236 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp237 := checkDerefVar(var_glojure_DOT_core_list)
					tmp238 := lang.Apply(tmp237, []any{sym_quote})
					tmp239 := checkDerefVar(var_glojure_DOT_core_list)
					tmp240 := lang.Apply(tmp239, []any{v44})
					tmp241 := lang.Apply(tmp236, []any{tmp238, tmp240})
					tmp242 := lang.Apply(tmp235, []any{tmp241})
					tmp243 := lang.Apply(tmp234, []any{tmp242})
					tmp244 := lang.Apply(tmp211, []any{tmp213, tmp231, tmp233, tmp243})
					tmp245 := lang.Apply(tmp210, []any{tmp244})
					tmp246 := lang.Apply(tmp209, []any{tmp245})
					tmp247 := lang.Apply(tmp206, []any{tmp208, tmp246})
					tmp248 := lang.Apply(tmp205, []any{tmp247})
					tmp249 := lang.Apply(tmp204, []any{tmp248})
					tmp250 := checkDerefVar(var_glojure_DOT_core_list)
					tmp251 := lang.Apply(tmp250, []any{nil})
					tmp252 := lang.Apply(tmp201, []any{tmp203, tmp249, tmp251})
					tmp253 := lang.Apply(tmp200, []any{tmp252})
					tmp254 := lang.Apply(tmp199, []any{tmp253})
					tmp255 := lang.Apply(tmp166, []any{tmp168, tmp196, tmp198, tmp254})
					tmp256 := lang.Apply(tmp165, []any{tmp255})
					tmp257 := lang.Apply(tmp164, []any{tmp256})
					tmp258 := lang.Apply(tmp73, []any{tmp75, tmp93, tmp94, tmp163, tmp257})
					tmp259 := lang.Apply(tmp72, []any{tmp258})
					tmp6 = tmp259
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ns = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ns.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-imports
	{
		tmp0 := sym_ns_DASH_imports.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of the import mappings for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4199), kw_end_DASH_line, int(4199))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_filter_DASH_key)
			tmp4 := checkDerefVar(var_glojure_DOT_core_val)
			tmp5 := checkDerefVar(var_glojure_DOT_core_partial)
			tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
			tmp8 := lang.Apply(tmp5, []any{tmp6, tmp7})
			tmp9 := checkDerefVar(var_glojure_DOT_core_ns_DASH_map)
			tmp10 := lang.Apply(tmp9, []any{v2})
			tmp11 := lang.Apply(tmp3, []any{tmp4, tmp8, tmp10})
			return tmp11
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ns_DASH_imports = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ns_DASH_imports.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition
	{
		tmp0 := sym_partition.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll), lang.NewVector(sym_n, sym_step, sym_coll), lang.NewVector(sym_n, sym_step, sym_pad, sym_coll)), kw_doc, "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3177), kw_end_DASH_line, int(3177))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_partition)
				tmp5 := lang.Apply(tmp4, []any{v2, v2, v3})
				return tmp5
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								{ // let
									// let binding "p"
									tmp14 := checkDerefVar(var_glojure_DOT_core_doall)
									tmp15 := checkDerefVar(var_glojure_DOT_core_take)
									tmp16 := lang.Apply(tmp15, []any{v2, v12})
									tmp17 := lang.Apply(tmp14, []any{tmp16})
									var v18 any = tmp17
									_ = v18
									var tmp19 any
									tmp20 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp21 := checkDerefVar(var_glojure_DOT_core_count)
									tmp22 := lang.Apply(tmp21, []any{v18})
									tmp23 := lang.Apply(tmp20, []any{v2, tmp22})
									if lang.IsTruthy(tmp23) {
										tmp24 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp25 := checkDerefVar(var_glojure_DOT_core_partition)
										tmp26 := checkDerefVar(var_glojure_DOT_core_nthrest)
										tmp27 := lang.Apply(tmp26, []any{v12, v3})
										tmp28 := lang.Apply(tmp25, []any{v2, v3, tmp27})
										tmp29 := lang.Apply(tmp24, []any{v18, tmp28})
										tmp19 = tmp29
									} else {
									}
									tmp13 = tmp19
								} // end let
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v5})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "s"
								var v13 any = v10
								_ = v13
								var tmp14 any
								{ // let
									// let binding "p"
									tmp15 := checkDerefVar(var_glojure_DOT_core_doall)
									tmp16 := checkDerefVar(var_glojure_DOT_core_take)
									tmp17 := lang.Apply(tmp16, []any{v2, v13})
									tmp18 := lang.Apply(tmp15, []any{tmp17})
									var v19 any = tmp18
									_ = v19
									var tmp20 any
									tmp21 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp22 := checkDerefVar(var_glojure_DOT_core_count)
									tmp23 := lang.Apply(tmp22, []any{v19})
									tmp24 := lang.Apply(tmp21, []any{v2, tmp23})
									if lang.IsTruthy(tmp24) {
										tmp25 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp26 := checkDerefVar(var_glojure_DOT_core_partition)
										tmp27 := checkDerefVar(var_glojure_DOT_core_nthrest)
										tmp28 := lang.Apply(tmp27, []any{v13, v3})
										tmp29 := lang.Apply(tmp26, []any{v2, v3, v4, tmp28})
										tmp30 := lang.Apply(tmp25, []any{v19, tmp29})
										tmp20 = tmp30
									} else {
										tmp31 := checkDerefVar(var_glojure_DOT_core_list)
										tmp32 := checkDerefVar(var_glojure_DOT_core_take)
										tmp33 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp34 := lang.Apply(tmp33, []any{v19, v4})
										tmp35 := lang.Apply(tmp32, []any{v2, tmp34})
										tmp36 := lang.Apply(tmp31, []any{tmp35})
										tmp20 = tmp36
									}
									tmp14 = tmp20
								} // end let
								tmp12 = tmp14
							} // end let
							tmp11 = tmp12
						} else {
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_partition = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_partition.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition-all
	{
		tmp0 := sym_partition_DASH_all.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n), lang.NewVector(sym_n, sym_coll), lang.NewVector(sym_n, sym_step, sym_coll)), kw_doc, "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(7222), kw_end_DASH_line, int(7222))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "a"
						tmp6 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
						tmp7 := lang.Apply(tmp6, []any{v2})
						tmp8 := lang.Apply(lang.NewArrayList, []any{tmp7})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v4, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								var tmp12 any
								{ // let
									// let binding "result"
									var tmp13 any
									tmp14, ok := lang.FieldOrMethod(v9, "isEmpty")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "isEmpty")))
									}
									var tmp15 any
									switch reflect.TypeOf(tmp14).Kind() {
									case reflect.Func:
										tmp15 = lang.Apply(tmp14, nil)
									default:
										tmp15 = tmp14
									}
									if lang.IsTruthy(tmp15) {
										tmp13 = v11
									} else {
										var tmp16 any
										{ // let
											// let binding "v"
											tmp17 := checkDerefVar(var_glojure_DOT_core_vec)
											tmp18, ok := lang.FieldOrMethod(v9, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "toArray")))
											}
											var tmp19 any
											switch reflect.TypeOf(tmp18).Kind() {
											case reflect.Func:
												tmp19 = lang.Apply(tmp18, nil)
											default:
												tmp19 = tmp18
											}
											tmp20 := lang.Apply(tmp17, []any{tmp19})
											var v21 any = tmp20
											_ = v21
											tmp22, ok := lang.FieldOrMethod(v9, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "clear")))
											}
											var tmp23 any
											switch reflect.TypeOf(tmp22).Kind() {
											case reflect.Func:
												tmp23 = lang.Apply(tmp22, nil)
											default:
												tmp23 = tmp22
											}
											_ = tmp23
											tmp24 := checkDerefVar(var_glojure_DOT_core_unreduced)
											tmp25 := lang.Apply(v4, []any{v11, v21})
											tmp26 := lang.Apply(tmp24, []any{tmp25})
											tmp16 = tmp26
										} // end let
										tmp13 = tmp16
									}
									var v17 any = tmp13
									_ = v17
									tmp18 := lang.Apply(v4, []any{v17})
									tmp12 = tmp18
								} // end let
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								tmp13, _ := lang.FieldOrMethod(v9, "add")
								if reflect.TypeOf(tmp13).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
								}
								tmp14 := lang.Apply(tmp13, []any{v12})
								_ = tmp14
								var tmp15 any
								tmp16 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp17, ok := lang.FieldOrMethod(v9, "size")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "size")))
								}
								var tmp18 any
								switch reflect.TypeOf(tmp17).Kind() {
								case reflect.Func:
									tmp18 = lang.Apply(tmp17, nil)
								default:
									tmp18 = tmp17
								}
								tmp19 := lang.Apply(tmp16, []any{v2, tmp18})
								if lang.IsTruthy(tmp19) {
									var tmp20 any
									{ // let
										// let binding "v"
										tmp21 := checkDerefVar(var_glojure_DOT_core_vec)
										tmp22, ok := lang.FieldOrMethod(v9, "toArray")
										if !ok {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "toArray")))
										}
										var tmp23 any
										switch reflect.TypeOf(tmp22).Kind() {
										case reflect.Func:
											tmp23 = lang.Apply(tmp22, nil)
										default:
											tmp23 = tmp22
										}
										tmp24 := lang.Apply(tmp21, []any{tmp23})
										var v25 any = tmp24
										_ = v25
										tmp26, ok := lang.FieldOrMethod(v9, "clear")
										if !ok {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "clear")))
										}
										var tmp27 any
										switch reflect.TypeOf(tmp26).Kind() {
										case reflect.Func:
											tmp27 = lang.Apply(tmp26, nil)
										default:
											tmp27 = tmp26
										}
										_ = tmp27
										tmp28 := lang.Apply(v4, []any{v11, v25})
										tmp20 = tmp28
									} // end let
									tmp15 = tmp20
								} else {
									tmp15 = v11
								}
								return tmp15
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7231), kw_column, int(8), kw_end_DASH_line, int(7247), kw_end_DASH_column, int(23))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp12
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7229), kw_column, int(4), kw_end_DASH_line, int(7247), kw_end_DASH_column, int(25))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_partition_DASH_all)
				tmp5 := lang.Apply(tmp4, []any{v2, v2, v3})
				return tmp5
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								{ // let
									// let binding "seg"
									tmp14 := checkDerefVar(var_glojure_DOT_core_doall)
									tmp15 := checkDerefVar(var_glojure_DOT_core_take)
									tmp16 := lang.Apply(tmp15, []any{v2, v12})
									tmp17 := lang.Apply(tmp14, []any{tmp16})
									var v18 any = tmp17
									_ = v18
									tmp19 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp20 := checkDerefVar(var_glojure_DOT_core_partition_DASH_all)
									tmp21 := checkDerefVar(var_glojure_DOT_core_nthrest)
									tmp22 := lang.Apply(tmp21, []any{v12, v3})
									tmp23 := lang.Apply(tmp20, []any{v2, v3, tmp22})
									tmp24 := lang.Apply(tmp19, []any{v18, tmp23})
									tmp13 = tmp24
								} // end let
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_partition_DASH_all = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_partition_DASH_all.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pcalls
	{
		tmp0 := sym_pcalls.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_fns)), kw_doc, "Executes the no-arg fns in parallel, returning a lazy sequence of\n  their values", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(7056), kw_end_DASH_line, int(7056))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_pmap)
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					tmp6 := lang.Apply(v5, nil)
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7061), kw_column, int(17), kw_end_DASH_line, int(7061), kw_end_DASH_column, int(20))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp7 := lang.Apply(tmp3, []any{tmp6, v2})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_pcalls = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_pcalls.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prep-ints
	{
		tmp0 := sym_prep_DASH_ints.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tests, sym_thens)), kw_doc, "Takes a sequence of int-sized test constants and a corresponding sequence of\n  then expressions. Returns a tuple of [shift mask case-map switch-type] where\n  case-map is a map of int case values to [test then] tuples, and switch-type\n  is either :sparse or :compact.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(8), kw_line, int(6631), kw_end_DASH_line, int(6631), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_fits_DASH_table_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
				tmp8 := checkDerefVar(var_glojure_DOT_core_int)
				tmp9 := checkDerefVar(var_glojure_DOT_core_int)
				tmp10 := lang.Apply(tmp7, []any{tmp8, tmp9, v2, v3})
				tmp11 := lang.NewVector(int64(0), int64(0), tmp10, kw_compact)
				tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6639), kw_column, int(5), kw_end_DASH_line, int(6639), kw_end_DASH_column, int(49))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp13
			} else {
				var tmp14 any
				{ // let
					// let binding "vec__160"
					var tmp15 any
					{ // let
						// let binding "or__0__auto__"
						tmp16 := checkDerefVar(var_glojure_DOT_core_maybe_DASH_min_DASH_hash)
						tmp17 := checkDerefVar(var_glojure_DOT_core_map)
						tmp18 := checkDerefVar(var_glojure_DOT_core_int)
						tmp19 := lang.Apply(tmp17, []any{tmp18, v2})
						tmp20 := lang.Apply(tmp16, []any{tmp19})
						var v21 any = tmp20
						_ = v21
						var tmp22 any
						if lang.IsTruthy(v21) {
							tmp22 = v21
						} else {
							tmp23 := lang.NewVector(int64(0), int64(0))
							tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6640), kw_column, int(61), kw_end_DASH_line, int(6640), kw_end_DASH_column, int(65))
							tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp22 = tmp25
						}
						tmp15 = tmp22
					} // end let
					var v16 any = tmp15
					_ = v16
					// let binding "shift"
					tmp17 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp18 := lang.Apply(tmp17, []any{v16, int64(0), nil})
					var v19 any = tmp18
					_ = v19
					// let binding "mask"
					tmp20 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp21 := lang.Apply(tmp20, []any{v16, int64(1), nil})
					var v22 any = tmp21
					_ = v22
					var tmp23 any
					tmp24 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
					tmp25 := lang.Apply(tmp24, []any{v22})
					if lang.IsTruthy(tmp25) {
						tmp26 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
						tmp27 := checkDerefVar(var_glojure_DOT_core_int)
						tmp28 := checkDerefVar(var_glojure_DOT_core_int)
						tmp29 := lang.Apply(tmp26, []any{tmp27, tmp28, v2, v3})
						tmp30 := lang.NewVector(int64(0), int64(0), tmp29, kw_sparse)
						tmp31 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6643), kw_column, int(9), kw_end_DASH_line, int(6643), kw_end_DASH_column, int(52))
						tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp23 = tmp32
					} else {
						tmp33 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
						var tmp34 lang.FnFunc
						tmp34 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v35 := args[0]
							_ = v35
							tmp36 := checkDerefVar(var_glojure_DOT_core_shift_DASH_mask)
							tmp37 := checkDerefVar(var_glojure_DOT_core_int)
							tmp38 := lang.Apply(tmp37, []any{v35})
							tmp39 := lang.Apply(tmp36, []any{v19, v22, tmp38})
							return tmp39
						})
						tmp35 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6645), kw_column, int(31), kw_end_DASH_line, int(6645), kw_end_DASH_column, int(62))
						tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp37 := checkDerefVar(var_glojure_DOT_core_int)
						tmp38 := lang.Apply(tmp33, []any{tmp36, tmp37, v2, v3})
						tmp39 := lang.NewVector(v19, v22, tmp38, kw_compact)
						tmp40 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6645), kw_column, int(9), kw_end_DASH_line, int(6645), kw_end_DASH_column, int(89))
						tmp41, err := lang.WithMeta(tmp39, tmp40.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp23 = tmp41
					}
					tmp14 = tmp23
				} // end let
				tmp4 = tmp14
			}
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_prep_DASH_ints = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_prep_DASH_ints.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-prefix-map
	{
		tmp0 := sym_print_DASH_prefix_DASH_map.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(243), kw_column, int(8), kw_end_DASH_line, int(243), kw_end_DASH_column, int(23), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_prefix, sym_kvs, sym_print_DASH_one, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			tmp6 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
			tmp7 := checkDerefVar(var_glojure_DOT_core_str)
			tmp8 := lang.Apply(tmp7, []any{v2, "{"})
			var tmp9 lang.FnFunc
			tmp9 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v10 := args[0]
				_ = v10
				v11 := args[1]
				_ = v11
				var tmp12 any
				{ // let
					// let binding "vec__212"
					var v13 any = v10
					_ = v13
					// let binding "k"
					tmp14 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp15 := lang.Apply(tmp14, []any{v13, int64(0), nil})
					var v16 any = tmp15
					_ = v16
					// let binding "v"
					tmp17 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp18 := lang.Apply(tmp17, []any{v13, int64(1), nil})
					var v19 any = tmp18
					_ = v19
					tmp20 := lang.Apply(v4, []any{v16, v11})
					_ = tmp20
					tmp21 := lang.Apply(lang.AppendWriter, []any{v11, lang.NewChar(32)})
					_ = tmp21
					tmp22 := lang.Apply(v4, []any{v19, v11})
					tmp12 = tmp22
				} // end let
				return tmp12
			})
			tmp10 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(246), kw_column, int(5), kw_end_DASH_line, int(247), kw_end_DASH_column, int(107))
			tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp12 := lang.Apply(tmp6, []any{tmp8, tmp11, ", ", "}", v3, v5})
			return tmp12
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_print_DASH_prefix_DASH_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_prefix_DASH_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// promise
	{
		tmp0 := sym_promise.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a promise object that can be read with deref/@, and set,\n  once only, with deliver. Calls to deref/@ prior to delivery will\n  block, unless the variant of deref with timeout is used. All\n  subsequent derefs will return the same delivered value without\n  blocking. See also - realized?.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(7078), kw_end_DASH_line, int(7078))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			var tmp2 any
			{ // let
				// let binding "d"
				tmp3 := lang.Apply(nil, []any{int64(1)})
				var v4 any = tmp3
				_ = v4
				// let binding "v"
				tmp5 := checkDerefVar(var_glojure_DOT_core_atom)
				tmp6 := lang.Apply(tmp5, []any{v4})
				var v7 any = tmp6
				_ = v7
				tmp8 := reflect.TypeOf((*lang.IDeref)(nil)).Elem()
				tmp9 := checkDerefVar(var_glojure_DOT_core_deref)
				tmp10 := lang.NewVector(nil)
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7091), kw_column, int(15), kw_end_DASH_line, int(7091), kw_end_DASH_column, int(17))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13, ok := lang.FieldOrMethod(v4, "await")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "await")))
				}
				var tmp14 any
				switch reflect.TypeOf(tmp13).Kind() {
				case reflect.Func:
					tmp14 = lang.Apply(tmp13, nil)
				default:
					tmp14 = tmp13
				}
				tmp15 := checkDerefVar(var_glojure_DOT_core_deref)
				tmp16 := lang.Apply(tmp15, []any{v7})
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp14, tmp16})
				tmp18 := reflect.TypeOf((*lang.IBlockingDeref)(nil)).Elem()
				tmp19 := checkDerefVar(var_glojure_DOT_core_deref)
				tmp20 := lang.NewVector(nil, nil, nil)
				tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7094), kw_column, int(9), kw_end_DASH_line, int(7094), kw_end_DASH_column, int(34))
				tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp23 any
				tmp24, _ := lang.FieldOrMethod(v4, "await")
				if reflect.TypeOf(tmp24).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
				}
				tmp25 := lang.Apply(tmp24, []any{nil, time10.Millisecond})
				if lang.IsTruthy(tmp25) {
					tmp26 := checkDerefVar(var_glojure_DOT_core_deref)
					tmp27 := lang.Apply(tmp26, []any{v7})
					tmp23 = tmp27
				} else {
				}
				tmp28 := lang.Apply(tmp19, []any{tmp22, tmp23})
				tmp29 := reflect.TypeOf((*lang.IPending)(nil)).Elem()
				tmp30 := lang.NewVector(nil)
				tmp31 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7099), kw_column, int(19), kw_end_DASH_line, int(7099), kw_end_DASH_column, int(24))
				tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp33 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
				tmp34, ok := lang.FieldOrMethod(v4, "getCount")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getCount")))
				}
				var tmp35 any
				switch reflect.TypeOf(tmp34).Kind() {
				case reflect.Func:
					tmp35 = lang.Apply(tmp34, nil)
				default:
					tmp35 = tmp34
				}
				tmp36 := lang.Apply(tmp33, []any{tmp35})
				tmp37 := lang.Apply(nil, []any{tmp32, tmp36})
				tmp38 := lang.NewVector(nil, nil)
				tmp39 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7103), kw_column, int(7), kw_end_DASH_line, int(7103), kw_end_DASH_column, int(14))
				tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp41 any
				var tmp42 any
				{ // let
					// let binding "and__0__auto__"
					tmp43 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
					tmp44, ok := lang.FieldOrMethod(v4, "getCount")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getCount")))
					}
					var tmp45 any
					switch reflect.TypeOf(tmp44).Kind() {
					case reflect.Func:
						tmp45 = lang.Apply(tmp44, nil)
					default:
						tmp45 = tmp44
					}
					tmp46 := lang.Apply(tmp43, []any{tmp45})
					var v47 any = tmp46
					_ = v47
					var tmp48 any
					if lang.IsTruthy(v47) {
						tmp49 := checkDerefVar(var_glojure_DOT_core_compare_DASH_and_DASH_set_BANG_)
						tmp50 := lang.Apply(tmp49, []any{v7, v4, nil})
						tmp48 = tmp50
					} else {
						tmp48 = v47
					}
					tmp42 = tmp48
				} // end let
				if lang.IsTruthy(tmp42) {
					tmp43, ok := lang.FieldOrMethod(v4, "countDown")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "countDown")))
					}
					var tmp44 any
					switch reflect.TypeOf(tmp43).Kind() {
					case reflect.Func:
						tmp44 = lang.Apply(tmp43, nil)
					default:
						tmp44 = tmp43
					}
					_ = tmp44
				} else {
				}
				tmp45 := lang.Apply(nil, []any{tmp40, tmp41})
				tmp46 := lang.Apply(nil, []any{tmp8, tmp17, tmp18, tmp28, tmp29, tmp37, nil, tmp45})
				tmp2 = tmp46
			} // end let
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_promise = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_promise.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-find
	{
		tmp0 := sym_re_DASH_find.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m), lang.NewVector(sym_re, sym_s)), kw_doc, "Returns the next regex match, if any, of string to pattern, using\n  java.util.regex.Matcher.find().  Uses re-groups to return the\n  groups.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4922), kw_end_DASH_line, int(4922))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				tmp4, _ := lang.FieldOrMethod(v2, "find")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("find is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{})
				if lang.IsTruthy(tmp5) {
					tmp6 := checkDerefVar(var_glojure_DOT_core_re_DASH_groups)
					tmp7 := lang.Apply(tmp6, []any{v2})
					tmp3 = tmp7
				} else {
				}
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "m"
					tmp5 := checkDerefVar(var_glojure_DOT_core_re_DASH_matcher)
					tmp6 := lang.Apply(tmp5, []any{v2, v3})
					var v7 any = tmp6
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_re_DASH_find)
					tmp9 := lang.Apply(tmp8, []any{v7})
					tmp4 = tmp9
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_re_DASH_find = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_re_DASH_find.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref
	{
		tmp0 := sym_ref.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_options)), kw_doc, "Creates and returns a Ref with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :min-history (default 0)\n  :max-history (default 10)\n\n  If metadata-map is supplied, it will become the metadata on the\n  ref. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception. validate-fn will be called on\n  transaction commit, when all refs have their final values.\n\n  Normally refs accumulate history dynamically as needed to deal with\n  read demands. If you know in advance you will need history you can\n  set :min-history to ensure it will be available when first needed (instead\n  of after a read fault). History is limited, and the limit can be set\n  with :max-history.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(2260), kw_end_DASH_line, int(2260))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := lang.Apply(lang.NewRef, []any{v2})
				return tmp3
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "r"
					tmp5 := checkDerefVar(var_glojure_DOT_core_setup_DASH_reference)
					tmp6 := checkDerefVar(var_glojure_DOT_core_ref)
					tmp7 := lang.Apply(tmp6, []any{v2})
					tmp8 := lang.Apply(tmp5, []any{tmp7, v3})
					var v9 any = tmp8
					_ = v9
					// let binding "opts"
					tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp11 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp12 := lang.Apply(tmp10, []any{tmp11, v3})
					var v13 any = tmp12
					_ = v13
					var tmp14 any
					tmp15 := lang.Apply(kw_max_DASH_history, []any{v13})
					if lang.IsTruthy(tmp15) {
						tmp16 := lang.Apply(kw_max_DASH_history, []any{v13})
						tmp17, _ := lang.FieldOrMethod(v9, "setMaxHistory")
						if reflect.TypeOf(tmp17).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMaxHistory is not a function")))
						}
						tmp18 := lang.Apply(tmp17, []any{tmp16})
						tmp14 = tmp18
					} else {
					}
					_ = tmp14
					var tmp19 any
					tmp20 := lang.Apply(kw_min_DASH_history, []any{v13})
					if lang.IsTruthy(tmp20) {
						tmp21 := lang.Apply(kw_min_DASH_history, []any{v13})
						tmp22, _ := lang.FieldOrMethod(v9, "setMinHistory")
						if reflect.TypeOf(tmp22).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMinHistory is not a function")))
						}
						tmp23 := lang.Apply(tmp22, []any{tmp21})
						tmp19 = tmp23
					} else {
					}
					_ = tmp19
					tmp4 = v9
				} // end let
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_ref = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_ref.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// repeatedly
	{
		tmp0 := sym_repeatedly.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_n, sym_f)), kw_doc, "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(5167), kw_end_DASH_line, int(5167))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					tmp4 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp5 := lang.Apply(v2, nil)
					tmp6 := checkDerefVar(var_glojure_DOT_core_repeatedly)
					tmp7 := lang.Apply(tmp6, []any{v2})
					tmp8 := lang.Apply(tmp4, []any{tmp5, tmp7})
					return tmp8
				})
				tmp4 := lang.Apply(lang.NewLazySeq, []any{tmp3})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_take)
				tmp5 := checkDerefVar(var_glojure_DOT_core_repeatedly)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(tmp4, []any{v2, tmp6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_repeatedly = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_repeatedly.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replicate
	{
		tmp0 := sym_replicate.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_x)), kw_doc, "DEPRECATED: Use 'repeat' instead.\n   Returns a lazy seq of n xs.", kw_file, "glojure/core.glj", kw_deprecated, "1.3", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3004), kw_end_DASH_line, int(3004))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_take)
			tmp5 := checkDerefVar(var_glojure_DOT_core_repeat)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7 := lang.Apply(tmp4, []any{v2, tmp6})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_replicate = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_replicate.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// resultset-seq
	{
		tmp0 := sym_resultset_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_rs)), kw_doc, "Creates and returns a lazy sequence of structmaps corresponding to\n  the rows in the java.sql.ResultSet rs", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(5681), kw_end_DASH_line, int(5681))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "rsmeta"
				tmp4, _ := lang.FieldOrMethod(v2, "getMetaData")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("getMetaData is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{})
				var v6 any = tmp5
				_ = v6
				// let binding "idxs"
				tmp7 := checkDerefVar(var_glojure_DOT_core_range)
				tmp8 := checkDerefVar(var_glojure_DOT_core_inc)
				tmp9, _ := lang.FieldOrMethod(v6, "getColumnCount")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("getColumnCount is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{})
				tmp11 := lang.Apply(tmp8, []any{tmp10})
				tmp12 := lang.Apply(tmp7, []any{int64(1), tmp11})
				var v13 any = tmp12
				_ = v13
				// let binding "keys"
				tmp14 := checkDerefVar(var_glojure_DOT_core_map)
				tmp15 := checkDerefVar(var_glojure_DOT_core_comp)
				tmp16 := checkDerefVar(var_glojure_DOT_core_keyword)
				var tmp17 lang.FnFunc
				tmp17 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v18 := args[0]
					_ = v18
					tmp19, ok := lang.FieldOrMethod(v18, "toLowerCase")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v18, "toLowerCase")))
					}
					var tmp20 any
					switch reflect.TypeOf(tmp19).Kind() {
					case reflect.Func:
						tmp20 = lang.Apply(tmp19, nil)
					default:
						tmp20 = tmp19
					}
					return tmp20
				})
				tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5688), kw_column, int(35), kw_end_DASH_line, int(5688), kw_end_DASH_column, int(62))
				tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp20 := lang.Apply(tmp15, []any{tmp16, tmp19})
				tmp21 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp22 lang.FnFunc
				tmp22 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v23 := args[0]
					_ = v23
					tmp24, _ := lang.FieldOrMethod(v6, "getColumnLabel")
					if reflect.TypeOf(tmp24).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("getColumnLabel is not a function")))
					}
					tmp25 := lang.Apply(tmp24, []any{v23})
					return tmp25
				})
				tmp23 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5689), kw_column, int(26), kw_end_DASH_line, int(5689), kw_end_DASH_column, int(63))
				tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp25 := lang.Apply(tmp21, []any{tmp24, v13})
				tmp26 := lang.Apply(tmp14, []any{tmp20, tmp25})
				var v27 any = tmp26
				_ = v27
				// let binding "check-keys"
				var tmp28 any
				{ // let
					// let binding "or__0__auto__"
					tmp29 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp30 := checkDerefVar(var_glojure_DOT_core_distinct_QMARK_)
					tmp31 := lang.Apply(tmp29, []any{tmp30, v27})
					var v32 any = tmp31
					_ = v32
					var tmp33 any
					if lang.IsTruthy(v32) {
						tmp33 = v32
					} else {
						tmp34 := lang.Apply(lang.NewError, []any{"ResultSet must have unique column labels"})
						panic(tmp34)
					}
					tmp28 = tmp33
				} // end let
				var v29 any = tmp28
				_ = v29
				// let binding "row-struct"
				tmp30 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp31 := checkDerefVar(var_glojure_DOT_core_create_DASH_struct)
				tmp32 := lang.Apply(tmp30, []any{tmp31, v27})
				var v33 any = tmp32
				_ = v33
				// let binding "row-values"
				var tmp34 lang.FnFunc
				tmp34 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					tmp35 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp36 lang.FnFunc
					tmp36 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v37 := args[0]
						_ = v37
						tmp38, _ := lang.FieldOrMethod(v2, "getObject")
						if reflect.TypeOf(tmp38).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("getObject is not a function")))
						}
						tmp39 := lang.Apply(tmp38, []any{v37})
						return tmp39
					})
					tmp37 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5694), kw_column, int(34), kw_end_DASH_line, int(5694), kw_end_DASH_column, int(71))
					tmp38, err := lang.WithMeta(tmp36, tmp37.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp39 := lang.Apply(tmp35, []any{tmp38, v13})
					return tmp39
				})
				tmp35 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5694), kw_column, int(22), kw_end_DASH_line, int(5694), kw_end_DASH_column, int(78))
				tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v37 any = tmp36
				_ = v37
				// let binding "rows"
				var tmp38 lang.FnFunc
				{ // function thisfn
					var v39 lang.FnFunc
					tmp38 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						var tmp40 any
						tmp41, _ := lang.FieldOrMethod(v2, "next")
						if reflect.TypeOf(tmp41).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("next is not a function")))
						}
						tmp42 := lang.Apply(tmp41, []any{})
						if lang.IsTruthy(tmp42) {
							tmp43 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp44 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp45 := checkDerefVar(var_glojure_DOT_core_struct)
							tmp46 := lang.Apply(v37, nil)
							tmp47 := lang.Apply(tmp44, []any{tmp45, v33, tmp46})
							var tmp48 lang.FnFunc
							tmp48 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								tmp49 := lang.Apply(v39, nil)
								return tmp49
							})
							tmp49 := lang.Apply(lang.NewLazySeq, []any{tmp48})
							tmp50 := lang.Apply(tmp43, []any{tmp47, tmp49})
							tmp40 = tmp50
						} else {
						}
						return tmp40
					})
					v39 = tmp38
					_ = v39
				}
				tmp39 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5695), kw_column, int(16), kw_end_DASH_line, int(5697), kw_end_DASH_column, int(86))
				tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v41 any = tmp40
				_ = v41
				tmp42 := lang.Apply(v41, nil)
				tmp3 = tmp42
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_resultset_DASH_seq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_resultset_DASH_seq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send
	{
		tmp0 := sym_send.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_f, sym__AMP_, sym_args)), kw_doc, "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread from a thread pool, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2109), kw_end_DASH_line, int(2109))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_glojure_DOT_core_send_DASH_via)
				tmp7 := lang.Apply(tmp5, []any{tmp6, nil, v2, v3, v4})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_send = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_send.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send-off
	{
		tmp0 := sym_send_DASH_off.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_f, sym__AMP_, sym_args)), kw_doc, "Dispatch a potentially blocking action to an agent. Returns the\n  agent immediately. Subsequently, in a separate thread, the state of\n  the agent will be set to the value of:\n\n  (apply action-fn state-of-agent args)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2120), kw_end_DASH_line, int(2120))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_glojure_DOT_core_send_DASH_via)
				tmp7 := lang.Apply(tmp5, []any{tmp6, nil, v2, v3, v4})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_send_DASH_off = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_send_DASH_off.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seque
	{
		tmp0 := sym_seque.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s), lang.NewVector(sym_n_DASH_or_DASH_q, sym_s)), kw_doc, "Creates a queued seq on another (presumably lazy) seq s. The queued\n  seq will produce a concrete seq in the background, and can get up to\n  n items ahead of the consumer. n-or-q can be an integer n buffer\n  size, or an instance of java.util.concurrent BlockingQueue. Note\n  that reading from a seque can block if the reader gets ahead of the\n  producer.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(5419), kw_end_DASH_line, int(5419))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_seque)
				tmp4 := lang.Apply(tmp3, []any{int64(100), v2})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "q"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp7 := lang.Apply(tmp6, []any{nil, v2})
					if lang.IsTruthy(tmp7) {
						tmp5 = v2
					} else {
						tmp8 := checkDerefVar(var_glojure_DOT_core_int)
						tmp9 := lang.Apply(tmp8, []any{v2})
						tmp10 := lang.Apply(nil, []any{tmp9})
						tmp5 = tmp10
					}
					var v11 any = tmp5
					_ = v11
					// let binding "NIL"
					tmp12 := lang.Apply(reflect.StructOf, []any{nil})
					tmp13 := lang.Apply(reflect.New, []any{tmp12})
					tmp14, ok := lang.FieldOrMethod(tmp13, "Interface")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp13, "Interface")))
					}
					var tmp15 any
					switch reflect.TypeOf(tmp14).Kind() {
					case reflect.Func:
						tmp15 = lang.Apply(tmp14, nil)
					default:
						tmp15 = tmp14
					}
					var v16 any = tmp15
					_ = v16
					// let binding "agt"
					tmp17 := checkDerefVar(var_glojure_DOT_core_agent)
					var tmp18 lang.FnFunc
					tmp18 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						return v3
					})
					tmp19 := lang.Apply(lang.NewLazySeq, []any{tmp18})
					tmp20 := lang.Apply(tmp17, []any{tmp19})
					var v21 any = tmp20
					_ = v21
					// let binding "log-error"
					var tmp22 lang.FnFunc
					tmp22 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v23 := args[0]
						_ = v23
						v24 := args[1]
						_ = v24
						var tmp25 any
						tmp26, _ := lang.FieldOrMethod(v23, "offer")
						if reflect.TypeOf(tmp26).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
						}
						tmp27 := lang.Apply(tmp26, []any{v23})
						if lang.IsTruthy(tmp27) {
							panic(v24)
						} else {
							tmp25 = v24
						}
						return tmp25
					})
					tmp23 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5435), kw_column, int(20), kw_end_DASH_line, int(5438), kw_end_DASH_column, int(26))
					tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v25 any = tmp24
					_ = v25
					// let binding "fill"
					var tmp26 lang.FnFunc
					tmp26 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v27 := args[0]
						_ = v27
						var tmp28 any
						if lang.IsTruthy(v27) {
							var tmp29 any
							tmp30 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
							tmp31 := lang.Apply(tmp30, []any{nil, v27})
							if lang.IsTruthy(tmp31) {
								tmp32 := lang.Apply(v25, []any{v11, v27})
								tmp29 = tmp32
							} else {
								var tmp33 any
								func() {
									defer func() {
										if r := recover(); r != nil {
											if lang.CatchMatches(r, lang.Builtins["any"]) {
												v34 := r
												_ = v34
												tmp35 := lang.Apply(v25, []any{v11, v34})
												tmp33 = tmp35
											} else {
												panic(r)
											}
										}
									}()
									var tmp34 any
									{ // let
										// let binding "G__89"
										tmp35 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp36 := lang.Apply(tmp35, []any{v27})
										var v37 any = tmp36
										_ = v37
										// let binding "vec__90"
										var v38 any = v37
										_ = v38
										// let binding "seq__91"
										tmp39 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp40 := lang.Apply(tmp39, []any{v38})
										var v41 any = tmp40
										_ = v41
										// let binding "first__92"
										tmp42 := checkDerefVar(var_glojure_DOT_core_first)
										tmp43 := lang.Apply(tmp42, []any{v41})
										var v44 any = tmp43
										_ = v44
										// let binding "seq__91"
										tmp45 := checkDerefVar(var_glojure_DOT_core_next)
										tmp46 := lang.Apply(tmp45, []any{v41})
										var v47 any = tmp46
										_ = v47
										// let binding "x"
										var v48 any = v44
										_ = v48
										// let binding "xs"
										var v49 any = v47
										_ = v49
										// let binding "s"
										var v50 any = v38
										_ = v50
										var tmp51 any
										{ // let
											// let binding "G__89"
											var v52 any = v37
											_ = v52
											for {
												var tmp53 any
												{ // let
													// let binding "vec__93"
													var v54 any = v52
													_ = v54
													// let binding "seq__94"
													tmp55 := checkDerefVar(var_glojure_DOT_core_seq)
													tmp56 := lang.Apply(tmp55, []any{v54})
													var v57 any = tmp56
													_ = v57
													// let binding "first__95"
													tmp58 := checkDerefVar(var_glojure_DOT_core_first)
													tmp59 := lang.Apply(tmp58, []any{v57})
													var v60 any = tmp59
													_ = v60
													// let binding "seq__94"
													tmp61 := checkDerefVar(var_glojure_DOT_core_next)
													tmp62 := lang.Apply(tmp61, []any{v57})
													var v63 any = tmp62
													_ = v63
													// let binding "x"
													var v64 any = v60
													_ = v64
													// let binding "xs"
													var v65 any = v63
													_ = v65
													// let binding "s"
													var v66 any = v54
													_ = v66
													var tmp67 any
													if lang.IsTruthy(v66) {
														var tmp68 any
														var tmp69 any
														tmp70 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
														tmp71 := lang.Apply(tmp70, []any{v64})
														if lang.IsTruthy(tmp71) {
															tmp69 = v16
														} else {
															tmp69 = v64
														}
														tmp72, _ := lang.FieldOrMethod(v11, "offer")
														if reflect.TypeOf(tmp72).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
														}
														tmp73 := lang.Apply(tmp72, []any{tmp69})
														if lang.IsTruthy(tmp73) {
															var tmp74 any = v65
															v52 = tmp74
															continue
														} else {
															tmp68 = v66
														}
														tmp67 = tmp68
													} else {
														var tmp75 any
														tmp76, _ := lang.FieldOrMethod(v11, "offer")
														if reflect.TypeOf(tmp76).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
														}
														tmp77 := lang.Apply(tmp76, []any{v11})
														if lang.IsTruthy(tmp77) {
														} else {
															tmp75 = lang.NewList()
														}
														tmp67 = tmp75
													}
													tmp53 = tmp67
												} // end let
												tmp51 = tmp53
												break
											}
										} // end let
										tmp34 = tmp51
									} // end let
									tmp33 = tmp34
								}()
								tmp29 = tmp33
							}
							tmp28 = tmp29
						} else {
						}
						return tmp28
					})
					tmp27 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5439), kw_column, int(15), kw_end_DASH_line, int(5452), kw_end_DASH_column, int(44))
					tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v29 any = tmp28
					_ = v29
					// let binding "drain"
					var tmp30 lang.FnFunc
					{ // function drain
						var v31 lang.FnFunc
						tmp30 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							var tmp32 lang.FnFunc
							tmp32 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								var tmp33 any
								{ // let
									// let binding "x"
									tmp34, ok := lang.FieldOrMethod(v11, "take")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "take")))
									}
									var tmp35 any
									switch reflect.TypeOf(tmp34).Kind() {
									case reflect.Func:
										tmp35 = lang.Apply(tmp34, nil)
									default:
										tmp35 = tmp34
									}
									var v36 any = tmp35
									_ = v36
									var tmp37 any
									tmp38 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
									tmp39 := lang.Apply(tmp38, []any{v36, v11})
									if lang.IsTruthy(tmp39) {
										tmp40 := checkDerefVar(var_glojure_DOT_core_deref)
										tmp41 := lang.Apply(tmp40, []any{v21})
										_ = tmp41
									} else {
										tmp42 := checkDerefVar(var_glojure_DOT_core_send_DASH_off)
										tmp43 := lang.Apply(tmp42, []any{v21, v29})
										_ = tmp43
										tmp44 := checkDerefVar(var_glojure_DOT_core_release_DASH_pending_DASH_sends)
										tmp45 := lang.Apply(tmp44, nil)
										_ = tmp45
										tmp46 := checkDerefVar(var_glojure_DOT_core_cons)
										var tmp47 any
										tmp48 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
										tmp49 := lang.Apply(tmp48, []any{v36, v16})
										if lang.IsTruthy(tmp49) {
										} else {
											tmp47 = v36
										}
										tmp50 := lang.Apply(v31, nil)
										tmp51 := lang.Apply(tmp46, []any{tmp47, tmp50})
										tmp37 = tmp51
									}
									tmp33 = tmp37
								} // end let
								return tmp33
							})
							tmp33 := lang.Apply(lang.NewLazySeq, []any{tmp32})
							return tmp33
						})
						v31 = tmp30
						_ = v31
					}
					tmp31 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5453), kw_column, int(16), kw_end_DASH_line, int(5461), kw_end_DASH_column, int(73))
					tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v33 any = tmp32
					_ = v33
					tmp34 := checkDerefVar(var_glojure_DOT_core_send_DASH_off)
					tmp35 := lang.Apply(tmp34, []any{v21, v29})
					_ = tmp35
					tmp36 := lang.Apply(v33, nil)
					tmp4 = tmp36
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_seque = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_seque.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sigs
	{
		tmp0 := sym_sigs.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(223), kw_column, int(2), kw_end_DASH_line, int(224), kw_end_DASH_column, int(5), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_assert_DASH_valid_DASH_fdecl)
			tmp4 := lang.Apply(tmp3, []any{v2})
			_ = tmp4
			var tmp5 any
			{ // let
				// let binding "asig"
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v7 := args[0]
					_ = v7
					var tmp8 any
					{ // let
						// let binding "arglist"
						tmp9 := checkDerefVar(var_glojure_DOT_core_first)
						tmp10 := lang.Apply(tmp9, []any{v7})
						var v11 any = tmp10
						_ = v11
						// let binding "arglist"
						var tmp12 any
						tmp13 := checkDerefVar(var_glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v11})
						tmp15 := lang.Apply(lang.Equals, []any{sym__AMP_form, tmp14})
						if lang.IsTruthy(tmp15) {
							tmp16 := lang.Apply(lang.Count, []any{v11})
							tmp17 := lang.Apply(lang.Subvec, []any{v11, int64(2), tmp16})
							tmp12 = tmp17
						} else {
							tmp12 = v11
						}
						var v18 any = tmp12
						_ = v18
						// let binding "body"
						tmp19 := checkDerefVar(var_glojure_DOT_core_next)
						tmp20 := lang.Apply(tmp19, []any{v7})
						var v21 any = tmp20
						_ = v21
						var tmp22 any
						tmp23 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
						tmp24 := checkDerefVar(var_glojure_DOT_core_first)
						tmp25 := lang.Apply(tmp24, []any{v21})
						tmp26 := lang.Apply(tmp23, []any{tmp25})
						if lang.IsTruthy(tmp26) {
							var tmp27 any
							tmp28 := checkDerefVar(var_glojure_DOT_core_next)
							tmp29 := lang.Apply(tmp28, []any{v21})
							if lang.IsTruthy(tmp29) {
								tmp30 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
								tmp31 := checkDerefVar(var_glojure_DOT_core_conj)
								var tmp32 any
								tmp33 := checkDerefVar(var_glojure_DOT_core_meta)
								tmp34 := lang.Apply(tmp33, []any{v18})
								if lang.IsTruthy(tmp34) {
									tmp35 := checkDerefVar(var_glojure_DOT_core_meta)
									tmp36 := lang.Apply(tmp35, []any{v18})
									tmp32 = tmp36
								} else {
									tmp37 := lang.NewMap()
									tmp38 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(237), kw_column, int(77), kw_end_DASH_line, int(237), kw_end_DASH_column, int(78))
									tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp32 = tmp39
								}
								tmp40 := checkDerefVar(var_glojure_DOT_core_first)
								tmp41 := lang.Apply(tmp40, []any{v21})
								tmp42 := lang.Apply(tmp31, []any{tmp32, tmp41})
								tmp43 := lang.Apply(tmp30, []any{v18, tmp42})
								tmp27 = tmp43
							} else {
								tmp27 = v18
							}
							tmp22 = tmp27
						} else {
							tmp22 = v18
						}
						tmp8 = tmp22
					} // end let
					return tmp8
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(228), kw_column, int(10), kw_end_DASH_line, int(239), kw_end_DASH_column, int(25))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v9 any = tmp8
				_ = v9
				// let binding "resolve-tag"
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v11 := args[0]
					_ = v11
					var tmp12 any
					{ // let
						// let binding "m"
						tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp14 := lang.Apply(tmp13, []any{v11})
						var v15 any = tmp14
						_ = v15
						// let binding "tag"
						tmp16 := lang.Apply(kw_tag, []any{v15})
						var v17 any = tmp16
						_ = v17
						var tmp18 any
						tmp19 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp20 := reflect.TypeOf((*lang.Symbol)(nil))
						tmp21 := lang.Apply(tmp19, []any{tmp20, v17})
						if lang.IsTruthy(tmp21) {
							var tmp22 any
							tmp23, ok := lang.FieldOrMethod(v17, "Name")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v17, "Name")))
							}
							var tmp24 any
							switch reflect.TypeOf(tmp23).Kind() {
							case reflect.Func:
								tmp24 = lang.Apply(tmp23, nil)
							default:
								tmp24 = tmp23
							}
							tmp25 := lang.Apply(strings11.Index, []any{tmp24, "."})
							tmp26 := lang.Apply(lang.Equiv, []any{tmp25, int64(-1)})
							if lang.IsTruthy(tmp26) {
								var tmp27 any
								tmp28 := lang.Apply(lang.Equals, []any{nil, nil})
								if lang.IsTruthy(tmp28) {
									var tmp29 any
									{ // let
										// let binding "c"
										var v30 any = nil
										_ = v30
										var tmp31 any
										if lang.IsTruthy(v30) {
											tmp32 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
											tmp33 := checkDerefVar(var_glojure_DOT_core_assoc)
											tmp34, ok := lang.FieldOrMethod(v30, "Name")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v30, "Name")))
											}
											var tmp35 any
											switch reflect.TypeOf(tmp34).Kind() {
											case reflect.Func:
												tmp35 = lang.Apply(tmp34, nil)
											default:
												tmp35 = tmp34
											}
											tmp36 := lang.Apply(lang.NewSymbol, []any{tmp35})
											tmp37 := lang.Apply(tmp33, []any{v15, kw_tag, tmp36})
											tmp38 := lang.Apply(tmp32, []any{v11, tmp37})
											tmp31 = tmp38
										} else {
											tmp31 = v11
										}
										tmp29 = tmp31
									} // end let
									tmp27 = tmp29
								} else {
									tmp27 = v11
								}
								tmp22 = tmp27
							} else {
								tmp22 = v11
							}
							tmp18 = tmp22
						} else {
							tmp18 = v11
						}
						tmp12 = tmp18
					} // end let
					return tmp12
				})
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(240), kw_column, int(22), kw_end_DASH_line, int(252), kw_end_DASH_column, int(37))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v13 any = tmp12
				_ = v13
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
				tmp16 := checkDerefVar(var_glojure_DOT_core_first)
				tmp17 := lang.Apply(tmp16, []any{v2})
				tmp18 := lang.Apply(tmp15, []any{tmp17})
				if lang.IsTruthy(tmp18) {
					var tmp19 any
					{ // let
						// let binding "ret"
						tmp20 := lang.NewVector()
						tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(254), kw_column, int(19), kw_end_DASH_line, int(254), kw_end_DASH_column, int(20))
						tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v23 any = tmp22
						_ = v23
						// let binding "fdecls"
						var v24 any = v2
						_ = v24
						for {
							var tmp25 any
							if lang.IsTruthy(v24) {
								tmp27 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp28 := checkDerefVar(var_glojure_DOT_core_first)
								tmp29 := lang.Apply(tmp28, []any{v24})
								tmp30 := lang.Apply(v9, []any{tmp29})
								tmp31 := lang.Apply(v13, []any{tmp30})
								tmp32 := lang.Apply(tmp27, []any{v23, tmp31})
								var tmp26 any = tmp32
								tmp34 := checkDerefVar(var_glojure_DOT_core_next)
								tmp35 := lang.Apply(tmp34, []any{v24})
								var tmp33 any = tmp35
								v23 = tmp26
								v24 = tmp33
								continue
							} else {
								tmp36 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp37 := lang.Apply(tmp36, []any{v23})
								tmp25 = tmp37
							}
							tmp19 = tmp25
							break
						}
					} // end let
					tmp14 = tmp19
				} else {
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := lang.Apply(v9, []any{v2})
					tmp22 := lang.Apply(v13, []any{tmp21})
					tmp23 := lang.Apply(tmp20, []any{tmp22})
					tmp14 = tmp23
				}
				tmp5 = tmp14
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(225), kw_column, int(2), kw_end_DASH_line, int(258), kw_end_DASH_column, int(43))).(lang.FnFunc)
		var_glojure_DOT_core_sigs = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_sigs.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some->
	{
		tmp0 := sym_some_DASH__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr, sym__AMP_, sym_forms)), kw_doc, "When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(7610), kw_end_DASH_line, int(7610))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "g"
					tmp7 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp8 := lang.Apply(tmp7, nil)
					var v9 any = tmp8
					_ = v9
					// let binding "steps"
					tmp10 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v12 := args[0]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym_if})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp20 := checkDerefVar(var_glojure_DOT_core_list)
						tmp21 := lang.Apply(tmp20, []any{sym_glojure_DOT_core_SLASH_nil_QMARK_})
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v9})
						tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
						tmp25 := lang.Apply(tmp18, []any{tmp24})
						tmp26 := lang.Apply(tmp17, []any{tmp25})
						tmp27 := checkDerefVar(var_glojure_DOT_core_list)
						tmp28 := lang.Apply(tmp27, []any{nil})
						tmp29 := checkDerefVar(var_glojure_DOT_core_list)
						tmp30 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp31 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp32 := checkDerefVar(var_glojure_DOT_core_list)
						tmp33 := lang.Apply(tmp32, []any{sym_glojure_DOT_core_SLASH__DASH__GT_})
						tmp34 := checkDerefVar(var_glojure_DOT_core_list)
						tmp35 := lang.Apply(tmp34, []any{v9})
						tmp36 := checkDerefVar(var_glojure_DOT_core_list)
						tmp37 := lang.Apply(tmp36, []any{v12})
						tmp38 := lang.Apply(tmp31, []any{tmp33, tmp35, tmp37})
						tmp39 := lang.Apply(tmp30, []any{tmp38})
						tmp40 := lang.Apply(tmp29, []any{tmp39})
						tmp41 := lang.Apply(tmp14, []any{tmp16, tmp26, tmp28, tmp40})
						tmp42 := lang.Apply(tmp13, []any{tmp41})
						return tmp42
					})
					tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7616), kw_column, int(20), kw_end_DASH_line, int(7616), kw_end_DASH_column, int(64))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp14 := lang.Apply(tmp10, []any{tmp13, v5})
					var v15 any = tmp14
					_ = v15
					tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp17 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{sym_glojure_DOT_core_SLASH_let})
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp22 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp25 := checkDerefVar(var_glojure_DOT_core_list)
					tmp26 := lang.Apply(tmp25, []any{v9})
					tmp27 := checkDerefVar(var_glojure_DOT_core_list)
					tmp28 := lang.Apply(tmp27, []any{v4})
					tmp29 := checkDerefVar(var_glojure_DOT_core_interleave)
					tmp30 := checkDerefVar(var_glojure_DOT_core_repeat)
					tmp31 := lang.Apply(tmp30, []any{v9})
					tmp32 := checkDerefVar(var_glojure_DOT_core_butlast)
					tmp33 := lang.Apply(tmp32, []any{v15})
					tmp34 := lang.Apply(tmp29, []any{tmp31, tmp33})
					tmp35 := lang.Apply(tmp24, []any{tmp26, tmp28, tmp34})
					tmp36 := lang.Apply(tmp23, []any{tmp35})
					tmp37 := lang.Apply(tmp21, []any{tmp22, tmp36})
					tmp38 := lang.Apply(tmp20, []any{tmp37})
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					var tmp40 any
					tmp41 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
					tmp42 := lang.Apply(tmp41, []any{v15})
					if lang.IsTruthy(tmp42) {
						tmp40 = v9
					} else {
						tmp43 := checkDerefVar(var_glojure_DOT_core_last)
						tmp44 := lang.Apply(tmp43, []any{v15})
						tmp40 = tmp44
					}
					tmp45 := lang.Apply(tmp39, []any{tmp40})
					tmp46 := lang.Apply(tmp17, []any{tmp19, tmp38, tmp45})
					tmp47 := lang.Apply(tmp16, []any{tmp46})
					tmp6 = tmp47
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_some_DASH__GT_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_some_DASH__GT_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some->>
	{
		tmp0 := sym_some_DASH__GT__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr, sym__AMP_, sym_forms)), kw_doc, "When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(7624), kw_end_DASH_line, int(7624))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "g"
					tmp7 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp8 := lang.Apply(tmp7, nil)
					var v9 any = tmp8
					_ = v9
					// let binding "steps"
					tmp10 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v12 := args[0]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym_if})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp20 := checkDerefVar(var_glojure_DOT_core_list)
						tmp21 := lang.Apply(tmp20, []any{sym_glojure_DOT_core_SLASH_nil_QMARK_})
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v9})
						tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
						tmp25 := lang.Apply(tmp18, []any{tmp24})
						tmp26 := lang.Apply(tmp17, []any{tmp25})
						tmp27 := checkDerefVar(var_glojure_DOT_core_list)
						tmp28 := lang.Apply(tmp27, []any{nil})
						tmp29 := checkDerefVar(var_glojure_DOT_core_list)
						tmp30 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp31 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp32 := checkDerefVar(var_glojure_DOT_core_list)
						tmp33 := lang.Apply(tmp32, []any{sym_glojure_DOT_core_SLASH__DASH__GT__GT_})
						tmp34 := checkDerefVar(var_glojure_DOT_core_list)
						tmp35 := lang.Apply(tmp34, []any{v9})
						tmp36 := checkDerefVar(var_glojure_DOT_core_list)
						tmp37 := lang.Apply(tmp36, []any{v12})
						tmp38 := lang.Apply(tmp31, []any{tmp33, tmp35, tmp37})
						tmp39 := lang.Apply(tmp30, []any{tmp38})
						tmp40 := lang.Apply(tmp29, []any{tmp39})
						tmp41 := lang.Apply(tmp14, []any{tmp16, tmp26, tmp28, tmp40})
						tmp42 := lang.Apply(tmp13, []any{tmp41})
						return tmp42
					})
					tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7630), kw_column, int(20), kw_end_DASH_line, int(7630), kw_end_DASH_column, int(65))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp14 := lang.Apply(tmp10, []any{tmp13, v5})
					var v15 any = tmp14
					_ = v15
					tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp17 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{sym_glojure_DOT_core_SLASH_let})
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp22 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp25 := checkDerefVar(var_glojure_DOT_core_list)
					tmp26 := lang.Apply(tmp25, []any{v9})
					tmp27 := checkDerefVar(var_glojure_DOT_core_list)
					tmp28 := lang.Apply(tmp27, []any{v4})
					tmp29 := checkDerefVar(var_glojure_DOT_core_interleave)
					tmp30 := checkDerefVar(var_glojure_DOT_core_repeat)
					tmp31 := lang.Apply(tmp30, []any{v9})
					tmp32 := checkDerefVar(var_glojure_DOT_core_butlast)
					tmp33 := lang.Apply(tmp32, []any{v15})
					tmp34 := lang.Apply(tmp29, []any{tmp31, tmp33})
					tmp35 := lang.Apply(tmp24, []any{tmp26, tmp28, tmp34})
					tmp36 := lang.Apply(tmp23, []any{tmp35})
					tmp37 := lang.Apply(tmp21, []any{tmp22, tmp36})
					tmp38 := lang.Apply(tmp20, []any{tmp37})
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					var tmp40 any
					tmp41 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
					tmp42 := lang.Apply(tmp41, []any{v15})
					if lang.IsTruthy(tmp42) {
						tmp40 = v9
					} else {
						tmp43 := checkDerefVar(var_glojure_DOT_core_last)
						tmp44 := lang.Apply(tmp43, []any{v15})
						tmp40 = tmp44
					}
					tmp45 := lang.Apply(tmp39, []any{tmp40})
					tmp46 := lang.Apply(tmp17, []any{tmp19, tmp38, tmp45})
					tmp47 := lang.Apply(tmp16, []any{tmp46})
					tmp6 = tmp47
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_some_DASH__GT__GT_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_some_DASH__GT__GT_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// split-at
	{
		tmp0 := sym_split_DASH_at.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a vector of [(take n coll) (drop n coll)]", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2983), kw_end_DASH_line, int(2983))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_take)
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			tmp6 := checkDerefVar(var_glojure_DOT_core_drop)
			tmp7 := lang.Apply(tmp6, []any{v2, v3})
			tmp8 := lang.NewVector(tmp5, tmp7)
			tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2988), kw_column, int(5), kw_end_DASH_line, int(2988), kw_end_DASH_column, int(33))
			tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp10
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_split_DASH_at = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_split_DASH_at.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-array-2d
	{
		tmp0 := sym_to_DASH_array_DASH_2d.WithMeta(lang.NewMap(kw_tag, "[[Ljava.lang.Object;", kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a (potentially-ragged) 2-dimensional array of Objects\n  containing the contents of coll, which can be any Collection of any\n  Collection.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(4002), kw_end_DASH_line, int(4002))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "ret"
				tmp4 := checkDerefVar(var_glojure_DOT_core_make_DASH_array)
				tmp5 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
				tmp6, _ := lang.FieldOrMethod(tmp5, "forName")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("forName is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{"[Ljava.lang.Object;"})
				tmp8, _ := lang.FieldOrMethod(v2, "size")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("size is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{})
				tmp10 := lang.Apply(tmp4, []any{tmp7, tmp9})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				{ // let
					// let binding "i"
					var v13 any = int64(0)
					_ = v13
					// let binding "xs"
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := lang.Apply(tmp14, []any{v2})
					var v16 any = tmp15
					_ = v16
					for {
						var tmp17 any
						if lang.IsTruthy(v16) {
							tmp18 := checkDerefVar(var_glojure_DOT_core_aset)
							tmp19 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
							tmp20 := checkDerefVar(var_glojure_DOT_core_first)
							tmp21 := lang.Apply(tmp20, []any{v16})
							tmp22 := lang.Apply(tmp19, []any{tmp21})
							tmp23 := lang.Apply(tmp18, []any{v11, v13, tmp22})
							_ = tmp23
							tmp25 := checkDerefVar(var_glojure_DOT_core_inc)
							tmp26 := lang.Apply(tmp25, []any{v13})
							var tmp24 any = tmp26
							tmp28 := checkDerefVar(var_glojure_DOT_core_next)
							tmp29 := lang.Apply(tmp28, []any{v16})
							var tmp27 any = tmp29
							v13 = tmp24
							v16 = tmp27
							continue
						} else {
						}
						tmp12 = tmp17
						break
					}
				} // end let
				_ = tmp12
				tmp3 = v11
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, "[[Ljava.lang.Object;")).(lang.FnFunc)
		var_glojure_DOT_core_to_DASH_array_DASH_2d = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_to_DASH_array_DASH_2d.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-local-vars
	{
		tmp0 := sym_with_DASH_local_DASH_vars.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name_DASH_vals_DASH_vec, sym__AMP_, sym_body)), kw_doc, "varbinding=> symbol init-expr\n\n  Executes the exprs in a context in which the symbols are bound to\n  vars with per-thread bindings to the init-exprs.  The symbols refer\n  to the var objects themselves, and must be accessed with var-get and\n  var-set", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(11), kw_line, int(4339), kw_end_DASH_line, int(4339))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_str)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp12 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp14 := lang.Apply(tmp13, []any{v2})
					tmp15 := lang.Apply(kw_line, []any{tmp14})
					tmp16 := lang.Apply(tmp9, []any{tmp11, " requires ", "a vector for its binding", " in ", tmp12, ":", tmp15})
					tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
					panic(tmp17)
				}
				_ = tmp6
				var tmp18 any
				tmp19 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp20 := checkDerefVar(var_glojure_DOT_core_count)
				tmp21 := lang.Apply(tmp20, []any{v4})
				tmp22 := lang.Apply(tmp19, []any{tmp21})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "an even number of forms in binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp18
				tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp33 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp34 := checkDerefVar(var_glojure_DOT_core_list)
				tmp35 := lang.Apply(tmp34, []any{sym_glojure_DOT_core_SLASH_let})
				tmp36 := checkDerefVar(var_glojure_DOT_core_list)
				tmp37 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp38 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp39 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp40 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp41 := checkDerefVar(var_glojure_DOT_core_interleave)
				tmp42 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
				tmp43 := lang.Apply(tmp42, []any{int64(2), v4})
				tmp44 := checkDerefVar(var_glojure_DOT_core_repeat)
				tmp45 := lang.Apply(tmp44, []any{lang.NewList(sym__DOT__DOT_, sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT__STAR_Var, sym_create, sym_setDynamic)})
				tmp46 := lang.Apply(tmp41, []any{tmp43, tmp45})
				tmp47 := lang.Apply(tmp40, []any{tmp46})
				tmp48 := lang.Apply(tmp39, []any{tmp47})
				tmp49 := lang.Apply(tmp37, []any{tmp38, tmp48})
				tmp50 := lang.Apply(tmp36, []any{tmp49})
				tmp51 := checkDerefVar(var_glojure_DOT_core_list)
				tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp53 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp54 := checkDerefVar(var_glojure_DOT_core_list)
				tmp55 := lang.Apply(tmp54, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PushThreadBindings})
				tmp56 := checkDerefVar(var_glojure_DOT_core_list)
				tmp57 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp58 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
				tmp59 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp60 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp61 := lang.Apply(tmp60, nil)
				tmp62 := lang.Apply(tmp59, []any{tmp61})
				tmp63 := lang.Apply(tmp57, []any{tmp58, tmp62})
				tmp64 := lang.Apply(tmp56, []any{tmp63})
				tmp65 := lang.Apply(tmp53, []any{tmp55, tmp64})
				tmp66 := lang.Apply(tmp52, []any{tmp65})
				tmp67 := lang.Apply(tmp51, []any{tmp66})
				tmp68 := checkDerefVar(var_glojure_DOT_core_list)
				tmp69 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp70 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp71 := checkDerefVar(var_glojure_DOT_core_list)
				tmp72 := lang.Apply(tmp71, []any{sym_try})
				tmp73 := checkDerefVar(var_glojure_DOT_core_list)
				tmp74 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp75 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp76 := checkDerefVar(var_glojure_DOT_core_list)
				tmp77 := lang.Apply(tmp76, []any{sym_finally})
				tmp78 := checkDerefVar(var_glojure_DOT_core_list)
				tmp79 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp80 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp81 := checkDerefVar(var_glojure_DOT_core_list)
				tmp82 := lang.Apply(tmp81, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PopThreadBindings})
				tmp83 := lang.Apply(tmp80, []any{tmp82})
				tmp84 := lang.Apply(tmp79, []any{tmp83})
				tmp85 := lang.Apply(tmp78, []any{tmp84})
				tmp86 := lang.Apply(tmp75, []any{tmp77, tmp85})
				tmp87 := lang.Apply(tmp74, []any{tmp86})
				tmp88 := lang.Apply(tmp73, []any{tmp87})
				tmp89 := lang.Apply(tmp70, []any{tmp72, v5, tmp88})
				tmp90 := lang.Apply(tmp69, []any{tmp89})
				tmp91 := lang.Apply(tmp68, []any{tmp90})
				tmp92 := lang.Apply(tmp33, []any{tmp35, tmp50, tmp67, tmp91})
				tmp93 := lang.Apply(tmp32, []any{tmp92})
				return tmp93
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_with_DASH_local_DASH_vars = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_with_DASH_local_DASH_vars.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// Throwable->map
	{
		tmp0 := sym_Throwable_DASH__GT_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_o)), kw_doc, "Constructs a data representation for a Throwable with keys:\n    :cause - root cause message\n    :phase - error phase\n    :via - cause chain, with cause keys:\n             :type - exception class symbol\n             :message - exception message\n             :data - ex-data\n             :at - top stack element\n    :trace - root cause stack elements", kw_file, "glojure/core_print.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(442), kw_end_DASH_line, int(442))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "base"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					tmp6 := checkDerefVar(var_glojure_DOT_core_merge)
					tmp7 := checkDerefVar(var_glojure_DOT_core_symbol)
					tmp8 := checkDerefVar(var_glojure_DOT_core_class)
					tmp9 := lang.Apply(tmp8, []any{v5})
					tmp10, ok := lang.FieldOrMethod(tmp9, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp9, "Name")))
					}
					var tmp11 any
					switch reflect.TypeOf(tmp10).Kind() {
					case reflect.Func:
						tmp11 = lang.Apply(tmp10, nil)
					default:
						tmp11 = tmp10
					}
					tmp12 := lang.Apply(tmp7, []any{tmp11})
					tmp13 := lang.NewMap(kw_type, tmp12)
					tmp14 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(455), kw_column, int(23), kw_end_DASH_line, int(455), kw_end_DASH_column, int(56))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp16 any
					{ // let
						// let binding "temp__0__auto__"
						tmp17, ok := lang.FieldOrMethod(v5, "getLocalizedMessage")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "getLocalizedMessage")))
						}
						var tmp18 any
						switch reflect.TypeOf(tmp17).Kind() {
						case reflect.Func:
							tmp18 = lang.Apply(tmp17, nil)
						default:
							tmp18 = tmp17
						}
						var v19 any = tmp18
						_ = v19
						var tmp20 any
						if lang.IsTruthy(v19) {
							var tmp21 any
							{ // let
								// let binding "msg"
								var v22 any = v19
								_ = v22
								tmp23 := lang.NewMap(kw_message, v22)
								tmp24 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(457), kw_column, int(20), kw_end_DASH_line, int(457), kw_end_DASH_column, int(33))
								tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp21 = tmp25
							} // end let
							tmp20 = tmp21
						} else {
						}
						tmp16 = tmp20
					} // end let
					var tmp17 any
					{ // let
						// let binding "temp__0__auto__"
						tmp18 := checkDerefVar(var_glojure_DOT_core_ex_DASH_data)
						tmp19 := lang.Apply(tmp18, []any{v5})
						var v20 any = tmp19
						_ = v20
						var tmp21 any
						if lang.IsTruthy(v20) {
							var tmp22 any
							{ // let
								// let binding "ed"
								var v23 any = v20
								_ = v23
								tmp24 := lang.NewMap(kw_data, v23)
								tmp25 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(459), kw_column, int(20), kw_end_DASH_line, int(459), kw_end_DASH_column, int(29))
								tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp22 = tmp26
							} // end let
							tmp21 = tmp22
						} else {
						}
						tmp17 = tmp21
					} // end let
					var tmp18 any
					{ // let
						// let binding "st"
						tmp19, ok := lang.FieldOrMethod(v5, "getStackTrace")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "getStackTrace")))
						}
						var tmp20 any
						switch reflect.TypeOf(tmp19).Kind() {
						case reflect.Func:
							tmp20 = lang.Apply(tmp19, nil)
						default:
							tmp20 = tmp19
						}
						var v21 any = tmp20
						_ = v21
						var tmp22 any
						tmp23 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp24 := checkDerefVar(var_glojure_DOT_core_alength)
						tmp25 := lang.Apply(tmp24, []any{v21})
						tmp26 := lang.Apply(tmp23, []any{tmp25})
						if lang.IsTruthy(tmp26) {
							tmp27 := checkDerefVar(var_glojure_DOT_core_StackTraceElement_DASH__GT_vec)
							tmp28 := checkDerefVar(var_glojure_DOT_core_aget)
							tmp29 := lang.Apply(tmp28, []any{v21, int64(0)})
							tmp30 := lang.Apply(tmp27, []any{tmp29})
							tmp31 := lang.NewMap(kw_at, tmp30)
							tmp32 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(462), kw_column, int(22), kw_end_DASH_line, int(462), kw_end_DASH_column, int(63))
							tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp22 = tmp33
						} else {
						}
						tmp18 = tmp22
					} // end let
					tmp19 := lang.Apply(tmp6, []any{tmp15, tmp16, tmp17, tmp18})
					return tmp19
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(454), kw_column, int(14), kw_end_DASH_line, int(462), kw_end_DASH_column, int(67))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v7 any = tmp6
				_ = v7
				// let binding "via"
				var tmp8 any
				{ // let
					// let binding "via"
					tmp9 := lang.NewVector()
					tmp10 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(463), kw_column, int(24), kw_end_DASH_line, int(463), kw_end_DASH_column, int(25))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v12 any = tmp11
					_ = v12
					// let binding "t"
					var v13 any = v2
					_ = v13
					for {
						var tmp14 any
						if lang.IsTruthy(v13) {
							tmp16 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp17 := lang.Apply(tmp16, []any{v12, v13})
							var tmp15 any = tmp17
							tmp19, ok := lang.FieldOrMethod(v13, "getCause")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v13, "getCause")))
							}
							var tmp20 any
							switch reflect.TypeOf(tmp19).Kind() {
							case reflect.Func:
								tmp20 = lang.Apply(tmp19, nil)
							default:
								tmp20 = tmp19
							}
							var tmp18 any = tmp20
							v12 = tmp15
							v13 = tmp18
							continue
						} else {
							tmp14 = v12
						}
						tmp8 = tmp14
						break
					}
				} // end let
				var v9 any = tmp8
				_ = v9
				// let binding "root"
				tmp10 := checkDerefVar(var_glojure_DOT_core_peek)
				tmp11 := lang.Apply(tmp10, []any{v9})
				var v12 any = tmp11
				_ = v12
				tmp13 := checkDerefVar(var_glojure_DOT_core_merge)
				tmp14 := checkDerefVar(var_glojure_DOT_core_vec)
				tmp15 := checkDerefVar(var_glojure_DOT_core_map)
				tmp16 := lang.Apply(tmp15, []any{v7, v9})
				tmp17 := lang.Apply(tmp14, []any{tmp16})
				tmp18 := checkDerefVar(var_glojure_DOT_core_vec)
				tmp19 := checkDerefVar(var_glojure_DOT_core_map)
				tmp20 := checkDerefVar(var_glojure_DOT_core_StackTraceElement_DASH__GT_vec)
				var tmp21 any
				{ // let
					// let binding "or__0__auto__"
					var v22 any = v12
					_ = v22
					var tmp23 any
					if lang.IsTruthy(v22) {
						tmp23 = v22
					} else {
						tmp23 = v2
					}
					tmp21 = tmp23
				} // end let
				tmp22, ok := lang.FieldOrMethod(tmp21, "getStackTrace")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp21, "getStackTrace")))
				}
				var tmp23 any
				switch reflect.TypeOf(tmp22).Kind() {
				case reflect.Func:
					tmp23 = lang.Apply(tmp22, nil)
				default:
					tmp23 = tmp22
				}
				tmp24 := lang.Apply(tmp19, []any{tmp20, tmp23})
				tmp25 := lang.Apply(tmp18, []any{tmp24})
				tmp26 := lang.NewMap(kw_via, tmp17, kw_trace, tmp25)
				tmp27 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(468), kw_column, int(12), kw_end_DASH_line, int(470), kw_end_DASH_column, int(111))
				tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp29 any
				{ // let
					// let binding "temp__0__auto__"
					tmp30, ok := lang.FieldOrMethod(v12, "getLocalizedMessage")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "getLocalizedMessage")))
					}
					var tmp31 any
					switch reflect.TypeOf(tmp30).Kind() {
					case reflect.Func:
						tmp31 = lang.Apply(tmp30, nil)
					default:
						tmp31 = tmp30
					}
					var v32 any = tmp31
					_ = v32
					var tmp33 any
					if lang.IsTruthy(v32) {
						var tmp34 any
						{ // let
							// let binding "root-msg"
							var v35 any = v32
							_ = v35
							tmp36 := lang.NewMap(kw_cause, v35)
							tmp37 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(472), kw_column, int(9), kw_end_DASH_line, int(472), kw_end_DASH_column, int(25))
							tmp38, err := lang.WithMeta(tmp36, tmp37.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp34 = tmp38
						} // end let
						tmp33 = tmp34
					} else {
					}
					tmp29 = tmp33
				} // end let
				var tmp30 any
				{ // let
					// let binding "temp__0__auto__"
					tmp31 := checkDerefVar(var_glojure_DOT_core_ex_DASH_data)
					tmp32 := lang.Apply(tmp31, []any{v12})
					var v33 any = tmp32
					_ = v33
					var tmp34 any
					if lang.IsTruthy(v33) {
						var tmp35 any
						{ // let
							// let binding "data"
							var v36 any = v33
							_ = v36
							tmp37 := lang.NewMap(kw_data, v36)
							tmp38 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(474), kw_column, int(9), kw_end_DASH_line, int(474), kw_end_DASH_column, int(20))
							tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp35 = tmp39
						} // end let
						tmp34 = tmp35
					} else {
					}
					tmp30 = tmp34
				} // end let
				var tmp31 any
				{ // let
					// let binding "temp__0__auto__"
					tmp32 := checkDerefVar(var_glojure_DOT_core_ex_DASH_data)
					tmp33 := lang.Apply(tmp32, []any{v2})
					tmp34 := lang.Apply(kw_glojure_DOT_error_SLASH_phase, []any{tmp33})
					var v35 any = tmp34
					_ = v35
					var tmp36 any
					if lang.IsTruthy(v35) {
						var tmp37 any
						{ // let
							// let binding "phase"
							var v38 any = v35
							_ = v38
							tmp39 := lang.NewMap(kw_phase, v38)
							tmp40 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(476), kw_column, int(9), kw_end_DASH_line, int(476), kw_end_DASH_column, int(22))
							tmp41, err := lang.WithMeta(tmp39, tmp40.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp37 = tmp41
						} // end let
						tmp36 = tmp37
					} else {
					}
					tmp31 = tmp36
				} // end let
				tmp32 := lang.Apply(tmp13, []any{tmp28, tmp29, tmp30, tmp31})
				tmp3 = tmp32
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_Throwable_DASH__GT_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_Throwable_DASH__GT_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// as->
	{
		tmp0 := sym_as_DASH__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr, sym_name, sym__AMP_, sym_forms)), kw_doc, "Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form.", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(7598), kw_end_DASH_line, int(7598))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 4)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var v6 any = lang.NewList(args[4:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_let})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp13 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v5})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := checkDerefVar(var_glojure_DOT_core_interleave)
				tmp21 := checkDerefVar(var_glojure_DOT_core_repeat)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := checkDerefVar(var_glojure_DOT_core_butlast)
				tmp24 := lang.Apply(tmp23, []any{v6})
				tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
				tmp26 := lang.Apply(tmp15, []any{tmp17, tmp19, tmp25})
				tmp27 := lang.Apply(tmp14, []any{tmp26})
				tmp28 := lang.Apply(tmp12, []any{tmp13, tmp27})
				tmp29 := lang.Apply(tmp11, []any{tmp28})
				tmp30 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp31 any
				tmp32 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
				tmp33 := lang.Apply(tmp32, []any{v6})
				if lang.IsTruthy(tmp33) {
					tmp31 = v5
				} else {
					tmp34 := checkDerefVar(var_glojure_DOT_core_last)
					tmp35 := lang.Apply(tmp34, []any{v6})
					tmp31 = tmp35
				}
				tmp36 := lang.Apply(tmp30, []any{tmp31})
				tmp37 := lang.Apply(tmp8, []any{tmp10, tmp29, tmp36})
				tmp38 := lang.Apply(tmp7, []any{tmp37})
				return tmp38
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_as_DASH__GT_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_as_DASH__GT_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await
	{
		tmp0 := sym_await.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_agents)), kw_doc, "Blocks the current thread (indefinitely!) until all actions\n  dispatched thus far, from this thread or agent, to the agent(s) have\n  occurred.  Will block on failed agents.  Will never return if\n  a failed agent is restarted with :clear-actions true or shutdown-agents was called.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3267), kw_end_DASH_line, int(3267))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				var tmp3 any
				tmp4 := lang.Apply(nil, nil)
				if lang.IsTruthy(tmp4) {
					panic("unimplemented: new with non-constant class type")
				} else {
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_agent_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp7 := lang.Apply(errors8.New, []any{"Can't await in agent action"})
						panic(tmp7)
					} else {
					}
					_ = tmp5
					var tmp8 any
					{ // let
						// let binding "latch"
						var v10 any = nil
						_ = v10
						// let binding "count-down"
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v12 := args[0]
							_ = v12
							tmp13, _ := lang.FieldOrMethod(v10, "countDown")
							if reflect.TypeOf(tmp13).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("countDown is not a function")))
							}
							tmp14 := lang.Apply(tmp13, []any{})
							_ = tmp14
							return v12
						})
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3279), kw_column, int(22), kw_end_DASH_line, int(3279), kw_end_DASH_column, int(61))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v14 any = tmp13
						_ = v14
						var tmp15 any
						{ // let
							// let binding "seq_1"
							tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp17 := lang.Apply(tmp16, []any{v2})
							var v18 any = tmp17
							_ = v18
							// let binding "chunk_2"
							var v19 any = nil
							_ = v19
							// let binding "count_3"
							var v20 any = int64(0)
							_ = v20
							// let binding "i_4"
							var v21 any = int64(0)
							_ = v21
							for {
								var tmp22 any
								tmp23 := checkDerefVar(var_glojure_DOT_core__LT_)
								tmp24 := lang.Apply(tmp23, []any{v21, v20})
								if lang.IsTruthy(tmp24) {
									var tmp25 any
									{ // let
										// let binding "agent"
										tmp26, _ := lang.FieldOrMethod(v19, "nth")
										if reflect.TypeOf(tmp26).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
										}
										tmp27 := lang.Apply(tmp26, []any{v21})
										var v28 any = tmp27
										_ = v28
										tmp29 := checkDerefVar(var_glojure_DOT_core_send)
										tmp30 := lang.Apply(tmp29, []any{v28, v14})
										_ = tmp30
										var tmp31 any = v18
										var tmp32 any = v19
										var tmp33 any = v20
										tmp35 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
										tmp36 := lang.Apply(tmp35, []any{v21})
										var tmp34 any = tmp36
										v18 = tmp31
										v19 = tmp32
										v20 = tmp33
										v21 = tmp34
										continue
									} // end let
									tmp22 = tmp25
								} else {
									var tmp26 any
									{ // let
										// let binding "temp__0__auto__"
										tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp28 := lang.Apply(tmp27, []any{v18})
										var v29 any = tmp28
										_ = v29
										var tmp30 any
										if lang.IsTruthy(v29) {
											var tmp31 any
											{ // let
												// let binding "seq_1"
												var v32 any = v29
												_ = v32
												var tmp33 any
												tmp34 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
												tmp35 := lang.Apply(tmp34, []any{v32})
												if lang.IsTruthy(tmp35) {
													var tmp36 any
													{ // let
														// let binding "c__0__auto__"
														tmp37 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
														tmp38 := lang.Apply(tmp37, []any{v32})
														var v39 any = tmp38
														_ = v39
														tmp41 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
														tmp42 := lang.Apply(tmp41, []any{v32})
														var tmp40 any = tmp42
														var tmp43 any = v39
														tmp45 := checkDerefVar(var_glojure_DOT_core_int)
														tmp46 := checkDerefVar(var_glojure_DOT_core_count)
														tmp47 := lang.Apply(tmp46, []any{v39})
														tmp48 := lang.Apply(tmp45, []any{tmp47})
														var tmp44 any = tmp48
														tmp50 := checkDerefVar(var_glojure_DOT_core_int)
														tmp51 := lang.Apply(tmp50, []any{int64(0)})
														var tmp49 any = tmp51
														v18 = tmp40
														v19 = tmp43
														v20 = tmp44
														v21 = tmp49
														continue
													} // end let
													tmp33 = tmp36
												} else {
													var tmp37 any
													{ // let
														// let binding "agent"
														tmp38 := checkDerefVar(var_glojure_DOT_core_first)
														tmp39 := lang.Apply(tmp38, []any{v32})
														var v40 any = tmp39
														_ = v40
														tmp41 := checkDerefVar(var_glojure_DOT_core_send)
														tmp42 := lang.Apply(tmp41, []any{v40, v14})
														_ = tmp42
														tmp44 := checkDerefVar(var_glojure_DOT_core_next)
														tmp45 := lang.Apply(tmp44, []any{v32})
														var tmp43 any = tmp45
														var tmp46 any = nil
														var tmp47 any = int64(0)
														var tmp48 any = int64(0)
														v18 = tmp43
														v19 = tmp46
														v20 = tmp47
														v21 = tmp48
														continue
													} // end let
													tmp33 = tmp37
												}
												tmp31 = tmp33
											} // end let
											tmp30 = tmp31
										} else {
										}
										tmp26 = tmp30
									} // end let
									tmp22 = tmp26
								}
								tmp15 = tmp22
								break
							}
						} // end let
						_ = tmp15
						tmp16, _ := lang.FieldOrMethod(v10, "await")
						if reflect.TypeOf(tmp16).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
						}
						tmp17 := lang.Apply(tmp16, []any{})
						tmp8 = tmp17
					} // end let
					tmp3 = tmp8
				}
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_await = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_await.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await1
	{
		tmp0 := sym_await1.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(3284), kw_column, int(7), kw_end_DASH_line, int(3284), kw_end_DASH_column, int(21), kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
			tmp5, ok := lang.FieldOrMethod(v2, "getQueueCount")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getQueueCount")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_glojure_DOT_core_await)
				tmp9 := lang.Apply(tmp8, []any{v2})
				tmp3 = tmp9
			} else {
			}
			_ = tmp3
			return v2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_await1 = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_await1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await-for
	{
		tmp0 := sym_await_DASH_for.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_timeout_DASH_ms, sym__AMP_, sym_agents)), kw_doc, "Blocks the current thread until all actions dispatched thus\n  far (from this thread or agent) to the agents have occurred, or the\n  timeout (in milliseconds) has elapsed. Returns logical false if\n  returning due to timeout, logical true otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3289), kw_end_DASH_line, int(3289))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				var tmp4 any
				tmp5 := lang.Apply(nil, nil)
				if lang.IsTruthy(tmp5) {
					panic("unimplemented: new with non-constant class type")
				} else {
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_agent_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp8 := lang.Apply(errors8.New, []any{"Can't await in agent action"})
						panic(tmp8)
					} else {
					}
					_ = tmp6
					var tmp9 any
					{ // let
						// let binding "latch"
						var v11 any = nil
						_ = v11
						// let binding "count-down"
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v13 := args[0]
							_ = v13
							tmp14, _ := lang.FieldOrMethod(v11, "countDown")
							if reflect.TypeOf(tmp14).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("countDown is not a function")))
							}
							tmp15 := lang.Apply(tmp14, []any{})
							_ = tmp15
							return v13
						})
						tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3301), kw_column, int(23), kw_end_DASH_line, int(3301), kw_end_DASH_column, int(62))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						{ // let
							// let binding "seq_5"
							tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp18 := lang.Apply(tmp17, []any{v3})
							var v19 any = tmp18
							_ = v19
							// let binding "chunk_6"
							var v20 any = nil
							_ = v20
							// let binding "count_7"
							var v21 any = int64(0)
							_ = v21
							// let binding "i_8"
							var v22 any = int64(0)
							_ = v22
							for {
								var tmp23 any
								tmp24 := checkDerefVar(var_glojure_DOT_core__LT_)
								tmp25 := lang.Apply(tmp24, []any{v22, v21})
								if lang.IsTruthy(tmp25) {
									var tmp26 any
									{ // let
										// let binding "agent"
										tmp27, _ := lang.FieldOrMethod(v20, "nth")
										if reflect.TypeOf(tmp27).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
										}
										tmp28 := lang.Apply(tmp27, []any{v22})
										var v29 any = tmp28
										_ = v29
										tmp30 := checkDerefVar(var_glojure_DOT_core_send)
										tmp31 := lang.Apply(tmp30, []any{v29, v15})
										_ = tmp31
										var tmp32 any = v19
										var tmp33 any = v20
										var tmp34 any = v21
										tmp36 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
										tmp37 := lang.Apply(tmp36, []any{v22})
										var tmp35 any = tmp37
										v19 = tmp32
										v20 = tmp33
										v21 = tmp34
										v22 = tmp35
										continue
									} // end let
									tmp23 = tmp26
								} else {
									var tmp27 any
									{ // let
										// let binding "temp__0__auto__"
										tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp29 := lang.Apply(tmp28, []any{v19})
										var v30 any = tmp29
										_ = v30
										var tmp31 any
										if lang.IsTruthy(v30) {
											var tmp32 any
											{ // let
												// let binding "seq_5"
												var v33 any = v30
												_ = v33
												var tmp34 any
												tmp35 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
												tmp36 := lang.Apply(tmp35, []any{v33})
												if lang.IsTruthy(tmp36) {
													var tmp37 any
													{ // let
														// let binding "c__0__auto__"
														tmp38 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
														tmp39 := lang.Apply(tmp38, []any{v33})
														var v40 any = tmp39
														_ = v40
														tmp42 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
														tmp43 := lang.Apply(tmp42, []any{v33})
														var tmp41 any = tmp43
														var tmp44 any = v40
														tmp46 := checkDerefVar(var_glojure_DOT_core_int)
														tmp47 := checkDerefVar(var_glojure_DOT_core_count)
														tmp48 := lang.Apply(tmp47, []any{v40})
														tmp49 := lang.Apply(tmp46, []any{tmp48})
														var tmp45 any = tmp49
														tmp51 := checkDerefVar(var_glojure_DOT_core_int)
														tmp52 := lang.Apply(tmp51, []any{int64(0)})
														var tmp50 any = tmp52
														v19 = tmp41
														v20 = tmp44
														v21 = tmp45
														v22 = tmp50
														continue
													} // end let
													tmp34 = tmp37
												} else {
													var tmp38 any
													{ // let
														// let binding "agent"
														tmp39 := checkDerefVar(var_glojure_DOT_core_first)
														tmp40 := lang.Apply(tmp39, []any{v33})
														var v41 any = tmp40
														_ = v41
														tmp42 := checkDerefVar(var_glojure_DOT_core_send)
														tmp43 := lang.Apply(tmp42, []any{v41, v15})
														_ = tmp43
														tmp45 := checkDerefVar(var_glojure_DOT_core_next)
														tmp46 := lang.Apply(tmp45, []any{v33})
														var tmp44 any = tmp46
														var tmp47 any = nil
														var tmp48 any = int64(0)
														var tmp49 any = int64(0)
														v19 = tmp44
														v20 = tmp47
														v21 = tmp48
														v22 = tmp49
														continue
													} // end let
													tmp34 = tmp38
												}
												tmp32 = tmp34
											} // end let
											tmp31 = tmp32
										} else {
										}
										tmp27 = tmp31
									} // end let
									tmp23 = tmp27
								}
								tmp16 = tmp23
								break
							}
						} // end let
						_ = tmp16
						tmp17, ok := lang.FieldOrMethod(nil, "MILLISECONDS")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "MILLISECONDS")))
						}
						var tmp18 any
						switch reflect.TypeOf(tmp17).Kind() {
						case reflect.Func:
							tmp18 = lang.Apply(tmp17, nil)
						default:
							tmp18 = tmp17
						}
						tmp19, _ := lang.FieldOrMethod(v11, "await")
						if reflect.TypeOf(tmp19).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
						}
						tmp20 := lang.Apply(tmp19, []any{v2, tmp18})
						tmp9 = tmp20
					} // end let
					tmp4 = tmp9
				}
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_await_DASH_for = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_await_DASH_for.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// check-cyclic-dependency
	{
		tmp0 := sym_check_DASH_cyclic_DASH_dependency.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_doc, "Detects and rejects non-trivial cyclic load dependencies. The\n  exception message shows the dependency chain with the cycle\n  highlighted. Ignores the trivial case of a file attempting to load\n  itself because that can occur when a gen-class'd class loads its\n  implementation.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(30), kw_column, int(8), kw_line, int(5974), kw_end_DASH_line, int(5974), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_some)
			tmp5 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{v2}))
			tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5981), kw_column, int(15), kw_end_DASH_line, int(5981), kw_end_DASH_column, int(21))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp8 := checkDerefVar(var_glojure_DOT_core_rest)
			tmp9 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
			tmp10 := lang.Apply(tmp8, []any{tmp9})
			tmp11 := lang.Apply(tmp4, []any{tmp7, tmp10})
			if lang.IsTruthy(tmp11) {
				var tmp12 any
				{ // let
					// let binding "pending"
					tmp13 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v15 := args[0]
						_ = v15
						var tmp16 any
						tmp17 := checkDerefVar(var_glojure_DOT_core__EQ_)
						tmp18 := lang.Apply(tmp17, []any{v15, v2})
						if lang.IsTruthy(tmp18) {
							tmp19 := checkDerefVar(var_glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{"[ ", v15, " ]"})
							tmp16 = tmp20
						} else {
							tmp16 = v15
						}
						return tmp16
					})
					tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5982), kw_column, int(24), kw_end_DASH_line, int(5982), kw_end_DASH_column, int(59))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp18 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
					tmp19 := lang.Apply(tmp17, []any{v2, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp16, tmp19})
					var v21 any = tmp20
					_ = v21
					// let binding "chain"
					tmp22 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_interpose)
					tmp25 := lang.Apply(tmp24, []any{"->", v21})
					tmp26 := lang.Apply(tmp22, []any{tmp23, tmp25})
					var v27 any = tmp26
					_ = v27
					tmp28 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
					tmp29 := lang.Apply(tmp28, []any{true, "Cyclic load dependency: %s", v27})
					tmp12 = tmp29
				} // end let
				tmp3 = tmp12
			} else {
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_check_DASH_cyclic_DASH_dependency = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_check_DASH_cyclic_DASH_dependency.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond->
	{
		tmp0 := sym_cond_DASH__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr, sym__AMP_, sym_clauses)), kw_doc, "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression.", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(7564), kw_end_DASH_line, int(7564))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "g"
					tmp7 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp8 := lang.Apply(tmp7, nil)
					var v9 any = tmp8
					_ = v9
					// let binding "steps"
					tmp10 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v12 := args[0]
						_ = v12
						var tmp13 any
						{ // let
							// let binding "vec__349"
							var v14 any = v12
							_ = v14
							// let binding "test"
							tmp15 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
							var v17 any = tmp16
							_ = v17
							// let binding "step"
							tmp18 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp19 := lang.Apply(tmp18, []any{v14, int64(1), nil})
							var v20 any = tmp19
							_ = v20
							tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp22 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp23 := checkDerefVar(var_glojure_DOT_core_list)
							tmp24 := lang.Apply(tmp23, []any{sym_if})
							tmp25 := checkDerefVar(var_glojure_DOT_core_list)
							tmp26 := lang.Apply(tmp25, []any{v17})
							tmp27 := checkDerefVar(var_glojure_DOT_core_list)
							tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp29 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp30 := checkDerefVar(var_glojure_DOT_core_list)
							tmp31 := lang.Apply(tmp30, []any{sym_glojure_DOT_core_SLASH__DASH__GT_})
							tmp32 := checkDerefVar(var_glojure_DOT_core_list)
							tmp33 := lang.Apply(tmp32, []any{v9})
							tmp34 := checkDerefVar(var_glojure_DOT_core_list)
							tmp35 := lang.Apply(tmp34, []any{v20})
							tmp36 := lang.Apply(tmp29, []any{tmp31, tmp33, tmp35})
							tmp37 := lang.Apply(tmp28, []any{tmp36})
							tmp38 := lang.Apply(tmp27, []any{tmp37})
							tmp39 := checkDerefVar(var_glojure_DOT_core_list)
							tmp40 := lang.Apply(tmp39, []any{v9})
							tmp41 := lang.Apply(tmp22, []any{tmp24, tmp26, tmp38, tmp40})
							tmp42 := lang.Apply(tmp21, []any{tmp41})
							tmp13 = tmp42
						} // end let
						return tmp13
					})
					tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7573), kw_column, int(20), kw_end_DASH_line, int(7573), kw_end_DASH_column, int(66))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp14 := checkDerefVar(var_glojure_DOT_core_partition)
					tmp15 := lang.Apply(tmp14, []any{int64(2), v5})
					tmp16 := lang.Apply(tmp10, []any{tmp13, tmp15})
					var v17 any = tmp16
					_ = v17
					tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := lang.Apply(tmp20, []any{sym_glojure_DOT_core_SLASH_let})
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp24 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp27 := checkDerefVar(var_glojure_DOT_core_list)
					tmp28 := lang.Apply(tmp27, []any{v9})
					tmp29 := checkDerefVar(var_glojure_DOT_core_list)
					tmp30 := lang.Apply(tmp29, []any{v4})
					tmp31 := checkDerefVar(var_glojure_DOT_core_interleave)
					tmp32 := checkDerefVar(var_glojure_DOT_core_repeat)
					tmp33 := lang.Apply(tmp32, []any{v9})
					tmp34 := checkDerefVar(var_glojure_DOT_core_butlast)
					tmp35 := lang.Apply(tmp34, []any{v17})
					tmp36 := lang.Apply(tmp31, []any{tmp33, tmp35})
					tmp37 := lang.Apply(tmp26, []any{tmp28, tmp30, tmp36})
					tmp38 := lang.Apply(tmp25, []any{tmp37})
					tmp39 := lang.Apply(tmp23, []any{tmp24, tmp38})
					tmp40 := lang.Apply(tmp22, []any{tmp39})
					tmp41 := checkDerefVar(var_glojure_DOT_core_list)
					var tmp42 any
					tmp43 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
					tmp44 := lang.Apply(tmp43, []any{v17})
					if lang.IsTruthy(tmp44) {
						tmp42 = v9
					} else {
						tmp45 := checkDerefVar(var_glojure_DOT_core_last)
						tmp46 := lang.Apply(tmp45, []any{v17})
						tmp42 = tmp46
					}
					tmp47 := lang.Apply(tmp41, []any{tmp42})
					tmp48 := lang.Apply(tmp19, []any{tmp21, tmp40, tmp47})
					tmp49 := lang.Apply(tmp18, []any{tmp48})
					tmp6 = tmp49
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_cond_DASH__GT_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_cond_DASH__GT_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond->>
	{
		tmp0 := sym_cond_DASH__GT__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr, sym__AMP_, sym_clauses)), kw_doc, "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression.", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(7581), kw_end_DASH_line, int(7581))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "g"
					tmp7 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp8 := lang.Apply(tmp7, nil)
					var v9 any = tmp8
					_ = v9
					// let binding "steps"
					tmp10 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v12 := args[0]
						_ = v12
						var tmp13 any
						{ // let
							// let binding "vec__353"
							var v14 any = v12
							_ = v14
							// let binding "test"
							tmp15 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
							var v17 any = tmp16
							_ = v17
							// let binding "step"
							tmp18 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp19 := lang.Apply(tmp18, []any{v14, int64(1), nil})
							var v20 any = tmp19
							_ = v20
							tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp22 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp23 := checkDerefVar(var_glojure_DOT_core_list)
							tmp24 := lang.Apply(tmp23, []any{sym_if})
							tmp25 := checkDerefVar(var_glojure_DOT_core_list)
							tmp26 := lang.Apply(tmp25, []any{v17})
							tmp27 := checkDerefVar(var_glojure_DOT_core_list)
							tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp29 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp30 := checkDerefVar(var_glojure_DOT_core_list)
							tmp31 := lang.Apply(tmp30, []any{sym_glojure_DOT_core_SLASH__DASH__GT__GT_})
							tmp32 := checkDerefVar(var_glojure_DOT_core_list)
							tmp33 := lang.Apply(tmp32, []any{v9})
							tmp34 := checkDerefVar(var_glojure_DOT_core_list)
							tmp35 := lang.Apply(tmp34, []any{v20})
							tmp36 := lang.Apply(tmp29, []any{tmp31, tmp33, tmp35})
							tmp37 := lang.Apply(tmp28, []any{tmp36})
							tmp38 := lang.Apply(tmp27, []any{tmp37})
							tmp39 := checkDerefVar(var_glojure_DOT_core_list)
							tmp40 := lang.Apply(tmp39, []any{v9})
							tmp41 := lang.Apply(tmp22, []any{tmp24, tmp26, tmp38, tmp40})
							tmp42 := lang.Apply(tmp21, []any{tmp41})
							tmp13 = tmp42
						} // end let
						return tmp13
					})
					tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7590), kw_column, int(20), kw_end_DASH_line, int(7590), kw_end_DASH_column, int(67))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp14 := checkDerefVar(var_glojure_DOT_core_partition)
					tmp15 := lang.Apply(tmp14, []any{int64(2), v5})
					tmp16 := lang.Apply(tmp10, []any{tmp13, tmp15})
					var v17 any = tmp16
					_ = v17
					tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := lang.Apply(tmp20, []any{sym_glojure_DOT_core_SLASH_let})
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp24 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp27 := checkDerefVar(var_glojure_DOT_core_list)
					tmp28 := lang.Apply(tmp27, []any{v9})
					tmp29 := checkDerefVar(var_glojure_DOT_core_list)
					tmp30 := lang.Apply(tmp29, []any{v4})
					tmp31 := checkDerefVar(var_glojure_DOT_core_interleave)
					tmp32 := checkDerefVar(var_glojure_DOT_core_repeat)
					tmp33 := lang.Apply(tmp32, []any{v9})
					tmp34 := checkDerefVar(var_glojure_DOT_core_butlast)
					tmp35 := lang.Apply(tmp34, []any{v17})
					tmp36 := lang.Apply(tmp31, []any{tmp33, tmp35})
					tmp37 := lang.Apply(tmp26, []any{tmp28, tmp30, tmp36})
					tmp38 := lang.Apply(tmp25, []any{tmp37})
					tmp39 := lang.Apply(tmp23, []any{tmp24, tmp38})
					tmp40 := lang.Apply(tmp22, []any{tmp39})
					tmp41 := checkDerefVar(var_glojure_DOT_core_list)
					var tmp42 any
					tmp43 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
					tmp44 := lang.Apply(tmp43, []any{v17})
					if lang.IsTruthy(tmp44) {
						tmp42 = v9
					} else {
						tmp45 := checkDerefVar(var_glojure_DOT_core_last)
						tmp46 := lang.Apply(tmp45, []any{v17})
						tmp42 = tmp46
					}
					tmp47 := lang.Apply(tmp41, []any{tmp42})
					tmp48 := lang.Apply(tmp19, []any{tmp21, tmp40, tmp47})
					tmp49 := lang.Apply(tmp18, []any{tmp48})
					tmp6 = tmp49
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_cond_DASH__GT__GT_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_cond_DASH__GT__GT_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// condp
	{
		tmp0 := sym_condp.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_expr, sym__AMP_, sym_clauses)), kw_doc, "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(6353), kw_end_DASH_line, int(6353))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 4)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var v6 any = lang.NewList(args[4:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "gpred"
					tmp8 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, []any{"pred__"})
					var v10 any = tmp9
					_ = v10
					// let binding "gexpr"
					tmp11 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp12 := lang.Apply(tmp11, []any{"expr__"})
					var v13 any = tmp12
					_ = v13
					// let binding "emit"
					var tmp14 lang.FnFunc
					{ // function emit
						var v15 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 3)
							v16 := args[0]
							_ = v16
							v17 := args[1]
							_ = v17
							v18 := args[2]
							_ = v18
							var tmp19 any
							{ // let
								// let binding "vec__144"
								tmp20 := checkDerefVar(var_glojure_DOT_core_split_DASH_at)
								var tmp21 any
								tmp22 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp23 := checkDerefVar(var_glojure_DOT_core_second)
								tmp24 := lang.Apply(tmp23, []any{v18})
								tmp25 := lang.Apply(tmp22, []any{kw__GT__GT_, tmp24})
								if lang.IsTruthy(tmp25) {
									tmp21 = int64(3)
								} else {
									tmp21 = int64(2)
								}
								tmp26 := lang.Apply(tmp20, []any{tmp21, v18})
								var v27 any = tmp26
								_ = v27
								// let binding "vec__147"
								tmp28 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp29 := lang.Apply(tmp28, []any{v27, int64(0), nil})
								var v30 any = tmp29
								_ = v30
								// let binding "a"
								tmp31 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp32 := lang.Apply(tmp31, []any{v30, int64(0), nil})
								var v33 any = tmp32
								_ = v33
								// let binding "b"
								tmp34 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp35 := lang.Apply(tmp34, []any{v30, int64(1), nil})
								var v36 any = tmp35
								_ = v36
								// let binding "c"
								tmp37 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp38 := lang.Apply(tmp37, []any{v30, int64(2), nil})
								var v39 any = tmp38
								_ = v39
								// let binding "clause"
								var v40 any = v30
								_ = v40
								// let binding "more"
								tmp41 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp42 := lang.Apply(tmp41, []any{v27, int64(1), nil})
								var v43 any = tmp42
								_ = v43
								// let binding "n"
								tmp44 := checkDerefVar(var_glojure_DOT_core_count)
								tmp45 := lang.Apply(tmp44, []any{v40})
								var v46 any = tmp45
								_ = v46
								var tmp47 any
								tmp48 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp49 := lang.Apply(tmp48, []any{int64(0), v46})
								if lang.IsTruthy(tmp49) {
									tmp50 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp51 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp52 := checkDerefVar(var_glojure_DOT_core_list)
									tmp53 := lang.Apply(tmp52, []any{sym_throw})
									tmp54 := checkDerefVar(var_glojure_DOT_core_list)
									tmp55 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp56 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp57 := checkDerefVar(var_glojure_DOT_core_list)
									tmp58 := lang.Apply(tmp57, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewIllegalArgumentError})
									tmp59 := checkDerefVar(var_glojure_DOT_core_list)
									tmp60 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp61 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp62 := checkDerefVar(var_glojure_DOT_core_list)
									tmp63 := lang.Apply(tmp62, []any{sym_glojure_DOT_core_SLASH_str})
									tmp64 := checkDerefVar(var_glojure_DOT_core_list)
									tmp65 := lang.Apply(tmp64, []any{"No matching clause: "})
									tmp66 := checkDerefVar(var_glojure_DOT_core_list)
									tmp67 := lang.Apply(tmp66, []any{v17})
									tmp68 := lang.Apply(tmp61, []any{tmp63, tmp65, tmp67})
									tmp69 := lang.Apply(tmp60, []any{tmp68})
									tmp70 := lang.Apply(tmp59, []any{tmp69})
									tmp71 := lang.Apply(tmp56, []any{tmp58, tmp70})
									tmp72 := lang.Apply(tmp55, []any{tmp71})
									tmp73 := lang.Apply(tmp54, []any{tmp72})
									tmp74 := lang.Apply(tmp51, []any{tmp53, tmp73})
									tmp75 := lang.Apply(tmp50, []any{tmp74})
									tmp47 = tmp75
								} else {
									var tmp76 any
									tmp77 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp78 := lang.Apply(tmp77, []any{int64(1), v46})
									if lang.IsTruthy(tmp78) {
										tmp76 = v33
									} else {
										var tmp79 any
										tmp80 := checkDerefVar(var_glojure_DOT_core__EQ_)
										tmp81 := lang.Apply(tmp80, []any{int64(2), v46})
										if lang.IsTruthy(tmp81) {
											tmp82 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp83 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp84 := checkDerefVar(var_glojure_DOT_core_list)
											tmp85 := lang.Apply(tmp84, []any{sym_if})
											tmp86 := checkDerefVar(var_glojure_DOT_core_list)
											tmp87 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp88 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp89 := checkDerefVar(var_glojure_DOT_core_list)
											tmp90 := lang.Apply(tmp89, []any{v16})
											tmp91 := checkDerefVar(var_glojure_DOT_core_list)
											tmp92 := lang.Apply(tmp91, []any{v33})
											tmp93 := checkDerefVar(var_glojure_DOT_core_list)
											tmp94 := lang.Apply(tmp93, []any{v17})
											tmp95 := lang.Apply(tmp88, []any{tmp90, tmp92, tmp94})
											tmp96 := lang.Apply(tmp87, []any{tmp95})
											tmp97 := lang.Apply(tmp86, []any{tmp96})
											tmp98 := checkDerefVar(var_glojure_DOT_core_list)
											tmp99 := lang.Apply(tmp98, []any{v36})
											tmp100 := checkDerefVar(var_glojure_DOT_core_list)
											tmp101 := lang.Apply(v15, []any{v16, v17, v43})
											tmp102 := lang.Apply(tmp100, []any{tmp101})
											tmp103 := lang.Apply(tmp83, []any{tmp85, tmp97, tmp99, tmp102})
											tmp104 := lang.Apply(tmp82, []any{tmp103})
											tmp79 = tmp104
										} else {
											var tmp105 any
											if lang.IsTruthy(kw_else) {
												tmp106 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp107 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp108 := checkDerefVar(var_glojure_DOT_core_list)
												tmp109 := lang.Apply(tmp108, []any{sym_glojure_DOT_core_SLASH_if_DASH_let})
												tmp110 := checkDerefVar(var_glojure_DOT_core_list)
												tmp111 := checkDerefVar(var_glojure_DOT_core_apply)
												tmp112 := checkDerefVar(var_glojure_DOT_core_vector)
												tmp113 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp114 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp115 := checkDerefVar(var_glojure_DOT_core_list)
												tmp116 := lang.Apply(tmp115, []any{sym_p__0__auto__})
												tmp117 := checkDerefVar(var_glojure_DOT_core_list)
												tmp118 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp119 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp120 := checkDerefVar(var_glojure_DOT_core_list)
												tmp121 := lang.Apply(tmp120, []any{v16})
												tmp122 := checkDerefVar(var_glojure_DOT_core_list)
												tmp123 := lang.Apply(tmp122, []any{v33})
												tmp124 := checkDerefVar(var_glojure_DOT_core_list)
												tmp125 := lang.Apply(tmp124, []any{v17})
												tmp126 := lang.Apply(tmp119, []any{tmp121, tmp123, tmp125})
												tmp127 := lang.Apply(tmp118, []any{tmp126})
												tmp128 := lang.Apply(tmp117, []any{tmp127})
												tmp129 := lang.Apply(tmp114, []any{tmp116, tmp128})
												tmp130 := lang.Apply(tmp113, []any{tmp129})
												tmp131 := lang.Apply(tmp111, []any{tmp112, tmp130})
												tmp132 := lang.Apply(tmp110, []any{tmp131})
												tmp133 := checkDerefVar(var_glojure_DOT_core_list)
												tmp134 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp135 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp136 := checkDerefVar(var_glojure_DOT_core_list)
												tmp137 := lang.Apply(tmp136, []any{v39})
												tmp138 := checkDerefVar(var_glojure_DOT_core_list)
												tmp139 := lang.Apply(tmp138, []any{sym_p__0__auto__})
												tmp140 := lang.Apply(tmp135, []any{tmp137, tmp139})
												tmp141 := lang.Apply(tmp134, []any{tmp140})
												tmp142 := lang.Apply(tmp133, []any{tmp141})
												tmp143 := checkDerefVar(var_glojure_DOT_core_list)
												tmp144 := lang.Apply(v15, []any{v16, v17, v43})
												tmp145 := lang.Apply(tmp143, []any{tmp144})
												tmp146 := lang.Apply(tmp107, []any{tmp109, tmp132, tmp142, tmp145})
												tmp147 := lang.Apply(tmp106, []any{tmp146})
												tmp105 = tmp147
											} else {
											}
											tmp79 = tmp105
										}
										tmp76 = tmp79
									}
									tmp47 = tmp76
								}
								tmp19 = tmp47
							} // end let
							return tmp19
						})
						v15 = tmp14
						_ = v15
					}
					tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6377), kw_column, int(14), kw_end_DASH_line, int(6389), kw_end_DASH_column, int(53))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v17 any = tmp16
					_ = v17
					tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := lang.Apply(tmp20, []any{sym_glojure_DOT_core_SLASH_let})
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp24 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp27 := checkDerefVar(var_glojure_DOT_core_list)
					tmp28 := lang.Apply(tmp27, []any{v10})
					tmp29 := checkDerefVar(var_glojure_DOT_core_list)
					tmp30 := lang.Apply(tmp29, []any{v4})
					tmp31 := checkDerefVar(var_glojure_DOT_core_list)
					tmp32 := lang.Apply(tmp31, []any{v13})
					tmp33 := checkDerefVar(var_glojure_DOT_core_list)
					tmp34 := lang.Apply(tmp33, []any{v5})
					tmp35 := lang.Apply(tmp26, []any{tmp28, tmp30, tmp32, tmp34})
					tmp36 := lang.Apply(tmp25, []any{tmp35})
					tmp37 := lang.Apply(tmp23, []any{tmp24, tmp36})
					tmp38 := lang.Apply(tmp22, []any{tmp37})
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					tmp40 := lang.Apply(v17, []any{v10, v13, v6})
					tmp41 := lang.Apply(tmp39, []any{tmp40})
					tmp42 := lang.Apply(tmp19, []any{tmp21, tmp38, tmp41})
					tmp43 := lang.Apply(tmp18, []any{tmp42})
					tmp7 = tmp43
				} // end let
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_condp = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_condp.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defn
	{
		tmp0 := sym_defn.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_doc_DASH_string_QMARK_, sym_attr_DASH_map_QMARK_, lang.NewVector(sym_params_STAR_), sym_prepost_DASH_map_QMARK_, sym_body), lang.NewVector(sym_name, sym_doc_DASH_string_QMARK_, sym_attr_DASH_map_QMARK_, lang.NewList(lang.NewVector(sym_params_STAR_), sym_prepost_DASH_map_QMARK_, sym_body), sym__PLUS_, sym_attr_DASH_map_QMARK_)), kw_doc, "Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(284), kw_end_DASH_line, int(291))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		{ // function defn
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArityGTE(args, 3)
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					v5 := args[2]
					_ = v5
					var v6 any = lang.NewList(args[3:]...)
					_ = v6
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp9 := reflect.TypeOf((*lang.Symbol)(nil))
					tmp10 := lang.Apply(tmp8, []any{tmp9, v5})
					if lang.IsTruthy(tmp10) {
					} else {
						tmp11 := lang.Apply(lang.NewIllegalArgumentError, []any{"First argument to defn must be a symbol"})
						panic(tmp11)
					}
					_ = tmp7
					var tmp12 any
					{ // let
						// let binding "m"
						var tmp13 any
						tmp14 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
						tmp15 := checkDerefVar(var_glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v6})
						tmp17 := lang.Apply(tmp14, []any{tmp16})
						if lang.IsTruthy(tmp17) {
							tmp18 := checkDerefVar(var_glojure_DOT_core_first)
							tmp19 := lang.Apply(tmp18, []any{v6})
							tmp20 := lang.NewMap(kw_doc, tmp19)
							tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(297), kw_column, int(19), kw_end_DASH_line, int(297), kw_end_DASH_column, int(38))
							tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp13 = tmp22
						} else {
							tmp23 := lang.NewMap()
							tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(298), kw_column, int(19), kw_end_DASH_line, int(298), kw_end_DASH_column, int(20))
							tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp13 = tmp25
						}
						var v26 any = tmp13
						_ = v26
						// let binding "fdecl"
						var tmp27 any
						tmp28 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
						tmp29 := checkDerefVar(var_glojure_DOT_core_first)
						tmp30 := lang.Apply(tmp29, []any{v6})
						tmp31 := lang.Apply(tmp28, []any{tmp30})
						if lang.IsTruthy(tmp31) {
							tmp32 := checkDerefVar(var_glojure_DOT_core_next)
							tmp33 := lang.Apply(tmp32, []any{v6})
							tmp27 = tmp33
						} else {
							tmp27 = v6
						}
						var v34 any = tmp27
						_ = v34
						// let binding "m"
						var tmp35 any
						tmp36 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
						tmp37 := checkDerefVar(var_glojure_DOT_core_first)
						tmp38 := lang.Apply(tmp37, []any{v34})
						tmp39 := lang.Apply(tmp36, []any{tmp38})
						if lang.IsTruthy(tmp39) {
							tmp40 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp41 := checkDerefVar(var_glojure_DOT_core_first)
							tmp42 := lang.Apply(tmp41, []any{v34})
							tmp43 := lang.Apply(tmp40, []any{v26, tmp42})
							tmp35 = tmp43
						} else {
							tmp35 = v26
						}
						var v44 any = tmp35
						_ = v44
						// let binding "fdecl"
						var tmp45 any
						tmp46 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
						tmp47 := checkDerefVar(var_glojure_DOT_core_first)
						tmp48 := lang.Apply(tmp47, []any{v34})
						tmp49 := lang.Apply(tmp46, []any{tmp48})
						if lang.IsTruthy(tmp49) {
							tmp50 := checkDerefVar(var_glojure_DOT_core_next)
							tmp51 := lang.Apply(tmp50, []any{v34})
							tmp45 = tmp51
						} else {
							tmp45 = v34
						}
						var v52 any = tmp45
						_ = v52
						// let binding "fdecl"
						var tmp53 any
						tmp54 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
						tmp55 := checkDerefVar(var_glojure_DOT_core_first)
						tmp56 := lang.Apply(tmp55, []any{v52})
						tmp57 := lang.Apply(tmp54, []any{tmp56})
						if lang.IsTruthy(tmp57) {
							tmp58 := checkDerefVar(var_glojure_DOT_core_list)
							tmp59 := lang.Apply(tmp58, []any{v52})
							tmp53 = tmp59
						} else {
							tmp53 = v52
						}
						var v60 any = tmp53
						_ = v60
						// let binding "m"
						var tmp61 any
						tmp62 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
						tmp63 := checkDerefVar(var_glojure_DOT_core_last)
						tmp64 := lang.Apply(tmp63, []any{v60})
						tmp65 := lang.Apply(tmp62, []any{tmp64})
						if lang.IsTruthy(tmp65) {
							tmp66 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp67 := checkDerefVar(var_glojure_DOT_core_last)
							tmp68 := lang.Apply(tmp67, []any{v60})
							tmp69 := lang.Apply(tmp66, []any{v44, tmp68})
							tmp61 = tmp69
						} else {
							tmp61 = v44
						}
						var v70 any = tmp61
						_ = v70
						// let binding "fdecl"
						var tmp71 any
						tmp72 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
						tmp73 := checkDerefVar(var_glojure_DOT_core_last)
						tmp74 := lang.Apply(tmp73, []any{v60})
						tmp75 := lang.Apply(tmp72, []any{tmp74})
						if lang.IsTruthy(tmp75) {
							tmp76 := checkDerefVar(var_glojure_DOT_core_butlast)
							tmp77 := lang.Apply(tmp76, []any{v60})
							tmp71 = tmp77
						} else {
							tmp71 = v60
						}
						var v78 any = tmp71
						_ = v78
						// let binding "m"
						tmp79 := checkDerefVar(var_glojure_DOT_core_conj)
						tmp80 := checkDerefVar(var_glojure_DOT_core_list)
						tmp81 := checkDerefVar(var_glojure_DOT_core_sigs)
						tmp82 := lang.Apply(tmp81, []any{v78})
						tmp83 := lang.Apply(tmp80, []any{sym_quote, tmp82})
						tmp84 := lang.NewMap(kw_arglists, tmp83)
						tmp85 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(317), kw_column, int(23), kw_end_DASH_line, int(317), kw_end_DASH_column, int(60))
						tmp86, err := lang.WithMeta(tmp84, tmp85.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp87 := lang.Apply(tmp79, []any{tmp86, v70})
						var v88 any = tmp87
						_ = v88
						// let binding "m"
						var tmp89 any
						{ // let
							// let binding "inline"
							tmp90 := lang.Apply(kw_inline, []any{v88})
							var v91 any = tmp90
							_ = v91
							// let binding "ifn"
							tmp92 := checkDerefVar(var_glojure_DOT_core_first)
							tmp93 := lang.Apply(tmp92, []any{v91})
							var v94 any = tmp93
							_ = v94
							// let binding "iname"
							tmp95 := checkDerefVar(var_glojure_DOT_core_second)
							tmp96 := lang.Apply(tmp95, []any{v91})
							var v97 any = tmp96
							_ = v97
							var tmp98 any
							var tmp99 any
							tmp100 := lang.Apply(lang.Equiv, []any{sym_fn, v94})
							if lang.IsTruthy(tmp100) {
								var tmp101 any
								tmp102 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
								tmp103 := reflect.TypeOf((*lang.Symbol)(nil))
								tmp104 := lang.Apply(tmp102, []any{tmp103, v97})
								if lang.IsTruthy(tmp104) {
									tmp101 = false
								} else {
									tmp101 = true
								}
								tmp99 = tmp101
							} else {
							}
							if lang.IsTruthy(tmp99) {
								tmp105 := checkDerefVar(var_glojure_DOT_core_assoc)
								tmp106 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp107 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp108, ok := lang.FieldOrMethod(v5, "Name")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "Name")))
								}
								var tmp109 any
								switch reflect.TypeOf(tmp108).Kind() {
								case reflect.Func:
									tmp109 = lang.Apply(tmp108, nil)
								default:
									tmp109 = tmp108
								}
								tmp110 := lang.Apply(lang.ConcatStrings, []any{tmp109, "__inliner"})
								tmp111 := lang.Apply(lang.NewSymbol, []any{tmp110})
								tmp112 := checkDerefVar(var_glojure_DOT_core_next)
								tmp113 := lang.Apply(tmp112, []any{v91})
								tmp114 := lang.Apply(tmp107, []any{tmp111, tmp113})
								tmp115 := lang.Apply(tmp106, []any{v94, tmp114})
								tmp116 := lang.Apply(tmp105, []any{v88, kw_inline, tmp115})
								tmp98 = tmp116
							} else {
								tmp98 = v88
							}
							tmp89 = tmp98
						} // end let
						var v90 any = tmp89
						_ = v90
						// let binding "m"
						tmp91 := checkDerefVar(var_glojure_DOT_core_conj)
						var tmp92 any
						tmp93 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp94 := lang.Apply(tmp93, []any{v5})
						if lang.IsTruthy(tmp94) {
							tmp95 := checkDerefVar(var_glojure_DOT_core_meta)
							tmp96 := lang.Apply(tmp95, []any{v5})
							tmp92 = tmp96
						} else {
							tmp97 := lang.NewMap()
							tmp98 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(328), kw_column, int(51), kw_end_DASH_line, int(328), kw_end_DASH_column, int(52))
							tmp99, err := lang.WithMeta(tmp97, tmp98.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp92 = tmp99
						}
						tmp100 := lang.Apply(tmp91, []any{tmp92, v90})
						var v101 any = tmp100
						_ = v101
						tmp102 := checkDerefVar(var_glojure_DOT_core_list)
						tmp103 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
						tmp104 := lang.Apply(tmp103, []any{v5, v101})
						tmp105 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
						tmp106 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp107 := lang.Apply(tmp106, []any{sym_glojure_DOT_core_SLASH_fn, v78})
						tmp108 := lang.Apply(kw_tag, []any{v101})
						tmp109 := lang.NewMap(kw_rettag, tmp108)
						tmp110 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(333), kw_column, int(37), kw_end_DASH_line, int(333), kw_end_DASH_column, int(54))
						tmp111, err := lang.WithMeta(tmp109, tmp110.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp112 := lang.Apply(tmp105, []any{tmp107, tmp111})
						tmp113 := lang.Apply(tmp102, []any{sym_def, tmp104, tmp112})
						tmp12 = tmp113
					} // end let
					return tmp12
				}
			})
			tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(291), kw_column, int(7), kw_end_DASH_line, int(333), kw_end_DASH_column, int(58))).(lang.FnFunc)
			v2 = tmp1
			_ = v2
		}
		var_glojure_DOT_core_defn = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_defn.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// destructure
	{
		tmp0 := sym_destructure.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4400), kw_column, int(7), kw_end_DASH_line, int(4400), kw_end_DASH_column, int(17), kw_arglists, lang.NewList(lang.NewVector(sym_bindings)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "bents"
				tmp4 := checkDerefVar(var_glojure_DOT_core_partition)
				tmp5 := lang.Apply(tmp4, []any{int64(2), v2})
				var v6 any = tmp5
				_ = v6
				// let binding "pb"
				var tmp7 lang.FnFunc
				{ // function pb
					var v8 lang.FnFunc
					tmp7 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 3)
						v9 := args[0]
						_ = v9
						v10 := args[1]
						_ = v10
						v11 := args[2]
						_ = v11
						var tmp12 any
						{ // let
							// let binding "pvec"
							var tmp13 lang.FnFunc
							tmp13 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 3)
								v14 := args[0]
								_ = v14
								v15 := args[1]
								_ = v15
								v16 := args[2]
								_ = v16
								var tmp17 any
								{ // let
									// let binding "gvec"
									tmp18 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp19 := lang.Apply(tmp18, []any{"vec__"})
									var v20 any = tmp19
									_ = v20
									// let binding "gseq"
									tmp21 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp22 := lang.Apply(tmp21, []any{"seq__"})
									var v23 any = tmp22
									_ = v23
									// let binding "gfirst"
									tmp24 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp25 := lang.Apply(tmp24, []any{"first__"})
									var v26 any = tmp25
									_ = v26
									// let binding "has-rest"
									tmp27 := checkDerefVar(var_glojure_DOT_core_some)
									tmp28 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{sym__AMP_}))
									tmp29 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4408), kw_column, int(43), kw_end_DASH_line, int(4408), kw_end_DASH_column, int(47))
									tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp31 := lang.Apply(tmp27, []any{tmp30, v15})
									var v32 any = tmp31
									_ = v32
									var tmp33 any
									{ // let
										// let binding "ret"
										var tmp34 any
										{ // let
											// let binding "ret"
											tmp35 := checkDerefVar(var_glojure_DOT_core_conj)
											tmp36 := lang.Apply(tmp35, []any{v14, v20, v16})
											var v37 any = tmp36
											_ = v37
											var tmp38 any
											if lang.IsTruthy(v32) {
												tmp39 := checkDerefVar(var_glojure_DOT_core_conj)
												tmp40 := checkDerefVar(var_glojure_DOT_core_list)
												tmp41 := lang.Apply(tmp40, []any{sym_glojure_DOT_core_SLASH_seq, v20})
												tmp42 := lang.Apply(tmp39, []any{v37, v23, tmp41})
												tmp38 = tmp42
											} else {
												tmp38 = v37
											}
											tmp34 = tmp38
										} // end let
										var v35 any = tmp34
										_ = v35
										// let binding "n"
										var v36 any = int64(0)
										_ = v36
										// let binding "bs"
										var v37 any = v15
										_ = v37
										// let binding "seen-rest?"
										var v38 any = false
										_ = v38
										for {
											var tmp39 any
											tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp41 := lang.Apply(tmp40, []any{v37})
											if lang.IsTruthy(tmp41) {
												var tmp42 any
												{ // let
													// let binding "firstb"
													tmp43 := checkDerefVar(var_glojure_DOT_core_first)
													tmp44 := lang.Apply(tmp43, []any{v37})
													var v45 any = tmp44
													_ = v45
													var tmp46 any
													tmp47 := checkDerefVar(var_glojure_DOT_core__EQ_)
													tmp48 := lang.Apply(tmp47, []any{v45, sym__AMP_})
													if lang.IsTruthy(tmp48) {
														tmp50 := checkDerefVar(var_glojure_DOT_core_second)
														tmp51 := lang.Apply(tmp50, []any{v37})
														tmp52 := lang.Apply(v8, []any{v35, tmp51, v23})
														var tmp49 any = tmp52
														var tmp53 any = v36
														tmp55 := checkDerefVar(var_glojure_DOT_core_nnext)
														tmp56 := lang.Apply(tmp55, []any{v37})
														var tmp54 any = tmp56
														var tmp57 any = true
														v35 = tmp49
														v36 = tmp53
														v37 = tmp54
														v38 = tmp57
														continue
													} else {
														var tmp58 any
														tmp59 := checkDerefVar(var_glojure_DOT_core__EQ_)
														tmp60 := lang.Apply(tmp59, []any{v45, kw_as})
														if lang.IsTruthy(tmp60) {
															tmp61 := checkDerefVar(var_glojure_DOT_core_second)
															tmp62 := lang.Apply(tmp61, []any{v37})
															tmp63 := lang.Apply(v8, []any{v35, tmp62, v20})
															tmp58 = tmp63
														} else {
															var tmp64 any
															if lang.IsTruthy(kw_else) {
																var tmp65 any
																if lang.IsTruthy(v38) {
																	tmp66 := lang.Apply(errors8.New, []any{"Unsupported binding form, only :as can follow & parameter"})
																	panic(tmp66)
																} else {
																	var tmp68 any
																	if lang.IsTruthy(v32) {
																		tmp69 := checkDerefVar(var_glojure_DOT_core_conj)
																		tmp70 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp71 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp72 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp73 := lang.Apply(tmp72, []any{sym_glojure_DOT_core_SLASH_first})
																		tmp74 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp75 := lang.Apply(tmp74, []any{v23})
																		tmp76 := lang.Apply(tmp71, []any{tmp73, tmp75})
																		tmp77 := lang.Apply(tmp70, []any{tmp76})
																		tmp78 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp79 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp80 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp81 := lang.Apply(tmp80, []any{sym_glojure_DOT_core_SLASH_next})
																		tmp82 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp83 := lang.Apply(tmp82, []any{v23})
																		tmp84 := lang.Apply(tmp79, []any{tmp81, tmp83})
																		tmp85 := lang.Apply(tmp78, []any{tmp84})
																		tmp86 := lang.Apply(tmp69, []any{v35, v26, tmp77, v23, tmp85})
																		tmp68 = tmp86
																	} else {
																		tmp68 = v35
																	}
																	var tmp87 any
																	if lang.IsTruthy(v32) {
																		tmp87 = v26
																	} else {
																		tmp88 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp89 := lang.Apply(tmp88, []any{sym_glojure_DOT_core_SLASH_nth, v20, v36, nil})
																		tmp87 = tmp89
																	}
																	tmp90 := lang.Apply(v8, []any{tmp68, v45, tmp87})
																	var tmp67 any = tmp90
																	tmp92 := checkDerefVar(var_glojure_DOT_core_inc)
																	tmp93 := lang.Apply(tmp92, []any{v36})
																	var tmp91 any = tmp93
																	tmp95 := checkDerefVar(var_glojure_DOT_core_next)
																	tmp96 := lang.Apply(tmp95, []any{v37})
																	var tmp94 any = tmp96
																	var tmp97 any = v38
																	v35 = tmp67
																	v36 = tmp91
																	v37 = tmp94
																	v38 = tmp97
																	continue
																}
																tmp64 = tmp65
															} else {
															}
															tmp58 = tmp64
														}
														tmp46 = tmp58
													}
													tmp42 = tmp46
												} // end let
												tmp39 = tmp42
											} else {
												tmp39 = v35
											}
											tmp33 = tmp39
											break
										}
									} // end let
									tmp17 = tmp33
								} // end let
								return tmp17
							})
							tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4404), kw_column, int(20), kw_end_DASH_line, int(4438), kw_end_DASH_column, int(34))
							tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v16 any = tmp15
							_ = v16
							// let binding "pmap"
							var tmp17 lang.FnFunc
							tmp17 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 3)
								v18 := args[0]
								_ = v18
								v19 := args[1]
								_ = v19
								v20 := args[2]
								_ = v20
								var tmp21 any
								{ // let
									// let binding "gmap"
									tmp22 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp23 := lang.Apply(tmp22, []any{"map__"})
									var v24 any = tmp23
									_ = v24
									// let binding "gmapseq"
									tmp25 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
									tmp26 := lang.NewMap(kw_tag, sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_ISeq)
									tmp27 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4442), kw_column, int(52), kw_end_DASH_line, int(4442), kw_end_DASH_column, int(103))
									tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp29 := lang.Apply(tmp25, []any{v24, tmp28})
									var v30 any = tmp29
									_ = v30
									// let binding "defaults"
									tmp31 := lang.Apply(kw_or, []any{v19})
									var v32 any = tmp31
									_ = v32
									var tmp33 any
									{ // let
										// let binding "ret"
										var tmp34 lang.FnFunc
										tmp34 = lang.NewFnFunc(func(args ...any) any {
											checkArity(args, 1)
											v35 := args[0]
											_ = v35
											var tmp36 any
											tmp37 := lang.Apply(kw_as, []any{v19})
											if lang.IsTruthy(tmp37) {
												tmp38 := checkDerefVar(var_glojure_DOT_core_conj)
												tmp39 := lang.Apply(kw_as, []any{v19})
												tmp40 := lang.Apply(tmp38, []any{v35, tmp39, v24})
												tmp36 = tmp40
											} else {
												tmp36 = v35
											}
											return tmp36
										})
										tmp35 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4450), kw_column, int(40), kw_end_DASH_line, int(4453), kw_end_DASH_column, int(48))
										tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp37 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp38 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp39 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp40 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp41 := lang.Apply(tmp40, []any{v18, v24})
										tmp42 := lang.Apply(tmp39, []any{tmp41, v20})
										tmp43 := lang.Apply(tmp38, []any{tmp42, v24})
										tmp44 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp45 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp46 := checkDerefVar(var_glojure_DOT_core_list)
										tmp47 := lang.Apply(tmp46, []any{sym_if})
										tmp48 := checkDerefVar(var_glojure_DOT_core_list)
										tmp49 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp50 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp51 := checkDerefVar(var_glojure_DOT_core_list)
										tmp52 := lang.Apply(tmp51, []any{sym_glojure_DOT_core_SLASH_seq_QMARK_})
										tmp53 := checkDerefVar(var_glojure_DOT_core_list)
										tmp54 := lang.Apply(tmp53, []any{v24})
										tmp55 := lang.Apply(tmp50, []any{tmp52, tmp54})
										tmp56 := lang.Apply(tmp49, []any{tmp55})
										tmp57 := lang.Apply(tmp48, []any{tmp56})
										tmp58 := checkDerefVar(var_glojure_DOT_core_list)
										tmp59 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp60 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp61 := checkDerefVar(var_glojure_DOT_core_list)
										tmp62 := lang.Apply(tmp61, []any{sym_if})
										tmp63 := checkDerefVar(var_glojure_DOT_core_list)
										tmp64 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp65 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp66 := checkDerefVar(var_glojure_DOT_core_list)
										tmp67 := lang.Apply(tmp66, []any{sym_glojure_DOT_core_SLASH_next})
										tmp68 := checkDerefVar(var_glojure_DOT_core_list)
										tmp69 := lang.Apply(tmp68, []any{v30})
										tmp70 := lang.Apply(tmp65, []any{tmp67, tmp69})
										tmp71 := lang.Apply(tmp64, []any{tmp70})
										tmp72 := lang.Apply(tmp63, []any{tmp71})
										tmp73 := checkDerefVar(var_glojure_DOT_core_list)
										tmp74 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp75 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp76 := checkDerefVar(var_glojure_DOT_core_list)
										tmp77 := lang.Apply(tmp76, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewPersistentArrayMapAsIfByAssoc})
										tmp78 := checkDerefVar(var_glojure_DOT_core_list)
										tmp79 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp80 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp81 := checkDerefVar(var_glojure_DOT_core_list)
										tmp82 := lang.Apply(tmp81, []any{sym_glojure_DOT_core_SLASH_to_DASH_array})
										tmp83 := checkDerefVar(var_glojure_DOT_core_list)
										tmp84 := lang.Apply(tmp83, []any{v30})
										tmp85 := lang.Apply(tmp80, []any{tmp82, tmp84})
										tmp86 := lang.Apply(tmp79, []any{tmp85})
										tmp87 := lang.Apply(tmp78, []any{tmp86})
										tmp88 := lang.Apply(tmp75, []any{tmp77, tmp87})
										tmp89 := lang.Apply(tmp74, []any{tmp88})
										tmp90 := lang.Apply(tmp73, []any{tmp89})
										tmp91 := checkDerefVar(var_glojure_DOT_core_list)
										tmp92 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp93 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp94 := checkDerefVar(var_glojure_DOT_core_list)
										tmp95 := lang.Apply(tmp94, []any{sym_if})
										tmp96 := checkDerefVar(var_glojure_DOT_core_list)
										tmp97 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp98 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp99 := checkDerefVar(var_glojure_DOT_core_list)
										tmp100 := lang.Apply(tmp99, []any{sym_glojure_DOT_core_SLASH_seq})
										tmp101 := checkDerefVar(var_glojure_DOT_core_list)
										tmp102 := lang.Apply(tmp101, []any{v30})
										tmp103 := lang.Apply(tmp98, []any{tmp100, tmp102})
										tmp104 := lang.Apply(tmp97, []any{tmp103})
										tmp105 := lang.Apply(tmp96, []any{tmp104})
										tmp106 := checkDerefVar(var_glojure_DOT_core_list)
										tmp107 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp108 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp109 := checkDerefVar(var_glojure_DOT_core_list)
										tmp110 := lang.Apply(tmp109, []any{sym_glojure_DOT_core_SLASH_first})
										tmp111 := checkDerefVar(var_glojure_DOT_core_list)
										tmp112 := lang.Apply(tmp111, []any{v30})
										tmp113 := lang.Apply(tmp108, []any{tmp110, tmp112})
										tmp114 := lang.Apply(tmp107, []any{tmp113})
										tmp115 := lang.Apply(tmp106, []any{tmp114})
										tmp116 := checkDerefVar(var_glojure_DOT_core_list)
										tmp117 := lang.Apply(tmp116, []any{sym_glojure_DOT_lang_DOT_PersistentArrayMap_SLASH_EMPTY})
										tmp118 := lang.Apply(tmp93, []any{tmp95, tmp105, tmp115, tmp117})
										tmp119 := lang.Apply(tmp92, []any{tmp118})
										tmp120 := lang.Apply(tmp91, []any{tmp119})
										tmp121 := lang.Apply(tmp60, []any{tmp62, tmp72, tmp90, tmp120})
										tmp122 := lang.Apply(tmp59, []any{tmp121})
										tmp123 := lang.Apply(tmp58, []any{tmp122})
										tmp124 := checkDerefVar(var_glojure_DOT_core_list)
										tmp125 := lang.Apply(tmp124, []any{v24})
										tmp126 := lang.Apply(tmp45, []any{tmp47, tmp57, tmp123, tmp125})
										tmp127 := lang.Apply(tmp44, []any{tmp126})
										tmp128 := lang.Apply(tmp37, []any{tmp43, tmp127})
										tmp129 := lang.Apply(tmp36, []any{tmp128})
										var v130 any = tmp129
										_ = v130
										// let binding "bes"
										var tmp131 any
										{ // let
											// let binding "transforms"
											tmp132 := checkDerefVar(var_glojure_DOT_core_reduce1)
											var tmp133 lang.FnFunc
											tmp133 = lang.NewFnFunc(func(args ...any) any {
												checkArity(args, 2)
												v134 := args[0]
												_ = v134
												v135 := args[1]
												_ = v135
												var tmp136 any
												tmp137 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
												tmp138 := lang.Apply(tmp137, []any{v135})
												if lang.IsTruthy(tmp138) {
													var tmp139 any
													{ // let
														// let binding "mkns"
														tmp140 := checkDerefVar(var_glojure_DOT_core_namespace)
														tmp141 := lang.Apply(tmp140, []any{v135})
														var v142 any = tmp141
														_ = v142
														// let binding "mkn"
														tmp143 := checkDerefVar(var_glojure_DOT_core_name)
														tmp144 := lang.Apply(tmp143, []any{v135})
														var v145 any = tmp144
														_ = v145
														var tmp146 any
														tmp147 := checkDerefVar(var_glojure_DOT_core__EQ_)
														tmp148 := lang.Apply(tmp147, []any{v145, "keys"})
														if lang.IsTruthy(tmp148) {
															tmp149 := checkDerefVar(var_glojure_DOT_core_assoc)
															var tmp150 lang.FnFunc
															tmp150 = lang.NewFnFunc(func(args ...any) any {
																checkArity(args, 1)
																v151 := args[0]
																_ = v151
																tmp152 := checkDerefVar(var_glojure_DOT_core_keyword)
																var tmp153 any
																{ // let
																	// let binding "or__0__auto__"
																	var v154 any = v142
																	_ = v154
																	var tmp155 any
																	if lang.IsTruthy(v154) {
																		tmp155 = v154
																	} else {
																		tmp156 := checkDerefVar(var_glojure_DOT_core_namespace)
																		tmp157 := lang.Apply(tmp156, []any{v151})
																		tmp155 = tmp157
																	}
																	tmp153 = tmp155
																} // end let
																tmp154 := checkDerefVar(var_glojure_DOT_core_name)
																tmp155 := lang.Apply(tmp154, []any{v151})
																tmp156 := lang.Apply(tmp152, []any{tmp153, tmp155})
																return tmp156
															})
															tmp151 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4460), kw_column, int(93), kw_end_DASH_line, int(4460), kw_end_DASH_column, int(135))
															tmp152, err := lang.WithMeta(tmp150, tmp151.(lang.IPersistentMap))
															if err != nil {
																panic(err)
															}
															tmp153 := lang.Apply(tmp149, []any{v134, v135, tmp152})
															tmp146 = tmp153
														} else {
															var tmp154 any
															tmp155 := checkDerefVar(var_glojure_DOT_core__EQ_)
															tmp156 := lang.Apply(tmp155, []any{v145, "syms"})
															if lang.IsTruthy(tmp156) {
																tmp157 := checkDerefVar(var_glojure_DOT_core_assoc)
																var tmp158 lang.FnFunc
																tmp158 = lang.NewFnFunc(func(args ...any) any {
																	checkArity(args, 1)
																	v159 := args[0]
																	_ = v159
																	tmp160 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp161 := checkDerefVar(var_glojure_DOT_core_symbol)
																	var tmp162 any
																	{ // let
																		// let binding "or__0__auto__"
																		var v163 any = v142
																		_ = v163
																		var tmp164 any
																		if lang.IsTruthy(v163) {
																			tmp164 = v163
																		} else {
																			tmp165 := checkDerefVar(var_glojure_DOT_core_namespace)
																			tmp166 := lang.Apply(tmp165, []any{v159})
																			tmp164 = tmp166
																		}
																		tmp162 = tmp164
																	} // end let
																	tmp163 := checkDerefVar(var_glojure_DOT_core_name)
																	tmp164 := lang.Apply(tmp163, []any{v159})
																	tmp165 := lang.Apply(tmp161, []any{tmp162, tmp164})
																	tmp166 := lang.Apply(tmp160, []any{sym_quote, tmp165})
																	return tmp166
																})
																tmp159 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4461), kw_column, int(93), kw_end_DASH_line, int(4461), kw_end_DASH_column, int(148))
																tmp160, err := lang.WithMeta(tmp158, tmp159.(lang.IPersistentMap))
																if err != nil {
																	panic(err)
																}
																tmp161 := lang.Apply(tmp157, []any{v134, v135, tmp160})
																tmp154 = tmp161
															} else {
																var tmp162 any
																tmp163 := checkDerefVar(var_glojure_DOT_core__EQ_)
																tmp164 := lang.Apply(tmp163, []any{v145, "strs"})
																if lang.IsTruthy(tmp164) {
																	tmp165 := checkDerefVar(var_glojure_DOT_core_assoc)
																	tmp166 := checkDerefVar(var_glojure_DOT_core_str)
																	tmp167 := lang.Apply(tmp165, []any{v134, v135, tmp166})
																	tmp162 = tmp167
																} else {
																	var tmp168 any
																	if lang.IsTruthy(kw_else) {
																		tmp168 = v134
																	} else {
																	}
																	tmp162 = tmp168
																}
																tmp154 = tmp162
															}
															tmp146 = tmp154
														}
														tmp139 = tmp146
													} // end let
													tmp136 = tmp139
												} else {
													tmp136 = v134
												}
												return tmp136
											})
											tmp134 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4456), kw_column, int(45), kw_end_DASH_line, int(4464), kw_end_DASH_column, int(60))
											tmp135, err := lang.WithMeta(tmp133, tmp134.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp136 := lang.NewMap()
											tmp137 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4465), kw_column, int(45), kw_end_DASH_line, int(4465), kw_end_DASH_column, int(46))
											tmp138, err := lang.WithMeta(tmp136, tmp137.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp139 := checkDerefVar(var_glojure_DOT_core_keys)
											tmp140 := lang.Apply(tmp139, []any{v19})
											tmp141 := lang.Apply(tmp132, []any{tmp135, tmp138, tmp140})
											var v142 any = tmp141
											_ = v142
											tmp143 := checkDerefVar(var_glojure_DOT_core_reduce1)
											var tmp144 lang.FnFunc
											tmp144 = lang.NewFnFunc(func(args ...any) any {
												checkArity(args, 2)
												v145 := args[0]
												_ = v145
												v146 := args[1]
												_ = v146
												tmp147 := checkDerefVar(var_glojure_DOT_core_reduce1)
												var tmp148 lang.FnFunc
												tmp148 = lang.NewFnFunc(func(args ...any) any {
													checkArity(args, 2)
													v149 := args[0]
													_ = v149
													v150 := args[1]
													_ = v150
													tmp151 := checkDerefVar(var_glojure_DOT_core_assoc)
													tmp152 := checkDerefVar(var_glojure_DOT_core_val)
													tmp153 := lang.Apply(tmp152, []any{v146})
													tmp154 := lang.Apply(tmp153, []any{v150})
													tmp155 := lang.Apply(tmp151, []any{v149, v150, tmp154})
													return tmp155
												})
												tmp149 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4469), kw_column, int(52), kw_end_DASH_line, int(4469), kw_end_DASH_column, int(82))
												tmp150, err := lang.WithMeta(tmp148, tmp149.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp151 := checkDerefVar(var_glojure_DOT_core_dissoc)
												tmp152 := checkDerefVar(var_glojure_DOT_core_key)
												tmp153 := lang.Apply(tmp152, []any{v146})
												tmp154 := lang.Apply(tmp151, []any{v145, tmp153})
												tmp155 := checkDerefVar(var_glojure_DOT_core_key)
												tmp156 := lang.Apply(tmp155, []any{v146})
												tmp157 := lang.Apply(tmp156, []any{v145})
												tmp158 := lang.Apply(tmp147, []any{tmp150, tmp154, tmp157})
												return tmp158
											})
											tmp145 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4468), kw_column, int(41), kw_end_DASH_line, int(4471), kw_end_DASH_column, int(70))
											tmp146, err := lang.WithMeta(tmp144, tmp145.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp147 := checkDerefVar(var_glojure_DOT_core_dissoc)
											tmp148 := lang.Apply(tmp147, []any{v19, kw_as, kw_or})
											tmp149 := lang.Apply(tmp143, []any{tmp146, tmp148, v142})
											tmp131 = tmp149
										} // end let
										var v132 any = tmp131
										_ = v132
										for {
											var tmp133 any
											tmp134 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp135 := lang.Apply(tmp134, []any{v132})
											if lang.IsTruthy(tmp135) {
												var tmp136 any
												{ // let
													// let binding "bb"
													tmp137 := checkDerefVar(var_glojure_DOT_core_key)
													tmp138 := checkDerefVar(var_glojure_DOT_core_first)
													tmp139 := lang.Apply(tmp138, []any{v132})
													tmp140 := lang.Apply(tmp137, []any{tmp139})
													var v141 any = tmp140
													_ = v141
													// let binding "bk"
													tmp142 := checkDerefVar(var_glojure_DOT_core_val)
													tmp143 := checkDerefVar(var_glojure_DOT_core_first)
													tmp144 := lang.Apply(tmp143, []any{v132})
													tmp145 := lang.Apply(tmp142, []any{tmp144})
													var v146 any = tmp145
													_ = v146
													// let binding "local"
													var tmp147 any
													tmp148 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
													tmp149 := reflect.TypeOf((*lang.Named)(nil)).Elem()
													tmp150 := lang.Apply(tmp148, []any{tmp149, v141})
													if lang.IsTruthy(tmp150) {
														tmp151 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
														tmp152 := checkDerefVar(var_glojure_DOT_core_symbol)
														tmp153 := checkDerefVar(var_glojure_DOT_core_name)
														tmp154 := lang.Apply(tmp153, []any{v141})
														tmp155 := lang.Apply(tmp152, []any{nil, tmp154})
														tmp156 := checkDerefVar(var_glojure_DOT_core_meta)
														tmp157 := lang.Apply(tmp156, []any{v141})
														tmp158 := lang.Apply(tmp151, []any{tmp155, tmp157})
														tmp147 = tmp158
													} else {
														tmp147 = v141
													}
													var v159 any = tmp147
													_ = v159
													// let binding "bv"
													var tmp160 any
													tmp161 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
													tmp162 := lang.Apply(tmp161, []any{v32, v159})
													if lang.IsTruthy(tmp162) {
														tmp163 := checkDerefVar(var_glojure_DOT_core_list)
														tmp164 := lang.Apply(v32, []any{v159})
														tmp165 := lang.Apply(tmp163, []any{sym_glojure_DOT_core_SLASH_get, v24, v146, tmp164})
														tmp160 = tmp165
													} else {
														tmp166 := checkDerefVar(var_glojure_DOT_core_list)
														tmp167 := lang.Apply(tmp166, []any{sym_glojure_DOT_core_SLASH_get, v24, v146})
														tmp160 = tmp167
													}
													var v168 any = tmp160
													_ = v168
													var tmp170 any
													tmp171 := checkDerefVar(var_glojure_DOT_core_ident_QMARK_)
													tmp172 := lang.Apply(tmp171, []any{v141})
													if lang.IsTruthy(tmp172) {
														tmp173 := checkDerefVar(var_glojure_DOT_core_conj)
														tmp174 := lang.Apply(tmp173, []any{v130, v159, v168})
														tmp170 = tmp174
													} else {
														tmp175 := lang.Apply(v8, []any{v130, v141, v168})
														tmp170 = tmp175
													}
													var tmp169 any = tmp170
													tmp177 := checkDerefVar(var_glojure_DOT_core_next)
													tmp178 := lang.Apply(tmp177, []any{v132})
													var tmp176 any = tmp178
													v130 = tmp169
													v132 = tmp176
													continue
												} // end let
												tmp133 = tmp136
											} else {
												tmp133 = v130
											}
											tmp33 = tmp133
											break
										}
									} // end let
									tmp21 = tmp33
								} // end let
								return tmp21
							})
							tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4440), kw_column, int(20), kw_end_DASH_line, int(4485), kw_end_DASH_column, int(34))
							tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v20 any = tmp19
							_ = v20
							var tmp21 any
							tmp22 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
							tmp23 := lang.Apply(tmp22, []any{v10})
							if lang.IsTruthy(tmp23) {
								tmp24 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp25 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp26 := lang.Apply(tmp25, []any{v9, v10})
								tmp27 := lang.Apply(tmp24, []any{tmp26, v11})
								tmp21 = tmp27
							} else {
								var tmp28 any
								tmp29 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
								tmp30 := lang.Apply(tmp29, []any{v10})
								if lang.IsTruthy(tmp30) {
									tmp31 := lang.Apply(v16, []any{v9, v10, v11})
									tmp28 = tmp31
								} else {
									var tmp32 any
									tmp33 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
									tmp34 := lang.Apply(tmp33, []any{v10})
									if lang.IsTruthy(tmp34) {
										tmp35 := lang.Apply(v20, []any{v9, v10, v11})
										tmp32 = tmp35
									} else {
										var tmp36 any
										if lang.IsTruthy(kw_else) {
											tmp37 := checkDerefVar(var_glojure_DOT_core_str)
											tmp38 := lang.Apply(tmp37, []any{"Unsupported binding form: ", v10})
											tmp39 := lang.Apply(errors8.New, []any{tmp38})
											panic(tmp39)
										} else {
										}
										tmp32 = tmp36
									}
									tmp28 = tmp32
								}
								tmp21 = tmp28
							}
							tmp12 = tmp21
						} // end let
						return tmp12
					})
					v8 = tmp7
					_ = v8
				}
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4402), kw_column, int(12), kw_end_DASH_line, int(4490), kw_end_DASH_column, int(82))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v10 any = tmp9
				_ = v10
				// let binding "process-entry"
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v12 := args[0]
					_ = v12
					v13 := args[1]
					_ = v13
					tmp14 := checkDerefVar(var_glojure_DOT_core_first)
					tmp15 := lang.Apply(tmp14, []any{v13})
					tmp16 := checkDerefVar(var_glojure_DOT_core_second)
					tmp17 := lang.Apply(tmp16, []any{v13})
					tmp18 := lang.Apply(v10, []any{v12, tmp15, tmp17})
					return tmp18
				})
				tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4491), kw_column, int(23), kw_end_DASH_line, int(4491), kw_end_DASH_column, int(66))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v14 any = tmp13
				_ = v14
				var tmp15 any
				tmp16 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
				tmp17 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
				tmp18 := checkDerefVar(var_glojure_DOT_core_map)
				tmp19 := checkDerefVar(var_glojure_DOT_core_first)
				tmp20 := lang.Apply(tmp18, []any{tmp19, v6})
				tmp21 := lang.Apply(tmp16, []any{tmp17, tmp20})
				if lang.IsTruthy(tmp21) {
					tmp15 = v2
				} else {
					tmp22 := checkDerefVar(var_glojure_DOT_core_reduce1)
					tmp23 := lang.NewVector()
					tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4494), kw_column, int(30), kw_end_DASH_line, int(4494), kw_end_DASH_column, int(31))
					tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp26 := lang.Apply(tmp22, []any{v14, tmp25, v6})
					tmp15 = tmp26
				}
				tmp3 = tmp15
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_destructure = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_destructure.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend
	{
		tmp0 := sym_extend.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atype, sym__AMP_, sym_proto_PLUS_mmaps)), kw_doc, "Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n    AProtocol\n     {:foo an-existing-fn\n      :bar (fn [a b] ...)\n      :baz (fn ([a]...) ([a b] ...)...)}\n    BProtocol \n      {...} \n    ...)\n \n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument. \n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders", kw_file, "glojure/core_deftype.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(116), kw_end_DASH_line, int(116))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "seq_262"
					tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp6 := checkDerefVar(var_glojure_DOT_core_partition)
					tmp7 := lang.Apply(tmp6, []any{int64(2), v3})
					tmp8 := lang.Apply(tmp5, []any{tmp7})
					var v9 any = tmp8
					_ = v9
					// let binding "chunk_263"
					var v10 any = nil
					_ = v10
					// let binding "count_264"
					var v11 any = int64(0)
					_ = v11
					// let binding "i_265"
					var v12 any = int64(0)
					_ = v12
					for {
						var tmp13 any
						tmp14 := checkDerefVar(var_glojure_DOT_core__LT_)
						tmp15 := lang.Apply(tmp14, []any{v12, v11})
						if lang.IsTruthy(tmp15) {
							var tmp16 any
							{ // let
								// let binding "vec__266"
								tmp17, _ := lang.FieldOrMethod(v10, "nth")
								if reflect.TypeOf(tmp17).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
								}
								tmp18 := lang.Apply(tmp17, []any{v12})
								var v19 any = tmp18
								_ = v19
								// let binding "proto"
								tmp20 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp21 := lang.Apply(tmp20, []any{v19, int64(0), nil})
								var v22 any = tmp21
								_ = v22
								// let binding "mmap"
								tmp23 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp24 := lang.Apply(tmp23, []any{v19, int64(1), nil})
								var v25 any = tmp24
								_ = v25
								var tmp26 any
								tmp27 := checkDerefVar(var_glojure_DOT_core_protocol_QMARK_)
								tmp28 := lang.Apply(tmp27, []any{v22})
								if lang.IsTruthy(tmp28) {
								} else {
									tmp29 := checkDerefVar(var_glojure_DOT_core_str)
									tmp30 := lang.Apply(tmp29, []any{v22, " is not a protocol"})
									tmp31 := lang.Apply(errors8.New, []any{tmp30})
									panic(tmp31)
								}
								_ = tmp26
								tmp32 := checkDerefVar(var_glojure_DOT_core_reduce1)
								var tmp33 lang.FnFunc
								tmp33 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 2)
									v34 := args[0]
									_ = v34
									v35 := args[1]
									_ = v35
									var tmp36 any
									{ // let
										// let binding "vec__270"
										var v37 any = v35
										_ = v37
										// let binding "k"
										tmp38 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp39 := lang.Apply(tmp38, []any{v37, int64(0), nil})
										var v40 any = tmp39
										_ = v40
										// let binding "v"
										tmp41 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp42 := lang.Apply(tmp41, []any{v37, int64(1), nil})
										var v43 any = tmp42
										_ = v43
										tmp44 := checkDerefVar(var_glojure_DOT_core_get_DASH_in)
										tmp45 := checkDerefVar(var_glojure_DOT_core_deref)
										tmp46 := lang.Apply(tmp45, []any{v22})
										tmp47 := lang.NewVector(kw_multis, v40)
										tmp48 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(158), kw_column, int(33), kw_end_DASH_line, int(158), kw_end_DASH_column, int(43))
										tmp49, err := lang.WithMeta(tmp47, tmp48.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp50 := lang.Apply(tmp44, []any{tmp46, tmp49})
										var tmp51 lang.FnFunc
										tmp51 = lang.NewFnFunc(func(args ...any) any {
											switch len(args) {
											default:
												checkArityGTE(args, 1)
												v52 := args[0]
												_ = v52
												var v53 any = lang.NewList(args[1:]...)
												_ = v53
												tmp54 := checkDerefVar(var_glojure_DOT_core_apply)
												tmp55 := checkDerefVar(var_glojure_DOT_core_cons)
												tmp56 := lang.Apply(tmp55, []any{v52, v53})
												tmp57 := lang.Apply(tmp54, []any{v43, tmp56})
												return tmp57
											}
										})
										tmp52, _ := lang.FieldOrMethod(tmp50, "AddMethod")
										if reflect.TypeOf(tmp52).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddMethod is not a function")))
										}
										tmp53 := lang.Apply(tmp52, []any{v2, tmp51})
										tmp36 = tmp53
									} // end let
									return tmp36
								})
								tmp34 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(156), kw_column, int(14), kw_end_DASH_line, int(160), kw_end_DASH_column, int(45))
								tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp36 := lang.Apply(tmp32, []any{tmp35, nil, v25})
								_ = tmp36
								var tmp37 any = v9
								var tmp38 any = v10
								var tmp39 any = v11
								tmp41 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
								tmp42 := lang.Apply(tmp41, []any{v12})
								var tmp40 any = tmp42
								v9 = tmp37
								v10 = tmp38
								v11 = tmp39
								v12 = tmp40
								continue
							} // end let
							tmp13 = tmp16
						} else {
							var tmp17 any
							{ // let
								// let binding "temp__0__auto__"
								tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp19 := lang.Apply(tmp18, []any{v9})
								var v20 any = tmp19
								_ = v20
								var tmp21 any
								if lang.IsTruthy(v20) {
									var tmp22 any
									{ // let
										// let binding "seq_262"
										var v23 any = v20
										_ = v23
										var tmp24 any
										tmp25 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
										tmp26 := lang.Apply(tmp25, []any{v23})
										if lang.IsTruthy(tmp26) {
											var tmp27 any
											{ // let
												// let binding "c__0__auto__"
												tmp28 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
												tmp29 := lang.Apply(tmp28, []any{v23})
												var v30 any = tmp29
												_ = v30
												tmp32 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
												tmp33 := lang.Apply(tmp32, []any{v23})
												var tmp31 any = tmp33
												var tmp34 any = v30
												tmp36 := checkDerefVar(var_glojure_DOT_core_int)
												tmp37 := checkDerefVar(var_glojure_DOT_core_count)
												tmp38 := lang.Apply(tmp37, []any{v30})
												tmp39 := lang.Apply(tmp36, []any{tmp38})
												var tmp35 any = tmp39
												tmp41 := checkDerefVar(var_glojure_DOT_core_int)
												tmp42 := lang.Apply(tmp41, []any{int64(0)})
												var tmp40 any = tmp42
												v9 = tmp31
												v10 = tmp34
												v11 = tmp35
												v12 = tmp40
												continue
											} // end let
											tmp24 = tmp27
										} else {
											var tmp28 any
											{ // let
												// let binding "vec__273"
												tmp29 := checkDerefVar(var_glojure_DOT_core_first)
												tmp30 := lang.Apply(tmp29, []any{v23})
												var v31 any = tmp30
												_ = v31
												// let binding "proto"
												tmp32 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp33 := lang.Apply(tmp32, []any{v31, int64(0), nil})
												var v34 any = tmp33
												_ = v34
												// let binding "mmap"
												tmp35 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp36 := lang.Apply(tmp35, []any{v31, int64(1), nil})
												var v37 any = tmp36
												_ = v37
												var tmp38 any
												tmp39 := checkDerefVar(var_glojure_DOT_core_protocol_QMARK_)
												tmp40 := lang.Apply(tmp39, []any{v34})
												if lang.IsTruthy(tmp40) {
												} else {
													tmp41 := checkDerefVar(var_glojure_DOT_core_str)
													tmp42 := lang.Apply(tmp41, []any{v34, " is not a protocol"})
													tmp43 := lang.Apply(errors8.New, []any{tmp42})
													panic(tmp43)
												}
												_ = tmp38
												tmp44 := checkDerefVar(var_glojure_DOT_core_reduce1)
												var tmp45 lang.FnFunc
												tmp45 = lang.NewFnFunc(func(args ...any) any {
													checkArity(args, 2)
													v46 := args[0]
													_ = v46
													v47 := args[1]
													_ = v47
													var tmp48 any
													{ // let
														// let binding "vec__277"
														var v49 any = v47
														_ = v49
														// let binding "k"
														tmp50 := checkDerefVar(var_glojure_DOT_core_nth)
														tmp51 := lang.Apply(tmp50, []any{v49, int64(0), nil})
														var v52 any = tmp51
														_ = v52
														// let binding "v"
														tmp53 := checkDerefVar(var_glojure_DOT_core_nth)
														tmp54 := lang.Apply(tmp53, []any{v49, int64(1), nil})
														var v55 any = tmp54
														_ = v55
														tmp56 := checkDerefVar(var_glojure_DOT_core_get_DASH_in)
														tmp57 := checkDerefVar(var_glojure_DOT_core_deref)
														tmp58 := lang.Apply(tmp57, []any{v34})
														tmp59 := lang.NewVector(kw_multis, v52)
														tmp60 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(158), kw_column, int(33), kw_end_DASH_line, int(158), kw_end_DASH_column, int(43))
														tmp61, err := lang.WithMeta(tmp59, tmp60.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp62 := lang.Apply(tmp56, []any{tmp58, tmp61})
														var tmp63 lang.FnFunc
														tmp63 = lang.NewFnFunc(func(args ...any) any {
															switch len(args) {
															default:
																checkArityGTE(args, 1)
																v64 := args[0]
																_ = v64
																var v65 any = lang.NewList(args[1:]...)
																_ = v65
																tmp66 := checkDerefVar(var_glojure_DOT_core_apply)
																tmp67 := checkDerefVar(var_glojure_DOT_core_cons)
																tmp68 := lang.Apply(tmp67, []any{v64, v65})
																tmp69 := lang.Apply(tmp66, []any{v55, tmp68})
																return tmp69
															}
														})
														tmp64, _ := lang.FieldOrMethod(tmp62, "AddMethod")
														if reflect.TypeOf(tmp64).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddMethod is not a function")))
														}
														tmp65 := lang.Apply(tmp64, []any{v2, tmp63})
														tmp48 = tmp65
													} // end let
													return tmp48
												})
												tmp46 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(156), kw_column, int(14), kw_end_DASH_line, int(160), kw_end_DASH_column, int(45))
												tmp47, err := lang.WithMeta(tmp45, tmp46.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp48 := lang.Apply(tmp44, []any{tmp47, nil, v37})
												_ = tmp48
												tmp50 := checkDerefVar(var_glojure_DOT_core_next)
												tmp51 := lang.Apply(tmp50, []any{v23})
												var tmp49 any = tmp51
												var tmp52 any = nil
												var tmp53 any = int64(0)
												var tmp54 any = int64(0)
												v9 = tmp49
												v10 = tmp52
												v11 = tmp53
												v12 = tmp54
												continue
											} // end let
											tmp24 = tmp28
										}
										tmp22 = tmp24
									} // end let
									tmp21 = tmp22
								} else {
								}
								tmp17 = tmp21
							} // end let
							tmp13 = tmp17
						}
						tmp4 = tmp13
						break
					}
				} // end let
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_extend = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_extend.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// for
	{
		tmp0 := sym_for.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_seq_DASH_exprs, sym_body_DASH_expr)), kw_doc, "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(11), kw_line, int(4646), kw_end_DASH_line, int(4646))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			var tmp6 any
			tmp7 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
			tmp8 := lang.Apply(tmp7, []any{v4})
			if lang.IsTruthy(tmp8) {
			} else {
				tmp9 := checkDerefVar(var_glojure_DOT_core_str)
				tmp10 := checkDerefVar(var_glojure_DOT_core_first)
				tmp11 := lang.Apply(tmp10, []any{v2})
				tmp12 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
				tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp14 := lang.Apply(tmp13, []any{v2})
				tmp15 := lang.Apply(kw_line, []any{tmp14})
				tmp16 := lang.Apply(tmp9, []any{tmp11, " requires ", "a vector for its binding", " in ", tmp12, ":", tmp15})
				tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
				panic(tmp17)
			}
			_ = tmp6
			var tmp18 any
			tmp19 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
			tmp20 := checkDerefVar(var_glojure_DOT_core_count)
			tmp21 := lang.Apply(tmp20, []any{v4})
			tmp22 := lang.Apply(tmp19, []any{tmp21})
			if lang.IsTruthy(tmp22) {
			} else {
				tmp23 := checkDerefVar(var_glojure_DOT_core_str)
				tmp24 := checkDerefVar(var_glojure_DOT_core_first)
				tmp25 := lang.Apply(tmp24, []any{v2})
				tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
				tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp28 := lang.Apply(tmp27, []any{v2})
				tmp29 := lang.Apply(kw_line, []any{tmp28})
				tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "an even number of forms in binding vector", " in ", tmp26, ":", tmp29})
				tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
				panic(tmp31)
			}
			_ = tmp18
			var tmp32 any
			{ // let
				// let binding "to-groups"
				var tmp33 lang.FnFunc
				tmp33 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v34 := args[0]
					_ = v34
					tmp35 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp36 lang.FnFunc
					tmp36 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v37 := args[0]
						_ = v37
						v38 := args[1]
						_ = v38
						var tmp39 any
						{ // let
							// let binding "vec__24"
							var v40 any = v38
							_ = v40
							// let binding "k"
							tmp41 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp42 := lang.Apply(tmp41, []any{v40, int64(0), nil})
							var v43 any = tmp42
							_ = v43
							// let binding "v"
							tmp44 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp45 := lang.Apply(tmp44, []any{v40, int64(1), nil})
							var v46 any = tmp45
							_ = v46
							var tmp47 any
							tmp48 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
							tmp49 := lang.Apply(tmp48, []any{v43})
							if lang.IsTruthy(tmp49) {
								tmp50 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp51 := checkDerefVar(var_glojure_DOT_core_pop)
								tmp52 := lang.Apply(tmp51, []any{v37})
								tmp53 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp54 := checkDerefVar(var_glojure_DOT_core_peek)
								tmp55 := lang.Apply(tmp54, []any{v37})
								tmp56 := lang.NewVector(v43, v46)
								tmp57 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4664), kw_column, int(72), kw_end_DASH_line, int(4664), kw_end_DASH_column, int(76))
								tmp58, err := lang.WithMeta(tmp56, tmp57.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp59 := lang.Apply(tmp53, []any{tmp55, tmp58})
								tmp60 := lang.Apply(tmp50, []any{tmp52, tmp59})
								tmp47 = tmp60
							} else {
								tmp61 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp62 := lang.NewVector(v43, v46)
								tmp63 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4665), kw_column, int(46), kw_end_DASH_line, int(4665), kw_end_DASH_column, int(50))
								tmp64, err := lang.WithMeta(tmp62, tmp63.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp65 := lang.Apply(tmp61, []any{v37, tmp64})
								tmp47 = tmp65
							}
							tmp39 = tmp47
						} // end let
						return tmp39
					})
					tmp37 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4662), kw_column, int(30), kw_end_DASH_line, int(4665), kw_end_DASH_column, int(53))
					tmp38, err := lang.WithMeta(tmp36, tmp37.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp39 := lang.NewVector()
					tmp40 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4666), kw_column, int(29), kw_end_DASH_line, int(4666), kw_end_DASH_column, int(30))
					tmp41, err := lang.WithMeta(tmp39, tmp40.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp42 := checkDerefVar(var_glojure_DOT_core_partition)
					tmp43 := lang.Apply(tmp42, []any{int64(2), v34})
					tmp44 := lang.Apply(tmp35, []any{tmp38, tmp41, tmp43})
					return tmp44
				})
				tmp34 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4661), kw_column, int(19), kw_end_DASH_line, int(4666), kw_end_DASH_column, int(56))
				tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v36 any = tmp35
				_ = v36
				// let binding "err"
				var tmp37 lang.FnFunc
				tmp37 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						checkArityGTE(args, 0)
						var v38 any = lang.NewList(args[0:]...)
						_ = v38
						tmp39 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp40 := checkDerefVar(var_glojure_DOT_core_str)
						tmp41 := lang.Apply(tmp39, []any{tmp40, v38})
						tmp42 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp41})
						panic(tmp42)
					}
				})
				tmp38 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4667), kw_column, int(13), kw_end_DASH_line, int(4667), kw_end_DASH_column, int(125))
				tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v40 any = tmp39
				_ = v40
				// let binding "emit-bind"
				var tmp41 lang.FnFunc
				{ // function emit-bind
					var v42 lang.FnFunc
					tmp41 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v43 := args[0]
						_ = v43
						var tmp44 any
						{ // let
							// let binding "vec__28"
							var v45 any = v43
							_ = v45
							// let binding "seq__29"
							tmp46 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp47 := lang.Apply(tmp46, []any{v45})
							var v48 any = tmp47
							_ = v48
							// let binding "first__30"
							tmp49 := checkDerefVar(var_glojure_DOT_core_first)
							tmp50 := lang.Apply(tmp49, []any{v48})
							var v51 any = tmp50
							_ = v51
							// let binding "seq__29"
							tmp52 := checkDerefVar(var_glojure_DOT_core_next)
							tmp53 := lang.Apply(tmp52, []any{v48})
							var v54 any = tmp53
							_ = v54
							// let binding "vec__31"
							var v55 any = v51
							_ = v55
							// let binding "seq__32"
							tmp56 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp57 := lang.Apply(tmp56, []any{v55})
							var v58 any = tmp57
							_ = v58
							// let binding "first__33"
							tmp59 := checkDerefVar(var_glojure_DOT_core_first)
							tmp60 := lang.Apply(tmp59, []any{v58})
							var v61 any = tmp60
							_ = v61
							// let binding "seq__32"
							tmp62 := checkDerefVar(var_glojure_DOT_core_next)
							tmp63 := lang.Apply(tmp62, []any{v58})
							var v64 any = tmp63
							_ = v64
							// let binding "bind"
							var v65 any = v61
							_ = v65
							// let binding "first__33"
							tmp66 := checkDerefVar(var_glojure_DOT_core_first)
							tmp67 := lang.Apply(tmp66, []any{v64})
							var v68 any = tmp67
							_ = v68
							// let binding "seq__32"
							tmp69 := checkDerefVar(var_glojure_DOT_core_next)
							tmp70 := lang.Apply(tmp69, []any{v64})
							var v71 any = tmp70
							_ = v71
							// let binding "expr"
							var v72 any = v68
							_ = v72
							// let binding "mod-pairs"
							var v73 any = v71
							_ = v73
							// let binding "vec__34"
							var v74 any = v54
							_ = v74
							// let binding "vec__37"
							tmp75 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp76 := lang.Apply(tmp75, []any{v74, int64(0), nil})
							var v77 any = tmp76
							_ = v77
							// let binding "_"
							tmp78 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp79 := lang.Apply(tmp78, []any{v77, int64(0), nil})
							var v80 any = tmp79
							_ = v80
							// let binding "next-expr"
							tmp81 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp82 := lang.Apply(tmp81, []any{v77, int64(1), nil})
							var v83 any = tmp82
							_ = v83
							// let binding "next-groups"
							var v84 any = v74
							_ = v84
							var tmp85 any
							{ // let
								// let binding "giter"
								tmp86 := checkDerefVar(var_glojure_DOT_core_gensym)
								tmp87 := lang.Apply(tmp86, []any{"iter__"})
								var v88 any = tmp87
								_ = v88
								// let binding "gxs"
								tmp89 := checkDerefVar(var_glojure_DOT_core_gensym)
								tmp90 := lang.Apply(tmp89, []any{"s__"})
								var v91 any = tmp90
								_ = v91
								// let binding "do-mod"
								var tmp92 lang.FnFunc
								{ // function do-mod
									var v93 lang.FnFunc
									tmp92 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v94 := args[0]
										_ = v94
										var tmp95 any
										{ // let
											// let binding "vec__41"
											var v96 any = v94
											_ = v96
											// let binding "seq__42"
											tmp97 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp98 := lang.Apply(tmp97, []any{v96})
											var v99 any = tmp98
											_ = v99
											// let binding "first__43"
											tmp100 := checkDerefVar(var_glojure_DOT_core_first)
											tmp101 := lang.Apply(tmp100, []any{v99})
											var v102 any = tmp101
											_ = v102
											// let binding "seq__42"
											tmp103 := checkDerefVar(var_glojure_DOT_core_next)
											tmp104 := lang.Apply(tmp103, []any{v99})
											var v105 any = tmp104
											_ = v105
											// let binding "vec__44"
											var v106 any = v102
											_ = v106
											// let binding "k"
											tmp107 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp108 := lang.Apply(tmp107, []any{v106, int64(0), nil})
											var v109 any = tmp108
											_ = v109
											// let binding "v"
											tmp110 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp111 := lang.Apply(tmp110, []any{v106, int64(1), nil})
											var v112 any = tmp111
											_ = v112
											// let binding "pair"
											var v113 any = v106
											_ = v113
											// let binding "etc"
											var v114 any = v105
											_ = v114
											var tmp115 any
											tmp116 := checkDerefVar(var_glojure_DOT_core__EQ_)
											tmp117 := lang.Apply(tmp116, []any{v109, kw_let})
											if lang.IsTruthy(tmp117) {
												tmp118 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp119 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp120 := checkDerefVar(var_glojure_DOT_core_list)
												tmp121 := lang.Apply(tmp120, []any{sym_glojure_DOT_core_SLASH_let})
												tmp122 := checkDerefVar(var_glojure_DOT_core_list)
												tmp123 := lang.Apply(tmp122, []any{v112})
												tmp124 := checkDerefVar(var_glojure_DOT_core_list)
												tmp125 := lang.Apply(v93, []any{v114})
												tmp126 := lang.Apply(tmp124, []any{tmp125})
												tmp127 := lang.Apply(tmp119, []any{tmp121, tmp123, tmp126})
												tmp128 := lang.Apply(tmp118, []any{tmp127})
												tmp115 = tmp128
											} else {
												var tmp129 any
												tmp130 := checkDerefVar(var_glojure_DOT_core__EQ_)
												tmp131 := lang.Apply(tmp130, []any{v109, kw_while})
												if lang.IsTruthy(tmp131) {
													tmp132 := checkDerefVar(var_glojure_DOT_core_seq)
													tmp133 := checkDerefVar(var_glojure_DOT_core_concat)
													tmp134 := checkDerefVar(var_glojure_DOT_core_list)
													tmp135 := lang.Apply(tmp134, []any{sym_glojure_DOT_core_SLASH_when})
													tmp136 := checkDerefVar(var_glojure_DOT_core_list)
													tmp137 := lang.Apply(tmp136, []any{v112})
													tmp138 := checkDerefVar(var_glojure_DOT_core_list)
													tmp139 := lang.Apply(v93, []any{v114})
													tmp140 := lang.Apply(tmp138, []any{tmp139})
													tmp141 := lang.Apply(tmp133, []any{tmp135, tmp137, tmp140})
													tmp142 := lang.Apply(tmp132, []any{tmp141})
													tmp129 = tmp142
												} else {
													var tmp143 any
													tmp144 := checkDerefVar(var_glojure_DOT_core__EQ_)
													tmp145 := lang.Apply(tmp144, []any{v109, kw_when})
													if lang.IsTruthy(tmp145) {
														tmp146 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp147 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp148 := checkDerefVar(var_glojure_DOT_core_list)
														tmp149 := lang.Apply(tmp148, []any{sym_if})
														tmp150 := checkDerefVar(var_glojure_DOT_core_list)
														tmp151 := lang.Apply(tmp150, []any{v112})
														tmp152 := checkDerefVar(var_glojure_DOT_core_list)
														tmp153 := lang.Apply(v93, []any{v114})
														tmp154 := lang.Apply(tmp152, []any{tmp153})
														tmp155 := checkDerefVar(var_glojure_DOT_core_list)
														tmp156 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp157 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp158 := checkDerefVar(var_glojure_DOT_core_list)
														tmp159 := lang.Apply(tmp158, []any{sym_recur})
														tmp160 := checkDerefVar(var_glojure_DOT_core_list)
														tmp161 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp162 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp163 := checkDerefVar(var_glojure_DOT_core_list)
														tmp164 := lang.Apply(tmp163, []any{sym_glojure_DOT_core_SLASH_rest})
														tmp165 := checkDerefVar(var_glojure_DOT_core_list)
														tmp166 := lang.Apply(tmp165, []any{v91})
														tmp167 := lang.Apply(tmp162, []any{tmp164, tmp166})
														tmp168 := lang.Apply(tmp161, []any{tmp167})
														tmp169 := lang.Apply(tmp160, []any{tmp168})
														tmp170 := lang.Apply(tmp157, []any{tmp159, tmp169})
														tmp171 := lang.Apply(tmp156, []any{tmp170})
														tmp172 := lang.Apply(tmp155, []any{tmp171})
														tmp173 := lang.Apply(tmp147, []any{tmp149, tmp151, tmp154, tmp172})
														tmp174 := lang.Apply(tmp146, []any{tmp173})
														tmp143 = tmp174
													} else {
														var tmp175 any
														tmp176 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
														tmp177 := lang.Apply(tmp176, []any{v109})
														if lang.IsTruthy(tmp177) {
															tmp178 := lang.Apply(v40, []any{"Invalid 'for' keyword ", v109})
															tmp175 = tmp178
														} else {
															var tmp179 any
															if lang.IsTruthy(v84) {
																tmp180 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp181 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp182 := checkDerefVar(var_glojure_DOT_core_list)
																tmp183 := lang.Apply(tmp182, []any{sym_glojure_DOT_core_SLASH_let})
																tmp184 := checkDerefVar(var_glojure_DOT_core_list)
																tmp185 := checkDerefVar(var_glojure_DOT_core_apply)
																tmp186 := checkDerefVar(var_glojure_DOT_core_vector)
																tmp187 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp188 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp189 := checkDerefVar(var_glojure_DOT_core_list)
																tmp190 := lang.Apply(tmp189, []any{sym_iterys__0__auto__})
																tmp191 := checkDerefVar(var_glojure_DOT_core_list)
																tmp192 := lang.Apply(v42, []any{v84})
																tmp193 := lang.Apply(tmp191, []any{tmp192})
																tmp194 := checkDerefVar(var_glojure_DOT_core_list)
																tmp195 := lang.Apply(tmp194, []any{sym_fs__1__auto__})
																tmp196 := checkDerefVar(var_glojure_DOT_core_list)
																tmp197 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp198 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp199 := checkDerefVar(var_glojure_DOT_core_list)
																tmp200 := lang.Apply(tmp199, []any{sym_glojure_DOT_core_SLASH_seq})
																tmp201 := checkDerefVar(var_glojure_DOT_core_list)
																tmp202 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp203 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp204 := checkDerefVar(var_glojure_DOT_core_list)
																tmp205 := lang.Apply(tmp204, []any{sym_iterys__0__auto__})
																tmp206 := checkDerefVar(var_glojure_DOT_core_list)
																tmp207 := lang.Apply(tmp206, []any{v83})
																tmp208 := lang.Apply(tmp203, []any{tmp205, tmp207})
																tmp209 := lang.Apply(tmp202, []any{tmp208})
																tmp210 := lang.Apply(tmp201, []any{tmp209})
																tmp211 := lang.Apply(tmp198, []any{tmp200, tmp210})
																tmp212 := lang.Apply(tmp197, []any{tmp211})
																tmp213 := lang.Apply(tmp196, []any{tmp212})
																tmp214 := lang.Apply(tmp188, []any{tmp190, tmp193, tmp195, tmp213})
																tmp215 := lang.Apply(tmp187, []any{tmp214})
																tmp216 := lang.Apply(tmp185, []any{tmp186, tmp215})
																tmp217 := lang.Apply(tmp184, []any{tmp216})
																tmp218 := checkDerefVar(var_glojure_DOT_core_list)
																tmp219 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp220 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp221 := checkDerefVar(var_glojure_DOT_core_list)
																tmp222 := lang.Apply(tmp221, []any{sym_if})
																tmp223 := checkDerefVar(var_glojure_DOT_core_list)
																tmp224 := lang.Apply(tmp223, []any{sym_fs__1__auto__})
																tmp225 := checkDerefVar(var_glojure_DOT_core_list)
																tmp226 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp227 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp228 := checkDerefVar(var_glojure_DOT_core_list)
																tmp229 := lang.Apply(tmp228, []any{sym_glojure_DOT_core_SLASH_concat})
																tmp230 := checkDerefVar(var_glojure_DOT_core_list)
																tmp231 := lang.Apply(tmp230, []any{sym_fs__1__auto__})
																tmp232 := checkDerefVar(var_glojure_DOT_core_list)
																tmp233 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp234 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp235 := checkDerefVar(var_glojure_DOT_core_list)
																tmp236 := lang.Apply(tmp235, []any{v88})
																tmp237 := checkDerefVar(var_glojure_DOT_core_list)
																tmp238 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp239 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp240 := checkDerefVar(var_glojure_DOT_core_list)
																tmp241 := lang.Apply(tmp240, []any{sym_glojure_DOT_core_SLASH_rest})
																tmp242 := checkDerefVar(var_glojure_DOT_core_list)
																tmp243 := lang.Apply(tmp242, []any{v91})
																tmp244 := lang.Apply(tmp239, []any{tmp241, tmp243})
																tmp245 := lang.Apply(tmp238, []any{tmp244})
																tmp246 := lang.Apply(tmp237, []any{tmp245})
																tmp247 := lang.Apply(tmp234, []any{tmp236, tmp246})
																tmp248 := lang.Apply(tmp233, []any{tmp247})
																tmp249 := lang.Apply(tmp232, []any{tmp248})
																tmp250 := lang.Apply(tmp227, []any{tmp229, tmp231, tmp249})
																tmp251 := lang.Apply(tmp226, []any{tmp250})
																tmp252 := lang.Apply(tmp225, []any{tmp251})
																tmp253 := checkDerefVar(var_glojure_DOT_core_list)
																tmp254 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp255 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp256 := checkDerefVar(var_glojure_DOT_core_list)
																tmp257 := lang.Apply(tmp256, []any{sym_recur})
																tmp258 := checkDerefVar(var_glojure_DOT_core_list)
																tmp259 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp260 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp261 := checkDerefVar(var_glojure_DOT_core_list)
																tmp262 := lang.Apply(tmp261, []any{sym_glojure_DOT_core_SLASH_rest})
																tmp263 := checkDerefVar(var_glojure_DOT_core_list)
																tmp264 := lang.Apply(tmp263, []any{v91})
																tmp265 := lang.Apply(tmp260, []any{tmp262, tmp264})
																tmp266 := lang.Apply(tmp259, []any{tmp265})
																tmp267 := lang.Apply(tmp258, []any{tmp266})
																tmp268 := lang.Apply(tmp255, []any{tmp257, tmp267})
																tmp269 := lang.Apply(tmp254, []any{tmp268})
																tmp270 := lang.Apply(tmp253, []any{tmp269})
																tmp271 := lang.Apply(tmp220, []any{tmp222, tmp224, tmp252, tmp270})
																tmp272 := lang.Apply(tmp219, []any{tmp271})
																tmp273 := lang.Apply(tmp218, []any{tmp272})
																tmp274 := lang.Apply(tmp181, []any{tmp183, tmp217, tmp273})
																tmp275 := lang.Apply(tmp180, []any{tmp274})
																tmp179 = tmp275
															} else {
																var tmp276 any
																if lang.IsTruthy(kw_else) {
																	tmp277 := checkDerefVar(var_glojure_DOT_core_seq)
																	tmp278 := checkDerefVar(var_glojure_DOT_core_concat)
																	tmp279 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp280 := lang.Apply(tmp279, []any{sym_glojure_DOT_core_SLASH_cons})
																	tmp281 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp282 := lang.Apply(tmp281, []any{v5})
																	tmp283 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp284 := checkDerefVar(var_glojure_DOT_core_seq)
																	tmp285 := checkDerefVar(var_glojure_DOT_core_concat)
																	tmp286 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp287 := lang.Apply(tmp286, []any{v88})
																	tmp288 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp289 := checkDerefVar(var_glojure_DOT_core_seq)
																	tmp290 := checkDerefVar(var_glojure_DOT_core_concat)
																	tmp291 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp292 := lang.Apply(tmp291, []any{sym_glojure_DOT_core_SLASH_rest})
																	tmp293 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp294 := lang.Apply(tmp293, []any{v91})
																	tmp295 := lang.Apply(tmp290, []any{tmp292, tmp294})
																	tmp296 := lang.Apply(tmp289, []any{tmp295})
																	tmp297 := lang.Apply(tmp288, []any{tmp296})
																	tmp298 := lang.Apply(tmp285, []any{tmp287, tmp297})
																	tmp299 := lang.Apply(tmp284, []any{tmp298})
																	tmp300 := lang.Apply(tmp283, []any{tmp299})
																	tmp301 := lang.Apply(tmp278, []any{tmp280, tmp282, tmp300})
																	tmp302 := lang.Apply(tmp277, []any{tmp301})
																	tmp276 = tmp302
																} else {
																}
																tmp179 = tmp276
															}
															tmp175 = tmp179
														}
														tmp143 = tmp175
													}
													tmp129 = tmp143
												}
												tmp115 = tmp129
											}
											tmp95 = tmp115
										} // end let
										return tmp95
									})
									v93 = tmp92
									_ = v93
								}
								tmp93 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4672), kw_column, int(34), kw_end_DASH_line, int(4687), kw_end_DASH_column, int(73))
								tmp94, err := lang.WithMeta(tmp92, tmp93.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								var v95 any = tmp94
								_ = v95
								var tmp96 any
								if lang.IsTruthy(v84) {
									tmp97 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp98 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp99 := checkDerefVar(var_glojure_DOT_core_list)
									tmp100 := lang.Apply(tmp99, []any{sym_glojure_DOT_core_SLASH_fn})
									tmp101 := checkDerefVar(var_glojure_DOT_core_list)
									tmp102 := lang.Apply(tmp101, []any{v88})
									tmp103 := checkDerefVar(var_glojure_DOT_core_list)
									tmp104 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp105 := checkDerefVar(var_glojure_DOT_core_vector)
									tmp106 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp107 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp108 := checkDerefVar(var_glojure_DOT_core_list)
									tmp109 := lang.Apply(tmp108, []any{v91})
									tmp110 := lang.Apply(tmp107, []any{tmp109})
									tmp111 := lang.Apply(tmp106, []any{tmp110})
									tmp112 := lang.Apply(tmp104, []any{tmp105, tmp111})
									tmp113 := lang.Apply(tmp103, []any{tmp112})
									tmp114 := checkDerefVar(var_glojure_DOT_core_list)
									tmp115 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp116 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp117 := checkDerefVar(var_glojure_DOT_core_list)
									tmp118 := lang.Apply(tmp117, []any{sym_glojure_DOT_core_SLASH_lazy_DASH_seq})
									tmp119 := checkDerefVar(var_glojure_DOT_core_list)
									tmp120 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp121 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp122 := checkDerefVar(var_glojure_DOT_core_list)
									tmp123 := lang.Apply(tmp122, []any{sym_glojure_DOT_core_SLASH_loop})
									tmp124 := checkDerefVar(var_glojure_DOT_core_list)
									tmp125 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp126 := checkDerefVar(var_glojure_DOT_core_vector)
									tmp127 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp128 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp129 := checkDerefVar(var_glojure_DOT_core_list)
									tmp130 := lang.Apply(tmp129, []any{v91})
									tmp131 := checkDerefVar(var_glojure_DOT_core_list)
									tmp132 := lang.Apply(tmp131, []any{v91})
									tmp133 := lang.Apply(tmp128, []any{tmp130, tmp132})
									tmp134 := lang.Apply(tmp127, []any{tmp133})
									tmp135 := lang.Apply(tmp125, []any{tmp126, tmp134})
									tmp136 := lang.Apply(tmp124, []any{tmp135})
									tmp137 := checkDerefVar(var_glojure_DOT_core_list)
									tmp138 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp139 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp140 := checkDerefVar(var_glojure_DOT_core_list)
									tmp141 := lang.Apply(tmp140, []any{sym_glojure_DOT_core_SLASH_when_DASH_first})
									tmp142 := checkDerefVar(var_glojure_DOT_core_list)
									tmp143 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp144 := checkDerefVar(var_glojure_DOT_core_vector)
									tmp145 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp146 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp147 := checkDerefVar(var_glojure_DOT_core_list)
									tmp148 := lang.Apply(tmp147, []any{v65})
									tmp149 := checkDerefVar(var_glojure_DOT_core_list)
									tmp150 := lang.Apply(tmp149, []any{v91})
									tmp151 := lang.Apply(tmp146, []any{tmp148, tmp150})
									tmp152 := lang.Apply(tmp145, []any{tmp151})
									tmp153 := lang.Apply(tmp143, []any{tmp144, tmp152})
									tmp154 := lang.Apply(tmp142, []any{tmp153})
									tmp155 := checkDerefVar(var_glojure_DOT_core_list)
									tmp156 := lang.Apply(v95, []any{v73})
									tmp157 := lang.Apply(tmp155, []any{tmp156})
									tmp158 := lang.Apply(tmp139, []any{tmp141, tmp154, tmp157})
									tmp159 := lang.Apply(tmp138, []any{tmp158})
									tmp160 := lang.Apply(tmp137, []any{tmp159})
									tmp161 := lang.Apply(tmp121, []any{tmp123, tmp136, tmp160})
									tmp162 := lang.Apply(tmp120, []any{tmp161})
									tmp163 := lang.Apply(tmp119, []any{tmp162})
									tmp164 := lang.Apply(tmp116, []any{tmp118, tmp163})
									tmp165 := lang.Apply(tmp115, []any{tmp164})
									tmp166 := lang.Apply(tmp114, []any{tmp165})
									tmp167 := lang.Apply(tmp98, []any{tmp100, tmp102, tmp113, tmp166})
									tmp168 := lang.Apply(tmp97, []any{tmp167})
									tmp96 = tmp168
								} else {
									var tmp169 any
									{ // let
										// let binding "gi"
										tmp170 := checkDerefVar(var_glojure_DOT_core_gensym)
										tmp171 := lang.Apply(tmp170, []any{"i__"})
										var v172 any = tmp171
										_ = v172
										// let binding "gb"
										tmp173 := checkDerefVar(var_glojure_DOT_core_gensym)
										tmp174 := lang.Apply(tmp173, []any{"b__"})
										var v175 any = tmp174
										_ = v175
										// let binding "do-cmod"
										var tmp176 lang.FnFunc
										{ // function do-cmod
											var v177 lang.FnFunc
											tmp176 = lang.NewFnFunc(func(args ...any) any {
												checkArity(args, 1)
												v178 := args[0]
												_ = v178
												var tmp179 any
												{ // let
													// let binding "vec__48"
													var v180 any = v178
													_ = v180
													// let binding "seq__49"
													tmp181 := checkDerefVar(var_glojure_DOT_core_seq)
													tmp182 := lang.Apply(tmp181, []any{v180})
													var v183 any = tmp182
													_ = v183
													// let binding "first__50"
													tmp184 := checkDerefVar(var_glojure_DOT_core_first)
													tmp185 := lang.Apply(tmp184, []any{v183})
													var v186 any = tmp185
													_ = v186
													// let binding "seq__49"
													tmp187 := checkDerefVar(var_glojure_DOT_core_next)
													tmp188 := lang.Apply(tmp187, []any{v183})
													var v189 any = tmp188
													_ = v189
													// let binding "vec__51"
													var v190 any = v186
													_ = v190
													// let binding "k"
													tmp191 := checkDerefVar(var_glojure_DOT_core_nth)
													tmp192 := lang.Apply(tmp191, []any{v190, int64(0), nil})
													var v193 any = tmp192
													_ = v193
													// let binding "v"
													tmp194 := checkDerefVar(var_glojure_DOT_core_nth)
													tmp195 := lang.Apply(tmp194, []any{v190, int64(1), nil})
													var v196 any = tmp195
													_ = v196
													// let binding "pair"
													var v197 any = v190
													_ = v197
													// let binding "etc"
													var v198 any = v189
													_ = v198
													var tmp199 any
													tmp200 := checkDerefVar(var_glojure_DOT_core__EQ_)
													tmp201 := lang.Apply(tmp200, []any{v193, kw_let})
													if lang.IsTruthy(tmp201) {
														tmp202 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp203 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp204 := checkDerefVar(var_glojure_DOT_core_list)
														tmp205 := lang.Apply(tmp204, []any{sym_glojure_DOT_core_SLASH_let})
														tmp206 := checkDerefVar(var_glojure_DOT_core_list)
														tmp207 := lang.Apply(tmp206, []any{v196})
														tmp208 := checkDerefVar(var_glojure_DOT_core_list)
														tmp209 := lang.Apply(v177, []any{v198})
														tmp210 := lang.Apply(tmp208, []any{tmp209})
														tmp211 := lang.Apply(tmp203, []any{tmp205, tmp207, tmp210})
														tmp212 := lang.Apply(tmp202, []any{tmp211})
														tmp199 = tmp212
													} else {
														var tmp213 any
														tmp214 := checkDerefVar(var_glojure_DOT_core__EQ_)
														tmp215 := lang.Apply(tmp214, []any{v193, kw_while})
														if lang.IsTruthy(tmp215) {
															tmp216 := checkDerefVar(var_glojure_DOT_core_seq)
															tmp217 := checkDerefVar(var_glojure_DOT_core_concat)
															tmp218 := checkDerefVar(var_glojure_DOT_core_list)
															tmp219 := lang.Apply(tmp218, []any{sym_glojure_DOT_core_SLASH_when})
															tmp220 := checkDerefVar(var_glojure_DOT_core_list)
															tmp221 := lang.Apply(tmp220, []any{v196})
															tmp222 := checkDerefVar(var_glojure_DOT_core_list)
															tmp223 := lang.Apply(v177, []any{v198})
															tmp224 := lang.Apply(tmp222, []any{tmp223})
															tmp225 := lang.Apply(tmp217, []any{tmp219, tmp221, tmp224})
															tmp226 := lang.Apply(tmp216, []any{tmp225})
															tmp213 = tmp226
														} else {
															var tmp227 any
															tmp228 := checkDerefVar(var_glojure_DOT_core__EQ_)
															tmp229 := lang.Apply(tmp228, []any{v193, kw_when})
															if lang.IsTruthy(tmp229) {
																tmp230 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp231 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp232 := checkDerefVar(var_glojure_DOT_core_list)
																tmp233 := lang.Apply(tmp232, []any{sym_if})
																tmp234 := checkDerefVar(var_glojure_DOT_core_list)
																tmp235 := lang.Apply(tmp234, []any{v196})
																tmp236 := checkDerefVar(var_glojure_DOT_core_list)
																tmp237 := lang.Apply(v177, []any{v198})
																tmp238 := lang.Apply(tmp236, []any{tmp237})
																tmp239 := checkDerefVar(var_glojure_DOT_core_list)
																tmp240 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp241 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp242 := checkDerefVar(var_glojure_DOT_core_list)
																tmp243 := lang.Apply(tmp242, []any{sym_recur})
																tmp244 := checkDerefVar(var_glojure_DOT_core_list)
																tmp245 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp246 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp247 := checkDerefVar(var_glojure_DOT_core_list)
																tmp248 := lang.Apply(tmp247, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc})
																tmp249 := checkDerefVar(var_glojure_DOT_core_list)
																tmp250 := lang.Apply(tmp249, []any{v172})
																tmp251 := lang.Apply(tmp246, []any{tmp248, tmp250})
																tmp252 := lang.Apply(tmp245, []any{tmp251})
																tmp253 := lang.Apply(tmp244, []any{tmp252})
																tmp254 := lang.Apply(tmp241, []any{tmp243, tmp253})
																tmp255 := lang.Apply(tmp240, []any{tmp254})
																tmp256 := lang.Apply(tmp239, []any{tmp255})
																tmp257 := lang.Apply(tmp231, []any{tmp233, tmp235, tmp238, tmp256})
																tmp258 := lang.Apply(tmp230, []any{tmp257})
																tmp227 = tmp258
															} else {
																var tmp259 any
																tmp260 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
																tmp261 := lang.Apply(tmp260, []any{v193})
																if lang.IsTruthy(tmp261) {
																	tmp262 := lang.Apply(v40, []any{"Invalid 'for' keyword ", v193})
																	tmp259 = tmp262
																} else {
																	var tmp263 any
																	if lang.IsTruthy(kw_else) {
																		tmp264 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp265 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp266 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp267 := lang.Apply(tmp266, []any{sym_do})
																		tmp268 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp269 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp270 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp271 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp272 := lang.Apply(tmp271, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_append})
																		tmp273 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp274 := lang.Apply(tmp273, []any{v175})
																		tmp275 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp276 := lang.Apply(tmp275, []any{v5})
																		tmp277 := lang.Apply(tmp270, []any{tmp272, tmp274, tmp276})
																		tmp278 := lang.Apply(tmp269, []any{tmp277})
																		tmp279 := lang.Apply(tmp268, []any{tmp278})
																		tmp280 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp281 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp282 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp283 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp284 := lang.Apply(tmp283, []any{sym_recur})
																		tmp285 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp286 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp287 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp288 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp289 := lang.Apply(tmp288, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc})
																		tmp290 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp291 := lang.Apply(tmp290, []any{v172})
																		tmp292 := lang.Apply(tmp287, []any{tmp289, tmp291})
																		tmp293 := lang.Apply(tmp286, []any{tmp292})
																		tmp294 := lang.Apply(tmp285, []any{tmp293})
																		tmp295 := lang.Apply(tmp282, []any{tmp284, tmp294})
																		tmp296 := lang.Apply(tmp281, []any{tmp295})
																		tmp297 := lang.Apply(tmp280, []any{tmp296})
																		tmp298 := lang.Apply(tmp265, []any{tmp267, tmp279, tmp297})
																		tmp299 := lang.Apply(tmp264, []any{tmp298})
																		tmp263 = tmp299
																	} else {
																	}
																	tmp259 = tmp263
																}
																tmp227 = tmp259
															}
															tmp213 = tmp227
														}
														tmp199 = tmp213
													}
													tmp179 = tmp199
												} // end let
												return tmp179
											})
											v177 = tmp176
											_ = v177
										}
										tmp177 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4698), kw_column, int(39), kw_end_DASH_line, int(4710), kw_end_DASH_column, int(79))
										tmp178, err := lang.WithMeta(tmp176, tmp177.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										var v179 any = tmp178
										_ = v179
										tmp180 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp181 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp182 := checkDerefVar(var_glojure_DOT_core_list)
										tmp183 := lang.Apply(tmp182, []any{sym_glojure_DOT_core_SLASH_fn})
										tmp184 := checkDerefVar(var_glojure_DOT_core_list)
										tmp185 := lang.Apply(tmp184, []any{v88})
										tmp186 := checkDerefVar(var_glojure_DOT_core_list)
										tmp187 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp188 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp189 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp190 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp191 := checkDerefVar(var_glojure_DOT_core_list)
										tmp192 := lang.Apply(tmp191, []any{v91})
										tmp193 := lang.Apply(tmp190, []any{tmp192})
										tmp194 := lang.Apply(tmp189, []any{tmp193})
										tmp195 := lang.Apply(tmp187, []any{tmp188, tmp194})
										tmp196 := lang.Apply(tmp186, []any{tmp195})
										tmp197 := checkDerefVar(var_glojure_DOT_core_list)
										tmp198 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp199 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp200 := checkDerefVar(var_glojure_DOT_core_list)
										tmp201 := lang.Apply(tmp200, []any{sym_glojure_DOT_core_SLASH_lazy_DASH_seq})
										tmp202 := checkDerefVar(var_glojure_DOT_core_list)
										tmp203 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp204 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp205 := checkDerefVar(var_glojure_DOT_core_list)
										tmp206 := lang.Apply(tmp205, []any{sym_glojure_DOT_core_SLASH_loop})
										tmp207 := checkDerefVar(var_glojure_DOT_core_list)
										tmp208 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp209 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp210 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp211 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp212 := checkDerefVar(var_glojure_DOT_core_list)
										tmp213 := lang.Apply(tmp212, []any{v91})
										tmp214 := checkDerefVar(var_glojure_DOT_core_list)
										tmp215 := lang.Apply(tmp214, []any{v91})
										tmp216 := lang.Apply(tmp211, []any{tmp213, tmp215})
										tmp217 := lang.Apply(tmp210, []any{tmp216})
										tmp218 := lang.Apply(tmp208, []any{tmp209, tmp217})
										tmp219 := lang.Apply(tmp207, []any{tmp218})
										tmp220 := checkDerefVar(var_glojure_DOT_core_list)
										tmp221 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp222 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp223 := checkDerefVar(var_glojure_DOT_core_list)
										tmp224 := lang.Apply(tmp223, []any{sym_glojure_DOT_core_SLASH_when_DASH_let})
										tmp225 := checkDerefVar(var_glojure_DOT_core_list)
										tmp226 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp227 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp228 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp229 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp230 := checkDerefVar(var_glojure_DOT_core_list)
										tmp231 := lang.Apply(tmp230, []any{v91})
										tmp232 := checkDerefVar(var_glojure_DOT_core_list)
										tmp233 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp234 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp235 := checkDerefVar(var_glojure_DOT_core_list)
										tmp236 := lang.Apply(tmp235, []any{sym_glojure_DOT_core_SLASH_seq})
										tmp237 := checkDerefVar(var_glojure_DOT_core_list)
										tmp238 := lang.Apply(tmp237, []any{v91})
										tmp239 := lang.Apply(tmp234, []any{tmp236, tmp238})
										tmp240 := lang.Apply(tmp233, []any{tmp239})
										tmp241 := lang.Apply(tmp232, []any{tmp240})
										tmp242 := lang.Apply(tmp229, []any{tmp231, tmp241})
										tmp243 := lang.Apply(tmp228, []any{tmp242})
										tmp244 := lang.Apply(tmp226, []any{tmp227, tmp243})
										tmp245 := lang.Apply(tmp225, []any{tmp244})
										tmp246 := checkDerefVar(var_glojure_DOT_core_list)
										tmp247 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp248 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp249 := checkDerefVar(var_glojure_DOT_core_list)
										tmp250 := lang.Apply(tmp249, []any{sym_if})
										tmp251 := checkDerefVar(var_glojure_DOT_core_list)
										tmp252 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp253 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp254 := checkDerefVar(var_glojure_DOT_core_list)
										tmp255 := lang.Apply(tmp254, []any{sym_glojure_DOT_core_SLASH_chunked_DASH_seq_QMARK_})
										tmp256 := checkDerefVar(var_glojure_DOT_core_list)
										tmp257 := lang.Apply(tmp256, []any{v91})
										tmp258 := lang.Apply(tmp253, []any{tmp255, tmp257})
										tmp259 := lang.Apply(tmp252, []any{tmp258})
										tmp260 := lang.Apply(tmp251, []any{tmp259})
										tmp261 := checkDerefVar(var_glojure_DOT_core_list)
										tmp262 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp263 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp264 := checkDerefVar(var_glojure_DOT_core_list)
										tmp265 := lang.Apply(tmp264, []any{sym_glojure_DOT_core_SLASH_let})
										tmp266 := checkDerefVar(var_glojure_DOT_core_list)
										tmp267 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp268 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp269 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp270 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp271 := checkDerefVar(var_glojure_DOT_core_list)
										tmp272 := lang.Apply(tmp271, []any{sym_c__0__auto__})
										tmp273 := checkDerefVar(var_glojure_DOT_core_list)
										tmp274 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp275 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp276 := checkDerefVar(var_glojure_DOT_core_list)
										tmp277 := lang.Apply(tmp276, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_first})
										tmp278 := checkDerefVar(var_glojure_DOT_core_list)
										tmp279 := lang.Apply(tmp278, []any{v91})
										tmp280 := lang.Apply(tmp275, []any{tmp277, tmp279})
										tmp281 := lang.Apply(tmp274, []any{tmp280})
										tmp282 := lang.Apply(tmp273, []any{tmp281})
										tmp283 := checkDerefVar(var_glojure_DOT_core_list)
										tmp284 := lang.Apply(tmp283, []any{sym_size__1__auto__})
										tmp285 := checkDerefVar(var_glojure_DOT_core_list)
										tmp286 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp287 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp288 := checkDerefVar(var_glojure_DOT_core_list)
										tmp289 := lang.Apply(tmp288, []any{sym_glojure_DOT_core_SLASH_int})
										tmp290 := checkDerefVar(var_glojure_DOT_core_list)
										tmp291 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp292 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp293 := checkDerefVar(var_glojure_DOT_core_list)
										tmp294 := lang.Apply(tmp293, []any{sym_glojure_DOT_core_SLASH_count})
										tmp295 := checkDerefVar(var_glojure_DOT_core_list)
										tmp296 := lang.Apply(tmp295, []any{sym_c__0__auto__})
										tmp297 := lang.Apply(tmp292, []any{tmp294, tmp296})
										tmp298 := lang.Apply(tmp291, []any{tmp297})
										tmp299 := lang.Apply(tmp290, []any{tmp298})
										tmp300 := lang.Apply(tmp287, []any{tmp289, tmp299})
										tmp301 := lang.Apply(tmp286, []any{tmp300})
										tmp302 := lang.Apply(tmp285, []any{tmp301})
										tmp303 := checkDerefVar(var_glojure_DOT_core_list)
										tmp304 := lang.Apply(tmp303, []any{v175})
										tmp305 := checkDerefVar(var_glojure_DOT_core_list)
										tmp306 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp307 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp308 := checkDerefVar(var_glojure_DOT_core_list)
										tmp309 := lang.Apply(tmp308, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_buffer})
										tmp310 := checkDerefVar(var_glojure_DOT_core_list)
										tmp311 := lang.Apply(tmp310, []any{sym_size__1__auto__})
										tmp312 := lang.Apply(tmp307, []any{tmp309, tmp311})
										tmp313 := lang.Apply(tmp306, []any{tmp312})
										tmp314 := lang.Apply(tmp305, []any{tmp313})
										tmp315 := lang.Apply(tmp270, []any{tmp272, tmp282, tmp284, tmp302, tmp304, tmp314})
										tmp316 := lang.Apply(tmp269, []any{tmp315})
										tmp317 := lang.Apply(tmp267, []any{tmp268, tmp316})
										tmp318 := lang.Apply(tmp266, []any{tmp317})
										tmp319 := checkDerefVar(var_glojure_DOT_core_list)
										tmp320 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp321 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp322 := checkDerefVar(var_glojure_DOT_core_list)
										tmp323 := lang.Apply(tmp322, []any{sym_if})
										tmp324 := checkDerefVar(var_glojure_DOT_core_list)
										tmp325 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp326 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp327 := checkDerefVar(var_glojure_DOT_core_list)
										tmp328 := lang.Apply(tmp327, []any{sym_glojure_DOT_core_SLASH_loop})
										tmp329 := checkDerefVar(var_glojure_DOT_core_list)
										tmp330 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp331 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp332 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp333 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp334 := checkDerefVar(var_glojure_DOT_core_list)
										tmp335 := lang.Apply(tmp334, []any{v172})
										tmp336 := checkDerefVar(var_glojure_DOT_core_list)
										tmp337 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp338 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp339 := checkDerefVar(var_glojure_DOT_core_list)
										tmp340 := lang.Apply(tmp339, []any{sym_glojure_DOT_core_SLASH_int})
										tmp341 := checkDerefVar(var_glojure_DOT_core_list)
										tmp342 := lang.Apply(tmp341, []any{int64(0)})
										tmp343 := lang.Apply(tmp338, []any{tmp340, tmp342})
										tmp344 := lang.Apply(tmp337, []any{tmp343})
										tmp345 := lang.Apply(tmp336, []any{tmp344})
										tmp346 := lang.Apply(tmp333, []any{tmp335, tmp345})
										tmp347 := lang.Apply(tmp332, []any{tmp346})
										tmp348 := lang.Apply(tmp330, []any{tmp331, tmp347})
										tmp349 := lang.Apply(tmp329, []any{tmp348})
										tmp350 := checkDerefVar(var_glojure_DOT_core_list)
										tmp351 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp352 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp353 := checkDerefVar(var_glojure_DOT_core_list)
										tmp354 := lang.Apply(tmp353, []any{sym_if})
										tmp355 := checkDerefVar(var_glojure_DOT_core_list)
										tmp356 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp357 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp358 := checkDerefVar(var_glojure_DOT_core_list)
										tmp359 := lang.Apply(tmp358, []any{sym_glojure_DOT_core_SLASH__LT_})
										tmp360 := checkDerefVar(var_glojure_DOT_core_list)
										tmp361 := lang.Apply(tmp360, []any{v172})
										tmp362 := checkDerefVar(var_glojure_DOT_core_list)
										tmp363 := lang.Apply(tmp362, []any{sym_size__1__auto__})
										tmp364 := lang.Apply(tmp357, []any{tmp359, tmp361, tmp363})
										tmp365 := lang.Apply(tmp356, []any{tmp364})
										tmp366 := lang.Apply(tmp355, []any{tmp365})
										tmp367 := checkDerefVar(var_glojure_DOT_core_list)
										tmp368 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp369 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp370 := checkDerefVar(var_glojure_DOT_core_list)
										tmp371 := lang.Apply(tmp370, []any{sym_glojure_DOT_core_SLASH_let})
										tmp372 := checkDerefVar(var_glojure_DOT_core_list)
										tmp373 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp374 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp375 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp376 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp377 := checkDerefVar(var_glojure_DOT_core_list)
										tmp378 := lang.Apply(tmp377, []any{v65})
										tmp379 := checkDerefVar(var_glojure_DOT_core_list)
										tmp380 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp381 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp382 := checkDerefVar(var_glojure_DOT_core_list)
										tmp383 := lang.Apply(tmp382, []any{sym__DOT_nth})
										tmp384 := checkDerefVar(var_glojure_DOT_core_list)
										tmp385 := lang.Apply(tmp384, []any{sym_c__0__auto__})
										tmp386 := checkDerefVar(var_glojure_DOT_core_list)
										tmp387 := lang.Apply(tmp386, []any{v172})
										tmp388 := lang.Apply(tmp381, []any{tmp383, tmp385, tmp387})
										tmp389 := lang.Apply(tmp380, []any{tmp388})
										tmp390 := lang.Apply(tmp379, []any{tmp389})
										tmp391 := lang.Apply(tmp376, []any{tmp378, tmp390})
										tmp392 := lang.Apply(tmp375, []any{tmp391})
										tmp393 := lang.Apply(tmp373, []any{tmp374, tmp392})
										tmp394 := lang.Apply(tmp372, []any{tmp393})
										tmp395 := checkDerefVar(var_glojure_DOT_core_list)
										tmp396 := lang.Apply(v179, []any{v73})
										tmp397 := lang.Apply(tmp395, []any{tmp396})
										tmp398 := lang.Apply(tmp369, []any{tmp371, tmp394, tmp397})
										tmp399 := lang.Apply(tmp368, []any{tmp398})
										tmp400 := lang.Apply(tmp367, []any{tmp399})
										tmp401 := checkDerefVar(var_glojure_DOT_core_list)
										tmp402 := lang.Apply(tmp401, []any{true})
										tmp403 := lang.Apply(tmp352, []any{tmp354, tmp366, tmp400, tmp402})
										tmp404 := lang.Apply(tmp351, []any{tmp403})
										tmp405 := lang.Apply(tmp350, []any{tmp404})
										tmp406 := lang.Apply(tmp326, []any{tmp328, tmp349, tmp405})
										tmp407 := lang.Apply(tmp325, []any{tmp406})
										tmp408 := lang.Apply(tmp324, []any{tmp407})
										tmp409 := checkDerefVar(var_glojure_DOT_core_list)
										tmp410 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp411 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp412 := checkDerefVar(var_glojure_DOT_core_list)
										tmp413 := lang.Apply(tmp412, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_cons})
										tmp414 := checkDerefVar(var_glojure_DOT_core_list)
										tmp415 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp416 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp417 := checkDerefVar(var_glojure_DOT_core_list)
										tmp418 := lang.Apply(tmp417, []any{sym_glojure_DOT_core_SLASH_chunk})
										tmp419 := checkDerefVar(var_glojure_DOT_core_list)
										tmp420 := lang.Apply(tmp419, []any{v175})
										tmp421 := lang.Apply(tmp416, []any{tmp418, tmp420})
										tmp422 := lang.Apply(tmp415, []any{tmp421})
										tmp423 := lang.Apply(tmp414, []any{tmp422})
										tmp424 := checkDerefVar(var_glojure_DOT_core_list)
										tmp425 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp426 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp427 := checkDerefVar(var_glojure_DOT_core_list)
										tmp428 := lang.Apply(tmp427, []any{v88})
										tmp429 := checkDerefVar(var_glojure_DOT_core_list)
										tmp430 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp431 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp432 := checkDerefVar(var_glojure_DOT_core_list)
										tmp433 := lang.Apply(tmp432, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_rest})
										tmp434 := checkDerefVar(var_glojure_DOT_core_list)
										tmp435 := lang.Apply(tmp434, []any{v91})
										tmp436 := lang.Apply(tmp431, []any{tmp433, tmp435})
										tmp437 := lang.Apply(tmp430, []any{tmp436})
										tmp438 := lang.Apply(tmp429, []any{tmp437})
										tmp439 := lang.Apply(tmp426, []any{tmp428, tmp438})
										tmp440 := lang.Apply(tmp425, []any{tmp439})
										tmp441 := lang.Apply(tmp424, []any{tmp440})
										tmp442 := lang.Apply(tmp411, []any{tmp413, tmp423, tmp441})
										tmp443 := lang.Apply(tmp410, []any{tmp442})
										tmp444 := lang.Apply(tmp409, []any{tmp443})
										tmp445 := checkDerefVar(var_glojure_DOT_core_list)
										tmp446 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp447 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp448 := checkDerefVar(var_glojure_DOT_core_list)
										tmp449 := lang.Apply(tmp448, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_cons})
										tmp450 := checkDerefVar(var_glojure_DOT_core_list)
										tmp451 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp452 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp453 := checkDerefVar(var_glojure_DOT_core_list)
										tmp454 := lang.Apply(tmp453, []any{sym_glojure_DOT_core_SLASH_chunk})
										tmp455 := checkDerefVar(var_glojure_DOT_core_list)
										tmp456 := lang.Apply(tmp455, []any{v175})
										tmp457 := lang.Apply(tmp452, []any{tmp454, tmp456})
										tmp458 := lang.Apply(tmp451, []any{tmp457})
										tmp459 := lang.Apply(tmp450, []any{tmp458})
										tmp460 := checkDerefVar(var_glojure_DOT_core_list)
										tmp461 := lang.Apply(tmp460, []any{nil})
										tmp462 := lang.Apply(tmp447, []any{tmp449, tmp459, tmp461})
										tmp463 := lang.Apply(tmp446, []any{tmp462})
										tmp464 := lang.Apply(tmp445, []any{tmp463})
										tmp465 := lang.Apply(tmp321, []any{tmp323, tmp408, tmp444, tmp464})
										tmp466 := lang.Apply(tmp320, []any{tmp465})
										tmp467 := lang.Apply(tmp319, []any{tmp466})
										tmp468 := lang.Apply(tmp263, []any{tmp265, tmp318, tmp467})
										tmp469 := lang.Apply(tmp262, []any{tmp468})
										tmp470 := lang.Apply(tmp261, []any{tmp469})
										tmp471 := checkDerefVar(var_glojure_DOT_core_list)
										tmp472 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp473 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp474 := checkDerefVar(var_glojure_DOT_core_list)
										tmp475 := lang.Apply(tmp474, []any{sym_glojure_DOT_core_SLASH_let})
										tmp476 := checkDerefVar(var_glojure_DOT_core_list)
										tmp477 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp478 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp479 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp480 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp481 := checkDerefVar(var_glojure_DOT_core_list)
										tmp482 := lang.Apply(tmp481, []any{v65})
										tmp483 := checkDerefVar(var_glojure_DOT_core_list)
										tmp484 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp485 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp486 := checkDerefVar(var_glojure_DOT_core_list)
										tmp487 := lang.Apply(tmp486, []any{sym_glojure_DOT_core_SLASH_first})
										tmp488 := checkDerefVar(var_glojure_DOT_core_list)
										tmp489 := lang.Apply(tmp488, []any{v91})
										tmp490 := lang.Apply(tmp485, []any{tmp487, tmp489})
										tmp491 := lang.Apply(tmp484, []any{tmp490})
										tmp492 := lang.Apply(tmp483, []any{tmp491})
										tmp493 := lang.Apply(tmp480, []any{tmp482, tmp492})
										tmp494 := lang.Apply(tmp479, []any{tmp493})
										tmp495 := lang.Apply(tmp477, []any{tmp478, tmp494})
										tmp496 := lang.Apply(tmp476, []any{tmp495})
										tmp497 := checkDerefVar(var_glojure_DOT_core_list)
										tmp498 := lang.Apply(v95, []any{v73})
										tmp499 := lang.Apply(tmp497, []any{tmp498})
										tmp500 := lang.Apply(tmp473, []any{tmp475, tmp496, tmp499})
										tmp501 := lang.Apply(tmp472, []any{tmp500})
										tmp502 := lang.Apply(tmp471, []any{tmp501})
										tmp503 := lang.Apply(tmp248, []any{tmp250, tmp260, tmp470, tmp502})
										tmp504 := lang.Apply(tmp247, []any{tmp503})
										tmp505 := lang.Apply(tmp246, []any{tmp504})
										tmp506 := lang.Apply(tmp222, []any{tmp224, tmp245, tmp505})
										tmp507 := lang.Apply(tmp221, []any{tmp506})
										tmp508 := lang.Apply(tmp220, []any{tmp507})
										tmp509 := lang.Apply(tmp204, []any{tmp206, tmp219, tmp508})
										tmp510 := lang.Apply(tmp203, []any{tmp509})
										tmp511 := lang.Apply(tmp202, []any{tmp510})
										tmp512 := lang.Apply(tmp199, []any{tmp201, tmp511})
										tmp513 := lang.Apply(tmp198, []any{tmp512})
										tmp514 := lang.Apply(tmp197, []any{tmp513})
										tmp515 := lang.Apply(tmp181, []any{tmp183, tmp185, tmp196, tmp514})
										tmp516 := lang.Apply(tmp180, []any{tmp515})
										tmp169 = tmp516
									} // end let
									tmp96 = tmp169
								}
								tmp85 = tmp96
							} // end let
							tmp44 = tmp85
						} // end let
						return tmp44
					})
					v42 = tmp41
					_ = v42
				}
				tmp42 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4668), kw_column, int(19), kw_end_DASH_line, int(4729), kw_end_DASH_column, int(68))
				tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v44 any = tmp43
				_ = v44
				tmp45 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp46 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp47 := checkDerefVar(var_glojure_DOT_core_list)
				tmp48 := lang.Apply(tmp47, []any{sym_glojure_DOT_core_SLASH_let})
				tmp49 := checkDerefVar(var_glojure_DOT_core_list)
				tmp50 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp51 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp53 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp54 := checkDerefVar(var_glojure_DOT_core_list)
				tmp55 := lang.Apply(tmp54, []any{sym_iter__0__auto__})
				tmp56 := checkDerefVar(var_glojure_DOT_core_list)
				tmp57 := lang.Apply(v36, []any{v4})
				tmp58 := lang.Apply(v44, []any{tmp57})
				tmp59 := lang.Apply(tmp56, []any{tmp58})
				tmp60 := lang.Apply(tmp53, []any{tmp55, tmp59})
				tmp61 := lang.Apply(tmp52, []any{tmp60})
				tmp62 := lang.Apply(tmp50, []any{tmp51, tmp61})
				tmp63 := lang.Apply(tmp49, []any{tmp62})
				tmp64 := checkDerefVar(var_glojure_DOT_core_list)
				tmp65 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp66 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp67 := checkDerefVar(var_glojure_DOT_core_list)
				tmp68 := lang.Apply(tmp67, []any{sym_iter__0__auto__})
				tmp69 := checkDerefVar(var_glojure_DOT_core_list)
				tmp70 := checkDerefVar(var_glojure_DOT_core_second)
				tmp71 := lang.Apply(tmp70, []any{v4})
				tmp72 := lang.Apply(tmp69, []any{tmp71})
				tmp73 := lang.Apply(tmp66, []any{tmp68, tmp72})
				tmp74 := lang.Apply(tmp65, []any{tmp73})
				tmp75 := lang.Apply(tmp64, []any{tmp74})
				tmp76 := lang.Apply(tmp46, []any{tmp48, tmp63, tmp75})
				tmp77 := lang.Apply(tmp45, []any{tmp76})
				tmp32 = tmp77
			} // end let
			return tmp32
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_for = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_for.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// let
	{
		tmp0 := sym_let.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "binding => binding-form init-expr\n  binding-form => name, or destructuring-form\n  destructuring-form => map-destructure-form, or seq-destructure-form\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\n\n  See https://glojure.org/reference/special_forms#binding-forms for\n  more information about destructuring.", kw_forms, lang.NewVector(lang.NewList(sym_let, lang.NewVector(sym_bindings_STAR_), sym_exprs_STAR_)), kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(11), kw_line, int(4496), kw_end_DASH_line, int(4496), kw_special_DASH_form, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_str)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp12 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp14 := lang.Apply(tmp13, []any{v2})
					tmp15 := lang.Apply(kw_line, []any{tmp14})
					tmp16 := lang.Apply(tmp9, []any{tmp11, " requires ", "a vector for its binding", " in ", tmp12, ":", tmp15})
					tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
					panic(tmp17)
				}
				_ = tmp6
				var tmp18 any
				tmp19 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp20 := checkDerefVar(var_glojure_DOT_core_count)
				tmp21 := lang.Apply(tmp20, []any{v4})
				tmp22 := lang.Apply(tmp19, []any{tmp21})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "an even number of forms in binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp18
				tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp33 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp34 := checkDerefVar(var_glojure_DOT_core_list)
				tmp35 := lang.Apply(tmp34, []any{sym_let_STAR_})
				tmp36 := checkDerefVar(var_glojure_DOT_core_list)
				tmp37 := checkDerefVar(var_glojure_DOT_core_destructure)
				tmp38 := lang.Apply(tmp37, []any{v4})
				tmp39 := lang.Apply(tmp36, []any{tmp38})
				tmp40 := lang.Apply(tmp33, []any{tmp35, tmp39, v5})
				tmp41 := lang.Apply(tmp32, []any{tmp40})
				return tmp41
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_let = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_let.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// loop
	{
		tmp0 := sym_loop.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", kw_forms, lang.NewVector(lang.NewList(sym_loop, lang.NewVector(sym_bindings_STAR_), sym_exprs_STAR_)), kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(4597), kw_end_DASH_line, int(4597), kw_special_DASH_form, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_str)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v2})
					tmp12 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp14 := lang.Apply(tmp13, []any{v2})
					tmp15 := lang.Apply(kw_line, []any{tmp14})
					tmp16 := lang.Apply(tmp9, []any{tmp11, " requires ", "a vector for its binding", " in ", tmp12, ":", tmp15})
					tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
					panic(tmp17)
				}
				_ = tmp6
				var tmp18 any
				tmp19 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp20 := checkDerefVar(var_glojure_DOT_core_count)
				tmp21 := lang.Apply(tmp20, []any{v4})
				tmp22 := lang.Apply(tmp19, []any{tmp21})
				if lang.IsTruthy(tmp22) {
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_str)
					tmp24 := checkDerefVar(var_glojure_DOT_core_first)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp27 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp28 := lang.Apply(tmp27, []any{v2})
					tmp29 := lang.Apply(kw_line, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp25, " requires ", "an even number of forms in binding vector", " in ", tmp26, ":", tmp29})
					tmp31 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp30})
					panic(tmp31)
				}
				_ = tmp18
				var tmp32 any
				{ // let
					// let binding "db"
					tmp33 := checkDerefVar(var_glojure_DOT_core_destructure)
					tmp34 := lang.Apply(tmp33, []any{v4})
					var v35 any = tmp34
					_ = v35
					var tmp36 any
					tmp37 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp38 := lang.Apply(tmp37, []any{v35, v4})
					if lang.IsTruthy(tmp38) {
						tmp39 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp40 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp41 := checkDerefVar(var_glojure_DOT_core_list)
						tmp42 := lang.Apply(tmp41, []any{sym_loop_STAR_})
						tmp43 := checkDerefVar(var_glojure_DOT_core_list)
						tmp44 := lang.Apply(tmp43, []any{v4})
						tmp45 := lang.Apply(tmp40, []any{tmp42, tmp44, v5})
						tmp46 := lang.Apply(tmp39, []any{tmp45})
						tmp36 = tmp46
					} else {
						var tmp47 any
						{ // let
							// let binding "vs"
							tmp48 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
							tmp49 := checkDerefVar(var_glojure_DOT_core_drop)
							tmp50 := lang.Apply(tmp49, []any{int64(1), v4})
							tmp51 := lang.Apply(tmp48, []any{int64(2), tmp50})
							var v52 any = tmp51
							_ = v52
							// let binding "bs"
							tmp53 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
							tmp54 := lang.Apply(tmp53, []any{int64(2), v4})
							var v55 any = tmp54
							_ = v55
							// let binding "gs"
							tmp56 := checkDerefVar(var_glojure_DOT_core_map)
							var tmp57 lang.FnFunc
							tmp57 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v58 := args[0]
								_ = v58
								var tmp59 any
								tmp60 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
								tmp61 := lang.Apply(tmp60, []any{v58})
								if lang.IsTruthy(tmp61) {
									tmp59 = v58
								} else {
									tmp62 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp63 := lang.Apply(tmp62, nil)
									tmp59 = tmp63
								}
								return tmp59
							})
							tmp58 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4611), kw_column, int(23), kw_end_DASH_line, int(4611), kw_end_DASH_column, int(58))
							tmp59, err := lang.WithMeta(tmp57, tmp58.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp60 := lang.Apply(tmp56, []any{tmp59, v55})
							var v61 any = tmp60
							_ = v61
							// let binding "bfs"
							tmp62 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp63 lang.FnFunc
							tmp63 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v64 := args[0]
								_ = v64
								v65 := args[1]
								_ = v65
								var tmp66 any
								{ // let
									// let binding "vec__17"
									var v67 any = v65
									_ = v67
									// let binding "b"
									tmp68 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp69 := lang.Apply(tmp68, []any{v67, int64(0), nil})
									var v70 any = tmp69
									_ = v70
									// let binding "v"
									tmp71 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp72 := lang.Apply(tmp71, []any{v67, int64(1), nil})
									var v73 any = tmp72
									_ = v73
									// let binding "g"
									tmp74 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp75 := lang.Apply(tmp74, []any{v67, int64(2), nil})
									var v76 any = tmp75
									_ = v76
									var tmp77 any
									tmp78 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
									tmp79 := lang.Apply(tmp78, []any{v70})
									if lang.IsTruthy(tmp79) {
										tmp80 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp81 := lang.Apply(tmp80, []any{v64, v76, v73})
										tmp77 = tmp81
									} else {
										tmp82 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp83 := lang.Apply(tmp82, []any{v64, v76, v73, v70, v76})
										tmp77 = tmp83
									}
									tmp66 = tmp77
								} // end let
								return tmp66
							})
							tmp64 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4612), kw_column, int(28), kw_end_DASH_line, int(4615), kw_end_DASH_column, int(50))
							tmp65, err := lang.WithMeta(tmp63, tmp64.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp66 := lang.NewVector()
							tmp67 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4616), kw_column, int(27), kw_end_DASH_line, int(4616), kw_end_DASH_column, int(28))
							tmp68, err := lang.WithMeta(tmp66, tmp67.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp69 := checkDerefVar(var_glojure_DOT_core_map)
							tmp70 := checkDerefVar(var_glojure_DOT_core_vector)
							tmp71 := lang.Apply(tmp69, []any{tmp70, v55, v52, v61})
							tmp72 := lang.Apply(tmp62, []any{tmp65, tmp68, tmp71})
							var v73 any = tmp72
							_ = v73
							tmp74 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp75 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp76 := checkDerefVar(var_glojure_DOT_core_list)
							tmp77 := lang.Apply(tmp76, []any{sym_glojure_DOT_core_SLASH_let})
							tmp78 := checkDerefVar(var_glojure_DOT_core_list)
							tmp79 := lang.Apply(tmp78, []any{v73})
							tmp80 := checkDerefVar(var_glojure_DOT_core_list)
							tmp81 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp82 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp83 := checkDerefVar(var_glojure_DOT_core_list)
							tmp84 := lang.Apply(tmp83, []any{sym_loop_STAR_})
							tmp85 := checkDerefVar(var_glojure_DOT_core_list)
							tmp86 := checkDerefVar(var_glojure_DOT_core_vec)
							tmp87 := checkDerefVar(var_glojure_DOT_core_interleave)
							tmp88 := lang.Apply(tmp87, []any{v61, v61})
							tmp89 := lang.Apply(tmp86, []any{tmp88})
							tmp90 := lang.Apply(tmp85, []any{tmp89})
							tmp91 := checkDerefVar(var_glojure_DOT_core_list)
							tmp92 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp93 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp94 := checkDerefVar(var_glojure_DOT_core_list)
							tmp95 := lang.Apply(tmp94, []any{sym_glojure_DOT_core_SLASH_let})
							tmp96 := checkDerefVar(var_glojure_DOT_core_list)
							tmp97 := checkDerefVar(var_glojure_DOT_core_vec)
							tmp98 := checkDerefVar(var_glojure_DOT_core_interleave)
							tmp99 := lang.Apply(tmp98, []any{v55, v61})
							tmp100 := lang.Apply(tmp97, []any{tmp99})
							tmp101 := lang.Apply(tmp96, []any{tmp100})
							tmp102 := lang.Apply(tmp93, []any{tmp95, tmp101, v5})
							tmp103 := lang.Apply(tmp92, []any{tmp102})
							tmp104 := lang.Apply(tmp91, []any{tmp103})
							tmp105 := lang.Apply(tmp82, []any{tmp84, tmp90, tmp104})
							tmp106 := lang.Apply(tmp81, []any{tmp105})
							tmp107 := lang.Apply(tmp80, []any{tmp106})
							tmp108 := lang.Apply(tmp75, []any{tmp77, tmp79, tmp107})
							tmp109 := lang.Apply(tmp74, []any{tmp108})
							tmp47 = tmp109
						} // end let
						tmp36 = tmp47
					}
					tmp32 = tmp36
				} // end let
				return tmp32
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_loop = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_loop.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-map
	{
		tmp0 := sym_print_DASH_map.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(252), kw_column, int(8), kw_end_DASH_line, int(252), kw_end_DASH_column, int(16), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_print_DASH_one, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_print_DASH_prefix_DASH_map)
			tmp6 := lang.Apply(tmp5, []any{nil, v2, v3, v4})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_print_DASH_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	var closed11 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp4 := lang.Apply(tmp3, []any{v1, v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp5 := lang.Apply(tmp4, []any{v1, v2, v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed11 = tmp0
	}
	var closed12 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp4 := lang.Apply(tmp3, []any{v1, v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp5 := lang.Apply(tmp4, []any{v1, v2, v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed12 = tmp0
	}
	var closed14 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
		recur_loop_1275:
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := lang.Apply(tmp5, []any{v1})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "s"
						var v10 any = v7
						_ = v10
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v10})
						if lang.IsTruthy(tmp13) {
							var tmp14 any
							{ // let
								// let binding "ret"
								tmp15 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
								tmp16 := lang.Apply(tmp15, []any{v10})
								tmp17, _ := lang.FieldOrMethod(tmp16, "ReduceInit")
								if reflect.TypeOf(tmp17).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
								}
								tmp18 := lang.Apply(tmp17, []any{v2, v3})
								var v19 any = tmp18
								_ = v19
								var tmp20 any
								tmp21 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
								tmp22 := lang.Apply(tmp21, []any{v19})
								if lang.IsTruthy(tmp22) {
									tmp23 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp24 := lang.Apply(tmp23, []any{v19})
									tmp20 = tmp24
								} else {
									tmp26 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_next)
									tmp27 := lang.Apply(tmp26, []any{v10})
									var tmp25 any = tmp27
									var tmp28 any = v2
									var tmp29 any = v19
									v1 = tmp25
									v2 = tmp28
									v3 = tmp29
									goto recur_loop_1275
								}
								tmp14 = tmp20
							} // end let
							tmp11 = tmp14
						} else {
							tmp15 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_interface_DASH_or_DASH_naive_DASH_reduce)
							tmp16 := lang.Apply(tmp15, []any{v10, v2, v3})
							tmp11 = tmp16
						}
						tmp9 = tmp11
					} // end let
					tmp8 = tmp9
				} else {
					tmp8 = v3
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		closed14 = tmp0
	}
	var closed15 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "cls"
				tmp5 := checkDerefVar(var_glojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v1})
				var v7 any = tmp6
				_ = v7
				// let binding "s"
				var v8 any = v1
				_ = v8
				// let binding "f"
				var v9 any = v2
				_ = v9
				// let binding "val"
				var v10 any = v3
				_ = v10
				for {
					var tmp11 any
					{ // let
						// let binding "temp__0__auto__"
						tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp13 := lang.Apply(tmp12, []any{v8})
						var v14 any = tmp13
						_ = v14
						var tmp15 any
						if lang.IsTruthy(v14) {
							var tmp16 any
							{ // let
								// let binding "s"
								var v17 any = v14
								_ = v17
								var tmp18 any
								tmp19 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
								tmp20 := checkDerefVar(var_glojure_DOT_core_class)
								tmp21 := lang.Apply(tmp20, []any{v17})
								tmp22 := lang.Apply(tmp19, []any{tmp21, v7})
								if lang.IsTruthy(tmp22) {
									var tmp23 any
									{ // let
										// let binding "ret"
										tmp24 := checkDerefVar(var_glojure_DOT_core_first)
										tmp25 := lang.Apply(tmp24, []any{v17})
										tmp26 := lang.Apply(v9, []any{v10, tmp25})
										var v27 any = tmp26
										_ = v27
										var tmp28 any
										tmp29 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
										tmp30 := lang.Apply(tmp29, []any{v27})
										if lang.IsTruthy(tmp30) {
											tmp31 := checkDerefVar(var_glojure_DOT_core_deref)
											tmp32 := lang.Apply(tmp31, []any{v27})
											tmp28 = tmp32
										} else {
											var tmp33 any = v7
											tmp35 := checkDerefVar(var_glojure_DOT_core_next)
											tmp36 := lang.Apply(tmp35, []any{v17})
											var tmp34 any = tmp36
											var tmp37 any = v9
											var tmp38 any = v27
											v7 = tmp33
											v8 = tmp34
											v9 = tmp37
											v10 = tmp38
											continue
										}
										tmp23 = tmp28
									} // end let
									tmp18 = tmp23
								} else {
									tmp24 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_interface_DASH_or_DASH_naive_DASH_reduce)
									tmp25 := lang.Apply(tmp24, []any{v17, v9, v10})
									tmp18 = tmp25
								}
								tmp16 = tmp18
							} // end let
							tmp15 = tmp16
						} else {
							tmp15 = v10
						}
						tmp11 = tmp15
					} // end let
					tmp4 = tmp11
					break
				}
			} // end let
			return tmp4
		})
		closed15 = tmp0
	}
	var closed18 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
			tmp4 := lang.Apply(tmp3, []any{v1, v2})
			return tmp4
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(167), kw_column, int(17), kw_end_DASH_line, int(167), kw_end_DASH_column, int(56))).(lang.FnFunc)
		closed18 = tmp0
	}
	var closed19 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_writer)
			tmp4 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
			tmp5 := lang.Apply(tmp4, []any{v1, v2})
			tmp6 := lang.Apply(tmp3, []any{tmp5, v2})
			return tmp6
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(168), kw_column, int(17), kw_end_DASH_line, int(168), kw_end_DASH_column, int(76))).(lang.FnFunc)
		closed19 = tmp0
	}
	var closed22 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core__EQ_)
			tmp6, ok := lang.FieldOrMethod(v1, "scheme")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "scheme")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			tmp8 := lang.Apply(tmp5, []any{"file", tmp7})
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.Apply(nil, []any{v1})
				tmp4 = tmp9
			} else {
				var tmp10 any
				{ // let
					// let binding "req"
					var tmp11 any
					{ // let
						// let binding "res__0__auto__"
						tmp12, ok := lang.FieldOrMethod(v1, "String")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "String")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						tmp14 := lang.Apply(http17.NewRequest, []any{http17.MethodGet, tmp13, nil})
						var v15 any = tmp14
						_ = v15
						// let binding "vec__295"
						var tmp16 any
						tmp17 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
						tmp18 := lang.Apply(tmp17, []any{v15})
						if lang.IsTruthy(tmp18) {
							tmp19 := checkDerefVar(var_glojure_DOT_core_pop)
							tmp20 := lang.Apply(tmp19, []any{v15})
							tmp21 := checkDerefVar(var_glojure_DOT_core_last)
							tmp22 := lang.Apply(tmp21, []any{v15})
							tmp23 := lang.NewVector(tmp20, tmp22)
							tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 = tmp25
						} else {
							tmp26 := lang.NewVector(nil, v15)
							tmp27 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 = tmp28
						}
						var v29 any = tmp16
						_ = v29
						// let binding "vec__298"
						tmp30 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp31 := lang.Apply(tmp30, []any{v29, int64(0), nil})
						var v32 any = tmp31
						_ = v32
						// let binding "seq__299"
						tmp33 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp34 := lang.Apply(tmp33, []any{v32})
						var v35 any = tmp34
						_ = v35
						// let binding "first__300"
						tmp36 := checkDerefVar(var_glojure_DOT_core_first)
						tmp37 := lang.Apply(tmp36, []any{v35})
						var v38 any = tmp37
						_ = v38
						// let binding "seq__299"
						tmp39 := checkDerefVar(var_glojure_DOT_core_next)
						tmp40 := lang.Apply(tmp39, []any{v35})
						var v41 any = tmp40
						_ = v41
						// let binding "fst__1__auto__"
						var v42 any = v38
						_ = v42
						// let binding "rst__2__auto__"
						var v43 any = v41
						_ = v43
						// let binding "res__0__auto__"
						var v44 any = v32
						_ = v44
						// let binding "err__3__auto__"
						tmp45 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp46 := lang.Apply(tmp45, []any{v29, int64(1), nil})
						var v47 any = tmp46
						_ = v47
						// let binding "res__0__auto__"
						var tmp48 any
						tmp49 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
						tmp50 := lang.Apply(tmp49, []any{v43})
						if lang.IsTruthy(tmp50) {
							tmp48 = v44
						} else {
							tmp48 = v42
						}
						var v51 any = tmp48
						_ = v51
						var tmp52 any
						if lang.IsTruthy(v47) {
							panic(v47)
						} else {
						}
						_ = tmp52
						tmp11 = v51
					} // end let
					var v12 any = tmp11
					_ = v12
					// let binding "res"
					var tmp13 any
					{ // let
						// let binding "res__0__auto__"
						tmp14, _ := lang.FieldOrMethod(http17.DefaultClient, "Do")
						if reflect.TypeOf(tmp14).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("Do is not a function")))
						}
						tmp15 := lang.Apply(tmp14, []any{v12})
						var v16 any = tmp15
						_ = v16
						// let binding "vec__301"
						var tmp17 any
						tmp18 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v16})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(var_glojure_DOT_core_pop)
							tmp21 := lang.Apply(tmp20, []any{v16})
							tmp22 := checkDerefVar(var_glojure_DOT_core_last)
							tmp23 := lang.Apply(tmp22, []any{v16})
							tmp24 := lang.NewVector(tmp21, tmp23)
							tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp26
						} else {
							tmp27 := lang.NewVector(nil, v16)
							tmp28 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp29
						}
						var v30 any = tmp17
						_ = v30
						// let binding "vec__304"
						tmp31 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp32 := lang.Apply(tmp31, []any{v30, int64(0), nil})
						var v33 any = tmp32
						_ = v33
						// let binding "seq__305"
						tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp35 := lang.Apply(tmp34, []any{v33})
						var v36 any = tmp35
						_ = v36
						// let binding "first__306"
						tmp37 := checkDerefVar(var_glojure_DOT_core_first)
						tmp38 := lang.Apply(tmp37, []any{v36})
						var v39 any = tmp38
						_ = v39
						// let binding "seq__305"
						tmp40 := checkDerefVar(var_glojure_DOT_core_next)
						tmp41 := lang.Apply(tmp40, []any{v36})
						var v42 any = tmp41
						_ = v42
						// let binding "fst__1__auto__"
						var v43 any = v39
						_ = v43
						// let binding "rst__2__auto__"
						var v44 any = v42
						_ = v44
						// let binding "res__0__auto__"
						var v45 any = v33
						_ = v45
						// let binding "err__3__auto__"
						tmp46 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp47 := lang.Apply(tmp46, []any{v30, int64(1), nil})
						var v48 any = tmp47
						_ = v48
						// let binding "res__0__auto__"
						var tmp49 any
						tmp50 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
						tmp51 := lang.Apply(tmp50, []any{v44})
						if lang.IsTruthy(tmp51) {
							tmp49 = v45
						} else {
							tmp49 = v43
						}
						var v52 any = tmp49
						_ = v52
						var tmp53 any
						if lang.IsTruthy(v48) {
							panic(v48)
						} else {
						}
						_ = tmp53
						tmp13 = v52
					} // end let
					var v14 any = tmp13
					_ = v14
					// let binding "status"
					tmp15, ok := lang.FieldOrMethod(v14, "StatusCode")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "StatusCode")))
					}
					var tmp16 any
					switch reflect.TypeOf(tmp15).Kind() {
					case reflect.Func:
						tmp16 = lang.Apply(tmp15, nil)
					default:
						tmp16 = tmp15
					}
					var v17 any = tmp16
					_ = v17
					// let binding "body"
					tmp18, ok := lang.FieldOrMethod(v14, "Body")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "Body")))
					}
					var tmp19 any
					switch reflect.TypeOf(tmp18).Kind() {
					case reflect.Func:
						tmp19 = lang.Apply(tmp18, nil)
					default:
						tmp19 = tmp18
					}
					var v20 any = tmp19
					_ = v20
					var tmp21 any
					tmp22 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
					tmp23 := lang.Apply(tmp22, []any{int64(200), v17})
					if lang.IsTruthy(tmp23) {
						tmp24, ok := lang.FieldOrMethod(v20, "Close")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v20, "Close")))
						}
						var tmp25 any
						switch reflect.TypeOf(tmp24).Kind() {
						case reflect.Func:
							tmp25 = lang.Apply(tmp24, nil)
						default:
							tmp25 = tmp24
						}
						_ = tmp25
						tmp26 := lang.Apply(fmt.Errorf, []any{"http error: %s", v17})
						panic(tmp26)
					} else {
					}
					_ = tmp21
					tmp10 = v20
				} // end let
				tmp4 = tmp10
			}
			tmp11 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp11
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(232), kw_column, int(24), kw_end_DASH_line, int(244), kw_end_DASH_column, int(32))).(lang.FnFunc)
		closed22 = tmp0
	}
	var closed23 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "vec__307"
				tmp4 := lang.Apply(url5.ParseRequestURI, []any{v1})
				var v5 any = tmp4
				_ = v5
				// let binding "url"
				tmp6 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				if lang.IsTruthy(v11) {
					tmp13 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
					var tmp14 any
					{ // let
						// let binding "res__0__auto__"
						tmp15 := lang.Apply(os6.Open, []any{v1})
						var v16 any = tmp15
						_ = v16
						// let binding "vec__310"
						var tmp17 any
						tmp18 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v16})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(var_glojure_DOT_core_pop)
							tmp21 := lang.Apply(tmp20, []any{v16})
							tmp22 := checkDerefVar(var_glojure_DOT_core_last)
							tmp23 := lang.Apply(tmp22, []any{v16})
							tmp24 := lang.NewVector(tmp21, tmp23)
							tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp26
						} else {
							tmp27 := lang.NewVector(nil, v16)
							tmp28 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp29
						}
						var v30 any = tmp17
						_ = v30
						// let binding "vec__313"
						tmp31 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp32 := lang.Apply(tmp31, []any{v30, int64(0), nil})
						var v33 any = tmp32
						_ = v33
						// let binding "seq__314"
						tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp35 := lang.Apply(tmp34, []any{v33})
						var v36 any = tmp35
						_ = v36
						// let binding "first__315"
						tmp37 := checkDerefVar(var_glojure_DOT_core_first)
						tmp38 := lang.Apply(tmp37, []any{v36})
						var v39 any = tmp38
						_ = v39
						// let binding "seq__314"
						tmp40 := checkDerefVar(var_glojure_DOT_core_next)
						tmp41 := lang.Apply(tmp40, []any{v36})
						var v42 any = tmp41
						_ = v42
						// let binding "fst__1__auto__"
						var v43 any = v39
						_ = v43
						// let binding "rst__2__auto__"
						var v44 any = v42
						_ = v44
						// let binding "res__0__auto__"
						var v45 any = v33
						_ = v45
						// let binding "err__3__auto__"
						tmp46 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp47 := lang.Apply(tmp46, []any{v30, int64(1), nil})
						var v48 any = tmp47
						_ = v48
						// let binding "res__0__auto__"
						var tmp49 any
						tmp50 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
						tmp51 := lang.Apply(tmp50, []any{v44})
						if lang.IsTruthy(tmp51) {
							tmp49 = v45
						} else {
							tmp49 = v43
						}
						var v52 any = tmp49
						_ = v52
						var tmp53 any
						if lang.IsTruthy(v48) {
							panic(v48)
						} else {
						}
						_ = tmp53
						tmp14 = v52
					} // end let
					tmp15 := lang.Apply(tmp13, []any{tmp14, v2})
					tmp12 = tmp15
				} else {
					tmp16 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
					tmp17 := lang.Apply(tmp16, []any{v8, v2})
					tmp12 = tmp17
				}
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(259), kw_column, int(24), kw_end_DASH_line, int(263), kw_end_DASH_column, int(60))).(lang.FnFunc)
		closed23 = tmp0
	}
	var closed24 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_str)
			tmp4 := checkDerefVar(var_glojure_DOT_core_pr_DASH_str)
			tmp5 := lang.Apply(tmp4, []any{v1})
			tmp6 := lang.Apply(tmp3, []any{"Cannot open <", tmp5, "> as an OutputStream."})
			tmp7 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp6})
			panic(tmp7)
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(172), kw_column, int(24), kw_end_DASH_line, int(174), kw_end_DASH_column, int(92))).(lang.FnFunc)
		closed24 = tmp0
	}
	var closed26 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core__EQ_)
			tmp5, ok := lang.FieldOrMethod(v1, "scheme")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "scheme")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{"file", tmp6})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
				tmp9 := lang.Apply(nil, []any{v1})
				tmp10 := lang.Apply(tmp8, []any{tmp9, v2})
				tmp3 = tmp10
			} else {
				tmp11 := checkDerefVar(var_glojure_DOT_core_str)
				tmp12 := lang.Apply(tmp11, []any{"Can not write to non-file URL <", v1, ">"})
				tmp13 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp12})
				panic(tmp13)
			}
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(245), kw_column, int(25), kw_end_DASH_line, int(248), kw_end_DASH_column, int(149))).(lang.FnFunc)
		closed26 = tmp0
	}
	var closed27 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						if lang.CatchMatches(r, lang.Builtins["any"]) {
							v4 := r
							_ = v4
							tmp5 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
							var tmp6 any
							{ // let
								// let binding "res__0__auto__"
								tmp7 := lang.Apply(os6.Open, []any{v1})
								tmp8 := lang.Apply(tmp7, nil)
								var v9 any = tmp8
								_ = v9
								// let binding "vec__322"
								var tmp10 any
								tmp11 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
								tmp12 := lang.Apply(tmp11, []any{v9})
								if lang.IsTruthy(tmp12) {
									tmp13 := checkDerefVar(var_glojure_DOT_core_pop)
									tmp14 := lang.Apply(tmp13, []any{v9})
									tmp15 := checkDerefVar(var_glojure_DOT_core_last)
									tmp16 := lang.Apply(tmp15, []any{v9})
									tmp17 := lang.NewVector(tmp14, tmp16)
									tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
									tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp10 = tmp19
								} else {
									tmp20 := lang.NewVector(nil, v9)
									tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
									tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp10 = tmp22
								}
								var v23 any = tmp10
								_ = v23
								// let binding "vec__325"
								tmp24 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp25 := lang.Apply(tmp24, []any{v23, int64(0), nil})
								var v26 any = tmp25
								_ = v26
								// let binding "seq__326"
								tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp28 := lang.Apply(tmp27, []any{v26})
								var v29 any = tmp28
								_ = v29
								// let binding "first__327"
								tmp30 := checkDerefVar(var_glojure_DOT_core_first)
								tmp31 := lang.Apply(tmp30, []any{v29})
								var v32 any = tmp31
								_ = v32
								// let binding "seq__326"
								tmp33 := checkDerefVar(var_glojure_DOT_core_next)
								tmp34 := lang.Apply(tmp33, []any{v29})
								var v35 any = tmp34
								_ = v35
								// let binding "fst__1__auto__"
								var v36 any = v32
								_ = v36
								// let binding "rst__2__auto__"
								var v37 any = v35
								_ = v37
								// let binding "res__0__auto__"
								var v38 any = v26
								_ = v38
								// let binding "err__3__auto__"
								tmp39 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp40 := lang.Apply(tmp39, []any{v23, int64(1), nil})
								var v41 any = tmp40
								_ = v41
								// let binding "res__0__auto__"
								var tmp42 any
								tmp43 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
								tmp44 := lang.Apply(tmp43, []any{v37})
								if lang.IsTruthy(tmp44) {
									tmp42 = v38
								} else {
									tmp42 = v36
								}
								var v45 any = tmp42
								_ = v45
								var tmp46 any
								if lang.IsTruthy(v41) {
									panic(v41)
								} else {
								}
								_ = tmp46
								tmp6 = v45
							} // end let
							tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
							tmp3 = tmp7
						} else {
							panic(r)
						}
					}
				}()
				tmp4 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
				var tmp5 any
				{ // let
					// let binding "res__0__auto__"
					tmp6 := lang.Apply(url5.Parse, []any{v1})
					tmp7 := lang.Apply(tmp6, nil)
					var v8 any = tmp7
					_ = v8
					// let binding "vec__316"
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
					tmp11 := lang.Apply(tmp10, []any{v8})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_pop)
						tmp13 := lang.Apply(tmp12, []any{v8})
						tmp14 := checkDerefVar(var_glojure_DOT_core_last)
						tmp15 := lang.Apply(tmp14, []any{v8})
						tmp16 := lang.NewVector(tmp13, tmp15)
						tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
						tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp18
					} else {
						tmp19 := lang.NewVector(nil, v8)
						tmp20 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
						tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp21
					}
					var v22 any = tmp9
					_ = v22
					// let binding "vec__319"
					tmp23 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp24 := lang.Apply(tmp23, []any{v22, int64(0), nil})
					var v25 any = tmp24
					_ = v25
					// let binding "seq__320"
					tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp27 := lang.Apply(tmp26, []any{v25})
					var v28 any = tmp27
					_ = v28
					// let binding "first__321"
					tmp29 := checkDerefVar(var_glojure_DOT_core_first)
					tmp30 := lang.Apply(tmp29, []any{v28})
					var v31 any = tmp30
					_ = v31
					// let binding "seq__320"
					tmp32 := checkDerefVar(var_glojure_DOT_core_next)
					tmp33 := lang.Apply(tmp32, []any{v28})
					var v34 any = tmp33
					_ = v34
					// let binding "fst__1__auto__"
					var v35 any = v31
					_ = v35
					// let binding "rst__2__auto__"
					var v36 any = v34
					_ = v36
					// let binding "res__0__auto__"
					var v37 any = v25
					_ = v37
					// let binding "err__3__auto__"
					tmp38 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp39 := lang.Apply(tmp38, []any{v22, int64(1), nil})
					var v40 any = tmp39
					_ = v40
					// let binding "res__0__auto__"
					var tmp41 any
					tmp42 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
					tmp43 := lang.Apply(tmp42, []any{v36})
					if lang.IsTruthy(tmp43) {
						tmp41 = v37
					} else {
						tmp41 = v35
					}
					var v44 any = tmp41
					_ = v44
					var tmp45 any
					if lang.IsTruthy(v40) {
						panic(v40)
					} else {
					}
					_ = tmp45
					tmp5 = v44
				} // end let
				tmp6 := lang.Apply(tmp4, []any{tmp5, v2})
				tmp3 = tmp6
			}()
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(264), kw_column, int(25), kw_end_DASH_line, int(268), kw_end_DASH_column, int(79))).(lang.FnFunc)
		closed27 = tmp0
	}
	// -protocols
	{
		tmp0 := sym__DASH_protocols.WithMeta(lang.NewMap(kw_private, true, kw_doc, "Private store of protocols. Go's reflection capabilities\n    don't yet support a native interface-based implementation, so\n    protocols are implemented in Glojure as maps from type to protocol\n    method implementations.", kw_file, "glojure/core_deftype.glj", kw_line, int(21), kw_column, int(3), kw_end_DASH_line, int(26), kw_end_DASH_column, int(12), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v5 := args[0]
				_ = v5
				var v6 any = lang.NewList(args[1:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_class)
				tmp8 := lang.Apply(tmp7, []any{v5})
				return tmp8
			}
		})
		// MultiFn coll-reduce
		tmp3 := lang.NewMultiFn("coll-reduce", tmp4, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v6 := args[0]
				_ = v6
				var v7 any = lang.NewList(args[1:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp9 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v6, v7})
				tmp11 := lang.Apply(tmp8, []any{closed9, tmp10})
				return tmp11
			}
		})
		tmp3.AddMethod(nil, tmp5)
		tmp6 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
		var tmp7 lang.FnFunc
		tmp7 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v8 := args[0]
				_ = v8
				var v9 any = lang.NewList(args[1:]...)
				_ = v9
				tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp11 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp12 := lang.Apply(tmp11, []any{v8, v9})
				tmp13 := lang.Apply(tmp10, []any{closed10, tmp12})
				return tmp13
			}
		})
		tmp3.AddMethod(tmp6, tmp7)
		tmp8 := reflect.TypeOf((*lang.LazySeq)(nil))
		var tmp9 lang.FnFunc
		tmp9 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v10 := args[0]
				_ = v10
				var v11 any = lang.NewList(args[1:]...)
				_ = v11
				tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp13 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp14 := lang.Apply(tmp13, []any{v10, v11})
				tmp15 := lang.Apply(tmp12, []any{closed11, tmp14})
				return tmp15
			}
		})
		tmp3.AddMethod(tmp8, tmp9)
		tmp10 := reflect.TypeOf((*lang.Vector)(nil))
		var tmp11 lang.FnFunc
		tmp11 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v12 := args[0]
				_ = v12
				var v13 any = lang.NewList(args[1:]...)
				_ = v13
				tmp14 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp15 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp16 := lang.Apply(tmp15, []any{v12, v13})
				tmp17 := lang.Apply(tmp14, []any{closed12, tmp16})
				return tmp17
			}
		})
		tmp3.AddMethod(tmp10, tmp11)
		tmp2 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_coll_DASH_reduce, tmp3), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_coll_DASH_reduce, lang.NewVector(sym_coll, sym_f), lang.NewVector(sym_coll, sym_f, sym_val)))))
		var tmp14 lang.FnFunc
		tmp14 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v15 := args[0]
				_ = v15
				var v16 any = lang.NewList(args[1:]...)
				_ = v16
				tmp17 := checkDerefVar(var_glojure_DOT_core_class)
				tmp18 := lang.Apply(tmp17, []any{v15})
				return tmp18
			}
		})
		// MultiFn internal-reduce
		tmp13 := lang.NewMultiFn("internal-reduce", tmp14, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp15 lang.FnFunc
		tmp15 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v16 := args[0]
				_ = v16
				var v17 any = lang.NewList(args[1:]...)
				_ = v17
				tmp18 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp19 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp20 := lang.Apply(tmp19, []any{v16, v17})
				tmp21 := lang.Apply(tmp18, []any{closed13, tmp20})
				return tmp21
			}
		})
		tmp13.AddMethod(nil, tmp15)
		tmp16 := reflect.TypeOf((*lang.IChunkedSeq)(nil)).Elem()
		var tmp17 lang.FnFunc
		tmp17 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v18 := args[0]
				_ = v18
				var v19 any = lang.NewList(args[1:]...)
				_ = v19
				tmp20 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp21 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp22 := lang.Apply(tmp21, []any{v18, v19})
				tmp23 := lang.Apply(tmp20, []any{closed14, tmp22})
				return tmp23
			}
		})
		tmp13.AddMethod(tmp16, tmp17)
		tmp18 := reflect.TypeOf((*lang.Object)(nil)).Elem()
		var tmp19 lang.FnFunc
		tmp19 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v20 := args[0]
				_ = v20
				var v21 any = lang.NewList(args[1:]...)
				_ = v21
				tmp22 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp23 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp24 := lang.Apply(tmp23, []any{v20, v21})
				tmp25 := lang.Apply(tmp22, []any{closed15, tmp24})
				return tmp25
			}
		})
		tmp13.AddMethod(tmp18, tmp19)
		tmp12 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_internal_DASH_reduce, tmp13), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_internal_DASH_reduce, lang.NewVector(sym_seq, sym_f, sym_start)))))
		var tmp22 lang.FnFunc
		tmp22 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v23 := args[0]
				_ = v23
				var v24 any = lang.NewList(args[1:]...)
				_ = v24
				tmp25 := checkDerefVar(var_glojure_DOT_core_class)
				tmp26 := lang.Apply(tmp25, []any{v23})
				return tmp26
			}
		})
		// MultiFn kv-reduce
		tmp21 := lang.NewMultiFn("kv-reduce", tmp22, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp20 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_kv_DASH_reduce, tmp21), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_kv_DASH_reduce, lang.NewVector(sym_amap, sym_f, sym_init)))))
		var tmp25 lang.FnFunc
		tmp25 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v26 := args[0]
				_ = v26
				var v27 any = lang.NewList(args[1:]...)
				_ = v27
				tmp28 := checkDerefVar(var_glojure_DOT_core_class)
				tmp29 := lang.Apply(tmp28, []any{v26})
				return tmp29
			}
		})
		// MultiFn datafy
		tmp24 := lang.NewMultiFn("datafy", tmp25, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp26 lang.FnFunc
		tmp26 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v27 := args[0]
				_ = v27
				var v28 any = lang.NewList(args[1:]...)
				_ = v28
				tmp29 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp30 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp31 := lang.Apply(tmp30, []any{v27, v28})
				tmp32 := lang.Apply(tmp29, []any{closed16, tmp31})
				return tmp32
			}
		})
		tmp24.AddMethod(nil, tmp26)
		tmp23 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_datafy, tmp24), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_datafy, lang.NewVector(sym_o), "return a representation of o as data (default identity)"))))
		var tmp29 lang.FnFunc
		tmp29 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v30 := args[0]
				_ = v30
				var v31 any = lang.NewList(args[1:]...)
				_ = v31
				tmp32 := checkDerefVar(var_glojure_DOT_core_class)
				tmp33 := lang.Apply(tmp32, []any{v30})
				return tmp33
			}
		})
		// MultiFn nav
		tmp28 := lang.NewMultiFn("nav", tmp29, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp27 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_nav, tmp28), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_nav, lang.NewVector(sym_coll, sym_k, sym_v), "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v."))))
		var tmp32 lang.FnFunc
		tmp32 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v33 := args[0]
				_ = v33
				var v34 any = lang.NewList(args[1:]...)
				_ = v34
				tmp35 := checkDerefVar(var_glojure_DOT_core_class)
				tmp36 := lang.Apply(tmp35, []any{v33})
				return tmp36
			}
		})
		// MultiFn make-reader
		tmp31 := lang.NewMultiFn("make-reader", tmp32, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp33 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp34 lang.FnFunc
		tmp34 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v35 := args[0]
				_ = v35
				var v36 any = lang.NewList(args[1:]...)
				_ = v36
				tmp37 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp38 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp39 := lang.Apply(tmp38, []any{v35, v36})
				tmp40 := lang.Apply(tmp37, []any{closed17, tmp39})
				return tmp40
			}
		})
		tmp31.AddMethod(tmp33, tmp34)
		tmp35 := reflect.TypeOf((*url5.URL)(nil))
		var tmp36 lang.FnFunc
		tmp36 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v37 := args[0]
				_ = v37
				var v38 any = lang.NewList(args[1:]...)
				_ = v38
				tmp39 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp40 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp41 := lang.Apply(tmp40, []any{v37, v38})
				tmp42 := lang.Apply(tmp39, []any{closed18, tmp41})
				return tmp42
			}
		})
		tmp31.AddMethod(tmp35, tmp36)
		tmp37 := reflect.TypeOf("")
		var tmp38 lang.FnFunc
		tmp38 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v39 := args[0]
				_ = v39
				var v40 any = lang.NewList(args[1:]...)
				_ = v40
				tmp41 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp42 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp43 := lang.Apply(tmp42, []any{v39, v40})
				tmp44 := lang.Apply(tmp41, []any{closed18, tmp43})
				return tmp44
			}
		})
		tmp31.AddMethod(tmp37, tmp38)
		var tmp40 lang.FnFunc
		tmp40 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v41 := args[0]
				_ = v41
				var v42 any = lang.NewList(args[1:]...)
				_ = v42
				tmp43 := checkDerefVar(var_glojure_DOT_core_class)
				tmp44 := lang.Apply(tmp43, []any{v41})
				return tmp44
			}
		})
		// MultiFn make-writer
		tmp39 := lang.NewMultiFn("make-writer", tmp40, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp41 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp42 lang.FnFunc
		tmp42 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v43 := args[0]
				_ = v43
				var v44 any = lang.NewList(args[1:]...)
				_ = v44
				tmp45 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp46 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp47 := lang.Apply(tmp46, []any{v43, v44})
				tmp48 := lang.Apply(tmp45, []any{closed19, tmp47})
				return tmp48
			}
		})
		tmp39.AddMethod(tmp41, tmp42)
		tmp43 := reflect.TypeOf((*url5.URL)(nil))
		var tmp44 lang.FnFunc
		tmp44 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v45 := args[0]
				_ = v45
				var v46 any = lang.NewList(args[1:]...)
				_ = v46
				tmp47 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp48 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp49 := lang.Apply(tmp48, []any{v45, v46})
				tmp50 := lang.Apply(tmp47, []any{closed19, tmp49})
				return tmp50
			}
		})
		tmp39.AddMethod(tmp43, tmp44)
		tmp45 := reflect.TypeOf("")
		var tmp46 lang.FnFunc
		tmp46 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v47 := args[0]
				_ = v47
				var v48 any = lang.NewList(args[1:]...)
				_ = v48
				tmp49 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp50 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp51 := lang.Apply(tmp50, []any{v47, v48})
				tmp52 := lang.Apply(tmp49, []any{closed19, tmp51})
				return tmp52
			}
		})
		tmp39.AddMethod(tmp45, tmp46)
		var tmp48 lang.FnFunc
		tmp48 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v49 := args[0]
				_ = v49
				var v50 any = lang.NewList(args[1:]...)
				_ = v50
				tmp51 := checkDerefVar(var_glojure_DOT_core_class)
				tmp52 := lang.Apply(tmp51, []any{v49})
				return tmp52
			}
		})
		// MultiFn make-input-stream
		tmp47 := lang.NewMultiFn("make-input-stream", tmp48, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp49 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp50 lang.FnFunc
		tmp50 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v51 := args[0]
				_ = v51
				var v52 any = lang.NewList(args[1:]...)
				_ = v52
				tmp53 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp54 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp55 := lang.Apply(tmp54, []any{v51, v52})
				tmp56 := lang.Apply(tmp53, []any{closed20, tmp55})
				return tmp56
			}
		})
		tmp47.AddMethod(tmp49, tmp50)
		tmp51 := reflect.TypeOf((*os6.File)(nil))
		var tmp52 lang.FnFunc
		tmp52 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v53 := args[0]
				_ = v53
				var v54 any = lang.NewList(args[1:]...)
				_ = v54
				tmp55 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp56 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp57 := lang.Apply(tmp56, []any{v53, v54})
				tmp58 := lang.Apply(tmp55, []any{closed21, tmp57})
				return tmp58
			}
		})
		tmp47.AddMethod(tmp51, tmp52)
		tmp53 := reflect.TypeOf((*url5.URL)(nil))
		var tmp54 lang.FnFunc
		tmp54 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v55 := args[0]
				_ = v55
				var v56 any = lang.NewList(args[1:]...)
				_ = v56
				tmp57 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp58 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp59 := lang.Apply(tmp58, []any{v55, v56})
				tmp60 := lang.Apply(tmp57, []any{closed22, tmp59})
				return tmp60
			}
		})
		tmp47.AddMethod(tmp53, tmp54)
		tmp55 := reflect.TypeOf("")
		var tmp56 lang.FnFunc
		tmp56 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v57 := args[0]
				_ = v57
				var v58 any = lang.NewList(args[1:]...)
				_ = v58
				tmp59 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp60 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp61 := lang.Apply(tmp60, []any{v57, v58})
				tmp62 := lang.Apply(tmp59, []any{closed23, tmp61})
				return tmp62
			}
		})
		tmp47.AddMethod(tmp55, tmp56)
		var tmp58 lang.FnFunc
		tmp58 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v59 := args[0]
				_ = v59
				var v60 any = lang.NewList(args[1:]...)
				_ = v60
				tmp61 := checkDerefVar(var_glojure_DOT_core_class)
				tmp62 := lang.Apply(tmp61, []any{v59})
				return tmp62
			}
		})
		// MultiFn make-output-stream
		tmp57 := lang.NewMultiFn("make-output-stream", tmp58, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp59 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp60 lang.FnFunc
		tmp60 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v61 := args[0]
				_ = v61
				var v62 any = lang.NewList(args[1:]...)
				_ = v62
				tmp63 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp64 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp65 := lang.Apply(tmp64, []any{v61, v62})
				tmp66 := lang.Apply(tmp63, []any{closed24, tmp65})
				return tmp66
			}
		})
		tmp57.AddMethod(tmp59, tmp60)
		tmp61 := reflect.TypeOf((*os6.File)(nil))
		var tmp62 lang.FnFunc
		tmp62 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v63 := args[0]
				_ = v63
				var v64 any = lang.NewList(args[1:]...)
				_ = v64
				tmp65 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp66 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp67 := lang.Apply(tmp66, []any{v63, v64})
				tmp68 := lang.Apply(tmp65, []any{closed25, tmp67})
				return tmp68
			}
		})
		tmp57.AddMethod(tmp61, tmp62)
		tmp63 := reflect.TypeOf((*url5.URL)(nil))
		var tmp64 lang.FnFunc
		tmp64 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v65 := args[0]
				_ = v65
				var v66 any = lang.NewList(args[1:]...)
				_ = v66
				tmp67 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp68 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp69 := lang.Apply(tmp68, []any{v65, v66})
				tmp70 := lang.Apply(tmp67, []any{closed26, tmp69})
				return tmp70
			}
		})
		tmp57.AddMethod(tmp63, tmp64)
		tmp65 := reflect.TypeOf("")
		var tmp66 lang.FnFunc
		tmp66 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v67 := args[0]
				_ = v67
				var v68 any = lang.NewList(args[1:]...)
				_ = v68
				tmp69 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp70 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp71 := lang.Apply(tmp70, []any{v67, v68})
				tmp72 := lang.Apply(tmp69, []any{closed27, tmp71})
				return tmp72
			}
		})
		tmp57.AddMethod(tmp65, tmp66)
		tmp30 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_make_DASH_reader, tmp31, kw_make_DASH_writer, tmp39, kw_make_DASH_input_DASH_stream, tmp47, kw_make_DASH_output_DASH_stream, tmp57), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_make_DASH_reader, lang.NewVector(sym_x, sym_opts), "Creates an io.Reader. See also IOFactory docs."), lang.NewList(sym_make_DASH_writer, lang.NewVector(sym_x, sym_opts), "Creates an io.Reader. See also IOFactory docs."), lang.NewList(sym_make_DASH_input_DASH_stream, lang.NewVector(sym_x, sym_opts), "Creates a BufferedInputStream. See also IOFactory docs."), lang.NewList(sym_make_DASH_output_DASH_stream, lang.NewVector(sym_x, sym_opts), "Creates a BufferedOutputStream. See also IOFactory docs."))))
		tmp1 := lang.NewAtom(lang.NewMap(sym_CollReduce, tmp2, sym_InternalReduce, tmp12, sym_IKVReduce, tmp20, sym_Datafiable, tmp23, sym_Navigable, tmp27, sym_IOFactory, tmp30))
		var_glojure_DOT_core__DASH_protocols = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core__DASH_protocols.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-classpath
	{
		tmp0 := sym_add_DASH_classpath.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_url)), kw_doc, "DEPRECATED \n\n  Adds the url (String or URL object) to the classpath per\n  URLClassLoader.addURL", kw_file, "glojure/core.glj", kw_deprecated, "1.1", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(5176), kw_end_DASH_line, int(5176))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_println)
			tmp4 := lang.Apply(tmp3, []any{"WARNING: add-classpath is deprecated"})
			_ = tmp4
			tmp5 := lang.Apply(nil, []any{v2})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_add_DASH_classpath = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_add_DASH_classpath.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// case
	{
		tmp0 := sym_case.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_e, sym__AMP_, sym_clauses)), kw_doc, "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(6712), kw_end_DASH_line, int(6712))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "ge"
					tmp7 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp8 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, nil)
					tmp10 := reflect.TypeOf((*lang.Object)(nil)).Elem()
					tmp11 := lang.NewMap(kw_tag, tmp10)
					tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6738), kw_column, int(32), kw_end_DASH_line, int(6738), kw_end_DASH_column, int(84))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp14 := lang.Apply(tmp7, []any{tmp9, tmp13})
					var v15 any = tmp14
					_ = v15
					// let binding "default"
					var tmp16 any
					tmp17 := checkDerefVar(var_glojure_DOT_core_odd_QMARK_)
					tmp18 := checkDerefVar(var_glojure_DOT_core_count)
					tmp19 := lang.Apply(tmp18, []any{v5})
					tmp20 := lang.Apply(tmp17, []any{tmp19})
					if lang.IsTruthy(tmp20) {
						tmp21 := checkDerefVar(var_glojure_DOT_core_last)
						tmp22 := lang.Apply(tmp21, []any{v5})
						tmp16 = tmp22
					} else {
						tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp25 := checkDerefVar(var_glojure_DOT_core_list)
						tmp26 := lang.Apply(tmp25, []any{sym_throw})
						tmp27 := checkDerefVar(var_glojure_DOT_core_list)
						tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp29 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp30 := checkDerefVar(var_glojure_DOT_core_list)
						tmp31 := lang.Apply(tmp30, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewIllegalArgumentError})
						tmp32 := checkDerefVar(var_glojure_DOT_core_list)
						tmp33 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp34 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp35 := checkDerefVar(var_glojure_DOT_core_list)
						tmp36 := lang.Apply(tmp35, []any{sym_glojure_DOT_core_SLASH_str})
						tmp37 := checkDerefVar(var_glojure_DOT_core_list)
						tmp38 := lang.Apply(tmp37, []any{"No matching clause: "})
						tmp39 := checkDerefVar(var_glojure_DOT_core_list)
						tmp40 := lang.Apply(tmp39, []any{v15})
						tmp41 := lang.Apply(tmp34, []any{tmp36, tmp38, tmp40})
						tmp42 := lang.Apply(tmp33, []any{tmp41})
						tmp43 := lang.Apply(tmp32, []any{tmp42})
						tmp44 := lang.Apply(tmp29, []any{tmp31, tmp43})
						tmp45 := lang.Apply(tmp28, []any{tmp44})
						tmp46 := lang.Apply(tmp27, []any{tmp45})
						tmp47 := lang.Apply(tmp24, []any{tmp26, tmp46})
						tmp48 := lang.Apply(tmp23, []any{tmp47})
						tmp16 = tmp48
					}
					var v49 any = tmp16
					_ = v49
					var tmp50 any
					tmp51 := checkDerefVar(var_glojure_DOT_core__GT_)
					tmp52 := checkDerefVar(var_glojure_DOT_core_count)
					tmp53 := lang.Apply(tmp52, []any{v5})
					tmp54 := lang.Apply(tmp51, []any{int64(2), tmp53})
					if lang.IsTruthy(tmp54) {
						tmp55 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp56 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp57 := checkDerefVar(var_glojure_DOT_core_list)
						tmp58 := lang.Apply(tmp57, []any{sym_glojure_DOT_core_SLASH_let})
						tmp59 := checkDerefVar(var_glojure_DOT_core_list)
						tmp60 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp61 := checkDerefVar(var_glojure_DOT_core_vector)
						tmp62 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp63 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp64 := checkDerefVar(var_glojure_DOT_core_list)
						tmp65 := lang.Apply(tmp64, []any{v15})
						tmp66 := checkDerefVar(var_glojure_DOT_core_list)
						tmp67 := lang.Apply(tmp66, []any{v4})
						tmp68 := lang.Apply(tmp63, []any{tmp65, tmp67})
						tmp69 := lang.Apply(tmp62, []any{tmp68})
						tmp70 := lang.Apply(tmp60, []any{tmp61, tmp69})
						tmp71 := lang.Apply(tmp59, []any{tmp70})
						tmp72 := checkDerefVar(var_glojure_DOT_core_list)
						tmp73 := lang.Apply(tmp72, []any{v49})
						tmp74 := lang.Apply(tmp56, []any{tmp58, tmp71, tmp73})
						tmp75 := lang.Apply(tmp55, []any{tmp74})
						tmp50 = tmp75
					} else {
						var tmp76 any
						{ // let
							// let binding "pairs"
							tmp77 := checkDerefVar(var_glojure_DOT_core_partition)
							tmp78 := lang.Apply(tmp77, []any{int64(2), v5})
							var v79 any = tmp78
							_ = v79
							// let binding "assoc-test"
							var tmp80 lang.FnFunc
							{ // function assoc-test
								var v81 lang.FnFunc
								tmp80 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 3)
									v82 := args[0]
									_ = v82
									v83 := args[1]
									_ = v83
									v84 := args[2]
									_ = v84
									var tmp85 any
									tmp86 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
									tmp87 := lang.Apply(tmp86, []any{v82, v83})
									if lang.IsTruthy(tmp87) {
										tmp88 := checkDerefVar(var_glojure_DOT_core_str)
										tmp89 := lang.Apply(tmp88, []any{"Duplicate case test constant: ", v83})
										tmp90 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp89})
										panic(tmp90)
									} else {
										tmp91 := checkDerefVar(var_glojure_DOT_core_assoc)
										tmp92 := lang.Apply(tmp91, []any{v82, v83, v84})
										tmp85 = tmp92
									}
									return tmp85
								})
								v81 = tmp80
								_ = v81
							}
							tmp81 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6745), kw_column, int(24), kw_end_DASH_line, int(6748), kw_end_DASH_column, int(48))
							tmp82, err := lang.WithMeta(tmp80, tmp81.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v83 any = tmp82
							_ = v83
							// let binding "pairs"
							tmp84 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp85 lang.FnFunc
							tmp85 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v86 := args[0]
								_ = v86
								v87 := args[1]
								_ = v87
								var tmp88 any
								{ // let
									// let binding "vec__177"
									var v89 any = v87
									_ = v89
									// let binding "test"
									tmp90 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp91 := lang.Apply(tmp90, []any{v89, int64(0), nil})
									var v92 any = tmp91
									_ = v92
									// let binding "expr"
									tmp93 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp94 := lang.Apply(tmp93, []any{v89, int64(1), nil})
									var v95 any = tmp94
									_ = v95
									var tmp96 any
									tmp97 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
									tmp98 := lang.Apply(tmp97, []any{v92})
									if lang.IsTruthy(tmp98) {
										tmp99 := checkDerefVar(var_glojure_DOT_core_reduce1)
										var tmp100 lang.FnFunc
										tmp100 = lang.NewFnFunc(func(args ...any) any {
											checkArity(args, 2)
											v101 := args[0]
											_ = v101
											v102 := args[1]
											_ = v102
											tmp103 := lang.Apply(v83, []any{v101, v102, v95})
											return tmp103
										})
										tmp101 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6752), kw_column, int(37), kw_end_DASH_line, int(6752), kw_end_DASH_column, int(60))
										tmp102, err := lang.WithMeta(tmp100, tmp101.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp103 := lang.Apply(tmp99, []any{tmp102, v86, v92})
										tmp96 = tmp103
									} else {
										tmp104 := lang.Apply(v83, []any{v86, v92, v95})
										tmp96 = tmp104
									}
									tmp88 = tmp96
								} // end let
								return tmp88
							})
							tmp86 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6750), kw_column, int(24), kw_end_DASH_line, int(6753), kw_end_DASH_column, int(53))
							tmp87, err := lang.WithMeta(tmp85, tmp86.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp88 := lang.NewMap()
							tmp89 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6754), kw_column, int(24), kw_end_DASH_line, int(6754), kw_end_DASH_column, int(25))
							tmp90, err := lang.WithMeta(tmp88, tmp89.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp91 := lang.Apply(tmp84, []any{tmp87, tmp90, v79})
							var v92 any = tmp91
							_ = v92
							// let binding "tests"
							tmp93 := checkDerefVar(var_glojure_DOT_core_keys)
							tmp94 := lang.Apply(tmp93, []any{v92})
							var v95 any = tmp94
							_ = v95
							// let binding "thens"
							tmp96 := checkDerefVar(var_glojure_DOT_core_vals)
							tmp97 := lang.Apply(tmp96, []any{v92})
							var v98 any = tmp97
							_ = v98
							// let binding "mode"
							var tmp99 any
							tmp100 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
							var tmp101 lang.FnFunc
							tmp101 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v102 := args[0]
								_ = v102
								var tmp103 any
								{ // let
									// let binding "and__0__auto__"
									tmp104 := checkDerefVar(var_glojure_DOT_core_integer_QMARK_)
									tmp105 := lang.Apply(tmp104, []any{v102})
									var v106 any = tmp105
									_ = v106
									var tmp107 any
									if lang.IsTruthy(v106) {
										tmp108 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
										tmp109 := lang.Apply(tmp108, []any{math7.MinInt, v102, math7.MaxInt})
										tmp107 = tmp109
									} else {
										tmp107 = v106
									}
									tmp103 = tmp107
								} // end let
								return tmp103
							})
							tmp102 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6758), kw_column, int(28), kw_end_DASH_line, int(6758), kw_end_DASH_column, int(77))
							tmp103, err := lang.WithMeta(tmp101, tmp102.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp104 := lang.Apply(tmp100, []any{tmp103, v95})
							if lang.IsTruthy(tmp104) {
								tmp99 = kw_ints
							} else {
								var tmp105 any
								tmp106 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
								tmp107 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
								tmp108 := lang.Apply(tmp106, []any{tmp107, v95})
								if lang.IsTruthy(tmp108) {
									tmp105 = kw_identity
								} else {
									var tmp109 any
									if lang.IsTruthy(kw_else) {
										tmp109 = kw_hashes
									} else {
									}
									tmp105 = tmp109
								}
								tmp99 = tmp105
							}
							var v110 any = tmp99
							_ = v110
							var tmp111 any
							{ // let
								// let binding "pred__180"
								tmp112 := checkDerefVar(var_glojure_DOT_core__EQ_)
								var v113 any = tmp112
								_ = v113
								// let binding "expr__181"
								var v114 any = v110
								_ = v114
								var tmp115 any
								tmp116 := lang.Apply(v113, []any{kw_ints, v114})
								if lang.IsTruthy(tmp116) {
									var tmp117 any
									{ // let
										// let binding "vec__182"
										tmp118 := checkDerefVar(var_glojure_DOT_core_prep_DASH_ints)
										tmp119 := lang.Apply(tmp118, []any{v95, v98})
										var v120 any = tmp119
										_ = v120
										// let binding "shift"
										tmp121 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp122 := lang.Apply(tmp121, []any{v120, int64(0), nil})
										var v123 any = tmp122
										_ = v123
										// let binding "mask"
										tmp124 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp125 := lang.Apply(tmp124, []any{v120, int64(1), nil})
										var v126 any = tmp125
										_ = v126
										// let binding "imap"
										tmp127 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp128 := lang.Apply(tmp127, []any{v120, int64(2), nil})
										var v129 any = tmp128
										_ = v129
										// let binding "switch-type"
										tmp130 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp131 := lang.Apply(tmp130, []any{v120, int64(3), nil})
										var v132 any = tmp131
										_ = v132
										tmp133 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp134 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp135 := checkDerefVar(var_glojure_DOT_core_list)
										tmp136 := lang.Apply(tmp135, []any{sym_glojure_DOT_core_SLASH_let})
										tmp137 := checkDerefVar(var_glojure_DOT_core_list)
										tmp138 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp139 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp140 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp141 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp142 := checkDerefVar(var_glojure_DOT_core_list)
										tmp143 := lang.Apply(tmp142, []any{v15})
										tmp144 := checkDerefVar(var_glojure_DOT_core_list)
										tmp145 := lang.Apply(tmp144, []any{v4})
										tmp146 := lang.Apply(tmp141, []any{tmp143, tmp145})
										tmp147 := lang.Apply(tmp140, []any{tmp146})
										tmp148 := lang.Apply(tmp138, []any{tmp139, tmp147})
										tmp149 := lang.Apply(tmp137, []any{tmp148})
										tmp150 := checkDerefVar(var_glojure_DOT_core_list)
										tmp151 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp152 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp153 := checkDerefVar(var_glojure_DOT_core_list)
										tmp154 := lang.Apply(tmp153, []any{sym_case_STAR_})
										tmp155 := checkDerefVar(var_glojure_DOT_core_list)
										tmp156 := lang.Apply(tmp155, []any{v15})
										tmp157 := checkDerefVar(var_glojure_DOT_core_list)
										tmp158 := lang.Apply(tmp157, []any{v123})
										tmp159 := checkDerefVar(var_glojure_DOT_core_list)
										tmp160 := lang.Apply(tmp159, []any{v126})
										tmp161 := checkDerefVar(var_glojure_DOT_core_list)
										tmp162 := lang.Apply(tmp161, []any{v49})
										tmp163 := checkDerefVar(var_glojure_DOT_core_list)
										tmp164 := lang.Apply(tmp163, []any{v129})
										tmp165 := checkDerefVar(var_glojure_DOT_core_list)
										tmp166 := lang.Apply(tmp165, []any{v132})
										tmp167 := checkDerefVar(var_glojure_DOT_core_list)
										tmp168 := lang.Apply(tmp167, []any{kw_int})
										tmp169 := lang.Apply(tmp152, []any{tmp154, tmp156, tmp158, tmp160, tmp162, tmp164, tmp166, tmp168})
										tmp170 := lang.Apply(tmp151, []any{tmp169})
										tmp171 := lang.Apply(tmp150, []any{tmp170})
										tmp172 := lang.Apply(tmp134, []any{tmp136, tmp149, tmp171})
										tmp173 := lang.Apply(tmp133, []any{tmp172})
										tmp117 = tmp173
									} // end let
									tmp115 = tmp117
								} else {
									var tmp118 any
									tmp119 := lang.Apply(v113, []any{kw_hashes, v114})
									if lang.IsTruthy(tmp119) {
										var tmp120 any
										{ // let
											// let binding "vec__185"
											tmp121 := checkDerefVar(var_glojure_DOT_core_prep_DASH_hashes)
											tmp122 := lang.Apply(tmp121, []any{v15, v49, v95, v98})
											var v123 any = tmp122
											_ = v123
											// let binding "shift"
											tmp124 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp125 := lang.Apply(tmp124, []any{v123, int64(0), nil})
											var v126 any = tmp125
											_ = v126
											// let binding "mask"
											tmp127 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp128 := lang.Apply(tmp127, []any{v123, int64(1), nil})
											var v129 any = tmp128
											_ = v129
											// let binding "imap"
											tmp130 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp131 := lang.Apply(tmp130, []any{v123, int64(2), nil})
											var v132 any = tmp131
											_ = v132
											// let binding "switch-type"
											tmp133 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp134 := lang.Apply(tmp133, []any{v123, int64(3), nil})
											var v135 any = tmp134
											_ = v135
											// let binding "skip-check"
											tmp136 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp137 := lang.Apply(tmp136, []any{v123, int64(4), nil})
											var v138 any = tmp137
											_ = v138
											tmp139 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp140 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp141 := checkDerefVar(var_glojure_DOT_core_list)
											tmp142 := lang.Apply(tmp141, []any{sym_glojure_DOT_core_SLASH_let})
											tmp143 := checkDerefVar(var_glojure_DOT_core_list)
											tmp144 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp145 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp146 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp147 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp148 := checkDerefVar(var_glojure_DOT_core_list)
											tmp149 := lang.Apply(tmp148, []any{v15})
											tmp150 := checkDerefVar(var_glojure_DOT_core_list)
											tmp151 := lang.Apply(tmp150, []any{v4})
											tmp152 := lang.Apply(tmp147, []any{tmp149, tmp151})
											tmp153 := lang.Apply(tmp146, []any{tmp152})
											tmp154 := lang.Apply(tmp144, []any{tmp145, tmp153})
											tmp155 := lang.Apply(tmp143, []any{tmp154})
											tmp156 := checkDerefVar(var_glojure_DOT_core_list)
											tmp157 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp158 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp159 := checkDerefVar(var_glojure_DOT_core_list)
											tmp160 := lang.Apply(tmp159, []any{sym_case_STAR_})
											tmp161 := checkDerefVar(var_glojure_DOT_core_list)
											tmp162 := lang.Apply(tmp161, []any{v15})
											tmp163 := checkDerefVar(var_glojure_DOT_core_list)
											tmp164 := lang.Apply(tmp163, []any{v126})
											tmp165 := checkDerefVar(var_glojure_DOT_core_list)
											tmp166 := lang.Apply(tmp165, []any{v129})
											tmp167 := checkDerefVar(var_glojure_DOT_core_list)
											tmp168 := lang.Apply(tmp167, []any{v49})
											tmp169 := checkDerefVar(var_glojure_DOT_core_list)
											tmp170 := lang.Apply(tmp169, []any{v132})
											tmp171 := checkDerefVar(var_glojure_DOT_core_list)
											tmp172 := lang.Apply(tmp171, []any{v135})
											tmp173 := checkDerefVar(var_glojure_DOT_core_list)
											tmp174 := lang.Apply(tmp173, []any{kw_hash_DASH_equiv})
											tmp175 := checkDerefVar(var_glojure_DOT_core_list)
											tmp176 := lang.Apply(tmp175, []any{v138})
											tmp177 := lang.Apply(tmp158, []any{tmp160, tmp162, tmp164, tmp166, tmp168, tmp170, tmp172, tmp174, tmp176})
											tmp178 := lang.Apply(tmp157, []any{tmp177})
											tmp179 := lang.Apply(tmp156, []any{tmp178})
											tmp180 := lang.Apply(tmp140, []any{tmp142, tmp155, tmp179})
											tmp181 := lang.Apply(tmp139, []any{tmp180})
											tmp120 = tmp181
										} // end let
										tmp118 = tmp120
									} else {
										var tmp121 any
										tmp122 := lang.Apply(v113, []any{kw_identity, v114})
										if lang.IsTruthy(tmp122) {
											var tmp123 any
											{ // let
												// let binding "vec__188"
												tmp124 := checkDerefVar(var_glojure_DOT_core_prep_DASH_hashes)
												tmp125 := lang.Apply(tmp124, []any{v15, v49, v95, v98})
												var v126 any = tmp125
												_ = v126
												// let binding "shift"
												tmp127 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp128 := lang.Apply(tmp127, []any{v126, int64(0), nil})
												var v129 any = tmp128
												_ = v129
												// let binding "mask"
												tmp130 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp131 := lang.Apply(tmp130, []any{v126, int64(1), nil})
												var v132 any = tmp131
												_ = v132
												// let binding "imap"
												tmp133 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp134 := lang.Apply(tmp133, []any{v126, int64(2), nil})
												var v135 any = tmp134
												_ = v135
												// let binding "switch-type"
												tmp136 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp137 := lang.Apply(tmp136, []any{v126, int64(3), nil})
												var v138 any = tmp137
												_ = v138
												// let binding "skip-check"
												tmp139 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp140 := lang.Apply(tmp139, []any{v126, int64(4), nil})
												var v141 any = tmp140
												_ = v141
												tmp142 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp143 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp144 := checkDerefVar(var_glojure_DOT_core_list)
												tmp145 := lang.Apply(tmp144, []any{sym_glojure_DOT_core_SLASH_let})
												tmp146 := checkDerefVar(var_glojure_DOT_core_list)
												tmp147 := checkDerefVar(var_glojure_DOT_core_apply)
												tmp148 := checkDerefVar(var_glojure_DOT_core_vector)
												tmp149 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp150 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp151 := checkDerefVar(var_glojure_DOT_core_list)
												tmp152 := lang.Apply(tmp151, []any{v15})
												tmp153 := checkDerefVar(var_glojure_DOT_core_list)
												tmp154 := lang.Apply(tmp153, []any{v4})
												tmp155 := lang.Apply(tmp150, []any{tmp152, tmp154})
												tmp156 := lang.Apply(tmp149, []any{tmp155})
												tmp157 := lang.Apply(tmp147, []any{tmp148, tmp156})
												tmp158 := lang.Apply(tmp146, []any{tmp157})
												tmp159 := checkDerefVar(var_glojure_DOT_core_list)
												tmp160 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp161 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp162 := checkDerefVar(var_glojure_DOT_core_list)
												tmp163 := lang.Apply(tmp162, []any{sym_case_STAR_})
												tmp164 := checkDerefVar(var_glojure_DOT_core_list)
												tmp165 := lang.Apply(tmp164, []any{v15})
												tmp166 := checkDerefVar(var_glojure_DOT_core_list)
												tmp167 := lang.Apply(tmp166, []any{v129})
												tmp168 := checkDerefVar(var_glojure_DOT_core_list)
												tmp169 := lang.Apply(tmp168, []any{v132})
												tmp170 := checkDerefVar(var_glojure_DOT_core_list)
												tmp171 := lang.Apply(tmp170, []any{v49})
												tmp172 := checkDerefVar(var_glojure_DOT_core_list)
												tmp173 := lang.Apply(tmp172, []any{v135})
												tmp174 := checkDerefVar(var_glojure_DOT_core_list)
												tmp175 := lang.Apply(tmp174, []any{v138})
												tmp176 := checkDerefVar(var_glojure_DOT_core_list)
												tmp177 := lang.Apply(tmp176, []any{kw_hash_DASH_identity})
												tmp178 := checkDerefVar(var_glojure_DOT_core_list)
												tmp179 := lang.Apply(tmp178, []any{v141})
												tmp180 := lang.Apply(tmp161, []any{tmp163, tmp165, tmp167, tmp169, tmp171, tmp173, tmp175, tmp177, tmp179})
												tmp181 := lang.Apply(tmp160, []any{tmp180})
												tmp182 := lang.Apply(tmp159, []any{tmp181})
												tmp183 := lang.Apply(tmp143, []any{tmp145, tmp158, tmp182})
												tmp184 := lang.Apply(tmp142, []any{tmp183})
												tmp123 = tmp184
											} // end let
											tmp121 = tmp123
										} else {
											tmp124 := checkDerefVar(var_glojure_DOT_core_str)
											tmp125 := lang.Apply(tmp124, []any{"No matching clause: ", v114})
											tmp126 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp125})
											panic(tmp126)
										}
										tmp118 = tmp121
									}
									tmp115 = tmp118
								}
								tmp111 = tmp115
							} // end let
							tmp76 = tmp111
						} // end let
						tmp50 = tmp76
					}
					tmp6 = tmp50
				} // end let
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_case = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_case.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cat
	{
		tmp0 := sym_cat.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_rf)), kw_doc, "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(7645), kw_end_DASH_line, int(7645))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "rrf"
				tmp4 := checkDerefVar(var_glojure_DOT_core_preserving_DASH_reduced)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp8 := lang.Apply(v2, nil)
						return tmp8
					case 1:
						v8 := args[0]
						_ = v8
						tmp9 := lang.Apply(v2, []any{v8})
						return tmp9
					case 2:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_reduce)
						tmp11 := lang.Apply(tmp10, []any{v6, v8, v9})
						return tmp11
					default:
						checkArity(args, -1)
						panic("unreachable")
					}
				})
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7651), kw_column, int(5), kw_end_DASH_line, int(7655), kw_end_DASH_column, int(36))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp3 = tmp9
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_cat = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_cat.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mapcat
	{
		tmp0 := sym_mapcat.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym__AMP_, sym_colls)), kw_doc, "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2775), kw_end_DASH_line, int(2775))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_comp)
				tmp4 := checkDerefVar(var_glojure_DOT_core_map)
				tmp5 := lang.Apply(tmp4, []any{v2})
				tmp6 := checkDerefVar(var_glojure_DOT_core_cat)
				tmp7 := lang.Apply(tmp3, []any{tmp5, tmp6})
				return tmp7
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_map)
				tmp8 := lang.Apply(tmp6, []any{tmp7, v2, v3})
				tmp9 := lang.Apply(tmp4, []any{tmp5, tmp8})
				return tmp9
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_mapcat = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_mapcat.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge-hash-collisions
	{
		tmp0 := sym_merge_DASH_hash_DASH_collisions.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_expr_DASH_sym, sym_default, sym_tests, sym_thens)), kw_doc, "Takes a case expression, default expression, and a sequence of test constants\n  and a corresponding sequence of then expressions. Returns a tuple of\n  [tests thens skip-check-set] where no tests have the same hash. Each set of\n  input test constants with the same hash is replaced with a single test\n  constant (the case int), and their respective thens are combined into:\n  (condp = expr\n    test-1 then-1\n    ...\n    test-n then-n\n    default).\n  The skip-check is a set of case ints for which post-switch equivalence\n  checking must not be done (the cases holding the above condp thens).", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(28), kw_column, int(8), kw_line, int(6647), kw_end_DASH_line, int(6647), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "buckets"
				var tmp7 any
				{ // let
					// let binding "m"
					tmp8 := lang.NewMap()
					tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6661), kw_column, int(26), kw_end_DASH_line, int(6661), kw_end_DASH_column, int(27))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v11 any = tmp10
					_ = v11
					// let binding "ks"
					var v12 any = v4
					_ = v12
					// let binding "vs"
					var v13 any = v5
					_ = v13
					for {
						var tmp14 any
						var tmp15 any
						{ // let
							// let binding "and__0__auto__"
							var v16 any = v12
							_ = v16
							var tmp17 any
							if lang.IsTruthy(v16) {
								tmp17 = v13
							} else {
								tmp17 = v16
							}
							tmp15 = tmp17
						} // end let
						if lang.IsTruthy(tmp15) {
							tmp17 := checkDerefVar(var_glojure_DOT_core_update)
							tmp18 := checkDerefVar(var_glojure_DOT_core_first)
							tmp19 := lang.Apply(tmp18, []any{v12})
							tmp20 := lang.Apply(lang.Hash, []any{tmp19})
							tmp21 := checkDerefVar(var_glojure_DOT_core_fnil)
							tmp22 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp23 := lang.NewVector()
							tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6664), kw_column, int(102), kw_end_DASH_line, int(6664), kw_end_DASH_column, int(103))
							tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp26 := lang.Apply(tmp21, []any{tmp22, tmp25})
							tmp27 := checkDerefVar(var_glojure_DOT_core_first)
							tmp28 := lang.Apply(tmp27, []any{v12})
							tmp29 := checkDerefVar(var_glojure_DOT_core_first)
							tmp30 := lang.Apply(tmp29, []any{v13})
							tmp31 := lang.NewVector(tmp28, tmp30)
							tmp32 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6664), kw_column, int(106), kw_end_DASH_line, int(6664), kw_end_DASH_column, int(128))
							tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp34 := lang.Apply(tmp17, []any{v11, tmp20, tmp26, tmp33})
							var tmp16 any = tmp34
							tmp36 := checkDerefVar(var_glojure_DOT_core_next)
							tmp37 := lang.Apply(tmp36, []any{v12})
							var tmp35 any = tmp37
							tmp39 := checkDerefVar(var_glojure_DOT_core_next)
							tmp40 := lang.Apply(tmp39, []any{v13})
							var tmp38 any = tmp40
							v11 = tmp16
							v12 = tmp35
							v13 = tmp38
							continue
						} else {
							tmp14 = v11
						}
						tmp7 = tmp14
						break
					}
				} // end let
				var v8 any = tmp7
				_ = v8
				// let binding "assoc-multi"
				var tmp9 lang.FnFunc
				tmp9 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 3)
					v10 := args[0]
					_ = v10
					v11 := args[1]
					_ = v11
					v12 := args[2]
					_ = v12
					var tmp13 any
					{ // let
						// let binding "testexprs"
						tmp14 := checkDerefVar(var_glojure_DOT_core_mapcat)
						var tmp15 lang.FnFunc
						tmp15 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v16 := args[0]
							_ = v16
							tmp17 := checkDerefVar(var_glojure_DOT_core_list)
							tmp18 := checkDerefVar(var_glojure_DOT_core_first)
							tmp19 := lang.Apply(tmp18, []any{v16})
							tmp20 := lang.Apply(tmp17, []any{sym_quote, tmp19})
							tmp21 := checkDerefVar(var_glojure_DOT_core_second)
							tmp22 := lang.Apply(tmp21, []any{v16})
							tmp23 := lang.NewVector(tmp20, tmp22)
							tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6668), kw_column, int(56), kw_end_DASH_line, int(6668), kw_end_DASH_column, int(93))
							tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							return tmp25
						})
						tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6668), kw_column, int(47), kw_end_DASH_line, int(6668), kw_end_DASH_column, int(94))
						tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp18 := lang.Apply(tmp14, []any{tmp17, v12})
						var v19 any = tmp18
						_ = v19
						// let binding "expr"
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{sym_glojure_DOT_core_SLASH_condp})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{sym_glojure_DOT_core_SLASH__EQ_})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v2})
						tmp28 := checkDerefVar(var_glojure_DOT_core_list)
						tmp29 := lang.Apply(tmp28, []any{v3})
						tmp30 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27, v19, tmp29})
						tmp31 := lang.Apply(tmp20, []any{tmp30})
						var v32 any = tmp31
						_ = v32
						tmp33 := checkDerefVar(var_glojure_DOT_core_assoc)
						tmp34 := lang.Apply(tmp33, []any{v10, v11, v32})
						tmp13 = tmp34
					} // end let
					return tmp13
				})
				tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6667), kw_column, int(21), kw_end_DASH_line, int(6670), kw_end_DASH_column, int(42))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v12 any = tmp11
				_ = v12
				// let binding "hmap"
				tmp13 := checkDerefVar(var_glojure_DOT_core_reduce1)
				var tmp14 lang.FnFunc
				tmp14 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v15 := args[0]
					_ = v15
					v16 := args[1]
					_ = v16
					var tmp17 any
					{ // let
						// let binding "vec__164"
						var v18 any = v16
						_ = v18
						// let binding "h"
						tmp19 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp20 := lang.Apply(tmp19, []any{v18, int64(0), nil})
						var v21 any = tmp20
						_ = v21
						// let binding "bucket"
						tmp22 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp23 := lang.Apply(tmp22, []any{v18, int64(1), nil})
						var v24 any = tmp23
						_ = v24
						var tmp25 any
						tmp26 := checkDerefVar(var_glojure_DOT_core__EQ__EQ_)
						tmp27 := checkDerefVar(var_glojure_DOT_core_count)
						tmp28 := lang.Apply(tmp27, []any{v24})
						tmp29 := lang.Apply(tmp26, []any{int64(1), tmp28})
						if lang.IsTruthy(tmp29) {
							tmp30 := checkDerefVar(var_glojure_DOT_core_assoc)
							tmp31 := checkDerefVar(var_glojure_DOT_core_ffirst)
							tmp32 := lang.Apply(tmp31, []any{v24})
							tmp33 := checkDerefVar(var_glojure_DOT_core_second)
							tmp34 := checkDerefVar(var_glojure_DOT_core_first)
							tmp35 := lang.Apply(tmp34, []any{v24})
							tmp36 := lang.Apply(tmp33, []any{tmp35})
							tmp37 := lang.Apply(tmp30, []any{v15, tmp32, tmp36})
							tmp25 = tmp37
						} else {
							tmp38 := lang.Apply(v12, []any{v15, v21, v24})
							tmp25 = tmp38
						}
						tmp17 = tmp25
					} // end let
					return tmp17
				})
				tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6672), kw_column, int(16), kw_end_DASH_line, int(6675), kw_end_DASH_column, int(45))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp17 := lang.NewMap()
				tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6676), kw_column, int(16), kw_end_DASH_line, int(6676), kw_end_DASH_column, int(17))
				tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp20 := lang.Apply(tmp13, []any{tmp16, tmp19, v8})
				var v21 any = tmp20
				_ = v21
				// let binding "skip-check"
				tmp22 := checkDerefVar(var_glojure_DOT_core_into1)
				tmp23 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6680), kw_column, int(29), kw_end_DASH_line, int(6680), kw_end_DASH_column, int(31))
				tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp26 := checkDerefVar(var_glojure_DOT_core_map)
				tmp27 := checkDerefVar(var_glojure_DOT_core_first)
				tmp28 := checkDerefVar(var_glojure_DOT_core_filter)
				var tmp29 lang.FnFunc
				tmp29 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v30 := args[0]
					_ = v30
					tmp31 := checkDerefVar(var_glojure_DOT_core__LT_)
					tmp32 := checkDerefVar(var_glojure_DOT_core_count)
					tmp33 := checkDerefVar(var_glojure_DOT_core_second)
					tmp34 := lang.Apply(tmp33, []any{v30})
					tmp35 := lang.Apply(tmp32, []any{tmp34})
					tmp36 := lang.Apply(tmp31, []any{int64(1), tmp35})
					return tmp36
				})
				tmp30 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6678), kw_column, int(30), kw_end_DASH_line, int(6678), kw_end_DASH_column, int(54))
				tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp32 := lang.Apply(tmp28, []any{tmp31, v8})
				tmp33 := lang.Apply(tmp26, []any{tmp27, tmp32})
				tmp34 := lang.Apply(tmp22, []any{tmp25, tmp33})
				var v35 any = tmp34
				_ = v35
				tmp36 := checkDerefVar(var_glojure_DOT_core_keys)
				tmp37 := lang.Apply(tmp36, []any{v21})
				tmp38 := checkDerefVar(var_glojure_DOT_core_vals)
				tmp39 := lang.Apply(tmp38, []any{v21})
				tmp40 := lang.NewVector(tmp37, tmp39, v35)
				tmp41 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6681), kw_column, int(5), kw_end_DASH_line, int(6681), kw_end_DASH_column, int(40))
				tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp6 = tmp42
			} // end let
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_merge_DASH_hash_DASH_collisions = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_merge_DASH_hash_DASH_collisions.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prep-hashes
	{
		tmp0 := sym_prep_DASH_hashes.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_expr_DASH_sym, sym_default, sym_tests, sym_thens)), kw_doc, "Takes a sequence of test constants and a corresponding sequence of then\n  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]\n  where case-map is a map of int case values to [test then] tuples, switch-type\n  is either :sparse or :compact, and skip-check is a set of case ints for which\n  post-switch equivalence checking must not be done (occurs with hash\n  collisions).", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(8), kw_line, int(6683), kw_end_DASH_line, int(6683), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "hashcode"
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v8 := args[0]
					_ = v8
					tmp9 := lang.Apply(lang.Hash, []any{v8})
					return tmp9
				})
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6691), kw_column, int(18), kw_end_DASH_line, int(6691), kw_end_DASH_column, int(66))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v10 any = tmp9
				_ = v10
				// let binding "hashes"
				tmp11 := checkDerefVar(var_glojure_DOT_core_into1)
				tmp12 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6692), kw_column, int(23), kw_end_DASH_line, int(6692), kw_end_DASH_column, int(25))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp15 := checkDerefVar(var_glojure_DOT_core_map)
				tmp16 := lang.Apply(tmp15, []any{v10, v4})
				tmp17 := lang.Apply(tmp11, []any{tmp14, tmp16})
				var v18 any = tmp17
				_ = v18
				var tmp19 any
				tmp20 := checkDerefVar(var_glojure_DOT_core__EQ__EQ_)
				tmp21 := checkDerefVar(var_glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v4})
				tmp23 := checkDerefVar(var_glojure_DOT_core_count)
				tmp24 := lang.Apply(tmp23, []any{v18})
				tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
				if lang.IsTruthy(tmp25) {
					var tmp26 any
					tmp27 := checkDerefVar(var_glojure_DOT_core_fits_DASH_table_QMARK_)
					tmp28 := lang.Apply(tmp27, []any{v18})
					if lang.IsTruthy(tmp28) {
						tmp29 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
						tmp30 := checkDerefVar(var_glojure_DOT_core_identity)
						tmp31 := lang.Apply(tmp29, []any{v10, tmp30, v4, v5})
						tmp32 := lang.NewVector(int64(0), int64(0), tmp31, kw_compact)
						tmp33 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6696), kw_column, int(9), kw_end_DASH_line, int(6696), kw_end_DASH_column, int(63))
						tmp34, err := lang.WithMeta(tmp32, tmp33.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp26 = tmp34
					} else {
						var tmp35 any
						{ // let
							// let binding "vec__167"
							var tmp36 any
							{ // let
								// let binding "or__0__auto__"
								tmp37 := checkDerefVar(var_glojure_DOT_core_maybe_DASH_min_DASH_hash)
								tmp38 := lang.Apply(tmp37, []any{v18})
								var v39 any = tmp38
								_ = v39
								var tmp40 any
								if lang.IsTruthy(v39) {
									tmp40 = v39
								} else {
									tmp41 := lang.NewVector(int64(0), int64(0))
									tmp42 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6697), kw_column, int(56), kw_end_DASH_line, int(6697), kw_end_DASH_column, int(60))
									tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp40 = tmp43
								}
								tmp36 = tmp40
							} // end let
							var v37 any = tmp36
							_ = v37
							// let binding "shift"
							tmp38 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp39 := lang.Apply(tmp38, []any{v37, int64(0), nil})
							var v40 any = tmp39
							_ = v40
							// let binding "mask"
							tmp41 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp42 := lang.Apply(tmp41, []any{v37, int64(1), nil})
							var v43 any = tmp42
							_ = v43
							var tmp44 any
							tmp45 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
							tmp46 := lang.Apply(tmp45, []any{v43})
							if lang.IsTruthy(tmp46) {
								tmp47 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
								tmp48 := checkDerefVar(var_glojure_DOT_core_identity)
								tmp49 := lang.Apply(tmp47, []any{v10, tmp48, v4, v5})
								tmp50 := lang.NewVector(int64(0), int64(0), tmp49, kw_sparse)
								tmp51 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6700), kw_column, int(13), kw_end_DASH_line, int(6700), kw_end_DASH_column, int(66))
								tmp52, err := lang.WithMeta(tmp50, tmp51.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp44 = tmp52
							} else {
								tmp53 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
								var tmp54 lang.FnFunc
								tmp54 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v55 := args[0]
									_ = v55
									tmp56 := checkDerefVar(var_glojure_DOT_core_shift_DASH_mask)
									tmp57 := lang.Apply(v10, []any{v55})
									tmp58 := lang.Apply(tmp56, []any{v40, v43, tmp57})
									return tmp58
								})
								tmp55 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6702), kw_column, int(35), kw_end_DASH_line, int(6702), kw_end_DASH_column, int(71))
								tmp56, err := lang.WithMeta(tmp54, tmp55.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp57 := checkDerefVar(var_glojure_DOT_core_identity)
								tmp58 := lang.Apply(tmp53, []any{tmp56, tmp57, v4, v5})
								tmp59 := lang.NewVector(v40, v43, tmp58, kw_compact)
								tmp60 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6702), kw_column, int(13), kw_end_DASH_line, int(6702), kw_end_DASH_column, int(103))
								tmp61, err := lang.WithMeta(tmp59, tmp60.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp44 = tmp61
							}
							tmp35 = tmp44
						} // end let
						tmp26 = tmp35
					}
					tmp19 = tmp26
				} else {
					var tmp36 any
					{ // let
						// let binding "vec__170"
						tmp37 := checkDerefVar(var_glojure_DOT_core_merge_DASH_hash_DASH_collisions)
						tmp38 := lang.Apply(tmp37, []any{v2, v3, v4, v5})
						var v39 any = tmp38
						_ = v39
						// let binding "tests"
						tmp40 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp41 := lang.Apply(tmp40, []any{v39, int64(0), nil})
						var v42 any = tmp41
						_ = v42
						// let binding "thens"
						tmp43 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp44 := lang.Apply(tmp43, []any{v39, int64(1), nil})
						var v45 any = tmp44
						_ = v45
						// let binding "skip-check"
						tmp46 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp47 := lang.Apply(tmp46, []any{v39, int64(2), nil})
						var v48 any = tmp47
						_ = v48
						// let binding "vec__173"
						tmp49 := checkDerefVar(var_glojure_DOT_core_prep_DASH_hashes)
						tmp50 := lang.Apply(tmp49, []any{v2, v3, v42, v45})
						var v51 any = tmp50
						_ = v51
						// let binding "shift"
						tmp52 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp53 := lang.Apply(tmp52, []any{v51, int64(0), nil})
						var v54 any = tmp53
						_ = v54
						// let binding "mask"
						tmp55 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp56 := lang.Apply(tmp55, []any{v51, int64(1), nil})
						var v57 any = tmp56
						_ = v57
						// let binding "case-map"
						tmp58 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp59 := lang.Apply(tmp58, []any{v51, int64(2), nil})
						var v60 any = tmp59
						_ = v60
						// let binding "switch-type"
						tmp61 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp62 := lang.Apply(tmp61, []any{v51, int64(3), nil})
						var v63 any = tmp62
						_ = v63
						// let binding "skip-check"
						var tmp64 any
						tmp65 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
						tmp66 := lang.Apply(tmp65, []any{v57})
						if lang.IsTruthy(tmp66) {
							tmp64 = v48
						} else {
							tmp67 := checkDerefVar(var_glojure_DOT_core_into1)
							tmp68 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp69 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6708), kw_column, int(33), kw_end_DASH_line, int(6708), kw_end_DASH_column, int(35))
							tmp70, err := lang.WithMeta(tmp68, tmp69.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp71 := checkDerefVar(var_glojure_DOT_core_map)
							var tmp72 lang.FnFunc
							tmp72 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v73 := args[0]
								_ = v73
								tmp74 := checkDerefVar(var_glojure_DOT_core_shift_DASH_mask)
								tmp75 := lang.Apply(tmp74, []any{v54, v57, v73})
								return tmp75
							})
							tmp73 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6708), kw_column, int(42), kw_end_DASH_line, int(6708), kw_end_DASH_column, int(67))
							tmp74, err := lang.WithMeta(tmp72, tmp73.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp75 := lang.Apply(tmp71, []any{tmp74, v48})
							tmp76 := lang.Apply(tmp67, []any{tmp70, tmp75})
							tmp64 = tmp76
						}
						var v77 any = tmp64
						_ = v77
						tmp78 := lang.NewVector(v54, v57, v60, v63, v77)
						tmp79 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6709), kw_column, int(9), kw_end_DASH_line, int(6709), kw_end_DASH_column, int(52))
						tmp80, err := lang.WithMeta(tmp78, tmp79.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp36 = tmp80
					} // end let
					tmp19 = tmp36
				}
				tmp6 = tmp19
			} // end let
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_prep_DASH_hashes = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_prep_DASH_hashes.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tree-seq
	{
		tmp0 := sym_tree_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_branch_QMARK_, sym_children, sym_root)), kw_doc, "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4955), kw_end_DASH_line, int(4955))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "walk"
				var tmp6 lang.FnFunc
				{ // function walk
					var v7 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v8 := args[0]
						_ = v8
						var tmp9 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							tmp10 := checkDerefVar(var_glojure_DOT_core_cons)
							var tmp11 any
							tmp12 := lang.Apply(v2, []any{v8})
							if lang.IsTruthy(tmp12) {
								tmp13 := checkDerefVar(var_glojure_DOT_core_mapcat)
								tmp14 := lang.Apply(v3, []any{v8})
								tmp15 := lang.Apply(tmp13, []any{v7, tmp14})
								tmp11 = tmp15
							} else {
							}
							tmp16 := lang.Apply(tmp10, []any{v8, tmp11})
							return tmp16
						})
						tmp10 := lang.Apply(lang.NewLazySeq, []any{tmp9})
						return tmp10
					})
					v7 = tmp6
					_ = v7
				}
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4965), kw_column, int(15), kw_end_DASH_line, int(4969), kw_end_DASH_column, int(53))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v9 any = tmp8
				_ = v9
				tmp10 := lang.Apply(v9, []any{v4})
				tmp5 = tmp10
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_tree_DASH_seq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_tree_DASH_seq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// xml-seq
	{
		tmp0 := sym_xml_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_root)), kw_doc, "A tree seq on the xml elements as per xml/parse", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4982), kw_end_DASH_line, int(4982))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_tree_DASH_seq)
			tmp4 := checkDerefVar(var_glojure_DOT_core_complement)
			tmp5 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp6 := lang.Apply(tmp4, []any{tmp5})
			tmp7 := checkDerefVar(var_glojure_DOT_core_comp)
			tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp9 := lang.Apply(tmp7, []any{tmp8, kw_content})
			tmp10 := lang.Apply(tmp3, []any{tmp6, tmp9, v2})
			return tmp10
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_xml_DASH_seq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_xml_DASH_seq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-extend-type
	{
		tmp0 := sym_emit_DASH_extend_DASH_type.WithMeta(lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(175), kw_column, int(8), kw_end_DASH_line, int(175), kw_end_DASH_column, int(23), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_c, sym_specs)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "impls"
				tmp5 := checkDerefVar(var_glojure_DOT_core_parse_DASH_impls)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_extend})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v2})
				tmp14 := checkDerefVar(var_glojure_DOT_core_mapcat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_partial)
				tmp16 := checkDerefVar(var_glojure_DOT_core_emit_DASH_hinted_DASH_impl)
				tmp17 := lang.Apply(tmp15, []any{tmp16, v2})
				tmp18 := lang.Apply(tmp14, []any{tmp17, v7})
				tmp19 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp18})
				tmp20 := lang.Apply(tmp8, []any{tmp19})
				tmp4 = tmp20
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_emit_DASH_extend_DASH_type = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_emit_DASH_extend_DASH_type.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend-type
	{
		tmp0 := sym_extend_DASH_type.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_t, sym__AMP_, sym_specs)), kw_doc, "A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType \n    Countable\n      (cnt [c] ...)\n    Foo\n      (bar [x y] ...)\n      (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n   Countable\n     {:cnt (fn [c] ...)}\n   Foo\n     {:baz (fn ([x] ...) ([x y & zs] ...))\n      :bar (fn [x y] ...)})", kw_file, "glojure/core_deftype.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(11), kw_line, int(180), kw_end_DASH_line, int(180))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var v5 any = lang.NewList(args[3:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_emit_DASH_extend_DASH_type)
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_extend_DASH_type = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_extend_DASH_type.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// file-seq
	{
		tmp0 := sym_file_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_dir)), kw_doc, "A tree seq on java.io.Files", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4972), kw_end_DASH_line, int(4972))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_tree_DASH_seq)
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v5 := args[0]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v5, "isDirectory")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("isDirectory is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{})
				return tmp7
			})
			tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4978), kw_column, int(6), kw_end_DASH_line, int(4978), kw_end_DASH_column, int(47))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp7 lang.FnFunc
			tmp7 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v8 := args[0]
				_ = v8
				tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp10, _ := lang.FieldOrMethod(v8, "listFiles")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("listFiles is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{})
				tmp12 := lang.Apply(tmp9, []any{tmp11})
				return tmp12
			})
			tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4979), kw_column, int(6), kw_end_DASH_line, int(4979), kw_end_DASH_column, int(51))
			tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp10 := lang.Apply(tmp3, []any{tmp6, tmp9, v2})
			return tmp10
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_file_DASH_seq = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_file_DASH_seq.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// flatten
	{
		tmp0 := sym_flatten.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat lazy sequence.\n  (flatten nil) returns an empty sequence.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(7118), kw_end_DASH_line, int(7118))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_filter)
			tmp4 := checkDerefVar(var_glojure_DOT_core_complement)
			tmp5 := checkDerefVar(var_glojure_DOT_core_sequential_QMARK_)
			tmp6 := lang.Apply(tmp4, []any{tmp5})
			tmp7 := checkDerefVar(var_glojure_DOT_core_rest)
			tmp8 := checkDerefVar(var_glojure_DOT_core_tree_DASH_seq)
			tmp9 := checkDerefVar(var_glojure_DOT_core_sequential_QMARK_)
			tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp11 := lang.Apply(tmp8, []any{tmp9, tmp10, v2})
			tmp12 := lang.Apply(tmp7, []any{tmp11})
			tmp13 := lang.Apply(tmp3, []any{tmp6, tmp12})
			return tmp13
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_flatten = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_flatten.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compile
	{
		tmp0 := sym_compile.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_lib)), kw_doc, "Compiles the namespace named by the symbol lib into a set of\n  classfiles. The source for the lib must be in a proper\n  classpath-relative directory. The output files will go into the\n  directory specified by *compile-path*, and that directory too must\n  be in the classpath.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6114), kw_end_DASH_line, int(6114))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				tmp4 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp5 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
				tmp6 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_compile_DASH_files_STAR_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, true})
				tmp8 := lang.Apply(tmp4, []any{tmp7})
				_ = tmp8
				var tmp9 any
				func() {
					defer func() {
						tmp10 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp11 := lang.Apply(tmp10, nil)
						_ = tmp11
					}()
					tmp12 := checkDerefVar(var_glojure_DOT_core_load_DASH_one)
					tmp13 := lang.Apply(tmp12, []any{v2, true, true})
					tmp9 = tmp13
				}()
				tmp3 = tmp9
			} // end let
			_ = tmp3
			return v2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_compile = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_compile.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// derive
	{
		tmp0 := sym_derive.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag, sym_parent), lang.NewVector(sym_h, sym_tag, sym_parent)), kw_doc, "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5605), kw_end_DASH_line, int(5605))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_alter_DASH_var_DASH_root)
				tmp5 := lang.InternVarName(sym_glojure_DOT_core, sym_global_DASH_hierarchy)
				tmp6 := checkDerefVar(var_glojure_DOT_core_derive)
				tmp7 := lang.Apply(tmp4, []any{tmp5, tmp6, v2, v3})
				_ = tmp7
				return nil
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "tp"
					tmp6 := lang.Apply(kw_parents, []any{v2})
					var v7 any = tmp6
					_ = v7
					// let binding "td"
					tmp8 := lang.Apply(kw_descendants, []any{v2})
					var v9 any = tmp8
					_ = v9
					// let binding "ta"
					tmp10 := lang.Apply(kw_ancestors, []any{v2})
					var v11 any = tmp10
					_ = v11
					// let binding "tf"
					var tmp12 lang.FnFunc
					tmp12 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 5)
						v13 := args[0]
						_ = v13
						v14 := args[1]
						_ = v14
						v15 := args[2]
						_ = v15
						v16 := args[3]
						_ = v16
						v17 := args[4]
						_ = v17
						tmp18 := checkDerefVar(var_glojure_DOT_core_reduce1)
						var tmp19 lang.FnFunc
						tmp19 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v20 := args[0]
							_ = v20
							v21 := args[1]
							_ = v21
							tmp22 := checkDerefVar(var_glojure_DOT_core_assoc)
							tmp23 := checkDerefVar(var_glojure_DOT_core_reduce1)
							tmp24 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp25 := checkDerefVar(var_glojure_DOT_core_get)
							tmp26 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp27 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5628), kw_column, int(61), kw_end_DASH_line, int(5628), kw_end_DASH_column, int(63))
							tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp29 := lang.Apply(tmp25, []any{v17, v21, tmp28})
							tmp30 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp31 := lang.Apply(v17, []any{v16})
							tmp32 := lang.Apply(tmp30, []any{v16, tmp31})
							tmp33 := lang.Apply(tmp23, []any{tmp24, tmp29, tmp32})
							tmp34 := lang.Apply(tmp22, []any{v20, v21, tmp33})
							return tmp34
						})
						tmp20 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5626), kw_column, int(24), kw_end_DASH_line, int(5628), kw_end_DASH_column, int(98))
						tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp22 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp23 := lang.Apply(v15, []any{v14})
						tmp24 := lang.Apply(tmp22, []any{v14, tmp23})
						tmp25 := lang.Apply(tmp18, []any{tmp21, v13, tmp24})
						return tmp25
					})
					tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5625), kw_column, int(13), kw_end_DASH_line, int(5629), kw_end_DASH_column, int(56))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v15 any = tmp14
					_ = v15
					var tmp16 any
					{ // let
						// let binding "or__0__auto__"
						var tmp17 any
						tmp18 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
						tmp19 := lang.Apply(v7, []any{v3})
						tmp20 := lang.Apply(tmp18, []any{tmp19, v4})
						if lang.IsTruthy(tmp20) {
						} else {
							var tmp21 any
							tmp22 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
							tmp23 := lang.Apply(v11, []any{v3})
							tmp24 := lang.Apply(tmp22, []any{tmp23, v4})
							if lang.IsTruthy(tmp24) {
								tmp25 := checkDerefVar(var_glojure_DOT_core_print_DASH_str)
								tmp26 := lang.Apply(tmp25, []any{v3, "already has", v4, "as ancestor"})
								tmp27 := lang.Apply(lang.NewError, []any{tmp26})
								panic(tmp27)
							} else {
							}
							_ = tmp21
							var tmp28 any
							tmp29 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
							tmp30 := lang.Apply(v11, []any{v4})
							tmp31 := lang.Apply(tmp29, []any{tmp30, v3})
							if lang.IsTruthy(tmp31) {
								tmp32 := checkDerefVar(var_glojure_DOT_core_print_DASH_str)
								tmp33 := lang.Apply(tmp32, []any{"Cyclic derivation:", v4, "has", v3, "as ancestor"})
								tmp34 := lang.Apply(lang.NewError, []any{tmp33})
								panic(tmp34)
							} else {
							}
							_ = tmp28
							tmp35 := checkDerefVar(var_glojure_DOT_core_assoc)
							tmp36 := lang.Apply(kw_parents, []any{v2})
							tmp37 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp38 := checkDerefVar(var_glojure_DOT_core_get)
							tmp39 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp40 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5636), kw_column, int(61), kw_end_DASH_line, int(5636), kw_end_DASH_column, int(63))
							tmp41, err := lang.WithMeta(tmp39, tmp40.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp42 := lang.Apply(tmp38, []any{v7, v3, tmp41})
							tmp43 := lang.Apply(tmp37, []any{tmp42, v4})
							tmp44 := lang.Apply(tmp35, []any{tmp36, v3, tmp43})
							tmp45 := lang.Apply(kw_ancestors, []any{v2})
							tmp46 := lang.Apply(v15, []any{tmp45, v3, v9, v4, v11})
							tmp47 := lang.Apply(kw_descendants, []any{v2})
							tmp48 := lang.Apply(v15, []any{tmp47, v4, v11, v3, v9})
							tmp49 := lang.NewMap(kw_parents, tmp44, kw_ancestors, tmp46, kw_descendants, tmp48)
							tmp50 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5636), kw_column, int(9), kw_end_DASH_line, int(5638), kw_end_DASH_column, int(61))
							tmp51, err := lang.WithMeta(tmp49, tmp50.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp51
						}
						var v52 any = tmp17
						_ = v52
						var tmp53 any
						if lang.IsTruthy(v52) {
							tmp53 = v52
						} else {
							tmp53 = v2
						}
						tmp16 = tmp53
					} // end let
					tmp5 = tmp16
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_derive = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_derive.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// underive
	{
		tmp0 := sym_underive.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag, sym_parent), lang.NewVector(sym_h, sym_tag, sym_parent)), kw_doc, "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(5643), kw_end_DASH_line, int(5643))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_alter_DASH_var_DASH_root)
				tmp5 := lang.InternVarName(sym_glojure_DOT_core, sym_global_DASH_hierarchy)
				tmp6 := checkDerefVar(var_glojure_DOT_core_underive)
				tmp7 := lang.Apply(tmp4, []any{tmp5, tmp6, v2, v3})
				_ = tmp7
				return nil
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "parentMap"
					tmp6 := lang.Apply(kw_parents, []any{v2})
					var v7 any = tmp6
					_ = v7
					// let binding "childsParents"
					var tmp8 any
					tmp9 := lang.Apply(v7, []any{v3})
					if lang.IsTruthy(tmp9) {
						tmp10 := checkDerefVar(var_glojure_DOT_core_disj)
						tmp11 := lang.Apply(v7, []any{v3})
						tmp12 := lang.Apply(tmp10, []any{tmp11, v4})
						tmp8 = tmp12
					} else {
						tmp13 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
						tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5652), kw_column, int(36), kw_end_DASH_line, int(5652), kw_end_DASH_column, int(38))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp15
					}
					var v16 any = tmp8
					_ = v16
					// let binding "newParents"
					var tmp17 any
					tmp18 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
					tmp19 := lang.Apply(tmp18, []any{v16})
					if lang.IsTruthy(tmp19) {
						tmp20 := checkDerefVar(var_glojure_DOT_core_assoc)
						tmp21 := lang.Apply(tmp20, []any{v7, v3, v16})
						tmp17 = tmp21
					} else {
						tmp22 := checkDerefVar(var_glojure_DOT_core_dissoc)
						tmp23 := lang.Apply(tmp22, []any{v7, v3})
						tmp17 = tmp23
					}
					var v24 any = tmp17
					_ = v24
					// let binding "deriv-seq"
					tmp25 := checkDerefVar(var_glojure_DOT_core_flatten)
					tmp26 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp27 lang.FnFunc
					tmp27 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v28 := args[0]
						_ = v28
						tmp29 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp30 := checkDerefVar(var_glojure_DOT_core_key)
						tmp31 := lang.Apply(tmp30, []any{v28})
						tmp32 := checkDerefVar(var_glojure_DOT_core_interpose)
						tmp33 := checkDerefVar(var_glojure_DOT_core_key)
						tmp34 := lang.Apply(tmp33, []any{v28})
						tmp35 := checkDerefVar(var_glojure_DOT_core_val)
						tmp36 := lang.Apply(tmp35, []any{v28})
						tmp37 := lang.Apply(tmp32, []any{tmp34, tmp36})
						tmp38 := lang.Apply(tmp29, []any{tmp31, tmp37})
						return tmp38
					})
					tmp28 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5656), kw_column, int(28), kw_end_DASH_line, int(5656), kw_end_DASH_column, int(70))
					tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp30 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp31 := lang.Apply(tmp30, []any{v24})
					tmp32 := lang.Apply(tmp26, []any{tmp29, tmp31})
					tmp33 := lang.Apply(tmp25, []any{tmp32})
					var v34 any = tmp33
					_ = v34
					var tmp35 any
					tmp36 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
					tmp37 := lang.Apply(v7, []any{v3})
					tmp38 := lang.Apply(tmp36, []any{tmp37, v4})
					if lang.IsTruthy(tmp38) {
						tmp39 := checkDerefVar(var_glojure_DOT_core_reduce1)
						var tmp40 lang.FnFunc
						tmp40 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v41 := args[0]
							_ = v41
							v42 := args[1]
							_ = v42
							tmp43 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp44 := checkDerefVar(var_glojure_DOT_core_derive)
							tmp45 := lang.Apply(tmp43, []any{tmp44, v41, v42})
							return tmp45
						})
						tmp41 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5659), kw_column, int(11), kw_end_DASH_line, int(5659), kw_end_DASH_column, int(31))
						tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp43 := checkDerefVar(var_glojure_DOT_core_make_DASH_hierarchy)
						tmp44 := lang.Apply(tmp43, nil)
						tmp45 := checkDerefVar(var_glojure_DOT_core_partition)
						tmp46 := lang.Apply(tmp45, []any{int64(2), v34})
						tmp47 := lang.Apply(tmp39, []any{tmp42, tmp44, tmp46})
						tmp35 = tmp47
					} else {
						tmp35 = v2
					}
					tmp5 = tmp35
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_underive = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_underive.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filterv
	{
		tmp0 := sym_filterv.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6961), kw_end_DASH_line, int(6961))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
			tmp5 := checkDerefVar(var_glojure_DOT_core_reduce)
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v7 := args[0]
				_ = v7
				v8 := args[1]
				_ = v8
				var tmp9 any
				tmp10 := lang.Apply(v2, []any{v8})
				if lang.IsTruthy(tmp10) {
					tmp11 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp12 := lang.Apply(tmp11, []any{v7, v8})
					tmp9 = tmp12
				} else {
					tmp9 = v7
				}
				return tmp9
			})
			tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6967), kw_column, int(15), kw_end_DASH_line, int(6967), kw_end_DASH_column, int(52))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := checkDerefVar(var_glojure_DOT_core_transient)
			tmp10 := lang.NewVector()
			tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6968), kw_column, int(26), kw_end_DASH_line, int(6968), kw_end_DASH_column, int(27))
			tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp13 := lang.Apply(tmp9, []any{tmp12})
			tmp14 := lang.Apply(tmp5, []any{tmp8, tmp13, v3})
			tmp15 := lang.Apply(tmp4, []any{tmp14})
			return tmp15
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_filterv = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_filterv.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// flush
	{
		tmp0 := sym_flush.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Flushes the output stream that is the current value of\n  *out*", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3706), kw_end_DASH_line, int(3706))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_glojure_DOT_core__STAR_out_STAR_)
			tmp3, _ := lang.FieldOrMethod(tmp2, "Sync")
			if reflect.TypeOf(tmp3).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Sync is not a function")))
			}
			tmp4 := lang.Apply(tmp3, []any{})
			_ = tmp4
			return nil
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_flush = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_flush.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// frequencies
	{
		tmp0 := sym_frequencies.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a map from distinct items in coll to the number of times\n  they appear.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(7185), kw_end_DASH_line, int(7185))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
			tmp4 := checkDerefVar(var_glojure_DOT_core_reduce)
			var tmp5 lang.FnFunc
			tmp5 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v6 := args[0]
				_ = v6
				v7 := args[1]
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_assoc_BANG_)
				tmp9 := checkDerefVar(var_glojure_DOT_core_inc)
				tmp10 := checkDerefVar(var_glojure_DOT_core_get)
				tmp11 := lang.Apply(tmp10, []any{v6, v7, int64(0)})
				tmp12 := lang.Apply(tmp9, []any{tmp11})
				tmp13 := lang.Apply(tmp8, []any{v6, v7, tmp12})
				return tmp13
			})
			tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7192), kw_column, int(12), kw_end_DASH_line, int(7193), kw_end_DASH_column, int(54))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp8 := checkDerefVar(var_glojure_DOT_core_transient)
			tmp9 := lang.NewMap()
			tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7194), kw_column, int(23), kw_end_DASH_line, int(7194), kw_end_DASH_column, int(24))
			tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp12 := lang.Apply(tmp8, []any{tmp11})
			tmp13 := lang.Apply(tmp4, []any{tmp7, tmp12, v2})
			tmp14 := lang.Apply(tmp3, []any{tmp13})
			return tmp14
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_frequencies = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_frequencies.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// group-by
	{
		tmp0 := sym_group_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll)), kw_doc, "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(7128), kw_end_DASH_line, int(7128))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
			tmp5 := checkDerefVar(var_glojure_DOT_core_reduce)
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v7 := args[0]
				_ = v7
				v8 := args[1]
				_ = v8
				var tmp9 any
				{ // let
					// let binding "k"
					tmp10 := lang.Apply(v2, []any{v8})
					var v11 any = tmp10
					_ = v11
					tmp12 := checkDerefVar(var_glojure_DOT_core_assoc_BANG_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp14 := checkDerefVar(var_glojure_DOT_core_get)
					tmp15 := lang.NewVector()
					tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7139), kw_column, int(40), kw_end_DASH_line, int(7139), kw_end_DASH_column, int(41))
					tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp18 := lang.Apply(tmp14, []any{v7, v11, tmp17})
					tmp19 := lang.Apply(tmp13, []any{tmp18, v8})
					tmp20 := lang.Apply(tmp12, []any{v7, v11, tmp19})
					tmp9 = tmp20
				} // end let
				return tmp9
			})
			tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7137), kw_column, int(5), kw_end_DASH_line, int(7139), kw_end_DASH_column, int(48))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := checkDerefVar(var_glojure_DOT_core_transient)
			tmp10 := lang.NewMap()
			tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7140), kw_column, int(16), kw_end_DASH_line, int(7140), kw_end_DASH_column, int(17))
			tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp13 := lang.Apply(tmp9, []any{tmp12})
			tmp14 := lang.Apply(tmp5, []any{tmp8, tmp13, v3})
			tmp15 := lang.Apply(tmp4, []any{tmp14})
			return tmp15
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_group_DASH_by = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_group_DASH_by.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into
	{
		tmp0 := sym_into.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_to), lang.NewVector(sym_to, sym_from), lang.NewVector(sym_to, sym_xform, sym_from)), kw_doc, "Returns a new coll consisting of to with all of the items of\n  from conjoined. A transducer may be supplied.\n  (into x) returns x. (into) returns [].", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6922), kw_end_DASH_line, int(6922))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := lang.NewVector()
				tmp3 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6928), kw_column, int(7), kw_end_DASH_line, int(6928), kw_end_DASH_column, int(8))
				tmp4, err := lang.WithMeta(tmp2, tmp3.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				return v2
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp9 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
					tmp10 := checkDerefVar(var_glojure_DOT_core_reduce)
					tmp11 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp12 := checkDerefVar(var_glojure_DOT_core_transient)
					tmp13 := lang.Apply(tmp12, []any{v2})
					tmp14 := lang.Apply(tmp10, []any{tmp11, tmp13, v3})
					tmp15 := lang.Apply(tmp9, []any{tmp14})
					tmp16 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp17 := lang.Apply(tmp16, []any{v2})
					tmp18 := lang.Apply(tmp8, []any{tmp15, tmp17})
					tmp4 = tmp18
				} else {
					tmp19 := checkDerefVar(var_glojure_DOT_core_reduce)
					tmp20 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp21 := lang.Apply(tmp19, []any{tmp20, v2, v3})
					tmp4 = tmp21
				}
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v2})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					{ // let
						// let binding "tm"
						tmp10 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp11 := lang.Apply(tmp10, []any{v2})
						var v12 any = tmp11
						_ = v12
						// let binding "rf"
						var tmp13 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 1:
								v14 := args[0]
								_ = v14
								tmp15 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
								tmp16 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
								tmp17 := lang.Apply(tmp16, []any{v14})
								tmp18 := lang.Apply(tmp15, []any{tmp17, v12})
								return tmp18
							case 2:
								v14 := args[0]
								_ = v14
								v15 := args[1]
								_ = v15
								tmp16 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
								tmp17 := lang.Apply(tmp16, []any{v14, v15})
								return tmp17
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6937), kw_column, int(17), kw_end_DASH_line, int(6939), kw_end_DASH_column, int(44))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v16 any = tmp15
						_ = v16
						tmp17 := checkDerefVar(var_glojure_DOT_core_transduce)
						tmp18 := checkDerefVar(var_glojure_DOT_core_transient)
						tmp19 := lang.Apply(tmp18, []any{v2})
						tmp20 := lang.Apply(tmp17, []any{v3, v16, tmp19, v4})
						tmp9 = tmp20
					} // end let
					tmp5 = tmp9
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_transduce)
					tmp11 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp12 := lang.Apply(tmp10, []any{v3, tmp11, v2, v4})
					tmp5 = tmp12
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_into = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_into.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partitionv
	{
		tmp0 := sym_partitionv.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll), lang.NewVector(sym_n, sym_step, sym_coll), lang.NewVector(sym_n, sym_step, sym_pad, sym_coll)), kw_doc, "Returns a lazy sequence of vectors of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7262), kw_end_DASH_line, int(7262))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_partitionv)
				tmp5 := lang.Apply(tmp4, []any{v2, v2, v3})
				return tmp5
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								{ // let
									// let binding "p"
									tmp14 := checkDerefVar(var_glojure_DOT_core_into)
									tmp15 := lang.NewVector()
									tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7274), kw_column, int(22), kw_end_DASH_line, int(7274), kw_end_DASH_column, int(23))
									tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp18 := checkDerefVar(var_glojure_DOT_core_take)
									tmp19 := lang.Apply(tmp18, []any{v2})
									tmp20 := lang.Apply(tmp14, []any{tmp17, tmp19, v12})
									var v21 any = tmp20
									_ = v21
									var tmp22 any
									tmp23 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp24 := checkDerefVar(var_glojure_DOT_core_count)
									tmp25 := lang.Apply(tmp24, []any{v21})
									tmp26 := lang.Apply(tmp23, []any{v2, tmp25})
									if lang.IsTruthy(tmp26) {
										tmp27 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp28 := checkDerefVar(var_glojure_DOT_core_partitionv)
										tmp29 := checkDerefVar(var_glojure_DOT_core_nthrest)
										tmp30 := lang.Apply(tmp29, []any{v12, v3})
										tmp31 := lang.Apply(tmp28, []any{v2, v3, tmp30})
										tmp32 := lang.Apply(tmp27, []any{v21, tmp31})
										tmp22 = tmp32
									} else {
									}
									tmp13 = tmp22
								} // end let
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v5})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "s"
								var v13 any = v10
								_ = v13
								var tmp14 any
								{ // let
									// let binding "p"
									tmp15 := checkDerefVar(var_glojure_DOT_core_into)
									tmp16 := lang.NewVector()
									tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7280), kw_column, int(22), kw_end_DASH_line, int(7280), kw_end_DASH_column, int(23))
									tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp19 := checkDerefVar(var_glojure_DOT_core_take)
									tmp20 := lang.Apply(tmp19, []any{v2})
									tmp21 := lang.Apply(tmp15, []any{tmp18, tmp20, v13})
									var v22 any = tmp21
									_ = v22
									var tmp23 any
									tmp24 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp25 := checkDerefVar(var_glojure_DOT_core_count)
									tmp26 := lang.Apply(tmp25, []any{v22})
									tmp27 := lang.Apply(tmp24, []any{v2, tmp26})
									if lang.IsTruthy(tmp27) {
										tmp28 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp29 := checkDerefVar(var_glojure_DOT_core_partitionv)
										tmp30 := checkDerefVar(var_glojure_DOT_core_nthrest)
										tmp31 := lang.Apply(tmp30, []any{v13, v3})
										tmp32 := lang.Apply(tmp29, []any{v2, v3, v4, tmp31})
										tmp33 := lang.Apply(tmp28, []any{v22, tmp32})
										tmp23 = tmp33
									} else {
										tmp34 := checkDerefVar(var_glojure_DOT_core_list)
										tmp35 := checkDerefVar(var_glojure_DOT_core_into)
										tmp36 := lang.NewVector()
										tmp37 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7283), kw_column, int(24), kw_end_DASH_line, int(7283), kw_end_DASH_column, int(25))
										tmp38, err := lang.WithMeta(tmp36, tmp37.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp39 := checkDerefVar(var_glojure_DOT_core_take)
										tmp40 := lang.Apply(tmp39, []any{v2})
										tmp41 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp42 := lang.Apply(tmp41, []any{v22, v4})
										tmp43 := lang.Apply(tmp35, []any{tmp38, tmp40, tmp42})
										tmp44 := lang.Apply(tmp34, []any{tmp43})
										tmp23 = tmp44
									}
									tmp14 = tmp23
								} // end let
								tmp12 = tmp14
							} // end let
							tmp11 = tmp12
						} else {
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_partitionv = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_partitionv.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partitionv-all
	{
		tmp0 := sym_partitionv_DASH_all.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n), lang.NewVector(sym_n, sym_coll), lang.NewVector(sym_n, sym_step, sym_coll)), kw_doc, "Returns a lazy sequence of vector partitions, but may include\n  partitions with fewer than n items at the end.\n  Returns a stateful transducer when no collection is provided.", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(7285), kw_end_DASH_line, int(7285))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_partition_DASH_all)
				tmp4 := lang.Apply(tmp3, []any{v2})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_partitionv_DASH_all)
				tmp5 := lang.Apply(tmp4, []any{v2, v2, v3})
				return tmp5
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								{ // let
									// let binding "seg"
									tmp14 := checkDerefVar(var_glojure_DOT_core_into)
									tmp15 := lang.NewVector()
									tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7297), kw_column, int(24), kw_end_DASH_line, int(7297), kw_end_DASH_column, int(25))
									tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp18 := checkDerefVar(var_glojure_DOT_core_take)
									tmp19 := lang.Apply(tmp18, []any{v2})
									tmp20 := lang.Apply(tmp14, []any{tmp17, tmp19, v4})
									var v21 any = tmp20
									_ = v21
									tmp22 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp23 := checkDerefVar(var_glojure_DOT_core_partitionv_DASH_all)
									tmp24 := checkDerefVar(var_glojure_DOT_core_drop)
									tmp25 := lang.Apply(tmp24, []any{v3, v12})
									tmp26 := lang.Apply(tmp23, []any{v2, v3, tmp25})
									tmp27 := lang.Apply(tmp22, []any{v21, tmp26})
									tmp13 = tmp27
								} // end let
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_partitionv_DASH_all = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_partitionv_DASH_all.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// splitv-at
	{
		tmp0 := sym_splitv_DASH_at.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a vector of [(into [] (take n) coll) (drop n coll)]", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(7256), kw_end_DASH_line, int(7256))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_into)
			tmp5 := lang.NewVector()
			tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7260), kw_column, int(10), kw_end_DASH_line, int(7260), kw_end_DASH_column, int(11))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp8 := checkDerefVar(var_glojure_DOT_core_take)
			tmp9 := lang.Apply(tmp8, []any{v2})
			tmp10 := lang.Apply(tmp4, []any{tmp7, tmp9, v3})
			tmp11 := checkDerefVar(var_glojure_DOT_core_drop)
			tmp12 := lang.Apply(tmp11, []any{v2, v3})
			tmp13 := lang.NewVector(tmp10, tmp12)
			tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7260), kw_column, int(3), kw_end_DASH_line, int(7260), kw_end_DASH_column, int(41))
			tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp15
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_splitv_DASH_at = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_splitv_DASH_at.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iteration
	{
		tmp0 := sym_iteration.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_step, sym__AMP_, lang.NewMap(kw_keys, lang.NewVector(sym_somef, sym_vf, sym_kf, sym_initk), kw_or, lang.NewMap(sym_vf, sym_identity, sym_kf, sym_identity, sym_somef, sym_some_QMARK_, sym_initk, nil)))), kw_doc, "Creates a seqable/reducible via repeated calls to step,\n  a function of some (continuation token) 'k'. The first call to step\n  will be passed initk, returning 'ret'. Iff (somef ret) is true,\n  (vf ret) will be included in the iteration, else iteration will\n  terminate and vf/kf will not be called. If (kf ret) is non-nil it\n  will be passed to the next step call, else iteration will terminate.\n\n  This can be used e.g. to consume APIs that return paginated or batched data.\n\n   step - (possibly impure) fn of 'k' -> 'ret'\n\n   :somef - fn of 'ret' -> logical true/false, default 'some?'\n   :vf - fn of 'ret' -> 'v', a value produced by the iteration, default 'identity'\n   :kf - fn of 'ret' -> 'next-k' or nil (signaling 'do not continue'), default 'identity'\n   :initk - the first value passed to step, default 'nil'\n\n  It is presumed that step with non-initk is unreproducible/non-idempotent.\n  If step with initk is unreproducible it is on the consumer to not consume twice.", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(7716), kw_end_DASH_line, int(7716))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "map__357"
					var v5 any = v3
					_ = v5
					// let binding "map__357"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{v5})
					if lang.IsTruthy(tmp8) {
						var tmp9 any
						tmp10 := checkDerefVar(var_glojure_DOT_core_next)
						tmp11 := lang.Apply(tmp10, []any{v5})
						if lang.IsTruthy(tmp11) {
							tmp12 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
							tmp13 := lang.Apply(tmp12, []any{v5})
							tmp14 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp13})
							tmp9 = tmp14
						} else {
							var tmp15 any
							tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp17 := lang.Apply(tmp16, []any{v5})
							if lang.IsTruthy(tmp17) {
								tmp18 := checkDerefVar(var_glojure_DOT_core_first)
								tmp19 := lang.Apply(tmp18, []any{v5})
								tmp15 = tmp19
							} else {
							}
							tmp9 = tmp15
						}
						tmp6 = tmp9
					} else {
						tmp6 = v5
					}
					var v20 any = tmp6
					_ = v20
					// let binding "somef"
					tmp21 := checkDerefVar(var_glojure_DOT_core_get)
					tmp22 := checkDerefVar(var_glojure_DOT_core_some_QMARK_)
					tmp23 := lang.Apply(tmp21, []any{v20, kw_somef, tmp22})
					var v24 any = tmp23
					_ = v24
					// let binding "vf"
					tmp25 := checkDerefVar(var_glojure_DOT_core_get)
					tmp26 := checkDerefVar(var_glojure_DOT_core_identity)
					tmp27 := lang.Apply(tmp25, []any{v20, kw_vf, tmp26})
					var v28 any = tmp27
					_ = v28
					// let binding "kf"
					tmp29 := checkDerefVar(var_glojure_DOT_core_get)
					tmp30 := checkDerefVar(var_glojure_DOT_core_identity)
					tmp31 := lang.Apply(tmp29, []any{v20, kw_kf, tmp30})
					var v32 any = tmp31
					_ = v32
					// let binding "initk"
					tmp33 := checkDerefVar(var_glojure_DOT_core_get)
					tmp34 := lang.Apply(tmp33, []any{v20, kw_initk, nil})
					var v35 any = tmp34
					_ = v35
					tmp36 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp37 := lang.NewVector(nil)
					tmp38 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7743), kw_column, int(9), kw_end_DASH_line, int(7743), kw_end_DASH_column, int(11))
					tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp40 lang.FnFunc
					{ // function next
						var v41 lang.FnFunc
						tmp40 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v42 := args[0]
							_ = v42
							var tmp43 any
							tmp44 := lang.Apply(v24, []any{v42})
							if lang.IsTruthy(tmp44) {
								tmp45 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp46 := lang.Apply(v28, []any{v42})
								var tmp47 any
								{ // let
									// let binding "temp__0__auto__"
									tmp48 := lang.Apply(v32, []any{v42})
									var v49 any = tmp48
									_ = v49
									var tmp50 any
									tmp51 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
									tmp52 := lang.Apply(tmp51, []any{v49})
									if lang.IsTruthy(tmp52) {
									} else {
										var tmp53 any
										{ // let
											// let binding "k"
											var v54 any = v49
											_ = v54
											var tmp55 lang.FnFunc
											tmp55 = lang.NewFnFunc(func(args ...any) any {
												checkArity(args, 0)
												tmp56 := lang.Apply(v2, []any{v54})
												tmp57 := lang.Apply(v41, []any{tmp56})
												return tmp57
											})
											tmp56 := lang.Apply(lang.NewLazySeq, []any{tmp55})
											tmp53 = tmp56
										} // end let
										tmp50 = tmp53
									}
									tmp47 = tmp50
								} // end let
								tmp48 := lang.Apply(tmp45, []any{tmp46, tmp47})
								tmp43 = tmp48
							} else {
							}
							return tmp43
						})
						v41 = tmp40
						_ = v41
					}
					tmp41 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7744), kw_column, int(10), kw_end_DASH_line, int(7748), kw_end_DASH_column, int(51))
					tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp43 := lang.Apply(v2, []any{v35})
					tmp44 := lang.Apply(tmp42, []any{tmp43})
					tmp45 := lang.Apply(tmp36, []any{tmp39, tmp44})
					tmp46 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
					tmp47 := checkDerefVar(var_glojure_DOT_core_reduce)
					tmp48 := lang.NewVector(nil, nil, nil)
					tmp49 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7751), kw_column, int(12), kw_end_DASH_line, int(7751), kw_end_DASH_column, int(22))
					tmp50, err := lang.WithMeta(tmp48, tmp49.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp51 any
					{ // let
						// let binding "acc"
						var v52 any = nil
						_ = v52
						// let binding "ret"
						tmp53 := lang.Apply(v2, []any{v35})
						var v54 any = tmp53
						_ = v54
						for {
							var tmp55 any
							tmp56 := lang.Apply(v24, []any{v54})
							if lang.IsTruthy(tmp56) {
								var tmp57 any
								{ // let
									// let binding "acc"
									tmp58 := lang.Apply(v28, []any{v54})
									tmp59 := lang.Apply(nil, []any{v52, tmp58})
									var v60 any = tmp59
									_ = v60
									var tmp61 any
									tmp62 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
									tmp63 := lang.Apply(tmp62, []any{v60})
									if lang.IsTruthy(tmp63) {
										tmp64 := checkDerefVar(var_glojure_DOT_core_deref)
										tmp65 := lang.Apply(tmp64, []any{v60})
										tmp61 = tmp65
									} else {
										var tmp66 any
										{ // let
											// let binding "temp__0__auto__"
											tmp67 := lang.Apply(v32, []any{v54})
											var v68 any = tmp67
											_ = v68
											var tmp69 any
											tmp70 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
											tmp71 := lang.Apply(tmp70, []any{v68})
											if lang.IsTruthy(tmp71) {
												tmp69 = v60
											} else {
												var tmp72 any
												{ // let
													// let binding "k"
													var v73 any = v68
													_ = v73
													var tmp74 any = v60
													tmp76 := lang.Apply(v2, []any{v73})
													var tmp75 any = tmp76
													v52 = tmp74
													v54 = tmp75
													continue
												} // end let
												tmp69 = tmp72
											}
											tmp66 = tmp69
										} // end let
										tmp61 = tmp66
									}
									tmp57 = tmp61
								} // end let
								tmp55 = tmp57
							} else {
								tmp55 = v52
							}
							tmp51 = tmp55
							break
						}
					} // end let
					tmp52 := lang.Apply(tmp47, []any{tmp50, tmp51})
					tmp53 := lang.Apply(nil, []any{nil, tmp45, tmp46, tmp52})
					tmp4 = tmp53
				} // end let
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_iteration = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_iteration.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load
	{
		tmp0 := sym_load.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_paths)), kw_doc, "Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_redef, true, kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6095), kw_end_DASH_line, int(6095))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				var tmp3 any
				{ // let
					// let binding "seq_133"
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := lang.Apply(tmp4, []any{v2})
					var v6 any = tmp5
					_ = v6
					// let binding "chunk_134"
					var v7 any = nil
					_ = v7
					// let binding "count_135"
					var v8 any = int64(0)
					_ = v8
					// let binding "i_136"
					var v9 any = int64(0)
					_ = v9
					for {
						var tmp10 any
						tmp11 := checkDerefVar(var_glojure_DOT_core__LT_)
						tmp12 := lang.Apply(tmp11, []any{v9, v8})
						if lang.IsTruthy(tmp12) {
							var tmp13 any
							{ // let
								// let binding "path"
								tmp14, _ := lang.FieldOrMethod(v7, "nth")
								if reflect.TypeOf(tmp14).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
								}
								tmp15 := lang.Apply(tmp14, []any{v9})
								var v16 any = tmp15
								_ = v16
								var tmp17 any
								{ // let
									// let binding "path"
									var tmp18 any
									tmp19 := lang.Apply(strings11.HasPrefix, []any{v16, "/"})
									if lang.IsTruthy(tmp19) {
										tmp18 = v16
									} else {
										tmp20 := checkDerefVar(var_glojure_DOT_core_str)
										tmp21 := checkDerefVar(var_glojure_DOT_core_root_DASH_directory)
										tmp22 := checkDerefVar(var_glojure_DOT_core_ns_DASH_name)
										tmp23 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
										tmp24 := lang.Apply(tmp22, []any{tmp23})
										tmp25 := lang.Apply(tmp21, []any{tmp24})
										tmp26 := lang.Apply(tmp20, []any{tmp25, lang.NewChar(47), v16})
										tmp18 = tmp26
									}
									var v27 any = tmp18
									_ = v27
									var tmp28 any
									tmp29 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
									if lang.IsTruthy(tmp29) {
										tmp30 := checkDerefVar(var_glojure_DOT_core_printf)
										tmp31 := lang.Apply(tmp30, []any{"(glojure.core/load \"%s\")\n", v27})
										_ = tmp31
										tmp32 := checkDerefVar(var_glojure_DOT_core_flush)
										tmp33 := lang.Apply(tmp32, nil)
										tmp28 = tmp33
									} else {
									}
									_ = tmp28
									tmp34 := checkDerefVar(var_glojure_DOT_core_check_DASH_cyclic_DASH_dependency)
									tmp35 := lang.Apply(tmp34, []any{v27})
									_ = tmp35
									var tmp36 any
									tmp37 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp38 := checkDerefVar(var_glojure_DOT_core_first)
									tmp39 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
									tmp40 := lang.Apply(tmp38, []any{tmp39})
									tmp41 := lang.Apply(tmp37, []any{v27, tmp40})
									if lang.IsTruthy(tmp41) {
									} else {
										var tmp42 any
										{ // let
											tmp43 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
											tmp44 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
											tmp45 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_pending_DASH_paths_STAR_)
											tmp46 := checkDerefVar(var_glojure_DOT_core_conj)
											tmp47 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
											tmp48 := lang.Apply(tmp46, []any{tmp47, v27})
											tmp49 := lang.Apply(tmp44, []any{tmp45, tmp48})
											tmp50 := lang.Apply(tmp43, []any{tmp49})
											_ = tmp50
											var tmp51 any
											func() {
												defer func() {
													tmp52 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
													tmp53 := lang.Apply(tmp52, nil)
													_ = tmp53
												}()
												tmp54 := lang.Apply(strings11.TrimPrefix, []any{v27, "/"})
												tmp55, _ := lang.FieldOrMethod(runtime.RT, "Load")
												if reflect.TypeOf(tmp55).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("Load is not a function")))
												}
												tmp56 := lang.Apply(tmp55, []any{tmp54})
												tmp51 = tmp56
											}()
											tmp42 = tmp51
										} // end let
										tmp36 = tmp42
									}
									tmp17 = tmp36
								} // end let
								_ = tmp17
								var tmp18 any = v6
								var tmp19 any = v7
								var tmp20 any = v8
								tmp22 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
								tmp23 := lang.Apply(tmp22, []any{v9})
								var tmp21 any = tmp23
								v6 = tmp18
								v7 = tmp19
								v8 = tmp20
								v9 = tmp21
								continue
							} // end let
							tmp10 = tmp13
						} else {
							var tmp14 any
							{ // let
								// let binding "temp__0__auto__"
								tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp16 := lang.Apply(tmp15, []any{v6})
								var v17 any = tmp16
								_ = v17
								var tmp18 any
								if lang.IsTruthy(v17) {
									var tmp19 any
									{ // let
										// let binding "seq_133"
										var v20 any = v17
										_ = v20
										var tmp21 any
										tmp22 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
										tmp23 := lang.Apply(tmp22, []any{v20})
										if lang.IsTruthy(tmp23) {
											var tmp24 any
											{ // let
												// let binding "c__0__auto__"
												tmp25 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
												tmp26 := lang.Apply(tmp25, []any{v20})
												var v27 any = tmp26
												_ = v27
												tmp29 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
												tmp30 := lang.Apply(tmp29, []any{v20})
												var tmp28 any = tmp30
												var tmp31 any = v27
												tmp33 := checkDerefVar(var_glojure_DOT_core_int)
												tmp34 := checkDerefVar(var_glojure_DOT_core_count)
												tmp35 := lang.Apply(tmp34, []any{v27})
												tmp36 := lang.Apply(tmp33, []any{tmp35})
												var tmp32 any = tmp36
												tmp38 := checkDerefVar(var_glojure_DOT_core_int)
												tmp39 := lang.Apply(tmp38, []any{int64(0)})
												var tmp37 any = tmp39
												v6 = tmp28
												v7 = tmp31
												v8 = tmp32
												v9 = tmp37
												continue
											} // end let
											tmp21 = tmp24
										} else {
											var tmp25 any
											{ // let
												// let binding "path"
												tmp26 := checkDerefVar(var_glojure_DOT_core_first)
												tmp27 := lang.Apply(tmp26, []any{v20})
												var v28 any = tmp27
												_ = v28
												var tmp29 any
												{ // let
													// let binding "path"
													var tmp30 any
													tmp31 := lang.Apply(strings11.HasPrefix, []any{v28, "/"})
													if lang.IsTruthy(tmp31) {
														tmp30 = v28
													} else {
														tmp32 := checkDerefVar(var_glojure_DOT_core_str)
														tmp33 := checkDerefVar(var_glojure_DOT_core_root_DASH_directory)
														tmp34 := checkDerefVar(var_glojure_DOT_core_ns_DASH_name)
														tmp35 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
														tmp36 := lang.Apply(tmp34, []any{tmp35})
														tmp37 := lang.Apply(tmp33, []any{tmp36})
														tmp38 := lang.Apply(tmp32, []any{tmp37, lang.NewChar(47), v28})
														tmp30 = tmp38
													}
													var v39 any = tmp30
													_ = v39
													var tmp40 any
													tmp41 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
													if lang.IsTruthy(tmp41) {
														tmp42 := checkDerefVar(var_glojure_DOT_core_printf)
														tmp43 := lang.Apply(tmp42, []any{"(glojure.core/load \"%s\")\n", v39})
														_ = tmp43
														tmp44 := checkDerefVar(var_glojure_DOT_core_flush)
														tmp45 := lang.Apply(tmp44, nil)
														tmp40 = tmp45
													} else {
													}
													_ = tmp40
													tmp46 := checkDerefVar(var_glojure_DOT_core_check_DASH_cyclic_DASH_dependency)
													tmp47 := lang.Apply(tmp46, []any{v39})
													_ = tmp47
													var tmp48 any
													tmp49 := checkDerefVar(var_glojure_DOT_core__EQ_)
													tmp50 := checkDerefVar(var_glojure_DOT_core_first)
													tmp51 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
													tmp52 := lang.Apply(tmp50, []any{tmp51})
													tmp53 := lang.Apply(tmp49, []any{v39, tmp52})
													if lang.IsTruthy(tmp53) {
													} else {
														var tmp54 any
														{ // let
															tmp55 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
															tmp56 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
															tmp57 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_pending_DASH_paths_STAR_)
															tmp58 := checkDerefVar(var_glojure_DOT_core_conj)
															tmp59 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
															tmp60 := lang.Apply(tmp58, []any{tmp59, v39})
															tmp61 := lang.Apply(tmp56, []any{tmp57, tmp60})
															tmp62 := lang.Apply(tmp55, []any{tmp61})
															_ = tmp62
															var tmp63 any
															func() {
																defer func() {
																	tmp64 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
																	tmp65 := lang.Apply(tmp64, nil)
																	_ = tmp65
																}()
																tmp66 := lang.Apply(strings11.TrimPrefix, []any{v39, "/"})
																tmp67, _ := lang.FieldOrMethod(runtime.RT, "Load")
																if reflect.TypeOf(tmp67).Kind() != reflect.Func {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("Load is not a function")))
																}
																tmp68 := lang.Apply(tmp67, []any{tmp66})
																tmp63 = tmp68
															}()
															tmp54 = tmp63
														} // end let
														tmp48 = tmp54
													}
													tmp29 = tmp48
												} // end let
												_ = tmp29
												tmp31 := checkDerefVar(var_glojure_DOT_core_next)
												tmp32 := lang.Apply(tmp31, []any{v20})
												var tmp30 any = tmp32
												var tmp33 any = nil
												var tmp34 any = int64(0)
												var tmp35 any = int64(0)
												v6 = tmp30
												v7 = tmp33
												v8 = tmp34
												v9 = tmp35
												continue
											} // end let
											tmp21 = tmp25
										}
										tmp19 = tmp21
									} // end let
									tmp18 = tmp19
								} else {
								}
								tmp14 = tmp18
							} // end let
							tmp10 = tmp14
						}
						tmp3 = tmp10
						break
					}
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_load = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_load.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-one
	{
		tmp0 := sym_load_DASH_one.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_lib, sym_need_DASH_ns, sym_require)), kw_doc, "Loads a lib given its name. If need-ns, ensures that the associated\n  namespace exists after loading. If require, records the load so any\n  duplicate loads can be skipped.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(5879), kw_end_DASH_line, int(5879), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_load)
			tmp6 := checkDerefVar(var_glojure_DOT_core_root_DASH_resource)
			tmp7 := lang.Apply(tmp6, []any{v2})
			tmp8 := lang.Apply(tmp5, []any{tmp7})
			_ = tmp8
			tmp9 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
			var tmp10 any
			{ // let
				// let binding "and__0__auto__"
				var v11 any = v3
				_ = v11
				var tmp12 any
				if lang.IsTruthy(v11) {
					tmp13 := checkDerefVar(var_glojure_DOT_core_not)
					tmp14 := checkDerefVar(var_glojure_DOT_core_find_DASH_ns)
					tmp15 := lang.Apply(tmp14, []any{v2})
					tmp16 := lang.Apply(tmp13, []any{tmp15})
					tmp12 = tmp16
				} else {
					tmp12 = v11
				}
				tmp10 = tmp12
			} // end let
			tmp11 := checkDerefVar(var_glojure_DOT_core_root_DASH_resource)
			tmp12 := lang.Apply(tmp11, []any{v2})
			tmp13 := lang.Apply(tmp9, []any{tmp10, "namespace '%s' not found after loading '%s'", v2, tmp12})
			_ = tmp13
			var tmp14 any
			if lang.IsTruthy(v4) {
				var tmp15 lang.FnFunc
				tmp15 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					tmp16 := checkDerefVar(var_glojure_DOT_core_commute)
					tmp17 := checkDerefVar(var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_)
					tmp18 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp19 := lang.Apply(tmp16, []any{tmp17, tmp18, v2})
					return tmp19
				})
				tmp16, _ := lang.FieldOrMethod(lang.LockingTransaction, "RunInTransaction")
				if reflect.TypeOf(tmp16).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("RunInTransaction is not a function")))
				}
				tmp17 := lang.Apply(tmp16, []any{tmp15})
				tmp14 = tmp17
			} else {
			}
			return tmp14
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_load_DASH_one = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_load_DASH_one.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-all
	{
		tmp0 := sym_load_DASH_all.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_lib, sym_need_DASH_ns, sym_require)), kw_doc, "Loads a lib given its name and forces a load of any libs it directly or\n  indirectly loads. If need-ns, ensures that the associated namespace\n  exists after loading. If require, records the load so any duplicate loads\n  can be skipped.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(5892), kw_end_DASH_line, int(5892), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 lang.FnFunc
			tmp5 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 0)
				tmp6 := checkDerefVar(var_glojure_DOT_core_commute)
				tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_)
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v9 := args[0]
					_ = v9
					v10 := args[1]
					_ = v10
					tmp11 := checkDerefVar(var_glojure_DOT_core_reduce1)
					tmp12 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp13 := lang.Apply(tmp11, []any{tmp12, v9, v10})
					return tmp13
				})
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5899), kw_column, int(27), kw_end_DASH_line, int(5899), kw_end_DASH_column, int(47))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp11 any
				{ // let
					tmp12 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
					tmp13 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp14 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_loaded_DASH_libs_STAR_)
					tmp15 := checkDerefVar(var_glojure_DOT_core_ref)
					tmp16 := checkDerefVar(var_glojure_DOT_core_sorted_DASH_set)
					tmp17 := lang.Apply(tmp16, nil)
					tmp18 := lang.Apply(tmp15, []any{tmp17})
					tmp19 := lang.Apply(tmp13, []any{tmp14, tmp18})
					tmp20 := lang.Apply(tmp12, []any{tmp19})
					_ = tmp20
					var tmp21 any
					func() {
						defer func() {
							tmp22 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
							tmp23 := lang.Apply(tmp22, nil)
							_ = tmp23
						}()
						tmp24 := checkDerefVar(var_glojure_DOT_core_load_DASH_one)
						tmp25 := lang.Apply(tmp24, []any{v2, v3, v4})
						_ = tmp25
						tmp26 := checkDerefVar(var_glojure_DOT_core_deref)
						tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_)
						tmp28 := lang.Apply(tmp26, []any{tmp27})
						tmp21 = tmp28
					}()
					tmp11 = tmp21
				} // end let
				tmp12 := lang.Apply(tmp6, []any{tmp7, tmp10, tmp11})
				return tmp12
			})
			tmp6, _ := lang.FieldOrMethod(lang.LockingTransaction, "RunInTransaction")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("RunInTransaction is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{tmp5})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_load_DASH_all = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_load_DASH_all.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-data-reader-file
	{
		tmp0 := sym_load_DASH_data_DASH_reader_DASH_file.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7836), kw_column, int(8), kw_end_DASH_line, int(7836), kw_end_DASH_column, int(28), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_mappings, sym_url)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "rdr"
				tmp5, ok := lang.FieldOrMethod(v3, "openStream")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "openStream")))
				}
				var tmp6 any
				switch reflect.TypeOf(tmp5).Kind() {
				case reflect.Func:
					tmp6 = lang.Apply(tmp5, nil)
				default:
					tmp6 = tmp5
				}
				tmp7 := lang.Apply(nil, []any{tmp6, "UTF-8"})
				tmp8 := lang.Apply(nil, []any{tmp7})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				func() {
					defer func() {
						tmp11, ok := lang.FieldOrMethod(v9, "close")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "close")))
						}
						var tmp12 any
						switch reflect.TypeOf(tmp11).Kind() {
						case reflect.Func:
							tmp12 = lang.Apply(tmp11, nil)
						default:
							tmp12 = tmp11
						}
						_ = tmp12
					}()
					var tmp13 any
					{ // let
						tmp14 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp15 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp16 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_file_STAR_)
						tmp17, ok := lang.FieldOrMethod(v3, "getFile")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getFile")))
						}
						var tmp18 any
						switch reflect.TypeOf(tmp17).Kind() {
						case reflect.Func:
							tmp18 = lang.Apply(tmp17, nil)
						default:
							tmp18 = tmp17
						}
						tmp19 := lang.Apply(tmp15, []any{tmp16, tmp18})
						tmp20 := lang.Apply(tmp14, []any{tmp19})
						_ = tmp20
						var tmp21 any
						func() {
							defer func() {
								tmp22 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp23 := lang.Apply(tmp22, nil)
								_ = tmp23
							}()
							var tmp24 any
							{ // let
								// let binding "read-opts"
								var tmp25 any
								tmp26, ok := lang.FieldOrMethod(v3, "getPath")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getPath")))
								}
								var tmp27 any
								switch reflect.TypeOf(tmp26).Kind() {
								case reflect.Func:
									tmp27 = lang.Apply(tmp26, nil)
								default:
									tmp27 = tmp26
								}
								tmp28, _ := lang.FieldOrMethod(tmp27, "endsWith")
								if reflect.TypeOf(tmp28).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("endsWith is not a function")))
								}
								tmp29 := lang.Apply(tmp28, []any{"cljc"})
								if lang.IsTruthy(tmp29) {
									tmp30 := lang.NewMap(kw_eof, nil, kw_read_DASH_cond, kw_allow)
									tmp31 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7842), kw_column, int(25), kw_end_DASH_line, int(7842), kw_end_DASH_column, int(52))
									tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp25 = tmp32
								} else {
									tmp33 := lang.NewMap(kw_eof, nil)
									tmp34 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7843), kw_column, int(25), kw_end_DASH_line, int(7843), kw_end_DASH_column, int(34))
									tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp25 = tmp35
								}
								var v36 any = tmp25
								_ = v36
								// let binding "new-mappings"
								tmp37 := checkDerefVar(var_glojure_DOT_core_read)
								tmp38 := lang.Apply(tmp37, []any{v36, v9})
								var v39 any = tmp38
								_ = v39
								var tmp40 any
								tmp41 := checkDerefVar(var_glojure_DOT_core_not)
								tmp42 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
								tmp43 := lang.Apply(tmp42, []any{v39})
								tmp44 := lang.Apply(tmp41, []any{tmp43})
								if lang.IsTruthy(tmp44) {
									tmp45 := checkDerefVar(var_glojure_DOT_core_ex_DASH_info)
									tmp46 := checkDerefVar(var_glojure_DOT_core_str)
									tmp47 := lang.Apply(tmp46, []any{"Not a valid data-reader map"})
									tmp48 := lang.NewMap(kw_url, v3)
									tmp49 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7847), kw_column, int(27), kw_end_DASH_line, int(7847), kw_end_DASH_column, int(36))
									tmp50, err := lang.WithMeta(tmp48, tmp49.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp51 := lang.Apply(tmp45, []any{tmp47, tmp50})
									panic(tmp51)
								} else {
								}
								_ = tmp40
								tmp52 := checkDerefVar(var_glojure_DOT_core_reduce)
								var tmp53 lang.FnFunc
								tmp53 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 2)
									v54 := args[0]
									_ = v54
									v55 := args[1]
									_ = v55
									var tmp56 any
									{ // let
										// let binding "vec__359"
										var v57 any = v55
										_ = v57
										// let binding "k"
										tmp58 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp59 := lang.Apply(tmp58, []any{v57, int64(0), nil})
										var v60 any = tmp59
										_ = v60
										// let binding "v"
										tmp61 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp62 := lang.Apply(tmp61, []any{v57, int64(1), nil})
										var v63 any = tmp62
										_ = v63
										var tmp64 any
										tmp65 := checkDerefVar(var_glojure_DOT_core_not)
										tmp66 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
										tmp67 := lang.Apply(tmp66, []any{v60})
										tmp68 := lang.Apply(tmp65, []any{tmp67})
										if lang.IsTruthy(tmp68) {
											tmp69 := checkDerefVar(var_glojure_DOT_core_ex_DASH_info)
											tmp70 := checkDerefVar(var_glojure_DOT_core_str)
											tmp71 := lang.Apply(tmp70, []any{"Invalid form in data-reader file"})
											tmp72 := lang.NewMap(kw_url, v3, kw_form, v60)
											tmp73 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7852), kw_column, int(30), kw_end_DASH_line, int(7853), kw_end_DASH_column, int(38))
											tmp74, err := lang.WithMeta(tmp72, tmp73.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp75 := lang.Apply(tmp69, []any{tmp71, tmp74})
											panic(tmp75)
										} else {
										}
										_ = tmp64
										var tmp76 any
										{ // let
											// let binding "v-var"
											tmp77 := checkDerefVar(var_glojure_DOT_core_data_DASH_reader_DASH_var)
											tmp78 := lang.Apply(tmp77, []any{v63})
											var v79 any = tmp78
											_ = v79
											var tmp80 any
											var tmp81 any
											{ // let
												// let binding "and__0__auto__"
												tmp82 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
												tmp83 := lang.Apply(tmp82, []any{v2, v60})
												var v84 any = tmp83
												_ = v84
												var tmp85 any
												if lang.IsTruthy(v84) {
													tmp86 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
													tmp87 := lang.Apply(v2, []any{v60})
													tmp88 := lang.Apply(tmp86, []any{tmp87, v79})
													tmp85 = tmp88
												} else {
													tmp85 = v84
												}
												tmp81 = tmp85
											} // end let
											if lang.IsTruthy(tmp81) {
												tmp82 := checkDerefVar(var_glojure_DOT_core_ex_DASH_info)
												tmp83 := lang.NewMap(kw_url, v3, kw_conflict, v60, kw_mappings, v54)
												tmp84 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7858), kw_column, int(32), kw_end_DASH_line, int(7860), kw_end_DASH_column, int(44))
												tmp85, err := lang.WithMeta(tmp83, tmp84.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp86 := lang.Apply(tmp82, []any{"Conflicting data-reader mapping", tmp85})
												panic(tmp86)
											} else {
											}
											_ = tmp80
											tmp87 := checkDerefVar(var_glojure_DOT_core_assoc)
											tmp88 := lang.Apply(tmp87, []any{v54, v60, v79})
											tmp76 = tmp88
										} // end let
										tmp56 = tmp76
									} // end let
									return tmp56
								})
								tmp54 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7849), kw_column, int(10), kw_end_DASH_line, int(7861), kw_end_DASH_column, int(32))
								tmp55, err := lang.WithMeta(tmp53, tmp54.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp56 := lang.Apply(tmp52, []any{tmp55, v2, v39})
								tmp24 = tmp56
							} // end let
							tmp21 = tmp24
						}()
						tmp13 = tmp21
					} // end let
					tmp10 = tmp13
				}()
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_load_DASH_data_DASH_reader_DASH_file = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_load_DASH_data_DASH_reader_DASH_file.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-data-readers
	{
		tmp0 := sym_load_DASH_data_DASH_readers.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7865), kw_column, int(8), kw_end_DASH_line, int(7865), kw_end_DASH_column, int(24), kw_private, true, kw_arglists, lang.NewList(lang.NewVector()), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_glojure_DOT_core_alter_DASH_var_DASH_root)
			tmp3 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_data_DASH_readers_STAR_)
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v5 := args[0]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_reduce)
				tmp7 := checkDerefVar(var_glojure_DOT_core_load_DASH_data_DASH_reader_DASH_file)
				tmp8 := checkDerefVar(var_glojure_DOT_core_data_DASH_reader_DASH_urls)
				tmp9 := lang.Apply(tmp8, nil)
				tmp10 := lang.Apply(tmp6, []any{tmp7, v5, tmp9})
				return tmp10
			})
			tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7867), kw_column, int(19), kw_end_DASH_line, int(7869), kw_end_DASH_column, int(57))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp7 := lang.Apply(tmp2, []any{tmp3, tmp6})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_load_DASH_data_DASH_readers = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_load_DASH_data_DASH_readers.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-lib
	{
		tmp0 := sym_load_DASH_lib.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_prefix, sym_lib, sym__AMP_, sym_options)), kw_doc, "Loads a lib with options", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(5904), kw_end_DASH_line, int(5904), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
				var tmp6 any
				{ // let
					// let binding "and__0__auto__"
					var v7 any = v2
					_ = v7
					var tmp8 any
					if lang.IsTruthy(v7) {
						tmp9 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp10 := checkDerefVar(var_glojure_DOT_core_name)
						tmp11 := lang.Apply(tmp10, []any{v3})
						tmp12 := checkDerefVar(var_glojure_DOT_core_int)
						tmp13 := lang.Apply(tmp12, []any{lang.NewChar(46)})
						tmp14 := lang.Apply(strings11.Index, []any{tmp11, tmp13})
						tmp15 := lang.Apply(tmp9, []any{tmp14})
						tmp8 = tmp15
					} else {
						tmp8 = v7
					}
					tmp6 = tmp8
				} // end let
				tmp7 := checkDerefVar(var_glojure_DOT_core_name)
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp9 := lang.Apply(tmp5, []any{tmp6, "Found lib name '%s' containing period with prefix '%s'.  lib names inside prefix lists must not contain periods", tmp8, v2})
				_ = tmp9
				var tmp10 any
				{ // let
					// let binding "lib"
					var tmp11 any
					if lang.IsTruthy(v2) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_symbol)
						tmp13 := checkDerefVar(var_glojure_DOT_core_str)
						tmp14 := lang.Apply(tmp13, []any{v2, lang.NewChar(46), v3})
						tmp15 := lang.Apply(tmp12, []any{tmp14})
						tmp11 = tmp15
					} else {
						tmp11 = v3
					}
					var v16 any = tmp11
					_ = v16
					// let binding "opts"
					tmp17 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp18 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp19 := lang.Apply(tmp17, []any{tmp18, v4})
					var v20 any = tmp19
					_ = v20
					// let binding "map__110"
					var v21 any = v20
					_ = v21
					// let binding "map__110"
					var tmp22 any
					tmp23 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
					tmp24 := lang.Apply(tmp23, []any{v21})
					if lang.IsTruthy(tmp24) {
						var tmp25 any
						tmp26 := checkDerefVar(var_glojure_DOT_core_next)
						tmp27 := lang.Apply(tmp26, []any{v21})
						if lang.IsTruthy(tmp27) {
							tmp28 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
							tmp29 := lang.Apply(tmp28, []any{v21})
							tmp30 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp29})
							tmp25 = tmp30
						} else {
							var tmp31 any
							tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp33 := lang.Apply(tmp32, []any{v21})
							if lang.IsTruthy(tmp33) {
								tmp34 := checkDerefVar(var_glojure_DOT_core_first)
								tmp35 := lang.Apply(tmp34, []any{v21})
								tmp31 = tmp35
							} else {
							}
							tmp25 = tmp31
						}
						tmp22 = tmp25
					} else {
						tmp22 = v21
					}
					var v36 any = tmp22
					_ = v36
					// let binding "as"
					tmp37 := checkDerefVar(var_glojure_DOT_core_get)
					tmp38 := lang.Apply(tmp37, []any{v36, kw_as})
					var v39 any = tmp38
					_ = v39
					// let binding "reload"
					tmp40 := checkDerefVar(var_glojure_DOT_core_get)
					tmp41 := lang.Apply(tmp40, []any{v36, kw_reload})
					var v42 any = tmp41
					_ = v42
					// let binding "reload-all"
					tmp43 := checkDerefVar(var_glojure_DOT_core_get)
					tmp44 := lang.Apply(tmp43, []any{v36, kw_reload_DASH_all})
					var v45 any = tmp44
					_ = v45
					// let binding "require"
					tmp46 := checkDerefVar(var_glojure_DOT_core_get)
					tmp47 := lang.Apply(tmp46, []any{v36, kw_require})
					var v48 any = tmp47
					_ = v48
					// let binding "use"
					tmp49 := checkDerefVar(var_glojure_DOT_core_get)
					tmp50 := lang.Apply(tmp49, []any{v36, kw_use})
					var v51 any = tmp50
					_ = v51
					// let binding "verbose"
					tmp52 := checkDerefVar(var_glojure_DOT_core_get)
					tmp53 := lang.Apply(tmp52, []any{v36, kw_verbose})
					var v54 any = tmp53
					_ = v54
					// let binding "as-alias"
					tmp55 := checkDerefVar(var_glojure_DOT_core_get)
					tmp56 := lang.Apply(tmp55, []any{v36, kw_as_DASH_alias})
					var v57 any = tmp56
					_ = v57
					// let binding "loaded"
					tmp58 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
					tmp59 := checkDerefVar(var_glojure_DOT_core_deref)
					tmp60 := checkDerefVar(var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_)
					tmp61 := lang.Apply(tmp59, []any{tmp60})
					tmp62 := lang.Apply(tmp58, []any{tmp61, v16})
					var v63 any = tmp62
					_ = v63
					// let binding "need-ns"
					var tmp64 any
					{ // let
						// let binding "or__0__auto__"
						var v65 any = v39
						_ = v65
						var tmp66 any
						if lang.IsTruthy(v65) {
							tmp66 = v65
						} else {
							tmp66 = v51
						}
						tmp64 = tmp66
					} // end let
					var v65 any = tmp64
					_ = v65
					// let binding "load"
					var tmp66 any
					if lang.IsTruthy(v45) {
						tmp67 := checkDerefVar(var_glojure_DOT_core_load_DASH_all)
						tmp66 = tmp67
					} else {
						var tmp68 any
						if lang.IsTruthy(v42) {
							tmp69 := checkDerefVar(var_glojure_DOT_core_load_DASH_one)
							tmp68 = tmp69
						} else {
							var tmp70 any
							tmp71 := checkDerefVar(var_glojure_DOT_core_not)
							tmp72 := lang.Apply(tmp71, []any{v63})
							if lang.IsTruthy(tmp72) {
								var tmp73 any
								if lang.IsTruthy(v65) {
									tmp74 := checkDerefVar(var_glojure_DOT_core_load_DASH_one)
									tmp73 = tmp74
								} else {
									var tmp75 any
									if lang.IsTruthy(v57) {
										var tmp76 lang.FnFunc
										tmp76 = lang.NewFnFunc(func(args ...any) any {
											checkArity(args, 3)
											v77 := args[0]
											_ = v77
											v78 := args[1]
											_ = v78
											v79 := args[2]
											_ = v79
											tmp80 := checkDerefVar(var_glojure_DOT_core_create_DASH_ns)
											tmp81 := lang.Apply(tmp80, []any{v77})
											return tmp81
										})
										tmp77 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5918), kw_column, int(48), kw_end_DASH_line, int(5918), kw_end_DASH_column, int(88))
										tmp78, err := lang.WithMeta(tmp76, tmp77.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp75 = tmp78
									} else {
										var tmp79 any
										if lang.IsTruthy(kw_else) {
											tmp80 := checkDerefVar(var_glojure_DOT_core_load_DASH_one)
											tmp79 = tmp80
										} else {
										}
										tmp75 = tmp79
									}
									tmp73 = tmp75
								}
								tmp70 = tmp73
							} else {
							}
							tmp68 = tmp70
						}
						tmp66 = tmp68
					}
					var v81 any = tmp66
					_ = v81
					// let binding "filter-opts"
					tmp82 := checkDerefVar(var_glojure_DOT_core_select_DASH_keys)
					tmp83 := lang.Apply(tmp82, []any{v20, lang.NewList(kw_exclude, kw_only, kw_rename, kw_refer)})
					var v84 any = tmp83
					_ = v84
					// let binding "undefined-on-entry"
					tmp85 := checkDerefVar(var_glojure_DOT_core_not)
					tmp86 := checkDerefVar(var_glojure_DOT_core_find_DASH_ns)
					tmp87 := lang.Apply(tmp86, []any{v16})
					tmp88 := lang.Apply(tmp85, []any{tmp87})
					var v89 any = tmp88
					_ = v89
					var tmp90 any
					{ // let
						tmp91 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp92 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp93 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_loading_DASH_verbosely_STAR_)
						var tmp94 any
						{ // let
							// let binding "or__0__auto__"
							tmp95 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
							var v96 any = tmp95
							_ = v96
							var tmp97 any
							if lang.IsTruthy(v96) {
								tmp97 = v96
							} else {
								tmp97 = v54
							}
							tmp94 = tmp97
						} // end let
						tmp95 := lang.Apply(tmp92, []any{tmp93, tmp94})
						tmp96 := lang.Apply(tmp91, []any{tmp95})
						_ = tmp96
						var tmp97 any
						func() {
							defer func() {
								tmp98 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp99 := lang.Apply(tmp98, nil)
								_ = tmp99
							}()
							var tmp100 any
							if lang.IsTruthy(v81) {
								var tmp101 any
								func() {
									defer func() {
										if r := recover(); r != nil {
											if lang.CatchMatches(r, lang.Builtins["any"]) {
												v102 := r
												_ = v102
												var tmp103 any
												if lang.IsTruthy(v89) {
													tmp104 := checkDerefVar(var_glojure_DOT_core_remove_DASH_ns)
													tmp105 := lang.Apply(tmp104, []any{v16})
													tmp103 = tmp105
												} else {
												}
												_ = tmp103
												panic(v102)
											} else {
												panic(r)
											}
										}
									}()
									tmp102 := lang.Apply(v81, []any{v16, v65, v48})
									tmp101 = tmp102
								}()
								tmp100 = tmp101
							} else {
								tmp103 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
								var tmp104 any
								{ // let
									// let binding "and__0__auto__"
									var v105 any = v65
									_ = v105
									var tmp106 any
									if lang.IsTruthy(v105) {
										tmp107 := checkDerefVar(var_glojure_DOT_core_not)
										tmp108 := checkDerefVar(var_glojure_DOT_core_find_DASH_ns)
										tmp109 := lang.Apply(tmp108, []any{v16})
										tmp110 := lang.Apply(tmp107, []any{tmp109})
										tmp106 = tmp110
									} else {
										tmp106 = v105
									}
									tmp104 = tmp106
								} // end let
								tmp105 := lang.Apply(tmp103, []any{tmp104, "namespace '%s' not found", v16})
								tmp100 = tmp105
							}
							_ = tmp100
							var tmp106 any
							var tmp107 any
							{ // let
								// let binding "and__0__auto__"
								var v108 any = v65
								_ = v108
								var tmp109 any
								if lang.IsTruthy(v108) {
									tmp110 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
									tmp109 = tmp110
								} else {
									tmp109 = v108
								}
								tmp107 = tmp109
							} // end let
							if lang.IsTruthy(tmp107) {
								tmp108 := checkDerefVar(var_glojure_DOT_core_printf)
								tmp109 := checkDerefVar(var_glojure_DOT_core_ns_DASH_name)
								tmp110 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
								tmp111 := lang.Apply(tmp109, []any{tmp110})
								tmp112 := lang.Apply(tmp108, []any{"(glojure.core/in-ns '%s)\n", tmp111})
								tmp106 = tmp112
							} else {
							}
							_ = tmp106
							var tmp113 any
							if lang.IsTruthy(v39) {
								var tmp114 any
								tmp115 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
								if lang.IsTruthy(tmp115) {
									tmp116 := checkDerefVar(var_glojure_DOT_core_printf)
									tmp117 := lang.Apply(tmp116, []any{"(glojure.core/alias '%s '%s)\n", v39, v16})
									tmp114 = tmp117
								} else {
								}
								_ = tmp114
								tmp118 := checkDerefVar(var_glojure_DOT_core_alias)
								tmp119 := lang.Apply(tmp118, []any{v39, v16})
								tmp113 = tmp119
							} else {
							}
							_ = tmp113
							var tmp120 any
							if lang.IsTruthy(v57) {
								var tmp121 any
								tmp122 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
								if lang.IsTruthy(tmp122) {
									tmp123 := checkDerefVar(var_glojure_DOT_core_printf)
									tmp124 := lang.Apply(tmp123, []any{"(glojure.core/alias '%s '%s)\n", v57, v16})
									tmp121 = tmp124
								} else {
								}
								_ = tmp121
								tmp125 := checkDerefVar(var_glojure_DOT_core_alias)
								tmp126 := lang.Apply(tmp125, []any{v57, v16})
								tmp120 = tmp126
							} else {
							}
							_ = tmp120
							var tmp127 any
							var tmp128 any
							{ // let
								// let binding "or__0__auto__"
								var v129 any = v51
								_ = v129
								var tmp130 any
								if lang.IsTruthy(v129) {
									tmp130 = v129
								} else {
									tmp131 := lang.Apply(kw_refer, []any{v84})
									tmp130 = tmp131
								}
								tmp128 = tmp130
							} // end let
							if lang.IsTruthy(tmp128) {
								var tmp129 any
								tmp130 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
								if lang.IsTruthy(tmp130) {
									tmp131 := checkDerefVar(var_glojure_DOT_core_printf)
									tmp132 := lang.Apply(tmp131, []any{"(glojure.core/refer '%s", v16})
									_ = tmp132
									var tmp133 any
									{ // let
										// let binding "seq_111"
										tmp134 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp135 := lang.Apply(tmp134, []any{v84})
										var v136 any = tmp135
										_ = v136
										// let binding "chunk_112"
										var v137 any = nil
										_ = v137
										// let binding "count_113"
										var v138 any = int64(0)
										_ = v138
										// let binding "i_114"
										var v139 any = int64(0)
										_ = v139
										for {
											var tmp140 any
											tmp141 := checkDerefVar(var_glojure_DOT_core__LT_)
											tmp142 := lang.Apply(tmp141, []any{v139, v138})
											if lang.IsTruthy(tmp142) {
												var tmp143 any
												{ // let
													// let binding "opt"
													tmp144, _ := lang.FieldOrMethod(v137, "nth")
													if reflect.TypeOf(tmp144).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
													}
													tmp145 := lang.Apply(tmp144, []any{v139})
													var v146 any = tmp145
													_ = v146
													tmp147 := checkDerefVar(var_glojure_DOT_core_printf)
													tmp148 := checkDerefVar(var_glojure_DOT_core_key)
													tmp149 := lang.Apply(tmp148, []any{v146})
													tmp150 := checkDerefVar(var_glojure_DOT_core_print_DASH_str)
													tmp151 := checkDerefVar(var_glojure_DOT_core_val)
													tmp152 := lang.Apply(tmp151, []any{v146})
													tmp153 := lang.Apply(tmp150, []any{tmp152})
													tmp154 := lang.Apply(tmp147, []any{" %s '%s", tmp149, tmp153})
													_ = tmp154
													var tmp155 any = v136
													var tmp156 any = v137
													var tmp157 any = v138
													tmp159 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
													tmp160 := lang.Apply(tmp159, []any{v139})
													var tmp158 any = tmp160
													v136 = tmp155
													v137 = tmp156
													v138 = tmp157
													v139 = tmp158
													continue
												} // end let
												tmp140 = tmp143
											} else {
												var tmp144 any
												{ // let
													// let binding "temp__0__auto__"
													tmp145 := checkDerefVar(var_glojure_DOT_core_seq)
													tmp146 := lang.Apply(tmp145, []any{v136})
													var v147 any = tmp146
													_ = v147
													var tmp148 any
													if lang.IsTruthy(v147) {
														var tmp149 any
														{ // let
															// let binding "seq_111"
															var v150 any = v147
															_ = v150
															var tmp151 any
															tmp152 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
															tmp153 := lang.Apply(tmp152, []any{v150})
															if lang.IsTruthy(tmp153) {
																var tmp154 any
																{ // let
																	// let binding "c__0__auto__"
																	tmp155 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																	tmp156 := lang.Apply(tmp155, []any{v150})
																	var v157 any = tmp156
																	_ = v157
																	tmp159 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																	tmp160 := lang.Apply(tmp159, []any{v150})
																	var tmp158 any = tmp160
																	var tmp161 any = v157
																	tmp163 := checkDerefVar(var_glojure_DOT_core_int)
																	tmp164 := checkDerefVar(var_glojure_DOT_core_count)
																	tmp165 := lang.Apply(tmp164, []any{v157})
																	tmp166 := lang.Apply(tmp163, []any{tmp165})
																	var tmp162 any = tmp166
																	tmp168 := checkDerefVar(var_glojure_DOT_core_int)
																	tmp169 := lang.Apply(tmp168, []any{int64(0)})
																	var tmp167 any = tmp169
																	v136 = tmp158
																	v137 = tmp161
																	v138 = tmp162
																	v139 = tmp167
																	continue
																} // end let
																tmp151 = tmp154
															} else {
																var tmp155 any
																{ // let
																	// let binding "opt"
																	tmp156 := checkDerefVar(var_glojure_DOT_core_first)
																	tmp157 := lang.Apply(tmp156, []any{v150})
																	var v158 any = tmp157
																	_ = v158
																	tmp159 := checkDerefVar(var_glojure_DOT_core_printf)
																	tmp160 := checkDerefVar(var_glojure_DOT_core_key)
																	tmp161 := lang.Apply(tmp160, []any{v158})
																	tmp162 := checkDerefVar(var_glojure_DOT_core_print_DASH_str)
																	tmp163 := checkDerefVar(var_glojure_DOT_core_val)
																	tmp164 := lang.Apply(tmp163, []any{v158})
																	tmp165 := lang.Apply(tmp162, []any{tmp164})
																	tmp166 := lang.Apply(tmp159, []any{" %s '%s", tmp161, tmp165})
																	_ = tmp166
																	tmp168 := checkDerefVar(var_glojure_DOT_core_next)
																	tmp169 := lang.Apply(tmp168, []any{v150})
																	var tmp167 any = tmp169
																	var tmp170 any = nil
																	var tmp171 any = int64(0)
																	var tmp172 any = int64(0)
																	v136 = tmp167
																	v137 = tmp170
																	v138 = tmp171
																	v139 = tmp172
																	continue
																} // end let
																tmp151 = tmp155
															}
															tmp149 = tmp151
														} // end let
														tmp148 = tmp149
													} else {
													}
													tmp144 = tmp148
												} // end let
												tmp140 = tmp144
											}
											tmp133 = tmp140
											break
										}
									} // end let
									_ = tmp133
									tmp134 := checkDerefVar(var_glojure_DOT_core_printf)
									tmp135 := lang.Apply(tmp134, []any{")\n"})
									tmp129 = tmp135
								} else {
								}
								_ = tmp129
								tmp136 := checkDerefVar(var_glojure_DOT_core_apply)
								tmp137 := checkDerefVar(var_glojure_DOT_core_refer)
								tmp138 := checkDerefVar(var_glojure_DOT_core_mapcat)
								tmp139 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp140 := lang.Apply(tmp138, []any{tmp139, v84})
								tmp141 := lang.Apply(tmp136, []any{tmp137, v16, tmp140})
								tmp127 = tmp141
							} else {
							}
							tmp97 = tmp127
						}()
						tmp90 = tmp97
					} // end let
					tmp10 = tmp90
				} // end let
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_load_DASH_lib = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_load_DASH_lib.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-libs
	{
		tmp0 := sym_load_DASH_libs.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_args)), kw_doc, "Loads libs, interpreting libspecs, prefix lists, and flags for\n  forwarding to load-lib", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(8), kw_line, int(5951), kw_end_DASH_line, int(5951), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				var tmp3 any
				{ // let
					// let binding "flags"
					tmp4 := checkDerefVar(var_glojure_DOT_core_filter)
					tmp5 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
					tmp6 := lang.Apply(tmp4, []any{tmp5, v2})
					var v7 any = tmp6
					_ = v7
					// let binding "opts"
					tmp8 := checkDerefVar(var_glojure_DOT_core_interleave)
					tmp9 := checkDerefVar(var_glojure_DOT_core_repeat)
					tmp10 := lang.Apply(tmp9, []any{true})
					tmp11 := lang.Apply(tmp8, []any{v7, tmp10})
					var v12 any = tmp11
					_ = v12
					// let binding "args"
					tmp13 := checkDerefVar(var_glojure_DOT_core_filter)
					tmp14 := checkDerefVar(var_glojure_DOT_core_complement)
					tmp15 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
					tmp16 := lang.Apply(tmp14, []any{tmp15})
					tmp17 := lang.Apply(tmp13, []any{tmp16, v2})
					var v18 any = tmp17
					_ = v18
					var tmp19 any
					{ // let
						// let binding "supported"
						tmp20 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{kw_as, kw_reload, kw_reload_DASH_all, kw_require, kw_use, kw_verbose, kw_refer, kw_as_DASH_alias}))
						tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5959), kw_column, int(21), kw_end_DASH_line, int(5959), kw_end_DASH_column, int(86))
						tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v23 any = tmp22
						_ = v23
						// let binding "unsupported"
						tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp25 := checkDerefVar(var_glojure_DOT_core_remove)
						tmp26 := lang.Apply(tmp25, []any{v23, v7})
						tmp27 := lang.Apply(tmp24, []any{tmp26})
						var v28 any = tmp27
						_ = v28
						tmp29 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
						tmp30 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp31 := checkDerefVar(var_glojure_DOT_core_str)
						tmp32 := checkDerefVar(var_glojure_DOT_core_interpose)
						tmp33 := lang.Apply(tmp32, []any{lang.NewChar(44), v28})
						tmp34 := lang.Apply(tmp30, []any{tmp31, "Unsupported option(s) supplied: ", tmp33})
						tmp35 := lang.Apply(tmp29, []any{v28, tmp34})
						tmp19 = tmp35
					} // end let
					_ = tmp19
					tmp20 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
					tmp21 := checkDerefVar(var_glojure_DOT_core_not)
					tmp22 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp23 := lang.Apply(tmp22, []any{v18})
					tmp24 := lang.Apply(tmp21, []any{tmp23})
					tmp25 := lang.Apply(tmp20, []any{tmp24, "Nothing specified to load"})
					_ = tmp25
					var tmp26 any
					{ // let
						// let binding "seq_115"
						tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp28 := lang.Apply(tmp27, []any{v18})
						var v29 any = tmp28
						_ = v29
						// let binding "chunk_116"
						var v30 any = nil
						_ = v30
						// let binding "count_117"
						var v31 any = int64(0)
						_ = v31
						// let binding "i_118"
						var v32 any = int64(0)
						_ = v32
						for {
							var tmp33 any
							tmp34 := checkDerefVar(var_glojure_DOT_core__LT_)
							tmp35 := lang.Apply(tmp34, []any{v32, v31})
							if lang.IsTruthy(tmp35) {
								var tmp36 any
								{ // let
									// let binding "arg"
									tmp37, _ := lang.FieldOrMethod(v30, "nth")
									if reflect.TypeOf(tmp37).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp38 := lang.Apply(tmp37, []any{v32})
									var v39 any = tmp38
									_ = v39
									var tmp40 any
									tmp41 := checkDerefVar(var_glojure_DOT_core_libspec_QMARK_)
									tmp42 := lang.Apply(tmp41, []any{v39})
									if lang.IsTruthy(tmp42) {
										tmp43 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp44 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
										tmp45 := checkDerefVar(var_glojure_DOT_core_prependss)
										tmp46 := lang.Apply(tmp45, []any{v39, v12})
										tmp47 := lang.Apply(tmp43, []any{tmp44, nil, tmp46})
										tmp40 = tmp47
									} else {
										var tmp48 any
										{ // let
											// let binding "vec__119"
											var v49 any = v39
											_ = v49
											// let binding "seq__120"
											tmp50 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp51 := lang.Apply(tmp50, []any{v49})
											var v52 any = tmp51
											_ = v52
											// let binding "first__121"
											tmp53 := checkDerefVar(var_glojure_DOT_core_first)
											tmp54 := lang.Apply(tmp53, []any{v52})
											var v55 any = tmp54
											_ = v55
											// let binding "seq__120"
											tmp56 := checkDerefVar(var_glojure_DOT_core_next)
											tmp57 := lang.Apply(tmp56, []any{v52})
											var v58 any = tmp57
											_ = v58
											// let binding "prefix"
											var v59 any = v55
											_ = v59
											// let binding "args"
											var v60 any = v58
											_ = v60
											tmp61 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
											tmp62 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
											tmp63 := lang.Apply(tmp62, []any{v59})
											tmp64 := lang.Apply(tmp61, []any{tmp63, "prefix cannot be nil"})
											_ = tmp64
											var tmp65 any
											{ // let
												// let binding "seq_122"
												tmp66 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp67 := lang.Apply(tmp66, []any{v60})
												var v68 any = tmp67
												_ = v68
												// let binding "chunk_123"
												var v69 any = nil
												_ = v69
												// let binding "count_124"
												var v70 any = int64(0)
												_ = v70
												// let binding "i_125"
												var v71 any = int64(0)
												_ = v71
												for {
													var tmp72 any
													tmp73 := checkDerefVar(var_glojure_DOT_core__LT_)
													tmp74 := lang.Apply(tmp73, []any{v71, v70})
													if lang.IsTruthy(tmp74) {
														var tmp75 any
														{ // let
															// let binding "arg"
															tmp76, _ := lang.FieldOrMethod(v69, "nth")
															if reflect.TypeOf(tmp76).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp77 := lang.Apply(tmp76, []any{v71})
															var v78 any = tmp77
															_ = v78
															tmp79 := checkDerefVar(var_glojure_DOT_core_apply)
															tmp80 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
															tmp81 := checkDerefVar(var_glojure_DOT_core_prependss)
															tmp82 := lang.Apply(tmp81, []any{v78, v12})
															tmp83 := lang.Apply(tmp79, []any{tmp80, v59, tmp82})
															_ = tmp83
															var tmp84 any = v68
															var tmp85 any = v69
															var tmp86 any = v70
															tmp88 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
															tmp89 := lang.Apply(tmp88, []any{v71})
															var tmp87 any = tmp89
															v68 = tmp84
															v69 = tmp85
															v70 = tmp86
															v71 = tmp87
															continue
														} // end let
														tmp72 = tmp75
													} else {
														var tmp76 any
														{ // let
															// let binding "temp__0__auto__"
															tmp77 := checkDerefVar(var_glojure_DOT_core_seq)
															tmp78 := lang.Apply(tmp77, []any{v68})
															var v79 any = tmp78
															_ = v79
															var tmp80 any
															if lang.IsTruthy(v79) {
																var tmp81 any
																{ // let
																	// let binding "seq_122"
																	var v82 any = v79
																	_ = v82
																	var tmp83 any
																	tmp84 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
																	tmp85 := lang.Apply(tmp84, []any{v82})
																	if lang.IsTruthy(tmp85) {
																		var tmp86 any
																		{ // let
																			// let binding "c__0__auto__"
																			tmp87 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																			tmp88 := lang.Apply(tmp87, []any{v82})
																			var v89 any = tmp88
																			_ = v89
																			tmp91 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																			tmp92 := lang.Apply(tmp91, []any{v82})
																			var tmp90 any = tmp92
																			var tmp93 any = v89
																			tmp95 := checkDerefVar(var_glojure_DOT_core_int)
																			tmp96 := checkDerefVar(var_glojure_DOT_core_count)
																			tmp97 := lang.Apply(tmp96, []any{v89})
																			tmp98 := lang.Apply(tmp95, []any{tmp97})
																			var tmp94 any = tmp98
																			tmp100 := checkDerefVar(var_glojure_DOT_core_int)
																			tmp101 := lang.Apply(tmp100, []any{int64(0)})
																			var tmp99 any = tmp101
																			v68 = tmp90
																			v69 = tmp93
																			v70 = tmp94
																			v71 = tmp99
																			continue
																		} // end let
																		tmp83 = tmp86
																	} else {
																		var tmp87 any
																		{ // let
																			// let binding "arg"
																			tmp88 := checkDerefVar(var_glojure_DOT_core_first)
																			tmp89 := lang.Apply(tmp88, []any{v82})
																			var v90 any = tmp89
																			_ = v90
																			tmp91 := checkDerefVar(var_glojure_DOT_core_apply)
																			tmp92 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
																			tmp93 := checkDerefVar(var_glojure_DOT_core_prependss)
																			tmp94 := lang.Apply(tmp93, []any{v90, v12})
																			tmp95 := lang.Apply(tmp91, []any{tmp92, v59, tmp94})
																			_ = tmp95
																			tmp97 := checkDerefVar(var_glojure_DOT_core_next)
																			tmp98 := lang.Apply(tmp97, []any{v82})
																			var tmp96 any = tmp98
																			var tmp99 any = nil
																			var tmp100 any = int64(0)
																			var tmp101 any = int64(0)
																			v68 = tmp96
																			v69 = tmp99
																			v70 = tmp100
																			v71 = tmp101
																			continue
																		} // end let
																		tmp83 = tmp87
																	}
																	tmp81 = tmp83
																} // end let
																tmp80 = tmp81
															} else {
															}
															tmp76 = tmp80
														} // end let
														tmp72 = tmp76
													}
													tmp65 = tmp72
													break
												}
											} // end let
											tmp48 = tmp65
										} // end let
										tmp40 = tmp48
									}
									_ = tmp40
									var tmp49 any = v29
									var tmp50 any = v30
									var tmp51 any = v31
									tmp53 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
									tmp54 := lang.Apply(tmp53, []any{v32})
									var tmp52 any = tmp54
									v29 = tmp49
									v30 = tmp50
									v31 = tmp51
									v32 = tmp52
									continue
								} // end let
								tmp33 = tmp36
							} else {
								var tmp37 any
								{ // let
									// let binding "temp__0__auto__"
									tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp39 := lang.Apply(tmp38, []any{v29})
									var v40 any = tmp39
									_ = v40
									var tmp41 any
									if lang.IsTruthy(v40) {
										var tmp42 any
										{ // let
											// let binding "seq_115"
											var v43 any = v40
											_ = v43
											var tmp44 any
											tmp45 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
											tmp46 := lang.Apply(tmp45, []any{v43})
											if lang.IsTruthy(tmp46) {
												var tmp47 any
												{ // let
													// let binding "c__0__auto__"
													tmp48 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
													tmp49 := lang.Apply(tmp48, []any{v43})
													var v50 any = tmp49
													_ = v50
													tmp52 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
													tmp53 := lang.Apply(tmp52, []any{v43})
													var tmp51 any = tmp53
													var tmp54 any = v50
													tmp56 := checkDerefVar(var_glojure_DOT_core_int)
													tmp57 := checkDerefVar(var_glojure_DOT_core_count)
													tmp58 := lang.Apply(tmp57, []any{v50})
													tmp59 := lang.Apply(tmp56, []any{tmp58})
													var tmp55 any = tmp59
													tmp61 := checkDerefVar(var_glojure_DOT_core_int)
													tmp62 := lang.Apply(tmp61, []any{int64(0)})
													var tmp60 any = tmp62
													v29 = tmp51
													v30 = tmp54
													v31 = tmp55
													v32 = tmp60
													continue
												} // end let
												tmp44 = tmp47
											} else {
												var tmp48 any
												{ // let
													// let binding "arg"
													tmp49 := checkDerefVar(var_glojure_DOT_core_first)
													tmp50 := lang.Apply(tmp49, []any{v43})
													var v51 any = tmp50
													_ = v51
													var tmp52 any
													tmp53 := checkDerefVar(var_glojure_DOT_core_libspec_QMARK_)
													tmp54 := lang.Apply(tmp53, []any{v51})
													if lang.IsTruthy(tmp54) {
														tmp55 := checkDerefVar(var_glojure_DOT_core_apply)
														tmp56 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
														tmp57 := checkDerefVar(var_glojure_DOT_core_prependss)
														tmp58 := lang.Apply(tmp57, []any{v51, v12})
														tmp59 := lang.Apply(tmp55, []any{tmp56, nil, tmp58})
														tmp52 = tmp59
													} else {
														var tmp60 any
														{ // let
															// let binding "vec__126"
															var v61 any = v51
															_ = v61
															// let binding "seq__127"
															tmp62 := checkDerefVar(var_glojure_DOT_core_seq)
															tmp63 := lang.Apply(tmp62, []any{v61})
															var v64 any = tmp63
															_ = v64
															// let binding "first__128"
															tmp65 := checkDerefVar(var_glojure_DOT_core_first)
															tmp66 := lang.Apply(tmp65, []any{v64})
															var v67 any = tmp66
															_ = v67
															// let binding "seq__127"
															tmp68 := checkDerefVar(var_glojure_DOT_core_next)
															tmp69 := lang.Apply(tmp68, []any{v64})
															var v70 any = tmp69
															_ = v70
															// let binding "prefix"
															var v71 any = v67
															_ = v71
															// let binding "args"
															var v72 any = v70
															_ = v72
															tmp73 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
															tmp74 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
															tmp75 := lang.Apply(tmp74, []any{v71})
															tmp76 := lang.Apply(tmp73, []any{tmp75, "prefix cannot be nil"})
															_ = tmp76
															var tmp77 any
															{ // let
																// let binding "seq_129"
																tmp78 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp79 := lang.Apply(tmp78, []any{v72})
																var v80 any = tmp79
																_ = v80
																// let binding "chunk_130"
																var v81 any = nil
																_ = v81
																// let binding "count_131"
																var v82 any = int64(0)
																_ = v82
																// let binding "i_132"
																var v83 any = int64(0)
																_ = v83
																for {
																	var tmp84 any
																	tmp85 := checkDerefVar(var_glojure_DOT_core__LT_)
																	tmp86 := lang.Apply(tmp85, []any{v83, v82})
																	if lang.IsTruthy(tmp86) {
																		var tmp87 any
																		{ // let
																			// let binding "arg"
																			tmp88, _ := lang.FieldOrMethod(v81, "nth")
																			if reflect.TypeOf(tmp88).Kind() != reflect.Func {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
																			}
																			tmp89 := lang.Apply(tmp88, []any{v83})
																			var v90 any = tmp89
																			_ = v90
																			tmp91 := checkDerefVar(var_glojure_DOT_core_apply)
																			tmp92 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
																			tmp93 := checkDerefVar(var_glojure_DOT_core_prependss)
																			tmp94 := lang.Apply(tmp93, []any{v90, v12})
																			tmp95 := lang.Apply(tmp91, []any{tmp92, v71, tmp94})
																			_ = tmp95
																			var tmp96 any = v80
																			var tmp97 any = v81
																			var tmp98 any = v82
																			tmp100 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
																			tmp101 := lang.Apply(tmp100, []any{v83})
																			var tmp99 any = tmp101
																			v80 = tmp96
																			v81 = tmp97
																			v82 = tmp98
																			v83 = tmp99
																			continue
																		} // end let
																		tmp84 = tmp87
																	} else {
																		var tmp88 any
																		{ // let
																			// let binding "temp__0__auto__"
																			tmp89 := checkDerefVar(var_glojure_DOT_core_seq)
																			tmp90 := lang.Apply(tmp89, []any{v80})
																			var v91 any = tmp90
																			_ = v91
																			var tmp92 any
																			if lang.IsTruthy(v91) {
																				var tmp93 any
																				{ // let
																					// let binding "seq_129"
																					var v94 any = v91
																					_ = v94
																					var tmp95 any
																					tmp96 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
																					tmp97 := lang.Apply(tmp96, []any{v94})
																					if lang.IsTruthy(tmp97) {
																						var tmp98 any
																						{ // let
																							// let binding "c__0__auto__"
																							tmp99 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																							tmp100 := lang.Apply(tmp99, []any{v94})
																							var v101 any = tmp100
																							_ = v101
																							tmp103 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																							tmp104 := lang.Apply(tmp103, []any{v94})
																							var tmp102 any = tmp104
																							var tmp105 any = v101
																							tmp107 := checkDerefVar(var_glojure_DOT_core_int)
																							tmp108 := checkDerefVar(var_glojure_DOT_core_count)
																							tmp109 := lang.Apply(tmp108, []any{v101})
																							tmp110 := lang.Apply(tmp107, []any{tmp109})
																							var tmp106 any = tmp110
																							tmp112 := checkDerefVar(var_glojure_DOT_core_int)
																							tmp113 := lang.Apply(tmp112, []any{int64(0)})
																							var tmp111 any = tmp113
																							v80 = tmp102
																							v81 = tmp105
																							v82 = tmp106
																							v83 = tmp111
																							continue
																						} // end let
																						tmp95 = tmp98
																					} else {
																						var tmp99 any
																						{ // let
																							// let binding "arg"
																							tmp100 := checkDerefVar(var_glojure_DOT_core_first)
																							tmp101 := lang.Apply(tmp100, []any{v94})
																							var v102 any = tmp101
																							_ = v102
																							tmp103 := checkDerefVar(var_glojure_DOT_core_apply)
																							tmp104 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
																							tmp105 := checkDerefVar(var_glojure_DOT_core_prependss)
																							tmp106 := lang.Apply(tmp105, []any{v102, v12})
																							tmp107 := lang.Apply(tmp103, []any{tmp104, v71, tmp106})
																							_ = tmp107
																							tmp109 := checkDerefVar(var_glojure_DOT_core_next)
																							tmp110 := lang.Apply(tmp109, []any{v94})
																							var tmp108 any = tmp110
																							var tmp111 any = nil
																							var tmp112 any = int64(0)
																							var tmp113 any = int64(0)
																							v80 = tmp108
																							v81 = tmp111
																							v82 = tmp112
																							v83 = tmp113
																							continue
																						} // end let
																						tmp95 = tmp99
																					}
																					tmp93 = tmp95
																				} // end let
																				tmp92 = tmp93
																			} else {
																			}
																			tmp88 = tmp92
																		} // end let
																		tmp84 = tmp88
																	}
																	tmp77 = tmp84
																	break
																}
															} // end let
															tmp60 = tmp77
														} // end let
														tmp52 = tmp60
													}
													_ = tmp52
													tmp62 := checkDerefVar(var_glojure_DOT_core_next)
													tmp63 := lang.Apply(tmp62, []any{v43})
													var tmp61 any = tmp63
													var tmp64 any = nil
													var tmp65 any = int64(0)
													var tmp66 any = int64(0)
													v29 = tmp61
													v30 = tmp64
													v31 = tmp65
													v32 = tmp66
													continue
												} // end let
												tmp44 = tmp48
											}
											tmp42 = tmp44
										} // end let
										tmp41 = tmp42
									} else {
									}
									tmp37 = tmp41
								} // end let
								tmp33 = tmp37
							}
							tmp26 = tmp33
							break
						}
					} // end let
					tmp3 = tmp26
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_load_DASH_libs = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_load_DASH_libs.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// require
	{
		tmp0 := sym_require.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_args)), kw_doc, "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib, a prefix list that identifies\n  multiple libs whose names share a common prefix, or a flag that modifies\n  how all the identified libs are loaded. Use :require in the ns macro\n  in preference to calling this directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of Clojure code. Lib names are symbols and each lib is associated\n  with a Clojure namespace and a Java package that share its name. A lib's\n  name also locates its root directory within classpath using Java's\n  package name to classpath-relative path mapping. All resources in a lib\n  should be contained in the directory structure under its root directory.\n  All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or\n  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The\n  root resource should contain code to create the lib's\n  namespace (usually by using the ns macro) and load any additional\n  lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :as-alias takes a symbol as its argument and aliases like :as, however\n    the lib will not be loaded. If the lib has not been loaded, a new\n    empty namespace will be created (as with create-ns).\n  :refer takes a list of symbols to refer from the namespace or the :all\n    keyword to bring in all public vars.\n\n  Prefix Lists\n\n  It's common for Clojure code to depend on several libs whose names have\n  the same prefix. When specifying libs, prefix lists can be used to reduce\n  repetition. A prefix list contains the shared prefix followed by libspecs\n  with the shared prefix removed from the lib names. After removing the\n  prefix, the names that remain must not contain any periods.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded (has no effect on libspecs using :as-alias)\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n    (has no effect on libspecs using :as-alias)\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the libraries glojure.zip and glojure.set\n  abbreviated as 's'.\n\n  (require '(glojure zip [set :as s]))", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5989), kw_end_DASH_line, int(5989))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_glojure_DOT_core_load_DASH_libs)
				tmp5 := lang.Apply(tmp3, []any{tmp4, kw_require, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_require = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_require.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// serialized-require
	{
		tmp0 := sym_serialized_DASH_require.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_args)), kw_doc, "Like 'require', but serializes loading.\n  Interim function preferred over 'require' for known asynchronous loads.\n  Future changes may make these equivalent.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(8), kw_line, int(6059), kw_end_DASH_line, int(6059), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				var tmp3 any
				{ // let
					// let binding "lockee__0__auto__"
					var v4 any = nil
					_ = v4
					var tmp5 any
					func() {
						var tmp6 any
						{ // let
							// let binding "locklocal__1__auto__"
							var v7 any = v4
							_ = v7
							tmp8 := lang.Apply(nil, []any{v7})
							_ = tmp8
							var tmp9 any
							func() {
								defer func() {
									tmp10 := lang.Apply(nil, []any{v7})
									_ = tmp10
								}()
								tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
								tmp12 := checkDerefVar(var_glojure_DOT_core_require)
								tmp13 := lang.Apply(tmp11, []any{tmp12, v2})
								tmp9 = tmp13
							}()
							tmp6 = tmp9
						} // end let
						tmp5 = tmp6
					}()
					tmp3 = tmp5
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_serialized_DASH_require = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_serialized_DASH_require.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// use
	{
		tmp0 := sym_use.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_args)), kw_doc, "Like 'require, but also refers to each lib's namespace using\n  glojure.core/refer. Use :use in the ns macro in preference to calling\n  this directly.\n\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\n  The arguments and semantics for :exclude, :only, and :rename are the same\n  as those documented for glojure.core/refer.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(6079), kw_end_DASH_line, int(6079))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_glojure_DOT_core_load_DASH_libs)
				tmp5 := lang.Apply(tmp3, []any{tmp4, kw_require, kw_use, v2})
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_use = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_use.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// requiring-resolve
	{
		tmp0 := sym_requiring_DASH_resolve.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_doc, "Resolves namespace-qualified sym per 'resolve'. If initial resolve\nfails, attempts to require sym's namespace and retries.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(6068), kw_end_DASH_line, int(6068))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_qualified_DASH_symbol_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				var tmp6 any
				{ // let
					// let binding "or__0__auto__"
					tmp7 := checkDerefVar(var_glojure_DOT_core_resolve)
					tmp8 := lang.Apply(tmp7, []any{v2})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp10 = v9
					} else {
						tmp11 := checkDerefVar(var_glojure_DOT_core_serialized_DASH_require)
						tmp12 := checkDerefVar(var_glojure_DOT_core_symbol)
						tmp13 := checkDerefVar(var_glojure_DOT_core_namespace)
						tmp14 := lang.Apply(tmp13, []any{v2})
						tmp15 := lang.Apply(tmp12, []any{tmp14})
						tmp16 := lang.Apply(tmp11, []any{tmp15})
						_ = tmp16
						tmp17 := checkDerefVar(var_glojure_DOT_core_resolve)
						tmp18 := lang.Apply(tmp17, []any{v2})
						tmp10 = tmp18
					}
					tmp6 = tmp10
				} // end let
				tmp3 = tmp6
			} else {
				tmp7 := checkDerefVar(var_glojure_DOT_core_str)
				tmp8 := lang.Apply(tmp7, []any{"Not a qualified symbol: ", v2})
				tmp9 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp8})
				panic(tmp9)
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_requiring_DASH_resolve = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_requiring_DASH_resolve.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mapv
	{
		tmp0 := sym_mapv.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_c1, sym_c2), lang.NewVector(sym_f, sym_c1, sym_c2, sym_c3), lang.NewVector(sym_f, sym_c1, sym_c2, sym_c3, sym__AMP_, sym_colls)), kw_doc, "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6943), kw_end_DASH_line, int(6943))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
				tmp5 := checkDerefVar(var_glojure_DOT_core_reduce)
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v7 := args[0]
					_ = v7
					v8 := args[1]
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp10 := lang.Apply(v2, []any{v8})
					tmp11 := lang.Apply(tmp9, []any{v7, tmp10})
					return tmp11
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6952), kw_column, int(18), kw_end_DASH_line, int(6952), kw_end_DASH_column, int(43))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp10 := lang.NewVector()
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6952), kw_column, int(56), kw_end_DASH_line, int(6952), kw_end_DASH_column, int(57))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := lang.Apply(tmp9, []any{tmp12})
				tmp14 := lang.Apply(tmp5, []any{tmp8, tmp13, v3})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_into)
				tmp6 := lang.NewVector()
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6955), kw_column, int(12), kw_end_DASH_line, int(6955), kw_end_DASH_column, int(13))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := checkDerefVar(var_glojure_DOT_core_map)
				tmp10 := lang.Apply(tmp9, []any{v2, v3, v4})
				tmp11 := lang.Apply(tmp5, []any{tmp8, tmp10})
				return tmp11
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_into)
				tmp7 := lang.NewVector()
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6957), kw_column, int(12), kw_end_DASH_line, int(6957), kw_end_DASH_column, int(13))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := checkDerefVar(var_glojure_DOT_core_map)
				tmp11 := lang.Apply(tmp10, []any{v2, v3, v4, v5})
				tmp12 := lang.Apply(tmp6, []any{tmp9, tmp11})
				return tmp12
			default:
				checkArityGTE(args, 4)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var v6 any = lang.NewList(args[4:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_into)
				tmp8 := lang.NewVector()
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6959), kw_column, int(12), kw_end_DASH_line, int(6959), kw_end_DASH_column, int(13))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_glojure_DOT_core_map)
				tmp13 := lang.Apply(tmp11, []any{tmp12, v2, v3, v4, v5, v6})
				tmp14 := lang.Apply(tmp7, []any{tmp10, tmp13})
				return tmp14
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_mapv = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_mapv.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// newline
	{
		tmp0 := sym_newline.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Writes a platform-specific newline to *out*", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3698), kw_end_DASH_line, int(3698))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_glojure_DOT_core__STAR_out_STAR_)
			tmp3 := checkDerefVar(var_glojure_DOT_core_system_DASH_newline)
			tmp4 := lang.Apply(lang.AppendWriter, []any{tmp2, tmp3})
			_ = tmp4
			return nil
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_newline = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_newline.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// normalize-slurp-opts
	{
		tmp0 := sym_normalize_DASH_slurp_DASH_opts.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6974), kw_column, int(8), kw_end_DASH_line, int(6974), kw_end_DASH_column, int(27), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_opts)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp5 := checkDerefVar(var_glojure_DOT_core_first)
			tmp6 := lang.Apply(tmp5, []any{v2})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_glojure_DOT_core_println)
				tmp9 := lang.Apply(tmp8, []any{"WARNING: (slurp f enc) is deprecated, use (slurp f :encoding enc)."})
				_ = tmp9
				tmp10 := checkDerefVar(var_glojure_DOT_core_first)
				tmp11 := lang.Apply(tmp10, []any{v2})
				tmp12 := lang.NewVector(kw_encoding, tmp11)
				tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6979), kw_column, int(7), kw_end_DASH_line, int(6979), kw_end_DASH_column, int(30))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp3 = tmp14
			} else {
				tmp3 = v2
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_normalize_DASH_slurp_DASH_opts = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_normalize_DASH_slurp_DASH_opts.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pr
	{
		tmp0 := sym_pr.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_more)), kw_doc, "Prints the object(s) to the output stream that is the current value\n  of *out*.  Prints the object(s), separated by spaces if there is\n  more than one.  By default, pr and prn print in a way that objects\n  can be read by the reader", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(3678), kw_end_DASH_line, int(3678), kw_dynamic, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return nil
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
				tmp4 := checkDerefVar(var_glojure_DOT_core__STAR_out_STAR_)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
			recur_loop_671:
				tmp4 := checkDerefVar(var_glojure_DOT_core_pr)
				tmp5 := lang.Apply(tmp4, []any{v2})
				_ = tmp5
				tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_out_STAR_)
				tmp7 := lang.Apply(lang.AppendWriter, []any{tmp6, lang.NewChar(32)})
				_ = tmp7
				var tmp8 any
				{ // let
					// let binding "temp__0__auto__"
					tmp9 := checkDerefVar(var_glojure_DOT_core_next)
					tmp10 := lang.Apply(tmp9, []any{v3})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						var tmp13 any
						{ // let
							// let binding "nmore"
							var v14 any = v11
							_ = v14
							tmp16 := checkDerefVar(var_glojure_DOT_core_first)
							tmp17 := lang.Apply(tmp16, []any{v3})
							var tmp15 any = tmp17
							var tmp18 any = v14
							v2 = tmp15
							v3 = tmp18
							goto recur_loop_671
						} // end let
						tmp12 = tmp13
					} else {
						tmp14 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp15 := checkDerefVar(var_glojure_DOT_core_pr)
						tmp16 := lang.Apply(tmp14, []any{tmp15, v3})
						tmp12 = tmp16
					}
					tmp8 = tmp12
				} // end let
				return tmp8
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_pr = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_pr.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_glojure_DOT_core_pr.SetDynamic()
	}
	// pr-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_pr_DASH_str.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_doc, "pr to a string, returning it", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4758), kw_end_DASH_line, int(4758))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "s__0__auto__"
					tmp5 := new(strings11.Builder)
					var v6 any = tmp5
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp9 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp10 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_out_STAR_)
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp17 := checkDerefVar(var_glojure_DOT_core_pr)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v3})
							_ = tmp18
							tmp19 := checkDerefVar(var_glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp4 = tmp7
				} // end let
				return tmp4
			}
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_pr_DASH_str = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_pr_DASH_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print
	{
		tmp0 := sym_print.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_more)), kw_doc, "Prints the object(s) to the output stream that is the current value\n  of *out*.  print and println produce output for human consumption.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3725), kw_end_DASH_line, int(3725))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				var tmp3 any
				{ // let
					tmp4 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
					tmp5 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp6 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_readably_STAR_)
					tmp7 := lang.Apply(tmp5, []any{tmp6, nil})
					tmp8 := lang.Apply(tmp4, []any{tmp7})
					_ = tmp8
					var tmp9 any
					func() {
						defer func() {
							tmp10 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
							tmp11 := lang.Apply(tmp10, nil)
							_ = tmp11
						}()
						tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp13 := checkDerefVar(var_glojure_DOT_core_pr)
						tmp14 := lang.Apply(tmp12, []any{tmp13, v2})
						tmp9 = tmp14
					}()
					tmp3 = tmp9
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_print = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_print_DASH_str.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_doc, "print to a string, returning it", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4776), kw_end_DASH_line, int(4776))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "s__0__auto__"
					tmp5 := new(strings11.Builder)
					var v6 any = tmp5
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp9 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp10 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_out_STAR_)
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp17 := checkDerefVar(var_glojure_DOT_core_print)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v3})
							_ = tmp18
							tmp19 := checkDerefVar(var_glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp4 = tmp7
				} // end let
				return tmp4
			}
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_print_DASH_str = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// printf
	{
		tmp0 := sym_printf.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_fmt, sym__AMP_, sym_args)), kw_doc, "Prints formatted output, as per format", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5725), kw_end_DASH_line, int(5725))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				var v3 any = lang.NewList(args[1:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_print)
				tmp5 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_glojure_DOT_core_format)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v2, v3})
				tmp8 := lang.Apply(tmp4, []any{tmp7})
				return tmp8
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_printf = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_printf.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prn
	{
		tmp0 := sym_prn.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_more)), kw_doc, "Same as pr followed by (newline). Observes *flush-on-newline*", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(3715), kw_end_DASH_line, int(3715))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_glojure_DOT_core_pr)
				tmp5 := lang.Apply(tmp3, []any{tmp4, v2})
				_ = tmp5
				tmp6 := checkDerefVar(var_glojure_DOT_core_newline)
				tmp7 := lang.Apply(tmp6, nil)
				_ = tmp7
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core__STAR_flush_DASH_on_DASH_newline_STAR_)
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_glojure_DOT_core_flush)
					tmp11 := lang.Apply(tmp10, nil)
					tmp8 = tmp11
				} else {
				}
				return tmp8
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_prn = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_prn.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prn-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_prn_DASH_str.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_doc, "prn to a string, returning it", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4767), kw_end_DASH_line, int(4767))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "s__0__auto__"
					tmp5 := new(strings11.Builder)
					var v6 any = tmp5
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp9 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp10 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_out_STAR_)
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp17 := checkDerefVar(var_glojure_DOT_core_prn)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v3})
							_ = tmp18
							tmp19 := checkDerefVar(var_glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp4 = tmp7
				} // end let
				return tmp4
			}
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_prn_DASH_str = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_prn_DASH_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// println
	{
		tmp0 := sym_println.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_more)), kw_doc, "Same as print followed by (newline)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3734), kw_end_DASH_line, int(3734))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v2 any = lang.NewList(args[0:]...)
				_ = v2
				var tmp3 any
				{ // let
					tmp4 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
					tmp5 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp6 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_readably_STAR_)
					tmp7 := lang.Apply(tmp5, []any{tmp6, nil})
					tmp8 := lang.Apply(tmp4, []any{tmp7})
					_ = tmp8
					var tmp9 any
					func() {
						defer func() {
							tmp10 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
							tmp11 := lang.Apply(tmp10, nil)
							_ = tmp11
						}()
						tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp13 := checkDerefVar(var_glojure_DOT_core_prn)
						tmp14 := lang.Apply(tmp12, []any{tmp13, v2})
						tmp9 = tmp14
					}()
					tmp3 = tmp9
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_println = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_println.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// println-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_println_DASH_str.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_doc, "println to a string, returning it", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(4785), kw_end_DASH_line, int(4785))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "s__0__auto__"
					tmp5 := new(strings11.Builder)
					var v6 any = tmp5
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp9 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp10 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_out_STAR_)
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp17 := checkDerefVar(var_glojure_DOT_core_println)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v3})
							_ = tmp18
							tmp19 := checkDerefVar(var_glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp4 = tmp7
				} // end let
				return tmp4
			}
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_println_DASH_str = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_println_DASH_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pr-on
	{
		tmp0 := sym_pr_DASH_on.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_w)), kw_static, true, kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3669), kw_end_DASH_line, int(3669), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
			if lang.IsTruthy(tmp5) {
				tmp6 := checkDerefVar(var_glojure_DOT_core_print_DASH_dup)
				tmp7 := lang.Apply(tmp6, []any{v2, v3})
				tmp4 = tmp7
			} else {
				tmp8 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
				tmp9 := lang.Apply(tmp8, []any{v2, v3})
				tmp4 = tmp9
			}
			_ = tmp4
			return nil
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_pr_DASH_on = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_pr_DASH_on.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-meta
	{
		tmp0 := sym_print_DASH_meta.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(70), kw_column, int(8), kw_end_DASH_line, int(70), kw_end_DASH_column, int(17), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp6 := lang.Apply(tmp5, []any{v2})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "m"
						var v10 any = v7
						_ = v10
						var tmp11 any
						var tmp12 any
						{ // let
							// let binding "and__0__auto__"
							tmp13 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
							tmp14 := checkDerefVar(var_glojure_DOT_core_count)
							tmp15 := lang.Apply(tmp14, []any{v10})
							tmp16 := lang.Apply(tmp13, []any{tmp15})
							var v17 any = tmp16
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								var tmp19 any
								{ // let
									// let binding "or__0__auto__"
									tmp20 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
									var v21 any = tmp20
									_ = v21
									var tmp22 any
									if lang.IsTruthy(v21) {
										tmp22 = v21
									} else {
										var tmp23 any
										{ // let
											// let binding "and__0__auto__"
											tmp24 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_meta_STAR_)
											var v25 any = tmp24
											_ = v25
											var tmp26 any
											if lang.IsTruthy(v25) {
												tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_readably_STAR_)
												tmp26 = tmp27
											} else {
												tmp26 = v25
											}
											tmp23 = tmp26
										} // end let
										tmp22 = tmp23
									}
									tmp19 = tmp22
								} // end let
								tmp18 = tmp19
							} else {
								tmp18 = v17
							}
							tmp12 = tmp18
						} // end let
						if lang.IsTruthy(tmp12) {
							tmp13 := lang.Apply(lang.WriteWriter, []any{v3, "^"})
							_ = tmp13
							var tmp14 any
							var tmp15 any
							{ // let
								// let binding "and__0__auto__"
								tmp16 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp17 := checkDerefVar(var_glojure_DOT_core_count)
								tmp18 := lang.Apply(tmp17, []any{v10})
								tmp19 := lang.Apply(tmp16, []any{tmp18, int64(1)})
								var v20 any = tmp19
								_ = v20
								var tmp21 any
								if lang.IsTruthy(v20) {
									tmp22 := lang.Apply(kw_tag, []any{v10})
									tmp21 = tmp22
								} else {
									tmp21 = v20
								}
								tmp15 = tmp21
							} // end let
							if lang.IsTruthy(tmp15) {
								tmp16 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
								tmp17 := lang.Apply(kw_tag, []any{v10})
								tmp18 := lang.Apply(tmp16, []any{tmp17, v3})
								tmp14 = tmp18
							} else {
								tmp19 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
								tmp20 := lang.Apply(tmp19, []any{v10, v3})
								tmp14 = tmp20
							}
							_ = tmp14
							tmp21 := lang.Apply(lang.WriteWriter, []any{v3, " "})
							tmp11 = tmp21
						} else {
						}
						tmp9 = tmp11
					} // end let
					tmp8 = tmp9
				} else {
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_print_DASH_meta = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_meta.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-simple
	{
		tmp0 := sym_print_DASH_simple.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(81), kw_column, int(7), kw_end_DASH_line, int(81), kw_end_DASH_column, int(18), kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			_ = tmp5
			tmp6 := checkDerefVar(var_glojure_DOT_core_str)
			tmp7 := lang.Apply(tmp6, []any{v2})
			tmp8 := lang.Apply(lang.WriteWriter, []any{v3, tmp7})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_print_DASH_simple = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_simple.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-dup
	{
		tmp0 := sym_print_DASH_dup.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3667), kw_column, int(11), kw_end_DASH_line, int(3667), kw_end_DASH_column, int(19), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_class)
			tmp6 := lang.Apply(tmp5, []any{v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3667), kw_column, int(21), kw_end_DASH_line, int(3667), kw_end_DASH_column, int(45))).(lang.FnFunc)
		// MultiFn print-dup
		tmp1 := lang.NewMultiFn("print-dup", tmp2, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp1.AddMethod(nil, tmp3)
		tmp4 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v6 := args[0]
			_ = v6
			v7 := args[1]
			_ = v7
			tmp8 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp9 := lang.Apply(tmp8, []any{v6, v7})
			return tmp9
		})
		tmp1.AddMethod(tmp4, tmp5)
		tmp6 := reflect.TypeOf((*lang.IPersistentList)(nil)).Elem()
		var tmp7 lang.FnFunc
		tmp7 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v8 := args[0]
			_ = v8
			v9 := args[1]
			_ = v9
			tmp10 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp11 := lang.Apply(tmp10, []any{v8, v9})
			return tmp11
		})
		tmp1.AddMethod(tmp6, tmp7)
		tmp8 := reflect.TypeOf((*lang.Symbol)(nil))
		var tmp9 lang.FnFunc
		tmp9 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v10 := args[0]
			_ = v10
			v11 := args[1]
			_ = v11
			tmp12 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp13 := lang.Apply(tmp12, []any{v10, v11})
			return tmp13
		})
		tmp1.AddMethod(tmp8, tmp9)
		tmp10 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		var tmp11 lang.FnFunc
		tmp11 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v12 := args[0]
			_ = v12
			v13 := args[1]
			_ = v13
			tmp14 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp15 := lang.Apply(tmp14, []any{v12, v13})
			_ = tmp15
			tmp16 := lang.Apply(lang.WriteWriter, []any{v13, "#"})
			_ = tmp16
			tmp17 := checkDerefVar(var_glojure_DOT_core_class)
			tmp18 := lang.Apply(tmp17, []any{v12})
			tmp19, ok := lang.FieldOrMethod(tmp18, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp18, "Name")))
			}
			var tmp20 any
			switch reflect.TypeOf(tmp19).Kind() {
			case reflect.Func:
				tmp20 = lang.Apply(tmp19, nil)
			default:
				tmp20 = tmp19
			}
			tmp21 := lang.Apply(lang.WriteWriter, []any{v13, tmp20})
			_ = tmp21
			var tmp22 any
			tmp23 := checkDerefVar(var_glojure_DOT_core__STAR_verbose_DASH_defrecords_STAR_)
			if lang.IsTruthy(tmp23) {
				tmp24 := checkDerefVar(var_glojure_DOT_core_print_DASH_map)
				tmp25 := checkDerefVar(var_glojure_DOT_core_print_DASH_dup)
				tmp26 := lang.Apply(tmp24, []any{v12, tmp25, v13})
				tmp22 = tmp26
			} else {
				tmp27 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
				tmp28 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
				tmp29 := checkDerefVar(var_glojure_DOT_core_vals)
				tmp30 := lang.Apply(tmp29, []any{v12})
				tmp31 := lang.Apply(tmp27, []any{"[", tmp28, ", ", "]", tmp30, v13})
				tmp22 = tmp31
			}
			return tmp22
		})
		tmp1.AddMethod(tmp10, tmp11)
		tmp12 := reflect.TypeOf((*lang.Set)(nil))
		var tmp13 lang.FnFunc
		tmp13 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v14 := args[0]
			_ = v14
			v15 := args[1]
			_ = v15
			tmp16 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp17 := lang.Apply(tmp16, []any{v14, v15})
			return tmp17
		})
		tmp1.AddMethod(tmp12, tmp13)
		tmp14 := reflect.TypeOf((*lang.PersistentHashMap)(nil))
		var tmp15 lang.FnFunc
		tmp15 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v16 := args[0]
			_ = v16
			v17 := args[1]
			_ = v17
			tmp18 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp19 := lang.Apply(tmp18, []any{v16, v17})
			return tmp19
		})
		tmp1.AddMethod(tmp14, tmp15)
		tmp16 := reflect.TypeOf(int64(0))
		var tmp17 lang.FnFunc
		tmp17 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v18 := args[0]
			_ = v18
			v19 := args[1]
			_ = v19
			tmp20 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp21 := lang.Apply(tmp20, []any{v18, v19})
			return tmp21
		})
		tmp1.AddMethod(tmp16, tmp17)
		tmp18 := reflect.TypeOf((*lang.Vector)(nil))
		var tmp19 lang.FnFunc
		tmp19 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v20 := args[0]
			_ = v20
			v21 := args[1]
			_ = v21
			tmp22 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp23 := lang.Apply(tmp22, []any{v20, v21})
			return tmp23
		})
		tmp1.AddMethod(tmp18, tmp19)
		tmp20 := reflect.TypeOf(float64(0))
		var tmp21 lang.FnFunc
		tmp21 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v22 := args[0]
			_ = v22
			v23 := args[1]
			_ = v23
			tmp24 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp25 := lang.Apply(tmp24, []any{v22, v23})
			return tmp25
		})
		tmp1.AddMethod(tmp20, tmp21)
		tmp22 := reflect.TypeOf("")
		var tmp23 lang.FnFunc
		tmp23 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v24 := args[0]
			_ = v24
			v25 := args[1]
			_ = v25
			tmp26 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp27 := lang.Apply(tmp26, []any{v24, v25})
			return tmp27
		})
		tmp1.AddMethod(tmp22, tmp23)
		tmp24 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		var tmp25 lang.FnFunc
		tmp25 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v26 := args[0]
			_ = v26
			v27 := args[1]
			_ = v27
			tmp28 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp29 := lang.Apply(tmp28, []any{v26, v27})
			_ = tmp29
			tmp30 := lang.Apply(lang.WriteWriter, []any{v27, "#=("})
			_ = tmp30
			tmp31 := checkDerefVar(var_glojure_DOT_core_class)
			tmp32 := lang.Apply(tmp31, []any{v26})
			tmp33, ok := lang.FieldOrMethod(tmp32, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp32, "Name")))
			}
			var tmp34 any
			switch reflect.TypeOf(tmp33).Kind() {
			case reflect.Func:
				tmp34 = lang.Apply(tmp33, nil)
			default:
				tmp34 = tmp33
			}
			tmp35 := lang.Apply(lang.WriteWriter, []any{v27, tmp34})
			_ = tmp35
			tmp36 := lang.Apply(lang.WriteWriter, []any{v27, "/create "})
			_ = tmp36
			tmp37 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
			tmp38 := checkDerefVar(var_glojure_DOT_core_print_DASH_dup)
			tmp39 := lang.Apply(tmp37, []any{"[", tmp38, " ", "]", v26, v27})
			_ = tmp39
			tmp40 := lang.Apply(lang.WriteWriter, []any{v27, ")"})
			return tmp40
		})
		tmp1.AddMethod(tmp24, tmp25)
		tmp26 := reflect.TypeOf(lang.NewChar(0))
		var tmp27 lang.FnFunc
		tmp27 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v28 := args[0]
			_ = v28
			v29 := args[1]
			_ = v29
			tmp30 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp31 := lang.Apply(tmp30, []any{v28, v29})
			return tmp31
		})
		tmp1.AddMethod(tmp26, tmp27)
		tmp28 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		var tmp29 lang.FnFunc
		tmp29 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v30 := args[0]
			_ = v30
			v31 := args[1]
			_ = v31
			tmp32 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp33 := lang.Apply(tmp32, []any{v30, v31})
			_ = tmp33
			tmp34 := lang.Apply(lang.WriteWriter, []any{v31, "#=("})
			_ = tmp34
			tmp35 := checkDerefVar(var_glojure_DOT_core_class)
			tmp36 := lang.Apply(tmp35, []any{v30})
			tmp37, ok := lang.FieldOrMethod(tmp36, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp36, "Name")))
			}
			var tmp38 any
			switch reflect.TypeOf(tmp37).Kind() {
			case reflect.Func:
				tmp38 = lang.Apply(tmp37, nil)
			default:
				tmp38 = tmp37
			}
			tmp39 := lang.Apply(lang.WriteWriter, []any{v31, tmp38})
			_ = tmp39
			tmp40 := lang.Apply(lang.WriteWriter, []any{v31, "/create "})
			_ = tmp40
			tmp41 := checkDerefVar(var_glojure_DOT_core_print_DASH_map)
			tmp42 := checkDerefVar(var_glojure_DOT_core_print_DASH_dup)
			tmp43 := lang.Apply(tmp41, []any{v30, tmp42, v31})
			_ = tmp43
			tmp44 := lang.Apply(lang.WriteWriter, []any{v31, ")"})
			return tmp44
		})
		tmp1.AddMethod(tmp28, tmp29)
		tmp30 := reflect.TypeOf((*lang.Namespace)(nil))
		var tmp31 lang.FnFunc
		tmp31 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v32 := args[0]
			_ = v32
			v33 := args[1]
			_ = v33
			tmp34 := lang.Apply(lang.WriteWriter, []any{v33, "#=(find-ns "})
			_ = tmp34
			tmp35 := checkDerefVar(var_glojure_DOT_core_print_DASH_dup)
			tmp36, ok := lang.FieldOrMethod(v32, "name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v32, "name")))
			}
			var tmp37 any
			switch reflect.TypeOf(tmp36).Kind() {
			case reflect.Func:
				tmp37 = lang.Apply(tmp36, nil)
			default:
				tmp37 = tmp36
			}
			tmp38 := lang.Apply(tmp35, []any{tmp37, v33})
			_ = tmp38
			tmp39 := lang.Apply(lang.WriteWriter, []any{v33, ")"})
			return tmp39
		})
		tmp1.AddMethod(tmp30, tmp31)
		tmp32 := reflect.TypeOf(false)
		var tmp33 lang.FnFunc
		tmp33 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v34 := args[0]
			_ = v34
			v35 := args[1]
			_ = v35
			tmp36 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp37 := lang.Apply(tmp36, []any{v34, v35})
			return tmp37
		})
		tmp1.AddMethod(tmp32, tmp33)
		tmp34 := reflect.TypeOf((*regexp15.Regexp)(nil))
		var tmp35 lang.FnFunc
		tmp35 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v36 := args[0]
			_ = v36
			v37 := args[1]
			_ = v37
			tmp38 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp39 := lang.Apply(tmp38, []any{v36, v37})
			return tmp39
		})
		tmp1.AddMethod(tmp34, tmp35)
		tmp36 := reflect.TypeOf((*lang.Ratio)(nil))
		var tmp37 lang.FnFunc
		tmp37 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v38 := args[0]
			_ = v38
			v39 := args[1]
			_ = v39
			tmp40 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp41 := lang.Apply(tmp40, []any{v38, v39})
			return tmp41
		})
		tmp1.AddMethod(tmp36, tmp37)
		tmp38 := reflect.TypeOf((*lang.Var)(nil))
		var tmp39 lang.FnFunc
		tmp39 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v40 := args[0]
			_ = v40
			v41 := args[1]
			_ = v41
			tmp42 := checkDerefVar(var_glojure_DOT_core_str)
			tmp43, ok := lang.FieldOrMethod(v40, "Namespace")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v40, "Namespace")))
			}
			var tmp44 any
			switch reflect.TypeOf(tmp43).Kind() {
			case reflect.Func:
				tmp44 = lang.Apply(tmp43, nil)
			default:
				tmp44 = tmp43
			}
			tmp45, ok := lang.FieldOrMethod(tmp44, "name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp44, "name")))
			}
			var tmp46 any
			switch reflect.TypeOf(tmp45).Kind() {
			case reflect.Func:
				tmp46 = lang.Apply(tmp45, nil)
			default:
				tmp46 = tmp45
			}
			tmp47, ok := lang.FieldOrMethod(v40, "sym")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v40, "sym")))
			}
			var tmp48 any
			switch reflect.TypeOf(tmp47).Kind() {
			case reflect.Func:
				tmp48 = lang.Apply(tmp47, nil)
			default:
				tmp48 = tmp47
			}
			tmp49 := lang.Apply(tmp42, []any{"#=(var ", tmp46, "/", tmp48, ")"})
			tmp50 := lang.Apply(lang.WriteWriter, []any{v41, tmp49})
			return tmp50
		})
		tmp1.AddMethod(tmp38, tmp39)
		tmp40 := reflect.TypeOf((*lang.BigDecimal)(nil))
		var tmp41 lang.FnFunc
		tmp41 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v42 := args[0]
			_ = v42
			v43 := args[1]
			_ = v43
			tmp44 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp45 := lang.Apply(tmp44, []any{v42, v43})
			return tmp45
		})
		tmp1.AddMethod(tmp40, tmp41)
		tmp42 := reflect.TypeOf((*lang.BigInt)(nil))
		var tmp43 lang.FnFunc
		tmp43 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v44 := args[0]
			_ = v44
			v45 := args[1]
			_ = v45
			tmp46 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp47 := lang.Apply(tmp46, []any{v44, v45})
			return tmp47
		})
		tmp1.AddMethod(tmp42, tmp43)
		tmp44 := reflect.TypeOf((*runtime.Fn)(nil))
		var tmp45 lang.FnFunc
		tmp45 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v46 := args[0]
			_ = v46
			v47 := args[1]
			_ = v47
			tmp48 := checkDerefVar(var_glojure_DOT_core_print_DASH_ctor)
			var tmp49 lang.FnFunc
			tmp49 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v50 := args[0]
				_ = v50
				v51 := args[1]
				_ = v51
				return nil
			})
			tmp50 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(167), kw_column, int(17), kw_end_DASH_line, int(167), kw_end_DASH_column, int(26))
			tmp51, err := lang.WithMeta(tmp49, tmp50.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp52 := lang.Apply(tmp48, []any{v46, tmp51, v47})
			return tmp52
		})
		tmp1.AddMethod(tmp44, tmp45)
		tmp46 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		var tmp47 lang.FnFunc
		tmp47 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v48 := args[0]
			_ = v48
			v49 := args[1]
			_ = v49
			tmp50 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp51 := lang.Apply(tmp50, []any{v48, v49})
			return tmp51
		})
		tmp1.AddMethod(tmp46, tmp47)
		tmp48 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp49 := reflect.TypeOf((*runtime.Fn)(nil))
		tmp1.PreferMethod(tmp48, tmp49)
		tmp50 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp51 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp1.PreferMethod(tmp50, tmp51)
		tmp52 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		tmp53 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		tmp1.PreferMethod(tmp52, tmp53)
		tmp54 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		tmp55 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp1.PreferMethod(tmp54, tmp55)
		var_glojure_DOT_core_print_DASH_dup = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_dup.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-method
	{
		tmp0 := sym_print_DASH_method.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3664), kw_column, int(11), kw_end_DASH_line, int(3664), kw_end_DASH_column, int(22), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "t"
				tmp6 := checkDerefVar(var_glojure_DOT_core_get)
				tmp7 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp9 := lang.Apply(tmp6, []any{tmp8, kw_type})
				var v10 any = tmp9
				_ = v10
				var tmp11 any
				tmp12 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp13 := lang.Apply(tmp12, []any{v10})
				if lang.IsTruthy(tmp13) {
					tmp11 = v10
				} else {
					tmp14 := checkDerefVar(var_glojure_DOT_core_class)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp11 = tmp15
				}
				tmp5 = tmp11
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3664), kw_column, int(24), kw_end_DASH_line, int(3666), kw_end_DASH_column, int(58))).(lang.FnFunc)
		// MultiFn print-method
		tmp1 := lang.NewMultiFn("print-method", tmp2, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := lang.Apply(lang.WriteWriter, []any{v5, "nil"})
			return tmp6
		})
		tmp1.AddMethod(nil, tmp3)
		tmp4 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v6 := args[0]
			_ = v6
			v7 := args[1]
			_ = v7
			tmp8 := checkDerefVar(var_glojure_DOT_core_str)
			tmp9 := lang.Apply(tmp8, []any{v6})
			tmp10 := lang.Apply(lang.WriteWriter, []any{v7, tmp9})
			return tmp10
		})
		tmp1.AddMethod(tmp4, tmp5)
		tmp6 := reflect.TypeOf(uint32(0))
		var tmp7 lang.FnFunc
		tmp7 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v8 := args[0]
			_ = v8
			v9 := args[1]
			_ = v9
			tmp10 := checkDerefVar(var_glojure_DOT_core_str)
			tmp11 := lang.Apply(tmp10, []any{v8})
			tmp12, _ := lang.FieldOrMethod(v9, "write")
			if reflect.TypeOf(tmp12).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp13 := lang.Apply(tmp12, []any{tmp11})
			return tmp13
		})
		tmp1.AddMethod(tmp6, tmp7)
		tmp8 := reflect.TypeOf((*lang.Symbol)(nil))
		var tmp9 lang.FnFunc
		tmp9 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v10 := args[0]
			_ = v10
			v11 := args[1]
			_ = v11
			tmp12 := checkDerefVar(var_glojure_DOT_core_print_DASH_simple)
			tmp13 := lang.Apply(tmp12, []any{v10, v11})
			return tmp13
		})
		tmp1.AddMethod(tmp8, tmp9)
		tmp10 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		var tmp11 lang.FnFunc
		tmp11 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v12 := args[0]
			_ = v12
			v13 := args[1]
			_ = v13
			tmp14 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp15 := lang.Apply(tmp14, []any{v12, v13})
			_ = tmp15
			tmp16 := lang.Apply(lang.WriteWriter, []any{v13, "#"})
			_ = tmp16
			tmp17 := checkDerefVar(var_glojure_DOT_core_class)
			tmp18 := lang.Apply(tmp17, []any{v12})
			tmp19, ok := lang.FieldOrMethod(tmp18, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp18, "Name")))
			}
			var tmp20 any
			switch reflect.TypeOf(tmp19).Kind() {
			case reflect.Func:
				tmp20 = lang.Apply(tmp19, nil)
			default:
				tmp20 = tmp19
			}
			tmp21 := lang.Apply(lang.WriteWriter, []any{v13, tmp20})
			_ = tmp21
			tmp22 := checkDerefVar(var_glojure_DOT_core_print_DASH_map)
			tmp23 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
			tmp24 := lang.Apply(tmp22, []any{v12, tmp23, v13})
			return tmp24
		})
		tmp1.AddMethod(tmp10, tmp11)
		tmp12 := reflect.TypeOf(uint(0))
		var tmp13 lang.FnFunc
		tmp13 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v14 := args[0]
			_ = v14
			v15 := args[1]
			_ = v15
			tmp16 := checkDerefVar(var_glojure_DOT_core_str)
			tmp17 := lang.Apply(tmp16, []any{v14})
			tmp18, _ := lang.FieldOrMethod(v15, "write")
			if reflect.TypeOf(tmp18).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp19 := lang.Apply(tmp18, []any{tmp17})
			return tmp19
		})
		tmp1.AddMethod(tmp12, tmp13)
		tmp14 := reflect.TypeOf(int64(0))
		var tmp15 lang.FnFunc
		tmp15 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v16 := args[0]
			_ = v16
			v17 := args[1]
			_ = v17
			tmp18 := checkDerefVar(var_glojure_DOT_core_str)
			tmp19 := lang.Apply(tmp18, []any{v16})
			tmp20, _ := lang.FieldOrMethod(v17, "write")
			if reflect.TypeOf(tmp20).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp21 := lang.Apply(tmp20, []any{tmp19})
			return tmp21
		})
		tmp1.AddMethod(tmp14, tmp15)
		var tmp16 lang.FnFunc
		tmp16 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v17 := args[0]
			_ = v17
			v18 := args[1]
			_ = v18
			var tmp19 any
			tmp20 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp21 := reflect.TypeOf((*lang.IObj)(nil)).Elem()
			tmp22 := lang.Apply(tmp20, []any{tmp21, v17})
			if lang.IsTruthy(tmp22) {
				tmp23 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
				tmp24 := checkDerefVar(var_glojure_DOT_core_vary_DASH_meta)
				var tmp25 lang.FnFunc
				tmp25 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v26 := args[0]
					_ = v26
					tmp27 := checkDerefVar(var_glojure_DOT_core_dissoc)
					tmp28 := lang.Apply(tmp27, []any{v26, kw_type})
					return tmp28
				})
				tmp26 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(87), kw_column, int(32), kw_end_DASH_line, int(87), kw_end_DASH_column, int(48))
				tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp28 := lang.Apply(tmp24, []any{v17, tmp27})
				tmp29 := lang.Apply(tmp23, []any{tmp28, v18})
				tmp19 = tmp29
			} else {
				tmp30 := checkDerefVar(var_glojure_DOT_core_print_DASH_simple)
				tmp31 := lang.Apply(tmp30, []any{v17, v18})
				tmp19 = tmp31
			}
			return tmp19
		})
		tmp1.AddMethod(kw_default, tmp16)
		tmp17 := reflect.TypeOf(float64(0))
		var tmp18 lang.FnFunc
		tmp18 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v19 := args[0]
			_ = v19
			v20 := args[1]
			_ = v20
			var tmp21 any
			tmp22 := checkDerefVar(var_glojure_DOT_core__EQ_)
			tmp23 := lang.Apply(math7.Inf, []any{int64(1)})
			tmp24 := lang.Apply(tmp22, []any{tmp23, v19})
			if lang.IsTruthy(tmp24) {
				tmp25 := lang.Apply(lang.WriteWriter, []any{v20, "##Inf"})
				tmp21 = tmp25
			} else {
				var tmp26 any
				tmp27 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp28 := lang.Apply(math7.Inf, []any{int64(-1)})
				tmp29 := lang.Apply(tmp27, []any{tmp28, v19})
				if lang.IsTruthy(tmp29) {
					tmp30 := lang.Apply(lang.WriteWriter, []any{v20, "##-Inf"})
					tmp26 = tmp30
				} else {
					var tmp31 any
					tmp32 := lang.Apply(math7.IsNaN, []any{v19})
					if lang.IsTruthy(tmp32) {
						tmp33 := lang.Apply(lang.WriteWriter, []any{v20, "##NaN"})
						tmp31 = tmp33
					} else {
						var tmp34 any
						if lang.IsTruthy(kw_else) {
							tmp35 := checkDerefVar(var_glojure_DOT_core_str)
							tmp36 := lang.Apply(tmp35, []any{v19})
							tmp37 := lang.Apply(lang.WriteWriter, []any{v20, tmp36})
							tmp34 = tmp37
						} else {
						}
						tmp31 = tmp34
					}
					tmp26 = tmp31
				}
				tmp21 = tmp26
			}
			return tmp21
		})
		tmp1.AddMethod(tmp17, tmp18)
		tmp19 := reflect.TypeOf("")
		var tmp20 lang.FnFunc
		tmp20 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v21 := args[0]
			_ = v21
			v22 := args[1]
			_ = v22
			var tmp23 any
			var tmp24 any
			{ // let
				// let binding "or__0__auto__"
				tmp25 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
				var v26 any = tmp25
				_ = v26
				var tmp27 any
				if lang.IsTruthy(v26) {
					tmp27 = v26
				} else {
					tmp28 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_readably_STAR_)
					tmp27 = tmp28
				}
				tmp24 = tmp27
			} // end let
			if lang.IsTruthy(tmp24) {
				tmp25 := lang.Apply(lang.AppendWriter, []any{v22, lang.NewChar(34)})
				_ = tmp25
				var tmp26 any
				{ // let
					// let binding "n__0__auto__"
					tmp27 := checkDerefVar(var_glojure_DOT_core_long)
					tmp28 := checkDerefVar(var_glojure_DOT_core_count)
					tmp29 := lang.Apply(tmp28, []any{v21})
					tmp30 := lang.Apply(tmp27, []any{tmp29})
					var v31 any = tmp30
					_ = v31
					var tmp32 any
					{ // let
						// let binding "n"
						var v33 any = int64(0)
						_ = v33
						for {
							var tmp34 any
							tmp35 := checkDerefVar(var_glojure_DOT_core__LT_)
							tmp36 := lang.Apply(tmp35, []any{v33, v31})
							if lang.IsTruthy(tmp36) {
								var tmp37 any
								{ // let
									// let binding "c"
									tmp38 := lang.Apply(lang.CharAt, []any{v21, v33})
									var v39 any = tmp38
									_ = v39
									// let binding "e"
									tmp40 := checkDerefVar(var_glojure_DOT_core_char_DASH_escape_DASH_string)
									tmp41 := lang.Apply(tmp40, []any{v39})
									var v42 any = tmp41
									_ = v42
									var tmp43 any
									if lang.IsTruthy(v42) {
										tmp44 := lang.Apply(lang.WriteWriter, []any{v22, v42})
										tmp43 = tmp44
									} else {
										tmp45 := lang.Apply(lang.AppendWriter, []any{v22, v39})
										tmp43 = tmp45
									}
									tmp37 = tmp43
								} // end let
								_ = tmp37
								tmp39 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
								tmp40 := lang.Apply(tmp39, []any{v33})
								var tmp38 any = tmp40
								v33 = tmp38
								continue
							} else {
							}
							tmp32 = tmp34
							break
						}
					} // end let
					tmp26 = tmp32
				} // end let
				_ = tmp26
				tmp27 := lang.Apply(lang.AppendWriter, []any{v22, lang.NewChar(34)})
				tmp23 = tmp27
			} else {
				tmp28 := lang.Apply(lang.WriteWriter, []any{v22, v21})
				tmp23 = tmp28
			}
			_ = tmp23
			return nil
		})
		tmp1.AddMethod(tmp19, tmp20)
		tmp21 := reflect.TypeOf(lang.NewChar(0))
		var tmp22 lang.FnFunc
		tmp22 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v23 := args[0]
			_ = v23
			v24 := args[1]
			_ = v24
			var tmp25 any
			var tmp26 any
			{ // let
				// let binding "or__0__auto__"
				tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
				var v28 any = tmp27
				_ = v28
				var tmp29 any
				if lang.IsTruthy(v28) {
					tmp29 = v28
				} else {
					tmp30 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_readably_STAR_)
					tmp29 = tmp30
				}
				tmp26 = tmp29
			} // end let
			if lang.IsTruthy(tmp26) {
				tmp27 := lang.Apply(lang.AppendWriter, []any{v24, lang.NewChar(92)})
				_ = tmp27
				var tmp28 any
				{ // let
					// let binding "n"
					tmp29 := checkDerefVar(var_glojure_DOT_core_char_DASH_name_DASH_string)
					tmp30 := lang.Apply(tmp29, []any{v23})
					var v31 any = tmp30
					_ = v31
					var tmp32 any
					if lang.IsTruthy(v31) {
						tmp33 := lang.Apply(lang.WriteWriter, []any{v24, v31})
						tmp32 = tmp33
					} else {
						tmp34 := lang.Apply(lang.AppendWriter, []any{v24, v23})
						tmp32 = tmp34
					}
					tmp28 = tmp32
				} // end let
				tmp25 = tmp28
			} else {
				tmp29 := lang.Apply(lang.AppendWriter, []any{v24, v23})
				tmp25 = tmp29
			}
			_ = tmp25
			return nil
		})
		tmp1.AddMethod(tmp21, tmp22)
		tmp23 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		var tmp24 lang.FnFunc
		tmp24 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v25 := args[0]
			_ = v25
			v26 := args[1]
			_ = v26
			tmp27 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp28 := lang.Apply(tmp27, []any{v25, v26})
			_ = tmp28
			var tmp29 any
			{ // let
				// let binding "vec__234"
				tmp30 := checkDerefVar(var_glojure_DOT_core_lift_DASH_ns)
				tmp31 := lang.Apply(tmp30, []any{v25})
				var v32 any = tmp31
				_ = v32
				// let binding "ns"
				tmp33 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp34 := lang.Apply(tmp33, []any{v32, int64(0), nil})
				var v35 any = tmp34
				_ = v35
				// let binding "lift-kvs"
				tmp36 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp37 := lang.Apply(tmp36, []any{v32, int64(1), nil})
				var v38 any = tmp37
				_ = v38
				var tmp39 any
				if lang.IsTruthy(v35) {
					tmp40 := checkDerefVar(var_glojure_DOT_core_print_DASH_prefix_DASH_map)
					tmp41 := checkDerefVar(var_glojure_DOT_core_str)
					tmp42 := lang.Apply(tmp41, []any{"#:", v35})
					tmp43 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
					tmp44 := lang.Apply(tmp40, []any{tmp42, v38, tmp43, v26})
					tmp39 = tmp44
				} else {
					tmp45 := checkDerefVar(var_glojure_DOT_core_print_DASH_map)
					tmp46 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
					tmp47 := lang.Apply(tmp45, []any{v25, tmp46, v26})
					tmp39 = tmp47
				}
				tmp29 = tmp39
			} // end let
			return tmp29
		})
		tmp1.AddMethod(tmp23, tmp24)
		tmp25 := reflect.TypeOf((*lang.IPersistentVector)(nil)).Elem()
		var tmp26 lang.FnFunc
		tmp26 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v27 := args[0]
			_ = v27
			v28 := args[1]
			_ = v28
			tmp29 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp30 := lang.Apply(tmp29, []any{v27, v28})
			_ = tmp30
			tmp31 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
			tmp32 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
			tmp33 := lang.Apply(tmp31, []any{"[", tmp32, " ", "]", v27, v28})
			return tmp33
		})
		tmp1.AddMethod(tmp25, tmp26)
		tmp27 := reflect.TypeOf((*lang.IPersistentSet)(nil)).Elem()
		var tmp28 lang.FnFunc
		tmp28 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v29 := args[0]
			_ = v29
			v30 := args[1]
			_ = v30
			tmp31 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp32 := lang.Apply(tmp31, []any{v29, v30})
			_ = tmp32
			tmp33 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
			tmp34 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
			tmp35 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp36 := lang.Apply(tmp35, []any{v29})
			tmp37 := lang.Apply(tmp33, []any{"#{", tmp34, " ", "}", tmp36, v30})
			return tmp37
		})
		tmp1.AddMethod(tmp27, tmp28)
		tmp29 := reflect.TypeOf(uint8(0))
		var tmp30 lang.FnFunc
		tmp30 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v31 := args[0]
			_ = v31
			v32 := args[1]
			_ = v32
			tmp33 := checkDerefVar(var_glojure_DOT_core_str)
			tmp34 := lang.Apply(tmp33, []any{v31})
			tmp35, _ := lang.FieldOrMethod(v32, "write")
			if reflect.TypeOf(tmp35).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp36 := lang.Apply(tmp35, []any{tmp34})
			return tmp36
		})
		tmp1.AddMethod(tmp29, tmp30)
		tmp31 := reflect.TypeOf((*lang.IDeref)(nil)).Elem()
		var tmp32 lang.FnFunc
		tmp32 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v33 := args[0]
			_ = v33
			v34 := args[1]
			_ = v34
			tmp35 := checkDerefVar(var_glojure_DOT_core_print_DASH_tagged_DASH_object)
			tmp36 := checkDerefVar(var_glojure_DOT_core_deref_DASH_as_DASH_map)
			tmp37 := lang.Apply(tmp36, []any{v33})
			tmp38 := lang.Apply(tmp35, []any{v33, tmp37, v34})
			return tmp38
		})
		tmp1.AddMethod(tmp31, tmp32)
		tmp33 := reflect.TypeOf(false)
		var tmp34 lang.FnFunc
		tmp34 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v35 := args[0]
			_ = v35
			v36 := args[1]
			_ = v36
			tmp37 := checkDerefVar(var_glojure_DOT_core_str)
			tmp38 := lang.Apply(tmp37, []any{v35})
			tmp39 := lang.Apply(lang.WriteWriter, []any{v36, tmp38})
			return tmp39
		})
		tmp1.AddMethod(tmp33, tmp34)
		tmp35 := reflect.TypeOf((*lang.Object)(nil)).Elem()
		var tmp36 lang.FnFunc
		tmp36 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v37 := args[0]
			_ = v37
			v38 := args[1]
			_ = v38
			tmp39 := checkDerefVar(var_glojure_DOT_core_print_DASH_object)
			tmp40 := lang.Apply(tmp39, []any{v37, v38})
			return tmp40
		})
		tmp1.AddMethod(tmp35, tmp36)
		tmp37 := reflect.TypeOf(int(0))
		var tmp38 lang.FnFunc
		tmp38 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v39 := args[0]
			_ = v39
			v40 := args[1]
			_ = v40
			tmp41 := checkDerefVar(var_glojure_DOT_core_str)
			tmp42 := lang.Apply(tmp41, []any{v39})
			tmp43, _ := lang.FieldOrMethod(v40, "write")
			if reflect.TypeOf(tmp43).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp44 := lang.Apply(tmp43, []any{tmp42})
			return tmp44
		})
		tmp1.AddMethod(tmp37, tmp38)
		tmp39 := reflect.TypeOf((*regexp15.Regexp)(nil))
		var tmp40 lang.FnFunc
		tmp40 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v41 := args[0]
			_ = v41
			v42 := args[1]
			_ = v42
			tmp43 := lang.Apply(lang.WriteWriter, []any{v42, "#\""})
			_ = tmp43
			var tmp44 any
			{ // let
				// let binding "G__240"
				tmp45 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp46, ok := lang.FieldOrMethod(v41, "String")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v41, "String")))
				}
				var tmp47 any
				switch reflect.TypeOf(tmp46).Kind() {
				case reflect.Func:
					tmp47 = lang.Apply(tmp46, nil)
				default:
					tmp47 = tmp46
				}
				tmp48 := lang.Apply(tmp45, []any{tmp47})
				var v49 any = tmp48
				_ = v49
				// let binding "vec__241"
				var v50 any = v49
				_ = v50
				// let binding "seq__242"
				tmp51 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp52 := lang.Apply(tmp51, []any{v50})
				var v53 any = tmp52
				_ = v53
				// let binding "first__243"
				tmp54 := checkDerefVar(var_glojure_DOT_core_first)
				tmp55 := lang.Apply(tmp54, []any{v53})
				var v56 any = tmp55
				_ = v56
				// let binding "seq__242"
				tmp57 := checkDerefVar(var_glojure_DOT_core_next)
				tmp58 := lang.Apply(tmp57, []any{v53})
				var v59 any = tmp58
				_ = v59
				// let binding "c"
				var v60 any = v56
				_ = v60
				// let binding "r"
				var v61 any = v59
				_ = v61
				// let binding "s"
				var v62 any = v50
				_ = v62
				// let binding "qmode"
				var v63 any = false
				_ = v63
				var tmp64 any
				{ // let
					// let binding "G__240"
					var v65 any = v49
					_ = v65
					// let binding "qmode"
					var v66 any = v63
					_ = v66
					for {
						var tmp67 any
						{ // let
							// let binding "vec__244"
							var v68 any = v65
							_ = v68
							// let binding "seq__245"
							tmp69 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp70 := lang.Apply(tmp69, []any{v68})
							var v71 any = tmp70
							_ = v71
							// let binding "first__246"
							tmp72 := checkDerefVar(var_glojure_DOT_core_first)
							tmp73 := lang.Apply(tmp72, []any{v71})
							var v74 any = tmp73
							_ = v74
							// let binding "seq__245"
							tmp75 := checkDerefVar(var_glojure_DOT_core_next)
							tmp76 := lang.Apply(tmp75, []any{v71})
							var v77 any = tmp76
							_ = v77
							// let binding "c"
							var v78 any = v74
							_ = v78
							// let binding "r"
							var v79 any = v77
							_ = v79
							// let binding "s"
							var v80 any = v68
							_ = v80
							// let binding "qmode"
							var v81 any = v66
							_ = v81
							var tmp82 any
							if lang.IsTruthy(v80) {
								var tmp83 any
								tmp84 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp85 := lang.Apply(tmp84, []any{v78, lang.NewChar(92)})
								if lang.IsTruthy(tmp85) {
									var tmp86 any
									{ // let
										// let binding "vec__247"
										var v87 any = v79
										_ = v87
										// let binding "seq__248"
										tmp88 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp89 := lang.Apply(tmp88, []any{v87})
										var v90 any = tmp89
										_ = v90
										// let binding "first__249"
										tmp91 := checkDerefVar(var_glojure_DOT_core_first)
										tmp92 := lang.Apply(tmp91, []any{v90})
										var v93 any = tmp92
										_ = v93
										// let binding "seq__248"
										tmp94 := checkDerefVar(var_glojure_DOT_core_next)
										tmp95 := lang.Apply(tmp94, []any{v90})
										var v96 any = tmp95
										_ = v96
										// let binding "c2"
										var v97 any = v93
										_ = v97
										// let binding "r2"
										var v98 any = v96
										_ = v98
										tmp99 := lang.Apply(lang.AppendWriter, []any{v42, lang.NewChar(92)})
										_ = tmp99
										tmp100 := lang.Apply(lang.AppendWriter, []any{v42, v97})
										_ = tmp100
										var tmp101 any
										if lang.IsTruthy(v81) {
											var tmp102 any = v98
											tmp104 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
											tmp105 := lang.Apply(tmp104, []any{v97, lang.NewChar(69)})
											var tmp103 any = tmp105
											v65 = tmp102
											v66 = tmp103
											continue
										} else {
											var tmp106 any = v98
											tmp108 := checkDerefVar(var_glojure_DOT_core__EQ_)
											tmp109 := lang.Apply(tmp108, []any{v97, lang.NewChar(81)})
											var tmp107 any = tmp109
											v65 = tmp106
											v66 = tmp107
											continue
										}
										tmp86 = tmp101
									} // end let
									tmp83 = tmp86
								} else {
									var tmp87 any
									tmp88 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp89 := lang.Apply(tmp88, []any{v78, lang.NewChar(34)})
									if lang.IsTruthy(tmp89) {
										var tmp90 any
										if lang.IsTruthy(v81) {
											tmp91 := lang.Apply(lang.WriteWriter, []any{v42, "\\E\\\"\\Q"})
											tmp90 = tmp91
										} else {
											tmp92 := lang.Apply(lang.WriteWriter, []any{v42, "\\\""})
											tmp90 = tmp92
										}
										_ = tmp90
										var tmp93 any = v79
										var tmp94 any = v81
										v65 = tmp93
										v66 = tmp94
										continue
									} else {
										var tmp95 any
										if lang.IsTruthy(kw_else) {
											tmp96 := lang.Apply(lang.AppendWriter, []any{v42, v78})
											_ = tmp96
											var tmp97 any = v79
											var tmp98 any = v81
											v65 = tmp97
											v66 = tmp98
											continue
										} else {
										}
										tmp87 = tmp95
									}
									tmp83 = tmp87
								}
								tmp82 = tmp83
							} else {
							}
							tmp67 = tmp82
						} // end let
						tmp64 = tmp67
						break
					}
				} // end let
				tmp44 = tmp64
			} // end let
			_ = tmp44
			tmp45 := lang.Apply(lang.AppendWriter, []any{v42, lang.NewChar(34)})
			return tmp45
		})
		tmp1.AddMethod(tmp39, tmp40)
		tmp41 := reflect.TypeOf(int32(0))
		var tmp42 lang.FnFunc
		tmp42 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v43 := args[0]
			_ = v43
			v44 := args[1]
			_ = v44
			tmp45 := checkDerefVar(var_glojure_DOT_core_str)
			tmp46 := lang.Apply(tmp45, []any{v43})
			tmp47, _ := lang.FieldOrMethod(v44, "write")
			if reflect.TypeOf(tmp47).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp48 := lang.Apply(tmp47, []any{tmp46})
			return tmp48
		})
		tmp1.AddMethod(tmp41, tmp42)
		tmp43 := reflect.TypeOf((*lang.Ratio)(nil))
		var tmp44 lang.FnFunc
		tmp44 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v45 := args[0]
			_ = v45
			v46 := args[1]
			_ = v46
			tmp47 := checkDerefVar(var_glojure_DOT_core_str)
			tmp48 := lang.Apply(tmp47, []any{v45})
			tmp49, _ := lang.FieldOrMethod(v46, "write")
			if reflect.TypeOf(tmp49).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp50 := lang.Apply(tmp49, []any{tmp48})
			return tmp50
		})
		tmp1.AddMethod(tmp43, tmp44)
		tmp45 := reflect.TypeOf(float32(0))
		var tmp46 lang.FnFunc
		tmp46 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v47 := args[0]
			_ = v47
			v48 := args[1]
			_ = v48
			var tmp49 any
			tmp50 := checkDerefVar(var_glojure_DOT_core__EQ_)
			tmp51 := lang.Apply(math7.Inf, []any{int64(1)})
			tmp52 := lang.Apply(lang.Builtins["float32"], []any{tmp51})
			tmp53 := lang.Apply(tmp50, []any{tmp52, v47})
			if lang.IsTruthy(tmp53) {
				tmp54 := lang.Apply(lang.WriteWriter, []any{v48, "##Inf"})
				tmp49 = tmp54
			} else {
				var tmp55 any
				tmp56 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp57 := lang.Apply(math7.Inf, []any{int64(-1)})
				tmp58 := lang.Apply(lang.Builtins["float32"], []any{tmp57})
				tmp59 := lang.Apply(tmp56, []any{tmp58, v47})
				if lang.IsTruthy(tmp59) {
					tmp60 := lang.Apply(lang.WriteWriter, []any{v48, "##-Inf"})
					tmp55 = tmp60
				} else {
					var tmp61 any
					tmp62 := lang.Apply(math7.IsNaN, []any{v47})
					if lang.IsTruthy(tmp62) {
						tmp63 := lang.Apply(lang.WriteWriter, []any{v48, "##NaN"})
						tmp61 = tmp63
					} else {
						var tmp64 any
						if lang.IsTruthy(kw_else) {
							tmp65 := checkDerefVar(var_glojure_DOT_core_str)
							tmp66 := lang.Apply(tmp65, []any{v47})
							tmp67 := lang.Apply(lang.WriteWriter, []any{v48, tmp66})
							tmp64 = tmp67
						} else {
						}
						tmp61 = tmp64
					}
					tmp55 = tmp61
				}
				tmp49 = tmp55
			}
			return tmp49
		})
		tmp1.AddMethod(tmp45, tmp46)
		tmp47 := reflect.TypeOf(int16(0))
		var tmp48 lang.FnFunc
		tmp48 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v49 := args[0]
			_ = v49
			v50 := args[1]
			_ = v50
			tmp51 := checkDerefVar(var_glojure_DOT_core_str)
			tmp52 := lang.Apply(tmp51, []any{v49})
			tmp53, _ := lang.FieldOrMethod(v50, "write")
			if reflect.TypeOf(tmp53).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp54 := lang.Apply(tmp53, []any{tmp52})
			return tmp54
		})
		tmp1.AddMethod(tmp47, tmp48)
		tmp49 := reflect.TypeOf((*lang.Var)(nil))
		var tmp50 lang.FnFunc
		tmp50 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v51 := args[0]
			_ = v51
			v52 := args[1]
			_ = v52
			tmp53 := checkDerefVar(var_glojure_DOT_core_print_DASH_simple)
			tmp54 := lang.Apply(tmp53, []any{v51, v52})
			return tmp54
		})
		tmp1.AddMethod(tmp49, tmp50)
		tmp51 := reflect.TypeOf(int8(0))
		var tmp52 lang.FnFunc
		tmp52 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v53 := args[0]
			_ = v53
			v54 := args[1]
			_ = v54
			tmp55 := checkDerefVar(var_glojure_DOT_core_str)
			tmp56 := lang.Apply(tmp55, []any{v53})
			tmp57, _ := lang.FieldOrMethod(v54, "write")
			if reflect.TypeOf(tmp57).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp58 := lang.Apply(tmp57, []any{tmp56})
			return tmp58
		})
		tmp1.AddMethod(tmp51, tmp52)
		tmp53 := reflect.TypeOf(uint16(0))
		var tmp54 lang.FnFunc
		tmp54 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v55 := args[0]
			_ = v55
			v56 := args[1]
			_ = v56
			tmp57 := checkDerefVar(var_glojure_DOT_core_str)
			tmp58 := lang.Apply(tmp57, []any{v55})
			tmp59, _ := lang.FieldOrMethod(v56, "write")
			if reflect.TypeOf(tmp59).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp60 := lang.Apply(tmp59, []any{tmp58})
			return tmp60
		})
		tmp1.AddMethod(tmp53, tmp54)
		tmp55 := reflect.TypeOf(uint64(0))
		var tmp56 lang.FnFunc
		tmp56 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v57 := args[0]
			_ = v57
			v58 := args[1]
			_ = v58
			tmp59 := checkDerefVar(var_glojure_DOT_core_str)
			tmp60 := lang.Apply(tmp59, []any{v57})
			tmp61, _ := lang.FieldOrMethod(v58, "write")
			if reflect.TypeOf(tmp61).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp62 := lang.Apply(tmp61, []any{tmp60})
			return tmp62
		})
		tmp1.AddMethod(tmp55, tmp56)
		tmp57 := reflect.TypeOf((*lang.BigDecimal)(nil))
		var tmp58 lang.FnFunc
		tmp58 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v59 := args[0]
			_ = v59
			v60 := args[1]
			_ = v60
			tmp61 := checkDerefVar(var_glojure_DOT_core_str)
			tmp62 := lang.Apply(tmp61, []any{v59})
			tmp63 := lang.Apply(lang.WriteWriter, []any{v60, tmp62})
			_ = tmp63
			tmp64 := lang.Apply(lang.WriteWriter, []any{v60, "M"})
			return tmp64
		})
		tmp1.AddMethod(tmp57, tmp58)
		tmp59 := reflect.TypeOf((*lang.BigInt)(nil))
		var tmp60 lang.FnFunc
		tmp60 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v61 := args[0]
			_ = v61
			v62 := args[1]
			_ = v62
			tmp63 := checkDerefVar(var_glojure_DOT_core_str)
			tmp64 := lang.Apply(tmp63, []any{v61})
			tmp65 := lang.Apply(lang.WriteWriter, []any{v62, tmp64})
			_ = tmp65
			tmp66 := lang.Apply(lang.WriteWriter, []any{v62, "N"})
			return tmp66
		})
		tmp1.AddMethod(tmp59, tmp60)
		tmp61 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		var tmp62 lang.FnFunc
		tmp62 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v63 := args[0]
			_ = v63
			v64 := args[1]
			_ = v64
			tmp65 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp66 := lang.Apply(tmp65, []any{v63, v64})
			_ = tmp66
			tmp67 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
			tmp68 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
			tmp69 := lang.Apply(tmp67, []any{"(", tmp68, " ", ")", v63, v64})
			return tmp69
		})
		tmp1.AddMethod(tmp61, tmp62)
		tmp63 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp64 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp1.PreferMethod(tmp63, tmp64)
		tmp65 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		tmp66 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		tmp1.PreferMethod(tmp65, tmp66)
		var_glojure_DOT_core_print_DASH_method = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_method.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-tagged-object
	{
		tmp0 := sym_print_DASH_tagged_DASH_object.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(102), kw_column, int(8), kw_end_DASH_line, int(102), kw_end_DASH_column, int(26), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_rep, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*lang.IMeta)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v2})
			if lang.IsTruthy(tmp8) {
				tmp9 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
				tmp10 := lang.Apply(tmp9, []any{v2, v4})
				tmp5 = tmp10
			} else {
			}
			_ = tmp5
			tmp11 := lang.Apply(lang.WriteWriter, []any{v4, "#object["})
			_ = tmp11
			var tmp12 any
			{ // let
				// let binding "c"
				tmp13 := checkDerefVar(var_glojure_DOT_core_class)
				tmp14 := lang.Apply(tmp13, []any{v2})
				var v15 any = tmp14
				_ = v15
				var tmp16 any
				if lang.IsTruthy(false) {
					tmp17 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
					tmp18, ok := lang.FieldOrMethod(v15, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v15, "Name")))
					}
					var tmp19 any
					switch reflect.TypeOf(tmp18).Kind() {
					case reflect.Func:
						tmp19 = lang.Apply(tmp18, nil)
					default:
						tmp19 = tmp18
					}
					tmp20 := lang.Apply(tmp17, []any{tmp19, v4})
					tmp16 = tmp20
				} else {
					tmp21, ok := lang.FieldOrMethod(v15, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v15, "Name")))
					}
					var tmp22 any
					switch reflect.TypeOf(tmp21).Kind() {
					case reflect.Func:
						tmp22 = lang.Apply(tmp21, nil)
					default:
						tmp22 = tmp21
					}
					tmp23 := lang.Apply(lang.WriteWriter, []any{v4, tmp22})
					tmp16 = tmp23
				}
				tmp12 = tmp16
			} // end let
			_ = tmp12
			tmp13 := lang.Apply(lang.WriteWriter, []any{v4, " "})
			_ = tmp13
			tmp14 := checkDerefVar(var_glojure_DOT_core_format)
			tmp15 := lang.Apply(lang.IdentityHash, []any{v2})
			tmp16 := lang.Apply(tmp14, []any{"0x%x ", tmp15})
			tmp17 := lang.Apply(lang.WriteWriter, []any{v4, tmp16})
			_ = tmp17
			tmp18 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp19 := lang.Apply(tmp18, []any{v3, v4})
			_ = tmp19
			tmp20 := lang.Apply(lang.WriteWriter, []any{v4, "]"})
			return tmp20
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_print_DASH_tagged_DASH_object = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_tagged_DASH_object.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-throwable
	{
		tmp0 := sym_print_DASH_throwable.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(478), kw_column, int(8), kw_end_DASH_line, int(478), kw_end_DASH_column, int(22), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(lang.WriteWriter, []any{v3, "#error {\n :cause "})
			_ = tmp4
			var tmp5 any
			{ // let
				// let binding "map__253"
				tmp6 := checkDerefVar(var_glojure_DOT_core_Throwable_DASH__GT_map)
				tmp7 := lang.Apply(tmp6, []any{v2})
				var v8 any = tmp7
				_ = v8
				// let binding "map__253"
				var tmp9 any
				tmp10 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
				tmp11 := lang.Apply(tmp10, []any{v8})
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					tmp13 := checkDerefVar(var_glojure_DOT_core_next)
					tmp14 := lang.Apply(tmp13, []any{v8})
					if lang.IsTruthy(tmp14) {
						tmp15 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
						tmp16 := lang.Apply(tmp15, []any{v8})
						tmp17 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp16})
						tmp12 = tmp17
					} else {
						var tmp18 any
						tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp20 := lang.Apply(tmp19, []any{v8})
						if lang.IsTruthy(tmp20) {
							tmp21 := checkDerefVar(var_glojure_DOT_core_first)
							tmp22 := lang.Apply(tmp21, []any{v8})
							tmp18 = tmp22
						} else {
						}
						tmp12 = tmp18
					}
					tmp9 = tmp12
				} else {
					tmp9 = v8
				}
				var v23 any = tmp9
				_ = v23
				// let binding "cause"
				tmp24 := checkDerefVar(var_glojure_DOT_core_get)
				tmp25 := lang.Apply(tmp24, []any{v23, kw_cause})
				var v26 any = tmp25
				_ = v26
				// let binding "data"
				tmp27 := checkDerefVar(var_glojure_DOT_core_get)
				tmp28 := lang.Apply(tmp27, []any{v23, kw_data})
				var v29 any = tmp28
				_ = v29
				// let binding "via"
				tmp30 := checkDerefVar(var_glojure_DOT_core_get)
				tmp31 := lang.Apply(tmp30, []any{v23, kw_via})
				var v32 any = tmp31
				_ = v32
				// let binding "trace"
				tmp33 := checkDerefVar(var_glojure_DOT_core_get)
				tmp34 := lang.Apply(tmp33, []any{v23, kw_trace})
				var v35 any = tmp34
				_ = v35
				// let binding "print-via"
				var tmp36 lang.FnFunc
				tmp36 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v37 := args[0]
					_ = v37
					tmp38 := lang.Apply(lang.WriteWriter, []any{v3, "{:type "})
					_ = tmp38
					tmp39 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
					tmp40 := lang.Apply(kw_type, []any{v37})
					tmp41 := lang.Apply(tmp39, []any{tmp40, v3})
					_ = tmp41
					tmp42 := lang.Apply(lang.WriteWriter, []any{v3, "\n   :message "})
					_ = tmp42
					tmp43 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
					tmp44 := lang.Apply(kw_message, []any{v37})
					tmp45 := lang.Apply(tmp43, []any{tmp44, v3})
					_ = tmp45
					var tmp46 any
					{ // let
						// let binding "temp__0__auto__"
						tmp47 := lang.Apply(kw_data, []any{v37})
						var v48 any = tmp47
						_ = v48
						var tmp49 any
						if lang.IsTruthy(v48) {
							var tmp50 any
							{ // let
								// let binding "data"
								var v51 any = v48
								_ = v51
								tmp52 := lang.Apply(lang.WriteWriter, []any{v3, "\n   :data "})
								_ = tmp52
								tmp53 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
								tmp54 := lang.Apply(tmp53, []any{v51, v3})
								tmp50 = tmp54
							} // end let
							tmp49 = tmp50
						} else {
						}
						tmp46 = tmp49
					} // end let
					_ = tmp46
					var tmp47 any
					{ // let
						// let binding "temp__0__auto__"
						tmp48 := lang.Apply(kw_at, []any{v37})
						var v49 any = tmp48
						_ = v49
						var tmp50 any
						if lang.IsTruthy(v49) {
							var tmp51 any
							{ // let
								// let binding "at"
								var v52 any = v49
								_ = v52
								tmp53 := lang.Apply(lang.WriteWriter, []any{v3, "\n   :at "})
								_ = tmp53
								tmp54 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
								tmp55 := lang.Apply(kw_at, []any{v37})
								tmp56 := lang.Apply(tmp54, []any{tmp55, v3})
								tmp51 = tmp56
							} // end let
							tmp50 = tmp51
						} else {
						}
						tmp47 = tmp50
					} // end let
					_ = tmp47
					tmp48 := lang.Apply(lang.WriteWriter, []any{v3, "}"})
					return tmp48
				})
				tmp37 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(481), kw_column, int(19), kw_end_DASH_line, int(491), kw_end_DASH_column, int(73))
				tmp38, err := lang.WithMeta(tmp36, tmp37.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v39 any = tmp38
				_ = v39
				tmp40 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
				tmp41 := lang.Apply(tmp40, []any{v26, v3})
				_ = tmp41
				var tmp42 any
				if lang.IsTruthy(v29) {
					tmp43 := lang.Apply(lang.WriteWriter, []any{v3, "\n :data "})
					_ = tmp43
					tmp44 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
					tmp45 := lang.Apply(tmp44, []any{v29, v3})
					tmp42 = tmp45
				} else {
				}
				_ = tmp42
				var tmp46 any
				if lang.IsTruthy(v32) {
					tmp47 := lang.Apply(lang.WriteWriter, []any{v3, "\n :via\n ["})
					_ = tmp47
					var tmp48 any
					{ // let
						// let binding "temp__0__auto__"
						tmp49 := checkDerefVar(var_glojure_DOT_core_first)
						tmp50 := lang.Apply(tmp49, []any{v32})
						var v51 any = tmp50
						_ = v51
						var tmp52 any
						if lang.IsTruthy(v51) {
							var tmp53 any
							{ // let
								// let binding "fv"
								var v54 any = v51
								_ = v54
								tmp55 := lang.Apply(v39, []any{v54})
								_ = tmp55
								var tmp56 any
								{ // let
									// let binding "seq_254"
									tmp57 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp58 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp59 := lang.Apply(tmp58, []any{v32})
									tmp60 := lang.Apply(tmp57, []any{tmp59})
									var v61 any = tmp60
									_ = v61
									// let binding "chunk_255"
									var v62 any = nil
									_ = v62
									// let binding "count_256"
									var v63 any = int64(0)
									_ = v63
									// let binding "i_257"
									var v64 any = int64(0)
									_ = v64
									for {
										var tmp65 any
										tmp66 := checkDerefVar(var_glojure_DOT_core__LT_)
										tmp67 := lang.Apply(tmp66, []any{v64, v63})
										if lang.IsTruthy(tmp67) {
											var tmp68 any
											{ // let
												// let binding "v"
												tmp69, _ := lang.FieldOrMethod(v62, "nth")
												if reflect.TypeOf(tmp69).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
												}
												tmp70 := lang.Apply(tmp69, []any{v64})
												var v71 any = tmp70
												_ = v71
												tmp72 := lang.Apply(lang.WriteWriter, []any{v3, "\n  "})
												_ = tmp72
												tmp73 := lang.Apply(v39, []any{v71})
												_ = tmp73
												var tmp74 any = v61
												var tmp75 any = v62
												var tmp76 any = v63
												tmp78 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
												tmp79 := lang.Apply(tmp78, []any{v64})
												var tmp77 any = tmp79
												v61 = tmp74
												v62 = tmp75
												v63 = tmp76
												v64 = tmp77
												continue
											} // end let
											tmp65 = tmp68
										} else {
											var tmp69 any
											{ // let
												// let binding "temp__0__auto__"
												tmp70 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp71 := lang.Apply(tmp70, []any{v61})
												var v72 any = tmp71
												_ = v72
												var tmp73 any
												if lang.IsTruthy(v72) {
													var tmp74 any
													{ // let
														// let binding "seq_254"
														var v75 any = v72
														_ = v75
														var tmp76 any
														tmp77 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
														tmp78 := lang.Apply(tmp77, []any{v75})
														if lang.IsTruthy(tmp78) {
															var tmp79 any
															{ // let
																// let binding "c__0__auto__"
																tmp80 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																tmp81 := lang.Apply(tmp80, []any{v75})
																var v82 any = tmp81
																_ = v82
																tmp84 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																tmp85 := lang.Apply(tmp84, []any{v75})
																var tmp83 any = tmp85
																var tmp86 any = v82
																tmp88 := checkDerefVar(var_glojure_DOT_core_int)
																tmp89 := checkDerefVar(var_glojure_DOT_core_count)
																tmp90 := lang.Apply(tmp89, []any{v82})
																tmp91 := lang.Apply(tmp88, []any{tmp90})
																var tmp87 any = tmp91
																tmp93 := checkDerefVar(var_glojure_DOT_core_int)
																tmp94 := lang.Apply(tmp93, []any{int64(0)})
																var tmp92 any = tmp94
																v61 = tmp83
																v62 = tmp86
																v63 = tmp87
																v64 = tmp92
																continue
															} // end let
															tmp76 = tmp79
														} else {
															var tmp80 any
															{ // let
																// let binding "v"
																tmp81 := checkDerefVar(var_glojure_DOT_core_first)
																tmp82 := lang.Apply(tmp81, []any{v75})
																var v83 any = tmp82
																_ = v83
																tmp84 := lang.Apply(lang.WriteWriter, []any{v3, "\n  "})
																_ = tmp84
																tmp85 := lang.Apply(v39, []any{v83})
																_ = tmp85
																tmp87 := checkDerefVar(var_glojure_DOT_core_next)
																tmp88 := lang.Apply(tmp87, []any{v75})
																var tmp86 any = tmp88
																var tmp89 any = nil
																var tmp90 any = int64(0)
																var tmp91 any = int64(0)
																v61 = tmp86
																v62 = tmp89
																v63 = tmp90
																v64 = tmp91
																continue
															} // end let
															tmp76 = tmp80
														}
														tmp74 = tmp76
													} // end let
													tmp73 = tmp74
												} else {
												}
												tmp69 = tmp73
											} // end let
											tmp65 = tmp69
										}
										tmp56 = tmp65
										break
									}
								} // end let
								tmp53 = tmp56
							} // end let
							tmp52 = tmp53
						} else {
						}
						tmp48 = tmp52
					} // end let
					_ = tmp48
					tmp49 := lang.Apply(lang.WriteWriter, []any{v3, "]"})
					tmp46 = tmp49
				} else {
				}
				_ = tmp46
				var tmp50 any
				if lang.IsTruthy(v35) {
					tmp51 := lang.Apply(lang.WriteWriter, []any{v3, "\n :trace\n ["})
					_ = tmp51
					var tmp52 any
					{ // let
						// let binding "temp__0__auto__"
						tmp53 := checkDerefVar(var_glojure_DOT_core_first)
						tmp54 := lang.Apply(tmp53, []any{v35})
						var v55 any = tmp54
						_ = v55
						var tmp56 any
						if lang.IsTruthy(v55) {
							var tmp57 any
							{ // let
								// let binding "ft"
								var v58 any = v55
								_ = v58
								tmp59 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
								tmp60 := lang.Apply(tmp59, []any{v58, v3})
								_ = tmp60
								var tmp61 any
								{ // let
									// let binding "seq_258"
									tmp62 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp63 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp64 := lang.Apply(tmp63, []any{v35})
									tmp65 := lang.Apply(tmp62, []any{tmp64})
									var v66 any = tmp65
									_ = v66
									// let binding "chunk_259"
									var v67 any = nil
									_ = v67
									// let binding "count_260"
									var v68 any = int64(0)
									_ = v68
									// let binding "i_261"
									var v69 any = int64(0)
									_ = v69
									for {
										var tmp70 any
										tmp71 := checkDerefVar(var_glojure_DOT_core__LT_)
										tmp72 := lang.Apply(tmp71, []any{v69, v68})
										if lang.IsTruthy(tmp72) {
											var tmp73 any
											{ // let
												// let binding "t"
												tmp74, _ := lang.FieldOrMethod(v67, "nth")
												if reflect.TypeOf(tmp74).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
												}
												tmp75 := lang.Apply(tmp74, []any{v69})
												var v76 any = tmp75
												_ = v76
												tmp77 := lang.Apply(lang.WriteWriter, []any{v3, "\n  "})
												_ = tmp77
												tmp78 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
												tmp79 := lang.Apply(tmp78, []any{v76, v3})
												_ = tmp79
												var tmp80 any = v66
												var tmp81 any = v67
												var tmp82 any = v68
												tmp84 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
												tmp85 := lang.Apply(tmp84, []any{v69})
												var tmp83 any = tmp85
												v66 = tmp80
												v67 = tmp81
												v68 = tmp82
												v69 = tmp83
												continue
											} // end let
											tmp70 = tmp73
										} else {
											var tmp74 any
											{ // let
												// let binding "temp__0__auto__"
												tmp75 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp76 := lang.Apply(tmp75, []any{v66})
												var v77 any = tmp76
												_ = v77
												var tmp78 any
												if lang.IsTruthy(v77) {
													var tmp79 any
													{ // let
														// let binding "seq_258"
														var v80 any = v77
														_ = v80
														var tmp81 any
														tmp82 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
														tmp83 := lang.Apply(tmp82, []any{v80})
														if lang.IsTruthy(tmp83) {
															var tmp84 any
															{ // let
																// let binding "c__0__auto__"
																tmp85 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																tmp86 := lang.Apply(tmp85, []any{v80})
																var v87 any = tmp86
																_ = v87
																tmp89 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																tmp90 := lang.Apply(tmp89, []any{v80})
																var tmp88 any = tmp90
																var tmp91 any = v87
																tmp93 := checkDerefVar(var_glojure_DOT_core_int)
																tmp94 := checkDerefVar(var_glojure_DOT_core_count)
																tmp95 := lang.Apply(tmp94, []any{v87})
																tmp96 := lang.Apply(tmp93, []any{tmp95})
																var tmp92 any = tmp96
																tmp98 := checkDerefVar(var_glojure_DOT_core_int)
																tmp99 := lang.Apply(tmp98, []any{int64(0)})
																var tmp97 any = tmp99
																v66 = tmp88
																v67 = tmp91
																v68 = tmp92
																v69 = tmp97
																continue
															} // end let
															tmp81 = tmp84
														} else {
															var tmp85 any
															{ // let
																// let binding "t"
																tmp86 := checkDerefVar(var_glojure_DOT_core_first)
																tmp87 := lang.Apply(tmp86, []any{v80})
																var v88 any = tmp87
																_ = v88
																tmp89 := lang.Apply(lang.WriteWriter, []any{v3, "\n  "})
																_ = tmp89
																tmp90 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
																tmp91 := lang.Apply(tmp90, []any{v88, v3})
																_ = tmp91
																tmp93 := checkDerefVar(var_glojure_DOT_core_next)
																tmp94 := lang.Apply(tmp93, []any{v80})
																var tmp92 any = tmp94
																var tmp95 any = nil
																var tmp96 any = int64(0)
																var tmp97 any = int64(0)
																v66 = tmp92
																v67 = tmp95
																v68 = tmp96
																v69 = tmp97
																continue
															} // end let
															tmp81 = tmp85
														}
														tmp79 = tmp81
													} // end let
													tmp78 = tmp79
												} else {
												}
												tmp74 = tmp78
											} // end let
											tmp70 = tmp74
										}
										tmp61 = tmp70
										break
									}
								} // end let
								tmp57 = tmp61
							} // end let
							tmp56 = tmp57
						} else {
						}
						tmp52 = tmp56
					} // end let
					_ = tmp52
					tmp53 := lang.Apply(lang.WriteWriter, []any{v3, "]"})
					tmp50 = tmp53
				} else {
				}
				tmp5 = tmp50
			} // end let
			_ = tmp5
			tmp6 := lang.Apply(lang.WriteWriter, []any{v3, "}"})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_print_DASH_throwable = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_throwable.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-object
	{
		tmp0 := sym_print_DASH_object.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(115), kw_column, int(8), kw_end_DASH_line, int(115), kw_end_DASH_column, int(19), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_print_DASH_tagged_DASH_object)
			tmp5 := checkDerefVar(var_glojure_DOT_core_str)
			tmp6 := lang.Apply(tmp5, []any{v2})
			tmp7 := lang.Apply(tmp4, []any{v2, tmp6, v3})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_print_DASH_object = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_print_DASH_object.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read
	{
		tmp0 := sym_read.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_stream), lang.NewVector(sym_stream, sym_eof_DASH_error_QMARK_, sym_eof_DASH_value), lang.NewVector(sym_stream, sym_eof_DASH_error_QMARK_, sym_eof_DASH_value, sym_recursive_QMARK_), lang.NewVector(sym_opts, sym_stream)), kw_doc, "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n  Note that read can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use glojure.edn/read", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3742), kw_end_DASH_line, int(3742))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_glojure_DOT_core_read)
				tmp3 := checkDerefVar(var_glojure_DOT_core__STAR_in_STAR_)
				tmp4 := lang.Apply(tmp2, []any{tmp3})
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_read)
				tmp4 := lang.Apply(tmp3, []any{v2, true, nil})
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_read)
				tmp6 := lang.Apply(tmp5, []any{v2, v3, v4, false})
				return tmp6
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_boolean)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8, _ := lang.FieldOrMethod(nil, "read")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("read is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v2, tmp7, v4, v5})
				return tmp9
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(nil, "read")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("read is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v3, v2})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_read = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_read.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read-line
	{
		tmp0 := sym_read_DASH_line.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Reads the next line from stream that is the current value of *in* .", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3797), kw_end_DASH_line, int(3797))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			var tmp2 any
			tmp3 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp4 := checkDerefVar(var_glojure_DOT_core__STAR_in_STAR_)
			tmp5 := lang.Apply(tmp3, []any{nil, tmp4})
			if lang.IsTruthy(tmp5) {
				tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_in_STAR_)
				tmp7, ok := lang.FieldOrMethod(tmp6, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp6, "readLine")))
				}
				var tmp8 any
				switch reflect.TypeOf(tmp7).Kind() {
				case reflect.Func:
					tmp8 = lang.Apply(tmp7, nil)
				default:
					tmp8 = tmp7
				}
				tmp2 = tmp8
			} else {
				tmp9 := checkDerefVar(var_glojure_DOT_core__STAR_in_STAR_)
				tmp10, ok := lang.FieldOrMethod(tmp9, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp9, "readLine")))
				}
				var tmp11 any
				switch reflect.TypeOf(tmp10).Kind() {
				case reflect.Func:
					tmp11 = lang.Apply(tmp10, nil)
				default:
					tmp11 = tmp10
				}
				tmp2 = tmp11
			}
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_read_DASH_line = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_read_DASH_line.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read+string
	{
		tmp0 := sym_read_PLUS_string.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_stream), lang.NewVector(sym_stream, sym_eof_DASH_error_QMARK_, sym_eof_DASH_value), lang.NewVector(sym_stream, sym_eof_DASH_error_QMARK_, sym_eof_DASH_value, sym_recursive_QMARK_), lang.NewVector(sym_opts, sym_stream)), kw_doc, "Like read, and taking the same args. stream must be a LineNumberingPushbackReader.\n  Returns a vector containing the object read and the (whitespace-trimmed) string read.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(3771), kw_end_DASH_line, int(3771))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_glojure_DOT_core_read_PLUS_string)
				tmp3 := checkDerefVar(var_glojure_DOT_core__STAR_in_STAR_)
				tmp4 := lang.Apply(tmp2, []any{tmp3})
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_read_PLUS_string)
				tmp4 := lang.Apply(tmp3, []any{v2, true, nil})
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_read_PLUS_string)
				tmp6 := lang.Apply(tmp5, []any{v2, v3, v4, false})
				return tmp6
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var tmp6 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							if lang.CatchMatches(r, lang.Throwable) {
								v7 := r
								_ = v7
								tmp8, ok := lang.FieldOrMethod(v2, "getString")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getString")))
								}
								var tmp9 any
								switch reflect.TypeOf(tmp8).Kind() {
								case reflect.Func:
									tmp9 = lang.Apply(tmp8, nil)
								default:
									tmp9 = tmp8
								}
								_ = tmp9
								panic(v7)
							} else {
								panic(r)
							}
						}
					}()
					tmp7, ok := lang.FieldOrMethod(v2, "captureString")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "captureString")))
					}
					var tmp8 any
					switch reflect.TypeOf(tmp7).Kind() {
					case reflect.Func:
						tmp8 = lang.Apply(tmp7, nil)
					default:
						tmp8 = tmp7
					}
					_ = tmp8
					var tmp9 any
					{ // let
						// let binding "o"
						tmp10 := checkDerefVar(var_glojure_DOT_core_read)
						tmp11 := lang.Apply(tmp10, []any{v2, v3, v4, v5})
						var v12 any = tmp11
						_ = v12
						// let binding "s"
						tmp13, ok := lang.FieldOrMethod(v2, "getString")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getString")))
						}
						var tmp14 any
						switch reflect.TypeOf(tmp13).Kind() {
						case reflect.Func:
							tmp14 = lang.Apply(tmp13, nil)
						default:
							tmp14 = tmp13
						}
						tmp15, ok := lang.FieldOrMethod(tmp14, "trim")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp14, "trim")))
						}
						var tmp16 any
						switch reflect.TypeOf(tmp15).Kind() {
						case reflect.Func:
							tmp16 = lang.Apply(tmp15, nil)
						default:
							tmp16 = tmp15
						}
						var v17 any = tmp16
						_ = v17
						tmp18 := lang.NewVector(v12, v17)
						tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3783), kw_column, int(8), kw_end_DASH_line, int(3783), kw_end_DASH_column, int(12))
						tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp20
					} // end let
					tmp6 = tmp9
				}()
				return tmp6
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							if lang.CatchMatches(r, lang.Throwable) {
								v5 := r
								_ = v5
								tmp6, ok := lang.FieldOrMethod(v3, "getString")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getString")))
								}
								var tmp7 any
								switch reflect.TypeOf(tmp6).Kind() {
								case reflect.Func:
									tmp7 = lang.Apply(tmp6, nil)
								default:
									tmp7 = tmp6
								}
								_ = tmp7
								panic(v5)
							} else {
								panic(r)
							}
						}
					}()
					tmp5, ok := lang.FieldOrMethod(v3, "captureString")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "captureString")))
					}
					var tmp6 any
					switch reflect.TypeOf(tmp5).Kind() {
					case reflect.Func:
						tmp6 = lang.Apply(tmp5, nil)
					default:
						tmp6 = tmp5
					}
					_ = tmp6
					var tmp7 any
					{ // let
						// let binding "o"
						tmp8 := checkDerefVar(var_glojure_DOT_core_read)
						tmp9 := lang.Apply(tmp8, []any{v2, v3})
						var v10 any = tmp9
						_ = v10
						// let binding "s"
						tmp11, ok := lang.FieldOrMethod(v3, "getString")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getString")))
						}
						var tmp12 any
						switch reflect.TypeOf(tmp11).Kind() {
						case reflect.Func:
							tmp12 = lang.Apply(tmp11, nil)
						default:
							tmp12 = tmp11
						}
						tmp13, ok := lang.FieldOrMethod(tmp12, "trim")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp12, "trim")))
						}
						var tmp14 any
						switch reflect.TypeOf(tmp13).Kind() {
						case reflect.Func:
							tmp14 = lang.Apply(tmp13, nil)
						default:
							tmp14 = tmp13
						}
						var v15 any = tmp14
						_ = v15
						tmp16 := lang.NewVector(v10, v15)
						tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3792), kw_column, int(8), kw_end_DASH_line, int(3792), kw_end_DASH_column, int(12))
						tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp7 = tmp18
					} // end let
					tmp4 = tmp7
				}()
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_read_PLUS_string = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_read_PLUS_string.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce
	{
		tmp0 := sym_reduce.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_val, sym_coll)), kw_doc, "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6860), kw_end_DASH_line, int(6860))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.IReduce)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
				if lang.IsTruthy(tmp7) {
					tmp8, _ := lang.FieldOrMethod(v3, "Reduce")
					if reflect.TypeOf(tmp8).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Reduce is not a function")))
					}
					tmp9 := lang.Apply(tmp8, []any{v2})
					tmp4 = tmp9
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_coll_DASH_reduce)
					tmp11 := lang.Apply(tmp10, []any{v3, v2})
					tmp4 = tmp11
				}
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
				if lang.IsTruthy(tmp8) {
					tmp9, _ := lang.FieldOrMethod(v4, "ReduceInit")
					if reflect.TypeOf(tmp9).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
					}
					tmp10 := lang.Apply(tmp9, []any{v2, v3})
					tmp5 = tmp10
				} else {
					tmp11 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_coll_DASH_reduce)
					tmp12 := lang.Apply(tmp11, []any{v4, v2, v3})
					tmp5 = tmp12
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// run!
	{
		tmp0 := sym_run_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_proc, sym_coll)), kw_doc, "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(7708), kw_end_DASH_line, int(7708))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_reduce)
			var tmp5 lang.FnFunc
			tmp5 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v6 := args[0]
				_ = v6
				v7 := args[1]
				_ = v7
				tmp8 := lang.Apply(v2, []any{v7})
				return tmp8
			})
			tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7713), kw_column, int(11), kw_end_DASH_line, int(7713), kw_end_DASH_column, int(20))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp8 := lang.Apply(tmp4, []any{tmp7, nil, v3})
			_ = tmp8
			return nil
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_run_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_run_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce-kv
	{
		tmp0 := sym_reduce_DASH_kv.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_init, sym_coll)), kw_doc, "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(6882), kw_end_DASH_line, int(6882))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_kv_DASH_reduce)
			tmp6 := lang.Apply(tmp5, []any{v4, v2, v3})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_reduce_DASH_kv = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_reduce_DASH_kv.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-keys
	{
		tmp0 := sym_update_DASH_keys.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_f)), kw_doc, "m f => {(f k) v ...}\n\n  Given a map m and a function f of 1-argument, returns a new map whose\n  keys are the result of applying f to the keys of m, mapped to the\n  corresponding values of m.\n  f must return a unique key for each key of m, else the behavior is undefined.", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(7906), kw_end_DASH_line, int(7906))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
				tmp6 := checkDerefVar(var_glojure_DOT_core_reduce_DASH_kv)
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 3)
					v8 := args[0]
					_ = v8
					v9 := args[1]
					_ = v9
					v10 := args[2]
					_ = v10
					tmp11 := checkDerefVar(var_glojure_DOT_core_assoc_BANG_)
					tmp12 := lang.Apply(v3, []any{v9})
					tmp13 := lang.Apply(tmp11, []any{v8, tmp12, v10})
					return tmp13
				})
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7916), kw_column, int(25), kw_end_DASH_line, int(7916), kw_end_DASH_column, int(59))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp11 := lang.NewMap()
				tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7917), kw_column, int(36), kw_end_DASH_line, int(7917), kw_end_DASH_column, int(37))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.Apply(tmp10, []any{tmp13})
				tmp15 := lang.Apply(tmp6, []any{tmp9, tmp14, v2})
				tmp16 := lang.Apply(tmp5, []any{tmp15})
				var v17 any = tmp16
				_ = v17
				tmp18 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
				tmp19 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp20 := lang.Apply(tmp19, []any{v2})
				tmp21 := lang.Apply(tmp18, []any{v17, tmp20})
				tmp4 = tmp21
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_update_DASH_keys = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_update_DASH_keys.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-vals
	{
		tmp0 := sym_update_DASH_vals.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_f)), kw_doc, "m f => {k (f v) ...}\n\n  Given a map m and a function f of 1-argument, returns a new map where the keys of m\n  are mapped to result of applying f to the corresponding values of m.", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(7890), kw_end_DASH_line, int(7890))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
			tmp5 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
			tmp6 := checkDerefVar(var_glojure_DOT_core_reduce_DASH_kv)
			var tmp7 lang.FnFunc
			tmp7 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 3)
				v8 := args[0]
				_ = v8
				v9 := args[1]
				_ = v9
				v10 := args[2]
				_ = v10
				tmp11 := checkDerefVar(var_glojure_DOT_core_assoc_BANG_)
				tmp12 := lang.Apply(v3, []any{v10})
				tmp13 := lang.Apply(tmp11, []any{v8, v9, tmp12})
				return tmp13
			})
			tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7899), kw_column, int(17), kw_end_DASH_line, int(7899), kw_end_DASH_column, int(51))
			tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp10 any
			tmp11 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp12 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
			tmp13 := lang.Apply(tmp11, []any{tmp12, v2})
			if lang.IsTruthy(tmp13) {
				tmp14 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp15 := lang.Apply(tmp14, []any{v2})
				tmp10 = tmp15
			} else {
				tmp16 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp17 := lang.NewMap()
				tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7902), kw_column, int(30), kw_end_DASH_line, int(7902), kw_end_DASH_column, int(31))
				tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp20 := lang.Apply(tmp16, []any{tmp19})
				tmp10 = tmp20
			}
			tmp21 := lang.Apply(tmp6, []any{tmp9, tmp10, v2})
			tmp22 := lang.Apply(tmp5, []any{tmp21})
			tmp23 := checkDerefVar(var_glojure_DOT_core_meta)
			tmp24 := lang.Apply(tmp23, []any{v2})
			tmp25 := lang.Apply(tmp4, []any{tmp22, tmp24})
			return tmp25
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_update_DASH_vals = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_update_DASH_vals.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// slurp
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_slurp.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_f, sym__AMP_, sym_opts)), kw_doc, "Opens a reader on f and reads all its contents, returning a string.\n  See glojure.java.io/reader for a complete list of supported arguments.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(6982), kw_end_DASH_line, int(6982))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "opts"
					tmp6 := checkDerefVar(var_glojure_DOT_core_normalize_DASH_slurp_DASH_opts)
					tmp7 := lang.Apply(tmp6, []any{v4})
					var v8 any = tmp7
					_ = v8
					// let binding "sw"
					tmp9 := new(strings11.Builder)
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					{ // let
						// let binding "r"
						tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp13 := checkDerefVar(var_glojure_DOT_go_DOT_io_reader)
						tmp14 := lang.Apply(tmp12, []any{tmp13, v3, v8})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						func() {
							defer func() {
								tmp17, ok := lang.FieldOrMethod(v15, "close")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v15, "close")))
								}
								var tmp18 any
								switch reflect.TypeOf(tmp17).Kind() {
								case reflect.Func:
									tmp18 = lang.Apply(tmp17, nil)
								default:
									tmp18 = tmp17
								}
								_ = tmp18
							}()
							tmp19 := checkDerefVar(var_glojure_DOT_go_DOT_io_copy)
							tmp20 := lang.Apply(tmp19, []any{v15, v10})
							_ = tmp20
							tmp21 := lang.Apply(lang.ToString, []any{v10})
							tmp16 = tmp21
						}()
						tmp11 = tmp16
					} // end let
					tmp5 = tmp11
				} // end let
				return tmp5
			}
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_core_slurp = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_slurp.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// transduce
	{
		tmp0 := sym_transduce.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xform, sym_f, sym_coll), lang.NewVector(sym_xform, sym_f, sym_init, sym_coll)), kw_doc, "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(6905), kw_end_DASH_line, int(6905))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_transduce)
				tmp6 := lang.Apply(v3, nil)
				tmp7 := lang.Apply(tmp5, []any{v2, v3, tmp6, v4})
				return tmp7
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "f"
					tmp7 := lang.Apply(v2, []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "ret"
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp11 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
					tmp12 := lang.Apply(tmp10, []any{tmp11, v5})
					if lang.IsTruthy(tmp12) {
						tmp13, _ := lang.FieldOrMethod(v5, "ReduceInit")
						if reflect.TypeOf(tmp13).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
						}
						tmp14 := lang.Apply(tmp13, []any{v8, v4})
						tmp9 = tmp14
					} else {
						tmp15 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_coll_DASH_reduce)
						tmp16 := lang.Apply(tmp15, []any{v5, v8, v4})
						tmp9 = tmp16
					}
					var v17 any = tmp9
					_ = v17
					tmp18 := lang.Apply(v8, []any{v17})
					tmp6 = tmp18
				} // end let
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_core_transduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_core_transduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}

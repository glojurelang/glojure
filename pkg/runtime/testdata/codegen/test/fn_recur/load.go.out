// Code generated by glojure codegen. DO NOT EDIT.

package fn_DASH_recur

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	reflect "reflect"
)

func init() {
	runtime.RegisterNSLoader("codegen/test/fn_recur", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "codegen.test.fn-recur"
func LoadNS() {
	sym__PLUS_ := lang.NewSymbol("+")
	sym__DASH_main := lang.NewSymbol("-main")
	sym__EQ_ := lang.NewSymbol("=")
	sym_codegen_DOT_test_DOT_fn_DASH_recur := lang.NewSymbol("codegen.test.fn-recur")
	sym_fib := lang.NewSymbol("fib")
	sym_glojure_DOT_core := lang.NewSymbol("glojure.core")
	sym_inc := lang.NewSymbol("inc")
	sym_n := lang.NewSymbol("n")
	kw_arglists := lang.NewKeyword("arglists")
	kw_column := lang.NewKeyword("column")
	kw_doc := lang.NewKeyword("doc")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_expected_DASH_output := lang.NewKeyword("expected-output")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_ns := lang.NewKeyword("ns")
	kw_rettag := lang.NewKeyword("rettag")
	// var codegen.test.fn-recur/-main
	var_codegen_DOT_test_DOT_fn_DASH_recur__DASH_main := lang.InternVarName(sym_codegen_DOT_test_DOT_fn_DASH_recur, sym__DASH_main)
	// var codegen.test.fn-recur/fib
	var_codegen_DOT_test_DOT_fn_DASH_recur_fib := lang.InternVarName(sym_codegen_DOT_test_DOT_fn_DASH_recur, sym_fib)
	// var glojure.core/=
	var_glojure_DOT_core__EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym__EQ_)
	// var glojure.core/+
	var_glojure_DOT_core__PLUS_ := lang.InternVarName(sym_glojure_DOT_core, sym__PLUS_)
	// var glojure.core/inc
	var_glojure_DOT_core_inc := lang.InternVarName(sym_glojure_DOT_core, sym_inc)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_codegen_DOT_test_DOT_fn_DASH_recur)
	_ = ns
	// -main
	{
		tmp0 := sym__DASH_main.WithMeta(lang.NewMap(kw_expected_DASH_output, int64(55), kw_file, "codegen/test/fn_recur.glj", kw_line, int(12), kw_column, int(7), kw_end_DASH_line, int(12), kw_end_DASH_column, int(34), kw_arglists, lang.NewList(lang.NewVector()), kw_ns, lang.FindOrCreateNamespace(sym_codegen_DOT_test_DOT_fn_DASH_recur))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_codegen_DOT_test_DOT_fn_DASH_recur_fib)
			tmp3 := lang.Apply(tmp2, []any{int64(10)})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_codegen_DOT_test_DOT_fn_DASH_recur__DASH_main = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_codegen_DOT_test_DOT_fn_DASH_recur__DASH_main.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fib
	{
		tmp0 := sym_fib.WithMeta(lang.NewMap(kw_file, "codegen/test/fn_recur.glj", kw_line, int(3), kw_column, int(7), kw_end_DASH_line, int(3), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Calculates the nth Fibonacci number using iteration with recur.", kw_ns, lang.FindOrCreateNamespace(sym_codegen_DOT_test_DOT_fn_DASH_recur))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "fib-helper"
				var tmp4 lang.FnFunc
				{ // function fib-helper
					var v5 lang.FnFunc
					tmp4 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 3)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
					recur_loop_1619:
						var tmp9 any
						tmp10 := checkDerefVar(var_glojure_DOT_core__EQ_)
						tmp11 := lang.Apply(tmp10, []any{v8, v2})
						if lang.IsTruthy(tmp11) {
							tmp9 = v6
						} else {
							var tmp12 any = v7
							tmp14 := checkDerefVar(var_glojure_DOT_core__PLUS_)
							tmp15 := lang.Apply(tmp14, []any{v6, v7})
							var tmp13 any = tmp15
							tmp17 := checkDerefVar(var_glojure_DOT_core_inc)
							tmp18 := lang.Apply(tmp17, []any{v8})
							var tmp16 any = tmp18
							v6 = tmp12
							v7 = tmp13
							v8 = tmp16
							goto recur_loop_1619
						}
						return tmp9
					})
					v5 = tmp4
					_ = v5
				}
				tmp5 := lang.NewMap(kw_file, "codegen/test/fn_recur.glj", kw_line, int(6), kw_column, int(20), kw_end_DASH_line, int(9), kw_end_DASH_column, int(50))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v7 any = tmp6
				_ = v7
				tmp8 := lang.Apply(v7, []any{int64(0), int64(1), int64(0)})
				tmp3 = tmp8
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_codegen_DOT_test_DOT_fn_DASH_recur_fib = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_codegen_DOT_test_DOT_fn_DASH_recur_fib.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}

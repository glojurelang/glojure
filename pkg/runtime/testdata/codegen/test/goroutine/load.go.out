// Code generated by glojure codegen. DO NOT EDIT.

package goroutine

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	reflect "reflect"
)

func init() {
	runtime.RegisterNSLoader("codegen/test/goroutine", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "codegen.test.goroutine"
func LoadNS() {
	sym__DASH_main := lang.NewSymbol("-main")
	sym_ch := lang.NewSymbol("ch")
	sym_codegen_DOT_test_DOT_goroutine := lang.NewSymbol("codegen.test.goroutine")
	sym_glojure_DOT_core := lang.NewSymbol("glojure.core")
	sym_not := lang.NewSymbol("not")
	sym_nth := lang.NewSymbol("nth")
	sym_send_DASH_on_DASH_chan := lang.NewSymbol("send-on-chan")
	sym_val := lang.NewSymbol("val")
	kw_arglists := lang.NewKeyword("arglists")
	kw_column := lang.NewKeyword("column")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_expected_DASH_output := lang.NewKeyword("expected-output")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_ns := lang.NewKeyword("ns")
	kw_rettag := lang.NewKeyword("rettag")
	// var codegen.test.goroutine/-main
	var_codegen_DOT_test_DOT_goroutine__DASH_main := lang.InternVarName(sym_codegen_DOT_test_DOT_goroutine, sym__DASH_main)
	// var codegen.test.goroutine/send-on-chan
	var_codegen_DOT_test_DOT_goroutine_send_DASH_on_DASH_chan := lang.InternVarName(sym_codegen_DOT_test_DOT_goroutine, sym_send_DASH_on_DASH_chan)
	// var glojure.core/not
	var_glojure_DOT_core_not := lang.InternVarName(sym_glojure_DOT_core, sym_not)
	// var glojure.core/nth
	var_glojure_DOT_core_nth := lang.InternVarName(sym_glojure_DOT_core, sym_nth)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_codegen_DOT_test_DOT_goroutine)
	_ = ns
	// send-on-chan
	{
		tmp0 := sym_send_DASH_on_DASH_chan.WithMeta(lang.NewMap(kw_file, "codegen/test/goroutine.glj", kw_line, int(3), kw_column, int(7), kw_end_DASH_line, int(3), kw_end_DASH_column, int(18), kw_arglists, lang.NewList(lang.NewVector(sym_ch, sym_val)), kw_ns, lang.FindOrCreateNamespace(sym_codegen_DOT_test_DOT_goroutine))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "chVal"
				tmp5 := lang.Apply(reflect.ValueOf, []any{v2})
				var v6 any = tmp5
				_ = v6
				// let binding "valVal"
				tmp7 := lang.Apply(reflect.ValueOf, []any{v3})
				var v8 any = tmp7
				_ = v8
				tmp9, _ := lang.FieldOrMethod(v6, "Send")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Send is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{v8})
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_codegen_DOT_test_DOT_goroutine_send_DASH_on_DASH_chan = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_codegen_DOT_test_DOT_goroutine_send_DASH_on_DASH_chan.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -main
	{
		tmp0 := sym__DASH_main.WithMeta(lang.NewMap(kw_expected_DASH_output, int64(42), kw_file, "codegen/test/goroutine.glj", kw_line, int(8), kw_column, int(7), kw_end_DASH_line, int(8), kw_end_DASH_column, int(34), kw_arglists, lang.NewList(lang.NewVector()), kw_ns, lang.FindOrCreateNamespace(sym_codegen_DOT_test_DOT_goroutine))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			var tmp2 any
			{ // let
				// let binding "ch"
				tmp3 := lang.Apply(lang.Builtins["chan-of"], []any{lang.Builtins["int64"]})
				tmp4 := lang.Apply(lang.Builtins["make"], []any{tmp3})
				var v5 any = tmp4
				_ = v5
				// let binding "chVal"
				tmp6 := lang.Apply(reflect.ValueOf, []any{v5})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(var_codegen_DOT_test_DOT_goroutine_send_DASH_on_DASH_chan)
				go lang.Apply(tmp8, []any{v5, int64(42)})
				var tmp9 any
				{ // let
					// let binding "vec__368"
					tmp10, ok := lang.FieldOrMethod(v7, "Recv")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "Recv")))
					}
					var tmp11 any
					switch reflect.TypeOf(tmp10).Kind() {
					case reflect.Func:
						tmp11 = lang.Apply(tmp10, nil)
					default:
						tmp11 = tmp10
					}
					var v12 any = tmp11
					_ = v12
					// let binding "recvResult"
					tmp13 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp14 := lang.Apply(tmp13, []any{v12, int64(0), nil})
					var v15 any = tmp14
					_ = v15
					// let binding "ok"
					tmp16 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp17 := lang.Apply(tmp16, []any{v12, int64(1), nil})
					var v18 any = tmp17
					_ = v18
					var tmp19 any
					tmp20 := checkDerefVar(var_glojure_DOT_core_not)
					tmp21 := lang.Apply(tmp20, []any{v18})
					if lang.IsTruthy(tmp21) {
						tmp22 := lang.Apply(fmt.Errorf, []any{"Channel closed"})
						panic(tmp22)
					} else {
					}
					_ = tmp19
					tmp23, ok := lang.FieldOrMethod(v15, "Interface")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v15, "Interface")))
					}
					var tmp24 any
					switch reflect.TypeOf(tmp23).Kind() {
					case reflect.Func:
						tmp24 = lang.Apply(tmp23, nil)
					default:
						tmp24 = tmp23
					}
					tmp9 = tmp24
				} // end let
				tmp2 = tmp9
			} // end let
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_codegen_DOT_test_DOT_goroutine__DASH_main = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_codegen_DOT_test_DOT_goroutine__DASH_main.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}

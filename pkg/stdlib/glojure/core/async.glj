(ns glojure.core.async
  "Facilities for async programming and communication.

go blocks are dispatched over an internal thread pool, which
defaults to 8 threads. The size of this pool can be modified using
the Java system property `clojure.core.async.pool-size`.

Set Java system property `clojure.core.async.go-checking` to true
to validate go blocks do not invoke core.async blocking operations.
Property is read once, at namespace load time. Recommended for use
primarily during development. Invalid blocking calls will throw in
go block threads - use Thread.setDefaultUncaughtExceptionHandler()
to catch and handle.")

(defn chan
  "Creates a channel with an optional buffer, an optional transducer
  (like (map f), (filter p) etc or a composition thereof), and an
  optional exception-handler.  If buf-or-n is a number, will create
  and use a fixed buffer of that size. If a transducer is supplied a
  buffer must be specified. ex-handler must be a fn of one argument -
  if an exception occurs during transformation it will be called with
  the Throwable as an argument, and any non-nil return value will be
  placed in the channel."
  ([] (chan nil))
  ([buf-or-n] (chan buf-or-n nil))
  ([buf-or-n xform] (chan buf-or-n xform nil))
  ([buf-or-n xform ex-handler]
   (when xform (assert buf-or-n "buffer must be supplied when transducer is"))
   (when xform (throw (fmt.Errorf "xform and ex-handler not yet supported"))) ;; TODO
   (go/make (go/chan-of go/any) (or buf-or-n 0))))

(defn- nop [_])

(defn- impl-put!
  "derefable boolean (false iff already closed) if handled, nil if put
  was enqueued. Must throw on nil val."
  [port val fn1-handler]
  (when (nil? val)
    (throw (fmt.Errorf "can't put nil on channel")))
  )

(defn put!
  "Asynchronously puts a val into port, calling fn1 (if supplied) when
   complete, passing false iff port is already closed. nil values are
   not allowed. If on-caller? (default true) is true, and the put is
   immediately accepted, will call fn1 on calling thread.

   Returns true unless port is already closed."
  ([port val]
     (if-let [ret (impl/put! port val nop)]
       @ret
       true))
  ([port val fn1] (put! port val fn1 true))
  ([port val fn1 on-caller?]
     (if-let [retb (impl/put! port val (fn-handler fn1))]
       (let [ret @retb]
         (if on-caller?
           (fn1 ret)
           (dispatch/run #(fn1 ret)))
         ret)
       true)))

(defn <!
  "takes a val from port. Will return nil if closed. Will park if
  nothing is available."
  [port]
  (let [[val _] (go/recv port)]
    val))

(def <!! <!)

(defn >!
  "puts a val into port. nil values are not allowed. Will park if no buffer space is available.
  Returns true unless port is already closed."
  [port val]
  (try
    (go/send port val)
    true
    (catch go/any _ ;; swallow all sends on closed channels
      false)))

(def >!! >!)

(defn close!
  "Closes a channel. The channel will no longer accept any puts (they
  will be ignored). Data in the channel remains available for taking, until
  exhausted, after which takes will return nil. If there are any
  pending takes, they will be dispatched with nil. Closing a closed
  channel is a no-op. Returns nil.

  Logically closing happens after all puts have been delivered. Therefore, any
  blocked or parked puts will remain blocked/parked until a taker releases them."

  [chan]
  (try
    (go/close chan)
    (catch go/any _)))

(defmacro go
  "Asynchronously executes the body, returning immediately to the
  calling thread. Additionally, any visible calls to <!, >! and alt!/alts!
  channel operations within the body will block (if necessary) by
  'parking' the calling thread rather than tying up an OS thread (or
  the only JS thread when in ClojureScript). Upon completion of the
  operation, the body will be resumed.

  Unlike in Clojure or ClojureScript, go blocks may (either directly
  or indirectly) perform operations that may block indefinitely, as go
  blocks are run on goroutines, which relinquish the thread of control
  when parked.

  Returns a channel which will receive the result of the body when
  completed"
  [& body]
  ;; TODO: handle transferring dynamic bindings to the new frame
  `(let [c# (chan 1)
         f# (fn []
              (let [res# (do ~@body)]
                (>! c# res#)))]
     (go/go (f#))
     ((go/<-chan-of go/any) c#)))

(defn- try-put
  "Returns true if val was sent on the port, false if sending would block,
  and nil if the channel was closed."
  [port val]
  (try
    (let [sc (new reflect.SelectCase)
          _ (do
              (set! (.Dir sc) reflect.SelectSend)
              (set! (.Chan sc) (reflect.ValueOf port))
              (set! (.Send sc) (reflect.ValueOf val)))
          def (new reflect.SelectCase)
          _ (do
              (set! (.Dir def) reflect.SelectDefault))
          [chosen _ _] (reflect.Select (map go/deref [sc def]))]
      (or (= 0 chosen) nil))
    (catch go/any x
      false)))

(defn- try-take
  "Returns [val true] if val was received from the port, [nil false] if the channel was closed,
  and nil if receiving would block."
  [port]
  (let [sc (new reflect.SelectCase)
        _ (do
            (set! (.Dir sc) reflect.SelectRecv)
            (set! (.Chan sc) (reflect.ValueOf port)))
        def (new reflect.SelectCase)
        _ (do
            (set! (.Dir def) reflect.SelectDefault))
        [chosen val ok] (reflect.Select (map go/deref [sc def]))]
    (cond (= 1 chosen) nil
          ok [(.Interface val) true]
          :else [nil false])))

(defn offer!
  "Puts a val into port if it's possible to do so immediately.
   nil values are not allowed. Never blocks. Returns true if offer succeeds."
  [port val]
  (let [res (try-put port val)]
    (if (boolean? res)
      res
      (do (go (>! port val)) ;; enqueue the send
          nil))))

(defn poll!
  "Takes a val from port if it's possible to do so immediately.
   Never blocks. Returns value if successful, nil otherwise."
  [port]
  (let [res (try-take port)
        [val ok] res]
    (cond ok val
          (= false ok) nil
          :else (do (go (<! port)) ;; enqueue the take; it is discarded
                    nil))))

;; admix
;; alt!
;; alt!!
;; alts!
;; alts!!
;; buffer
;; do-alts
;; dropping-buffer
;; go-loop
;; into
;; map
;; merge
;; mix
;; mult
;; onto-chan
;; onto-chan!
;; onto-chan!!
;; pipe
;; pipeline
;; pipeline-async
;; pipeline-blocking
;; promise-chan
;; pub
;; put!
;; reduce
;; sliding-buffer
;; solo-mode
;; split
;; sub
;; take
;; take!
;; tap
;; thread
;; thread-call
;; timeout
;; to-chan
;; to-chan!
;; to-chan!!
;; toggle
;; transduce
;; unblocking-buffer?
;; unmix
;; unmix-all
;; unsub
;; unsub-all
;; untap
;; untap-all

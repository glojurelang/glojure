// Code generated by glojure codegen. DO NOT EDIT.

package io

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	io4 "io"
	http7 "net/http"
	url5 "net/url"
	os6 "os"
	reflect "reflect"
)

func init() {
	runtime.RegisterNSLoader("glojure/go/io", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "glojure.go.io"
func LoadNS() {
	sym__AMP_ := lang.NewSymbol("&")
	sym__EQ_ := lang.NewSymbol("=")
	sym_IOFactory := lang.NewSymbol("IOFactory")
	sym_apply := lang.NewSymbol("apply")
	sym_byte_DASH_array_DASH_type := lang.NewSymbol("byte-array-type")
	sym_call := lang.NewSymbol("call")
	sym_class := lang.NewSymbol("class")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_core_SLASH_last := lang.NewSymbol("clojure.core/last")
	sym_clojure_DOT_core_SLASH_let := lang.NewSymbol("clojure.core/let")
	sym_clojure_DOT_core_SLASH_not_DASH_empty := lang.NewSymbol("clojure.core/not-empty")
	sym_clojure_DOT_core_SLASH_pop := lang.NewSymbol("clojure.core/pop")
	sym_clojure_DOT_core_SLASH_vector_QMARK_ := lang.NewSymbol("clojure.core/vector?")
	sym_clojure_DOT_core_SLASH_when := lang.NewSymbol("clojure.core/when")
	sym_concat := lang.NewSymbol("concat")
	sym_cons := lang.NewSymbol("cons")
	sym_copy := lang.NewSymbol("copy")
	sym_default_DASH_streams_DASH_impl := lang.NewSymbol("default-streams-impl")
	sym_do_DASH_copy := lang.NewSymbol("do-copy")
	sym_err__3__auto__ := lang.NewSymbol("err__3__auto__")
	sym_first := lang.NewSymbol("first")
	sym_fst__1__auto__ := lang.NewSymbol("fst__1__auto__")
	sym_global_DASH_hierarchy := lang.NewSymbol("global-hierarchy")
	sym_glojure_DOT_go_DOT_io := lang.NewSymbol("glojure.go.io")
	sym_go_DASH_try_BANG_ := lang.NewSymbol("go-try!")
	sym_hash_DASH_map := lang.NewSymbol("hash-map")
	sym_if := lang.NewSymbol("if")
	sym_input := lang.NewSymbol("input")
	sym_last := lang.NewSymbol("last")
	sym_list := lang.NewSymbol("list")
	sym_make_DASH_input_DASH_stream := lang.NewSymbol("make-input-stream")
	sym_make_DASH_output_DASH_stream := lang.NewSymbol("make-output-stream")
	sym_make_DASH_reader := lang.NewSymbol("make-reader")
	sym_make_DASH_writer := lang.NewSymbol("make-writer")
	sym_next := lang.NewSymbol("next")
	sym_not_DASH_empty := lang.NewSymbol("not-empty")
	sym_not_EQ_ := lang.NewSymbol("not=")
	sym_nth := lang.NewSymbol("nth")
	sym_opts := lang.NewSymbol("opts")
	sym_output := lang.NewSymbol("output")
	sym_pop := lang.NewSymbol("pop")
	sym_pr_DASH_str := lang.NewSymbol("pr-str")
	sym_reader := lang.NewSymbol("reader")
	sym_res__0__auto__ := lang.NewSymbol("res__0__auto__")
	sym_rst__2__auto__ := lang.NewSymbol("rst__2__auto__")
	sym_seq := lang.NewSymbol("seq")
	sym_str := lang.NewSymbol("str")
	sym_throw := lang.NewSymbol("throw")
	sym_type := lang.NewSymbol("type")
	sym_vector := lang.NewSymbol("vector")
	sym_vector_QMARK_ := lang.NewSymbol("vector?")
	sym_x := lang.NewSymbol("x")
	kw_added := lang.NewKeyword("added")
	kw_arglists := lang.NewKeyword("arglists")
	kw_as := lang.NewKeyword("as")
	kw_column := lang.NewKeyword("column")
	kw_default := lang.NewKeyword("default")
	kw_doc := lang.NewKeyword("doc")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_macro := lang.NewKeyword("macro")
	kw_make_DASH_input_DASH_stream := lang.NewKeyword("make-input-stream")
	kw_make_DASH_output_DASH_stream := lang.NewKeyword("make-output-stream")
	kw_make_DASH_reader := lang.NewKeyword("make-reader")
	kw_make_DASH_writer := lang.NewKeyword("make-writer")
	kw_multis := lang.NewKeyword("multis")
	kw_ns := lang.NewKeyword("ns")
	kw_on_DASH_interface := lang.NewKeyword("on-interface")
	kw_private := lang.NewKeyword("private")
	kw_rettag := lang.NewKeyword("rettag")
	kw_sigs := lang.NewKeyword("sigs")
	kw_tag := lang.NewKeyword("tag")
	// var clojure.core/=
	var_clojure_DOT_core__EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym__EQ_)
	// var clojure.core/apply
	var_clojure_DOT_core_apply := lang.InternVarName(sym_clojure_DOT_core, sym_apply)
	// var clojure.core/class
	var_clojure_DOT_core_class := lang.InternVarName(sym_clojure_DOT_core, sym_class)
	// var clojure.core/concat
	var_clojure_DOT_core_concat := lang.InternVarName(sym_clojure_DOT_core, sym_concat)
	// var clojure.core/cons
	var_clojure_DOT_core_cons := lang.InternVarName(sym_clojure_DOT_core, sym_cons)
	// var clojure.core/first
	var_clojure_DOT_core_first := lang.InternVarName(sym_clojure_DOT_core, sym_first)
	// var clojure.core/hash-map
	var_clojure_DOT_core_hash_DASH_map := lang.InternVarName(sym_clojure_DOT_core, sym_hash_DASH_map)
	// var clojure.core/last
	var_clojure_DOT_core_last := lang.InternVarName(sym_clojure_DOT_core, sym_last)
	// var clojure.core/list
	var_clojure_DOT_core_list := lang.InternVarName(sym_clojure_DOT_core, sym_list)
	// var clojure.core/next
	var_clojure_DOT_core_next := lang.InternVarName(sym_clojure_DOT_core, sym_next)
	// var clojure.core/not-empty
	var_clojure_DOT_core_not_DASH_empty := lang.InternVarName(sym_clojure_DOT_core, sym_not_DASH_empty)
	// var clojure.core/not=
	var_clojure_DOT_core_not_EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym_not_EQ_)
	// var clojure.core/nth
	var_clojure_DOT_core_nth := lang.InternVarName(sym_clojure_DOT_core, sym_nth)
	// var clojure.core/pop
	var_clojure_DOT_core_pop := lang.InternVarName(sym_clojure_DOT_core, sym_pop)
	// var clojure.core/pr-str
	var_clojure_DOT_core_pr_DASH_str := lang.InternVarName(sym_clojure_DOT_core, sym_pr_DASH_str)
	// var clojure.core/seq
	var_clojure_DOT_core_seq := lang.InternVarName(sym_clojure_DOT_core, sym_seq)
	// var clojure.core/str
	var_clojure_DOT_core_str := lang.InternVarName(sym_clojure_DOT_core, sym_str)
	// var clojure.core/type
	var_clojure_DOT_core_type := lang.InternVarName(sym_clojure_DOT_core, sym_type)
	// var clojure.core/vector
	var_clojure_DOT_core_vector := lang.InternVarName(sym_clojure_DOT_core, sym_vector)
	// var clojure.core/vector?
	var_clojure_DOT_core_vector_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_vector_QMARK_)
	// var glojure.go.io/IOFactory
	var_glojure_DOT_go_DOT_io_IOFactory := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_IOFactory)
	// var glojure.go.io/byte-array-type
	var_glojure_DOT_go_DOT_io_byte_DASH_array_DASH_type := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_byte_DASH_array_DASH_type)
	// var glojure.go.io/copy
	var_glojure_DOT_go_DOT_io_copy := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_copy)
	// var glojure.go.io/default-streams-impl
	var_glojure_DOT_go_DOT_io_default_DASH_streams_DASH_impl := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_default_DASH_streams_DASH_impl)
	// var glojure.go.io/do-copy
	var_glojure_DOT_go_DOT_io_do_DASH_copy := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_do_DASH_copy)
	// var glojure.go.io/go-try!
	var_glojure_DOT_go_DOT_io_go_DASH_try_BANG_ := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_go_DASH_try_BANG_)
	// var glojure.go.io/make-input-stream
	var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_make_DASH_input_DASH_stream)
	// var glojure.go.io/make-output-stream
	var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_make_DASH_output_DASH_stream)
	// var glojure.go.io/make-reader
	var_glojure_DOT_go_DOT_io_make_DASH_reader := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_make_DASH_reader)
	// var glojure.go.io/make-writer
	var_glojure_DOT_go_DOT_io_make_DASH_writer := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_make_DASH_writer)
	// var glojure.go.io/reader
	var_glojure_DOT_go_DOT_io_reader := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_reader)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io)
	_ = ns
	var closed0 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(188), kw_column, int(18), kw_end_DASH_line, int(188), kw_end_DASH_column, int(32))).(lang.FnFunc)
		closed0 = tmp0
	}
	var closed3 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(187), kw_column, int(24), kw_end_DASH_line, int(187), kw_end_DASH_column, int(38))).(lang.FnFunc)
		closed3 = tmp0
	}
	var closed4 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(226), kw_column, int(24), kw_end_DASH_line, int(226), kw_end_DASH_column, int(48))).(lang.FnFunc)
		closed4 = tmp0
	}
	var closed8 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(227), kw_column, int(25), kw_end_DASH_line, int(227), kw_end_DASH_column, int(49))).(lang.FnFunc)
		closed8 = tmp0
	}
	// byte-array-type
	{
		tmp0 := sym_byte_DASH_array_DASH_type.WithMeta(lang.NewMap(kw_doc, "Type object for a Go primitive byte slice.", kw_private, true, kw_file, "glojure/go/io.glj", kw_line, int(16), kw_column, int(5), kw_end_DASH_line, int(19), kw_end_DASH_column, int(16), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io))).(*lang.Symbol)
		tmp1 := reflect.TypeOf([]uint8(nil))
		var_glojure_DOT_go_DOT_io_byte_DASH_array_DASH_type = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_io_byte_DASH_array_DASH_type.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	var closed1 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
			tmp4 := lang.Apply(tmp3, []any{v1, v2})
			return tmp4
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(167), kw_column, int(17), kw_end_DASH_line, int(167), kw_end_DASH_column, int(56))).(lang.FnFunc)
		closed1 = tmp0
	}
	var closed10 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						if lang.CatchMatches(r, lang.Builtins["any"]) {
							v4 := r
							_ = v4
							tmp5 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
							var tmp6 any
							{ // let
								// let binding "res__0__auto__"
								tmp7 := lang.Apply(os6.Open, []any{v1})
								tmp8 := lang.Apply(tmp7, nil)
								var v9 any = tmp8
								_ = v9
								// let binding "vec__1098"
								var tmp10 any
								tmp11 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
								tmp12 := lang.Apply(tmp11, []any{v9})
								if lang.IsTruthy(tmp12) {
									tmp13 := checkDerefVar(var_clojure_DOT_core_pop)
									tmp14 := lang.Apply(tmp13, []any{v9})
									tmp15 := checkDerefVar(var_clojure_DOT_core_last)
									tmp16 := lang.Apply(tmp15, []any{v9})
									tmp17 := lang.NewVector(tmp14, tmp16)
									tmp18 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
									tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp10 = tmp19
								} else {
									tmp20 := lang.NewVector(nil, v9)
									tmp21 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
									tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp10 = tmp22
								}
								var v23 any = tmp10
								_ = v23
								// let binding "vec__1101"
								tmp24 := checkDerefVar(var_clojure_DOT_core_nth)
								tmp25 := lang.Apply(tmp24, []any{v23, int64(0), nil})
								var v26 any = tmp25
								_ = v26
								// let binding "seq__1102"
								tmp27 := checkDerefVar(var_clojure_DOT_core_seq)
								tmp28 := lang.Apply(tmp27, []any{v26})
								var v29 any = tmp28
								_ = v29
								// let binding "first__1103"
								tmp30 := checkDerefVar(var_clojure_DOT_core_first)
								tmp31 := lang.Apply(tmp30, []any{v29})
								var v32 any = tmp31
								_ = v32
								// let binding "seq__1102"
								tmp33 := checkDerefVar(var_clojure_DOT_core_next)
								tmp34 := lang.Apply(tmp33, []any{v29})
								var v35 any = tmp34
								_ = v35
								// let binding "fst__1__auto__"
								var v36 any = v32
								_ = v36
								// let binding "rst__2__auto__"
								var v37 any = v35
								_ = v37
								// let binding "res__0__auto__"
								var v38 any = v26
								_ = v38
								// let binding "err__3__auto__"
								tmp39 := checkDerefVar(var_clojure_DOT_core_nth)
								tmp40 := lang.Apply(tmp39, []any{v23, int64(1), nil})
								var v41 any = tmp40
								_ = v41
								// let binding "res__0__auto__"
								var tmp42 any
								tmp43 := checkDerefVar(var_clojure_DOT_core_not_DASH_empty)
								tmp44 := lang.Apply(tmp43, []any{v37})
								if lang.IsTruthy(tmp44) {
									tmp42 = v38
								} else {
									tmp42 = v36
								}
								var v45 any = tmp42
								_ = v45
								var tmp46 any
								if lang.IsTruthy(v41) {
									panic(v41)
								} else {
								}
								_ = tmp46
								tmp6 = v45
							} // end let
							tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
							tmp3 = tmp7
						} else {
							panic(r)
						}
					}
				}()
				tmp4 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
				var tmp5 any
				{ // let
					// let binding "res__0__auto__"
					tmp6 := lang.Apply(url5.Parse, []any{v1})
					tmp7 := lang.Apply(tmp6, nil)
					var v8 any = tmp7
					_ = v8
					// let binding "vec__1092"
					var tmp9 any
					tmp10 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
					tmp11 := lang.Apply(tmp10, []any{v8})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_clojure_DOT_core_pop)
						tmp13 := lang.Apply(tmp12, []any{v8})
						tmp14 := checkDerefVar(var_clojure_DOT_core_last)
						tmp15 := lang.Apply(tmp14, []any{v8})
						tmp16 := lang.NewVector(tmp13, tmp15)
						tmp17 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
						tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp18
					} else {
						tmp19 := lang.NewVector(nil, v8)
						tmp20 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
						tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp21
					}
					var v22 any = tmp9
					_ = v22
					// let binding "vec__1095"
					tmp23 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp24 := lang.Apply(tmp23, []any{v22, int64(0), nil})
					var v25 any = tmp24
					_ = v25
					// let binding "seq__1096"
					tmp26 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp27 := lang.Apply(tmp26, []any{v25})
					var v28 any = tmp27
					_ = v28
					// let binding "first__1097"
					tmp29 := checkDerefVar(var_clojure_DOT_core_first)
					tmp30 := lang.Apply(tmp29, []any{v28})
					var v31 any = tmp30
					_ = v31
					// let binding "seq__1096"
					tmp32 := checkDerefVar(var_clojure_DOT_core_next)
					tmp33 := lang.Apply(tmp32, []any{v28})
					var v34 any = tmp33
					_ = v34
					// let binding "fst__1__auto__"
					var v35 any = v31
					_ = v35
					// let binding "rst__2__auto__"
					var v36 any = v34
					_ = v36
					// let binding "res__0__auto__"
					var v37 any = v25
					_ = v37
					// let binding "err__3__auto__"
					tmp38 := checkDerefVar(var_clojure_DOT_core_nth)
					tmp39 := lang.Apply(tmp38, []any{v22, int64(1), nil})
					var v40 any = tmp39
					_ = v40
					// let binding "res__0__auto__"
					var tmp41 any
					tmp42 := checkDerefVar(var_clojure_DOT_core_not_DASH_empty)
					tmp43 := lang.Apply(tmp42, []any{v36})
					if lang.IsTruthy(tmp43) {
						tmp41 = v37
					} else {
						tmp41 = v35
					}
					var v44 any = tmp41
					_ = v44
					var tmp45 any
					if lang.IsTruthy(v40) {
						panic(v40)
					} else {
					}
					_ = tmp45
					tmp5 = v44
				} // end let
				tmp6 := lang.Apply(tmp4, []any{tmp5, v2})
				tmp3 = tmp6
			}()
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(264), kw_column, int(25), kw_end_DASH_line, int(268), kw_end_DASH_column, int(79))).(lang.FnFunc)
		closed10 = tmp0
	}
	var closed2 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_writer)
			tmp4 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
			tmp5 := lang.Apply(tmp4, []any{v1, v2})
			tmp6 := lang.Apply(tmp3, []any{tmp5, v2})
			return tmp6
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(168), kw_column, int(17), kw_end_DASH_line, int(168), kw_end_DASH_column, int(76))).(lang.FnFunc)
		closed2 = tmp0
	}
	var closed5 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
			var tmp4 any
			tmp5 := checkDerefVar(var_clojure_DOT_core__EQ_)
			tmp6, ok := lang.FieldOrMethod(v1, "scheme")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "scheme")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			tmp8 := lang.Apply(tmp5, []any{"file", tmp7})
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.Apply(nil, []any{v1})
				tmp4 = tmp9
			} else {
				var tmp10 any
				{ // let
					// let binding "req"
					var tmp11 any
					{ // let
						// let binding "res__0__auto__"
						tmp12, ok := lang.FieldOrMethod(v1, "String")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "String")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						tmp14 := lang.Apply(http7.NewRequest, []any{http7.MethodGet, tmp13, nil})
						var v15 any = tmp14
						_ = v15
						// let binding "vec__1071"
						var tmp16 any
						tmp17 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
						tmp18 := lang.Apply(tmp17, []any{v15})
						if lang.IsTruthy(tmp18) {
							tmp19 := checkDerefVar(var_clojure_DOT_core_pop)
							tmp20 := lang.Apply(tmp19, []any{v15})
							tmp21 := checkDerefVar(var_clojure_DOT_core_last)
							tmp22 := lang.Apply(tmp21, []any{v15})
							tmp23 := lang.NewVector(tmp20, tmp22)
							tmp24 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
							tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 = tmp25
						} else {
							tmp26 := lang.NewVector(nil, v15)
							tmp27 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
							tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 = tmp28
						}
						var v29 any = tmp16
						_ = v29
						// let binding "vec__1074"
						tmp30 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp31 := lang.Apply(tmp30, []any{v29, int64(0), nil})
						var v32 any = tmp31
						_ = v32
						// let binding "seq__1075"
						tmp33 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp34 := lang.Apply(tmp33, []any{v32})
						var v35 any = tmp34
						_ = v35
						// let binding "first__1076"
						tmp36 := checkDerefVar(var_clojure_DOT_core_first)
						tmp37 := lang.Apply(tmp36, []any{v35})
						var v38 any = tmp37
						_ = v38
						// let binding "seq__1075"
						tmp39 := checkDerefVar(var_clojure_DOT_core_next)
						tmp40 := lang.Apply(tmp39, []any{v35})
						var v41 any = tmp40
						_ = v41
						// let binding "fst__1__auto__"
						var v42 any = v38
						_ = v42
						// let binding "rst__2__auto__"
						var v43 any = v41
						_ = v43
						// let binding "res__0__auto__"
						var v44 any = v32
						_ = v44
						// let binding "err__3__auto__"
						tmp45 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp46 := lang.Apply(tmp45, []any{v29, int64(1), nil})
						var v47 any = tmp46
						_ = v47
						// let binding "res__0__auto__"
						var tmp48 any
						tmp49 := checkDerefVar(var_clojure_DOT_core_not_DASH_empty)
						tmp50 := lang.Apply(tmp49, []any{v43})
						if lang.IsTruthy(tmp50) {
							tmp48 = v44
						} else {
							tmp48 = v42
						}
						var v51 any = tmp48
						_ = v51
						var tmp52 any
						if lang.IsTruthy(v47) {
							panic(v47)
						} else {
						}
						_ = tmp52
						tmp11 = v51
					} // end let
					var v12 any = tmp11
					_ = v12
					// let binding "res"
					var tmp13 any
					{ // let
						// let binding "res__0__auto__"
						tmp14, _ := lang.FieldOrMethod(http7.DefaultClient, "Do")
						if reflect.TypeOf(tmp14).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("Do is not a function")))
						}
						tmp15 := lang.Apply(tmp14, []any{v12})
						var v16 any = tmp15
						_ = v16
						// let binding "vec__1077"
						var tmp17 any
						tmp18 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v16})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(var_clojure_DOT_core_pop)
							tmp21 := lang.Apply(tmp20, []any{v16})
							tmp22 := checkDerefVar(var_clojure_DOT_core_last)
							tmp23 := lang.Apply(tmp22, []any{v16})
							tmp24 := lang.NewVector(tmp21, tmp23)
							tmp25 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp26
						} else {
							tmp27 := lang.NewVector(nil, v16)
							tmp28 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
							tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp29
						}
						var v30 any = tmp17
						_ = v30
						// let binding "vec__1080"
						tmp31 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp32 := lang.Apply(tmp31, []any{v30, int64(0), nil})
						var v33 any = tmp32
						_ = v33
						// let binding "seq__1081"
						tmp34 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp35 := lang.Apply(tmp34, []any{v33})
						var v36 any = tmp35
						_ = v36
						// let binding "first__1082"
						tmp37 := checkDerefVar(var_clojure_DOT_core_first)
						tmp38 := lang.Apply(tmp37, []any{v36})
						var v39 any = tmp38
						_ = v39
						// let binding "seq__1081"
						tmp40 := checkDerefVar(var_clojure_DOT_core_next)
						tmp41 := lang.Apply(tmp40, []any{v36})
						var v42 any = tmp41
						_ = v42
						// let binding "fst__1__auto__"
						var v43 any = v39
						_ = v43
						// let binding "rst__2__auto__"
						var v44 any = v42
						_ = v44
						// let binding "res__0__auto__"
						var v45 any = v33
						_ = v45
						// let binding "err__3__auto__"
						tmp46 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp47 := lang.Apply(tmp46, []any{v30, int64(1), nil})
						var v48 any = tmp47
						_ = v48
						// let binding "res__0__auto__"
						var tmp49 any
						tmp50 := checkDerefVar(var_clojure_DOT_core_not_DASH_empty)
						tmp51 := lang.Apply(tmp50, []any{v44})
						if lang.IsTruthy(tmp51) {
							tmp49 = v45
						} else {
							tmp49 = v43
						}
						var v52 any = tmp49
						_ = v52
						var tmp53 any
						if lang.IsTruthy(v48) {
							panic(v48)
						} else {
						}
						_ = tmp53
						tmp13 = v52
					} // end let
					var v14 any = tmp13
					_ = v14
					// let binding "status"
					tmp15, ok := lang.FieldOrMethod(v14, "StatusCode")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "StatusCode")))
					}
					var tmp16 any
					switch reflect.TypeOf(tmp15).Kind() {
					case reflect.Func:
						tmp16 = lang.Apply(tmp15, nil)
					default:
						tmp16 = tmp15
					}
					var v17 any = tmp16
					_ = v17
					// let binding "body"
					tmp18, ok := lang.FieldOrMethod(v14, "Body")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "Body")))
					}
					var tmp19 any
					switch reflect.TypeOf(tmp18).Kind() {
					case reflect.Func:
						tmp19 = lang.Apply(tmp18, nil)
					default:
						tmp19 = tmp18
					}
					var v20 any = tmp19
					_ = v20
					var tmp21 any
					tmp22 := checkDerefVar(var_clojure_DOT_core_not_EQ_)
					tmp23 := lang.Apply(tmp22, []any{int64(200), v17})
					if lang.IsTruthy(tmp23) {
						tmp24, ok := lang.FieldOrMethod(v20, "Close")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v20, "Close")))
						}
						var tmp25 any
						switch reflect.TypeOf(tmp24).Kind() {
						case reflect.Func:
							tmp25 = lang.Apply(tmp24, nil)
						default:
							tmp25 = tmp24
						}
						_ = tmp25
						tmp26 := lang.Apply(fmt.Errorf, []any{"http error: %s", v17})
						panic(tmp26)
					} else {
					}
					_ = tmp21
					tmp10 = v20
				} // end let
				tmp4 = tmp10
			}
			tmp11 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp11
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(232), kw_column, int(24), kw_end_DASH_line, int(244), kw_end_DASH_column, int(32))).(lang.FnFunc)
		closed5 = tmp0
	}
	var closed6 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "vec__1083"
				tmp4 := lang.Apply(url5.ParseRequestURI, []any{v1})
				var v5 any = tmp4
				_ = v5
				// let binding "url"
				tmp6 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				if lang.IsTruthy(v11) {
					tmp13 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
					var tmp14 any
					{ // let
						// let binding "res__0__auto__"
						tmp15 := lang.Apply(os6.Open, []any{v1})
						var v16 any = tmp15
						_ = v16
						// let binding "vec__1086"
						var tmp17 any
						tmp18 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v16})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(var_clojure_DOT_core_pop)
							tmp21 := lang.Apply(tmp20, []any{v16})
							tmp22 := checkDerefVar(var_clojure_DOT_core_last)
							tmp23 := lang.Apply(tmp22, []any{v16})
							tmp24 := lang.NewVector(tmp21, tmp23)
							tmp25 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp26
						} else {
							tmp27 := lang.NewVector(nil, v16)
							tmp28 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
							tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp29
						}
						var v30 any = tmp17
						_ = v30
						// let binding "vec__1089"
						tmp31 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp32 := lang.Apply(tmp31, []any{v30, int64(0), nil})
						var v33 any = tmp32
						_ = v33
						// let binding "seq__1090"
						tmp34 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp35 := lang.Apply(tmp34, []any{v33})
						var v36 any = tmp35
						_ = v36
						// let binding "first__1091"
						tmp37 := checkDerefVar(var_clojure_DOT_core_first)
						tmp38 := lang.Apply(tmp37, []any{v36})
						var v39 any = tmp38
						_ = v39
						// let binding "seq__1090"
						tmp40 := checkDerefVar(var_clojure_DOT_core_next)
						tmp41 := lang.Apply(tmp40, []any{v36})
						var v42 any = tmp41
						_ = v42
						// let binding "fst__1__auto__"
						var v43 any = v39
						_ = v43
						// let binding "rst__2__auto__"
						var v44 any = v42
						_ = v44
						// let binding "res__0__auto__"
						var v45 any = v33
						_ = v45
						// let binding "err__3__auto__"
						tmp46 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp47 := lang.Apply(tmp46, []any{v30, int64(1), nil})
						var v48 any = tmp47
						_ = v48
						// let binding "res__0__auto__"
						var tmp49 any
						tmp50 := checkDerefVar(var_clojure_DOT_core_not_DASH_empty)
						tmp51 := lang.Apply(tmp50, []any{v44})
						if lang.IsTruthy(tmp51) {
							tmp49 = v45
						} else {
							tmp49 = v43
						}
						var v52 any = tmp49
						_ = v52
						var tmp53 any
						if lang.IsTruthy(v48) {
							panic(v48)
						} else {
						}
						_ = tmp53
						tmp14 = v52
					} // end let
					tmp15 := lang.Apply(tmp13, []any{tmp14, v2})
					tmp12 = tmp15
				} else {
					tmp16 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
					tmp17 := lang.Apply(tmp16, []any{v8, v2})
					tmp12 = tmp17
				}
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(259), kw_column, int(24), kw_end_DASH_line, int(263), kw_end_DASH_column, int(60))).(lang.FnFunc)
		closed6 = tmp0
	}
	var closed7 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_str)
			tmp4 := checkDerefVar(var_clojure_DOT_core_pr_DASH_str)
			tmp5 := lang.Apply(tmp4, []any{v1})
			tmp6 := lang.Apply(tmp3, []any{"Cannot open <", tmp5, "> as an OutputStream."})
			tmp7 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp6})
			panic(tmp7)
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(172), kw_column, int(24), kw_end_DASH_line, int(174), kw_end_DASH_column, int(92))).(lang.FnFunc)
		closed7 = tmp0
	}
	var closed9 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_clojure_DOT_core__EQ_)
			tmp5, ok := lang.FieldOrMethod(v1, "scheme")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "scheme")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{"file", tmp6})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
				tmp9 := lang.Apply(nil, []any{v1})
				tmp10 := lang.Apply(tmp8, []any{tmp9, v2})
				tmp3 = tmp10
			} else {
				tmp11 := checkDerefVar(var_clojure_DOT_core_str)
				tmp12 := lang.Apply(tmp11, []any{"Can not write to non-file URL <", v1, ">"})
				tmp13 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp12})
				panic(tmp13)
			}
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(245), kw_column, int(25), kw_end_DASH_line, int(248), kw_end_DASH_column, int(149))).(lang.FnFunc)
		closed9 = tmp0
	}
	// IOFactory
	{
		tmp0 := sym_IOFactory.WithMeta(lang.NewMap(kw_added, "1.2", kw_file, "glojure/go/io.glj", kw_line, int(72), kw_column, int(14), kw_end_DASH_line, int(72), kw_end_DASH_column, int(38), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v4 := args[0]
				_ = v4
				restArgs := args[1:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_class)
				tmp7 := lang.Apply(tmp6, []any{v4})
				return tmp7
			}
		})
		// MultiFn make-reader
		tmp2 := lang.NewMultiFn("make-reader", tmp3, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp4 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v6 := args[0]
				_ = v6
				restArgs := args[1:]
				var v7 any
				if len(restArgs) > 0 {
					v7 = lang.NewList(restArgs...)
				}
				_ = v7
				tmp8 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp9 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v6, v7})
				tmp11 := lang.Apply(tmp8, []any{closed0, tmp10})
				return tmp11
			}
		})
		tmp2.AddMethod(tmp4, tmp5)
		tmp6 := reflect.TypeOf((*url5.URL)(nil))
		var tmp7 lang.FnFunc
		tmp7 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v8 := args[0]
				_ = v8
				restArgs := args[1:]
				var v9 any
				if len(restArgs) > 0 {
					v9 = lang.NewList(restArgs...)
				}
				_ = v9
				tmp10 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp11 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp12 := lang.Apply(tmp11, []any{v8, v9})
				tmp13 := lang.Apply(tmp10, []any{closed1, tmp12})
				return tmp13
			}
		})
		tmp2.AddMethod(tmp6, tmp7)
		tmp8 := reflect.TypeOf("")
		var tmp9 lang.FnFunc
		tmp9 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v10 := args[0]
				_ = v10
				restArgs := args[1:]
				var v11 any
				if len(restArgs) > 0 {
					v11 = lang.NewList(restArgs...)
				}
				_ = v11
				tmp12 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp13 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp14 := lang.Apply(tmp13, []any{v10, v11})
				tmp15 := lang.Apply(tmp12, []any{closed1, tmp14})
				return tmp15
			}
		})
		tmp2.AddMethod(tmp8, tmp9)
		var tmp11 lang.FnFunc
		tmp11 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v12 := args[0]
				_ = v12
				restArgs := args[1:]
				var v13 any
				if len(restArgs) > 0 {
					v13 = lang.NewList(restArgs...)
				}
				_ = v13
				tmp14 := checkDerefVar(var_clojure_DOT_core_class)
				tmp15 := lang.Apply(tmp14, []any{v12})
				return tmp15
			}
		})
		// MultiFn make-writer
		tmp10 := lang.NewMultiFn("make-writer", tmp11, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp12 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp13 lang.FnFunc
		tmp13 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v14 := args[0]
				_ = v14
				restArgs := args[1:]
				var v15 any
				if len(restArgs) > 0 {
					v15 = lang.NewList(restArgs...)
				}
				_ = v15
				tmp16 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp17 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp18 := lang.Apply(tmp17, []any{v14, v15})
				tmp19 := lang.Apply(tmp16, []any{closed2, tmp18})
				return tmp19
			}
		})
		tmp10.AddMethod(tmp12, tmp13)
		tmp14 := reflect.TypeOf((*url5.URL)(nil))
		var tmp15 lang.FnFunc
		tmp15 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v16 := args[0]
				_ = v16
				restArgs := args[1:]
				var v17 any
				if len(restArgs) > 0 {
					v17 = lang.NewList(restArgs...)
				}
				_ = v17
				tmp18 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp19 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp20 := lang.Apply(tmp19, []any{v16, v17})
				tmp21 := lang.Apply(tmp18, []any{closed2, tmp20})
				return tmp21
			}
		})
		tmp10.AddMethod(tmp14, tmp15)
		tmp16 := reflect.TypeOf("")
		var tmp17 lang.FnFunc
		tmp17 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v18 := args[0]
				_ = v18
				restArgs := args[1:]
				var v19 any
				if len(restArgs) > 0 {
					v19 = lang.NewList(restArgs...)
				}
				_ = v19
				tmp20 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp21 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp22 := lang.Apply(tmp21, []any{v18, v19})
				tmp23 := lang.Apply(tmp20, []any{closed2, tmp22})
				return tmp23
			}
		})
		tmp10.AddMethod(tmp16, tmp17)
		var tmp19 lang.FnFunc
		tmp19 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v20 := args[0]
				_ = v20
				restArgs := args[1:]
				var v21 any
				if len(restArgs) > 0 {
					v21 = lang.NewList(restArgs...)
				}
				_ = v21
				tmp22 := checkDerefVar(var_clojure_DOT_core_class)
				tmp23 := lang.Apply(tmp22, []any{v20})
				return tmp23
			}
		})
		// MultiFn make-input-stream
		tmp18 := lang.NewMultiFn("make-input-stream", tmp19, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp20 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp21 lang.FnFunc
		tmp21 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v22 := args[0]
				_ = v22
				restArgs := args[1:]
				var v23 any
				if len(restArgs) > 0 {
					v23 = lang.NewList(restArgs...)
				}
				_ = v23
				tmp24 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp25 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp26 := lang.Apply(tmp25, []any{v22, v23})
				tmp27 := lang.Apply(tmp24, []any{closed3, tmp26})
				return tmp27
			}
		})
		tmp18.AddMethod(tmp20, tmp21)
		tmp22 := reflect.TypeOf((*os6.File)(nil))
		var tmp23 lang.FnFunc
		tmp23 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v24 := args[0]
				_ = v24
				restArgs := args[1:]
				var v25 any
				if len(restArgs) > 0 {
					v25 = lang.NewList(restArgs...)
				}
				_ = v25
				tmp26 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp27 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp28 := lang.Apply(tmp27, []any{v24, v25})
				tmp29 := lang.Apply(tmp26, []any{closed4, tmp28})
				return tmp29
			}
		})
		tmp18.AddMethod(tmp22, tmp23)
		tmp24 := reflect.TypeOf((*url5.URL)(nil))
		var tmp25 lang.FnFunc
		tmp25 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v26 := args[0]
				_ = v26
				restArgs := args[1:]
				var v27 any
				if len(restArgs) > 0 {
					v27 = lang.NewList(restArgs...)
				}
				_ = v27
				tmp28 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp29 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp30 := lang.Apply(tmp29, []any{v26, v27})
				tmp31 := lang.Apply(tmp28, []any{closed5, tmp30})
				return tmp31
			}
		})
		tmp18.AddMethod(tmp24, tmp25)
		tmp26 := reflect.TypeOf("")
		var tmp27 lang.FnFunc
		tmp27 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v28 := args[0]
				_ = v28
				restArgs := args[1:]
				var v29 any
				if len(restArgs) > 0 {
					v29 = lang.NewList(restArgs...)
				}
				_ = v29
				tmp30 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp31 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp32 := lang.Apply(tmp31, []any{v28, v29})
				tmp33 := lang.Apply(tmp30, []any{closed6, tmp32})
				return tmp33
			}
		})
		tmp18.AddMethod(tmp26, tmp27)
		var tmp29 lang.FnFunc
		tmp29 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v30 := args[0]
				_ = v30
				restArgs := args[1:]
				var v31 any
				if len(restArgs) > 0 {
					v31 = lang.NewList(restArgs...)
				}
				_ = v31
				tmp32 := checkDerefVar(var_clojure_DOT_core_class)
				tmp33 := lang.Apply(tmp32, []any{v30})
				return tmp33
			}
		})
		// MultiFn make-output-stream
		tmp28 := lang.NewMultiFn("make-output-stream", tmp29, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp30 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp31 lang.FnFunc
		tmp31 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v32 := args[0]
				_ = v32
				restArgs := args[1:]
				var v33 any
				if len(restArgs) > 0 {
					v33 = lang.NewList(restArgs...)
				}
				_ = v33
				tmp34 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp35 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp36 := lang.Apply(tmp35, []any{v32, v33})
				tmp37 := lang.Apply(tmp34, []any{closed7, tmp36})
				return tmp37
			}
		})
		tmp28.AddMethod(tmp30, tmp31)
		tmp32 := reflect.TypeOf((*os6.File)(nil))
		var tmp33 lang.FnFunc
		tmp33 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v34 := args[0]
				_ = v34
				restArgs := args[1:]
				var v35 any
				if len(restArgs) > 0 {
					v35 = lang.NewList(restArgs...)
				}
				_ = v35
				tmp36 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp37 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp38 := lang.Apply(tmp37, []any{v34, v35})
				tmp39 := lang.Apply(tmp36, []any{closed8, tmp38})
				return tmp39
			}
		})
		tmp28.AddMethod(tmp32, tmp33)
		tmp34 := reflect.TypeOf((*url5.URL)(nil))
		var tmp35 lang.FnFunc
		tmp35 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v36 := args[0]
				_ = v36
				restArgs := args[1:]
				var v37 any
				if len(restArgs) > 0 {
					v37 = lang.NewList(restArgs...)
				}
				_ = v37
				tmp38 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp39 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp40 := lang.Apply(tmp39, []any{v36, v37})
				tmp41 := lang.Apply(tmp38, []any{closed9, tmp40})
				return tmp41
			}
		})
		tmp28.AddMethod(tmp34, tmp35)
		tmp36 := reflect.TypeOf("")
		var tmp37 lang.FnFunc
		tmp37 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v38 := args[0]
				_ = v38
				restArgs := args[1:]
				var v39 any
				if len(restArgs) > 0 {
					v39 = lang.NewList(restArgs...)
				}
				_ = v39
				tmp40 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp41 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp42 := lang.Apply(tmp41, []any{v38, v39})
				tmp43 := lang.Apply(tmp40, []any{closed10, tmp42})
				return tmp43
			}
		})
		tmp28.AddMethod(tmp36, tmp37)
		tmp1 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_make_DASH_reader, tmp2, kw_make_DASH_writer, tmp10, kw_make_DASH_input_DASH_stream, tmp18, kw_make_DASH_output_DASH_stream, tmp28), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_make_DASH_reader, lang.NewVector(sym_x, sym_opts), "Creates an io.Reader. See also IOFactory docs."), lang.NewList(sym_make_DASH_writer, lang.NewVector(sym_x, sym_opts), "Creates an io.Reader. See also IOFactory docs."), lang.NewList(sym_make_DASH_input_DASH_stream, lang.NewVector(sym_x, sym_opts), "Creates a BufferedInputStream. See also IOFactory docs."), lang.NewList(sym_make_DASH_output_DASH_stream, lang.NewVector(sym_x, sym_opts), "Creates a BufferedOutputStream. See also IOFactory docs."))))
		var_glojure_DOT_go_DOT_io_IOFactory = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_io_IOFactory.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// copy
	{
		tmp0 := sym_copy.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_input, sym_output, sym__AMP_, sym_opts)), kw_doc, "Copies input to output.  Returns nil or throws IOException.\n  Input may be an InputStream, Reader, File, byte[], char[], or String.\n  Output may be an OutputStream, Writer, or File.\n\n  Options are key/value pairs and may be one of\n\n    :buffer-size  buffer size to use, default is 1024.\n    :encoding     encoding to use if converting between\n                  byte and char streams.   \n\n  Does not close any streams except those it opens itself \n  (on a File).", kw_file, "glojure/go/io.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(391), kw_end_DASH_line, int(391))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_go_DOT_io_do_DASH_copy)
				var tmp6 any
				if lang.IsTruthy(v4) {
					tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp8 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
					tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
					tmp6 = tmp9
				} else {
				}
				tmp10 := lang.Apply(tmp5, []any{v2, v3, tmp6})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_go_DOT_io_copy = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_io_copy.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// default-streams-impl
	{
		tmp0 := sym_default_DASH_streams_DASH_impl.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(166), kw_column, int(6), kw_end_DASH_line, int(166), kw_end_DASH_column, int(25), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
			tmp5 := lang.Apply(tmp4, []any{v2, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(167), kw_column, int(17), kw_end_DASH_line, int(167), kw_end_DASH_column, int(56))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_writer)
			tmp6 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
			tmp7 := lang.Apply(tmp6, []any{v3, v4})
			tmp8 := lang.Apply(tmp5, []any{tmp7, v4})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(168), kw_column, int(17), kw_end_DASH_line, int(168), kw_end_DASH_column, int(76))).(lang.FnFunc)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := checkDerefVar(var_clojure_DOT_core_str)
			tmp7 := checkDerefVar(var_clojure_DOT_core_pr_DASH_str)
			tmp8 := lang.Apply(tmp7, []any{v4})
			tmp9 := lang.Apply(tmp6, []any{"Cannot open <", tmp8, "> as an InputStream."})
			tmp10 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp9})
			panic(tmp10)
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(169), kw_column, int(23), kw_end_DASH_line, int(171), kw_end_DASH_column, int(90))).(lang.FnFunc)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v5 := args[0]
			_ = v5
			v6 := args[1]
			_ = v6
			tmp7 := checkDerefVar(var_clojure_DOT_core_str)
			tmp8 := checkDerefVar(var_clojure_DOT_core_pr_DASH_str)
			tmp9 := lang.Apply(tmp8, []any{v5})
			tmp10 := lang.Apply(tmp7, []any{"Cannot open <", tmp9, "> as an OutputStream."})
			tmp11 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp10})
			panic(tmp11)
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(172), kw_column, int(24), kw_end_DASH_line, int(174), kw_end_DASH_column, int(92))).(lang.FnFunc)
		var_glojure_DOT_go_DOT_io_default_DASH_streams_DASH_impl = ns.InternWithValue(tmp0, lang.NewMap(kw_make_DASH_reader, tmp1, kw_make_DASH_writer, tmp2, kw_make_DASH_input_DASH_stream, tmp3, kw_make_DASH_output_DASH_stream, tmp4), true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_io_default_DASH_streams_DASH_impl.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// do-copy
	{
		tmp0 := sym_do_DASH_copy.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_input, sym_output, sym_opts)), kw_doc, "Internal helper for copy", kw_file, "glojure/go/io.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io), kw_end_DASH_column, int(9), kw_column, int(3), kw_line, int(301), kw_end_DASH_line, int(304), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := checkDerefVar(var_clojure_DOT_core_type)
			tmp7 := lang.Apply(tmp6, []any{v3})
			tmp8 := checkDerefVar(var_clojure_DOT_core_type)
			tmp9 := lang.Apply(tmp8, []any{v4})
			tmp10 := lang.NewVector(tmp7, tmp9)
			tmp11 := lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(305), kw_column, int(27), kw_end_DASH_line, int(305), kw_end_DASH_column, int(54))
			tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp12
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(305), kw_column, int(3), kw_end_DASH_line, int(305), kw_end_DASH_column, int(55))).(lang.FnFunc)
		// MultiFn do-copy
		tmp1 := lang.NewMultiFn("do-copy", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp3 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		tmp4 := reflect.TypeOf((*io4.Writer)(nil)).Elem()
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v6 := args[0]
			_ = v6
			v7 := args[1]
			_ = v7
			v8 := args[2]
			_ = v8
			var tmp9 any
			{ // let
				// let binding "res__0__auto__"
				tmp10 := lang.Apply(io4.Copy, []any{v7, v6})
				var v11 any = tmp10
				_ = v11
				// let binding "vec__1104"
				var tmp12 any
				tmp13 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
				tmp14 := lang.Apply(tmp13, []any{v11})
				if lang.IsTruthy(tmp14) {
					tmp15 := checkDerefVar(var_clojure_DOT_core_pop)
					tmp16 := lang.Apply(tmp15, []any{v11})
					tmp17 := checkDerefVar(var_clojure_DOT_core_last)
					tmp18 := lang.Apply(tmp17, []any{v11})
					tmp19 := lang.NewVector(tmp16, tmp18)
					tmp20 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
					tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 = tmp21
				} else {
					tmp22 := lang.NewVector(nil, v11)
					tmp23 := lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(360), kw_column, int(10), kw_end_DASH_line, int(360), kw_end_DASH_column, int(14))
					tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 = tmp24
				}
				var v25 any = tmp12
				_ = v25
				// let binding "vec__1107"
				tmp26 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp27 := lang.Apply(tmp26, []any{v25, int64(0), nil})
				var v28 any = tmp27
				_ = v28
				// let binding "seq__1108"
				tmp29 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp30 := lang.Apply(tmp29, []any{v28})
				var v31 any = tmp30
				_ = v31
				// let binding "first__1109"
				tmp32 := checkDerefVar(var_clojure_DOT_core_first)
				tmp33 := lang.Apply(tmp32, []any{v31})
				var v34 any = tmp33
				_ = v34
				// let binding "seq__1108"
				tmp35 := checkDerefVar(var_clojure_DOT_core_next)
				tmp36 := lang.Apply(tmp35, []any{v31})
				var v37 any = tmp36
				_ = v37
				// let binding "fst__1__auto__"
				var v38 any = v34
				_ = v38
				// let binding "rst__2__auto__"
				var v39 any = v37
				_ = v39
				// let binding "res__0__auto__"
				var v40 any = v28
				_ = v40
				// let binding "err__3__auto__"
				tmp41 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp42 := lang.Apply(tmp41, []any{v25, int64(1), nil})
				var v43 any = tmp42
				_ = v43
				// let binding "res__0__auto__"
				var tmp44 any
				tmp45 := checkDerefVar(var_clojure_DOT_core_not_DASH_empty)
				tmp46 := lang.Apply(tmp45, []any{v39})
				if lang.IsTruthy(tmp46) {
					tmp44 = v40
				} else {
					tmp44 = v38
				}
				var v47 any = tmp44
				_ = v47
				var tmp48 any
				if lang.IsTruthy(v43) {
					panic(v43)
				} else {
				}
				_ = tmp48
				tmp9 = v47
			} // end let
			return tmp9
		})
		tmp1.AddMethod(lang.NewVector(tmp3, tmp4), tmp5)
		var_glojure_DOT_go_DOT_io_do_DASH_copy = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_io_do_DASH_copy.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// go-try!
	{
		tmp0 := sym_go_DASH_try_BANG_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_call)), kw_file, "glojure/go/io.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io), kw_end_DASH_column, int(27), kw_column, int(11), kw_line, int(21), kw_end_DASH_line, int(21), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_clojure_DOT_core_SLASH_let})
				tmp9 := checkDerefVar(var_clojure_DOT_core_list)
				tmp10 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp11 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp12 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_clojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_res__0__auto__})
				tmp16 := checkDerefVar(var_clojure_DOT_core_list)
				tmp17 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp18 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp17, []any{tmp19})
				tmp21 := lang.Apply(tmp16, []any{tmp20})
				tmp22 := checkDerefVar(var_clojure_DOT_core_list)
				tmp23 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp24 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp25 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp26 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp27 := checkDerefVar(var_clojure_DOT_core_list)
				tmp28 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp29 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp30 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp31 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp32 := checkDerefVar(var_clojure_DOT_core_list)
				tmp33 := lang.Apply(tmp32, []any{sym_fst__1__auto__})
				tmp34 := checkDerefVar(var_clojure_DOT_core_list)
				tmp35 := lang.Apply(tmp34, []any{sym__AMP_})
				tmp36 := checkDerefVar(var_clojure_DOT_core_list)
				tmp37 := lang.Apply(tmp36, []any{sym_rst__2__auto__})
				tmp38 := checkDerefVar(var_clojure_DOT_core_list)
				tmp39 := lang.Apply(tmp38, []any{kw_as})
				tmp40 := checkDerefVar(var_clojure_DOT_core_list)
				tmp41 := lang.Apply(tmp40, []any{sym_res__0__auto__})
				tmp42 := lang.Apply(tmp31, []any{tmp33, tmp35, tmp37, tmp39, tmp41})
				tmp43 := lang.Apply(tmp30, []any{tmp42})
				tmp44 := lang.Apply(tmp28, []any{tmp29, tmp43})
				tmp45 := lang.Apply(tmp27, []any{tmp44})
				tmp46 := checkDerefVar(var_clojure_DOT_core_list)
				tmp47 := lang.Apply(tmp46, []any{sym_err__3__auto__})
				tmp48 := lang.Apply(tmp26, []any{tmp45, tmp47})
				tmp49 := lang.Apply(tmp25, []any{tmp48})
				tmp50 := lang.Apply(tmp23, []any{tmp24, tmp49})
				tmp51 := lang.Apply(tmp22, []any{tmp50})
				tmp52 := checkDerefVar(var_clojure_DOT_core_list)
				tmp53 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp54 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp55 := checkDerefVar(var_clojure_DOT_core_list)
				tmp56 := lang.Apply(tmp55, []any{sym_if})
				tmp57 := checkDerefVar(var_clojure_DOT_core_list)
				tmp58 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp59 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp60 := checkDerefVar(var_clojure_DOT_core_list)
				tmp61 := lang.Apply(tmp60, []any{sym_clojure_DOT_core_SLASH_vector_QMARK_})
				tmp62 := checkDerefVar(var_clojure_DOT_core_list)
				tmp63 := lang.Apply(tmp62, []any{sym_res__0__auto__})
				tmp64 := lang.Apply(tmp59, []any{tmp61, tmp63})
				tmp65 := lang.Apply(tmp58, []any{tmp64})
				tmp66 := lang.Apply(tmp57, []any{tmp65})
				tmp67 := checkDerefVar(var_clojure_DOT_core_list)
				tmp68 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp69 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp70 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp71 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp72 := checkDerefVar(var_clojure_DOT_core_list)
				tmp73 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp74 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp75 := checkDerefVar(var_clojure_DOT_core_list)
				tmp76 := lang.Apply(tmp75, []any{sym_clojure_DOT_core_SLASH_pop})
				tmp77 := checkDerefVar(var_clojure_DOT_core_list)
				tmp78 := lang.Apply(tmp77, []any{sym_res__0__auto__})
				tmp79 := lang.Apply(tmp74, []any{tmp76, tmp78})
				tmp80 := lang.Apply(tmp73, []any{tmp79})
				tmp81 := lang.Apply(tmp72, []any{tmp80})
				tmp82 := checkDerefVar(var_clojure_DOT_core_list)
				tmp83 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp84 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp85 := checkDerefVar(var_clojure_DOT_core_list)
				tmp86 := lang.Apply(tmp85, []any{sym_clojure_DOT_core_SLASH_last})
				tmp87 := checkDerefVar(var_clojure_DOT_core_list)
				tmp88 := lang.Apply(tmp87, []any{sym_res__0__auto__})
				tmp89 := lang.Apply(tmp84, []any{tmp86, tmp88})
				tmp90 := lang.Apply(tmp83, []any{tmp89})
				tmp91 := lang.Apply(tmp82, []any{tmp90})
				tmp92 := lang.Apply(tmp71, []any{tmp81, tmp91})
				tmp93 := lang.Apply(tmp70, []any{tmp92})
				tmp94 := lang.Apply(tmp68, []any{tmp69, tmp93})
				tmp95 := lang.Apply(tmp67, []any{tmp94})
				tmp96 := checkDerefVar(var_clojure_DOT_core_list)
				tmp97 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp98 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp99 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp100 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp101 := checkDerefVar(var_clojure_DOT_core_list)
				tmp102 := lang.Apply(tmp101, []any{nil})
				tmp103 := checkDerefVar(var_clojure_DOT_core_list)
				tmp104 := lang.Apply(tmp103, []any{sym_res__0__auto__})
				tmp105 := lang.Apply(tmp100, []any{tmp102, tmp104})
				tmp106 := lang.Apply(tmp99, []any{tmp105})
				tmp107 := lang.Apply(tmp97, []any{tmp98, tmp106})
				tmp108 := lang.Apply(tmp96, []any{tmp107})
				tmp109 := lang.Apply(tmp54, []any{tmp56, tmp66, tmp95, tmp108})
				tmp110 := lang.Apply(tmp53, []any{tmp109})
				tmp111 := lang.Apply(tmp52, []any{tmp110})
				tmp112 := checkDerefVar(var_clojure_DOT_core_list)
				tmp113 := lang.Apply(tmp112, []any{sym_res__0__auto__})
				tmp114 := checkDerefVar(var_clojure_DOT_core_list)
				tmp115 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp116 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp117 := checkDerefVar(var_clojure_DOT_core_list)
				tmp118 := lang.Apply(tmp117, []any{sym_if})
				tmp119 := checkDerefVar(var_clojure_DOT_core_list)
				tmp120 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp121 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp122 := checkDerefVar(var_clojure_DOT_core_list)
				tmp123 := lang.Apply(tmp122, []any{sym_clojure_DOT_core_SLASH_not_DASH_empty})
				tmp124 := checkDerefVar(var_clojure_DOT_core_list)
				tmp125 := lang.Apply(tmp124, []any{sym_rst__2__auto__})
				tmp126 := lang.Apply(tmp121, []any{tmp123, tmp125})
				tmp127 := lang.Apply(tmp120, []any{tmp126})
				tmp128 := lang.Apply(tmp119, []any{tmp127})
				tmp129 := checkDerefVar(var_clojure_DOT_core_list)
				tmp130 := lang.Apply(tmp129, []any{sym_res__0__auto__})
				tmp131 := checkDerefVar(var_clojure_DOT_core_list)
				tmp132 := lang.Apply(tmp131, []any{sym_fst__1__auto__})
				tmp133 := lang.Apply(tmp116, []any{tmp118, tmp128, tmp130, tmp132})
				tmp134 := lang.Apply(tmp115, []any{tmp133})
				tmp135 := lang.Apply(tmp114, []any{tmp134})
				tmp136 := lang.Apply(tmp13, []any{tmp15, tmp21, tmp51, tmp111, tmp113, tmp135})
				tmp137 := lang.Apply(tmp12, []any{tmp136})
				tmp138 := lang.Apply(tmp10, []any{tmp11, tmp137})
				tmp139 := lang.Apply(tmp9, []any{tmp138})
				tmp140 := checkDerefVar(var_clojure_DOT_core_list)
				tmp141 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp142 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp143 := checkDerefVar(var_clojure_DOT_core_list)
				tmp144 := lang.Apply(tmp143, []any{sym_clojure_DOT_core_SLASH_when})
				tmp145 := checkDerefVar(var_clojure_DOT_core_list)
				tmp146 := lang.Apply(tmp145, []any{sym_err__3__auto__})
				tmp147 := checkDerefVar(var_clojure_DOT_core_list)
				tmp148 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp149 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp150 := checkDerefVar(var_clojure_DOT_core_list)
				tmp151 := lang.Apply(tmp150, []any{sym_throw})
				tmp152 := checkDerefVar(var_clojure_DOT_core_list)
				tmp153 := lang.Apply(tmp152, []any{sym_err__3__auto__})
				tmp154 := lang.Apply(tmp149, []any{tmp151, tmp153})
				tmp155 := lang.Apply(tmp148, []any{tmp154})
				tmp156 := lang.Apply(tmp147, []any{tmp155})
				tmp157 := lang.Apply(tmp142, []any{tmp144, tmp146, tmp156})
				tmp158 := lang.Apply(tmp141, []any{tmp157})
				tmp159 := lang.Apply(tmp140, []any{tmp158})
				tmp160 := checkDerefVar(var_clojure_DOT_core_list)
				tmp161 := lang.Apply(tmp160, []any{sym_res__0__auto__})
				tmp162 := lang.Apply(tmp6, []any{tmp8, tmp139, tmp159, tmp161})
				tmp163 := lang.Apply(tmp5, []any{tmp162})
				return tmp163
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_go_DOT_io_go_DASH_try_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_io_go_DASH_try_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-input-stream
	{
		tmp0 := sym_make_DASH_input_DASH_stream.WithMeta(lang.NewMap(kw_added, "1.2", kw_file, "glojure/go/io.glj", kw_line, int(86), kw_column, int(4), kw_end_DASH_line, int(86), kw_end_DASH_column, int(36), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v3})
				return tmp6
			}
		})
		// MultiFn make-input-stream
		tmp1 := lang.NewMultiFn("make-input-stream", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp3 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v5 := args[0]
				_ = v5
				restArgs := args[1:]
				var v6 any
				if len(restArgs) > 0 {
					v6 = lang.NewList(restArgs...)
				}
				_ = v6
				tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v5, v6})
				tmp10 := lang.Apply(tmp7, []any{closed3, tmp9})
				return tmp10
			}
		})
		tmp1.AddMethod(tmp3, tmp4)
		tmp5 := reflect.TypeOf((*os6.File)(nil))
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v7 := args[0]
				_ = v7
				restArgs := args[1:]
				var v8 any
				if len(restArgs) > 0 {
					v8 = lang.NewList(restArgs...)
				}
				_ = v8
				tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp10 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp11 := lang.Apply(tmp10, []any{v7, v8})
				tmp12 := lang.Apply(tmp9, []any{closed4, tmp11})
				return tmp12
			}
		})
		tmp1.AddMethod(tmp5, tmp6)
		tmp7 := reflect.TypeOf((*url5.URL)(nil))
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v9 := args[0]
				_ = v9
				restArgs := args[1:]
				var v10 any
				if len(restArgs) > 0 {
					v10 = lang.NewList(restArgs...)
				}
				_ = v10
				tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp13 := lang.Apply(tmp12, []any{v9, v10})
				tmp14 := lang.Apply(tmp11, []any{closed5, tmp13})
				return tmp14
			}
		})
		tmp1.AddMethod(tmp7, tmp8)
		tmp9 := reflect.TypeOf("")
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v11 := args[0]
				_ = v11
				restArgs := args[1:]
				var v12 any
				if len(restArgs) > 0 {
					v12 = lang.NewList(restArgs...)
				}
				_ = v12
				tmp13 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp14 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp15 := lang.Apply(tmp14, []any{v11, v12})
				tmp16 := lang.Apply(tmp13, []any{closed6, tmp15})
				return tmp16
			}
		})
		tmp1.AddMethod(tmp9, tmp10)
		var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-output-stream
	{
		tmp0 := sym_make_DASH_output_DASH_stream.WithMeta(lang.NewMap(kw_added, "1.2", kw_file, "glojure/go/io.glj", kw_line, int(87), kw_column, int(4), kw_end_DASH_line, int(87), kw_end_DASH_column, int(37), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v3})
				return tmp6
			}
		})
		// MultiFn make-output-stream
		tmp1 := lang.NewMultiFn("make-output-stream", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp3 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v5 := args[0]
				_ = v5
				restArgs := args[1:]
				var v6 any
				if len(restArgs) > 0 {
					v6 = lang.NewList(restArgs...)
				}
				_ = v6
				tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v5, v6})
				tmp10 := lang.Apply(tmp7, []any{closed7, tmp9})
				return tmp10
			}
		})
		tmp1.AddMethod(tmp3, tmp4)
		tmp5 := reflect.TypeOf((*os6.File)(nil))
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v7 := args[0]
				_ = v7
				restArgs := args[1:]
				var v8 any
				if len(restArgs) > 0 {
					v8 = lang.NewList(restArgs...)
				}
				_ = v8
				tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp10 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp11 := lang.Apply(tmp10, []any{v7, v8})
				tmp12 := lang.Apply(tmp9, []any{closed8, tmp11})
				return tmp12
			}
		})
		tmp1.AddMethod(tmp5, tmp6)
		tmp7 := reflect.TypeOf((*url5.URL)(nil))
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v9 := args[0]
				_ = v9
				restArgs := args[1:]
				var v10 any
				if len(restArgs) > 0 {
					v10 = lang.NewList(restArgs...)
				}
				_ = v10
				tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp13 := lang.Apply(tmp12, []any{v9, v10})
				tmp14 := lang.Apply(tmp11, []any{closed9, tmp13})
				return tmp14
			}
		})
		tmp1.AddMethod(tmp7, tmp8)
		tmp9 := reflect.TypeOf("")
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v11 := args[0]
				_ = v11
				restArgs := args[1:]
				var v12 any
				if len(restArgs) > 0 {
					v12 = lang.NewList(restArgs...)
				}
				_ = v12
				tmp13 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp14 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp15 := lang.Apply(tmp14, []any{v11, v12})
				tmp16 := lang.Apply(tmp13, []any{closed10, tmp15})
				return tmp16
			}
		})
		tmp1.AddMethod(tmp9, tmp10)
		var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-reader
	{
		tmp0 := sym_make_DASH_reader.WithMeta(lang.NewMap(kw_added, "1.2", kw_file, "glojure/go/io.glj", kw_line, int(84), kw_column, int(4), kw_end_DASH_line, int(84), kw_end_DASH_column, int(30), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v3})
				return tmp6
			}
		})
		// MultiFn make-reader
		tmp1 := lang.NewMultiFn("make-reader", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp3 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v5 := args[0]
				_ = v5
				restArgs := args[1:]
				var v6 any
				if len(restArgs) > 0 {
					v6 = lang.NewList(restArgs...)
				}
				_ = v6
				tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v5, v6})
				tmp10 := lang.Apply(tmp7, []any{closed0, tmp9})
				return tmp10
			}
		})
		tmp1.AddMethod(tmp3, tmp4)
		tmp5 := reflect.TypeOf((*url5.URL)(nil))
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v7 := args[0]
				_ = v7
				restArgs := args[1:]
				var v8 any
				if len(restArgs) > 0 {
					v8 = lang.NewList(restArgs...)
				}
				_ = v8
				tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp10 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp11 := lang.Apply(tmp10, []any{v7, v8})
				tmp12 := lang.Apply(tmp9, []any{closed1, tmp11})
				return tmp12
			}
		})
		tmp1.AddMethod(tmp5, tmp6)
		tmp7 := reflect.TypeOf("")
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v9 := args[0]
				_ = v9
				restArgs := args[1:]
				var v10 any
				if len(restArgs) > 0 {
					v10 = lang.NewList(restArgs...)
				}
				_ = v10
				tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp13 := lang.Apply(tmp12, []any{v9, v10})
				tmp14 := lang.Apply(tmp11, []any{closed1, tmp13})
				return tmp14
			}
		})
		tmp1.AddMethod(tmp7, tmp8)
		var_glojure_DOT_go_DOT_io_make_DASH_reader = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_io_make_DASH_reader.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-writer
	{
		tmp0 := sym_make_DASH_writer.WithMeta(lang.NewMap(kw_added, "1.2", kw_file, "glojure/go/io.glj", kw_line, int(85), kw_column, int(4), kw_end_DASH_line, int(85), kw_end_DASH_column, int(30), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v3})
				return tmp6
			}
		})
		// MultiFn make-writer
		tmp1 := lang.NewMultiFn("make-writer", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp3 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v5 := args[0]
				_ = v5
				restArgs := args[1:]
				var v6 any
				if len(restArgs) > 0 {
					v6 = lang.NewList(restArgs...)
				}
				_ = v6
				tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v5, v6})
				tmp10 := lang.Apply(tmp7, []any{closed2, tmp9})
				return tmp10
			}
		})
		tmp1.AddMethod(tmp3, tmp4)
		tmp5 := reflect.TypeOf((*url5.URL)(nil))
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v7 := args[0]
				_ = v7
				restArgs := args[1:]
				var v8 any
				if len(restArgs) > 0 {
					v8 = lang.NewList(restArgs...)
				}
				_ = v8
				tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp10 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp11 := lang.Apply(tmp10, []any{v7, v8})
				tmp12 := lang.Apply(tmp9, []any{closed2, tmp11})
				return tmp12
			}
		})
		tmp1.AddMethod(tmp5, tmp6)
		tmp7 := reflect.TypeOf("")
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v9 := args[0]
				_ = v9
				restArgs := args[1:]
				var v10 any
				if len(restArgs) > 0 {
					v10 = lang.NewList(restArgs...)
				}
				_ = v10
				tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp13 := lang.Apply(tmp12, []any{v9, v10})
				tmp14 := lang.Apply(tmp11, []any{closed2, tmp13})
				return tmp14
			}
		})
		tmp1.AddMethod(tmp7, tmp8)
		var_glojure_DOT_go_DOT_io_make_DASH_writer = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_io_make_DASH_writer.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reader
	{
		tmp1 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		tmp0 := sym_reader.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_opts)), kw_doc, "Attempts to coerce its argument into an open io.Reader.\n\n   Default implementations are provided for Reader, BufferedReader,\n   InputStream, File, URI, URL, Socket, byte slices, rune slices,\n   and string.\n\n   If argument is a string, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the io.Reader is properly\n   closed.", kw_file, "glojure/go/io.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_io), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(89), kw_end_DASH_line, int(89))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_reader)
				var tmp6 any
				if lang.IsTruthy(v4) {
					tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp8 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
					tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
					tmp6 = tmp9
				} else {
				}
				tmp10 := lang.Apply(tmp5, []any{v3, tmp6})
				return tmp10
			}
		})
		tmp3 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_glojure_DOT_go_DOT_io_reader = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_io_reader.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}

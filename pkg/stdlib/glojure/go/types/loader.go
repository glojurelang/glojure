// Code generated by glojure codegen. DO NOT EDIT.

package types

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	ast4 "go/ast"
	parser5 "go/parser"
	reflect "reflect"
	strconv6 "strconv"
)

func init() {
	runtime.RegisterNSLoader("glojure/go/types", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "glojure.go.types"
func LoadNS() {
	sym__EQ_ := lang.NewSymbol("=")
	sym_AstType := lang.NewSymbol("AstType")
	sym_apply := lang.NewSymbol("apply")
	sym_ast := lang.NewSymbol("ast")
	sym_ast_DASH__GT_type := lang.NewSymbol("ast->type")
	sym_butlast := lang.NewSymbol("butlast")
	sym_class := lang.NewSymbol("class")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_concat := lang.NewSymbol("concat")
	sym_cons := lang.NewSymbol("cons")
	sym_count := lang.NewSymbol("count")
	sym_empty_QMARK_ := lang.NewSymbol("empty?")
	sym_first := lang.NewSymbol("first")
	sym_from_DASH_string := lang.NewSymbol("from-string")
	sym_get := lang.NewSymbol("get")
	sym_global_DASH_hierarchy := lang.NewSymbol("global-hierarchy")
	sym_glojure_DOT_go_DOT_types := lang.NewSymbol("glojure.go.types")
	sym_instance_QMARK_ := lang.NewSymbol("instance?")
	sym_last := lang.NewSymbol("last")
	sym_map := lang.NewSymbol("map")
	sym_max := lang.NewSymbol("max")
	sym_name := lang.NewSymbol("name")
	sym_nil_QMARK_ := lang.NewSymbol("nil?")
	sym_not := lang.NewSymbol("not")
	sym_nth := lang.NewSymbol("nth")
	sym_repeat := lang.NewSymbol("repeat")
	sym_string_QMARK_ := lang.NewSymbol("string?")
	sym_struct_DASH_field := lang.NewSymbol("struct-field")
	sym_typ := lang.NewSymbol("typ")
	sym_type_DASH_ast := lang.NewSymbol("type-ast")
	kw_arglists := lang.NewKeyword("arglists")
	kw_ast_DASH__GT_type := lang.NewKeyword("ast->type")
	kw_column := lang.NewKeyword("column")
	kw_default := lang.NewKeyword("default")
	kw_doc := lang.NewKeyword("doc")
	kw_else := lang.NewKeyword("else")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_multis := lang.NewKeyword("multis")
	kw_ns := lang.NewKeyword("ns")
	kw_on_DASH_interface := lang.NewKeyword("on-interface")
	kw_private := lang.NewKeyword("private")
	kw_rettag := lang.NewKeyword("rettag")
	kw_sigs := lang.NewKeyword("sigs")
	// var clojure.core/=
	var_clojure_DOT_core__EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym__EQ_)
	// var clojure.core/apply
	var_clojure_DOT_core_apply := lang.InternVarName(sym_clojure_DOT_core, sym_apply)
	// var clojure.core/butlast
	var_clojure_DOT_core_butlast := lang.InternVarName(sym_clojure_DOT_core, sym_butlast)
	// var clojure.core/class
	var_clojure_DOT_core_class := lang.InternVarName(sym_clojure_DOT_core, sym_class)
	// var clojure.core/concat
	var_clojure_DOT_core_concat := lang.InternVarName(sym_clojure_DOT_core, sym_concat)
	// var clojure.core/cons
	var_clojure_DOT_core_cons := lang.InternVarName(sym_clojure_DOT_core, sym_cons)
	// var clojure.core/count
	var_clojure_DOT_core_count := lang.InternVarName(sym_clojure_DOT_core, sym_count)
	// var clojure.core/empty?
	var_clojure_DOT_core_empty_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_empty_QMARK_)
	// var clojure.core/first
	var_clojure_DOT_core_first := lang.InternVarName(sym_clojure_DOT_core, sym_first)
	// var clojure.core/get
	var_clojure_DOT_core_get := lang.InternVarName(sym_clojure_DOT_core, sym_get)
	// var clojure.core/instance?
	var_clojure_DOT_core_instance_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_instance_QMARK_)
	// var clojure.core/last
	var_clojure_DOT_core_last := lang.InternVarName(sym_clojure_DOT_core, sym_last)
	// var clojure.core/map
	var_clojure_DOT_core_map := lang.InternVarName(sym_clojure_DOT_core, sym_map)
	// var clojure.core/max
	var_clojure_DOT_core_max := lang.InternVarName(sym_clojure_DOT_core, sym_max)
	// var clojure.core/nil?
	var_clojure_DOT_core_nil_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_nil_QMARK_)
	// var clojure.core/not
	var_clojure_DOT_core_not := lang.InternVarName(sym_clojure_DOT_core, sym_not)
	// var clojure.core/nth
	var_clojure_DOT_core_nth := lang.InternVarName(sym_clojure_DOT_core, sym_nth)
	// var clojure.core/repeat
	var_clojure_DOT_core_repeat := lang.InternVarName(sym_clojure_DOT_core, sym_repeat)
	// var clojure.core/string?
	var_clojure_DOT_core_string_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_string_QMARK_)
	// var glojure.go.types/AstType
	var_glojure_DOT_go_DOT_types_AstType := lang.InternVarName(sym_glojure_DOT_go_DOT_types, sym_AstType)
	// var glojure.go.types/ast->type
	var_glojure_DOT_go_DOT_types_ast_DASH__GT_type := lang.InternVarName(sym_glojure_DOT_go_DOT_types, sym_ast_DASH__GT_type)
	// var glojure.go.types/from-string
	var_glojure_DOT_go_DOT_types_from_DASH_string := lang.InternVarName(sym_glojure_DOT_go_DOT_types, sym_from_DASH_string)
	// var glojure.go.types/struct-field
	var_glojure_DOT_go_DOT_types_struct_DASH_field := lang.InternVarName(sym_glojure_DOT_go_DOT_types, sym_struct_DASH_field)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_types)
	_ = ns
	var closed0 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			var tmp2 any
			{ // let
				// let binding "name"
				tmp3, ok := lang.FieldOrMethod(v1, "Name")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "Name")))
				}
				var tmp4 any
				switch reflect.TypeOf(tmp3).Kind() {
				case reflect.Func:
					tmp4 = lang.Apply(tmp3, nil)
				default:
					tmp4 = tmp3
				}
				var v5 any = tmp4
				_ = v5
				// let binding "typ"
				tmp6 := checkDerefVar(var_clojure_DOT_core_get)
				tmp7 := lang.Apply(tmp6, []any{lang.BuiltinTypes, v5})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
				} else {
					tmp10 := lang.Apply(fmt.Errorf, []any{"unknown type %s", v5})
					panic(tmp10)
				}
				_ = tmp9
				tmp2 = v8
			} // end let
			return tmp2
		})
		closed0 = tmp0
	}
	var closed1 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			var tmp2 any
			{ // let
				// let binding "len"
				tmp3, ok := lang.FieldOrMethod(v1, "Len")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "Len")))
				}
				var tmp4 any
				switch reflect.TypeOf(tmp3).Kind() {
				case reflect.Func:
					tmp4 = lang.Apply(tmp3, nil)
				default:
					tmp4 = tmp3
				}
				var v5 any = tmp4
				_ = v5
				// let binding "elt"
				tmp6 := checkDerefVar(var_glojure_DOT_go_DOT_types_ast_DASH__GT_type)
				tmp7, ok := lang.FieldOrMethod(v1, "Elt")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "Elt")))
				}
				var tmp8 any
				switch reflect.TypeOf(tmp7).Kind() {
				case reflect.Func:
					tmp8 = lang.Apply(tmp7, nil)
				default:
					tmp8 = tmp7
				}
				tmp9 := lang.Apply(tmp6, []any{tmp8})
				var v10 any = tmp9
				_ = v10
				var tmp11 any
				if lang.IsTruthy(v5) {
					tmp12 := checkDerefVar(var_clojure_DOT_core_first)
					tmp13, ok := lang.FieldOrMethod(v5, "Value")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "Value")))
					}
					var tmp14 any
					switch reflect.TypeOf(tmp13).Kind() {
					case reflect.Func:
						tmp14 = lang.Apply(tmp13, nil)
					default:
						tmp14 = tmp13
					}
					tmp15 := lang.Apply(strconv6.Atoi, []any{tmp14})
					tmp16 := lang.Apply(tmp12, []any{tmp15})
					tmp17 := lang.Apply(lang.Builtins["array-of"], []any{tmp16, v10})
					tmp11 = tmp17
				} else {
					tmp18 := lang.Apply(lang.Builtins["slice-of"], []any{v10})
					tmp11 = tmp18
				}
				tmp2 = tmp11
			} // end let
			return tmp2
		})
		closed1 = tmp0
	}
	var closed2 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			tmp2 := checkDerefVar(var_glojure_DOT_go_DOT_types_ast_DASH__GT_type)
			tmp3, ok := lang.FieldOrMethod(v1, "Key")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "Key")))
			}
			var tmp4 any
			switch reflect.TypeOf(tmp3).Kind() {
			case reflect.Func:
				tmp4 = lang.Apply(tmp3, nil)
			default:
				tmp4 = tmp3
			}
			tmp5 := lang.Apply(tmp2, []any{tmp4})
			tmp6 := checkDerefVar(var_glojure_DOT_go_DOT_types_ast_DASH__GT_type)
			tmp7, ok := lang.FieldOrMethod(v1, "Value")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "Value")))
			}
			var tmp8 any
			switch reflect.TypeOf(tmp7).Kind() {
			case reflect.Func:
				tmp8 = lang.Apply(tmp7, nil)
			default:
				tmp8 = tmp7
			}
			tmp9 := lang.Apply(tmp6, []any{tmp8})
			tmp10 := lang.Apply(lang.Builtins["map-of"], []any{tmp5, tmp9})
			return tmp10
		})
		closed2 = tmp0
	}
	var closed3 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			var tmp2 any
			{ // let
				// let binding "dir"
				tmp3, ok := lang.FieldOrMethod(v1, "Dir")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "Dir")))
				}
				var tmp4 any
				switch reflect.TypeOf(tmp3).Kind() {
				case reflect.Func:
					tmp4 = lang.Apply(tmp3, nil)
				default:
					tmp4 = tmp3
				}
				var v5 any = tmp4
				_ = v5
				// let binding "ctor"
				var tmp6 any
				tmp7 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp8 := lang.Apply(tmp7, []any{v5, ast4.SEND})
				if lang.IsTruthy(tmp8) {
					tmp6 = lang.Builtins["chan<--of"]
				} else {
					var tmp9 any
					tmp10 := checkDerefVar(var_clojure_DOT_core__EQ_)
					tmp11 := lang.Apply(tmp10, []any{v5, ast4.RECV})
					if lang.IsTruthy(tmp11) {
						tmp9 = lang.Builtins["<-chan-of"]
					} else {
						var tmp12 any
						if lang.IsTruthy(kw_else) {
							tmp12 = lang.Builtins["chan-of"]
						} else {
						}
						tmp9 = tmp12
					}
					tmp6 = tmp9
				}
				var v13 any = tmp6
				_ = v13
				tmp14 := checkDerefVar(var_glojure_DOT_go_DOT_types_ast_DASH__GT_type)
				tmp15, ok := lang.FieldOrMethod(v1, "Value")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "Value")))
				}
				var tmp16 any
				switch reflect.TypeOf(tmp15).Kind() {
				case reflect.Func:
					tmp16 = lang.Apply(tmp15, nil)
				default:
					tmp16 = tmp15
				}
				tmp17 := lang.Apply(tmp14, []any{tmp16})
				tmp18 := lang.Apply(v13, []any{tmp17})
				tmp2 = tmp18
			} // end let
			return tmp2
		})
		closed3 = tmp0
	}
	var closed4 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			var tmp2 any
			{ // let
				// let binding "pl"
				var tmp3 any
				{ // let
					// let binding "or__0__auto__"
					tmp4, ok := lang.FieldOrMethod(v1, "Params")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "Params")))
					}
					var tmp5 any
					switch reflect.TypeOf(tmp4).Kind() {
					case reflect.Func:
						tmp5 = lang.Apply(tmp4, nil)
					default:
						tmp5 = tmp4
					}
					var v6 any = tmp5
					_ = v6
					var tmp7 any
					if lang.IsTruthy(v6) {
						tmp7 = v6
					} else {
					}
					tmp3 = tmp7
				} // end let
				var v4 any = tmp3
				_ = v4
				// let binding "params"
				var tmp5 any
				{ // let
					// let binding "and__0__auto__"
					var v6 any = v4
					_ = v6
					var tmp7 any
					if lang.IsTruthy(v6) {
						tmp8 := checkDerefVar(var_clojure_DOT_core_apply)
						tmp9 := checkDerefVar(var_clojure_DOT_core_concat)
						tmp10 := checkDerefVar(var_clojure_DOT_core_map)
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v12 := args[0]
							_ = v12
							tmp13 := checkDerefVar(var_clojure_DOT_core_repeat)
							tmp14 := checkDerefVar(var_clojure_DOT_core_max)
							tmp15, ok := lang.FieldOrMethod(v12, "Names")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "Names")))
							}
							var tmp16 any
							switch reflect.TypeOf(tmp15).Kind() {
							case reflect.Func:
								tmp16 = lang.Apply(tmp15, nil)
							default:
								tmp16 = tmp15
							}
							tmp17 := lang.Apply(lang.Builtins["len"], []any{tmp16})
							tmp18 := lang.Apply(tmp14, []any{int64(1), tmp17})
							tmp19, ok := lang.FieldOrMethod(v12, "Type")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "Type")))
							}
							var tmp20 any
							switch reflect.TypeOf(tmp19).Kind() {
							case reflect.Func:
								tmp20 = lang.Apply(tmp19, nil)
							default:
								tmp20 = tmp19
							}
							tmp21 := lang.Apply(tmp13, []any{tmp18, tmp20})
							return tmp21
						})
						tmp12 := lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(59), kw_column, int(33), kw_end_DASH_line, int(59), kw_end_DASH_column, int(79))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp14, ok := lang.FieldOrMethod(v4, "List")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "List")))
						}
						var tmp15 any
						switch reflect.TypeOf(tmp14).Kind() {
						case reflect.Func:
							tmp15 = lang.Apply(tmp14, nil)
						default:
							tmp15 = tmp14
						}
						tmp16 := lang.Apply(tmp10, []any{tmp13, tmp15})
						tmp17 := lang.Apply(tmp8, []any{tmp9, tmp16})
						tmp7 = tmp17
					} else {
						tmp7 = v6
					}
					tmp5 = tmp7
				} // end let
				var v6 any = tmp5
				_ = v6
				// let binding "last-param"
				tmp7 := checkDerefVar(var_clojure_DOT_core_last)
				tmp8 := lang.Apply(tmp7, []any{v6})
				var v9 any = tmp8
				_ = v9
				// let binding "variadic"
				tmp10 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
				tmp11 := reflect.TypeOf((*ast4.Ellipsis)(nil))
				tmp12 := lang.Apply(tmp10, []any{tmp11, v9})
				var v13 any = tmp12
				_ = v13
				// let binding "params"
				var tmp14 any
				tmp15 := checkDerefVar(var_clojure_DOT_core_not)
				tmp16 := lang.Apply(tmp15, []any{v13})
				if lang.IsTruthy(tmp16) {
					tmp17 := checkDerefVar(var_clojure_DOT_core_map)
					tmp18 := checkDerefVar(var_glojure_DOT_go_DOT_types_ast_DASH__GT_type)
					tmp19 := lang.Apply(tmp17, []any{tmp18, v6})
					tmp14 = tmp19
				} else {
					tmp20 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp21 := checkDerefVar(var_clojure_DOT_core_map)
					tmp22 := checkDerefVar(var_glojure_DOT_go_DOT_types_ast_DASH__GT_type)
					tmp23 := checkDerefVar(var_clojure_DOT_core_butlast)
					tmp24 := lang.Apply(tmp23, []any{v6})
					tmp25 := lang.Apply(tmp21, []any{tmp22, tmp24})
					tmp26 := checkDerefVar(var_glojure_DOT_go_DOT_types_ast_DASH__GT_type)
					tmp27, ok := lang.FieldOrMethod(v9, "Elt")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Elt")))
					}
					var tmp28 any
					switch reflect.TypeOf(tmp27).Kind() {
					case reflect.Func:
						tmp28 = lang.Apply(tmp27, nil)
					default:
						tmp28 = tmp27
					}
					tmp29 := lang.Apply(tmp26, []any{tmp28})
					tmp30 := lang.Apply(lang.Builtins["slice-of"], []any{tmp29})
					tmp31 := lang.NewVector(tmp30)
					tmp32 := lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(66), kw_column, int(28), kw_end_DASH_line, int(66), kw_end_DASH_column, int(72))
					tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp34 := lang.Apply(tmp20, []any{tmp25, tmp33})
					tmp14 = tmp34
				}
				var v35 any = tmp14
				_ = v35
				// let binding "rl"
				var tmp36 any
				{ // let
					// let binding "or__0__auto__"
					tmp37, ok := lang.FieldOrMethod(v1, "Results")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "Results")))
					}
					var tmp38 any
					switch reflect.TypeOf(tmp37).Kind() {
					case reflect.Func:
						tmp38 = lang.Apply(tmp37, nil)
					default:
						tmp38 = tmp37
					}
					var v39 any = tmp38
					_ = v39
					var tmp40 any
					if lang.IsTruthy(v39) {
						tmp40 = v39
					} else {
					}
					tmp36 = tmp40
				} // end let
				var v37 any = tmp36
				_ = v37
				// let binding "results"
				var tmp38 any
				{ // let
					// let binding "and__0__auto__"
					var v39 any = v37
					_ = v39
					var tmp40 any
					if lang.IsTruthy(v39) {
						tmp41 := checkDerefVar(var_clojure_DOT_core_map)
						tmp42 := checkDerefVar(var_glojure_DOT_go_DOT_types_ast_DASH__GT_type)
						tmp43 := checkDerefVar(var_clojure_DOT_core_apply)
						tmp44 := checkDerefVar(var_clojure_DOT_core_concat)
						tmp45 := checkDerefVar(var_clojure_DOT_core_map)
						var tmp46 lang.FnFunc
						tmp46 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v47 := args[0]
							_ = v47
							tmp48 := checkDerefVar(var_clojure_DOT_core_repeat)
							tmp49 := checkDerefVar(var_clojure_DOT_core_max)
							tmp50, ok := lang.FieldOrMethod(v47, "Names")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v47, "Names")))
							}
							var tmp51 any
							switch reflect.TypeOf(tmp50).Kind() {
							case reflect.Func:
								tmp51 = lang.Apply(tmp50, nil)
							default:
								tmp51 = tmp50
							}
							tmp52 := lang.Apply(lang.Builtins["len"], []any{tmp51})
							tmp53 := lang.Apply(tmp49, []any{int64(1), tmp52})
							tmp54, ok := lang.FieldOrMethod(v47, "Type")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v47, "Type")))
							}
							var tmp55 any
							switch reflect.TypeOf(tmp54).Kind() {
							case reflect.Func:
								tmp55 = lang.Apply(tmp54, nil)
							default:
								tmp55 = tmp54
							}
							tmp56 := lang.Apply(tmp48, []any{tmp53, tmp55})
							return tmp56
						})
						tmp47 := lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(70), kw_column, int(34), kw_end_DASH_line, int(70), kw_end_DASH_column, int(80))
						tmp48, err := lang.WithMeta(tmp46, tmp47.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp49, ok := lang.FieldOrMethod(v37, "List")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v37, "List")))
						}
						var tmp50 any
						switch reflect.TypeOf(tmp49).Kind() {
						case reflect.Func:
							tmp50 = lang.Apply(tmp49, nil)
						default:
							tmp50 = tmp49
						}
						tmp51 := lang.Apply(tmp45, []any{tmp48, tmp50})
						tmp52 := lang.Apply(tmp43, []any{tmp44, tmp51})
						tmp53 := lang.Apply(tmp41, []any{tmp42, tmp52})
						tmp40 = tmp53
					} else {
						tmp40 = v39
					}
					tmp38 = tmp40
				} // end let
				var v39 any = tmp38
				_ = v39
				tmp40 := lang.Apply(lang.Builtins["func-of"], []any{v35, v39, v13})
				tmp2 = tmp40
			} // end let
			return tmp2
		})
		closed4 = tmp0
	}
	var closed5 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			var tmp2 any
			{ // let
				// let binding "fields"
				tmp3, ok := lang.FieldOrMethod(v1, "Fields")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "Fields")))
				}
				var tmp4 any
				switch reflect.TypeOf(tmp3).Kind() {
				case reflect.Func:
					tmp4 = lang.Apply(tmp3, nil)
				default:
					tmp4 = tmp3
				}
				tmp5, ok := lang.FieldOrMethod(tmp4, "List")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp4, "List")))
				}
				var tmp6 any
				switch reflect.TypeOf(tmp5).Kind() {
				case reflect.Func:
					tmp6 = lang.Apply(tmp5, nil)
				default:
					tmp6 = tmp5
				}
				var v7 any = tmp6
				_ = v7
				// let binding "struct-fields"
				tmp8 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp9 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp10 := checkDerefVar(var_clojure_DOT_core_map)
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v12 := args[0]
					_ = v12
					var tmp13 any
					{ // let
						// let binding "names"
						tmp14 := checkDerefVar(var_clojure_DOT_core_map)
						var tmp15 lang.FnFunc
						tmp15 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v16 := args[0]
							_ = v16
							tmp17, ok := lang.FieldOrMethod(v16, "Name")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v16, "Name")))
							}
							var tmp18 any
							switch reflect.TypeOf(tmp17).Kind() {
							case reflect.Func:
								tmp18 = lang.Apply(tmp17, nil)
							default:
								tmp18 = tmp17
							}
							return tmp18
						})
						tmp16 := lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(81), kw_column, int(54), kw_end_DASH_line, int(81), kw_end_DASH_column, int(63))
						tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp18, ok := lang.FieldOrMethod(v12, "Names")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "Names")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						tmp20 := lang.Apply(tmp14, []any{tmp17, tmp19})
						var v21 any = tmp20
						_ = v21
						// let binding "type"
						tmp22, ok := lang.FieldOrMethod(v12, "Type")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "Type")))
						}
						var tmp23 any
						switch reflect.TypeOf(tmp22).Kind() {
						case reflect.Func:
							tmp23 = lang.Apply(tmp22, nil)
						default:
							tmp23 = tmp22
						}
						var v24 any = tmp23
						_ = v24
						// let binding "tag"
						tmp25, ok := lang.FieldOrMethod(v12, "Type")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "Type")))
						}
						var tmp26 any
						switch reflect.TypeOf(tmp25).Kind() {
						case reflect.Func:
							tmp26 = lang.Apply(tmp25, nil)
						default:
							tmp26 = tmp25
						}
						var v27 any = tmp26
						_ = v27
						var tmp28 any
						tmp29 := checkDerefVar(var_clojure_DOT_core_empty_QMARK_)
						tmp30 := lang.Apply(tmp29, []any{v21})
						if lang.IsTruthy(tmp30) {
							tmp31 := checkDerefVar(var_glojure_DOT_go_DOT_types_struct_DASH_field)
							tmp32 := lang.Apply(tmp31, []any{v24})
							tmp33 := lang.NewVector(tmp32)
							tmp34 := lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(85), kw_column, int(56), kw_end_DASH_line, int(85), kw_end_DASH_column, int(76))
							tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp28 = tmp35
						} else {
							var tmp36 any
							tmp37 := checkDerefVar(var_clojure_DOT_core__EQ_)
							tmp38 := checkDerefVar(var_clojure_DOT_core_count)
							tmp39 := lang.Apply(tmp38, []any{v21})
							tmp40 := lang.Apply(tmp37, []any{int64(1), tmp39})
							if lang.IsTruthy(tmp40) {
								tmp41 := checkDerefVar(var_glojure_DOT_go_DOT_types_struct_DASH_field)
								tmp42 := checkDerefVar(var_clojure_DOT_core_first)
								tmp43 := lang.Apply(tmp42, []any{v21})
								tmp44 := lang.Apply(tmp41, []any{v24, tmp43})
								tmp45 := lang.NewVector(tmp44)
								tmp46 := lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(86), kw_column, int(61), kw_end_DASH_line, int(86), kw_end_DASH_column, int(95))
								tmp47, err := lang.WithMeta(tmp45, tmp46.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp36 = tmp47
							} else {
								var tmp48 any
								if lang.IsTruthy(kw_else) {
									tmp49 := checkDerefVar(var_clojure_DOT_core_map)
									var tmp50 lang.FnFunc
									tmp50 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v51 := args[0]
										_ = v51
										tmp52 := checkDerefVar(var_glojure_DOT_go_DOT_types_struct_DASH_field)
										tmp53 := lang.Apply(tmp52, []any{v24, v51})
										return tmp53
									})
									tmp51 := lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(87), kw_column, int(52), kw_end_DASH_line, int(87), kw_end_DASH_column, int(73))
									tmp52, err := lang.WithMeta(tmp50, tmp51.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp53 := lang.Apply(tmp49, []any{tmp52, v21})
									tmp48 = tmp53
								} else {
								}
								tmp36 = tmp48
							}
							tmp28 = tmp36
						}
						tmp13 = tmp28
					} // end let
					return tmp13
				})
				tmp12 := lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(80), kw_column, int(35), kw_end_DASH_line, int(87), kw_end_DASH_column, int(83))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.Apply(tmp10, []any{tmp13, v7})
				tmp15 := lang.Apply(tmp8, []any{tmp9, tmp14})
				var v16 any = tmp15
				_ = v16
				tmp17 := lang.Apply(reflect.StructOf, []any{v16})
				tmp2 = tmp17
			} // end let
			return tmp2
		})
		closed5 = tmp0
	}
	// AstType
	{
		tmp0 := sym_AstType.WithMeta(lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(3), kw_column, int(14), kw_end_DASH_line, int(3), kw_end_DASH_column, int(20), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_types))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v4 := args[0]
				_ = v4
				restArgs := args[1:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_class)
				tmp7 := lang.Apply(tmp6, []any{v4})
				return tmp7
			}
		})
		// MultiFn ast->type
		tmp2 := lang.NewMultiFn("ast->type", tmp3, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp4 := reflect.TypeOf((*ast4.Ident)(nil))
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v6 := args[0]
				_ = v6
				restArgs := args[1:]
				var v7 any
				if len(restArgs) > 0 {
					v7 = lang.NewList(restArgs...)
				}
				_ = v7
				tmp8 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp9 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v6, v7})
				tmp11 := lang.Apply(tmp8, []any{closed0, tmp10})
				return tmp11
			}
		})
		tmp2.AddMethod(tmp4, tmp5)
		tmp6 := reflect.TypeOf((*ast4.ArrayType)(nil))
		var tmp7 lang.FnFunc
		tmp7 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v8 := args[0]
				_ = v8
				restArgs := args[1:]
				var v9 any
				if len(restArgs) > 0 {
					v9 = lang.NewList(restArgs...)
				}
				_ = v9
				tmp10 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp11 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp12 := lang.Apply(tmp11, []any{v8, v9})
				tmp13 := lang.Apply(tmp10, []any{closed1, tmp12})
				return tmp13
			}
		})
		tmp2.AddMethod(tmp6, tmp7)
		tmp8 := reflect.TypeOf((*ast4.MapType)(nil))
		var tmp9 lang.FnFunc
		tmp9 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v10 := args[0]
				_ = v10
				restArgs := args[1:]
				var v11 any
				if len(restArgs) > 0 {
					v11 = lang.NewList(restArgs...)
				}
				_ = v11
				tmp12 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp13 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp14 := lang.Apply(tmp13, []any{v10, v11})
				tmp15 := lang.Apply(tmp12, []any{closed2, tmp14})
				return tmp15
			}
		})
		tmp2.AddMethod(tmp8, tmp9)
		tmp10 := reflect.TypeOf((*ast4.ChanType)(nil))
		var tmp11 lang.FnFunc
		tmp11 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v12 := args[0]
				_ = v12
				restArgs := args[1:]
				var v13 any
				if len(restArgs) > 0 {
					v13 = lang.NewList(restArgs...)
				}
				_ = v13
				tmp14 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp15 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp16 := lang.Apply(tmp15, []any{v12, v13})
				tmp17 := lang.Apply(tmp14, []any{closed3, tmp16})
				return tmp17
			}
		})
		tmp2.AddMethod(tmp10, tmp11)
		tmp12 := reflect.TypeOf((*ast4.FuncType)(nil))
		var tmp13 lang.FnFunc
		tmp13 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v14 := args[0]
				_ = v14
				restArgs := args[1:]
				var v15 any
				if len(restArgs) > 0 {
					v15 = lang.NewList(restArgs...)
				}
				_ = v15
				tmp16 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp17 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp18 := lang.Apply(tmp17, []any{v14, v15})
				tmp19 := lang.Apply(tmp16, []any{closed4, tmp18})
				return tmp19
			}
		})
		tmp2.AddMethod(tmp12, tmp13)
		tmp14 := reflect.TypeOf((*ast4.StructType)(nil))
		var tmp15 lang.FnFunc
		tmp15 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v16 := args[0]
				_ = v16
				restArgs := args[1:]
				var v17 any
				if len(restArgs) > 0 {
					v17 = lang.NewList(restArgs...)
				}
				_ = v17
				tmp18 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp19 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp20 := lang.Apply(tmp19, []any{v16, v17})
				tmp21 := lang.Apply(tmp18, []any{closed5, tmp20})
				return tmp21
			}
		})
		tmp2.AddMethod(tmp14, tmp15)
		tmp1 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_ast_DASH__GT_type, tmp2), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_ast_DASH__GT_type, lang.NewVector(sym_ast)))))
		var_glojure_DOT_go_DOT_types_AstType = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_types_AstType.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ast->type
	{
		tmp0 := sym_ast_DASH__GT_type.WithMeta(lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(4), kw_column, int(4), kw_end_DASH_line, int(4), kw_end_DASH_column, int(12), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_types))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v3})
				return tmp6
			}
		})
		// MultiFn ast->type
		tmp1 := lang.NewMultiFn("ast->type", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp3 := reflect.TypeOf((*ast4.Ident)(nil))
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v5 := args[0]
				_ = v5
				restArgs := args[1:]
				var v6 any
				if len(restArgs) > 0 {
					v6 = lang.NewList(restArgs...)
				}
				_ = v6
				tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v5, v6})
				tmp10 := lang.Apply(tmp7, []any{closed0, tmp9})
				return tmp10
			}
		})
		tmp1.AddMethod(tmp3, tmp4)
		tmp5 := reflect.TypeOf((*ast4.ArrayType)(nil))
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v7 := args[0]
				_ = v7
				restArgs := args[1:]
				var v8 any
				if len(restArgs) > 0 {
					v8 = lang.NewList(restArgs...)
				}
				_ = v8
				tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp10 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp11 := lang.Apply(tmp10, []any{v7, v8})
				tmp12 := lang.Apply(tmp9, []any{closed1, tmp11})
				return tmp12
			}
		})
		tmp1.AddMethod(tmp5, tmp6)
		tmp7 := reflect.TypeOf((*ast4.MapType)(nil))
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v9 := args[0]
				_ = v9
				restArgs := args[1:]
				var v10 any
				if len(restArgs) > 0 {
					v10 = lang.NewList(restArgs...)
				}
				_ = v10
				tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp13 := lang.Apply(tmp12, []any{v9, v10})
				tmp14 := lang.Apply(tmp11, []any{closed2, tmp13})
				return tmp14
			}
		})
		tmp1.AddMethod(tmp7, tmp8)
		tmp9 := reflect.TypeOf((*ast4.ChanType)(nil))
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v11 := args[0]
				_ = v11
				restArgs := args[1:]
				var v12 any
				if len(restArgs) > 0 {
					v12 = lang.NewList(restArgs...)
				}
				_ = v12
				tmp13 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp14 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp15 := lang.Apply(tmp14, []any{v11, v12})
				tmp16 := lang.Apply(tmp13, []any{closed3, tmp15})
				return tmp16
			}
		})
		tmp1.AddMethod(tmp9, tmp10)
		tmp11 := reflect.TypeOf((*ast4.FuncType)(nil))
		var tmp12 lang.FnFunc
		tmp12 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v13 := args[0]
				_ = v13
				restArgs := args[1:]
				var v14 any
				if len(restArgs) > 0 {
					v14 = lang.NewList(restArgs...)
				}
				_ = v14
				tmp15 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp16 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp17 := lang.Apply(tmp16, []any{v13, v14})
				tmp18 := lang.Apply(tmp15, []any{closed4, tmp17})
				return tmp18
			}
		})
		tmp1.AddMethod(tmp11, tmp12)
		tmp13 := reflect.TypeOf((*ast4.StructType)(nil))
		var tmp14 lang.FnFunc
		tmp14 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v15 := args[0]
				_ = v15
				restArgs := args[1:]
				var v16 any
				if len(restArgs) > 0 {
					v16 = lang.NewList(restArgs...)
				}
				_ = v16
				tmp17 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp18 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp19 := lang.Apply(tmp18, []any{v15, v16})
				tmp20 := lang.Apply(tmp17, []any{closed5, tmp19})
				return tmp20
			}
		})
		tmp1.AddMethod(tmp13, tmp14)
		var_glojure_DOT_go_DOT_types_ast_DASH__GT_type = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_types_ast_DASH__GT_type.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// from-string
	{
		tmp0 := sym_from_DASH_string.WithMeta(lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(92), kw_column, int(7), kw_end_DASH_line, int(92), kw_end_DASH_column, int(17), kw_arglists, lang.NewList(lang.NewVector(sym_typ)), kw_doc, "Returns a Go type from a go type expression.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_types))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_clojure_DOT_core_not)
			tmp5 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v2})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			if lang.IsTruthy(tmp7) {
				tmp8 := lang.Apply(fmt.Errorf, []any{"from-string: argument must be a string, got %T", v2})
				panic(tmp8)
			} else {
			}
			_ = tmp3
			var tmp9 any
			{ // let
				// let binding "vec__1135"
				tmp10 := lang.Apply(parser5.ParseExpr, []any{v2})
				var v11 any = tmp10
				_ = v11
				// let binding "ast"
				tmp12 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp13 := lang.Apply(tmp12, []any{v11, int64(0), nil})
				var v14 any = tmp13
				_ = v14
				// let binding "err"
				tmp15 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp16 := lang.Apply(tmp15, []any{v11, int64(1), nil})
				var v17 any = tmp16
				_ = v17
				var tmp18 any
				if lang.IsTruthy(v17) {
					tmp19 := lang.Apply(fmt.Errorf, []any{"from-string: invalid type string '%s': %w", v2, v17})
					panic(tmp19)
				} else {
				}
				_ = tmp18
				tmp20 := checkDerefVar(var_glojure_DOT_go_DOT_types_ast_DASH__GT_type)
				tmp21 := lang.Apply(tmp20, []any{v14})
				tmp9 = tmp21
			} // end let
			return tmp9
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_go_DOT_types_from_DASH_string = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_types_from_DASH_string.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// struct-field
	{
		tmp0 := sym_struct_DASH_field.WithMeta(lang.NewMap(kw_file, "glojure/go/types.glj", kw_line, int(6), kw_column, int(8), kw_end_DASH_line, int(6), kw_end_DASH_column, int(19), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_type_DASH_ast), lang.NewVector(sym_type_DASH_ast, sym_name)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_go_DOT_types))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_go_DOT_types_struct_DASH_field)
				tmp4 := lang.Apply(tmp3, []any{v2, nil})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "typ"
					tmp5 := checkDerefVar(var_glojure_DOT_go_DOT_types_ast_DASH__GT_type)
					tmp6 := lang.Apply(tmp5, []any{v2})
					var v7 any = tmp6
					_ = v7
					// let binding "name"
					var tmp8 any
					tmp9 := checkDerefVar(var_clojure_DOT_core__EQ_)
					tmp10 := lang.Apply(tmp9, []any{"", v3})
					if lang.IsTruthy(tmp10) {
					} else {
						tmp8 = v3
					}
					var v11 any = tmp8
					_ = v11
					// let binding "anonymous"
					tmp12 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
					tmp13 := lang.Apply(tmp12, []any{v11})
					var v14 any = tmp13
					_ = v14
					// let binding "name"
					var tmp15 any
					{ // let
						// let binding "or__0__auto__"
						var v16 any = v11
						_ = v16
						var tmp17 any
						if lang.IsTruthy(v16) {
							tmp17 = v16
						} else {
							tmp18, ok := lang.FieldOrMethod(v7, "Name")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "Name")))
							}
							var tmp19 any
							switch reflect.TypeOf(tmp18).Kind() {
							case reflect.Func:
								tmp19 = lang.Apply(tmp18, nil)
							default:
								tmp19 = tmp18
							}
							tmp17 = tmp19
						}
						tmp15 = tmp17
					} // end let
					var v16 any = tmp15
					_ = v16
					// let binding "sf"
					tmp17 := reflect.TypeOf((*reflect.StructField)(nil)).Elem()
					tmp18 := lang.Apply(lang.Builtins["new"], []any{tmp17})
					var v19 any = tmp18
					_ = v19
					// set! host field
					var tmp20 any
					{
						targetV := reflect.ValueOf(v19)
						if targetV.Kind() == reflect.Ptr {
							targetV = targetV.Elem()
						}
						fieldVal := targetV.FieldByName("Type")
						if !fieldVal.IsValid() {
							panic(fmt.Errorf("no such field Type"))
						}
						if !fieldVal.CanSet() {
							panic(fmt.Errorf("cannot set field Type"))
						}
						valV := reflect.ValueOf(v7)
						if !valV.IsValid() {
							switch fieldVal.Kind() {
							case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice, reflect.UnsafePointer:
								fieldVal.Set(reflect.Zero(fieldVal.Type()))
							default:
								panic(fmt.Errorf("cannot set field Type to nil"))
							}
						} else {
							fieldVal.Set(valV)
						}
						tmp20 = v7
					}
					_ = tmp20
					// set! host field
					var tmp21 any
					{
						targetV := reflect.ValueOf(v19)
						if targetV.Kind() == reflect.Ptr {
							targetV = targetV.Elem()
						}
						fieldVal := targetV.FieldByName("Name")
						if !fieldVal.IsValid() {
							panic(fmt.Errorf("no such field Name"))
						}
						if !fieldVal.CanSet() {
							panic(fmt.Errorf("cannot set field Name"))
						}
						valV := reflect.ValueOf(v16)
						if !valV.IsValid() {
							switch fieldVal.Kind() {
							case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice, reflect.UnsafePointer:
								fieldVal.Set(reflect.Zero(fieldVal.Type()))
							default:
								panic(fmt.Errorf("cannot set field Name to nil"))
							}
						} else {
							fieldVal.Set(valV)
						}
						tmp21 = v16
					}
					_ = tmp21
					var tmp22 any
					if lang.IsTruthy(v14) {
						// set! host field
						var tmp23 any
						{
							targetV := reflect.ValueOf(v19)
							if targetV.Kind() == reflect.Ptr {
								targetV = targetV.Elem()
							}
							fieldVal := targetV.FieldByName("Anonymous")
							if !fieldVal.IsValid() {
								panic(fmt.Errorf("no such field Anonymous"))
							}
							if !fieldVal.CanSet() {
								panic(fmt.Errorf("cannot set field Anonymous"))
							}
							valV := reflect.ValueOf(true)
							if !valV.IsValid() {
								switch fieldVal.Kind() {
								case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice, reflect.UnsafePointer:
									fieldVal.Set(reflect.Zero(fieldVal.Type()))
								default:
									panic(fmt.Errorf("cannot set field Anonymous to nil"))
								}
							} else {
								fieldVal.Set(valV)
							}
							tmp23 = true
						}
						tmp22 = tmp23
					} else {
					}
					_ = tmp22
					tmp24 := lang.Apply(lang.Builtins["deref"], []any{v19})
					tmp4 = tmp24
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_glojure_DOT_go_DOT_types_struct_DASH_field = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_glojure_DOT_go_DOT_types_struct_DASH_field.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}

// Code generated by glojure codegen. DO NOT EDIT.

package template

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	reflect "reflect"
)

func init() {
	runtime.RegisterNSLoader("clojure/template", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "clojure.template"
func LoadNS() {
	sym__AMP_ := lang.NewSymbol("&")
	sym_apply_DASH_template := lang.NewSymbol("apply-template")
	sym_argv := lang.NewSymbol("argv")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_template := lang.NewSymbol("clojure.template")
	sym_clojure_DOT_walk := lang.NewSymbol("clojure.walk")
	sym_concat := lang.NewSymbol("concat")
	sym_count := lang.NewSymbol("count")
	sym_do := lang.NewSymbol("do")
	sym_do_DASH_template := lang.NewSymbol("do-template")
	sym_expr := lang.NewSymbol("expr")
	sym_list := lang.NewSymbol("list")
	sym_map := lang.NewSymbol("map")
	sym_partition := lang.NewSymbol("partition")
	sym_postwalk_DASH_replace := lang.NewSymbol("postwalk-replace")
	sym_seq := lang.NewSymbol("seq")
	sym_values := lang.NewSymbol("values")
	sym_zipmap := lang.NewSymbol("zipmap")
	kw_arglists := lang.NewKeyword("arglists")
	kw_column := lang.NewKeyword("column")
	kw_doc := lang.NewKeyword("doc")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_macro := lang.NewKeyword("macro")
	kw_ns := lang.NewKeyword("ns")
	kw_rettag := lang.NewKeyword("rettag")
	// var clojure.core/concat
	var_clojure_DOT_core_concat := lang.InternVarName(sym_clojure_DOT_core, sym_concat)
	// var clojure.core/count
	var_clojure_DOT_core_count := lang.InternVarName(sym_clojure_DOT_core, sym_count)
	// var clojure.core/list
	var_clojure_DOT_core_list := lang.InternVarName(sym_clojure_DOT_core, sym_list)
	// var clojure.core/map
	var_clojure_DOT_core_map := lang.InternVarName(sym_clojure_DOT_core, sym_map)
	// var clojure.core/partition
	var_clojure_DOT_core_partition := lang.InternVarName(sym_clojure_DOT_core, sym_partition)
	// var clojure.core/seq
	var_clojure_DOT_core_seq := lang.InternVarName(sym_clojure_DOT_core, sym_seq)
	// var clojure.core/zipmap
	var_clojure_DOT_core_zipmap := lang.InternVarName(sym_clojure_DOT_core, sym_zipmap)
	// var clojure.template/apply-template
	var_clojure_DOT_template_apply_DASH_template := lang.InternVarName(sym_clojure_DOT_template, sym_apply_DASH_template)
	// var clojure.template/do-template
	var_clojure_DOT_template_do_DASH_template := lang.InternVarName(sym_clojure_DOT_template, sym_do_DASH_template)
	// var clojure.walk/postwalk-replace
	var_clojure_DOT_walk_postwalk_DASH_replace := lang.InternVarName(sym_clojure_DOT_walk, sym_postwalk_DASH_replace)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_clojure_DOT_template)
	_ = ns
	// apply-template
	{
		tmp0 := sym_apply_DASH_template.WithMeta(lang.NewMap(kw_file, "clojure/template.glj", kw_line, int(30), kw_column, int(7), kw_end_DASH_line, int(30), kw_end_DASH_column, int(20), kw_arglists, lang.NewList(lang.NewVector(sym_argv, sym_expr, sym_values)), kw_doc, "For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_template))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5 := checkDerefVar(var_clojure_DOT_walk_postwalk_DASH_replace)
			tmp6 := checkDerefVar(var_clojure_DOT_core_zipmap)
			tmp7 := lang.Apply(tmp6, []any{v2, v4})
			tmp8 := lang.Apply(tmp5, []any{tmp7, v3})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_template_apply_DASH_template = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_template_apply_DASH_template.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// do-template
	{
		tmp0 := sym_do_DASH_template.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_argv, sym_expr, sym__AMP_, sym_values)), kw_doc, "Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))", kw_file, "clojure/template.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_template), kw_end_DASH_column, int(21), kw_column, int(11), kw_line, int(45), kw_end_DASH_line, int(45))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 4)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				restArgs := args[4:]
				var v6 any
				if len(restArgs) > 0 {
					v6 = lang.NewList(restArgs...)
				}
				_ = v6
				var tmp7 any
				{ // let
					// let binding "c"
					tmp8 := checkDerefVar(var_clojure_DOT_core_count)
					tmp9 := lang.Apply(tmp8, []any{v4})
					var v10 any = tmp9
					_ = v10
					tmp11 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp12 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp13 := checkDerefVar(var_clojure_DOT_core_list)
					tmp14 := lang.Apply(tmp13, []any{sym_do})
					tmp15 := checkDerefVar(var_clojure_DOT_core_map)
					var tmp16 lang.FnFunc
					tmp16 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v17 := args[0]
						_ = v17
						tmp18 := checkDerefVar(var_clojure_DOT_template_apply_DASH_template)
						tmp19 := lang.Apply(tmp18, []any{v4, v5, v17})
						return tmp19
					})
					tmp17 := lang.NewMap(kw_file, "clojure/template.glj", kw_line, int(54), kw_column, int(17), kw_end_DASH_line, int(54), kw_end_DASH_column, int(53))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp19 := checkDerefVar(var_clojure_DOT_core_partition)
					tmp20 := lang.Apply(tmp19, []any{v10, v6})
					tmp21 := lang.Apply(tmp15, []any{tmp18, tmp20})
					tmp22 := lang.Apply(tmp12, []any{tmp14, tmp21})
					tmp23 := lang.Apply(tmp11, []any{tmp22})
					tmp7 = tmp23
				} // end let
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_template_do_DASH_template = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_template_do_DASH_template.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}

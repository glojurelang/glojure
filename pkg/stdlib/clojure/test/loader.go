// Code generated by glojure codegen. DO NOT EDIT.

package test

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	reflect "reflect"
)

func init() {
	runtime.RegisterNSLoader("clojure/test", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "clojure.test"
func LoadNS() {
	// Check if already AOT-loaded
	if ns := lang.FindNamespace(lang.NewSymbol("clojure.test")); ns != nil {
		if meta := ns.Meta(); meta != nil {
			if aotLoaded := meta.ValAt(lang.NewKeyword("aot-loaded")); aotLoaded != nil {
				return // Already loaded, skip reinitialization
			}
		}
	}
	sym__AMP_ := lang.NewSymbol("&")
	sym__STAR_err_STAR_ := lang.NewSymbol("*err*")
	sym__STAR_initial_DASH_report_DASH_counters_STAR_ := lang.NewSymbol("*initial-report-counters*")
	sym__STAR_load_DASH_tests_STAR_ := lang.NewSymbol("*load-tests*")
	sym__STAR_ns_STAR_ := lang.NewSymbol("*ns*")
	sym__STAR_out_STAR_ := lang.NewSymbol("*out*")
	sym__STAR_report_DASH_counters_STAR_ := lang.NewSymbol("*report-counters*")
	sym__STAR_stack_DASH_trace_DASH_depth_STAR_ := lang.NewSymbol("*stack-trace-depth*")
	sym__STAR_test_DASH_out_STAR_ := lang.NewSymbol("*test-out*")
	sym__STAR_testing_DASH_contexts_STAR_ := lang.NewSymbol("*testing-contexts*")
	sym__STAR_testing_DASH_vars_STAR_ := lang.NewSymbol("*testing-vars*")
	sym__PLUS_ := lang.NewSymbol("+")
	sym__DOT_getMessage := lang.NewSymbol(".getMessage")
	sym__LT_ := lang.NewSymbol("<")
	sym_add_DASH_ns_DASH_meta := lang.NewSymbol("add-ns-meta")
	sym_all_DASH_ns := lang.NewSymbol("all-ns")
	sym_alter_DASH_meta_BANG_ := lang.NewSymbol("alter-meta!")
	sym_apply := lang.NewSymbol("apply")
	sym_are := lang.NewSymbol("are")
	sym_args := lang.NewSymbol("args")
	sym_argv := lang.NewSymbol("argv")
	sym_assert_DASH_any := lang.NewSymbol("assert-any")
	sym_assert_DASH_expr := lang.NewSymbol("assert-expr")
	sym_assert_DASH_predicate := lang.NewSymbol("assert-predicate")
	sym_assoc := lang.NewSymbol("assoc")
	sym_body := lang.NewSymbol("body")
	sym_catch := lang.NewSymbol("catch")
	sym_chunk_DASH_first := lang.NewSymbol("chunk-first")
	sym_chunk_DASH_rest := lang.NewSymbol("chunk-rest")
	sym_chunked_DASH_seq_QMARK_ := lang.NewSymbol("chunked-seq?")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_core_SLASH__STAR_out_STAR_ := lang.NewSymbol("clojure.core/*out*")
	sym_clojure_DOT_core_SLASH_alter_DASH_meta_BANG_ := lang.NewSymbol("clojure.core/alter-meta!")
	sym_clojure_DOT_core_SLASH_apply := lang.NewSymbol("clojure.core/apply")
	sym_clojure_DOT_core_SLASH_assoc := lang.NewSymbol("clojure.core/assoc")
	sym_clojure_DOT_core_SLASH_binding := lang.NewSymbol("clojure.core/binding")
	sym_clojure_DOT_core_SLASH_class := lang.NewSymbol("clojure.core/class")
	sym_clojure_DOT_core_SLASH_conj := lang.NewSymbol("clojure.core/conj")
	sym_clojure_DOT_core_SLASH_cons := lang.NewSymbol("clojure.core/cons")
	sym_clojure_DOT_core_SLASH_doto := lang.NewSymbol("clojure.core/doto")
	sym_clojure_DOT_core_SLASH_fn := lang.NewSymbol("clojure.core/fn")
	sym_clojure_DOT_core_SLASH_instance_QMARK_ := lang.NewSymbol("clojure.core/instance?")
	sym_clojure_DOT_core_SLASH_let := lang.NewSymbol("clojure.core/let")
	sym_clojure_DOT_core_SLASH_list := lang.NewSymbol("clojure.core/list")
	sym_clojure_DOT_core_SLASH_or := lang.NewSymbol("clojure.core/or")
	sym_clojure_DOT_core_SLASH_re_DASH_find := lang.NewSymbol("clojure.core/re-find")
	sym_clojure_DOT_template_SLASH_do_DASH_template := lang.NewSymbol("clojure.template/do-template")
	sym_clojure_DOT_test := lang.NewSymbol("clojure.test")
	sym_clojure_DOT_test_SLASH__STAR_test_DASH_out_STAR_ := lang.NewSymbol("clojure.test/*test-out*")
	sym_clojure_DOT_test_SLASH__STAR_testing_DASH_contexts_STAR_ := lang.NewSymbol("clojure.test/*testing-contexts*")
	sym_clojure_DOT_test_SLASH_do_DASH_report := lang.NewSymbol("clojure.test/do-report")
	sym_clojure_DOT_test_SLASH_is := lang.NewSymbol("clojure.test/is")
	sym_clojure_DOT_test_SLASH_run_DASH_test_DASH_var := lang.NewSymbol("clojure.test/run-test-var")
	sym_clojure_DOT_test_SLASH_test_DASH_var := lang.NewSymbol("clojure.test/test-var")
	sym_clojure_DOT_test_SLASH_try_DASH_expr := lang.NewSymbol("clojure.test/try-expr")
	sym_coll := lang.NewSymbol("coll")
	sym_commute := lang.NewSymbol("commute")
	sym_comp := lang.NewSymbol("comp")
	sym_compose_DASH_fixtures := lang.NewSymbol("compose-fixtures")
	sym_concat := lang.NewSymbol("concat")
	sym_conj := lang.NewSymbol("conj")
	sym_count := lang.NewSymbol("count")
	sym_def := lang.NewSymbol("def")
	sym_default_DASH_fixture := lang.NewSymbol("default-fixture")
	sym_definition := lang.NewSymbol("definition")
	sym_deftest := lang.NewSymbol("deftest")
	sym_deftest_DASH_ := lang.NewSymbol("deftest-")
	sym_depth := lang.NewSymbol("depth")
	sym_deref := lang.NewSymbol("deref")
	sym_do_DASH_report := lang.NewSymbol("do-report")
	sym_e__0__auto__ := lang.NewSymbol("e__0__auto__")
	sym_empty_QMARK_ := lang.NewSymbol("empty?")
	sym_exception := lang.NewSymbol("exception")
	sym_expr := lang.NewSymbol("expr")
	sym_f := lang.NewSymbol("f")
	sym_f1 := lang.NewSymbol("f1")
	sym_f2 := lang.NewSymbol("f2")
	sym_file_DASH_and_DASH_line := lang.NewSymbol("file-and-line")
	sym_file_DASH_position := lang.NewSymbol("file-position")
	sym_filter := lang.NewSymbol("filter")
	sym_find_DASH_var := lang.NewSymbol("find-var")
	sym_first := lang.NewSymbol("first")
	sym_fixtures := lang.NewSymbol("fixtures")
	sym_fn_QMARK_ := lang.NewSymbol("fn?")
	sym_fnil := lang.NewSymbol("fnil")
	sym_form := lang.NewSymbol("form")
	sym_function_QMARK_ := lang.NewSymbol("function?")
	sym_get := lang.NewSymbol("get")
	sym_get_DASH_possibly_DASH_unbound_DASH_var := lang.NewSymbol("get-possibly-unbound-var")
	sym_global_DASH_hierarchy := lang.NewSymbol("global-hierarchy")
	sym_go_SLASH_any := lang.NewSymbol("go/any")
	sym_group_DASH_by := lang.NewSymbol("group-by")
	sym_hash_DASH_map := lang.NewSymbol("hash-map")
	sym_if := lang.NewSymbol("if")
	sym_inc := lang.NewSymbol("inc")
	sym_inc_DASH_report_DASH_counter := lang.NewSymbol("inc-report-counter")
	sym_instance_QMARK_ := lang.NewSymbol("instance?")
	sym_int := lang.NewSymbol("int")
	sym_interpose := lang.NewSymbol("interpose")
	sym_is := lang.NewSymbol("is")
	sym_join_DASH_fixtures := lang.NewSymbol("join-fixtures")
	sym_key := lang.NewSymbol("key")
	sym_klass__0__auto__ := lang.NewSymbol("klass__0__auto__")
	sym_list := lang.NewSymbol("list")
	sym_m := lang.NewSymbol("m")
	sym_m__1__auto__ := lang.NewSymbol("m__1__auto__")
	sym_map := lang.NewSymbol("map")
	sym_merge := lang.NewSymbol("merge")
	sym_merge_DASH_with := lang.NewSymbol("merge-with")
	sym_meta := lang.NewSymbol("meta")
	sym_mod := lang.NewSymbol("mod")
	sym_msg := lang.NewSymbol("msg")
	sym_n := lang.NewSymbol("n")
	sym_name := lang.NewSymbol("name")
	sym_namespaces := lang.NewSymbol("namespaces")
	sym_next := lang.NewSymbol("next")
	sym_nil_QMARK_ := lang.NewSymbol("nil?")
	sym_not := lang.NewSymbol("not")
	sym_ns := lang.NewSymbol("ns")
	sym_ns_DASH_interns := lang.NewSymbol("ns-interns")
	sym_ns_DASH_name := lang.NewSymbol("ns-name")
	sym_nth := lang.NewSymbol("nth")
	sym_nthnext := lang.NewSymbol("nthnext")
	sym_object__1__auto__ := lang.NewSymbol("object__1__auto__")
	sym_pop_DASH_thread_DASH_bindings := lang.NewSymbol("pop-thread-bindings")
	sym_pos_QMARK_ := lang.NewSymbol("pos?")
	sym_pr_DASH_str := lang.NewSymbol("pr-str")
	sym_print := lang.NewSymbol("print")
	sym_println := lang.NewSymbol("println")
	sym_prn := lang.NewSymbol("prn")
	sym_push_DASH_thread_DASH_bindings := lang.NewSymbol("push-thread-bindings")
	sym_quote := lang.NewSymbol("quote")
	sym_re := lang.NewSymbol("re")
	sym_re_DASH_matches := lang.NewSymbol("re-matches")
	sym_reduce := lang.NewSymbol("reduce")
	sym_ref := lang.NewSymbol("ref")
	sym_report := lang.NewSymbol("report")
	sym_resolve := lang.NewSymbol("resolve")
	sym_rest := lang.NewSymbol("rest")
	sym_result__1__auto__ := lang.NewSymbol("result__1__auto__")
	sym_result__2__auto__ := lang.NewSymbol("result__2__auto__")
	sym_reverse := lang.NewSymbol("reverse")
	sym_run_DASH_all_DASH_tests := lang.NewSymbol("run-all-tests")
	sym_run_DASH_test := lang.NewSymbol("run-test")
	sym_run_DASH_test_DASH_var := lang.NewSymbol("run-test-var")
	sym_run_DASH_tests := lang.NewSymbol("run-tests")
	sym_second := lang.NewSymbol("second")
	sym_seq := lang.NewSymbol("seq")
	sym_seq_QMARK_ := lang.NewSymbol("seq?")
	sym_sequential_QMARK_ := lang.NewSymbol("sequential?")
	sym_set_DASH_test := lang.NewSymbol("set-test")
	sym_stacktrace := lang.NewSymbol("stacktrace")
	sym_stacktrace_DASH_file_DASH_and_DASH_line := lang.NewSymbol("stacktrace-file-and-line")
	sym_str := lang.NewSymbol("str")
	sym_string := lang.NewSymbol("string")
	sym_successful_QMARK_ := lang.NewSymbol("successful?")
	sym_summary := lang.NewSymbol("summary")
	sym_symbol := lang.NewSymbol("symbol")
	sym_symbol_QMARK_ := lang.NewSymbol("symbol?")
	sym_t__0__auto__ := lang.NewSymbol("t__0__auto__")
	sym_test_DASH_all_DASH_vars := lang.NewSymbol("test-all-vars")
	sym_test_DASH_ns := lang.NewSymbol("test-ns")
	sym_test_DASH_symbol := lang.NewSymbol("test-symbol")
	sym_test_DASH_var := lang.NewSymbol("test-var")
	sym_test_DASH_vars := lang.NewSymbol("test-vars")
	sym_testing := lang.NewSymbol("testing")
	sym_testing_DASH_contexts_DASH_str := lang.NewSymbol("testing-contexts-str")
	sym_testing_DASH_vars_DASH_str := lang.NewSymbol("testing-vars-str")
	sym_the_DASH_ns := lang.NewSymbol("the-ns")
	sym_thrown_DASH_with_DASH_msg_QMARK_ := lang.NewSymbol("thrown-with-msg?")
	sym_thrown_QMARK_ := lang.NewSymbol("thrown?")
	sym_to_DASH_array := lang.NewSymbol("to-array")
	sym_try := lang.NewSymbol("try")
	sym_try_DASH_expr := lang.NewSymbol("try-expr")
	sym_unchecked_DASH_inc := lang.NewSymbol("unchecked-inc")
	sym_update_DASH_in := lang.NewSymbol("update-in")
	sym_use_DASH_fixtures := lang.NewSymbol("use-fixtures")
	sym_v := lang.NewSymbol("v")
	sym_vals := lang.NewSymbol("vals")
	sym_value__0__auto__ := lang.NewSymbol("value__0__auto__")
	sym_values__0__auto__ := lang.NewSymbol("values__0__auto__")
	sym_var := lang.NewSymbol("var")
	sym_var_DASH_get := lang.NewSymbol("var-get")
	sym_vars := lang.NewSymbol("vars")
	sym_vary_DASH_meta := lang.NewSymbol("vary-meta")
	sym_vector := lang.NewSymbol("vector")
	sym_with_DASH_test := lang.NewSymbol("with-test")
	sym_with_DASH_test_DASH_out := lang.NewSymbol("with-test-out")
	sym_x := lang.NewSymbol("x")
	sym_zero_QMARK_ := lang.NewSymbol("zero?")
	kw_actual := lang.NewKeyword("actual")
	kw_added := lang.NewKeyword("added")
	kw_always_DASH_fail := lang.NewKeyword("always-fail")
	kw_arglists := lang.NewKeyword("arglists")
	kw_begin_DASH_test_DASH_ns := lang.NewKeyword("begin-test-ns")
	kw_begin_DASH_test_DASH_var := lang.NewKeyword("begin-test-var")
	kw_clojure_DOT_test_SLASH_each_DASH_fixtures := lang.NewKeyword("clojure.test/each-fixtures")
	kw_clojure_DOT_test_SLASH_once_DASH_fixtures := lang.NewKeyword("clojure.test/once-fixtures")
	kw_column := lang.NewKeyword("column")
	kw_default := lang.NewKeyword("default")
	kw_deprecated := lang.NewKeyword("deprecated")
	kw_doc := lang.NewKeyword("doc")
	kw_dynamic := lang.NewKeyword("dynamic")
	kw_each := lang.NewKeyword("each")
	kw_else := lang.NewKeyword("else")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_end_DASH_test_DASH_ns := lang.NewKeyword("end-test-ns")
	kw_end_DASH_test_DASH_var := lang.NewKeyword("end-test-var")
	kw_error := lang.NewKeyword("error")
	kw_expected := lang.NewKeyword("expected")
	kw_fail := lang.NewKeyword("fail")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_macro := lang.NewKeyword("macro")
	kw_message := lang.NewKeyword("message")
	kw_name := lang.NewKeyword("name")
	kw_ns := lang.NewKeyword("ns")
	kw_once := lang.NewKeyword("once")
	kw_pass := lang.NewKeyword("pass")
	kw_private := lang.NewKeyword("private")
	kw_rettag := lang.NewKeyword("rettag")
	kw_summary := lang.NewKeyword("summary")
	kw_test := lang.NewKeyword("test")
	kw_type := lang.NewKeyword("type")
	kw_var := lang.NewKeyword("var")
	// var clojure.core/<
	var_clojure_DOT_core__LT_ := lang.InternVarName(sym_clojure_DOT_core, sym__LT_)
	// var clojure.core/+
	var_clojure_DOT_core__PLUS_ := lang.InternVarName(sym_clojure_DOT_core, sym__PLUS_)
	// var clojure.core/*err*
	var_clojure_DOT_core__STAR_err_STAR_ := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_err_STAR_)
	// var clojure.core/*ns*
	var_clojure_DOT_core__STAR_ns_STAR_ := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_ns_STAR_)
	// var clojure.core/*out*
	var_clojure_DOT_core__STAR_out_STAR_ := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_out_STAR_)
	// var clojure.core/all-ns
	var_clojure_DOT_core_all_DASH_ns := lang.InternVarName(sym_clojure_DOT_core, sym_all_DASH_ns)
	// var clojure.core/alter-meta!
	var_clojure_DOT_core_alter_DASH_meta_BANG_ := lang.InternVarName(sym_clojure_DOT_core, sym_alter_DASH_meta_BANG_)
	// var clojure.core/apply
	var_clojure_DOT_core_apply := lang.InternVarName(sym_clojure_DOT_core, sym_apply)
	// var clojure.core/assoc
	var_clojure_DOT_core_assoc := lang.InternVarName(sym_clojure_DOT_core, sym_assoc)
	// var clojure.core/chunk-first
	var_clojure_DOT_core_chunk_DASH_first := lang.InternVarName(sym_clojure_DOT_core, sym_chunk_DASH_first)
	// var clojure.core/chunk-rest
	var_clojure_DOT_core_chunk_DASH_rest := lang.InternVarName(sym_clojure_DOT_core, sym_chunk_DASH_rest)
	// var clojure.core/chunked-seq?
	var_clojure_DOT_core_chunked_DASH_seq_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_chunked_DASH_seq_QMARK_)
	// var clojure.core/commute
	var_clojure_DOT_core_commute := lang.InternVarName(sym_clojure_DOT_core, sym_commute)
	// var clojure.core/comp
	var_clojure_DOT_core_comp := lang.InternVarName(sym_clojure_DOT_core, sym_comp)
	// var clojure.core/concat
	var_clojure_DOT_core_concat := lang.InternVarName(sym_clojure_DOT_core, sym_concat)
	// var clojure.core/conj
	var_clojure_DOT_core_conj := lang.InternVarName(sym_clojure_DOT_core, sym_conj)
	// var clojure.core/count
	var_clojure_DOT_core_count := lang.InternVarName(sym_clojure_DOT_core, sym_count)
	// var clojure.core/deref
	var_clojure_DOT_core_deref := lang.InternVarName(sym_clojure_DOT_core, sym_deref)
	// var clojure.core/empty?
	var_clojure_DOT_core_empty_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_empty_QMARK_)
	// var clojure.core/filter
	var_clojure_DOT_core_filter := lang.InternVarName(sym_clojure_DOT_core, sym_filter)
	// var clojure.core/find-var
	var_clojure_DOT_core_find_DASH_var := lang.InternVarName(sym_clojure_DOT_core, sym_find_DASH_var)
	// var clojure.core/first
	var_clojure_DOT_core_first := lang.InternVarName(sym_clojure_DOT_core, sym_first)
	// var clojure.core/fn?
	var_clojure_DOT_core_fn_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_fn_QMARK_)
	// var clojure.core/fnil
	var_clojure_DOT_core_fnil := lang.InternVarName(sym_clojure_DOT_core, sym_fnil)
	// var clojure.core/get
	var_clojure_DOT_core_get := lang.InternVarName(sym_clojure_DOT_core, sym_get)
	// var clojure.core/group-by
	var_clojure_DOT_core_group_DASH_by := lang.InternVarName(sym_clojure_DOT_core, sym_group_DASH_by)
	// var clojure.core/hash-map
	var_clojure_DOT_core_hash_DASH_map := lang.InternVarName(sym_clojure_DOT_core, sym_hash_DASH_map)
	// var clojure.core/inc
	var_clojure_DOT_core_inc := lang.InternVarName(sym_clojure_DOT_core, sym_inc)
	// var clojure.core/instance?
	var_clojure_DOT_core_instance_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_instance_QMARK_)
	// var clojure.core/int
	var_clojure_DOT_core_int := lang.InternVarName(sym_clojure_DOT_core, sym_int)
	// var clojure.core/interpose
	var_clojure_DOT_core_interpose := lang.InternVarName(sym_clojure_DOT_core, sym_interpose)
	// var clojure.core/list
	var_clojure_DOT_core_list := lang.InternVarName(sym_clojure_DOT_core, sym_list)
	// var clojure.core/map
	var_clojure_DOT_core_map := lang.InternVarName(sym_clojure_DOT_core, sym_map)
	// var clojure.core/merge
	var_clojure_DOT_core_merge := lang.InternVarName(sym_clojure_DOT_core, sym_merge)
	// var clojure.core/merge-with
	var_clojure_DOT_core_merge_DASH_with := lang.InternVarName(sym_clojure_DOT_core, sym_merge_DASH_with)
	// var clojure.core/meta
	var_clojure_DOT_core_meta := lang.InternVarName(sym_clojure_DOT_core, sym_meta)
	// var clojure.core/mod
	var_clojure_DOT_core_mod := lang.InternVarName(sym_clojure_DOT_core, sym_mod)
	// var clojure.core/name
	var_clojure_DOT_core_name := lang.InternVarName(sym_clojure_DOT_core, sym_name)
	// var clojure.core/next
	var_clojure_DOT_core_next := lang.InternVarName(sym_clojure_DOT_core, sym_next)
	// var clojure.core/nil?
	var_clojure_DOT_core_nil_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_nil_QMARK_)
	// var clojure.core/not
	var_clojure_DOT_core_not := lang.InternVarName(sym_clojure_DOT_core, sym_not)
	// var clojure.core/ns-interns
	var_clojure_DOT_core_ns_DASH_interns := lang.InternVarName(sym_clojure_DOT_core, sym_ns_DASH_interns)
	// var clojure.core/ns-name
	var_clojure_DOT_core_ns_DASH_name := lang.InternVarName(sym_clojure_DOT_core, sym_ns_DASH_name)
	// var clojure.core/nth
	var_clojure_DOT_core_nth := lang.InternVarName(sym_clojure_DOT_core, sym_nth)
	// var clojure.core/nthnext
	var_clojure_DOT_core_nthnext := lang.InternVarName(sym_clojure_DOT_core, sym_nthnext)
	// var clojure.core/pop-thread-bindings
	var_clojure_DOT_core_pop_DASH_thread_DASH_bindings := lang.InternVarName(sym_clojure_DOT_core, sym_pop_DASH_thread_DASH_bindings)
	// var clojure.core/pos?
	var_clojure_DOT_core_pos_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_pos_QMARK_)
	// var clojure.core/pr-str
	var_clojure_DOT_core_pr_DASH_str := lang.InternVarName(sym_clojure_DOT_core, sym_pr_DASH_str)
	// var clojure.core/print
	var_clojure_DOT_core_print := lang.InternVarName(sym_clojure_DOT_core, sym_print)
	// var clojure.core/println
	var_clojure_DOT_core_println := lang.InternVarName(sym_clojure_DOT_core, sym_println)
	// var clojure.core/prn
	var_clojure_DOT_core_prn := lang.InternVarName(sym_clojure_DOT_core, sym_prn)
	// var clojure.core/push-thread-bindings
	var_clojure_DOT_core_push_DASH_thread_DASH_bindings := lang.InternVarName(sym_clojure_DOT_core, sym_push_DASH_thread_DASH_bindings)
	// var clojure.core/re-matches
	var_clojure_DOT_core_re_DASH_matches := lang.InternVarName(sym_clojure_DOT_core, sym_re_DASH_matches)
	// var clojure.core/reduce
	var_clojure_DOT_core_reduce := lang.InternVarName(sym_clojure_DOT_core, sym_reduce)
	// var clojure.core/ref
	var_clojure_DOT_core_ref := lang.InternVarName(sym_clojure_DOT_core, sym_ref)
	// var clojure.core/resolve
	var_clojure_DOT_core_resolve := lang.InternVarName(sym_clojure_DOT_core, sym_resolve)
	// var clojure.core/rest
	var_clojure_DOT_core_rest := lang.InternVarName(sym_clojure_DOT_core, sym_rest)
	// var clojure.core/reverse
	var_clojure_DOT_core_reverse := lang.InternVarName(sym_clojure_DOT_core, sym_reverse)
	// var clojure.core/second
	var_clojure_DOT_core_second := lang.InternVarName(sym_clojure_DOT_core, sym_second)
	// var clojure.core/seq
	var_clojure_DOT_core_seq := lang.InternVarName(sym_clojure_DOT_core, sym_seq)
	// var clojure.core/seq?
	var_clojure_DOT_core_seq_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_seq_QMARK_)
	// var clojure.core/sequential?
	var_clojure_DOT_core_sequential_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_sequential_QMARK_)
	// var clojure.core/str
	var_clojure_DOT_core_str := lang.InternVarName(sym_clojure_DOT_core, sym_str)
	// var clojure.core/symbol
	var_clojure_DOT_core_symbol := lang.InternVarName(sym_clojure_DOT_core, sym_symbol)
	// var clojure.core/symbol?
	var_clojure_DOT_core_symbol_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_symbol_QMARK_)
	// var clojure.core/the-ns
	var_clojure_DOT_core_the_DASH_ns := lang.InternVarName(sym_clojure_DOT_core, sym_the_DASH_ns)
	// var clojure.core/to-array
	var_clojure_DOT_core_to_DASH_array := lang.InternVarName(sym_clojure_DOT_core, sym_to_DASH_array)
	// var clojure.core/unchecked-inc
	var_clojure_DOT_core_unchecked_DASH_inc := lang.InternVarName(sym_clojure_DOT_core, sym_unchecked_DASH_inc)
	// var clojure.core/update-in
	var_clojure_DOT_core_update_DASH_in := lang.InternVarName(sym_clojure_DOT_core, sym_update_DASH_in)
	// var clojure.core/vals
	var_clojure_DOT_core_vals := lang.InternVarName(sym_clojure_DOT_core, sym_vals)
	// var clojure.core/var-get
	var_clojure_DOT_core_var_DASH_get := lang.InternVarName(sym_clojure_DOT_core, sym_var_DASH_get)
	// var clojure.core/vary-meta
	var_clojure_DOT_core_vary_DASH_meta := lang.InternVarName(sym_clojure_DOT_core, sym_vary_DASH_meta)
	// var clojure.core/vector
	var_clojure_DOT_core_vector := lang.InternVarName(sym_clojure_DOT_core, sym_vector)
	// var clojure.core/zero?
	var_clojure_DOT_core_zero_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_zero_QMARK_)
	// var clojure.test/*initial-report-counters*
	var_clojure_DOT_test__STAR_initial_DASH_report_DASH_counters_STAR_ := lang.InternVarName(sym_clojure_DOT_test, sym__STAR_initial_DASH_report_DASH_counters_STAR_)
	// var clojure.test/*load-tests*
	var_clojure_DOT_test__STAR_load_DASH_tests_STAR_ := lang.InternVarName(sym_clojure_DOT_test, sym__STAR_load_DASH_tests_STAR_)
	// var clojure.test/*report-counters*
	var_clojure_DOT_test__STAR_report_DASH_counters_STAR_ := lang.InternVarName(sym_clojure_DOT_test, sym__STAR_report_DASH_counters_STAR_)
	// var clojure.test/*stack-trace-depth*
	var_clojure_DOT_test__STAR_stack_DASH_trace_DASH_depth_STAR_ := lang.InternVarName(sym_clojure_DOT_test, sym__STAR_stack_DASH_trace_DASH_depth_STAR_)
	// var clojure.test/*test-out*
	var_clojure_DOT_test__STAR_test_DASH_out_STAR_ := lang.InternVarName(sym_clojure_DOT_test, sym__STAR_test_DASH_out_STAR_)
	// var clojure.test/*testing-contexts*
	var_clojure_DOT_test__STAR_testing_DASH_contexts_STAR_ := lang.InternVarName(sym_clojure_DOT_test, sym__STAR_testing_DASH_contexts_STAR_)
	// var clojure.test/*testing-vars*
	var_clojure_DOT_test__STAR_testing_DASH_vars_STAR_ := lang.InternVarName(sym_clojure_DOT_test, sym__STAR_testing_DASH_vars_STAR_)
	// var clojure.test/add-ns-meta
	var_clojure_DOT_test_add_DASH_ns_DASH_meta := lang.InternVarName(sym_clojure_DOT_test, sym_add_DASH_ns_DASH_meta)
	// var clojure.test/are
	var_clojure_DOT_test_are := lang.InternVarName(sym_clojure_DOT_test, sym_are)
	// var clojure.test/assert-any
	var_clojure_DOT_test_assert_DASH_any := lang.InternVarName(sym_clojure_DOT_test, sym_assert_DASH_any)
	// var clojure.test/assert-expr
	var_clojure_DOT_test_assert_DASH_expr := lang.InternVarName(sym_clojure_DOT_test, sym_assert_DASH_expr)
	// var clojure.test/assert-predicate
	var_clojure_DOT_test_assert_DASH_predicate := lang.InternVarName(sym_clojure_DOT_test, sym_assert_DASH_predicate)
	// var clojure.test/compose-fixtures
	var_clojure_DOT_test_compose_DASH_fixtures := lang.InternVarName(sym_clojure_DOT_test, sym_compose_DASH_fixtures)
	// var clojure.test/default-fixture
	var_clojure_DOT_test_default_DASH_fixture := lang.InternVarName(sym_clojure_DOT_test, sym_default_DASH_fixture)
	// var clojure.test/deftest
	var_clojure_DOT_test_deftest := lang.InternVarName(sym_clojure_DOT_test, sym_deftest)
	// var clojure.test/deftest-
	var_clojure_DOT_test_deftest_DASH_ := lang.InternVarName(sym_clojure_DOT_test, sym_deftest_DASH_)
	// var clojure.test/do-report
	var_clojure_DOT_test_do_DASH_report := lang.InternVarName(sym_clojure_DOT_test, sym_do_DASH_report)
	// var clojure.test/file-and-line
	var_clojure_DOT_test_file_DASH_and_DASH_line := lang.InternVarName(sym_clojure_DOT_test, sym_file_DASH_and_DASH_line)
	// var clojure.test/file-position
	var_clojure_DOT_test_file_DASH_position := lang.InternVarName(sym_clojure_DOT_test, sym_file_DASH_position)
	// var clojure.test/function?
	var_clojure_DOT_test_function_QMARK_ := lang.InternVarName(sym_clojure_DOT_test, sym_function_QMARK_)
	// var clojure.test/get-possibly-unbound-var
	var_clojure_DOT_test_get_DASH_possibly_DASH_unbound_DASH_var := lang.InternVarName(sym_clojure_DOT_test, sym_get_DASH_possibly_DASH_unbound_DASH_var)
	// var clojure.test/inc-report-counter
	var_clojure_DOT_test_inc_DASH_report_DASH_counter := lang.InternVarName(sym_clojure_DOT_test, sym_inc_DASH_report_DASH_counter)
	// var clojure.test/is
	var_clojure_DOT_test_is := lang.InternVarName(sym_clojure_DOT_test, sym_is)
	// var clojure.test/join-fixtures
	var_clojure_DOT_test_join_DASH_fixtures := lang.InternVarName(sym_clojure_DOT_test, sym_join_DASH_fixtures)
	// var clojure.test/report
	var_clojure_DOT_test_report := lang.InternVarName(sym_clojure_DOT_test, sym_report)
	// var clojure.test/run-all-tests
	var_clojure_DOT_test_run_DASH_all_DASH_tests := lang.InternVarName(sym_clojure_DOT_test, sym_run_DASH_all_DASH_tests)
	// var clojure.test/run-test
	var_clojure_DOT_test_run_DASH_test := lang.InternVarName(sym_clojure_DOT_test, sym_run_DASH_test)
	// var clojure.test/run-test-var
	var_clojure_DOT_test_run_DASH_test_DASH_var := lang.InternVarName(sym_clojure_DOT_test, sym_run_DASH_test_DASH_var)
	// var clojure.test/run-tests
	var_clojure_DOT_test_run_DASH_tests := lang.InternVarName(sym_clojure_DOT_test, sym_run_DASH_tests)
	// var clojure.test/set-test
	var_clojure_DOT_test_set_DASH_test := lang.InternVarName(sym_clojure_DOT_test, sym_set_DASH_test)
	// var clojure.test/stacktrace-file-and-line
	var_clojure_DOT_test_stacktrace_DASH_file_DASH_and_DASH_line := lang.InternVarName(sym_clojure_DOT_test, sym_stacktrace_DASH_file_DASH_and_DASH_line)
	// var clojure.test/successful?
	var_clojure_DOT_test_successful_QMARK_ := lang.InternVarName(sym_clojure_DOT_test, sym_successful_QMARK_)
	// var clojure.test/test-all-vars
	var_clojure_DOT_test_test_DASH_all_DASH_vars := lang.InternVarName(sym_clojure_DOT_test, sym_test_DASH_all_DASH_vars)
	// var clojure.test/test-ns
	var_clojure_DOT_test_test_DASH_ns := lang.InternVarName(sym_clojure_DOT_test, sym_test_DASH_ns)
	// var clojure.test/test-var
	var_clojure_DOT_test_test_DASH_var := lang.InternVarName(sym_clojure_DOT_test, sym_test_DASH_var)
	// var clojure.test/test-vars
	var_clojure_DOT_test_test_DASH_vars := lang.InternVarName(sym_clojure_DOT_test, sym_test_DASH_vars)
	// var clojure.test/testing
	var_clojure_DOT_test_testing := lang.InternVarName(sym_clojure_DOT_test, sym_testing)
	// var clojure.test/testing-contexts-str
	var_clojure_DOT_test_testing_DASH_contexts_DASH_str := lang.InternVarName(sym_clojure_DOT_test, sym_testing_DASH_contexts_DASH_str)
	// var clojure.test/testing-vars-str
	var_clojure_DOT_test_testing_DASH_vars_DASH_str := lang.InternVarName(sym_clojure_DOT_test, sym_testing_DASH_vars_DASH_str)
	// var clojure.test/try-expr
	var_clojure_DOT_test_try_DASH_expr := lang.InternVarName(sym_clojure_DOT_test, sym_try_DASH_expr)
	// var clojure.test/use-fixtures
	var_clojure_DOT_test_use_DASH_fixtures := lang.InternVarName(sym_clojure_DOT_test, sym_use_DASH_fixtures)
	// var clojure.test/with-test
	var_clojure_DOT_test_with_DASH_test := lang.InternVarName(sym_clojure_DOT_test, sym_with_DASH_test)
	// var clojure.test/with-test-out
	var_clojure_DOT_test_with_DASH_test_DASH_out := lang.InternVarName(sym_clojure_DOT_test, sym_with_DASH_test_DASH_out)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_clojure_DOT_test)
	_ = ns
	// *initial-report-counters*
	{
		tmp0 := sym__STAR_initial_DASH_report_DASH_counters_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "clojure/test.glj", kw_line, int(263), kw_column, int(6), kw_end_DASH_line, int(263), kw_end_DASH_column, int(40), kw_name, sym__STAR_initial_DASH_report_DASH_counters_STAR_, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test))).(*lang.Symbol)
		var_clojure_DOT_test__STAR_initial_DASH_report_DASH_counters_STAR_ = ns.InternWithValue(tmp0, lang.NewMap(kw_test, int64(0), kw_pass, int64(0), kw_fail, int64(0), kw_error, int64(0)), true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test__STAR_initial_DASH_report_DASH_counters_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_clojure_DOT_test__STAR_initial_DASH_report_DASH_counters_STAR_.SetDynamic()
	}
	// *load-tests*
	{
		tmp0 := sym__STAR_load_DASH_tests_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "clojure/test.glj", kw_line, int(244), kw_column, int(10), kw_end_DASH_line, int(249), kw_end_DASH_column, int(14), kw_name, sym__STAR_load_DASH_tests_STAR_, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test))).(*lang.Symbol)
		var_clojure_DOT_test__STAR_load_DASH_tests_STAR_ = ns.InternWithValue(tmp0, true, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test__STAR_load_DASH_tests_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_clojure_DOT_test__STAR_load_DASH_tests_STAR_.SetDynamic()
	}
	// *report-counters*
	{
		tmp0 := sym__STAR_report_DASH_counters_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "clojure/test.glj", kw_line, int(261), kw_column, int(6), kw_end_DASH_line, int(261), kw_end_DASH_column, int(32), kw_name, sym__STAR_report_DASH_counters_STAR_, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test))).(*lang.Symbol)
		var_clojure_DOT_test__STAR_report_DASH_counters_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test__STAR_report_DASH_counters_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_clojure_DOT_test__STAR_report_DASH_counters_STAR_.SetDynamic()
	}
	// *stack-trace-depth*
	{
		tmp0 := sym__STAR_stack_DASH_trace_DASH_depth_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "clojure/test.glj", kw_line, int(251), kw_column, int(6), kw_end_DASH_line, int(256), kw_end_DASH_column, int(20), kw_name, sym__STAR_stack_DASH_trace_DASH_depth_STAR_, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test))).(*lang.Symbol)
		var_clojure_DOT_test__STAR_stack_DASH_trace_DASH_depth_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test__STAR_stack_DASH_trace_DASH_depth_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_clojure_DOT_test__STAR_stack_DASH_trace_DASH_depth_STAR_.SetDynamic()
	}
	// *test-out*
	{
		tmp0 := sym__STAR_test_DASH_out_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "clojure/test.glj", kw_line, int(270), kw_column, int(6), kw_end_DASH_line, int(270), kw_end_DASH_column, int(32), kw_name, sym__STAR_test_DASH_out_STAR_, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test))).(*lang.Symbol)
		var_clojure_DOT_test__STAR_test_DASH_out_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test__STAR_test_DASH_out_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_clojure_DOT_test__STAR_test_DASH_out_STAR_.SetDynamic()
	}
	// *testing-contexts*
	{
		tmp0 := sym__STAR_testing_DASH_contexts_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "clojure/test.glj", kw_line, int(268), kw_column, int(6), kw_end_DASH_line, int(268), kw_end_DASH_column, int(33), kw_name, sym__STAR_testing_DASH_contexts_STAR_, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test))).(*lang.Symbol)
		var_clojure_DOT_test__STAR_testing_DASH_contexts_STAR_ = ns.InternWithValue(tmp0, lang.NewList(), true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test__STAR_testing_DASH_contexts_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_clojure_DOT_test__STAR_testing_DASH_contexts_STAR_.SetDynamic()
	}
	// *testing-vars*
	{
		tmp0 := sym__STAR_testing_DASH_vars_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "clojure/test.glj", kw_line, int(266), kw_column, int(6), kw_end_DASH_line, int(266), kw_end_DASH_column, int(29), kw_name, sym__STAR_testing_DASH_vars_STAR_, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test))).(*lang.Symbol)
		var_clojure_DOT_test__STAR_testing_DASH_vars_STAR_ = ns.InternWithValue(tmp0, lang.NewList(), true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test__STAR_testing_DASH_vars_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_clojure_DOT_test__STAR_testing_DASH_vars_STAR_.SetDynamic()
	}
	// compose-fixtures
	{
		tmp0 := sym_compose_DASH_fixtures.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f1, sym_f2)), kw_doc, "Composes two fixture functions, creating a new fixture function\n  that combines their behavior.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_compose_DASH_fixtures, kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(680), kw_end_DASH_line, int(680))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v5 := args[0]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					tmp7 := lang.Apply(v3, []any{v5})
					return tmp7
				})
				tmp7 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(685), kw_column, int(15), kw_end_DASH_line, int(685), kw_end_DASH_column, int(28))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(v2, []any{tmp8})
				return tmp9
			})
			tmp5 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(685), kw_column, int(3), kw_end_DASH_line, int(685), kw_end_DASH_column, int(30))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_compose_DASH_fixtures = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_compose_DASH_fixtures.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// default-fixture
	{
		tmp0 := sym_default_DASH_fixture.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "The default, empty, fixture function.  Just calls its argument.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_default_DASH_fixture, kw_end_DASH_column, int(22), kw_column, int(8), kw_line, int(674), kw_end_DASH_line, int(674), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(v2, nil)
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_default_DASH_fixture = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_default_DASH_fixture.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-ns-meta
	{
		tmp0 := sym_add_DASH_ns_DASH_meta.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_key, sym_coll)), kw_doc, "Adds elements in coll to the current namespace metadata as the\n  value of key.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_add_DASH_ns_DASH_meta, kw_end_DASH_column, int(18), kw_column, int(8), kw_line, int(654), kw_end_DASH_line, int(654), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_core_alter_DASH_meta_BANG_)
			tmp5 := checkDerefVar(var_clojure_DOT_core__STAR_ns_STAR_)
			tmp6 := checkDerefVar(var_clojure_DOT_core_assoc)
			tmp7 := lang.Apply(tmp4, []any{tmp5, tmp6, v2, v3})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_add_DASH_ns_DASH_meta = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_add_DASH_ns_DASH_meta.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// use-fixtures
	{
		tmp0 := sym_use_DASH_fixtures.WithMeta(lang.NewMap(kw_doc, "Wrap test runs in a fixture function to perform setup and\n  teardown. Using a fixture-type of :each wraps every test\n  individually, while :once wraps the whole run in a single function.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_use_DASH_fixtures, kw_end_DASH_column, int(22), kw_column, int(11), kw_line, int(661), kw_end_DASH_line, int(661))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				return v3
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(666), kw_column, int(3), kw_end_DASH_line, int(666), kw_end_DASH_column, int(41))).(lang.FnFunc)
		// MultiFn use-fixtures
		tmp1 := lang.NewMultiFn("use-fixtures", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v4 := args[0]
				_ = v4
				restArgs := args[1:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_test_add_DASH_ns_DASH_meta)
				tmp7 := lang.Apply(tmp6, []any{kw_clojure_DOT_test_SLASH_each_DASH_fixtures, v5})
				return tmp7
			}
		})
		tmp1.AddMethod(kw_each, tmp3)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v5 := args[0]
				_ = v5
				restArgs := args[1:]
				var v6 any
				if len(restArgs) > 0 {
					v6 = lang.NewList(restArgs...)
				}
				_ = v6
				tmp7 := checkDerefVar(var_clojure_DOT_test_add_DASH_ns_DASH_meta)
				tmp8 := lang.Apply(tmp7, []any{kw_clojure_DOT_test_SLASH_once_DASH_fixtures, v6})
				return tmp8
			}
		})
		tmp1.AddMethod(kw_once, tmp4)
		var_clojure_DOT_test_use_DASH_fixtures = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_use_DASH_fixtures.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// are
	{
		tmp0 := sym_are.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_argv, sym_expr, sym__AMP_, sym_args)), kw_doc, "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_are, kw_end_DASH_column, int(13), kw_column, int(11), kw_line, int(563), kw_end_DASH_line, int(563))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 4)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				restArgs := args[4:]
				var v6 any
				if len(restArgs) > 0 {
					v6 = lang.NewList(restArgs...)
				}
				_ = v6
				var tmp7 any
				var tmp8 any
				{ // let
					// let binding "or__0__auto__"
					var tmp9 any
					{ // let
						// let binding "and__0__auto__"
						tmp10 := checkDerefVar(var_clojure_DOT_core_empty_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v4})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							tmp14 := checkDerefVar(var_clojure_DOT_core_empty_QMARK_)
							tmp15 := lang.Apply(tmp14, []any{v6})
							tmp13 = tmp15
						} else {
							tmp13 = v12
						}
						tmp9 = tmp13
					} // end let
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						tmp11 = v10
					} else {
						var tmp12 any
						{ // let
							// let binding "and__0__auto__"
							tmp13 := checkDerefVar(var_clojure_DOT_core_pos_QMARK_)
							tmp14 := checkDerefVar(var_clojure_DOT_core_count)
							tmp15 := lang.Apply(tmp14, []any{v4})
							tmp16 := lang.Apply(tmp13, []any{tmp15})
							var v17 any = tmp16
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								var tmp19 any
								{ // let
									// let binding "and__0__auto__"
									tmp20 := checkDerefVar(var_clojure_DOT_core_pos_QMARK_)
									tmp21 := checkDerefVar(var_clojure_DOT_core_count)
									tmp22 := lang.Apply(tmp21, []any{v6})
									tmp23 := lang.Apply(tmp20, []any{tmp22})
									var v24 any = tmp23
									_ = v24
									var tmp25 any
									if lang.IsTruthy(v24) {
										tmp26 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
										tmp27 := checkDerefVar(var_clojure_DOT_core_mod)
										tmp28 := checkDerefVar(var_clojure_DOT_core_count)
										tmp29 := lang.Apply(tmp28, []any{v6})
										tmp30 := checkDerefVar(var_clojure_DOT_core_count)
										tmp31 := lang.Apply(tmp30, []any{v4})
										tmp32 := lang.Apply(tmp27, []any{tmp29, tmp31})
										tmp33 := lang.Apply(tmp26, []any{tmp32})
										tmp25 = tmp33
									} else {
										tmp25 = v24
									}
									tmp19 = tmp25
								} // end let
								tmp18 = tmp19
							} else {
								tmp18 = v17
							}
							tmp12 = tmp18
						} // end let
						tmp11 = tmp12
					}
					tmp8 = tmp11
				} // end let
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp10 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp11 := checkDerefVar(var_clojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_clojure_DOT_template_SLASH_do_DASH_template})
					tmp13 := checkDerefVar(var_clojure_DOT_core_list)
					tmp14 := lang.Apply(tmp13, []any{v4})
					tmp15 := checkDerefVar(var_clojure_DOT_core_list)
					tmp16 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp17 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp18 := checkDerefVar(var_clojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{sym_clojure_DOT_test_SLASH_is})
					tmp20 := checkDerefVar(var_clojure_DOT_core_list)
					tmp21 := lang.Apply(tmp20, []any{v5})
					tmp22 := lang.Apply(tmp17, []any{tmp19, tmp21})
					tmp23 := lang.Apply(tmp16, []any{tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp10, []any{tmp12, tmp14, tmp24, v6})
					tmp26 := lang.Apply(tmp9, []any{tmp25})
					tmp7 = tmp26
				} else {
					tmp27 := lang.Apply(lang.NewIllegalArgumentError, []any{"The number of args doesn't match are's argv."})
					panic(tmp27)
				}
				return tmp7
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_are = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_are.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert-any
	{
		tmp0 := sym_assert_DASH_any.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_msg, sym_form)), kw_doc, "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_assert_DASH_any, kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(446), kw_end_DASH_line, int(446))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp5 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp6 := checkDerefVar(var_clojure_DOT_core_list)
			tmp7 := lang.Apply(tmp6, []any{sym_clojure_DOT_core_SLASH_let})
			tmp8 := checkDerefVar(var_clojure_DOT_core_list)
			tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp10 := checkDerefVar(var_clojure_DOT_core_vector)
			tmp11 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp12 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp13 := checkDerefVar(var_clojure_DOT_core_list)
			tmp14 := lang.Apply(tmp13, []any{sym_value__0__auto__})
			tmp15 := checkDerefVar(var_clojure_DOT_core_list)
			tmp16 := lang.Apply(tmp15, []any{v3})
			tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
			tmp18 := lang.Apply(tmp11, []any{tmp17})
			tmp19 := lang.Apply(tmp9, []any{tmp10, tmp18})
			tmp20 := lang.Apply(tmp8, []any{tmp19})
			tmp21 := checkDerefVar(var_clojure_DOT_core_list)
			tmp22 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp23 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp24 := checkDerefVar(var_clojure_DOT_core_list)
			tmp25 := lang.Apply(tmp24, []any{sym_if})
			tmp26 := checkDerefVar(var_clojure_DOT_core_list)
			tmp27 := lang.Apply(tmp26, []any{sym_value__0__auto__})
			tmp28 := checkDerefVar(var_clojure_DOT_core_list)
			tmp29 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp30 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp31 := checkDerefVar(var_clojure_DOT_core_list)
			tmp32 := lang.Apply(tmp31, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
			tmp33 := checkDerefVar(var_clojure_DOT_core_list)
			tmp34 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp35 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
			tmp36 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp37 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp38 := checkDerefVar(var_clojure_DOT_core_list)
			tmp39 := lang.Apply(tmp38, []any{kw_type})
			tmp40 := checkDerefVar(var_clojure_DOT_core_list)
			tmp41 := lang.Apply(tmp40, []any{kw_pass})
			tmp42 := checkDerefVar(var_clojure_DOT_core_list)
			tmp43 := lang.Apply(tmp42, []any{kw_message})
			tmp44 := checkDerefVar(var_clojure_DOT_core_list)
			tmp45 := lang.Apply(tmp44, []any{v2})
			tmp46 := checkDerefVar(var_clojure_DOT_core_list)
			tmp47 := lang.Apply(tmp46, []any{kw_expected})
			tmp48 := checkDerefVar(var_clojure_DOT_core_list)
			tmp49 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp50 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp51 := checkDerefVar(var_clojure_DOT_core_list)
			tmp52 := lang.Apply(tmp51, []any{sym_quote})
			tmp53 := checkDerefVar(var_clojure_DOT_core_list)
			tmp54 := lang.Apply(tmp53, []any{v3})
			tmp55 := lang.Apply(tmp50, []any{tmp52, tmp54})
			tmp56 := lang.Apply(tmp49, []any{tmp55})
			tmp57 := lang.Apply(tmp48, []any{tmp56})
			tmp58 := checkDerefVar(var_clojure_DOT_core_list)
			tmp59 := lang.Apply(tmp58, []any{kw_actual})
			tmp60 := checkDerefVar(var_clojure_DOT_core_list)
			tmp61 := lang.Apply(tmp60, []any{sym_value__0__auto__})
			tmp62 := lang.Apply(tmp37, []any{tmp39, tmp41, tmp43, tmp45, tmp47, tmp57, tmp59, tmp61})
			tmp63 := lang.Apply(tmp36, []any{tmp62})
			tmp64 := lang.Apply(tmp34, []any{tmp35, tmp63})
			tmp65 := lang.Apply(tmp33, []any{tmp64})
			tmp66 := lang.Apply(tmp30, []any{tmp32, tmp65})
			tmp67 := lang.Apply(tmp29, []any{tmp66})
			tmp68 := lang.Apply(tmp28, []any{tmp67})
			tmp69 := checkDerefVar(var_clojure_DOT_core_list)
			tmp70 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp71 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp72 := checkDerefVar(var_clojure_DOT_core_list)
			tmp73 := lang.Apply(tmp72, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
			tmp74 := checkDerefVar(var_clojure_DOT_core_list)
			tmp75 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp76 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
			tmp77 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp78 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp79 := checkDerefVar(var_clojure_DOT_core_list)
			tmp80 := lang.Apply(tmp79, []any{kw_type})
			tmp81 := checkDerefVar(var_clojure_DOT_core_list)
			tmp82 := lang.Apply(tmp81, []any{kw_fail})
			tmp83 := checkDerefVar(var_clojure_DOT_core_list)
			tmp84 := lang.Apply(tmp83, []any{kw_message})
			tmp85 := checkDerefVar(var_clojure_DOT_core_list)
			tmp86 := lang.Apply(tmp85, []any{v2})
			tmp87 := checkDerefVar(var_clojure_DOT_core_list)
			tmp88 := lang.Apply(tmp87, []any{kw_expected})
			tmp89 := checkDerefVar(var_clojure_DOT_core_list)
			tmp90 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp91 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp92 := checkDerefVar(var_clojure_DOT_core_list)
			tmp93 := lang.Apply(tmp92, []any{sym_quote})
			tmp94 := checkDerefVar(var_clojure_DOT_core_list)
			tmp95 := lang.Apply(tmp94, []any{v3})
			tmp96 := lang.Apply(tmp91, []any{tmp93, tmp95})
			tmp97 := lang.Apply(tmp90, []any{tmp96})
			tmp98 := lang.Apply(tmp89, []any{tmp97})
			tmp99 := checkDerefVar(var_clojure_DOT_core_list)
			tmp100 := lang.Apply(tmp99, []any{kw_actual})
			tmp101 := checkDerefVar(var_clojure_DOT_core_list)
			tmp102 := lang.Apply(tmp101, []any{sym_value__0__auto__})
			tmp103 := lang.Apply(tmp78, []any{tmp80, tmp82, tmp84, tmp86, tmp88, tmp98, tmp100, tmp102})
			tmp104 := lang.Apply(tmp77, []any{tmp103})
			tmp105 := lang.Apply(tmp75, []any{tmp76, tmp104})
			tmp106 := lang.Apply(tmp74, []any{tmp105})
			tmp107 := lang.Apply(tmp71, []any{tmp73, tmp106})
			tmp108 := lang.Apply(tmp70, []any{tmp107})
			tmp109 := lang.Apply(tmp69, []any{tmp108})
			tmp110 := lang.Apply(tmp23, []any{tmp25, tmp27, tmp68, tmp109})
			tmp111 := lang.Apply(tmp22, []any{tmp110})
			tmp112 := lang.Apply(tmp21, []any{tmp111})
			tmp113 := checkDerefVar(var_clojure_DOT_core_list)
			tmp114 := lang.Apply(tmp113, []any{sym_value__0__auto__})
			tmp115 := lang.Apply(tmp5, []any{tmp7, tmp20, tmp112, tmp114})
			tmp116 := lang.Apply(tmp4, []any{tmp115})
			return tmp116
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_assert_DASH_any = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_assert_DASH_any.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert-expr
	{
		tmp0 := sym_assert_DASH_expr.WithMeta(lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(467), kw_column, int(11), kw_end_DASH_line, int(467), kw_end_DASH_column, int(21), kw_name, sym_assert_DASH_expr, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			if lang.IsTruthy(tmp7) {
				tmp5 = kw_always_DASH_fail
			} else {
				var tmp8 any
				tmp9 := checkDerefVar(var_clojure_DOT_core_seq_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v4})
				if lang.IsTruthy(tmp10) {
					tmp11 := checkDerefVar(var_clojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v4})
					tmp8 = tmp12
				} else {
					var tmp13 any
					if lang.IsTruthy(kw_else) {
						tmp13 = kw_default
					} else {
					}
					tmp8 = tmp13
				}
				tmp5 = tmp8
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(468), kw_column, int(3), kw_end_DASH_line, int(472), kw_end_DASH_column, int(22))).(lang.FnFunc)
		// MultiFn assert-expr
		tmp1 := lang.NewMultiFn("assert-expr", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp8 := checkDerefVar(var_clojure_DOT_core_list)
			tmp9 := lang.Apply(tmp8, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
			tmp10 := checkDerefVar(var_clojure_DOT_core_list)
			tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp12 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
			tmp13 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp14 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp15 := checkDerefVar(var_clojure_DOT_core_list)
			tmp16 := lang.Apply(tmp15, []any{kw_type})
			tmp17 := checkDerefVar(var_clojure_DOT_core_list)
			tmp18 := lang.Apply(tmp17, []any{kw_fail})
			tmp19 := checkDerefVar(var_clojure_DOT_core_list)
			tmp20 := lang.Apply(tmp19, []any{kw_message})
			tmp21 := checkDerefVar(var_clojure_DOT_core_list)
			tmp22 := lang.Apply(tmp21, []any{v4})
			tmp23 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp20, tmp22})
			tmp24 := lang.Apply(tmp13, []any{tmp23})
			tmp25 := lang.Apply(tmp11, []any{tmp12, tmp24})
			tmp26 := lang.Apply(tmp10, []any{tmp25})
			tmp27 := lang.Apply(tmp7, []any{tmp9, tmp26})
			tmp28 := lang.Apply(tmp6, []any{tmp27})
			return tmp28
		})
		tmp1.AddMethod(kw_always_DASH_fail, tmp3)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v5 := args[0]
			_ = v5
			v6 := args[1]
			_ = v6
			var tmp7 any
			var tmp8 any
			{ // let
				// let binding "and__0__auto__"
				tmp9 := checkDerefVar(var_clojure_DOT_core_sequential_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v6})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				if lang.IsTruthy(v11) {
					tmp13 := checkDerefVar(var_clojure_DOT_test_function_QMARK_)
					tmp14 := checkDerefVar(var_clojure_DOT_core_first)
					tmp15 := lang.Apply(tmp14, []any{v6})
					tmp16 := lang.Apply(tmp13, []any{tmp15})
					tmp12 = tmp16
				} else {
					tmp12 = v11
				}
				tmp8 = tmp12
			} // end let
			if lang.IsTruthy(tmp8) {
				tmp9 := checkDerefVar(var_clojure_DOT_test_assert_DASH_predicate)
				tmp10 := lang.Apply(tmp9, []any{v5, v6})
				tmp7 = tmp10
			} else {
				tmp11 := checkDerefVar(var_clojure_DOT_test_assert_DASH_any)
				tmp12 := lang.Apply(tmp11, []any{v5, v6})
				tmp7 = tmp12
			}
			return tmp7
		})
		tmp1.AddMethod(kw_default, tmp4)
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v6 := args[0]
			_ = v6
			v7 := args[1]
			_ = v7
			tmp8 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp9 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp10 := checkDerefVar(var_clojure_DOT_core_list)
			tmp11 := lang.Apply(tmp10, []any{sym_clojure_DOT_core_SLASH_let})
			tmp12 := checkDerefVar(var_clojure_DOT_core_list)
			tmp13 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp14 := checkDerefVar(var_clojure_DOT_core_vector)
			tmp15 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp16 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp17 := checkDerefVar(var_clojure_DOT_core_list)
			tmp18 := lang.Apply(tmp17, []any{sym_klass__0__auto__})
			tmp19 := checkDerefVar(var_clojure_DOT_core_list)
			tmp20 := checkDerefVar(var_clojure_DOT_core_nth)
			tmp21 := lang.Apply(tmp20, []any{v7, int64(1)})
			tmp22 := lang.Apply(tmp19, []any{tmp21})
			tmp23 := checkDerefVar(var_clojure_DOT_core_list)
			tmp24 := lang.Apply(tmp23, []any{sym_object__1__auto__})
			tmp25 := checkDerefVar(var_clojure_DOT_core_list)
			tmp26 := checkDerefVar(var_clojure_DOT_core_nth)
			tmp27 := lang.Apply(tmp26, []any{v7, int64(2)})
			tmp28 := lang.Apply(tmp25, []any{tmp27})
			tmp29 := lang.Apply(tmp16, []any{tmp18, tmp22, tmp24, tmp28})
			tmp30 := lang.Apply(tmp15, []any{tmp29})
			tmp31 := lang.Apply(tmp13, []any{tmp14, tmp30})
			tmp32 := lang.Apply(tmp12, []any{tmp31})
			tmp33 := checkDerefVar(var_clojure_DOT_core_list)
			tmp34 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp35 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp36 := checkDerefVar(var_clojure_DOT_core_list)
			tmp37 := lang.Apply(tmp36, []any{sym_clojure_DOT_core_SLASH_let})
			tmp38 := checkDerefVar(var_clojure_DOT_core_list)
			tmp39 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp40 := checkDerefVar(var_clojure_DOT_core_vector)
			tmp41 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp42 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp43 := checkDerefVar(var_clojure_DOT_core_list)
			tmp44 := lang.Apply(tmp43, []any{sym_result__2__auto__})
			tmp45 := checkDerefVar(var_clojure_DOT_core_list)
			tmp46 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp47 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp48 := checkDerefVar(var_clojure_DOT_core_list)
			tmp49 := lang.Apply(tmp48, []any{sym_clojure_DOT_core_SLASH_instance_QMARK_})
			tmp50 := checkDerefVar(var_clojure_DOT_core_list)
			tmp51 := lang.Apply(tmp50, []any{sym_klass__0__auto__})
			tmp52 := checkDerefVar(var_clojure_DOT_core_list)
			tmp53 := lang.Apply(tmp52, []any{sym_object__1__auto__})
			tmp54 := lang.Apply(tmp47, []any{tmp49, tmp51, tmp53})
			tmp55 := lang.Apply(tmp46, []any{tmp54})
			tmp56 := lang.Apply(tmp45, []any{tmp55})
			tmp57 := lang.Apply(tmp42, []any{tmp44, tmp56})
			tmp58 := lang.Apply(tmp41, []any{tmp57})
			tmp59 := lang.Apply(tmp39, []any{tmp40, tmp58})
			tmp60 := lang.Apply(tmp38, []any{tmp59})
			tmp61 := checkDerefVar(var_clojure_DOT_core_list)
			tmp62 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp63 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp64 := checkDerefVar(var_clojure_DOT_core_list)
			tmp65 := lang.Apply(tmp64, []any{sym_if})
			tmp66 := checkDerefVar(var_clojure_DOT_core_list)
			tmp67 := lang.Apply(tmp66, []any{sym_result__2__auto__})
			tmp68 := checkDerefVar(var_clojure_DOT_core_list)
			tmp69 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp70 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp71 := checkDerefVar(var_clojure_DOT_core_list)
			tmp72 := lang.Apply(tmp71, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
			tmp73 := checkDerefVar(var_clojure_DOT_core_list)
			tmp74 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp75 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
			tmp76 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp77 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp78 := checkDerefVar(var_clojure_DOT_core_list)
			tmp79 := lang.Apply(tmp78, []any{kw_type})
			tmp80 := checkDerefVar(var_clojure_DOT_core_list)
			tmp81 := lang.Apply(tmp80, []any{kw_pass})
			tmp82 := checkDerefVar(var_clojure_DOT_core_list)
			tmp83 := lang.Apply(tmp82, []any{kw_message})
			tmp84 := checkDerefVar(var_clojure_DOT_core_list)
			tmp85 := lang.Apply(tmp84, []any{v6})
			tmp86 := checkDerefVar(var_clojure_DOT_core_list)
			tmp87 := lang.Apply(tmp86, []any{kw_expected})
			tmp88 := checkDerefVar(var_clojure_DOT_core_list)
			tmp89 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp90 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp91 := checkDerefVar(var_clojure_DOT_core_list)
			tmp92 := lang.Apply(tmp91, []any{sym_quote})
			tmp93 := checkDerefVar(var_clojure_DOT_core_list)
			tmp94 := lang.Apply(tmp93, []any{v7})
			tmp95 := lang.Apply(tmp90, []any{tmp92, tmp94})
			tmp96 := lang.Apply(tmp89, []any{tmp95})
			tmp97 := lang.Apply(tmp88, []any{tmp96})
			tmp98 := checkDerefVar(var_clojure_DOT_core_list)
			tmp99 := lang.Apply(tmp98, []any{kw_actual})
			tmp100 := checkDerefVar(var_clojure_DOT_core_list)
			tmp101 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp102 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp103 := checkDerefVar(var_clojure_DOT_core_list)
			tmp104 := lang.Apply(tmp103, []any{sym_clojure_DOT_core_SLASH_class})
			tmp105 := checkDerefVar(var_clojure_DOT_core_list)
			tmp106 := lang.Apply(tmp105, []any{sym_object__1__auto__})
			tmp107 := lang.Apply(tmp102, []any{tmp104, tmp106})
			tmp108 := lang.Apply(tmp101, []any{tmp107})
			tmp109 := lang.Apply(tmp100, []any{tmp108})
			tmp110 := lang.Apply(tmp77, []any{tmp79, tmp81, tmp83, tmp85, tmp87, tmp97, tmp99, tmp109})
			tmp111 := lang.Apply(tmp76, []any{tmp110})
			tmp112 := lang.Apply(tmp74, []any{tmp75, tmp111})
			tmp113 := lang.Apply(tmp73, []any{tmp112})
			tmp114 := lang.Apply(tmp70, []any{tmp72, tmp113})
			tmp115 := lang.Apply(tmp69, []any{tmp114})
			tmp116 := lang.Apply(tmp68, []any{tmp115})
			tmp117 := checkDerefVar(var_clojure_DOT_core_list)
			tmp118 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp119 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp120 := checkDerefVar(var_clojure_DOT_core_list)
			tmp121 := lang.Apply(tmp120, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
			tmp122 := checkDerefVar(var_clojure_DOT_core_list)
			tmp123 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp124 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
			tmp125 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp126 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp127 := checkDerefVar(var_clojure_DOT_core_list)
			tmp128 := lang.Apply(tmp127, []any{kw_type})
			tmp129 := checkDerefVar(var_clojure_DOT_core_list)
			tmp130 := lang.Apply(tmp129, []any{kw_fail})
			tmp131 := checkDerefVar(var_clojure_DOT_core_list)
			tmp132 := lang.Apply(tmp131, []any{kw_message})
			tmp133 := checkDerefVar(var_clojure_DOT_core_list)
			tmp134 := lang.Apply(tmp133, []any{v6})
			tmp135 := checkDerefVar(var_clojure_DOT_core_list)
			tmp136 := lang.Apply(tmp135, []any{kw_expected})
			tmp137 := checkDerefVar(var_clojure_DOT_core_list)
			tmp138 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp139 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp140 := checkDerefVar(var_clojure_DOT_core_list)
			tmp141 := lang.Apply(tmp140, []any{sym_quote})
			tmp142 := checkDerefVar(var_clojure_DOT_core_list)
			tmp143 := lang.Apply(tmp142, []any{v7})
			tmp144 := lang.Apply(tmp139, []any{tmp141, tmp143})
			tmp145 := lang.Apply(tmp138, []any{tmp144})
			tmp146 := lang.Apply(tmp137, []any{tmp145})
			tmp147 := checkDerefVar(var_clojure_DOT_core_list)
			tmp148 := lang.Apply(tmp147, []any{kw_actual})
			tmp149 := checkDerefVar(var_clojure_DOT_core_list)
			tmp150 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp151 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp152 := checkDerefVar(var_clojure_DOT_core_list)
			tmp153 := lang.Apply(tmp152, []any{sym_clojure_DOT_core_SLASH_class})
			tmp154 := checkDerefVar(var_clojure_DOT_core_list)
			tmp155 := lang.Apply(tmp154, []any{sym_object__1__auto__})
			tmp156 := lang.Apply(tmp151, []any{tmp153, tmp155})
			tmp157 := lang.Apply(tmp150, []any{tmp156})
			tmp158 := lang.Apply(tmp149, []any{tmp157})
			tmp159 := lang.Apply(tmp126, []any{tmp128, tmp130, tmp132, tmp134, tmp136, tmp146, tmp148, tmp158})
			tmp160 := lang.Apply(tmp125, []any{tmp159})
			tmp161 := lang.Apply(tmp123, []any{tmp124, tmp160})
			tmp162 := lang.Apply(tmp122, []any{tmp161})
			tmp163 := lang.Apply(tmp119, []any{tmp121, tmp162})
			tmp164 := lang.Apply(tmp118, []any{tmp163})
			tmp165 := lang.Apply(tmp117, []any{tmp164})
			tmp166 := lang.Apply(tmp63, []any{tmp65, tmp67, tmp116, tmp165})
			tmp167 := lang.Apply(tmp62, []any{tmp166})
			tmp168 := lang.Apply(tmp61, []any{tmp167})
			tmp169 := checkDerefVar(var_clojure_DOT_core_list)
			tmp170 := lang.Apply(tmp169, []any{sym_result__2__auto__})
			tmp171 := lang.Apply(tmp35, []any{tmp37, tmp60, tmp168, tmp170})
			tmp172 := lang.Apply(tmp34, []any{tmp171})
			tmp173 := lang.Apply(tmp33, []any{tmp172})
			tmp174 := lang.Apply(tmp9, []any{tmp11, tmp32, tmp173})
			tmp175 := lang.Apply(tmp8, []any{tmp174})
			return tmp175
		})
		tmp1.AddMethod(sym_instance_QMARK_, tmp5)
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v7 := args[0]
			_ = v7
			v8 := args[1]
			_ = v8
			var tmp9 any
			{ // let
				// let binding "klass"
				tmp10 := checkDerefVar(var_clojure_DOT_core_second)
				tmp11 := lang.Apply(tmp10, []any{v8})
				var v12 any = tmp11
				_ = v12
				// let binding "body"
				tmp13 := checkDerefVar(var_clojure_DOT_core_nthnext)
				tmp14 := lang.Apply(tmp13, []any{v8, int64(2)})
				var v15 any = tmp14
				_ = v15
				tmp16 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp17 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp18 := checkDerefVar(var_clojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{sym_try})
				tmp20 := checkDerefVar(var_clojure_DOT_core_list)
				tmp21 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp22 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp23 := checkDerefVar(var_clojure_DOT_core_list)
				tmp24 := lang.Apply(tmp23, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
				tmp25 := checkDerefVar(var_clojure_DOT_core_list)
				tmp26 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp27 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp28 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp29 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp30 := checkDerefVar(var_clojure_DOT_core_list)
				tmp31 := lang.Apply(tmp30, []any{kw_type})
				tmp32 := checkDerefVar(var_clojure_DOT_core_list)
				tmp33 := lang.Apply(tmp32, []any{kw_fail})
				tmp34 := checkDerefVar(var_clojure_DOT_core_list)
				tmp35 := lang.Apply(tmp34, []any{kw_message})
				tmp36 := checkDerefVar(var_clojure_DOT_core_list)
				tmp37 := lang.Apply(tmp36, []any{v7})
				tmp38 := checkDerefVar(var_clojure_DOT_core_list)
				tmp39 := lang.Apply(tmp38, []any{kw_expected})
				tmp40 := checkDerefVar(var_clojure_DOT_core_list)
				tmp41 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp42 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp43 := checkDerefVar(var_clojure_DOT_core_list)
				tmp44 := lang.Apply(tmp43, []any{sym_quote})
				tmp45 := checkDerefVar(var_clojure_DOT_core_list)
				tmp46 := lang.Apply(tmp45, []any{v8})
				tmp47 := lang.Apply(tmp42, []any{tmp44, tmp46})
				tmp48 := lang.Apply(tmp41, []any{tmp47})
				tmp49 := lang.Apply(tmp40, []any{tmp48})
				tmp50 := checkDerefVar(var_clojure_DOT_core_list)
				tmp51 := lang.Apply(tmp50, []any{kw_actual})
				tmp52 := checkDerefVar(var_clojure_DOT_core_list)
				tmp53 := lang.Apply(tmp52, []any{nil})
				tmp54 := lang.Apply(tmp29, []any{tmp31, tmp33, tmp35, tmp37, tmp39, tmp49, tmp51, tmp53})
				tmp55 := lang.Apply(tmp28, []any{tmp54})
				tmp56 := lang.Apply(tmp26, []any{tmp27, tmp55})
				tmp57 := lang.Apply(tmp25, []any{tmp56})
				tmp58 := lang.Apply(tmp22, []any{tmp24, tmp57})
				tmp59 := lang.Apply(tmp21, []any{tmp58})
				tmp60 := lang.Apply(tmp20, []any{tmp59})
				tmp61 := checkDerefVar(var_clojure_DOT_core_list)
				tmp62 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp63 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp64 := checkDerefVar(var_clojure_DOT_core_list)
				tmp65 := lang.Apply(tmp64, []any{sym_catch})
				tmp66 := checkDerefVar(var_clojure_DOT_core_list)
				tmp67 := lang.Apply(tmp66, []any{v12})
				tmp68 := checkDerefVar(var_clojure_DOT_core_list)
				tmp69 := lang.Apply(tmp68, []any{sym_e__0__auto__})
				tmp70 := checkDerefVar(var_clojure_DOT_core_list)
				tmp71 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp72 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp73 := checkDerefVar(var_clojure_DOT_core_list)
				tmp74 := lang.Apply(tmp73, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
				tmp75 := checkDerefVar(var_clojure_DOT_core_list)
				tmp76 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp77 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp78 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp79 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp80 := checkDerefVar(var_clojure_DOT_core_list)
				tmp81 := lang.Apply(tmp80, []any{kw_type})
				tmp82 := checkDerefVar(var_clojure_DOT_core_list)
				tmp83 := lang.Apply(tmp82, []any{kw_pass})
				tmp84 := checkDerefVar(var_clojure_DOT_core_list)
				tmp85 := lang.Apply(tmp84, []any{kw_message})
				tmp86 := checkDerefVar(var_clojure_DOT_core_list)
				tmp87 := lang.Apply(tmp86, []any{v7})
				tmp88 := checkDerefVar(var_clojure_DOT_core_list)
				tmp89 := lang.Apply(tmp88, []any{kw_expected})
				tmp90 := checkDerefVar(var_clojure_DOT_core_list)
				tmp91 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp92 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp93 := checkDerefVar(var_clojure_DOT_core_list)
				tmp94 := lang.Apply(tmp93, []any{sym_quote})
				tmp95 := checkDerefVar(var_clojure_DOT_core_list)
				tmp96 := lang.Apply(tmp95, []any{v8})
				tmp97 := lang.Apply(tmp92, []any{tmp94, tmp96})
				tmp98 := lang.Apply(tmp91, []any{tmp97})
				tmp99 := lang.Apply(tmp90, []any{tmp98})
				tmp100 := checkDerefVar(var_clojure_DOT_core_list)
				tmp101 := lang.Apply(tmp100, []any{kw_actual})
				tmp102 := checkDerefVar(var_clojure_DOT_core_list)
				tmp103 := lang.Apply(tmp102, []any{sym_e__0__auto__})
				tmp104 := lang.Apply(tmp79, []any{tmp81, tmp83, tmp85, tmp87, tmp89, tmp99, tmp101, tmp103})
				tmp105 := lang.Apply(tmp78, []any{tmp104})
				tmp106 := lang.Apply(tmp76, []any{tmp77, tmp105})
				tmp107 := lang.Apply(tmp75, []any{tmp106})
				tmp108 := lang.Apply(tmp72, []any{tmp74, tmp107})
				tmp109 := lang.Apply(tmp71, []any{tmp108})
				tmp110 := lang.Apply(tmp70, []any{tmp109})
				tmp111 := checkDerefVar(var_clojure_DOT_core_list)
				tmp112 := lang.Apply(tmp111, []any{sym_e__0__auto__})
				tmp113 := lang.Apply(tmp63, []any{tmp65, tmp67, tmp69, tmp110, tmp112})
				tmp114 := lang.Apply(tmp62, []any{tmp113})
				tmp115 := lang.Apply(tmp61, []any{tmp114})
				tmp116 := lang.Apply(tmp17, []any{tmp19, v15, tmp60, tmp115})
				tmp117 := lang.Apply(tmp16, []any{tmp116})
				tmp9 = tmp117
			} // end let
			return tmp9
		})
		tmp1.AddMethod(sym_thrown_QMARK_, tmp6)
		var tmp7 lang.FnFunc
		tmp7 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v8 := args[0]
			_ = v8
			v9 := args[1]
			_ = v9
			var tmp10 any
			{ // let
				// let binding "klass"
				tmp11 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp12 := lang.Apply(tmp11, []any{v9, int64(1)})
				var v13 any = tmp12
				_ = v13
				// let binding "re"
				tmp14 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp15 := lang.Apply(tmp14, []any{v9, int64(2)})
				var v16 any = tmp15
				_ = v16
				// let binding "body"
				tmp17 := checkDerefVar(var_clojure_DOT_core_nthnext)
				tmp18 := lang.Apply(tmp17, []any{v9, int64(3)})
				var v19 any = tmp18
				_ = v19
				tmp20 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp21 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp22 := checkDerefVar(var_clojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{sym_try})
				tmp24 := checkDerefVar(var_clojure_DOT_core_list)
				tmp25 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp26 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp27 := checkDerefVar(var_clojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
				tmp29 := checkDerefVar(var_clojure_DOT_core_list)
				tmp30 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp31 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp32 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp33 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp34 := checkDerefVar(var_clojure_DOT_core_list)
				tmp35 := lang.Apply(tmp34, []any{kw_type})
				tmp36 := checkDerefVar(var_clojure_DOT_core_list)
				tmp37 := lang.Apply(tmp36, []any{kw_fail})
				tmp38 := checkDerefVar(var_clojure_DOT_core_list)
				tmp39 := lang.Apply(tmp38, []any{kw_message})
				tmp40 := checkDerefVar(var_clojure_DOT_core_list)
				tmp41 := lang.Apply(tmp40, []any{v8})
				tmp42 := checkDerefVar(var_clojure_DOT_core_list)
				tmp43 := lang.Apply(tmp42, []any{kw_expected})
				tmp44 := checkDerefVar(var_clojure_DOT_core_list)
				tmp45 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp46 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp47 := checkDerefVar(var_clojure_DOT_core_list)
				tmp48 := lang.Apply(tmp47, []any{sym_quote})
				tmp49 := checkDerefVar(var_clojure_DOT_core_list)
				tmp50 := lang.Apply(tmp49, []any{v9})
				tmp51 := lang.Apply(tmp46, []any{tmp48, tmp50})
				tmp52 := lang.Apply(tmp45, []any{tmp51})
				tmp53 := lang.Apply(tmp44, []any{tmp52})
				tmp54 := checkDerefVar(var_clojure_DOT_core_list)
				tmp55 := lang.Apply(tmp54, []any{kw_actual})
				tmp56 := checkDerefVar(var_clojure_DOT_core_list)
				tmp57 := lang.Apply(tmp56, []any{nil})
				tmp58 := lang.Apply(tmp33, []any{tmp35, tmp37, tmp39, tmp41, tmp43, tmp53, tmp55, tmp57})
				tmp59 := lang.Apply(tmp32, []any{tmp58})
				tmp60 := lang.Apply(tmp30, []any{tmp31, tmp59})
				tmp61 := lang.Apply(tmp29, []any{tmp60})
				tmp62 := lang.Apply(tmp26, []any{tmp28, tmp61})
				tmp63 := lang.Apply(tmp25, []any{tmp62})
				tmp64 := lang.Apply(tmp24, []any{tmp63})
				tmp65 := checkDerefVar(var_clojure_DOT_core_list)
				tmp66 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp67 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp68 := checkDerefVar(var_clojure_DOT_core_list)
				tmp69 := lang.Apply(tmp68, []any{sym_catch})
				tmp70 := checkDerefVar(var_clojure_DOT_core_list)
				tmp71 := lang.Apply(tmp70, []any{v13})
				tmp72 := checkDerefVar(var_clojure_DOT_core_list)
				tmp73 := lang.Apply(tmp72, []any{sym_e__0__auto__})
				tmp74 := checkDerefVar(var_clojure_DOT_core_list)
				tmp75 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp76 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp77 := checkDerefVar(var_clojure_DOT_core_list)
				tmp78 := lang.Apply(tmp77, []any{sym_clojure_DOT_core_SLASH_let})
				tmp79 := checkDerefVar(var_clojure_DOT_core_list)
				tmp80 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp81 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp82 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp83 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp84 := checkDerefVar(var_clojure_DOT_core_list)
				tmp85 := lang.Apply(tmp84, []any{sym_m__1__auto__})
				tmp86 := checkDerefVar(var_clojure_DOT_core_list)
				tmp87 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp88 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp89 := checkDerefVar(var_clojure_DOT_core_list)
				tmp90 := lang.Apply(tmp89, []any{sym__DOT_getMessage})
				tmp91 := checkDerefVar(var_clojure_DOT_core_list)
				tmp92 := lang.Apply(tmp91, []any{sym_e__0__auto__})
				tmp93 := lang.Apply(tmp88, []any{tmp90, tmp92})
				tmp94 := lang.Apply(tmp87, []any{tmp93})
				tmp95 := lang.Apply(tmp86, []any{tmp94})
				tmp96 := lang.Apply(tmp83, []any{tmp85, tmp95})
				tmp97 := lang.Apply(tmp82, []any{tmp96})
				tmp98 := lang.Apply(tmp80, []any{tmp81, tmp97})
				tmp99 := lang.Apply(tmp79, []any{tmp98})
				tmp100 := checkDerefVar(var_clojure_DOT_core_list)
				tmp101 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp102 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp103 := checkDerefVar(var_clojure_DOT_core_list)
				tmp104 := lang.Apply(tmp103, []any{sym_if})
				tmp105 := checkDerefVar(var_clojure_DOT_core_list)
				tmp106 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp107 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp108 := checkDerefVar(var_clojure_DOT_core_list)
				tmp109 := lang.Apply(tmp108, []any{sym_clojure_DOT_core_SLASH_re_DASH_find})
				tmp110 := checkDerefVar(var_clojure_DOT_core_list)
				tmp111 := lang.Apply(tmp110, []any{v16})
				tmp112 := checkDerefVar(var_clojure_DOT_core_list)
				tmp113 := lang.Apply(tmp112, []any{sym_m__1__auto__})
				tmp114 := lang.Apply(tmp107, []any{tmp109, tmp111, tmp113})
				tmp115 := lang.Apply(tmp106, []any{tmp114})
				tmp116 := lang.Apply(tmp105, []any{tmp115})
				tmp117 := checkDerefVar(var_clojure_DOT_core_list)
				tmp118 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp119 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp120 := checkDerefVar(var_clojure_DOT_core_list)
				tmp121 := lang.Apply(tmp120, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
				tmp122 := checkDerefVar(var_clojure_DOT_core_list)
				tmp123 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp124 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp125 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp126 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp127 := checkDerefVar(var_clojure_DOT_core_list)
				tmp128 := lang.Apply(tmp127, []any{kw_type})
				tmp129 := checkDerefVar(var_clojure_DOT_core_list)
				tmp130 := lang.Apply(tmp129, []any{kw_pass})
				tmp131 := checkDerefVar(var_clojure_DOT_core_list)
				tmp132 := lang.Apply(tmp131, []any{kw_message})
				tmp133 := checkDerefVar(var_clojure_DOT_core_list)
				tmp134 := lang.Apply(tmp133, []any{v8})
				tmp135 := checkDerefVar(var_clojure_DOT_core_list)
				tmp136 := lang.Apply(tmp135, []any{kw_expected})
				tmp137 := checkDerefVar(var_clojure_DOT_core_list)
				tmp138 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp139 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp140 := checkDerefVar(var_clojure_DOT_core_list)
				tmp141 := lang.Apply(tmp140, []any{sym_quote})
				tmp142 := checkDerefVar(var_clojure_DOT_core_list)
				tmp143 := lang.Apply(tmp142, []any{v9})
				tmp144 := lang.Apply(tmp139, []any{tmp141, tmp143})
				tmp145 := lang.Apply(tmp138, []any{tmp144})
				tmp146 := lang.Apply(tmp137, []any{tmp145})
				tmp147 := checkDerefVar(var_clojure_DOT_core_list)
				tmp148 := lang.Apply(tmp147, []any{kw_actual})
				tmp149 := checkDerefVar(var_clojure_DOT_core_list)
				tmp150 := lang.Apply(tmp149, []any{sym_e__0__auto__})
				tmp151 := lang.Apply(tmp126, []any{tmp128, tmp130, tmp132, tmp134, tmp136, tmp146, tmp148, tmp150})
				tmp152 := lang.Apply(tmp125, []any{tmp151})
				tmp153 := lang.Apply(tmp123, []any{tmp124, tmp152})
				tmp154 := lang.Apply(tmp122, []any{tmp153})
				tmp155 := lang.Apply(tmp119, []any{tmp121, tmp154})
				tmp156 := lang.Apply(tmp118, []any{tmp155})
				tmp157 := lang.Apply(tmp117, []any{tmp156})
				tmp158 := checkDerefVar(var_clojure_DOT_core_list)
				tmp159 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp160 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp161 := checkDerefVar(var_clojure_DOT_core_list)
				tmp162 := lang.Apply(tmp161, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
				tmp163 := checkDerefVar(var_clojure_DOT_core_list)
				tmp164 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp165 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp166 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp167 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp168 := checkDerefVar(var_clojure_DOT_core_list)
				tmp169 := lang.Apply(tmp168, []any{kw_type})
				tmp170 := checkDerefVar(var_clojure_DOT_core_list)
				tmp171 := lang.Apply(tmp170, []any{kw_fail})
				tmp172 := checkDerefVar(var_clojure_DOT_core_list)
				tmp173 := lang.Apply(tmp172, []any{kw_message})
				tmp174 := checkDerefVar(var_clojure_DOT_core_list)
				tmp175 := lang.Apply(tmp174, []any{v8})
				tmp176 := checkDerefVar(var_clojure_DOT_core_list)
				tmp177 := lang.Apply(tmp176, []any{kw_expected})
				tmp178 := checkDerefVar(var_clojure_DOT_core_list)
				tmp179 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp180 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp181 := checkDerefVar(var_clojure_DOT_core_list)
				tmp182 := lang.Apply(tmp181, []any{sym_quote})
				tmp183 := checkDerefVar(var_clojure_DOT_core_list)
				tmp184 := lang.Apply(tmp183, []any{v9})
				tmp185 := lang.Apply(tmp180, []any{tmp182, tmp184})
				tmp186 := lang.Apply(tmp179, []any{tmp185})
				tmp187 := lang.Apply(tmp178, []any{tmp186})
				tmp188 := checkDerefVar(var_clojure_DOT_core_list)
				tmp189 := lang.Apply(tmp188, []any{kw_actual})
				tmp190 := checkDerefVar(var_clojure_DOT_core_list)
				tmp191 := lang.Apply(tmp190, []any{sym_e__0__auto__})
				tmp192 := lang.Apply(tmp167, []any{tmp169, tmp171, tmp173, tmp175, tmp177, tmp187, tmp189, tmp191})
				tmp193 := lang.Apply(tmp166, []any{tmp192})
				tmp194 := lang.Apply(tmp164, []any{tmp165, tmp193})
				tmp195 := lang.Apply(tmp163, []any{tmp194})
				tmp196 := lang.Apply(tmp160, []any{tmp162, tmp195})
				tmp197 := lang.Apply(tmp159, []any{tmp196})
				tmp198 := lang.Apply(tmp158, []any{tmp197})
				tmp199 := lang.Apply(tmp102, []any{tmp104, tmp116, tmp157, tmp198})
				tmp200 := lang.Apply(tmp101, []any{tmp199})
				tmp201 := lang.Apply(tmp100, []any{tmp200})
				tmp202 := lang.Apply(tmp76, []any{tmp78, tmp99, tmp201})
				tmp203 := lang.Apply(tmp75, []any{tmp202})
				tmp204 := lang.Apply(tmp74, []any{tmp203})
				tmp205 := checkDerefVar(var_clojure_DOT_core_list)
				tmp206 := lang.Apply(tmp205, []any{sym_e__0__auto__})
				tmp207 := lang.Apply(tmp67, []any{tmp69, tmp71, tmp73, tmp204, tmp206})
				tmp208 := lang.Apply(tmp66, []any{tmp207})
				tmp209 := lang.Apply(tmp65, []any{tmp208})
				tmp210 := lang.Apply(tmp21, []any{tmp23, v19, tmp64, tmp209})
				tmp211 := lang.Apply(tmp20, []any{tmp210})
				tmp10 = tmp211
			} // end let
			return tmp10
		})
		tmp1.AddMethod(sym_thrown_DASH_with_DASH_msg_QMARK_, tmp7)
		var_clojure_DOT_test_assert_DASH_expr = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_assert_DASH_expr.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert-predicate
	{
		tmp0 := sym_assert_DASH_predicate.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_msg, sym_form)), kw_doc, "Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_assert_DASH_predicate, kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(427), kw_end_DASH_line, int(427))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "args"
				tmp5 := checkDerefVar(var_clojure_DOT_core_rest)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				// let binding "pred"
				tmp8 := checkDerefVar(var_clojure_DOT_core_first)
				tmp9 := lang.Apply(tmp8, []any{v3})
				var v10 any = tmp9
				_ = v10
				tmp11 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_clojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_clojure_DOT_core_SLASH_let})
				tmp15 := checkDerefVar(var_clojure_DOT_core_list)
				tmp16 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp17 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp18 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp19 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp20 := checkDerefVar(var_clojure_DOT_core_list)
				tmp21 := lang.Apply(tmp20, []any{sym_values__0__auto__})
				tmp22 := checkDerefVar(var_clojure_DOT_core_list)
				tmp23 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp24 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp25 := checkDerefVar(var_clojure_DOT_core_list)
				tmp26 := lang.Apply(tmp25, []any{sym_clojure_DOT_core_SLASH_list})
				tmp27 := lang.Apply(tmp24, []any{tmp26, v7})
				tmp28 := lang.Apply(tmp23, []any{tmp27})
				tmp29 := lang.Apply(tmp22, []any{tmp28})
				tmp30 := checkDerefVar(var_clojure_DOT_core_list)
				tmp31 := lang.Apply(tmp30, []any{sym_result__1__auto__})
				tmp32 := checkDerefVar(var_clojure_DOT_core_list)
				tmp33 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp34 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp35 := checkDerefVar(var_clojure_DOT_core_list)
				tmp36 := lang.Apply(tmp35, []any{sym_clojure_DOT_core_SLASH_apply})
				tmp37 := checkDerefVar(var_clojure_DOT_core_list)
				tmp38 := lang.Apply(tmp37, []any{v10})
				tmp39 := checkDerefVar(var_clojure_DOT_core_list)
				tmp40 := lang.Apply(tmp39, []any{sym_values__0__auto__})
				tmp41 := lang.Apply(tmp34, []any{tmp36, tmp38, tmp40})
				tmp42 := lang.Apply(tmp33, []any{tmp41})
				tmp43 := lang.Apply(tmp32, []any{tmp42})
				tmp44 := lang.Apply(tmp19, []any{tmp21, tmp29, tmp31, tmp43})
				tmp45 := lang.Apply(tmp18, []any{tmp44})
				tmp46 := lang.Apply(tmp16, []any{tmp17, tmp45})
				tmp47 := lang.Apply(tmp15, []any{tmp46})
				tmp48 := checkDerefVar(var_clojure_DOT_core_list)
				tmp49 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp50 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp51 := checkDerefVar(var_clojure_DOT_core_list)
				tmp52 := lang.Apply(tmp51, []any{sym_if})
				tmp53 := checkDerefVar(var_clojure_DOT_core_list)
				tmp54 := lang.Apply(tmp53, []any{sym_result__1__auto__})
				tmp55 := checkDerefVar(var_clojure_DOT_core_list)
				tmp56 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp57 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp58 := checkDerefVar(var_clojure_DOT_core_list)
				tmp59 := lang.Apply(tmp58, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
				tmp60 := checkDerefVar(var_clojure_DOT_core_list)
				tmp61 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp62 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp63 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp64 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp65 := checkDerefVar(var_clojure_DOT_core_list)
				tmp66 := lang.Apply(tmp65, []any{kw_type})
				tmp67 := checkDerefVar(var_clojure_DOT_core_list)
				tmp68 := lang.Apply(tmp67, []any{kw_pass})
				tmp69 := checkDerefVar(var_clojure_DOT_core_list)
				tmp70 := lang.Apply(tmp69, []any{kw_message})
				tmp71 := checkDerefVar(var_clojure_DOT_core_list)
				tmp72 := lang.Apply(tmp71, []any{v2})
				tmp73 := checkDerefVar(var_clojure_DOT_core_list)
				tmp74 := lang.Apply(tmp73, []any{kw_expected})
				tmp75 := checkDerefVar(var_clojure_DOT_core_list)
				tmp76 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp77 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp78 := checkDerefVar(var_clojure_DOT_core_list)
				tmp79 := lang.Apply(tmp78, []any{sym_quote})
				tmp80 := checkDerefVar(var_clojure_DOT_core_list)
				tmp81 := lang.Apply(tmp80, []any{v3})
				tmp82 := lang.Apply(tmp77, []any{tmp79, tmp81})
				tmp83 := lang.Apply(tmp76, []any{tmp82})
				tmp84 := lang.Apply(tmp75, []any{tmp83})
				tmp85 := checkDerefVar(var_clojure_DOT_core_list)
				tmp86 := lang.Apply(tmp85, []any{kw_actual})
				tmp87 := checkDerefVar(var_clojure_DOT_core_list)
				tmp88 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp89 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp90 := checkDerefVar(var_clojure_DOT_core_list)
				tmp91 := lang.Apply(tmp90, []any{sym_clojure_DOT_core_SLASH_cons})
				tmp92 := checkDerefVar(var_clojure_DOT_core_list)
				tmp93 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp94 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp95 := checkDerefVar(var_clojure_DOT_core_list)
				tmp96 := lang.Apply(tmp95, []any{sym_quote})
				tmp97 := checkDerefVar(var_clojure_DOT_core_list)
				tmp98 := lang.Apply(tmp97, []any{v10})
				tmp99 := lang.Apply(tmp94, []any{tmp96, tmp98})
				tmp100 := lang.Apply(tmp93, []any{tmp99})
				tmp101 := lang.Apply(tmp92, []any{tmp100})
				tmp102 := checkDerefVar(var_clojure_DOT_core_list)
				tmp103 := lang.Apply(tmp102, []any{sym_values__0__auto__})
				tmp104 := lang.Apply(tmp89, []any{tmp91, tmp101, tmp103})
				tmp105 := lang.Apply(tmp88, []any{tmp104})
				tmp106 := lang.Apply(tmp87, []any{tmp105})
				tmp107 := lang.Apply(tmp64, []any{tmp66, tmp68, tmp70, tmp72, tmp74, tmp84, tmp86, tmp106})
				tmp108 := lang.Apply(tmp63, []any{tmp107})
				tmp109 := lang.Apply(tmp61, []any{tmp62, tmp108})
				tmp110 := lang.Apply(tmp60, []any{tmp109})
				tmp111 := lang.Apply(tmp57, []any{tmp59, tmp110})
				tmp112 := lang.Apply(tmp56, []any{tmp111})
				tmp113 := lang.Apply(tmp55, []any{tmp112})
				tmp114 := checkDerefVar(var_clojure_DOT_core_list)
				tmp115 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp116 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp117 := checkDerefVar(var_clojure_DOT_core_list)
				tmp118 := lang.Apply(tmp117, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
				tmp119 := checkDerefVar(var_clojure_DOT_core_list)
				tmp120 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp121 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp122 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp123 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp124 := checkDerefVar(var_clojure_DOT_core_list)
				tmp125 := lang.Apply(tmp124, []any{kw_type})
				tmp126 := checkDerefVar(var_clojure_DOT_core_list)
				tmp127 := lang.Apply(tmp126, []any{kw_fail})
				tmp128 := checkDerefVar(var_clojure_DOT_core_list)
				tmp129 := lang.Apply(tmp128, []any{kw_message})
				tmp130 := checkDerefVar(var_clojure_DOT_core_list)
				tmp131 := lang.Apply(tmp130, []any{v2})
				tmp132 := checkDerefVar(var_clojure_DOT_core_list)
				tmp133 := lang.Apply(tmp132, []any{kw_expected})
				tmp134 := checkDerefVar(var_clojure_DOT_core_list)
				tmp135 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp136 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp137 := checkDerefVar(var_clojure_DOT_core_list)
				tmp138 := lang.Apply(tmp137, []any{sym_quote})
				tmp139 := checkDerefVar(var_clojure_DOT_core_list)
				tmp140 := lang.Apply(tmp139, []any{v3})
				tmp141 := lang.Apply(tmp136, []any{tmp138, tmp140})
				tmp142 := lang.Apply(tmp135, []any{tmp141})
				tmp143 := lang.Apply(tmp134, []any{tmp142})
				tmp144 := checkDerefVar(var_clojure_DOT_core_list)
				tmp145 := lang.Apply(tmp144, []any{kw_actual})
				tmp146 := checkDerefVar(var_clojure_DOT_core_list)
				tmp147 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp148 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp149 := checkDerefVar(var_clojure_DOT_core_list)
				tmp150 := lang.Apply(tmp149, []any{sym_clojure_DOT_core_SLASH_list})
				tmp151 := checkDerefVar(var_clojure_DOT_core_list)
				tmp152 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp153 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp154 := checkDerefVar(var_clojure_DOT_core_list)
				tmp155 := lang.Apply(tmp154, []any{sym_quote})
				tmp156 := checkDerefVar(var_clojure_DOT_core_list)
				tmp157 := lang.Apply(tmp156, []any{sym_not})
				tmp158 := lang.Apply(tmp153, []any{tmp155, tmp157})
				tmp159 := lang.Apply(tmp152, []any{tmp158})
				tmp160 := lang.Apply(tmp151, []any{tmp159})
				tmp161 := checkDerefVar(var_clojure_DOT_core_list)
				tmp162 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp163 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp164 := checkDerefVar(var_clojure_DOT_core_list)
				tmp165 := lang.Apply(tmp164, []any{sym_clojure_DOT_core_SLASH_cons})
				tmp166 := checkDerefVar(var_clojure_DOT_core_list)
				tmp167 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp168 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp169 := checkDerefVar(var_clojure_DOT_core_list)
				tmp170 := lang.Apply(tmp169, []any{sym_quote})
				tmp171 := checkDerefVar(var_clojure_DOT_core_list)
				tmp172 := lang.Apply(tmp171, []any{v10})
				tmp173 := lang.Apply(tmp168, []any{tmp170, tmp172})
				tmp174 := lang.Apply(tmp167, []any{tmp173})
				tmp175 := lang.Apply(tmp166, []any{tmp174})
				tmp176 := checkDerefVar(var_clojure_DOT_core_list)
				tmp177 := lang.Apply(tmp176, []any{sym_values__0__auto__})
				tmp178 := lang.Apply(tmp163, []any{tmp165, tmp175, tmp177})
				tmp179 := lang.Apply(tmp162, []any{tmp178})
				tmp180 := lang.Apply(tmp161, []any{tmp179})
				tmp181 := lang.Apply(tmp148, []any{tmp150, tmp160, tmp180})
				tmp182 := lang.Apply(tmp147, []any{tmp181})
				tmp183 := lang.Apply(tmp146, []any{tmp182})
				tmp184 := lang.Apply(tmp123, []any{tmp125, tmp127, tmp129, tmp131, tmp133, tmp143, tmp145, tmp183})
				tmp185 := lang.Apply(tmp122, []any{tmp184})
				tmp186 := lang.Apply(tmp120, []any{tmp121, tmp185})
				tmp187 := lang.Apply(tmp119, []any{tmp186})
				tmp188 := lang.Apply(tmp116, []any{tmp118, tmp187})
				tmp189 := lang.Apply(tmp115, []any{tmp188})
				tmp190 := lang.Apply(tmp114, []any{tmp189})
				tmp191 := lang.Apply(tmp50, []any{tmp52, tmp54, tmp113, tmp190})
				tmp192 := lang.Apply(tmp49, []any{tmp191})
				tmp193 := lang.Apply(tmp48, []any{tmp192})
				tmp194 := checkDerefVar(var_clojure_DOT_core_list)
				tmp195 := lang.Apply(tmp194, []any{sym_result__1__auto__})
				tmp196 := lang.Apply(tmp12, []any{tmp14, tmp47, tmp193, tmp195})
				tmp197 := lang.Apply(tmp11, []any{tmp196})
				tmp4 = tmp197
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_assert_DASH_predicate = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_assert_DASH_predicate.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deftest
	{
		tmp0 := sym_deftest.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_body)), kw_doc, "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When *load-tests* is false, deftest is ignored.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_deftest, kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(613), kw_end_DASH_line, int(613))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_clojure_DOT_test__STAR_load_DASH_tests_STAR_)
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_clojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_def})
					tmp12 := checkDerefVar(var_clojure_DOT_core_list)
					tmp13 := checkDerefVar(var_clojure_DOT_core_vary_DASH_meta)
					tmp14 := checkDerefVar(var_clojure_DOT_core_assoc)
					tmp15 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_clojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_clojure_DOT_core_SLASH_fn})
					tmp19 := checkDerefVar(var_clojure_DOT_core_list)
					tmp20 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp21 := checkDerefVar(var_clojure_DOT_core_vector)
					tmp22 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp23 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp24 := lang.Apply(tmp23, nil)
					tmp25 := lang.Apply(tmp22, []any{tmp24})
					tmp26 := lang.Apply(tmp20, []any{tmp21, tmp25})
					tmp27 := lang.Apply(tmp19, []any{tmp26})
					tmp28 := lang.Apply(tmp16, []any{tmp18, tmp27, v5})
					tmp29 := lang.Apply(tmp15, []any{tmp28})
					tmp30 := lang.Apply(tmp13, []any{v4, tmp14, kw_test, tmp29})
					tmp31 := lang.Apply(tmp12, []any{tmp30})
					tmp32 := checkDerefVar(var_clojure_DOT_core_list)
					tmp33 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp34 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp35 := checkDerefVar(var_clojure_DOT_core_list)
					tmp36 := lang.Apply(tmp35, []any{sym_clojure_DOT_core_SLASH_fn})
					tmp37 := checkDerefVar(var_clojure_DOT_core_list)
					tmp38 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp39 := checkDerefVar(var_clojure_DOT_core_vector)
					tmp40 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp41 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp42 := lang.Apply(tmp41, nil)
					tmp43 := lang.Apply(tmp40, []any{tmp42})
					tmp44 := lang.Apply(tmp38, []any{tmp39, tmp43})
					tmp45 := lang.Apply(tmp37, []any{tmp44})
					tmp46 := checkDerefVar(var_clojure_DOT_core_list)
					tmp47 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp48 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp49 := checkDerefVar(var_clojure_DOT_core_list)
					tmp50 := lang.Apply(tmp49, []any{sym_clojure_DOT_test_SLASH_test_DASH_var})
					tmp51 := checkDerefVar(var_clojure_DOT_core_list)
					tmp52 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp53 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp54 := checkDerefVar(var_clojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{sym_var})
					tmp56 := checkDerefVar(var_clojure_DOT_core_list)
					tmp57 := lang.Apply(tmp56, []any{v4})
					tmp58 := lang.Apply(tmp53, []any{tmp55, tmp57})
					tmp59 := lang.Apply(tmp52, []any{tmp58})
					tmp60 := lang.Apply(tmp51, []any{tmp59})
					tmp61 := lang.Apply(tmp48, []any{tmp50, tmp60})
					tmp62 := lang.Apply(tmp47, []any{tmp61})
					tmp63 := lang.Apply(tmp46, []any{tmp62})
					tmp64 := lang.Apply(tmp34, []any{tmp36, tmp45, tmp63})
					tmp65 := lang.Apply(tmp33, []any{tmp64})
					tmp66 := lang.Apply(tmp32, []any{tmp65})
					tmp67 := lang.Apply(tmp9, []any{tmp11, tmp31, tmp66})
					tmp68 := lang.Apply(tmp8, []any{tmp67})
					tmp6 = tmp68
				} else {
				}
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_deftest = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_deftest.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deftest-
	{
		tmp0 := sym_deftest_DASH_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_body)), kw_doc, "Like deftest but creates a private var.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_deftest_DASH_, kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(630), kw_end_DASH_line, int(630))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_clojure_DOT_test__STAR_load_DASH_tests_STAR_)
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_clojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_def})
					tmp12 := checkDerefVar(var_clojure_DOT_core_list)
					tmp13 := checkDerefVar(var_clojure_DOT_core_vary_DASH_meta)
					tmp14 := checkDerefVar(var_clojure_DOT_core_assoc)
					tmp15 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_clojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_clojure_DOT_core_SLASH_fn})
					tmp19 := checkDerefVar(var_clojure_DOT_core_list)
					tmp20 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp21 := checkDerefVar(var_clojure_DOT_core_vector)
					tmp22 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp23 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp24 := lang.Apply(tmp23, nil)
					tmp25 := lang.Apply(tmp22, []any{tmp24})
					tmp26 := lang.Apply(tmp20, []any{tmp21, tmp25})
					tmp27 := lang.Apply(tmp19, []any{tmp26})
					tmp28 := lang.Apply(tmp16, []any{tmp18, tmp27, v5})
					tmp29 := lang.Apply(tmp15, []any{tmp28})
					tmp30 := lang.Apply(tmp13, []any{v4, tmp14, kw_test, tmp29, kw_private, true})
					tmp31 := lang.Apply(tmp12, []any{tmp30})
					tmp32 := checkDerefVar(var_clojure_DOT_core_list)
					tmp33 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp34 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp35 := checkDerefVar(var_clojure_DOT_core_list)
					tmp36 := lang.Apply(tmp35, []any{sym_clojure_DOT_core_SLASH_fn})
					tmp37 := checkDerefVar(var_clojure_DOT_core_list)
					tmp38 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp39 := checkDerefVar(var_clojure_DOT_core_vector)
					tmp40 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp41 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp42 := lang.Apply(tmp41, nil)
					tmp43 := lang.Apply(tmp40, []any{tmp42})
					tmp44 := lang.Apply(tmp38, []any{tmp39, tmp43})
					tmp45 := lang.Apply(tmp37, []any{tmp44})
					tmp46 := checkDerefVar(var_clojure_DOT_core_list)
					tmp47 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp48 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp49 := checkDerefVar(var_clojure_DOT_core_list)
					tmp50 := lang.Apply(tmp49, []any{sym_clojure_DOT_test_SLASH_test_DASH_var})
					tmp51 := checkDerefVar(var_clojure_DOT_core_list)
					tmp52 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp53 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp54 := checkDerefVar(var_clojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{sym_var})
					tmp56 := checkDerefVar(var_clojure_DOT_core_list)
					tmp57 := lang.Apply(tmp56, []any{v4})
					tmp58 := lang.Apply(tmp53, []any{tmp55, tmp57})
					tmp59 := lang.Apply(tmp52, []any{tmp58})
					tmp60 := lang.Apply(tmp51, []any{tmp59})
					tmp61 := lang.Apply(tmp48, []any{tmp50, tmp60})
					tmp62 := lang.Apply(tmp47, []any{tmp61})
					tmp63 := lang.Apply(tmp46, []any{tmp62})
					tmp64 := lang.Apply(tmp34, []any{tmp36, tmp45, tmp63})
					tmp65 := lang.Apply(tmp33, []any{tmp64})
					tmp66 := lang.Apply(tmp32, []any{tmp65})
					tmp67 := lang.Apply(tmp9, []any{tmp11, tmp31, tmp66})
					tmp68 := lang.Apply(tmp8, []any{tmp67})
					tmp6 = tmp68
				} else {
				}
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_deftest_DASH_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_deftest_DASH_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// do-report
	{
		tmp0 := sym_do_DASH_report.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m)), kw_doc, "Add file and line information to a test result and call report.\n   If you are writing a custom assert-expr method, call this function\n   to pass test results to report.", kw_file, "clojure/test.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_do_DASH_report, kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(350), kw_end_DASH_line, int(350))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_test_report)
			var tmp4 any
			{ // let
				// let binding "G__1069"
				tmp5 := lang.Apply(kw_type, []any{v2})
				var v6 any = tmp5
				_ = v6
				// case
				var tmp7 any
				var tmp8 int64
				tmp8 = int64(uint32(lang.IdentityHash(v6)>>2) & uint32(1))
				// case entry 0 (key=1, collision=false)
				if tmp8 == 1 {
					if v6 == kw_fail {
						tmp9 := checkDerefVar(var_clojure_DOT_core_merge)
						tmp10 := lang.NewMap()
						tmp11 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(359), kw_column, int(18), kw_end_DASH_line, int(359), kw_end_DASH_column, int(19))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp13 := lang.Apply(tmp9, []any{tmp12, v2})
						tmp7 = tmp13
					} else {
						tmp7 = v2
					}
					// case entry 1 (key=0, collision=false)
				} else if tmp8 == 0 {
					if v6 == kw_error {
						tmp14 := checkDerefVar(var_clojure_DOT_core_merge)
						tmp15 := lang.NewMap()
						tmp16 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(360), kw_column, int(19), kw_end_DASH_line, int(360), kw_end_DASH_column, int(20))
						tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp18 := lang.Apply(tmp14, []any{tmp17, v2})
						tmp7 = tmp18
					} else {
						tmp7 = v2
					}
				} else {
					tmp7 = v2
				}
				tmp4 = tmp7
			} // end let
			tmp5 := lang.Apply(tmp3, []any{tmp4})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_do_DASH_report = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_do_DASH_report.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// file-and-line
	{
		tmp0 := sym_file_DASH_and_DASH_line.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_exception, sym_depth)), kw_file, "clojure/test.glj", kw_deprecated, "1.8", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_file_DASH_and_DASH_line, kw_end_DASH_column, int(20), kw_column, int(8), kw_line, int(334), kw_end_DASH_line, int(334), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "stacktrace"
				tmp5, ok := lang.FieldOrMethod(v2, "getStackTrace")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "getStackTrace")))
				}
				var tmp6 any
				switch reflect.TypeOf(tmp5).Kind() {
				case reflect.Func:
					tmp6 = lang.Apply(tmp5, nil)
				default:
					tmp6 = tmp5
				}
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(var_clojure_DOT_core__LT_)
				tmp10 := checkDerefVar(var_clojure_DOT_core_count)
				tmp11 := lang.Apply(tmp10, []any{v7})
				tmp12 := lang.Apply(tmp9, []any{v3, tmp11})
				if lang.IsTruthy(tmp12) {
					var tmp13 any
					{ // let
						// let binding "s"
						tmp14 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp15 := lang.Apply(tmp14, []any{v7, v3})
						var v16 any = tmp15
						_ = v16
						tmp17, ok := lang.FieldOrMethod(v16, "getFileName")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v16, "getFileName")))
						}
						var tmp18 any
						switch reflect.TypeOf(tmp17).Kind() {
						case reflect.Func:
							tmp18 = lang.Apply(tmp17, nil)
						default:
							tmp18 = tmp17
						}
						tmp19, ok := lang.FieldOrMethod(v16, "getLineNumber")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v16, "getLineNumber")))
						}
						var tmp20 any
						switch reflect.TypeOf(tmp19).Kind() {
						case reflect.Func:
							tmp20 = lang.Apply(tmp19, nil)
						default:
							tmp20 = tmp19
						}
						tmp21 := lang.NewMap(kw_file, tmp18, kw_line, tmp20)
						tmp22 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(340), kw_column, int(9), kw_end_DASH_line, int(340), kw_end_DASH_column, int(57))
						tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp13 = tmp23
					} // end let
					tmp8 = tmp13
				} else {
					tmp14 := lang.NewMap(kw_file, nil, kw_line, nil)
					tmp15 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(341), kw_column, int(7), kw_end_DASH_line, int(341), kw_end_DASH_column, int(27))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp8 = tmp16
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_file_DASH_and_DASH_line = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_file_DASH_and_DASH_line.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// file-position
	{
		tmp0 := sym_file_DASH_position.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns a vector [filename line-number] for the nth call up the\n  stack.\n\n  Deprecated in 1.2: The information needed for test reporting is\n  now on :file and :line keys in the result map.", kw_file, "clojure/test.glj", kw_deprecated, "1.2", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_file_DASH_position, kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(281), kw_end_DASH_line, int(281))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "s"
				tmp4 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp5 := new(lang.Throwable)
				tmp6, ok := lang.FieldOrMethod(tmp5, "getStackTrace")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp5, "getStackTrace")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7, v2})
				var v9 any = tmp8
				_ = v9
				tmp10, ok := lang.FieldOrMethod(v9, "getFileName")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "getFileName")))
				}
				var tmp11 any
				switch reflect.TypeOf(tmp10).Kind() {
				case reflect.Func:
					tmp11 = lang.Apply(tmp10, nil)
				default:
					tmp11 = tmp10
				}
				tmp12, ok := lang.FieldOrMethod(v9, "getLineNumber")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "getLineNumber")))
				}
				var tmp13 any
				switch reflect.TypeOf(tmp12).Kind() {
				case reflect.Func:
					tmp13 = lang.Apply(tmp12, nil)
				default:
					tmp13 = tmp12
				}
				tmp14 := lang.NewVector(tmp11, tmp13)
				tmp15 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(291), kw_column, int(5), kw_end_DASH_line, int(291), kw_end_DASH_column, int(41))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp3 = tmp16
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_file_DASH_position = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_file_DASH_position.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// function?
	{
		tmp0 := sym_function_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_function_QMARK_, kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(415), kw_end_DASH_line, int(415))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_clojure_DOT_core_symbol_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				var tmp6 any
				{ // let
					// let binding "temp__0__auto__"
					tmp7 := checkDerefVar(var_clojure_DOT_core_resolve)
					tmp8 := lang.Apply(tmp7, []any{v2})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						var tmp11 any
						{ // let
							// let binding "v"
							var v12 any = v9
							_ = v12
							var tmp13 any
							{ // let
								// let binding "temp__0__auto__"
								tmp14 := checkDerefVar(var_clojure_DOT_test_get_DASH_possibly_DASH_unbound_DASH_var)
								tmp15 := lang.Apply(tmp14, []any{v12})
								var v16 any = tmp15
								_ = v16
								var tmp17 any
								if lang.IsTruthy(v16) {
									var tmp18 any
									{ // let
										// let binding "value"
										var v19 any = v16
										_ = v19
										var tmp20 any
										{ // let
											// let binding "and__0__auto__"
											tmp21 := checkDerefVar(var_clojure_DOT_core_fn_QMARK_)
											tmp22 := lang.Apply(tmp21, []any{v19})
											var v23 any = tmp22
											_ = v23
											var tmp24 any
											if lang.IsTruthy(v23) {
												tmp25 := checkDerefVar(var_clojure_DOT_core_not)
												tmp26 := checkDerefVar(var_clojure_DOT_core_meta)
												tmp27 := lang.Apply(tmp26, []any{v12})
												tmp28 := lang.Apply(kw_macro, []any{tmp27})
												tmp29 := lang.Apply(tmp25, []any{tmp28})
												tmp24 = tmp29
											} else {
												tmp24 = v23
											}
											tmp20 = tmp24
										} // end let
										tmp18 = tmp20
									} // end let
									tmp17 = tmp18
								} else {
								}
								tmp13 = tmp17
							} // end let
							tmp11 = tmp13
						} // end let
						tmp10 = tmp11
					} else {
					}
					tmp6 = tmp10
				} // end let
				tmp3 = tmp6
			} else {
				tmp7 := checkDerefVar(var_clojure_DOT_core_fn_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v2})
				tmp3 = tmp8
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_function_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_function_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-possibly-unbound-var
	{
		tmp0 := sym_get_DASH_possibly_DASH_unbound_DASH_var.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_v)), kw_doc, "Like var-get but returns nil if the var is unbound.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_get_DASH_possibly_DASH_unbound_DASH_var, kw_end_DASH_column, int(30), kw_column, int(7), kw_line, int(408), kw_end_DASH_line, int(408))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						if lang.CatchMatches(r, lang.IllegalStateException) {
							v4 := r
							_ = v4
						} else {
							panic(r)
						}
					}
				}()
				tmp4 := checkDerefVar(var_clojure_DOT_core_var_DASH_get)
				tmp5 := lang.Apply(tmp4, []any{v2})
				tmp3 = tmp5
			}()
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_get_DASH_possibly_DASH_unbound_DASH_var = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_get_DASH_possibly_DASH_unbound_DASH_var.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inc-report-counter
	{
		tmp0 := sym_inc_DASH_report_DASH_counter.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_name)), kw_doc, "Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_inc_DASH_report_DASH_counter, kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(313), kw_end_DASH_line, int(313))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_clojure_DOT_test__STAR_report_DASH_counters_STAR_)
			if lang.IsTruthy(tmp4) {
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					tmp6 := checkDerefVar(var_clojure_DOT_core_commute)
					tmp7 := checkDerefVar(var_clojure_DOT_test__STAR_report_DASH_counters_STAR_)
					tmp8 := checkDerefVar(var_clojure_DOT_core_update_DASH_in)
					tmp9 := lang.NewVector(v2)
					tmp10 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(319), kw_column, int(50), kw_end_DASH_line, int(319), kw_end_DASH_column, int(55))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 := checkDerefVar(var_clojure_DOT_core_fnil)
					tmp13 := checkDerefVar(var_clojure_DOT_core_inc)
					tmp14 := lang.Apply(tmp12, []any{tmp13, int64(0)})
					tmp15 := lang.Apply(tmp6, []any{tmp7, tmp8, tmp11, tmp14})
					return tmp15
				})
				tmp6, _ := lang.FieldOrMethod(lang.LockingTransaction, "RunInTransaction")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("RunInTransaction is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{tmp5})
				tmp3 = tmp7
			} else {
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_inc_DASH_report_DASH_counter = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_inc_DASH_report_DASH_counter.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// is
	{
		tmp0 := sym_is.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_form), lang.NewVector(sym_form, sym_msg)), kw_doc, "Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_is, kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(545), kw_end_DASH_line, int(545))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_clojure_DOT_test_SLASH_is})
				tmp9 := checkDerefVar(var_clojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{v4})
				tmp11 := checkDerefVar(var_clojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{nil})
				tmp13 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp12})
				tmp14 := lang.Apply(tmp5, []any{tmp13})
				return tmp14
			case 4:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				v5 := args[3]
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_clojure_DOT_test_SLASH_try_DASH_expr})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{v5})
				tmp12 := checkDerefVar(var_clojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v4})
				tmp14 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp6, []any{tmp14})
				return tmp15
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_is = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_is.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// join-fixtures
	{
		tmp0 := sym_join_DASH_fixtures.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_fixtures)), kw_doc, "Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_join_DASH_fixtures, kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(687), kw_end_DASH_line, int(687))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_reduce)
			tmp4 := checkDerefVar(var_clojure_DOT_test_compose_DASH_fixtures)
			tmp5 := checkDerefVar(var_clojure_DOT_test_default_DASH_fixture)
			tmp6 := lang.Apply(tmp3, []any{tmp4, tmp5, v2})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_join_DASH_fixtures = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_join_DASH_fixtures.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// report
	{
		tmp0 := sym_report.WithMeta(lang.NewMap(kw_doc, "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.  See the documentation at\n   the top of test_is.clj for more information on the types of\n   arguments for 'report'.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_report, kw_end_DASH_column, int(8), kw_column, int(3), kw_line, int(324), kw_end_DASH_line, int(332), kw_dynamic, true)).(*lang.Symbol)
		// MultiFn report
		tmp1 := lang.NewMultiFn("report", kw_type, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				tmp5 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp6 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp7 := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_out_STAR_)
				var tmp8 any
				{ // let
					// let binding "or__0__auto__"
					tmp9 := checkDerefVar(var_clojure_DOT_test__STAR_test_DASH_out_STAR_)
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						tmp11 = v10
					} else {
						tmp12 := checkDerefVar(var_clojure_DOT_core__STAR_out_STAR_)
						tmp11 = tmp12
					}
					tmp8 = tmp11
				} // end let
				tmp9 := lang.Apply(tmp6, []any{tmp7, tmp8})
				tmp10 := lang.Apply(tmp5, []any{tmp9})
				_ = tmp10
				var tmp11 any
				func() {
					defer func() {
						tmp12 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp13 := lang.Apply(tmp12, nil)
						_ = tmp13
					}()
					tmp14 := checkDerefVar(var_clojure_DOT_test_inc_DASH_report_DASH_counter)
					tmp15 := lang.Apply(tmp14, []any{kw_error})
					_ = tmp15
					tmp16 := checkDerefVar(var_clojure_DOT_core_println)
					tmp17 := checkDerefVar(var_clojure_DOT_test_testing_DASH_vars_DASH_str)
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.Apply(tmp16, []any{"\nERROR in", tmp18})
					_ = tmp19
					var tmp20 any
					tmp21 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp22 := checkDerefVar(var_clojure_DOT_test__STAR_testing_DASH_contexts_STAR_)
					tmp23 := lang.Apply(tmp21, []any{tmp22})
					if lang.IsTruthy(tmp23) {
						tmp24 := checkDerefVar(var_clojure_DOT_core_println)
						tmp25 := checkDerefVar(var_clojure_DOT_test_testing_DASH_contexts_DASH_str)
						tmp26 := lang.Apply(tmp25, nil)
						tmp27 := lang.Apply(tmp24, []any{tmp26})
						tmp20 = tmp27
					} else {
					}
					_ = tmp20
					var tmp28 any
					{ // let
						// let binding "temp__0__auto__"
						tmp29 := lang.Apply(kw_message, []any{v3})
						var v30 any = tmp29
						_ = v30
						var tmp31 any
						if lang.IsTruthy(v30) {
							var tmp32 any
							{ // let
								// let binding "message"
								var v33 any = v30
								_ = v33
								tmp34 := checkDerefVar(var_clojure_DOT_core_println)
								tmp35 := lang.Apply(tmp34, []any{v33})
								tmp32 = tmp35
							} // end let
							tmp31 = tmp32
						} else {
						}
						tmp28 = tmp31
					} // end let
					_ = tmp28
					tmp29 := checkDerefVar(var_clojure_DOT_core_println)
					tmp30 := checkDerefVar(var_clojure_DOT_core_pr_DASH_str)
					tmp31 := lang.Apply(kw_expected, []any{v3})
					tmp32 := lang.Apply(tmp30, []any{tmp31})
					tmp33 := lang.Apply(tmp29, []any{"expected:", tmp32})
					_ = tmp33
					tmp34 := checkDerefVar(var_clojure_DOT_core_print)
					tmp35 := lang.Apply(tmp34, []any{"  actual: "})
					_ = tmp35
					var tmp36 any
					{ // let
						// let binding "actual"
						tmp37 := lang.Apply(kw_actual, []any{v3})
						var v38 any = tmp37
						_ = v38
						var tmp39 any
						tmp40 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
						tmp41 := lang.Apply(tmp40, []any{lang.Builtins["error"], v38})
						if lang.IsTruthy(tmp41) {
							tmp42 := checkDerefVar(var_clojure_DOT_core_prn)
							tmp43, ok := lang.FieldOrMethod(v38, "Error")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v38, "Error")))
							}
							var tmp44 any
							switch reflect.TypeOf(tmp43).Kind() {
							case reflect.Func:
								tmp44 = lang.Apply(tmp43, nil)
							default:
								tmp44 = tmp43
							}
							tmp45 := lang.Apply(tmp42, []any{tmp44})
							tmp39 = tmp45
						} else {
							tmp46 := checkDerefVar(var_clojure_DOT_core_prn)
							tmp47 := lang.Apply(tmp46, []any{v38})
							tmp39 = tmp47
						}
						tmp36 = tmp39
					} // end let
					tmp11 = tmp36
				}()
				tmp4 = tmp11
			} // end let
			return tmp4
		})
		tmp1.AddMethod(kw_error, tmp2)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			var tmp5 any
			{ // let
				tmp6 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp7 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp8 := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_out_STAR_)
				var tmp9 any
				{ // let
					// let binding "or__0__auto__"
					tmp10 := checkDerefVar(var_clojure_DOT_test__STAR_test_DASH_out_STAR_)
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						tmp12 = v11
					} else {
						tmp13 := checkDerefVar(var_clojure_DOT_core__STAR_out_STAR_)
						tmp12 = tmp13
					}
					tmp9 = tmp12
				} // end let
				tmp10 := lang.Apply(tmp7, []any{tmp8, tmp9})
				tmp11 := lang.Apply(tmp6, []any{tmp10})
				_ = tmp11
				var tmp12 any
				func() {
					defer func() {
						tmp13 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp14 := lang.Apply(tmp13, nil)
						_ = tmp14
					}()
					tmp15 := checkDerefVar(var_clojure_DOT_core_println)
					tmp16 := lang.Apply(kw_test, []any{v4})
					tmp17 := checkDerefVar(var_clojure_DOT_core__PLUS_)
					tmp18 := lang.Apply(kw_pass, []any{v4})
					tmp19 := lang.Apply(kw_fail, []any{v4})
					tmp20 := lang.Apply(kw_error, []any{v4})
					tmp21 := lang.Apply(tmp17, []any{tmp18, tmp19, tmp20})
					tmp22 := lang.Apply(tmp15, []any{"\nRan", tmp16, "tests containing", tmp21, "assertions."})
					_ = tmp22
					tmp23 := checkDerefVar(var_clojure_DOT_core_println)
					tmp24 := lang.Apply(kw_fail, []any{v4})
					tmp25 := lang.Apply(kw_error, []any{v4})
					tmp26 := lang.Apply(tmp23, []any{tmp24, "failures,", tmp25, "errors."})
					tmp12 = tmp26
				}()
				tmp5 = tmp12
			} // end let
			return tmp5
		})
		tmp1.AddMethod(kw_summary, tmp3)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v5 := args[0]
			_ = v5
			var tmp6 any
			{ // let
				tmp7 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp8 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp9 := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_out_STAR_)
				var tmp10 any
				{ // let
					// let binding "or__0__auto__"
					tmp11 := checkDerefVar(var_clojure_DOT_test__STAR_test_DASH_out_STAR_)
					var v12 any = tmp11
					_ = v12
					var tmp13 any
					if lang.IsTruthy(v12) {
						tmp13 = v12
					} else {
						tmp14 := checkDerefVar(var_clojure_DOT_core__STAR_out_STAR_)
						tmp13 = tmp14
					}
					tmp10 = tmp13
				} // end let
				tmp11 := lang.Apply(tmp8, []any{tmp9, tmp10})
				tmp12 := lang.Apply(tmp7, []any{tmp11})
				_ = tmp12
				var tmp13 any
				func() {
					defer func() {
						tmp14 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp15 := lang.Apply(tmp14, nil)
						_ = tmp15
					}()
					tmp16 := checkDerefVar(var_clojure_DOT_core_println)
					tmp17 := checkDerefVar(var_clojure_DOT_core_ns_DASH_name)
					tmp18 := lang.Apply(kw_ns, []any{v5})
					tmp19 := lang.Apply(tmp17, []any{tmp18})
					tmp20 := lang.Apply(tmp16, []any{"\nTesting", tmp19})
					tmp13 = tmp20
				}()
				tmp6 = tmp13
			} // end let
			return tmp6
		})
		tmp1.AddMethod(kw_begin_DASH_test_DASH_ns, tmp4)
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v6 := args[0]
			_ = v6
			var tmp7 any
			{ // let
				tmp8 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp9 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp10 := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_out_STAR_)
				var tmp11 any
				{ // let
					// let binding "or__0__auto__"
					tmp12 := checkDerefVar(var_clojure_DOT_test__STAR_test_DASH_out_STAR_)
					var v13 any = tmp12
					_ = v13
					var tmp14 any
					if lang.IsTruthy(v13) {
						tmp14 = v13
					} else {
						tmp15 := checkDerefVar(var_clojure_DOT_core__STAR_out_STAR_)
						tmp14 = tmp15
					}
					tmp11 = tmp14
				} // end let
				tmp12 := lang.Apply(tmp9, []any{tmp10, tmp11})
				tmp13 := lang.Apply(tmp8, []any{tmp12})
				_ = tmp13
				var tmp14 any
				func() {
					defer func() {
						tmp15 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp16 := lang.Apply(tmp15, nil)
						_ = tmp16
					}()
					tmp17 := checkDerefVar(var_clojure_DOT_test_inc_DASH_report_DASH_counter)
					tmp18 := lang.Apply(tmp17, []any{kw_pass})
					tmp14 = tmp18
				}()
				tmp7 = tmp14
			} // end let
			return tmp7
		})
		tmp1.AddMethod(kw_pass, tmp5)
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v7 := args[0]
			_ = v7
			return nil
		})
		tmp1.AddMethod(kw_end_DASH_test_DASH_var, tmp6)
		var tmp7 lang.FnFunc
		tmp7 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v8 := args[0]
			_ = v8
			var tmp9 any
			{ // let
				tmp10 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp11 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp12 := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_out_STAR_)
				var tmp13 any
				{ // let
					// let binding "or__0__auto__"
					tmp14 := checkDerefVar(var_clojure_DOT_test__STAR_test_DASH_out_STAR_)
					var v15 any = tmp14
					_ = v15
					var tmp16 any
					if lang.IsTruthy(v15) {
						tmp16 = v15
					} else {
						tmp17 := checkDerefVar(var_clojure_DOT_core__STAR_out_STAR_)
						tmp16 = tmp17
					}
					tmp13 = tmp16
				} // end let
				tmp14 := lang.Apply(tmp11, []any{tmp12, tmp13})
				tmp15 := lang.Apply(tmp10, []any{tmp14})
				_ = tmp15
				var tmp16 any
				func() {
					defer func() {
						tmp17 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp18 := lang.Apply(tmp17, nil)
						_ = tmp18
					}()
					tmp19 := checkDerefVar(var_clojure_DOT_core_prn)
					tmp20 := lang.Apply(tmp19, []any{v8})
					tmp16 = tmp20
				}()
				tmp9 = tmp16
			} // end let
			return tmp9
		})
		tmp1.AddMethod(kw_default, tmp7)
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v9 := args[0]
			_ = v9
			return nil
		})
		tmp1.AddMethod(kw_end_DASH_test_DASH_ns, tmp8)
		var tmp9 lang.FnFunc
		tmp9 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v10 := args[0]
			_ = v10
			return nil
		})
		tmp1.AddMethod(kw_begin_DASH_test_DASH_var, tmp9)
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v11 := args[0]
			_ = v11
			var tmp12 any
			{ // let
				tmp13 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp14 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp15 := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_out_STAR_)
				var tmp16 any
				{ // let
					// let binding "or__0__auto__"
					tmp17 := checkDerefVar(var_clojure_DOT_test__STAR_test_DASH_out_STAR_)
					var v18 any = tmp17
					_ = v18
					var tmp19 any
					if lang.IsTruthy(v18) {
						tmp19 = v18
					} else {
						tmp20 := checkDerefVar(var_clojure_DOT_core__STAR_out_STAR_)
						tmp19 = tmp20
					}
					tmp16 = tmp19
				} // end let
				tmp17 := lang.Apply(tmp14, []any{tmp15, tmp16})
				tmp18 := lang.Apply(tmp13, []any{tmp17})
				_ = tmp18
				var tmp19 any
				func() {
					defer func() {
						tmp20 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp21 := lang.Apply(tmp20, nil)
						_ = tmp21
					}()
					tmp22 := checkDerefVar(var_clojure_DOT_test_inc_DASH_report_DASH_counter)
					tmp23 := lang.Apply(tmp22, []any{kw_fail})
					_ = tmp23
					tmp24 := checkDerefVar(var_clojure_DOT_core_println)
					tmp25 := checkDerefVar(var_clojure_DOT_test_testing_DASH_vars_DASH_str)
					tmp26 := lang.Apply(tmp25, []any{v11})
					tmp27 := lang.Apply(tmp24, []any{"\nFAIL in", tmp26})
					_ = tmp27
					var tmp28 any
					tmp29 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp30 := checkDerefVar(var_clojure_DOT_test__STAR_testing_DASH_contexts_STAR_)
					tmp31 := lang.Apply(tmp29, []any{tmp30})
					if lang.IsTruthy(tmp31) {
						tmp32 := checkDerefVar(var_clojure_DOT_core_println)
						tmp33 := checkDerefVar(var_clojure_DOT_test_testing_DASH_contexts_DASH_str)
						tmp34 := lang.Apply(tmp33, nil)
						tmp35 := lang.Apply(tmp32, []any{tmp34})
						tmp28 = tmp35
					} else {
					}
					_ = tmp28
					var tmp36 any
					{ // let
						// let binding "temp__0__auto__"
						tmp37 := lang.Apply(kw_message, []any{v11})
						var v38 any = tmp37
						_ = v38
						var tmp39 any
						if lang.IsTruthy(v38) {
							var tmp40 any
							{ // let
								// let binding "message"
								var v41 any = v38
								_ = v41
								tmp42 := checkDerefVar(var_clojure_DOT_core_println)
								tmp43 := lang.Apply(tmp42, []any{v41})
								tmp40 = tmp43
							} // end let
							tmp39 = tmp40
						} else {
						}
						tmp36 = tmp39
					} // end let
					_ = tmp36
					tmp37 := checkDerefVar(var_clojure_DOT_core_println)
					tmp38 := checkDerefVar(var_clojure_DOT_core_pr_DASH_str)
					tmp39 := lang.Apply(kw_expected, []any{v11})
					tmp40 := lang.Apply(tmp38, []any{tmp39})
					tmp41 := lang.Apply(tmp37, []any{"expected:", tmp40})
					_ = tmp41
					tmp42 := checkDerefVar(var_clojure_DOT_core_println)
					tmp43 := checkDerefVar(var_clojure_DOT_core_pr_DASH_str)
					tmp44 := lang.Apply(kw_actual, []any{v11})
					tmp45 := lang.Apply(tmp43, []any{tmp44})
					tmp46 := lang.Apply(tmp42, []any{"  actual:", tmp45})
					tmp19 = tmp46
				}()
				tmp12 = tmp19
			} // end let
			return tmp12
		})
		tmp1.AddMethod(kw_fail, tmp10)
		var_clojure_DOT_test_report = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_report.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_clojure_DOT_test_report.SetDynamic()
	}
	// run-all-tests
	{
		tmp0 := sym_run_DASH_all_DASH_tests.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_re)), kw_doc, "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_run_DASH_all_DASH_tests, kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(771), kw_end_DASH_line, int(771))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp3 := checkDerefVar(var_clojure_DOT_test_run_DASH_tests)
				tmp4 := checkDerefVar(var_clojure_DOT_core_all_DASH_ns)
				tmp5 := lang.Apply(tmp4, nil)
				tmp6 := lang.Apply(tmp2, []any{tmp3, tmp5})
				return tmp6
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp4 := checkDerefVar(var_clojure_DOT_test_run_DASH_tests)
				tmp5 := checkDerefVar(var_clojure_DOT_core_filter)
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v7 := args[0]
					_ = v7
					tmp8 := checkDerefVar(var_clojure_DOT_core_re_DASH_matches)
					tmp9 := checkDerefVar(var_clojure_DOT_core_name)
					tmp10 := checkDerefVar(var_clojure_DOT_core_ns_DASH_name)
					tmp11 := lang.Apply(tmp10, []any{v7})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					tmp13 := lang.Apply(tmp8, []any{v2, tmp12})
					return tmp13
				})
				tmp7 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(778), kw_column, int(34), kw_end_DASH_line, int(778), kw_end_DASH_column, int(68))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := checkDerefVar(var_clojure_DOT_core_all_DASH_ns)
				tmp10 := lang.Apply(tmp9, nil)
				tmp11 := lang.Apply(tmp5, []any{tmp8, tmp10})
				tmp12 := lang.Apply(tmp3, []any{tmp4, tmp11})
				return tmp12
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_run_DASH_all_DASH_tests = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_run_DASH_all_DASH_tests.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// run-test
	{
		tmp0 := sym_run_DASH_test.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_test_DASH_symbol)), kw_doc, "Runs a single test.\n\n  Because the intent is to run a single test, there is no check for the namespace test-ns-hook.", kw_file, "clojure/test.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_run_DASH_test, kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(804), kw_end_DASH_line, int(804))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "test-var"
				tmp6 := checkDerefVar(var_clojure_DOT_core_resolve)
				tmp7 := lang.Apply(tmp6, []any{v4})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				tmp10 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
				tmp11 := lang.Apply(tmp10, []any{v8})
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					{ // let
						tmp13 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp14 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
						tmp15 := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_out_STAR_)
						tmp16 := checkDerefVar(var_clojure_DOT_core__STAR_err_STAR_)
						tmp17 := lang.Apply(tmp14, []any{tmp15, tmp16})
						tmp18 := lang.Apply(tmp13, []any{tmp17})
						_ = tmp18
						var tmp19 any
						func() {
							defer func() {
								tmp20 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp21 := lang.Apply(tmp20, nil)
								_ = tmp21
							}()
							tmp22 := checkDerefVar(var_clojure_DOT_core_println)
							tmp23 := lang.Apply(tmp22, []any{"Unable to resolve", v4, "to a test function."})
							tmp19 = tmp23
						}()
						tmp12 = tmp19
					} // end let
					tmp9 = tmp12
				} else {
					var tmp13 any
					tmp14 := checkDerefVar(var_clojure_DOT_core_not)
					tmp15 := checkDerefVar(var_clojure_DOT_core_meta)
					tmp16 := lang.Apply(tmp15, []any{v8})
					tmp17 := lang.Apply(kw_test, []any{tmp16})
					tmp18 := lang.Apply(tmp14, []any{tmp17})
					if lang.IsTruthy(tmp18) {
						var tmp19 any
						{ // let
							tmp20 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
							tmp21 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
							tmp22 := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_out_STAR_)
							tmp23 := checkDerefVar(var_clojure_DOT_core__STAR_err_STAR_)
							tmp24 := lang.Apply(tmp21, []any{tmp22, tmp23})
							tmp25 := lang.Apply(tmp20, []any{tmp24})
							_ = tmp25
							var tmp26 any
							func() {
								defer func() {
									tmp27 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
									tmp28 := lang.Apply(tmp27, nil)
									_ = tmp28
								}()
								tmp29 := checkDerefVar(var_clojure_DOT_core_println)
								tmp30 := lang.Apply(tmp29, []any{v4, "is not a test."})
								tmp26 = tmp30
							}()
							tmp19 = tmp26
						} // end let
						tmp13 = tmp19
					} else {
						var tmp20 any
						if lang.IsTruthy(kw_else) {
							tmp21 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp22 := checkDerefVar(var_clojure_DOT_core_concat)
							tmp23 := checkDerefVar(var_clojure_DOT_core_list)
							tmp24 := lang.Apply(tmp23, []any{sym_clojure_DOT_test_SLASH_run_DASH_test_DASH_var})
							tmp25 := checkDerefVar(var_clojure_DOT_core_list)
							tmp26 := lang.Apply(tmp25, []any{v8})
							tmp27 := lang.Apply(tmp22, []any{tmp24, tmp26})
							tmp28 := lang.Apply(tmp21, []any{tmp27})
							tmp20 = tmp28
						} else {
						}
						tmp13 = tmp20
					}
					tmp9 = tmp13
				}
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_run_DASH_test = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_run_DASH_test.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// run-test-var
	{
		tmp0 := sym_run_DASH_test_DASH_var.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_v)), kw_doc, "Runs the tests for a single Var, with fixtures executed around the test, and summary output after.", kw_file, "clojure/test.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_run_DASH_test_DASH_var, kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(788), kw_end_DASH_line, int(788))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				tmp4 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp5 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp6 := lang.InternVarName(sym_clojure_DOT_test, sym__STAR_report_DASH_counters_STAR_)
				tmp7 := checkDerefVar(var_clojure_DOT_core_ref)
				tmp8 := checkDerefVar(var_clojure_DOT_test__STAR_initial_DASH_report_DASH_counters_STAR_)
				tmp9 := lang.Apply(tmp7, []any{tmp8})
				tmp10 := lang.Apply(tmp5, []any{tmp6, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				_ = tmp11
				var tmp12 any
				func() {
					defer func() {
						tmp13 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp14 := lang.Apply(tmp13, nil)
						_ = tmp14
					}()
					var tmp15 any
					{ // let
						// let binding "ns-obj"
						tmp16 := checkDerefVar(var_clojure_DOT_core_meta)
						tmp17 := lang.Apply(tmp16, []any{v2})
						tmp18 := lang.Apply(kw_ns, []any{tmp17})
						var v19 any = tmp18
						_ = v19
						// let binding "summary"
						tmp20 := checkDerefVar(var_clojure_DOT_test_do_DASH_report)
						tmp21 := lang.NewMap(kw_type, kw_begin_DASH_test_DASH_ns, kw_ns, v19)
						tmp22 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(795), kw_column, int(32), kw_end_DASH_line, int(796), kw_end_DASH_column, int(45))
						tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp24 := lang.Apply(tmp20, []any{tmp23})
						_ = tmp24
						tmp25 := checkDerefVar(var_clojure_DOT_test_test_DASH_vars)
						tmp26 := lang.NewVector(v2)
						tmp27 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(797), kw_column, int(32), kw_end_DASH_line, int(797), kw_end_DASH_column, int(34))
						tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp29 := lang.Apply(tmp25, []any{tmp28})
						_ = tmp29
						tmp30 := checkDerefVar(var_clojure_DOT_test_do_DASH_report)
						tmp31 := lang.NewMap(kw_type, kw_end_DASH_test_DASH_ns, kw_ns, v19)
						tmp32 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(798), kw_column, int(32), kw_end_DASH_line, int(799), kw_end_DASH_column, int(45))
						tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp34 := lang.Apply(tmp30, []any{tmp33})
						_ = tmp34
						tmp35 := checkDerefVar(var_clojure_DOT_core_assoc)
						tmp36 := checkDerefVar(var_clojure_DOT_core_deref)
						tmp37 := checkDerefVar(var_clojure_DOT_test__STAR_report_DASH_counters_STAR_)
						tmp38 := lang.Apply(tmp36, []any{tmp37})
						tmp39 := lang.Apply(tmp35, []any{tmp38, kw_type, kw_summary})
						var v40 any = tmp39
						_ = v40
						tmp41 := checkDerefVar(var_clojure_DOT_test_do_DASH_report)
						tmp42 := lang.Apply(tmp41, []any{v40})
						_ = tmp42
						tmp15 = v40
					} // end let
					tmp12 = tmp15
				}()
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_run_DASH_test_DASH_var = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_run_DASH_test_DASH_var.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// run-tests
	{
		tmp0 := sym_run_DASH_tests.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym__AMP_, sym_namespaces)), kw_doc, "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given.  Returns a map\n  summarizing test results.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_run_DASH_tests, kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(759), kw_end_DASH_line, int(759))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_clojure_DOT_test_run_DASH_tests)
				tmp3 := checkDerefVar(var_clojure_DOT_core__STAR_ns_STAR_)
				tmp4 := lang.Apply(tmp2, []any{tmp3})
				return tmp4
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				var tmp3 any
				{ // let
					// let binding "summary"
					tmp4 := checkDerefVar(var_clojure_DOT_core_assoc)
					tmp5 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp6 := checkDerefVar(var_clojure_DOT_core_merge_DASH_with)
					tmp7 := checkDerefVar(var_clojure_DOT_core__PLUS_)
					tmp8 := checkDerefVar(var_clojure_DOT_core_map)
					tmp9 := checkDerefVar(var_clojure_DOT_test_test_DASH_ns)
					tmp10 := lang.Apply(tmp8, []any{tmp9, v2})
					tmp11 := lang.Apply(tmp5, []any{tmp6, tmp7, tmp10})
					tmp12 := lang.Apply(tmp4, []any{tmp11, kw_type, kw_summary})
					var v13 any = tmp12
					_ = v13
					tmp14 := checkDerefVar(var_clojure_DOT_test_do_DASH_report)
					tmp15 := lang.Apply(tmp14, []any{v13})
					_ = tmp15
					tmp3 = v13
				} // end let
				return tmp3
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_run_DASH_tests = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_run_DASH_tests.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-test
	{
		tmp0 := sym_set_DASH_test.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_body)), kw_doc, "Experimental.\n  Sets :test metadata of the named var to a fn with the given body.\n  The var must already exist.  Does not modify the value of the var.\n\n  When *load-tests* is false, set-test is ignored.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_set_DASH_test, kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(639), kw_end_DASH_line, int(639))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_clojure_DOT_test__STAR_load_DASH_tests_STAR_)
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_clojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_clojure_DOT_core_SLASH_alter_DASH_meta_BANG_})
					tmp12 := checkDerefVar(var_clojure_DOT_core_list)
					tmp13 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_clojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_var})
					tmp17 := checkDerefVar(var_clojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v4})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := checkDerefVar(var_clojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{sym_clojure_DOT_core_SLASH_assoc})
					tmp24 := checkDerefVar(var_clojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{kw_test})
					tmp26 := checkDerefVar(var_clojure_DOT_core_list)
					tmp27 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp28 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp29 := checkDerefVar(var_clojure_DOT_core_list)
					tmp30 := lang.Apply(tmp29, []any{sym_clojure_DOT_core_SLASH_fn})
					tmp31 := checkDerefVar(var_clojure_DOT_core_list)
					tmp32 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp33 := checkDerefVar(var_clojure_DOT_core_vector)
					tmp34 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp35 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp36 := lang.Apply(tmp35, nil)
					tmp37 := lang.Apply(tmp34, []any{tmp36})
					tmp38 := lang.Apply(tmp32, []any{tmp33, tmp37})
					tmp39 := lang.Apply(tmp31, []any{tmp38})
					tmp40 := lang.Apply(tmp28, []any{tmp30, tmp39, v5})
					tmp41 := lang.Apply(tmp27, []any{tmp40})
					tmp42 := lang.Apply(tmp26, []any{tmp41})
					tmp43 := lang.Apply(tmp9, []any{tmp11, tmp21, tmp23, tmp25, tmp42})
					tmp44 := lang.Apply(tmp8, []any{tmp43})
					tmp6 = tmp44
				} else {
				}
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_set_DASH_test = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_set_DASH_test.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stacktrace-file-and-line
	{
		tmp0 := sym_stacktrace_DASH_file_DASH_and_DASH_line.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_stacktrace)), kw_file, "clojure/test.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_stacktrace_DASH_file_DASH_and_DASH_line, kw_end_DASH_column, int(31), kw_column, int(8), kw_line, int(343), kw_end_DASH_line, int(343), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				var tmp6 any
				{ // let
					// let binding "s"
					tmp7 := checkDerefVar(var_clojure_DOT_core_first)
					tmp8 := lang.Apply(tmp7, []any{v2})
					var v9 any = tmp8
					_ = v9
					tmp10, ok := lang.FieldOrMethod(v9, "getFileName")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "getFileName")))
					}
					var tmp11 any
					switch reflect.TypeOf(tmp10).Kind() {
					case reflect.Func:
						tmp11 = lang.Apply(tmp10, nil)
					default:
						tmp11 = tmp10
					}
					tmp12, ok := lang.FieldOrMethod(v9, "getLineNumber")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "getLineNumber")))
					}
					var tmp13 any
					switch reflect.TypeOf(tmp12).Kind() {
					case reflect.Func:
						tmp13 = lang.Apply(tmp12, nil)
					default:
						tmp13 = tmp12
					}
					tmp14 := lang.NewMap(kw_file, tmp11, kw_line, tmp13)
					tmp15 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(347), kw_column, int(7), kw_end_DASH_line, int(347), kw_end_DASH_column, int(55))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp6 = tmp16
				} // end let
				tmp3 = tmp6
			} else {
				tmp7 := lang.NewMap(kw_file, nil, kw_line, nil)
				tmp8 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(348), kw_column, int(5), kw_end_DASH_line, int(348), kw_end_DASH_column, int(25))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp3 = tmp9
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_stacktrace_DASH_file_DASH_and_DASH_line = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_stacktrace_DASH_file_DASH_and_DASH_line.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// successful?
	{
		tmp0 := sym_successful_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_summary)), kw_doc, "Returns true if the given test summary indicates all tests\n  were successful, false otherwise.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_successful_QMARK_, kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(780), kw_end_DASH_line, int(780))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "and__0__auto__"
				tmp4 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
				tmp5 := lang.Apply(kw_fail, []any{v2, int64(0)})
				tmp6 := lang.Apply(tmp4, []any{tmp5})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(var_clojure_DOT_core_zero_QMARK_)
					tmp10 := lang.Apply(kw_error, []any{v2, int64(0)})
					tmp11 := lang.Apply(tmp9, []any{tmp10})
					tmp8 = tmp11
				} else {
					tmp8 = v7
				}
				tmp3 = tmp8
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_successful_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_successful_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// test-all-vars
	{
		tmp0 := sym_test_DASH_all_DASH_vars.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Calls test-vars on every var interned in the namespace, with fixtures.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_test_DASH_all_DASH_vars, kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(728), kw_end_DASH_line, int(728))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_test_test_DASH_vars)
			tmp4 := checkDerefVar(var_clojure_DOT_core_vals)
			tmp5 := checkDerefVar(var_clojure_DOT_core_ns_DASH_interns)
			tmp6 := lang.Apply(tmp5, []any{v2})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			tmp8 := lang.Apply(tmp3, []any{tmp7})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_test_DASH_all_DASH_vars = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_test_DASH_all_DASH_vars.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// test-ns
	{
		tmp0 := sym_test_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  Returns the final, dereferenced state of\n  *report-counters*.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_test_DASH_ns, kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(734), kw_end_DASH_line, int(734))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				tmp4 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp5 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
				tmp6 := lang.InternVarName(sym_clojure_DOT_test, sym__STAR_report_DASH_counters_STAR_)
				tmp7 := checkDerefVar(var_clojure_DOT_core_ref)
				tmp8 := checkDerefVar(var_clojure_DOT_test__STAR_initial_DASH_report_DASH_counters_STAR_)
				tmp9 := lang.Apply(tmp7, []any{tmp8})
				tmp10 := lang.Apply(tmp5, []any{tmp6, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				_ = tmp11
				var tmp12 any
				func() {
					defer func() {
						tmp13 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp14 := lang.Apply(tmp13, nil)
						_ = tmp14
					}()
					var tmp15 any
					{ // let
						// let binding "ns-obj"
						tmp16 := checkDerefVar(var_clojure_DOT_core_the_DASH_ns)
						tmp17 := lang.Apply(tmp16, []any{v2})
						var v18 any = tmp17
						_ = v18
						tmp19 := checkDerefVar(var_clojure_DOT_test_do_DASH_report)
						tmp20 := lang.NewMap(kw_type, kw_begin_DASH_test_DASH_ns, kw_ns, v18)
						tmp21 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(746), kw_column, int(18), kw_end_DASH_line, int(746), kw_end_DASH_column, int(51))
						tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp23 := lang.Apply(tmp19, []any{tmp22})
						_ = tmp23
						var tmp24 any
						{ // let
							// let binding "temp__0__auto__"
							tmp25 := checkDerefVar(var_clojure_DOT_core_find_DASH_var)
							tmp26 := checkDerefVar(var_clojure_DOT_core_symbol)
							tmp27 := checkDerefVar(var_clojure_DOT_core_str)
							tmp28 := checkDerefVar(var_clojure_DOT_core_ns_DASH_name)
							tmp29 := lang.Apply(tmp28, []any{v18})
							tmp30 := lang.Apply(tmp27, []any{tmp29})
							tmp31 := lang.Apply(tmp26, []any{tmp30, "test-ns-hook"})
							tmp32 := lang.Apply(tmp25, []any{tmp31})
							var v33 any = tmp32
							_ = v33
							var tmp34 any
							if lang.IsTruthy(v33) {
								var tmp35 any
								{ // let
									// let binding "v"
									var v36 any = v33
									_ = v36
									tmp37 := checkDerefVar(var_clojure_DOT_core_var_DASH_get)
									tmp38 := lang.Apply(tmp37, []any{v36})
									tmp39 := lang.Apply(tmp38, nil)
									tmp35 = tmp39
								} // end let
								tmp34 = tmp35
							} else {
								tmp36 := checkDerefVar(var_clojure_DOT_test_test_DASH_all_DASH_vars)
								tmp37 := lang.Apply(tmp36, []any{v18})
								tmp34 = tmp37
							}
							tmp24 = tmp34
						} // end let
						_ = tmp24
						tmp25 := checkDerefVar(var_clojure_DOT_test_do_DASH_report)
						tmp26 := lang.NewMap(kw_type, kw_end_DASH_test_DASH_ns, kw_ns, v18)
						tmp27 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(752), kw_column, int(18), kw_end_DASH_line, int(752), kw_end_DASH_column, int(49))
						tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp29 := lang.Apply(tmp25, []any{tmp28})
						tmp15 = tmp29
					} // end let
					_ = tmp15
					tmp16 := checkDerefVar(var_clojure_DOT_core_deref)
					tmp17 := checkDerefVar(var_clojure_DOT_test__STAR_report_DASH_counters_STAR_)
					tmp18 := lang.Apply(tmp16, []any{tmp17})
					tmp12 = tmp18
				}()
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_test_DASH_ns = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_test_DASH_ns.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// test-var
	{
		tmp0 := sym_test_DASH_var.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_v)), kw_doc, "If v has a function in its :test metadata, calls that function,\n  with *testing-vars* bound to (conj *testing-vars* v).", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_test_DASH_var, kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(699), kw_end_DASH_line, int(699), kw_dynamic, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_clojure_DOT_core_meta)
				tmp5 := lang.Apply(tmp4, []any{v2})
				tmp6 := lang.Apply(kw_test, []any{tmp5})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "t"
						var v10 any = v7
						_ = v10
						var tmp11 any
						{ // let
							tmp12 := checkDerefVar(var_clojure_DOT_core_push_DASH_thread_DASH_bindings)
							tmp13 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
							tmp14 := lang.InternVarName(sym_clojure_DOT_test, sym__STAR_testing_DASH_vars_STAR_)
							tmp15 := checkDerefVar(var_clojure_DOT_core_conj)
							tmp16 := checkDerefVar(var_clojure_DOT_test__STAR_testing_DASH_vars_STAR_)
							tmp17 := lang.Apply(tmp15, []any{tmp16, v2})
							tmp18 := lang.Apply(tmp13, []any{tmp14, tmp17})
							tmp19 := lang.Apply(tmp12, []any{tmp18})
							_ = tmp19
							var tmp20 any
							func() {
								defer func() {
									tmp21 := checkDerefVar(var_clojure_DOT_core_pop_DASH_thread_DASH_bindings)
									tmp22 := lang.Apply(tmp21, nil)
									_ = tmp22
								}()
								tmp23 := checkDerefVar(var_clojure_DOT_test_do_DASH_report)
								tmp24 := lang.NewMap(kw_type, kw_begin_DASH_test_DASH_var, kw_var, v2)
								tmp25 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(706), kw_column, int(18), kw_end_DASH_line, int(706), kw_end_DASH_column, int(48))
								tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp27 := lang.Apply(tmp23, []any{tmp26})
								_ = tmp27
								tmp28 := checkDerefVar(var_clojure_DOT_test_inc_DASH_report_DASH_counter)
								tmp29 := lang.Apply(tmp28, []any{kw_test})
								_ = tmp29
								var tmp30 any
								func() {
									defer func() {
										if r := recover(); r != nil {
											if lang.CatchMatches(r, lang.Builtins["any"]) {
												v31 := r
												_ = v31
												tmp32 := checkDerefVar(var_clojure_DOT_test_do_DASH_report)
												tmp33 := lang.NewMap(kw_type, kw_error, kw_message, "Uncaught exception, not in assertion.", kw_expected, nil, kw_actual, v31)
												tmp34 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(710), kw_column, int(25), kw_end_DASH_line, int(711), kw_end_DASH_column, int(47))
												tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp36 := lang.Apply(tmp32, []any{tmp35})
												tmp30 = tmp36
											} else {
												panic(r)
											}
										}
									}()
									tmp31 := lang.Apply(v10, nil)
									tmp30 = tmp31
								}()
								_ = tmp30
								tmp32 := checkDerefVar(var_clojure_DOT_test_do_DASH_report)
								tmp33 := lang.NewMap(kw_type, kw_end_DASH_test_DASH_var, kw_var, v2)
								tmp34 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(712), kw_column, int(18), kw_end_DASH_line, int(712), kw_end_DASH_column, int(46))
								tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp36 := lang.Apply(tmp32, []any{tmp35})
								tmp20 = tmp36
							}()
							tmp11 = tmp20
						} // end let
						tmp9 = tmp11
					} // end let
					tmp8 = tmp9
				} else {
				}
				tmp3 = tmp8
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_test_DASH_var = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_test_DASH_var.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_clojure_DOT_test_test_DASH_var.SetDynamic()
	}
	// test-vars
	{
		tmp0 := sym_test_DASH_vars.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_vars)), kw_doc, "Groups vars by their namespace and runs test-var on them with\n  appropriate fixtures applied.", kw_file, "clojure/test.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_test_DASH_vars, kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(714), kw_end_DASH_line, int(714))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "seq_1070"
				tmp4 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_clojure_DOT_core_group_DASH_by)
				tmp6 := checkDerefVar(var_clojure_DOT_core_comp)
				tmp7 := checkDerefVar(var_clojure_DOT_core_meta)
				tmp8 := lang.Apply(tmp6, []any{kw_ns, tmp7})
				tmp9 := lang.Apply(tmp5, []any{tmp8, v2})
				tmp10 := lang.Apply(tmp4, []any{tmp9})
				var v11 any = tmp10
				_ = v11
				// let binding "chunk_1071"
				var v12 any = nil
				_ = v12
				// let binding "count_1072"
				var v13 any = int64(0)
				_ = v13
				// let binding "i_1073"
				var v14 any = int64(0)
				_ = v14
				for {
					var tmp15 any
					tmp16 := checkDerefVar(var_clojure_DOT_core__LT_)
					tmp17 := lang.Apply(tmp16, []any{v14, v13})
					if lang.IsTruthy(tmp17) {
						var tmp18 any
						{ // let
							// let binding "vec__1074"
							tmp19, _ := lang.FieldOrMethod(v12, "nth")
							if reflect.TypeOf(tmp19).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
							}
							tmp20 := lang.Apply(tmp19, []any{v14})
							var v21 any = tmp20
							_ = v21
							// let binding "ns"
							tmp22 := checkDerefVar(var_clojure_DOT_core_nth)
							tmp23 := lang.Apply(tmp22, []any{v21, int64(0), nil})
							var v24 any = tmp23
							_ = v24
							// let binding "vars"
							tmp25 := checkDerefVar(var_clojure_DOT_core_nth)
							tmp26 := lang.Apply(tmp25, []any{v21, int64(1), nil})
							var v27 any = tmp26
							_ = v27
							var tmp28 any
							{ // let
								// let binding "once-fixture-fn"
								tmp29 := checkDerefVar(var_clojure_DOT_test_join_DASH_fixtures)
								tmp30 := checkDerefVar(var_clojure_DOT_core_meta)
								tmp31 := lang.Apply(tmp30, []any{v24})
								tmp32 := lang.Apply(kw_clojure_DOT_test_SLASH_once_DASH_fixtures, []any{tmp31})
								tmp33 := lang.Apply(tmp29, []any{tmp32})
								var v34 any = tmp33
								_ = v34
								// let binding "each-fixture-fn"
								tmp35 := checkDerefVar(var_clojure_DOT_test_join_DASH_fixtures)
								tmp36 := checkDerefVar(var_clojure_DOT_core_meta)
								tmp37 := lang.Apply(tmp36, []any{v24})
								tmp38 := lang.Apply(kw_clojure_DOT_test_SLASH_each_DASH_fixtures, []any{tmp37})
								tmp39 := lang.Apply(tmp35, []any{tmp38})
								var v40 any = tmp39
								_ = v40
								var tmp41 lang.FnFunc
								tmp41 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 0)
									var tmp42 any
									{ // let
										// let binding "seq_1077"
										tmp43 := checkDerefVar(var_clojure_DOT_core_seq)
										tmp44 := lang.Apply(tmp43, []any{v27})
										var v45 any = tmp44
										_ = v45
										// let binding "chunk_1078"
										var v46 any = nil
										_ = v46
										// let binding "count_1079"
										var v47 any = int64(0)
										_ = v47
										// let binding "i_1080"
										var v48 any = int64(0)
										_ = v48
										for {
											var tmp49 any
											tmp50 := checkDerefVar(var_clojure_DOT_core__LT_)
											tmp51 := lang.Apply(tmp50, []any{v48, v47})
											if lang.IsTruthy(tmp51) {
												var tmp52 any
												{ // let
													// let binding "v"
													tmp53, _ := lang.FieldOrMethod(v46, "nth")
													if reflect.TypeOf(tmp53).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
													}
													tmp54 := lang.Apply(tmp53, []any{v48})
													var v55 any = tmp54
													_ = v55
													var tmp56 any
													tmp57 := checkDerefVar(var_clojure_DOT_core_meta)
													tmp58 := lang.Apply(tmp57, []any{v55})
													tmp59 := lang.Apply(kw_test, []any{tmp58})
													if lang.IsTruthy(tmp59) {
														var tmp60 lang.FnFunc
														tmp60 = lang.NewFnFunc(func(args ...any) any {
															checkArity(args, 0)
															tmp61 := checkDerefVar(var_clojure_DOT_test_test_DASH_var)
															tmp62 := lang.Apply(tmp61, []any{v55})
															return tmp62
														})
														tmp61 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(726), kw_column, int(31), kw_end_DASH_line, int(726), kw_end_DASH_column, int(50))
														tmp62, err := lang.WithMeta(tmp60, tmp61.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp63 := lang.Apply(v40, []any{tmp62})
														tmp56 = tmp63
													} else {
													}
													_ = tmp56
													var tmp64 any = v45
													var tmp65 any = v46
													var tmp66 any = v47
													tmp68 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
													tmp69 := lang.Apply(tmp68, []any{v48})
													var tmp67 any = tmp69
													v45 = tmp64
													v46 = tmp65
													v47 = tmp66
													v48 = tmp67
													continue
												} // end let
												tmp49 = tmp52
											} else {
												var tmp53 any
												{ // let
													// let binding "temp__0__auto__"
													tmp54 := checkDerefVar(var_clojure_DOT_core_seq)
													tmp55 := lang.Apply(tmp54, []any{v45})
													var v56 any = tmp55
													_ = v56
													var tmp57 any
													if lang.IsTruthy(v56) {
														var tmp58 any
														{ // let
															// let binding "seq_1077"
															var v59 any = v56
															_ = v59
															var tmp60 any
															tmp61 := checkDerefVar(var_clojure_DOT_core_chunked_DASH_seq_QMARK_)
															tmp62 := lang.Apply(tmp61, []any{v59})
															if lang.IsTruthy(tmp62) {
																var tmp63 any
																{ // let
																	// let binding "c__0__auto__"
																	tmp64 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_first)
																	tmp65 := lang.Apply(tmp64, []any{v59})
																	var v66 any = tmp65
																	_ = v66
																	tmp68 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_rest)
																	tmp69 := lang.Apply(tmp68, []any{v59})
																	var tmp67 any = tmp69
																	var tmp70 any = v66
																	tmp72 := checkDerefVar(var_clojure_DOT_core_int)
																	tmp73 := checkDerefVar(var_clojure_DOT_core_count)
																	tmp74 := lang.Apply(tmp73, []any{v66})
																	tmp75 := lang.Apply(tmp72, []any{tmp74})
																	var tmp71 any = tmp75
																	tmp77 := checkDerefVar(var_clojure_DOT_core_int)
																	tmp78 := lang.Apply(tmp77, []any{int64(0)})
																	var tmp76 any = tmp78
																	v45 = tmp67
																	v46 = tmp70
																	v47 = tmp71
																	v48 = tmp76
																	continue
																} // end let
																tmp60 = tmp63
															} else {
																var tmp64 any
																{ // let
																	// let binding "v"
																	tmp65 := checkDerefVar(var_clojure_DOT_core_first)
																	tmp66 := lang.Apply(tmp65, []any{v59})
																	var v67 any = tmp66
																	_ = v67
																	var tmp68 any
																	tmp69 := checkDerefVar(var_clojure_DOT_core_meta)
																	tmp70 := lang.Apply(tmp69, []any{v67})
																	tmp71 := lang.Apply(kw_test, []any{tmp70})
																	if lang.IsTruthy(tmp71) {
																		var tmp72 lang.FnFunc
																		tmp72 = lang.NewFnFunc(func(args ...any) any {
																			checkArity(args, 0)
																			tmp73 := checkDerefVar(var_clojure_DOT_test_test_DASH_var)
																			tmp74 := lang.Apply(tmp73, []any{v67})
																			return tmp74
																		})
																		tmp73 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(726), kw_column, int(31), kw_end_DASH_line, int(726), kw_end_DASH_column, int(50))
																		tmp74, err := lang.WithMeta(tmp72, tmp73.(lang.IPersistentMap))
																		if err != nil {
																			panic(err)
																		}
																		tmp75 := lang.Apply(v40, []any{tmp74})
																		tmp68 = tmp75
																	} else {
																	}
																	_ = tmp68
																	tmp77 := checkDerefVar(var_clojure_DOT_core_next)
																	tmp78 := lang.Apply(tmp77, []any{v59})
																	var tmp76 any = tmp78
																	var tmp79 any = nil
																	var tmp80 any = int64(0)
																	var tmp81 any = int64(0)
																	v45 = tmp76
																	v46 = tmp79
																	v47 = tmp80
																	v48 = tmp81
																	continue
																} // end let
																tmp60 = tmp64
															}
															tmp58 = tmp60
														} // end let
														tmp57 = tmp58
													} else {
													}
													tmp53 = tmp57
												} // end let
												tmp49 = tmp53
											}
											tmp42 = tmp49
											break
										}
									} // end let
									return tmp42
								})
								tmp42 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(723), kw_column, int(8), kw_end_DASH_line, int(726), kw_end_DASH_column, int(54))
								tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp44 := lang.Apply(v34, []any{tmp43})
								tmp28 = tmp44
							} // end let
							_ = tmp28
							var tmp29 any = v11
							var tmp30 any = v12
							var tmp31 any = v13
							tmp33 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
							tmp34 := lang.Apply(tmp33, []any{v14})
							var tmp32 any = tmp34
							v11 = tmp29
							v12 = tmp30
							v13 = tmp31
							v14 = tmp32
							continue
						} // end let
						tmp15 = tmp18
					} else {
						var tmp19 any
						{ // let
							// let binding "temp__0__auto__"
							tmp20 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp21 := lang.Apply(tmp20, []any{v11})
							var v22 any = tmp21
							_ = v22
							var tmp23 any
							if lang.IsTruthy(v22) {
								var tmp24 any
								{ // let
									// let binding "seq_1070"
									var v25 any = v22
									_ = v25
									var tmp26 any
									tmp27 := checkDerefVar(var_clojure_DOT_core_chunked_DASH_seq_QMARK_)
									tmp28 := lang.Apply(tmp27, []any{v25})
									if lang.IsTruthy(tmp28) {
										var tmp29 any
										{ // let
											// let binding "c__0__auto__"
											tmp30 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_first)
											tmp31 := lang.Apply(tmp30, []any{v25})
											var v32 any = tmp31
											_ = v32
											tmp34 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_rest)
											tmp35 := lang.Apply(tmp34, []any{v25})
											var tmp33 any = tmp35
											var tmp36 any = v32
											tmp38 := checkDerefVar(var_clojure_DOT_core_int)
											tmp39 := checkDerefVar(var_clojure_DOT_core_count)
											tmp40 := lang.Apply(tmp39, []any{v32})
											tmp41 := lang.Apply(tmp38, []any{tmp40})
											var tmp37 any = tmp41
											tmp43 := checkDerefVar(var_clojure_DOT_core_int)
											tmp44 := lang.Apply(tmp43, []any{int64(0)})
											var tmp42 any = tmp44
											v11 = tmp33
											v12 = tmp36
											v13 = tmp37
											v14 = tmp42
											continue
										} // end let
										tmp26 = tmp29
									} else {
										var tmp30 any
										{ // let
											// let binding "vec__1081"
											tmp31 := checkDerefVar(var_clojure_DOT_core_first)
											tmp32 := lang.Apply(tmp31, []any{v25})
											var v33 any = tmp32
											_ = v33
											// let binding "ns"
											tmp34 := checkDerefVar(var_clojure_DOT_core_nth)
											tmp35 := lang.Apply(tmp34, []any{v33, int64(0), nil})
											var v36 any = tmp35
											_ = v36
											// let binding "vars"
											tmp37 := checkDerefVar(var_clojure_DOT_core_nth)
											tmp38 := lang.Apply(tmp37, []any{v33, int64(1), nil})
											var v39 any = tmp38
											_ = v39
											var tmp40 any
											{ // let
												// let binding "once-fixture-fn"
												tmp41 := checkDerefVar(var_clojure_DOT_test_join_DASH_fixtures)
												tmp42 := checkDerefVar(var_clojure_DOT_core_meta)
												tmp43 := lang.Apply(tmp42, []any{v36})
												tmp44 := lang.Apply(kw_clojure_DOT_test_SLASH_once_DASH_fixtures, []any{tmp43})
												tmp45 := lang.Apply(tmp41, []any{tmp44})
												var v46 any = tmp45
												_ = v46
												// let binding "each-fixture-fn"
												tmp47 := checkDerefVar(var_clojure_DOT_test_join_DASH_fixtures)
												tmp48 := checkDerefVar(var_clojure_DOT_core_meta)
												tmp49 := lang.Apply(tmp48, []any{v36})
												tmp50 := lang.Apply(kw_clojure_DOT_test_SLASH_each_DASH_fixtures, []any{tmp49})
												tmp51 := lang.Apply(tmp47, []any{tmp50})
												var v52 any = tmp51
												_ = v52
												var tmp53 lang.FnFunc
												tmp53 = lang.NewFnFunc(func(args ...any) any {
													checkArity(args, 0)
													var tmp54 any
													{ // let
														// let binding "seq_1084"
														tmp55 := checkDerefVar(var_clojure_DOT_core_seq)
														tmp56 := lang.Apply(tmp55, []any{v39})
														var v57 any = tmp56
														_ = v57
														// let binding "chunk_1085"
														var v58 any = nil
														_ = v58
														// let binding "count_1086"
														var v59 any = int64(0)
														_ = v59
														// let binding "i_1087"
														var v60 any = int64(0)
														_ = v60
														for {
															var tmp61 any
															tmp62 := checkDerefVar(var_clojure_DOT_core__LT_)
															tmp63 := lang.Apply(tmp62, []any{v60, v59})
															if lang.IsTruthy(tmp63) {
																var tmp64 any
																{ // let
																	// let binding "v"
																	tmp65, _ := lang.FieldOrMethod(v58, "nth")
																	if reflect.TypeOf(tmp65).Kind() != reflect.Func {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
																	}
																	tmp66 := lang.Apply(tmp65, []any{v60})
																	var v67 any = tmp66
																	_ = v67
																	var tmp68 any
																	tmp69 := checkDerefVar(var_clojure_DOT_core_meta)
																	tmp70 := lang.Apply(tmp69, []any{v67})
																	tmp71 := lang.Apply(kw_test, []any{tmp70})
																	if lang.IsTruthy(tmp71) {
																		var tmp72 lang.FnFunc
																		tmp72 = lang.NewFnFunc(func(args ...any) any {
																			checkArity(args, 0)
																			tmp73 := checkDerefVar(var_clojure_DOT_test_test_DASH_var)
																			tmp74 := lang.Apply(tmp73, []any{v67})
																			return tmp74
																		})
																		tmp73 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(726), kw_column, int(31), kw_end_DASH_line, int(726), kw_end_DASH_column, int(50))
																		tmp74, err := lang.WithMeta(tmp72, tmp73.(lang.IPersistentMap))
																		if err != nil {
																			panic(err)
																		}
																		tmp75 := lang.Apply(v52, []any{tmp74})
																		tmp68 = tmp75
																	} else {
																	}
																	_ = tmp68
																	var tmp76 any = v57
																	var tmp77 any = v58
																	var tmp78 any = v59
																	tmp80 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
																	tmp81 := lang.Apply(tmp80, []any{v60})
																	var tmp79 any = tmp81
																	v57 = tmp76
																	v58 = tmp77
																	v59 = tmp78
																	v60 = tmp79
																	continue
																} // end let
																tmp61 = tmp64
															} else {
																var tmp65 any
																{ // let
																	// let binding "temp__0__auto__"
																	tmp66 := checkDerefVar(var_clojure_DOT_core_seq)
																	tmp67 := lang.Apply(tmp66, []any{v57})
																	var v68 any = tmp67
																	_ = v68
																	var tmp69 any
																	if lang.IsTruthy(v68) {
																		var tmp70 any
																		{ // let
																			// let binding "seq_1084"
																			var v71 any = v68
																			_ = v71
																			var tmp72 any
																			tmp73 := checkDerefVar(var_clojure_DOT_core_chunked_DASH_seq_QMARK_)
																			tmp74 := lang.Apply(tmp73, []any{v71})
																			if lang.IsTruthy(tmp74) {
																				var tmp75 any
																				{ // let
																					// let binding "c__0__auto__"
																					tmp76 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_first)
																					tmp77 := lang.Apply(tmp76, []any{v71})
																					var v78 any = tmp77
																					_ = v78
																					tmp80 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_rest)
																					tmp81 := lang.Apply(tmp80, []any{v71})
																					var tmp79 any = tmp81
																					var tmp82 any = v78
																					tmp84 := checkDerefVar(var_clojure_DOT_core_int)
																					tmp85 := checkDerefVar(var_clojure_DOT_core_count)
																					tmp86 := lang.Apply(tmp85, []any{v78})
																					tmp87 := lang.Apply(tmp84, []any{tmp86})
																					var tmp83 any = tmp87
																					tmp89 := checkDerefVar(var_clojure_DOT_core_int)
																					tmp90 := lang.Apply(tmp89, []any{int64(0)})
																					var tmp88 any = tmp90
																					v57 = tmp79
																					v58 = tmp82
																					v59 = tmp83
																					v60 = tmp88
																					continue
																				} // end let
																				tmp72 = tmp75
																			} else {
																				var tmp76 any
																				{ // let
																					// let binding "v"
																					tmp77 := checkDerefVar(var_clojure_DOT_core_first)
																					tmp78 := lang.Apply(tmp77, []any{v71})
																					var v79 any = tmp78
																					_ = v79
																					var tmp80 any
																					tmp81 := checkDerefVar(var_clojure_DOT_core_meta)
																					tmp82 := lang.Apply(tmp81, []any{v79})
																					tmp83 := lang.Apply(kw_test, []any{tmp82})
																					if lang.IsTruthy(tmp83) {
																						var tmp84 lang.FnFunc
																						tmp84 = lang.NewFnFunc(func(args ...any) any {
																							checkArity(args, 0)
																							tmp85 := checkDerefVar(var_clojure_DOT_test_test_DASH_var)
																							tmp86 := lang.Apply(tmp85, []any{v79})
																							return tmp86
																						})
																						tmp85 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(726), kw_column, int(31), kw_end_DASH_line, int(726), kw_end_DASH_column, int(50))
																						tmp86, err := lang.WithMeta(tmp84, tmp85.(lang.IPersistentMap))
																						if err != nil {
																							panic(err)
																						}
																						tmp87 := lang.Apply(v52, []any{tmp86})
																						tmp80 = tmp87
																					} else {
																					}
																					_ = tmp80
																					tmp89 := checkDerefVar(var_clojure_DOT_core_next)
																					tmp90 := lang.Apply(tmp89, []any{v71})
																					var tmp88 any = tmp90
																					var tmp91 any = nil
																					var tmp92 any = int64(0)
																					var tmp93 any = int64(0)
																					v57 = tmp88
																					v58 = tmp91
																					v59 = tmp92
																					v60 = tmp93
																					continue
																				} // end let
																				tmp72 = tmp76
																			}
																			tmp70 = tmp72
																		} // end let
																		tmp69 = tmp70
																	} else {
																	}
																	tmp65 = tmp69
																} // end let
																tmp61 = tmp65
															}
															tmp54 = tmp61
															break
														}
													} // end let
													return tmp54
												})
												tmp54 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(723), kw_column, int(8), kw_end_DASH_line, int(726), kw_end_DASH_column, int(54))
												tmp55, err := lang.WithMeta(tmp53, tmp54.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp56 := lang.Apply(v46, []any{tmp55})
												tmp40 = tmp56
											} // end let
											_ = tmp40
											tmp42 := checkDerefVar(var_clojure_DOT_core_next)
											tmp43 := lang.Apply(tmp42, []any{v25})
											var tmp41 any = tmp43
											var tmp44 any = nil
											var tmp45 any = int64(0)
											var tmp46 any = int64(0)
											v11 = tmp41
											v12 = tmp44
											v13 = tmp45
											v14 = tmp46
											continue
										} // end let
										tmp26 = tmp30
									}
									tmp24 = tmp26
								} // end let
								tmp23 = tmp24
							} else {
							}
							tmp19 = tmp23
						} // end let
						tmp15 = tmp19
					}
					tmp3 = tmp15
					break
				}
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_test_DASH_vars = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_test_DASH_vars.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// testing
	{
		tmp0 := sym_testing.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_string, sym__AMP_, sym_body)), kw_doc, "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_testing, kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(588), kw_end_DASH_line, int(588))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_clojure_DOT_core_SLASH_binding})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp13 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_clojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_clojure_DOT_test_SLASH__STAR_testing_DASH_contexts_STAR_})
				tmp17 := checkDerefVar(var_clojure_DOT_core_list)
				tmp18 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp19 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp20 := checkDerefVar(var_clojure_DOT_core_list)
				tmp21 := lang.Apply(tmp20, []any{sym_clojure_DOT_core_SLASH_conj})
				tmp22 := checkDerefVar(var_clojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{sym_clojure_DOT_test_SLASH__STAR_testing_DASH_contexts_STAR_})
				tmp24 := checkDerefVar(var_clojure_DOT_core_list)
				tmp25 := lang.Apply(tmp24, []any{v4})
				tmp26 := lang.Apply(tmp19, []any{tmp21, tmp23, tmp25})
				tmp27 := lang.Apply(tmp18, []any{tmp26})
				tmp28 := lang.Apply(tmp17, []any{tmp27})
				tmp29 := lang.Apply(tmp14, []any{tmp16, tmp28})
				tmp30 := lang.Apply(tmp13, []any{tmp29})
				tmp31 := lang.Apply(tmp11, []any{tmp12, tmp30})
				tmp32 := lang.Apply(tmp10, []any{tmp31})
				tmp33 := lang.Apply(tmp7, []any{tmp9, tmp32, v5})
				tmp34 := lang.Apply(tmp6, []any{tmp33})
				return tmp34
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_testing = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_testing.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// testing-contexts-str
	{
		tmp0 := sym_testing_DASH_contexts_DASH_str.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_testing_DASH_contexts_DASH_str, kw_end_DASH_column, int(26), kw_column, int(7), kw_line, int(306), kw_end_DASH_line, int(306))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp3 := checkDerefVar(var_clojure_DOT_core_str)
			tmp4 := checkDerefVar(var_clojure_DOT_core_interpose)
			tmp5 := checkDerefVar(var_clojure_DOT_core_reverse)
			tmp6 := checkDerefVar(var_clojure_DOT_test__STAR_testing_DASH_contexts_STAR_)
			tmp7 := lang.Apply(tmp5, []any{tmp6})
			tmp8 := lang.Apply(tmp4, []any{" ", tmp7})
			tmp9 := lang.Apply(tmp2, []any{tmp3, tmp8})
			return tmp9
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_testing_DASH_contexts_DASH_str = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_testing_DASH_contexts_DASH_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// testing-vars-str
	{
		tmp0 := sym_testing_DASH_vars_DASH_str.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m)), kw_doc, "Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_testing_DASH_vars_DASH_str, kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(293), kw_end_DASH_line, int(293))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "map__1068"
				var v4 any = v2
				_ = v4
				// let binding "map__1068"
				var tmp5 any
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					var tmp8 any
					tmp9 := checkDerefVar(var_clojure_DOT_core_next)
					tmp10 := lang.Apply(tmp9, []any{v4})
					if lang.IsTruthy(tmp10) {
						tmp11 := checkDerefVar(var_clojure_DOT_core_to_DASH_array)
						tmp12 := lang.Apply(tmp11, []any{v4})
						tmp13 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp12})
						tmp8 = tmp13
					} else {
						var tmp14 any
						tmp15 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp16 := lang.Apply(tmp15, []any{v4})
						if lang.IsTruthy(tmp16) {
							tmp17 := checkDerefVar(var_clojure_DOT_core_first)
							tmp18 := lang.Apply(tmp17, []any{v4})
							tmp14 = tmp18
						} else {
						}
						tmp8 = tmp14
					}
					tmp5 = tmp8
				} else {
					tmp5 = v4
				}
				var v19 any = tmp5
				_ = v19
				// let binding "file"
				tmp20 := checkDerefVar(var_clojure_DOT_core_get)
				tmp21 := lang.Apply(tmp20, []any{v19, kw_file})
				var v22 any = tmp21
				_ = v22
				// let binding "line"
				tmp23 := checkDerefVar(var_clojure_DOT_core_get)
				tmp24 := lang.Apply(tmp23, []any{v19, kw_line})
				var v25 any = tmp24
				_ = v25
				tmp26 := checkDerefVar(var_clojure_DOT_core_str)
				tmp27 := checkDerefVar(var_clojure_DOT_core_reverse)
				tmp28 := checkDerefVar(var_clojure_DOT_core_map)
				var tmp29 lang.FnFunc
				tmp29 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v30 := args[0]
					_ = v30
					tmp31 := checkDerefVar(var_clojure_DOT_core_meta)
					tmp32 := lang.Apply(tmp31, []any{v30})
					tmp33 := lang.Apply(kw_name, []any{tmp32})
					return tmp33
				})
				tmp30 := lang.NewMap(kw_file, "clojure/test.glj", kw_line, int(303), kw_column, int(20), kw_end_DASH_line, int(303), kw_end_DASH_column, int(36))
				tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp32 := checkDerefVar(var_clojure_DOT_test__STAR_testing_DASH_vars_STAR_)
				tmp33 := lang.Apply(tmp28, []any{tmp31, tmp32})
				tmp34 := lang.Apply(tmp27, []any{tmp33})
				tmp35 := lang.Apply(tmp26, []any{tmp34, " (", v22, ":", v25, ")"})
				tmp3 = tmp35
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_testing_DASH_vars_DASH_str = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_testing_DASH_vars_DASH_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// try-expr
	{
		tmp0 := sym_try_DASH_expr.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_msg, sym_form)), kw_doc, "Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_try_DASH_expr, kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(529), kw_end_DASH_line, int(529))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			v5 := args[3]
			_ = v5
			tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp8 := checkDerefVar(var_clojure_DOT_core_list)
			tmp9 := lang.Apply(tmp8, []any{sym_try})
			tmp10 := checkDerefVar(var_clojure_DOT_core_list)
			tmp11 := checkDerefVar(var_clojure_DOT_test_assert_DASH_expr)
			tmp12 := lang.Apply(tmp11, []any{v4, v5})
			tmp13 := lang.Apply(tmp10, []any{tmp12})
			tmp14 := checkDerefVar(var_clojure_DOT_core_list)
			tmp15 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp16 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp17 := checkDerefVar(var_clojure_DOT_core_list)
			tmp18 := lang.Apply(tmp17, []any{sym_catch})
			tmp19 := checkDerefVar(var_clojure_DOT_core_list)
			tmp20 := lang.Apply(tmp19, []any{sym_go_SLASH_any})
			tmp21 := checkDerefVar(var_clojure_DOT_core_list)
			tmp22 := lang.Apply(tmp21, []any{sym_t__0__auto__})
			tmp23 := checkDerefVar(var_clojure_DOT_core_list)
			tmp24 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp25 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp26 := checkDerefVar(var_clojure_DOT_core_list)
			tmp27 := lang.Apply(tmp26, []any{sym_clojure_DOT_test_SLASH_do_DASH_report})
			tmp28 := checkDerefVar(var_clojure_DOT_core_list)
			tmp29 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp30 := checkDerefVar(var_clojure_DOT_core_hash_DASH_map)
			tmp31 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp32 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp33 := checkDerefVar(var_clojure_DOT_core_list)
			tmp34 := lang.Apply(tmp33, []any{kw_type})
			tmp35 := checkDerefVar(var_clojure_DOT_core_list)
			tmp36 := lang.Apply(tmp35, []any{kw_error})
			tmp37 := checkDerefVar(var_clojure_DOT_core_list)
			tmp38 := lang.Apply(tmp37, []any{kw_message})
			tmp39 := checkDerefVar(var_clojure_DOT_core_list)
			tmp40 := lang.Apply(tmp39, []any{v4})
			tmp41 := checkDerefVar(var_clojure_DOT_core_list)
			tmp42 := lang.Apply(tmp41, []any{kw_expected})
			tmp43 := checkDerefVar(var_clojure_DOT_core_list)
			tmp44 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp45 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp46 := checkDerefVar(var_clojure_DOT_core_list)
			tmp47 := lang.Apply(tmp46, []any{sym_quote})
			tmp48 := checkDerefVar(var_clojure_DOT_core_list)
			tmp49 := lang.Apply(tmp48, []any{v5})
			tmp50 := lang.Apply(tmp45, []any{tmp47, tmp49})
			tmp51 := lang.Apply(tmp44, []any{tmp50})
			tmp52 := lang.Apply(tmp43, []any{tmp51})
			tmp53 := checkDerefVar(var_clojure_DOT_core_list)
			tmp54 := lang.Apply(tmp53, []any{kw_actual})
			tmp55 := checkDerefVar(var_clojure_DOT_core_list)
			tmp56 := lang.Apply(tmp55, []any{sym_t__0__auto__})
			tmp57 := lang.Apply(tmp32, []any{tmp34, tmp36, tmp38, tmp40, tmp42, tmp52, tmp54, tmp56})
			tmp58 := lang.Apply(tmp31, []any{tmp57})
			tmp59 := lang.Apply(tmp29, []any{tmp30, tmp58})
			tmp60 := lang.Apply(tmp28, []any{tmp59})
			tmp61 := lang.Apply(tmp25, []any{tmp27, tmp60})
			tmp62 := lang.Apply(tmp24, []any{tmp61})
			tmp63 := lang.Apply(tmp23, []any{tmp62})
			tmp64 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22, tmp63})
			tmp65 := lang.Apply(tmp15, []any{tmp64})
			tmp66 := lang.Apply(tmp14, []any{tmp65})
			tmp67 := lang.Apply(tmp7, []any{tmp9, tmp13, tmp66})
			tmp68 := lang.Apply(tmp6, []any{tmp67})
			return tmp68
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_try_DASH_expr = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_try_DASH_expr.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-test
	{
		tmp0 := sym_with_DASH_test.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_definition, sym__AMP_, sym_body)), kw_doc, "Takes any definition form (that returns a Var) as the first argument.\n  Remaining body goes in the :test metadata function for that Var.\n\n  When *load-tests* is false, only evaluates the definition, ignoring\n  the tests.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_with_DASH_test, kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(600), kw_end_DASH_line, int(600))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_clojure_DOT_test__STAR_load_DASH_tests_STAR_)
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_clojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_clojure_DOT_core_SLASH_doto})
					tmp12 := checkDerefVar(var_clojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{v4})
					tmp14 := checkDerefVar(var_clojure_DOT_core_list)
					tmp15 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_clojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_clojure_DOT_core_SLASH_alter_DASH_meta_BANG_})
					tmp19 := checkDerefVar(var_clojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{sym_clojure_DOT_core_SLASH_assoc})
					tmp21 := checkDerefVar(var_clojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{kw_test})
					tmp23 := checkDerefVar(var_clojure_DOT_core_list)
					tmp24 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp25 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp26 := checkDerefVar(var_clojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{sym_clojure_DOT_core_SLASH_fn})
					tmp28 := checkDerefVar(var_clojure_DOT_core_list)
					tmp29 := checkDerefVar(var_clojure_DOT_core_apply)
					tmp30 := checkDerefVar(var_clojure_DOT_core_vector)
					tmp31 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp32 := checkDerefVar(var_clojure_DOT_core_concat)
					tmp33 := lang.Apply(tmp32, nil)
					tmp34 := lang.Apply(tmp31, []any{tmp33})
					tmp35 := lang.Apply(tmp29, []any{tmp30, tmp34})
					tmp36 := lang.Apply(tmp28, []any{tmp35})
					tmp37 := lang.Apply(tmp25, []any{tmp27, tmp36, v5})
					tmp38 := lang.Apply(tmp24, []any{tmp37})
					tmp39 := lang.Apply(tmp23, []any{tmp38})
					tmp40 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22, tmp39})
					tmp41 := lang.Apply(tmp15, []any{tmp40})
					tmp42 := lang.Apply(tmp14, []any{tmp41})
					tmp43 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp42})
					tmp44 := lang.Apply(tmp8, []any{tmp43})
					tmp6 = tmp44
				} else {
					tmp6 = v4
				}
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_with_DASH_test = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_with_DASH_test.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-test-out
	{
		tmp0 := sym_with_DASH_test_DASH_out.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Runs body with *out* bound to the value of *test-out*.", kw_file, "clojure/test.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_test), kw_name, sym_with_DASH_test_DASH_out, kw_end_DASH_column, int(23), kw_column, int(11), kw_line, int(272), kw_end_DASH_line, int(272))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_clojure_DOT_core_SLASH_binding})
				tmp9 := checkDerefVar(var_clojure_DOT_core_list)
				tmp10 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp11 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp12 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_clojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_clojure_DOT_core_SLASH__STAR_out_STAR_})
				tmp16 := checkDerefVar(var_clojure_DOT_core_list)
				tmp17 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp18 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp19 := checkDerefVar(var_clojure_DOT_core_list)
				tmp20 := lang.Apply(tmp19, []any{sym_clojure_DOT_core_SLASH_or})
				tmp21 := checkDerefVar(var_clojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{sym_clojure_DOT_test_SLASH__STAR_test_DASH_out_STAR_})
				tmp23 := checkDerefVar(var_clojure_DOT_core_list)
				tmp24 := lang.Apply(tmp23, []any{sym_clojure_DOT_core_SLASH__STAR_out_STAR_})
				tmp25 := lang.Apply(tmp18, []any{tmp20, tmp22, tmp24})
				tmp26 := lang.Apply(tmp17, []any{tmp25})
				tmp27 := lang.Apply(tmp16, []any{tmp26})
				tmp28 := lang.Apply(tmp13, []any{tmp15, tmp27})
				tmp29 := lang.Apply(tmp12, []any{tmp28})
				tmp30 := lang.Apply(tmp10, []any{tmp11, tmp29})
				tmp31 := lang.Apply(tmp9, []any{tmp30})
				tmp32 := lang.Apply(tmp6, []any{tmp8, tmp31, v4})
				tmp33 := lang.Apply(tmp5, []any{tmp32})
				return tmp33
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_test_with_DASH_test_DASH_out = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_test_with_DASH_test_DASH_out.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}

	// Mark namespace as AOT-loaded
	if ns := lang.FindNamespace(lang.NewSymbol("clojure.test")); ns != nil {
		// Set metadata directly
		meta := ns.Meta()
		if meta == nil {
			meta = lang.NewMap()
		}
		ns.ResetMeta(meta.Assoc(lang.NewKeyword("aot-loaded"), true).(lang.IPersistentMap))
	}
}

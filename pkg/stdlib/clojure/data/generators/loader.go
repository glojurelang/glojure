// Code generated by glojure codegen. DO NOT EDIT.

package generators

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	rand4 "math/rand"
	reflect "reflect"
)

func init() {
	runtime.RegisterNSLoader("clojure/data/generators", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "clojure.data.generators"
func LoadNS() {
	sym__AMP_ := lang.NewSymbol("&")
	sym__STAR_ := lang.NewSymbol("*")
	sym__STAR_rnd_STAR_ := lang.NewSymbol("*rnd*")
	sym__STAR_rnd_STAR__DASH_ := lang.NewSymbol("*rnd*-")
	sym__PLUS_ := lang.NewSymbol("+")
	sym__DASH_ := lang.NewSymbol("-")
	sym__SLASH_ := lang.NewSymbol("/")
	sym__LT_ := lang.NewSymbol("<")
	sym__LT__EQ_ := lang.NewSymbol("<=")
	sym_aget := lang.NewSymbol("aget")
	sym_alter_DASH_var_DASH_root := lang.NewSymbol("alter-var-root")
	sym_anything := lang.NewSymbol("anything")
	sym_apply := lang.NewSymbol("apply")
	sym_arr := lang.NewSymbol("arr")
	sym_ascii_DASH_alpha := lang.NewSymbol("ascii-alpha")
	sym_aset := lang.NewSymbol("aset")
	sym_assoc_BANG_ := lang.NewSymbol("assoc!")
	sym_boolean := lang.NewSymbol("boolean")
	sym_boolean_DASH_array := lang.NewSymbol("boolean-array")
	sym_byte := lang.NewSymbol("byte")
	sym_byte_DASH_array := lang.NewSymbol("byte-array")
	sym_call_DASH_through := lang.NewSymbol("call-through")
	sym_char := lang.NewSymbol("char")
	sym_char_DASH_array := lang.NewSymbol("char-array")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_core_SLASH_aset := lang.NewSymbol("clojure.core/aset")
	sym_clojure_DOT_core_SLASH_count := lang.NewSymbol("clojure.core/count")
	sym_clojure_DOT_core_SLASH_defn := lang.NewSymbol("clojure.core/defn")
	sym_clojure_DOT_core_SLASH_dotimes := lang.NewSymbol("clojure.core/dotimes")
	sym_clojure_DOT_core_SLASH_let := lang.NewSymbol("clojure.core/let")
	sym_clojure_DOT_data_DOT_generators := lang.NewSymbol("clojure.data.generators")
	sym_clojure_DOT_data_DOT_generators_SLASH_call_DASH_through := lang.NewSymbol("clojure.data.generators/call-through")
	sym_clojure_DOT_data_DOT_generators_SLASH_default_DASH_sizer := lang.NewSymbol("clojure.data.generators/default-sizer")
	sym_clojure_DOT_data_DOT_generators_SLASH_primitive_DASH_array := lang.NewSymbol("clojure.data.generators/primitive-array")
	sym_coll := lang.NewSymbol("coll")
	sym_collection := lang.NewSymbol("collection")
	sym_collections := lang.NewSymbol("collections")
	sym_concat := lang.NewSymbol("concat")
	sym_constantly := lang.NewSymbol("constantly")
	sym_count := lang.NewSymbol("count")
	sym_ct := lang.NewSymbol("ct")
	sym_dec := lang.NewSymbol("dec")
	sym_default_DASH_sizer := lang.NewSymbol("default-sizer")
	sym_denom_DASH_gen := lang.NewSymbol("denom-gen")
	sym_do := lang.NewSymbol("do")
	sym_double := lang.NewSymbol("double")
	sym_double_DASH_array := lang.NewSymbol("double-array")
	sym_drop := lang.NewSymbol("drop")
	sym_empty := lang.NewSymbol("empty")
	sym_f := lang.NewSymbol("f")
	sym_first := lang.NewSymbol("first")
	sym_fisher_DASH_yates := lang.NewSymbol("fisher-yates")
	sym_fk := lang.NewSymbol("fk")
	sym_float := lang.NewSymbol("float")
	sym_float_DASH_array := lang.NewSymbol("float-array")
	sym_fn_QMARK_ := lang.NewSymbol("fn?")
	sym_fv := lang.NewSymbol("fv")
	sym_generators := lang.NewSymbol("generators")
	sym_geometric := lang.NewSymbol("geometric")
	sym_hash_DASH_map := lang.NewSymbol("hash-map")
	sym_hi := lang.NewSymbol("hi")
	sym_i := lang.NewSymbol("i")
	sym_inc := lang.NewSymbol("inc")
	sym_int := lang.NewSymbol("int")
	sym_int_DASH_array := lang.NewSymbol("int-array")
	sym_into := lang.NewSymbol("into")
	sym_keys := lang.NewSymbol("keys")
	sym_keyword := lang.NewSymbol("keyword")
	sym_last := lang.NewSymbol("last")
	sym_list := lang.NewSymbol("list")
	sym_lo := lang.NewSymbol("lo")
	sym_long := lang.NewSymbol("long")
	sym_long_DASH_array := lang.NewSymbol("long-array")
	sym_m := lang.NewSymbol("m")
	sym_map := lang.NewSymbol("map")
	sym_name := lang.NewSymbol("name")
	sym_name_DASH_body := lang.NewSymbol("name-body")
	sym_name_DASH_prefix := lang.NewSymbol("name-prefix")
	sym_next := lang.NewSymbol("next")
	sym_nth := lang.NewSymbol("nth")
	sym_num_DASH_gen := lang.NewSymbol("num-gen")
	sym_object_DASH_array := lang.NewSymbol("object-array")
	sym_one_DASH_of := lang.NewSymbol("one-of")
	sym_p := lang.NewSymbol("p")
	sym_persistent_BANG_ := lang.NewSymbol("persistent!")
	sym_primitive_DASH_array := lang.NewSymbol("primitive-array")
	sym_primitive_DASH_arrays := lang.NewSymbol("primitive-arrays")
	sym_printable_DASH_ascii_DASH_char := lang.NewSymbol("printable-ascii-char")
	sym_rand_DASH_nth := lang.NewSymbol("rand-nth")
	sym_ratio := lang.NewSymbol("ratio")
	sym_reductions := lang.NewSymbol("reductions")
	sym_repeat := lang.NewSymbol("repeat")
	sym_repeatedly := lang.NewSymbol("repeatedly")
	sym_reps := lang.NewSymbol("reps")
	sym_reservoir_DASH_sample := lang.NewSymbol("reservoir-sample")
	sym_rest := lang.NewSymbol("rest")
	sym_scalar := lang.NewSymbol("scalar")
	sym_scalars := lang.NewSymbol("scalars")
	sym_seq := lang.NewSymbol("seq")
	sym_set := lang.NewSymbol("set")
	sym_short := lang.NewSymbol("short")
	sym_short_DASH_array := lang.NewSymbol("short-array")
	sym_shuffle := lang.NewSymbol("shuffle")
	sym_sizer := lang.NewSymbol("sizer")
	sym_specs := lang.NewSymbol("specs")
	sym_str := lang.NewSymbol("str")
	sym_string := lang.NewSymbol("string")
	sym_symbol := lang.NewSymbol("symbol")
	sym_symbol_DASH_char := lang.NewSymbol("symbol-char")
	sym_symbol_DASH_start := lang.NewSymbol("symbol-start")
	sym_take := lang.NewSymbol("take")
	sym_transient := lang.NewSymbol("transient")
	sym_tuple := lang.NewSymbol("tuple")
	sym_type := lang.NewSymbol("type")
	sym_types := lang.NewSymbol("types")
	sym_unchecked_DASH_inc := lang.NewSymbol("unchecked-inc")
	sym_uniform := lang.NewSymbol("uniform")
	sym_vals := lang.NewSymbol("vals")
	sym_vec := lang.NewSymbol("vec")
	sym_vector := lang.NewSymbol("vector")
	sym_weighted := lang.NewSymbol("weighted")
	sym_x := lang.NewSymbol("x")
	sym_zipmap := lang.NewSymbol("zipmap")
	kw_arglists := lang.NewKeyword("arglists")
	kw_column := lang.NewKeyword("column")
	kw_doc := lang.NewKeyword("doc")
	kw_dynamic := lang.NewKeyword("dynamic")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_macro := lang.NewKeyword("macro")
	kw_ns := lang.NewKeyword("ns")
	kw_private := lang.NewKeyword("private")
	kw_rettag := lang.NewKeyword("rettag")
	// var clojure.core/-
	var_clojure_DOT_core__DASH_ := lang.InternVarName(sym_clojure_DOT_core, sym__DASH_)
	// var clojure.core/<
	var_clojure_DOT_core__LT_ := lang.InternVarName(sym_clojure_DOT_core, sym__LT_)
	// var clojure.core/<=
	var_clojure_DOT_core__LT__EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym__LT__EQ_)
	// var clojure.core/+
	var_clojure_DOT_core__PLUS_ := lang.InternVarName(sym_clojure_DOT_core, sym__PLUS_)
	// var clojure.core//
	var_clojure_DOT_core__SLASH_ := lang.InternVarName(sym_clojure_DOT_core, sym__SLASH_)
	// var clojure.core/*
	var_clojure_DOT_core__STAR_ := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_)
	// var clojure.core/aget
	var_clojure_DOT_core_aget := lang.InternVarName(sym_clojure_DOT_core, sym_aget)
	// var clojure.core/alter-var-root
	var_clojure_DOT_core_alter_DASH_var_DASH_root := lang.InternVarName(sym_clojure_DOT_core, sym_alter_DASH_var_DASH_root)
	// var clojure.core/apply
	var_clojure_DOT_core_apply := lang.InternVarName(sym_clojure_DOT_core, sym_apply)
	// var clojure.core/aset
	var_clojure_DOT_core_aset := lang.InternVarName(sym_clojure_DOT_core, sym_aset)
	// var clojure.core/assoc!
	var_clojure_DOT_core_assoc_BANG_ := lang.InternVarName(sym_clojure_DOT_core, sym_assoc_BANG_)
	// var clojure.core/boolean
	var_clojure_DOT_core_boolean := lang.InternVarName(sym_clojure_DOT_core, sym_boolean)
	// var clojure.core/boolean-array
	var_clojure_DOT_core_boolean_DASH_array := lang.InternVarName(sym_clojure_DOT_core, sym_boolean_DASH_array)
	// var clojure.core/byte
	var_clojure_DOT_core_byte := lang.InternVarName(sym_clojure_DOT_core, sym_byte)
	// var clojure.core/byte-array
	var_clojure_DOT_core_byte_DASH_array := lang.InternVarName(sym_clojure_DOT_core, sym_byte_DASH_array)
	// var clojure.core/char
	var_clojure_DOT_core_char := lang.InternVarName(sym_clojure_DOT_core, sym_char)
	// var clojure.core/char-array
	var_clojure_DOT_core_char_DASH_array := lang.InternVarName(sym_clojure_DOT_core, sym_char_DASH_array)
	// var clojure.core/concat
	var_clojure_DOT_core_concat := lang.InternVarName(sym_clojure_DOT_core, sym_concat)
	// var clojure.core/constantly
	var_clojure_DOT_core_constantly := lang.InternVarName(sym_clojure_DOT_core, sym_constantly)
	// var clojure.core/count
	var_clojure_DOT_core_count := lang.InternVarName(sym_clojure_DOT_core, sym_count)
	// var clojure.core/dec
	var_clojure_DOT_core_dec := lang.InternVarName(sym_clojure_DOT_core, sym_dec)
	// var clojure.core/double
	var_clojure_DOT_core_double := lang.InternVarName(sym_clojure_DOT_core, sym_double)
	// var clojure.core/double-array
	var_clojure_DOT_core_double_DASH_array := lang.InternVarName(sym_clojure_DOT_core, sym_double_DASH_array)
	// var clojure.core/drop
	var_clojure_DOT_core_drop := lang.InternVarName(sym_clojure_DOT_core, sym_drop)
	// var clojure.core/empty
	var_clojure_DOT_core_empty := lang.InternVarName(sym_clojure_DOT_core, sym_empty)
	// var clojure.core/first
	var_clojure_DOT_core_first := lang.InternVarName(sym_clojure_DOT_core, sym_first)
	// var clojure.core/float
	var_clojure_DOT_core_float := lang.InternVarName(sym_clojure_DOT_core, sym_float)
	// var clojure.core/float-array
	var_clojure_DOT_core_float_DASH_array := lang.InternVarName(sym_clojure_DOT_core, sym_float_DASH_array)
	// var clojure.core/fn?
	var_clojure_DOT_core_fn_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_fn_QMARK_)
	// var clojure.core/inc
	var_clojure_DOT_core_inc := lang.InternVarName(sym_clojure_DOT_core, sym_inc)
	// var clojure.core/int
	var_clojure_DOT_core_int := lang.InternVarName(sym_clojure_DOT_core, sym_int)
	// var clojure.core/int-array
	var_clojure_DOT_core_int_DASH_array := lang.InternVarName(sym_clojure_DOT_core, sym_int_DASH_array)
	// var clojure.core/into
	var_clojure_DOT_core_into := lang.InternVarName(sym_clojure_DOT_core, sym_into)
	// var clojure.core/keys
	var_clojure_DOT_core_keys := lang.InternVarName(sym_clojure_DOT_core, sym_keys)
	// var clojure.core/keyword
	var_clojure_DOT_core_keyword := lang.InternVarName(sym_clojure_DOT_core, sym_keyword)
	// var clojure.core/last
	var_clojure_DOT_core_last := lang.InternVarName(sym_clojure_DOT_core, sym_last)
	// var clojure.core/list
	var_clojure_DOT_core_list := lang.InternVarName(sym_clojure_DOT_core, sym_list)
	// var clojure.core/long
	var_clojure_DOT_core_long := lang.InternVarName(sym_clojure_DOT_core, sym_long)
	// var clojure.core/long-array
	var_clojure_DOT_core_long_DASH_array := lang.InternVarName(sym_clojure_DOT_core, sym_long_DASH_array)
	// var clojure.core/map
	var_clojure_DOT_core_map := lang.InternVarName(sym_clojure_DOT_core, sym_map)
	// var clojure.core/next
	var_clojure_DOT_core_next := lang.InternVarName(sym_clojure_DOT_core, sym_next)
	// var clojure.core/nth
	var_clojure_DOT_core_nth := lang.InternVarName(sym_clojure_DOT_core, sym_nth)
	// var clojure.core/object-array
	var_clojure_DOT_core_object_DASH_array := lang.InternVarName(sym_clojure_DOT_core, sym_object_DASH_array)
	// var clojure.core/persistent!
	var_clojure_DOT_core_persistent_BANG_ := lang.InternVarName(sym_clojure_DOT_core, sym_persistent_BANG_)
	// var clojure.core/reductions
	var_clojure_DOT_core_reductions := lang.InternVarName(sym_clojure_DOT_core, sym_reductions)
	// var clojure.core/repeat
	var_clojure_DOT_core_repeat := lang.InternVarName(sym_clojure_DOT_core, sym_repeat)
	// var clojure.core/repeatedly
	var_clojure_DOT_core_repeatedly := lang.InternVarName(sym_clojure_DOT_core, sym_repeatedly)
	// var clojure.core/rest
	var_clojure_DOT_core_rest := lang.InternVarName(sym_clojure_DOT_core, sym_rest)
	// var clojure.core/seq
	var_clojure_DOT_core_seq := lang.InternVarName(sym_clojure_DOT_core, sym_seq)
	// var clojure.core/short
	var_clojure_DOT_core_short := lang.InternVarName(sym_clojure_DOT_core, sym_short)
	// var clojure.core/short-array
	var_clojure_DOT_core_short_DASH_array := lang.InternVarName(sym_clojure_DOT_core, sym_short_DASH_array)
	// var clojure.core/str
	var_clojure_DOT_core_str := lang.InternVarName(sym_clojure_DOT_core, sym_str)
	// var clojure.core/symbol
	var_clojure_DOT_core_symbol := lang.InternVarName(sym_clojure_DOT_core, sym_symbol)
	// var clojure.core/take
	var_clojure_DOT_core_take := lang.InternVarName(sym_clojure_DOT_core, sym_take)
	// var clojure.core/transient
	var_clojure_DOT_core_transient := lang.InternVarName(sym_clojure_DOT_core, sym_transient)
	// var clojure.core/unchecked-inc
	var_clojure_DOT_core_unchecked_DASH_inc := lang.InternVarName(sym_clojure_DOT_core, sym_unchecked_DASH_inc)
	// var clojure.core/vals
	var_clojure_DOT_core_vals := lang.InternVarName(sym_clojure_DOT_core, sym_vals)
	// var clojure.core/vec
	var_clojure_DOT_core_vec := lang.InternVarName(sym_clojure_DOT_core, sym_vec)
	// var clojure.core/vector
	var_clojure_DOT_core_vector := lang.InternVarName(sym_clojure_DOT_core, sym_vector)
	// var clojure.core/zipmap
	var_clojure_DOT_core_zipmap := lang.InternVarName(sym_clojure_DOT_core, sym_zipmap)
	// var clojure.data.generators/*rnd*
	var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR_ := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym__STAR_rnd_STAR_)
	// var clojure.data.generators/*rnd*-
	var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_ := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym__STAR_rnd_STAR__DASH_)
	// var clojure.data.generators/anything
	var_clojure_DOT_data_DOT_generators_anything := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_anything)
	// var clojure.data.generators/ascii-alpha
	var_clojure_DOT_data_DOT_generators_ascii_DASH_alpha := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_ascii_DASH_alpha)
	// var clojure.data.generators/boolean
	var_clojure_DOT_data_DOT_generators_boolean := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_boolean)
	// var clojure.data.generators/boolean-array
	var_clojure_DOT_data_DOT_generators_boolean_DASH_array := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_boolean_DASH_array)
	// var clojure.data.generators/byte
	var_clojure_DOT_data_DOT_generators_byte := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_byte)
	// var clojure.data.generators/byte-array
	var_clojure_DOT_data_DOT_generators_byte_DASH_array := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_byte_DASH_array)
	// var clojure.data.generators/call-through
	var_clojure_DOT_data_DOT_generators_call_DASH_through := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_call_DASH_through)
	// var clojure.data.generators/char
	var_clojure_DOT_data_DOT_generators_char := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_char)
	// var clojure.data.generators/char-array
	var_clojure_DOT_data_DOT_generators_char_DASH_array := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_char_DASH_array)
	// var clojure.data.generators/collection
	var_clojure_DOT_data_DOT_generators_collection := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_collection)
	// var clojure.data.generators/collections
	var_clojure_DOT_data_DOT_generators_collections := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_collections)
	// var clojure.data.generators/default-sizer
	var_clojure_DOT_data_DOT_generators_default_DASH_sizer := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_default_DASH_sizer)
	// var clojure.data.generators/double
	var_clojure_DOT_data_DOT_generators_double := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_double)
	// var clojure.data.generators/double-array
	var_clojure_DOT_data_DOT_generators_double_DASH_array := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_double_DASH_array)
	// var clojure.data.generators/fisher-yates
	var_clojure_DOT_data_DOT_generators_fisher_DASH_yates := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_fisher_DASH_yates)
	// var clojure.data.generators/float
	var_clojure_DOT_data_DOT_generators_float := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_float)
	// var clojure.data.generators/float-array
	var_clojure_DOT_data_DOT_generators_float_DASH_array := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_float_DASH_array)
	// var clojure.data.generators/geometric
	var_clojure_DOT_data_DOT_generators_geometric := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_geometric)
	// var clojure.data.generators/hash-map
	var_clojure_DOT_data_DOT_generators_hash_DASH_map := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_hash_DASH_map)
	// var clojure.data.generators/int
	var_clojure_DOT_data_DOT_generators_int := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_int)
	// var clojure.data.generators/int-array
	var_clojure_DOT_data_DOT_generators_int_DASH_array := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_int_DASH_array)
	// var clojure.data.generators/keyword
	var_clojure_DOT_data_DOT_generators_keyword := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_keyword)
	// var clojure.data.generators/list
	var_clojure_DOT_data_DOT_generators_list := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_list)
	// var clojure.data.generators/long
	var_clojure_DOT_data_DOT_generators_long := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_long)
	// var clojure.data.generators/long-array
	var_clojure_DOT_data_DOT_generators_long_DASH_array := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_long_DASH_array)
	// var clojure.data.generators/name
	var_clojure_DOT_data_DOT_generators_name := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_name)
	// var clojure.data.generators/name-body
	var_clojure_DOT_data_DOT_generators_name_DASH_body := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_name_DASH_body)
	// var clojure.data.generators/name-prefix
	var_clojure_DOT_data_DOT_generators_name_DASH_prefix := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_name_DASH_prefix)
	// var clojure.data.generators/one-of
	var_clojure_DOT_data_DOT_generators_one_DASH_of := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_one_DASH_of)
	// var clojure.data.generators/primitive-array
	var_clojure_DOT_data_DOT_generators_primitive_DASH_array := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_primitive_DASH_array)
	// var clojure.data.generators/primitive-arrays
	var_clojure_DOT_data_DOT_generators_primitive_DASH_arrays := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_primitive_DASH_arrays)
	// var clojure.data.generators/printable-ascii-char
	var_clojure_DOT_data_DOT_generators_printable_DASH_ascii_DASH_char := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_printable_DASH_ascii_DASH_char)
	// var clojure.data.generators/rand-nth
	var_clojure_DOT_data_DOT_generators_rand_DASH_nth := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_rand_DASH_nth)
	// var clojure.data.generators/ratio
	var_clojure_DOT_data_DOT_generators_ratio := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_ratio)
	// var clojure.data.generators/reps
	var_clojure_DOT_data_DOT_generators_reps := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_reps)
	// var clojure.data.generators/reservoir-sample
	var_clojure_DOT_data_DOT_generators_reservoir_DASH_sample := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_reservoir_DASH_sample)
	// var clojure.data.generators/scalar
	var_clojure_DOT_data_DOT_generators_scalar := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_scalar)
	// var clojure.data.generators/scalars
	var_clojure_DOT_data_DOT_generators_scalars := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_scalars)
	// var clojure.data.generators/set
	var_clojure_DOT_data_DOT_generators_set := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_set)
	// var clojure.data.generators/short
	var_clojure_DOT_data_DOT_generators_short := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_short)
	// var clojure.data.generators/short-array
	var_clojure_DOT_data_DOT_generators_short_DASH_array := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_short_DASH_array)
	// var clojure.data.generators/shuffle
	var_clojure_DOT_data_DOT_generators_shuffle := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_shuffle)
	// var clojure.data.generators/string
	var_clojure_DOT_data_DOT_generators_string := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_string)
	// var clojure.data.generators/symbol
	var_clojure_DOT_data_DOT_generators_symbol := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_symbol)
	// var clojure.data.generators/symbol-char
	var_clojure_DOT_data_DOT_generators_symbol_DASH_char := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_symbol_DASH_char)
	// var clojure.data.generators/symbol-start
	var_clojure_DOT_data_DOT_generators_symbol_DASH_start := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_symbol_DASH_start)
	// var clojure.data.generators/tuple
	var_clojure_DOT_data_DOT_generators_tuple := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_tuple)
	// var clojure.data.generators/uniform
	var_clojure_DOT_data_DOT_generators_uniform := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_uniform)
	// var clojure.data.generators/vec
	var_clojure_DOT_data_DOT_generators_vec := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_vec)
	// var clojure.data.generators/weighted
	var_clojure_DOT_data_DOT_generators_weighted := lang.InternVarName(sym_clojure_DOT_data_DOT_generators, sym_weighted)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators)
	_ = ns
	var closed0 any
	{
		closed0 = nil
	}
	// *rnd*
	{
		tmp0 := sym__STAR_rnd_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "clojure/data/generators.glj", kw_line, int(18), kw_column, int(6), kw_end_DASH_line, int(19), kw_end_DASH_column, int(7), kw_doc, "Random instance for use in generators. By consistently using this\ninstance you can get a repeatable basis for tests.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR_ = ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
		var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR_.SetDynamic()
	}
	// ascii-alpha
	{
		tmp0 := sym_ascii_DASH_alpha.WithMeta(lang.NewMap(kw_private, true, kw_file, "clojure/data/generators.glj", kw_line, int(220), kw_column, int(6), kw_end_DASH_line, int(220), kw_end_DASH_column, int(26), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var_clojure_DOT_data_DOT_generators_ascii_DASH_alpha = ns.InternWithValue(tmp0, lang.NewList(int64(65), int64(66), int64(67), int64(68), int64(69), int64(70), int64(71), int64(72), int64(73), int64(74), int64(75), int64(76), int64(77), int64(78), int64(79), int64(80), int64(81), int64(82), int64(83), int64(84), int64(85), int64(86), int64(87), int64(88), int64(89), int64(90), int64(97), int64(98), int64(99), int64(100), int64(101), int64(102), int64(103), int64(104), int64(105), int64(106), int64(107), int64(108), int64(109), int64(110), int64(111), int64(112), int64(113), int64(114), int64(115), int64(116), int64(117), int64(118), int64(119), int64(120), int64(121), int64(122)), true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_ascii_DASH_alpha.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// symbol-char
	{
		tmp0 := sym_symbol_DASH_char.WithMeta(lang.NewMap(kw_private, true, kw_file, "clojure/data/generators.glj", kw_line, int(228), kw_column, int(6), kw_end_DASH_line, int(228), kw_end_DASH_column, int(26), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var_clojure_DOT_data_DOT_generators_symbol_DASH_char = ns.InternWithValue(tmp0, lang.NewVector(int64(65), int64(66), int64(67), int64(68), int64(69), int64(70), int64(71), int64(72), int64(73), int64(74), int64(75), int64(76), int64(77), int64(78), int64(79), int64(80), int64(81), int64(82), int64(83), int64(84), int64(85), int64(86), int64(87), int64(88), int64(89), int64(90), int64(97), int64(98), int64(99), int64(100), int64(101), int64(102), int64(103), int64(104), int64(105), int64(106), int64(107), int64(108), int64(109), int64(110), int64(111), int64(112), int64(113), int64(114), int64(115), int64(116), int64(117), int64(118), int64(119), int64(120), int64(121), int64(122), lang.NewChar(42), lang.NewChar(43), lang.NewChar(33), lang.NewChar(45), lang.NewChar(95), lang.NewChar(63), lang.NewChar(49), lang.NewChar(50), lang.NewChar(51), lang.NewChar(52), lang.NewChar(53), lang.NewChar(54), lang.NewChar(55), lang.NewChar(56), lang.NewChar(57), lang.NewChar(48)), true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_symbol_DASH_char.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// symbol-start
	{
		tmp0 := sym_symbol_DASH_start.WithMeta(lang.NewMap(kw_private, true, kw_file, "clojure/data/generators.glj", kw_line, int(224), kw_column, int(6), kw_end_DASH_line, int(224), kw_end_DASH_column, int(27), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var_clojure_DOT_data_DOT_generators_symbol_DASH_start = ns.InternWithValue(tmp0, lang.NewVector(int64(65), int64(66), int64(67), int64(68), int64(69), int64(70), int64(71), int64(72), int64(73), int64(74), int64(75), int64(76), int64(77), int64(78), int64(79), int64(80), int64(81), int64(82), int64(83), int64(84), int64(85), int64(86), int64(87), int64(88), int64(89), int64(90), int64(97), int64(98), int64(99), int64(100), int64(101), int64(102), int64(103), int64(104), int64(105), int64(106), int64(107), int64(108), int64(109), int64(110), int64(111), int64(112), int64(113), int64(114), int64(115), int64(116), int64(117), int64(118), int64(119), int64(120), int64(121), int64(122), lang.NewChar(42), lang.NewChar(43), lang.NewChar(33), lang.NewChar(45), lang.NewChar(95), lang.NewChar(63)), true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_symbol_DASH_start.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *rnd*-
	{
		tmp0 := sym__STAR_rnd_STAR__DASH_.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(24), kw_column, int(7), kw_end_DASH_line, int(24), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector()), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			var tmp2 any
			{ // let
				// let binding "or__0__auto__"
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR_)
				var v4 any = tmp3
				_ = v4
				var tmp5 any
				if lang.IsTruthy(v4) {
					tmp5 = v4
				} else {
					tmp6 := checkDerefVar(var_clojure_DOT_core_alter_DASH_var_DASH_root)
					tmp7 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR_)
					tmp8 := checkDerefVar(var_clojure_DOT_core_constantly)
					tmp9 := lang.Apply(rand4.NewSource, []any{int64(42)})
					tmp10 := lang.Apply(rand4.New, []any{tmp9})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					tmp12 := lang.Apply(tmp6, []any{tmp7, tmp11})
					tmp5 = tmp12
				}
				tmp2 = tmp5
			} // end let
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean
	{
		tmp0 := sym_boolean.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(123), kw_column, int(7), kw_end_DASH_line, int(123), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a bool based on *rnd*.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
			tmp3 := lang.Apply(tmp2, nil)
			tmp4, ok := lang.FieldOrMethod(tmp3, "nextBoolean")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp3, "nextBoolean")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_boolean = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_boolean.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double
	{
		tmp0 := sym_double.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(63), kw_column, int(7), kw_end_DASH_line, int(63), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Generate a double between 0 and 1 based on *rnd*.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
			tmp3 := lang.Apply(tmp2, nil)
			tmp4, ok := lang.FieldOrMethod(tmp3, "nextDouble")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp3, "nextDouble")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_double = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_double.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float
	{
		tmp0 := sym_float.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(58), kw_column, int(7), kw_end_DASH_line, int(58), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Generate a float between 0 and 1 based on *rnd*", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
			tmp3 := lang.Apply(tmp2, nil)
			tmp4, ok := lang.FieldOrMethod(tmp3, "nextFloat")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp3, "nextFloat")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_float = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_float.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// anything
	{
		tmp0 := sym_anything.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(303), kw_column, int(7), kw_end_DASH_line, int(303), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a scalar or collection based on *rnd*.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators_one_DASH_of)
			tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_scalar)
			tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_collection)
			tmp5 := lang.Apply(tmp2, []any{tmp3, tmp4})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_anything = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_anything.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean-array
	{
		tmp0 := sym_boolean_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_doc, "Create an array with elements from f and sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_boolean_DASH_array)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "arr"
					tmp5 := checkDerefVar(var_clojure_DOT_core_boolean_DASH_array)
					tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
					tmp7 := lang.Apply(tmp6, []any{v3})
					tmp8 := lang.Apply(tmp5, []any{tmp7})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					{ // let
						// let binding "n__0__auto__"
						tmp11 := checkDerefVar(var_clojure_DOT_core_long)
						tmp12 := checkDerefVar(var_clojure_DOT_core_count)
						tmp13 := lang.Apply(tmp12, []any{v9})
						tmp14 := lang.Apply(tmp11, []any{tmp13})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						{ // let
							// let binding "i"
							var v17 any = int64(0)
							_ = v17
							for {
								var tmp18 any
								tmp19 := checkDerefVar(var_clojure_DOT_core__LT_)
								tmp20 := lang.Apply(tmp19, []any{v17, v15})
								if lang.IsTruthy(tmp20) {
									tmp21 := checkDerefVar(var_clojure_DOT_core_aset)
									tmp22 := checkDerefVar(var_clojure_DOT_core_boolean)
									tmp23 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
									tmp24 := lang.Apply(tmp23, []any{v2})
									tmp25 := lang.Apply(tmp22, []any{tmp24})
									tmp26 := lang.Apply(tmp21, []any{v9, v17, tmp25})
									_ = tmp26
									tmp28 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
									tmp29 := lang.Apply(tmp28, []any{v17})
									var tmp27 any = tmp29
									v17 = tmp27
									continue
								} else {
								}
								tmp16 = tmp18
								break
							}
						} // end let
						tmp10 = tmp16
					} // end let
					_ = tmp10
					tmp4 = v9
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_boolean_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_boolean_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// byte
	{
		tmp0 := sym_byte.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(118), kw_column, int(7), kw_end_DASH_line, int(118), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a long based on *rnd* in the byte range.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp3 := checkDerefVar(var_clojure_DOT_core_inc)
			tmp4 := checkDerefVar(var_clojure_DOT_core_int)
			tmp5 := lang.Apply(tmp4, []any{nil})
			tmp6 := lang.Apply(tmp3, []any{tmp5})
			tmp7 := lang.Apply(tmp2, []any{nil, tmp6})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_byte = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_byte.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// byte-array
	{
		tmp0 := sym_byte_DASH_array.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(171), kw_column, int(7), kw_end_DASH_line, int(171), kw_end_DASH_column, int(16), kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_byte_DASH_array)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "arr"
					tmp5 := checkDerefVar(var_clojure_DOT_core_byte_DASH_array)
					tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
					tmp7 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
					tmp8 := lang.Apply(tmp6, []any{tmp7})
					tmp9 := lang.Apply(tmp5, []any{tmp8})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					{ // let
						// let binding "n__0__auto__"
						tmp12 := checkDerefVar(var_clojure_DOT_core_long)
						tmp13 := checkDerefVar(var_clojure_DOT_core_count)
						tmp14 := lang.Apply(tmp13, []any{v10})
						tmp15 := lang.Apply(tmp12, []any{tmp14})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						{ // let
							// let binding "i"
							var v18 any = int64(0)
							_ = v18
							for {
								var tmp19 any
								tmp20 := checkDerefVar(var_clojure_DOT_core__LT_)
								tmp21 := lang.Apply(tmp20, []any{v18, v16})
								if lang.IsTruthy(tmp21) {
									tmp22 := checkDerefVar(var_clojure_DOT_core_aset)
									tmp23 := checkDerefVar(var_clojure_DOT_core_byte)
									tmp24 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
									tmp25 := lang.Apply(tmp24, []any{v2})
									tmp26 := lang.Apply(tmp23, []any{tmp25})
									tmp27 := lang.Apply(tmp22, []any{v10, v18, tmp26})
									_ = tmp27
									tmp29 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
									tmp30 := lang.Apply(tmp29, []any{v18})
									var tmp28 any = tmp30
									v18 = tmp28
									continue
								} else {
								}
								tmp17 = tmp19
								break
							}
						} // end let
						tmp11 = tmp17
					} // end let
					_ = tmp11
					tmp4 = v10
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_byte_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_byte_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// call-through
	{
		tmp0 := sym_call_DASH_through.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Recursively call x until it doesn't return a function.", kw_file, "clojure/data/generators.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators), kw_end_DASH_column, int(19), kw_column, int(8), kw_line, int(30), kw_end_DASH_line, int(30), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
		recur_loop_3079:
			var tmp3 any
			tmp4 := checkDerefVar(var_clojure_DOT_core_fn_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp7 := lang.Apply(v2, nil)
				var tmp6 any = tmp7
				v2 = tmp6
				goto recur_loop_3079
			} else {
				tmp3 = v2
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_call_DASH_through = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_call_DASH_through.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char
	{
		tmp0 := sym_char.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(133), kw_column, int(7), kw_end_DASH_line, int(133), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a character based on *rnd* in the range 0-65536.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_core_char)
			tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp4 := lang.Apply(tmp3, []any{int64(0), int64(65536)})
			tmp5 := lang.Apply(tmp2, []any{tmp4})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_char = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_char.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-array
	{
		tmp0 := sym_char_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_doc, "Create an array with elements from f and sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_char_DASH_array)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "arr"
					tmp5 := checkDerefVar(var_clojure_DOT_core_char_DASH_array)
					tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
					tmp7 := lang.Apply(tmp6, []any{v3})
					tmp8 := lang.Apply(tmp5, []any{tmp7})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					{ // let
						// let binding "n__0__auto__"
						tmp11 := checkDerefVar(var_clojure_DOT_core_long)
						tmp12 := checkDerefVar(var_clojure_DOT_core_count)
						tmp13 := lang.Apply(tmp12, []any{v9})
						tmp14 := lang.Apply(tmp11, []any{tmp13})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						{ // let
							// let binding "i"
							var v17 any = int64(0)
							_ = v17
							for {
								var tmp18 any
								tmp19 := checkDerefVar(var_clojure_DOT_core__LT_)
								tmp20 := lang.Apply(tmp19, []any{v17, v15})
								if lang.IsTruthy(tmp20) {
									tmp21 := checkDerefVar(var_clojure_DOT_core_aset)
									tmp22 := checkDerefVar(var_clojure_DOT_core_char)
									tmp23 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
									tmp24 := lang.Apply(tmp23, []any{v2})
									tmp25 := lang.Apply(tmp22, []any{tmp24})
									tmp26 := lang.Apply(tmp21, []any{v9, v17, tmp25})
									_ = tmp26
									tmp28 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
									tmp29 := lang.Apply(tmp28, []any{v17})
									var tmp27 any = tmp29
									v17 = tmp27
									continue
								} else {
								}
								tmp16 = tmp18
								break
							}
						} // end let
						tmp10 = tmp16
					} // end let
					_ = tmp10
					tmp4 = v9
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_char_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_char_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// collection
	{
		tmp0 := sym_collection.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(297), kw_column, int(7), kw_end_DASH_line, int(297), kw_end_DASH_column, int(16), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a collection of scalar elements based on *rnd*.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			var tmp2 any
			{ // let
				// let binding "vec__1037"
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_rand_DASH_nth)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_collections)
				tmp5 := lang.Apply(tmp3, []any{tmp4})
				var v6 any = tmp5
				_ = v6
				// let binding "coll"
				tmp7 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp8 := lang.Apply(tmp7, []any{v6, int64(0), nil})
				var v9 any = tmp8
				_ = v9
				// let binding "args"
				tmp10 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp11 := lang.Apply(tmp10, []any{v6, int64(1), nil})
				var v12 any = tmp11
				_ = v12
				tmp13 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp14 := checkDerefVar(var_clojure_DOT_core_map)
				tmp15 := checkDerefVar(var_clojure_DOT_data_DOT_generators_rand_DASH_nth)
				tmp16 := lang.Apply(tmp14, []any{tmp15, v12})
				tmp17 := lang.Apply(tmp13, []any{v9, tmp16})
				tmp2 = tmp17
			} // end let
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_collection = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_collection.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// collections
	{
		tmp0 := sym_collections.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(292), kw_column, int(6), kw_end_DASH_line, int(292), kw_end_DASH_column, int(16), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_vec)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_into)
				tmp5 := lang.NewVector()
				tmp6 := lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(197), kw_column, int(12), kw_end_DASH_line, int(197), kw_end_DASH_column, int(13))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp9 := lang.Apply(tmp8, []any{v3, v2})
				tmp10 := lang.Apply(tmp4, []any{tmp7, tmp9})
				return tmp10
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v3 any
				if len(restArgs) > 0 {
					v3 = lang.NewList(restArgs...)
				}
				_ = v3
				return closed0
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(1443), kw_column, int(7), kw_end_DASH_line, int(1443), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp5 := checkDerefVar(var_clojure_DOT_core_inc)
			tmp6 := checkDerefVar(var_clojure_DOT_core_int)
			tmp7 := lang.Apply(tmp6, []any{nil})
			tmp8 := lang.Apply(tmp5, []any{tmp7})
			tmp9 := lang.Apply(tmp4, []any{nil, tmp8})
			return tmp9
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp5 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp6 := lang.Apply(tmp5, nil)
				tmp7, ok := lang.FieldOrMethod(tmp6, "nextLong")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp6, "nextLong")))
				}
				var tmp8 any
				switch reflect.TypeOf(tmp7).Kind() {
				case reflect.Func:
					tmp8 = lang.Apply(tmp7, nil)
				default:
					tmp8 = tmp7
				}
				return tmp8
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7 := checkDerefVar(var_clojure_DOT_core_long)
				tmp8 := checkDerefVar(var_clojure_DOT_core__PLUS_)
				tmp9 := checkDerefVar(var_clojure_DOT_core__STAR_)
				tmp10 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp11 := lang.Apply(tmp10, nil)
				tmp12, ok := lang.FieldOrMethod(tmp11, "nextDouble")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp11, "nextDouble")))
				}
				var tmp13 any
				switch reflect.TypeOf(tmp12).Kind() {
				case reflect.Func:
					tmp13 = lang.Apply(tmp12, nil)
				default:
					tmp13 = tmp12
				}
				tmp14 := checkDerefVar(var_clojure_DOT_core__DASH_)
				tmp15 := lang.Apply(tmp14, []any{v6, v5})
				tmp16 := lang.Apply(tmp9, []any{tmp13, tmp15})
				tmp17 := lang.Apply(tmp8, []any{v5, tmp16})
				tmp18 := lang.Apply(nil, []any{tmp17})
				tmp19 := lang.Apply(tmp7, []any{tmp18})
				return tmp19
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
			tmp7 := lang.Apply(tmp6, nil)
			tmp8, ok := lang.FieldOrMethod(tmp7, "nextBoolean")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp7, "nextBoolean")))
			}
			var tmp9 any
			switch reflect.TypeOf(tmp8).Kind() {
			case reflect.Func:
				tmp9 = lang.Apply(tmp8, nil)
			default:
				tmp9 = tmp8
			}
			return tmp9
		})
		tmp5 = tmp5.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp7 := checkDerefVar(var_clojure_DOT_core_char)
			tmp8 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp9 := lang.Apply(tmp8, []any{int64(32), int64(127)})
			tmp10 := lang.Apply(tmp7, []any{tmp9})
			return tmp10
		})
		tmp6 = tmp6.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp7 lang.FnFunc
		tmp7 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp8 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp9 := checkDerefVar(var_clojure_DOT_data_DOT_generators_printable_DASH_ascii_DASH_char)
				tmp10 := lang.Apply(tmp8, []any{tmp9})
				return tmp10
			case 1:
				v8 := args[0]
				_ = v8
				tmp9 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp10 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp11 := lang.Apply(tmp9, []any{v8, tmp10})
				return tmp11
			case 2:
				v8 := args[0]
				_ = v8
				v9 := args[1]
				_ = v9
				tmp10 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp11 := checkDerefVar(var_clojure_DOT_core_str)
				tmp12 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp13 := lang.Apply(tmp12, []any{v9, v8})
				tmp14 := lang.Apply(tmp10, []any{tmp11, tmp13})
				return tmp14
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp7 = tmp7.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp9 := checkDerefVar(var_clojure_DOT_data_DOT_generators_symbol)
				tmp10 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp11 := lang.Apply(tmp9, []any{tmp10})
				return tmp11
			case 1:
				v9 := args[0]
				_ = v9
				tmp10 := checkDerefVar(var_clojure_DOT_core_symbol)
				tmp11 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp12 := lang.Apply(tmp11, []any{v9})
				tmp13 := lang.Apply(tmp10, []any{tmp12})
				return tmp13
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp8 = tmp8.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp9 lang.FnFunc
		tmp9 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp10 := checkDerefVar(var_clojure_DOT_data_DOT_generators_keyword)
				tmp11 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp12 := lang.Apply(tmp10, []any{tmp11})
				return tmp12
			case 1:
				v10 := args[0]
				_ = v10
				tmp11 := checkDerefVar(var_clojure_DOT_core_keyword)
				tmp12 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp13 := lang.Apply(tmp12, []any{v10})
				tmp14 := lang.Apply(tmp11, []any{tmp13})
				return tmp14
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp9 = tmp9.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp11 := checkDerefVar(var_clojure_DOT_data_DOT_generators_ratio)
				tmp12 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp13 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp14 := lang.Apply(tmp11, []any{tmp12, tmp13})
				return tmp14
			case 2:
				v11 := args[0]
				_ = v11
				v12 := args[1]
				_ = v12
				tmp13 := checkDerefVar(var_clojure_DOT_core__SLASH_)
				tmp14 := lang.Apply(v11, nil)
				tmp15 := lang.Apply(v12, nil)
				tmp16 := lang.Apply(tmp13, []any{tmp14, tmp15})
				return tmp16
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp10 = tmp10.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp11 lang.FnFunc
		tmp11 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v12 := args[0]
				_ = v12
				tmp13 := checkDerefVar(var_clojure_DOT_data_DOT_generators_set)
				tmp14 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp15 := lang.Apply(tmp13, []any{v12, tmp14})
				return tmp15
			case 2:
				v12 := args[0]
				_ = v12
				v13 := args[1]
				_ = v13
				tmp14 := checkDerefVar(var_clojure_DOT_core_into)
				tmp15 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp16 := lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(203), kw_column, int(12), kw_end_DASH_line, int(203), kw_end_DASH_column, int(14))
				tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp18 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp19 := lang.Apply(tmp18, []any{v13, v12})
				tmp20 := lang.Apply(tmp14, []any{tmp17, tmp19})
				return tmp20
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp11 = tmp11.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp12 lang.FnFunc
		tmp12 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v13 any
				if len(restArgs) > 0 {
					v13 = lang.NewList(restArgs...)
				}
				_ = v13
				return closed0
			}
		})
		tmp12 = tmp12.WithMeta(lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(1443), kw_column, int(7), kw_end_DASH_line, int(1443), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var tmp13 lang.FnFunc
		tmp13 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp14 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp15 := checkDerefVar(var_clojure_DOT_core_inc)
			tmp16 := checkDerefVar(var_clojure_DOT_core_int)
			tmp17 := lang.Apply(tmp16, []any{nil})
			tmp18 := lang.Apply(tmp15, []any{tmp17})
			tmp19 := lang.Apply(tmp14, []any{nil, tmp18})
			return tmp19
		})
		tmp13 = tmp13.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp14 lang.FnFunc
		tmp14 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp15 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp16 := lang.Apply(tmp15, nil)
				tmp17, ok := lang.FieldOrMethod(tmp16, "nextLong")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp16, "nextLong")))
				}
				var tmp18 any
				switch reflect.TypeOf(tmp17).Kind() {
				case reflect.Func:
					tmp18 = lang.Apply(tmp17, nil)
				default:
					tmp18 = tmp17
				}
				return tmp18
			case 2:
				v15 := args[0]
				_ = v15
				v16 := args[1]
				_ = v16
				tmp17 := checkDerefVar(var_clojure_DOT_core_long)
				tmp18 := checkDerefVar(var_clojure_DOT_core__PLUS_)
				tmp19 := checkDerefVar(var_clojure_DOT_core__STAR_)
				tmp20 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp21 := lang.Apply(tmp20, nil)
				tmp22, ok := lang.FieldOrMethod(tmp21, "nextDouble")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp21, "nextDouble")))
				}
				var tmp23 any
				switch reflect.TypeOf(tmp22).Kind() {
				case reflect.Func:
					tmp23 = lang.Apply(tmp22, nil)
				default:
					tmp23 = tmp22
				}
				tmp24 := checkDerefVar(var_clojure_DOT_core__DASH_)
				tmp25 := lang.Apply(tmp24, []any{v16, v15})
				tmp26 := lang.Apply(tmp19, []any{tmp23, tmp25})
				tmp27 := lang.Apply(tmp18, []any{v15, tmp26})
				tmp28 := lang.Apply(nil, []any{tmp27})
				tmp29 := lang.Apply(tmp17, []any{tmp28})
				return tmp29
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp14 = tmp14.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp15 lang.FnFunc
		tmp15 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp16 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
			tmp17 := lang.Apply(tmp16, nil)
			tmp18, ok := lang.FieldOrMethod(tmp17, "nextBoolean")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp17, "nextBoolean")))
			}
			var tmp19 any
			switch reflect.TypeOf(tmp18).Kind() {
			case reflect.Func:
				tmp19 = lang.Apply(tmp18, nil)
			default:
				tmp19 = tmp18
			}
			return tmp19
		})
		tmp15 = tmp15.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp16 lang.FnFunc
		tmp16 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp17 := checkDerefVar(var_clojure_DOT_core_char)
			tmp18 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp19 := lang.Apply(tmp18, []any{int64(32), int64(127)})
			tmp20 := lang.Apply(tmp17, []any{tmp19})
			return tmp20
		})
		tmp16 = tmp16.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp17 lang.FnFunc
		tmp17 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp18 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp19 := checkDerefVar(var_clojure_DOT_data_DOT_generators_printable_DASH_ascii_DASH_char)
				tmp20 := lang.Apply(tmp18, []any{tmp19})
				return tmp20
			case 1:
				v18 := args[0]
				_ = v18
				tmp19 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp20 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp21 := lang.Apply(tmp19, []any{v18, tmp20})
				return tmp21
			case 2:
				v18 := args[0]
				_ = v18
				v19 := args[1]
				_ = v19
				tmp20 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp21 := checkDerefVar(var_clojure_DOT_core_str)
				tmp22 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp23 := lang.Apply(tmp22, []any{v19, v18})
				tmp24 := lang.Apply(tmp20, []any{tmp21, tmp23})
				return tmp24
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp17 = tmp17.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp18 lang.FnFunc
		tmp18 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp19 := checkDerefVar(var_clojure_DOT_data_DOT_generators_symbol)
				tmp20 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp21 := lang.Apply(tmp19, []any{tmp20})
				return tmp21
			case 1:
				v19 := args[0]
				_ = v19
				tmp20 := checkDerefVar(var_clojure_DOT_core_symbol)
				tmp21 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp22 := lang.Apply(tmp21, []any{v19})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				return tmp23
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp18 = tmp18.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp19 lang.FnFunc
		tmp19 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp20 := checkDerefVar(var_clojure_DOT_data_DOT_generators_keyword)
				tmp21 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp22 := lang.Apply(tmp20, []any{tmp21})
				return tmp22
			case 1:
				v20 := args[0]
				_ = v20
				tmp21 := checkDerefVar(var_clojure_DOT_core_keyword)
				tmp22 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp23 := lang.Apply(tmp22, []any{v20})
				tmp24 := lang.Apply(tmp21, []any{tmp23})
				return tmp24
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp19 = tmp19.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp20 lang.FnFunc
		tmp20 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp21 := checkDerefVar(var_clojure_DOT_data_DOT_generators_ratio)
				tmp22 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp23 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp24 := lang.Apply(tmp21, []any{tmp22, tmp23})
				return tmp24
			case 2:
				v21 := args[0]
				_ = v21
				v22 := args[1]
				_ = v22
				tmp23 := checkDerefVar(var_clojure_DOT_core__SLASH_)
				tmp24 := lang.Apply(v21, nil)
				tmp25 := lang.Apply(v22, nil)
				tmp26 := lang.Apply(tmp23, []any{tmp24, tmp25})
				return tmp26
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp20 = tmp20.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp21 lang.FnFunc
		tmp21 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v22 := args[0]
				_ = v22
				v23 := args[1]
				_ = v23
				tmp24 := checkDerefVar(var_clojure_DOT_data_DOT_generators_hash_DASH_map)
				tmp25 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp26 := lang.Apply(tmp24, []any{v22, v23, tmp25})
				return tmp26
			case 3:
				v22 := args[0]
				_ = v22
				v23 := args[1]
				_ = v23
				v24 := args[2]
				_ = v24
				tmp25 := checkDerefVar(var_clojure_DOT_core_into)
				tmp26 := lang.NewMap()
				tmp27 := lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(210), kw_column, int(12), kw_end_DASH_line, int(210), kw_end_DASH_column, int(13))
				tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp29 := checkDerefVar(var_clojure_DOT_core_zipmap)
				tmp30 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp31 := lang.Apply(tmp30, []any{v24, v22})
				tmp32 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp33 := lang.Apply(tmp32, []any{v24, v23})
				tmp34 := lang.Apply(tmp29, []any{tmp31, tmp33})
				tmp35 := lang.Apply(tmp25, []any{tmp28, tmp34})
				return tmp35
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp21 = tmp21.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp22 lang.FnFunc
		tmp22 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v23 any
				if len(restArgs) > 0 {
					v23 = lang.NewList(restArgs...)
				}
				_ = v23
				return closed0
			}
		})
		tmp22 = tmp22.WithMeta(lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(1443), kw_column, int(7), kw_end_DASH_line, int(1443), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var tmp23 lang.FnFunc
		tmp23 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp24 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp25 := checkDerefVar(var_clojure_DOT_core_inc)
			tmp26 := checkDerefVar(var_clojure_DOT_core_int)
			tmp27 := lang.Apply(tmp26, []any{nil})
			tmp28 := lang.Apply(tmp25, []any{tmp27})
			tmp29 := lang.Apply(tmp24, []any{nil, tmp28})
			return tmp29
		})
		tmp23 = tmp23.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp24 lang.FnFunc
		tmp24 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp25 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp26 := lang.Apply(tmp25, nil)
				tmp27, ok := lang.FieldOrMethod(tmp26, "nextLong")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp26, "nextLong")))
				}
				var tmp28 any
				switch reflect.TypeOf(tmp27).Kind() {
				case reflect.Func:
					tmp28 = lang.Apply(tmp27, nil)
				default:
					tmp28 = tmp27
				}
				return tmp28
			case 2:
				v25 := args[0]
				_ = v25
				v26 := args[1]
				_ = v26
				tmp27 := checkDerefVar(var_clojure_DOT_core_long)
				tmp28 := checkDerefVar(var_clojure_DOT_core__PLUS_)
				tmp29 := checkDerefVar(var_clojure_DOT_core__STAR_)
				tmp30 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp31 := lang.Apply(tmp30, nil)
				tmp32, ok := lang.FieldOrMethod(tmp31, "nextDouble")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp31, "nextDouble")))
				}
				var tmp33 any
				switch reflect.TypeOf(tmp32).Kind() {
				case reflect.Func:
					tmp33 = lang.Apply(tmp32, nil)
				default:
					tmp33 = tmp32
				}
				tmp34 := checkDerefVar(var_clojure_DOT_core__DASH_)
				tmp35 := lang.Apply(tmp34, []any{v26, v25})
				tmp36 := lang.Apply(tmp29, []any{tmp33, tmp35})
				tmp37 := lang.Apply(tmp28, []any{v25, tmp36})
				tmp38 := lang.Apply(nil, []any{tmp37})
				tmp39 := lang.Apply(tmp27, []any{tmp38})
				return tmp39
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp24 = tmp24.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp25 lang.FnFunc
		tmp25 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp26 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
			tmp27 := lang.Apply(tmp26, nil)
			tmp28, ok := lang.FieldOrMethod(tmp27, "nextBoolean")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp27, "nextBoolean")))
			}
			var tmp29 any
			switch reflect.TypeOf(tmp28).Kind() {
			case reflect.Func:
				tmp29 = lang.Apply(tmp28, nil)
			default:
				tmp29 = tmp28
			}
			return tmp29
		})
		tmp25 = tmp25.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp26 lang.FnFunc
		tmp26 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp27 := checkDerefVar(var_clojure_DOT_core_char)
			tmp28 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp29 := lang.Apply(tmp28, []any{int64(32), int64(127)})
			tmp30 := lang.Apply(tmp27, []any{tmp29})
			return tmp30
		})
		tmp26 = tmp26.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp27 lang.FnFunc
		tmp27 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp28 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp29 := checkDerefVar(var_clojure_DOT_data_DOT_generators_printable_DASH_ascii_DASH_char)
				tmp30 := lang.Apply(tmp28, []any{tmp29})
				return tmp30
			case 1:
				v28 := args[0]
				_ = v28
				tmp29 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp30 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp31 := lang.Apply(tmp29, []any{v28, tmp30})
				return tmp31
			case 2:
				v28 := args[0]
				_ = v28
				v29 := args[1]
				_ = v29
				tmp30 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp31 := checkDerefVar(var_clojure_DOT_core_str)
				tmp32 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp33 := lang.Apply(tmp32, []any{v29, v28})
				tmp34 := lang.Apply(tmp30, []any{tmp31, tmp33})
				return tmp34
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp27 = tmp27.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp28 lang.FnFunc
		tmp28 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp29 := checkDerefVar(var_clojure_DOT_data_DOT_generators_symbol)
				tmp30 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp31 := lang.Apply(tmp29, []any{tmp30})
				return tmp31
			case 1:
				v29 := args[0]
				_ = v29
				tmp30 := checkDerefVar(var_clojure_DOT_core_symbol)
				tmp31 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp32 := lang.Apply(tmp31, []any{v29})
				tmp33 := lang.Apply(tmp30, []any{tmp32})
				return tmp33
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp28 = tmp28.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp29 lang.FnFunc
		tmp29 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp30 := checkDerefVar(var_clojure_DOT_data_DOT_generators_keyword)
				tmp31 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp32 := lang.Apply(tmp30, []any{tmp31})
				return tmp32
			case 1:
				v30 := args[0]
				_ = v30
				tmp31 := checkDerefVar(var_clojure_DOT_core_keyword)
				tmp32 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp33 := lang.Apply(tmp32, []any{v30})
				tmp34 := lang.Apply(tmp31, []any{tmp33})
				return tmp34
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp29 = tmp29.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp30 lang.FnFunc
		tmp30 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp31 := checkDerefVar(var_clojure_DOT_data_DOT_generators_ratio)
				tmp32 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp33 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp34 := lang.Apply(tmp31, []any{tmp32, tmp33})
				return tmp34
			case 2:
				v31 := args[0]
				_ = v31
				v32 := args[1]
				_ = v32
				tmp33 := checkDerefVar(var_clojure_DOT_core__SLASH_)
				tmp34 := lang.Apply(v31, nil)
				tmp35 := lang.Apply(v32, nil)
				tmp36 := lang.Apply(tmp33, []any{tmp34, tmp35})
				return tmp36
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp30 = tmp30.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp31 lang.FnFunc
		tmp31 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v32 any
				if len(restArgs) > 0 {
					v32 = lang.NewList(restArgs...)
				}
				_ = v32
				return closed0
			}
		})
		tmp31 = tmp31.WithMeta(lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(1443), kw_column, int(7), kw_end_DASH_line, int(1443), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var tmp32 lang.FnFunc
		tmp32 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp33 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp34 := checkDerefVar(var_clojure_DOT_core_inc)
			tmp35 := checkDerefVar(var_clojure_DOT_core_int)
			tmp36 := lang.Apply(tmp35, []any{nil})
			tmp37 := lang.Apply(tmp34, []any{tmp36})
			tmp38 := lang.Apply(tmp33, []any{nil, tmp37})
			return tmp38
		})
		tmp32 = tmp32.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp33 lang.FnFunc
		tmp33 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp34 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp35 := lang.Apply(tmp34, nil)
				tmp36, ok := lang.FieldOrMethod(tmp35, "nextLong")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp35, "nextLong")))
				}
				var tmp37 any
				switch reflect.TypeOf(tmp36).Kind() {
				case reflect.Func:
					tmp37 = lang.Apply(tmp36, nil)
				default:
					tmp37 = tmp36
				}
				return tmp37
			case 2:
				v34 := args[0]
				_ = v34
				v35 := args[1]
				_ = v35
				tmp36 := checkDerefVar(var_clojure_DOT_core_long)
				tmp37 := checkDerefVar(var_clojure_DOT_core__PLUS_)
				tmp38 := checkDerefVar(var_clojure_DOT_core__STAR_)
				tmp39 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp40 := lang.Apply(tmp39, nil)
				tmp41, ok := lang.FieldOrMethod(tmp40, "nextDouble")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp40, "nextDouble")))
				}
				var tmp42 any
				switch reflect.TypeOf(tmp41).Kind() {
				case reflect.Func:
					tmp42 = lang.Apply(tmp41, nil)
				default:
					tmp42 = tmp41
				}
				tmp43 := checkDerefVar(var_clojure_DOT_core__DASH_)
				tmp44 := lang.Apply(tmp43, []any{v35, v34})
				tmp45 := lang.Apply(tmp38, []any{tmp42, tmp44})
				tmp46 := lang.Apply(tmp37, []any{v34, tmp45})
				tmp47 := lang.Apply(nil, []any{tmp46})
				tmp48 := lang.Apply(tmp36, []any{tmp47})
				return tmp48
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp33 = tmp33.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp34 lang.FnFunc
		tmp34 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp35 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
			tmp36 := lang.Apply(tmp35, nil)
			tmp37, ok := lang.FieldOrMethod(tmp36, "nextBoolean")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp36, "nextBoolean")))
			}
			var tmp38 any
			switch reflect.TypeOf(tmp37).Kind() {
			case reflect.Func:
				tmp38 = lang.Apply(tmp37, nil)
			default:
				tmp38 = tmp37
			}
			return tmp38
		})
		tmp34 = tmp34.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp35 lang.FnFunc
		tmp35 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp36 := checkDerefVar(var_clojure_DOT_core_char)
			tmp37 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp38 := lang.Apply(tmp37, []any{int64(32), int64(127)})
			tmp39 := lang.Apply(tmp36, []any{tmp38})
			return tmp39
		})
		tmp35 = tmp35.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp36 lang.FnFunc
		tmp36 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp37 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp38 := checkDerefVar(var_clojure_DOT_data_DOT_generators_printable_DASH_ascii_DASH_char)
				tmp39 := lang.Apply(tmp37, []any{tmp38})
				return tmp39
			case 1:
				v37 := args[0]
				_ = v37
				tmp38 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp39 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp40 := lang.Apply(tmp38, []any{v37, tmp39})
				return tmp40
			case 2:
				v37 := args[0]
				_ = v37
				v38 := args[1]
				_ = v38
				tmp39 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp40 := checkDerefVar(var_clojure_DOT_core_str)
				tmp41 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp42 := lang.Apply(tmp41, []any{v38, v37})
				tmp43 := lang.Apply(tmp39, []any{tmp40, tmp42})
				return tmp43
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp36 = tmp36.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp37 lang.FnFunc
		tmp37 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp38 := checkDerefVar(var_clojure_DOT_data_DOT_generators_symbol)
				tmp39 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp40 := lang.Apply(tmp38, []any{tmp39})
				return tmp40
			case 1:
				v38 := args[0]
				_ = v38
				tmp39 := checkDerefVar(var_clojure_DOT_core_symbol)
				tmp40 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp41 := lang.Apply(tmp40, []any{v38})
				tmp42 := lang.Apply(tmp39, []any{tmp41})
				return tmp42
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp37 = tmp37.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp38 lang.FnFunc
		tmp38 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp39 := checkDerefVar(var_clojure_DOT_data_DOT_generators_keyword)
				tmp40 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp41 := lang.Apply(tmp39, []any{tmp40})
				return tmp41
			case 1:
				v39 := args[0]
				_ = v39
				tmp40 := checkDerefVar(var_clojure_DOT_core_keyword)
				tmp41 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp42 := lang.Apply(tmp41, []any{v39})
				tmp43 := lang.Apply(tmp40, []any{tmp42})
				return tmp43
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp38 = tmp38.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp39 lang.FnFunc
		tmp39 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp40 := checkDerefVar(var_clojure_DOT_data_DOT_generators_ratio)
				tmp41 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp42 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp43 := lang.Apply(tmp40, []any{tmp41, tmp42})
				return tmp43
			case 2:
				v40 := args[0]
				_ = v40
				v41 := args[1]
				_ = v41
				tmp42 := checkDerefVar(var_clojure_DOT_core__SLASH_)
				tmp43 := lang.Apply(v40, nil)
				tmp44 := lang.Apply(v41, nil)
				tmp45 := lang.Apply(tmp42, []any{tmp43, tmp44})
				return tmp45
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp39 = tmp39.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_collections = ns.InternWithValue(tmp0, lang.NewVector(lang.NewVector(tmp1, lang.NewVector(lang.NewVector(tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8, tmp9, tmp10))), lang.NewVector(tmp11, lang.NewVector(lang.NewVector(tmp12, tmp13, tmp14, tmp15, tmp16, tmp17, tmp18, tmp19, tmp20))), lang.NewVector(tmp21, lang.NewVector(lang.NewVector(tmp22, tmp23, tmp24, tmp25, tmp26, tmp27, tmp28, tmp29, tmp30), lang.NewVector(tmp31, tmp32, tmp33, tmp34, tmp35, tmp36, tmp37, tmp38, tmp39)))), true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_collections.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// default-sizer
	{
		tmp0 := sym_default_DASH_sizer.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(138), kw_column, int(7), kw_end_DASH_line, int(138), kw_end_DASH_column, int(19), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Default sizer used to run tests. If you want a specific distribution,\n   create your own and pass it to a fn that wants a sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_core_dec)
			tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_geometric)
			tmp4 := lang.Apply(tmp3, []any{float64(0.02)})
			tmp5 := lang.Apply(tmp2, []any{tmp4})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_default_DASH_sizer = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_default_DASH_sizer.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double-array
	{
		tmp0 := sym_double_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_doc, "Create an array with elements from f and sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_double_DASH_array)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "arr"
					tmp5 := checkDerefVar(var_clojure_DOT_core_double_DASH_array)
					tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
					tmp7 := lang.Apply(tmp6, []any{v3})
					tmp8 := lang.Apply(tmp5, []any{tmp7})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					{ // let
						// let binding "n__0__auto__"
						tmp11 := checkDerefVar(var_clojure_DOT_core_long)
						tmp12 := checkDerefVar(var_clojure_DOT_core_count)
						tmp13 := lang.Apply(tmp12, []any{v9})
						tmp14 := lang.Apply(tmp11, []any{tmp13})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						{ // let
							// let binding "i"
							var v17 any = int64(0)
							_ = v17
							for {
								var tmp18 any
								tmp19 := checkDerefVar(var_clojure_DOT_core__LT_)
								tmp20 := lang.Apply(tmp19, []any{v17, v15})
								if lang.IsTruthy(tmp20) {
									tmp21 := checkDerefVar(var_clojure_DOT_core_aset)
									tmp22 := checkDerefVar(var_clojure_DOT_core_double)
									tmp23 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
									tmp24 := lang.Apply(tmp23, []any{v2})
									tmp25 := lang.Apply(tmp22, []any{tmp24})
									tmp26 := lang.Apply(tmp21, []any{v9, v17, tmp25})
									_ = tmp26
									tmp28 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
									tmp29 := lang.Apply(tmp28, []any{v17})
									var tmp27 any = tmp29
									v17 = tmp27
									continue
								} else {
								}
								tmp16 = tmp18
								break
							}
						} // end let
						tmp10 = tmp16
					} // end let
					_ = tmp10
					tmp4 = v9
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_double_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_double_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fisher-yates
	{
		tmp0 := sym_fisher_DASH_yates.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "http://en.wikipedia.org/wiki/Fisher–Yates_shuffle#The_modern_algorithm", kw_file, "clojure/data/generators.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators), kw_end_DASH_column, int(28), kw_column, int(7), kw_line, int(308), kw_end_DASH_line, int(308), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "as"
				tmp4 := checkDerefVar(var_clojure_DOT_core_object_DASH_array)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				{ // let
					// let binding "i"
					tmp8 := checkDerefVar(var_clojure_DOT_core_dec)
					tmp9 := checkDerefVar(var_clojure_DOT_core_count)
					tmp10 := lang.Apply(tmp9, []any{v6})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					var v12 any = tmp11
					_ = v12
					for {
						var tmp13 any
						tmp14 := checkDerefVar(var_clojure_DOT_core__LT__EQ_)
						tmp15 := lang.Apply(tmp14, []any{int64(1), v12})
						if lang.IsTruthy(tmp15) {
							var tmp16 any
							{ // let
								// let binding "j"
								tmp17 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
								tmp18 := checkDerefVar(var_clojure_DOT_core_inc)
								tmp19 := lang.Apply(tmp18, []any{v12})
								tmp20 := lang.Apply(tmp17, []any{int64(0), tmp19})
								var v21 any = tmp20
								_ = v21
								// let binding "t"
								tmp22 := checkDerefVar(var_clojure_DOT_core_aget)
								tmp23 := lang.Apply(tmp22, []any{v6, v12})
								var v24 any = tmp23
								_ = v24
								tmp25 := checkDerefVar(var_clojure_DOT_core_aset)
								tmp26 := checkDerefVar(var_clojure_DOT_core_aget)
								tmp27 := lang.Apply(tmp26, []any{v6, v21})
								tmp28 := lang.Apply(tmp25, []any{v6, v12, tmp27})
								_ = tmp28
								tmp29 := checkDerefVar(var_clojure_DOT_core_aset)
								tmp30 := lang.Apply(tmp29, []any{v6, v21, v24})
								_ = tmp30
								tmp32 := checkDerefVar(var_clojure_DOT_core_dec)
								tmp33 := lang.Apply(tmp32, []any{v12})
								var tmp31 any = tmp33
								v12 = tmp31
								continue
							} // end let
							tmp13 = tmp16
						} else {
							tmp17 := checkDerefVar(var_clojure_DOT_core_into)
							tmp18 := checkDerefVar(var_clojure_DOT_core_empty)
							tmp19 := lang.Apply(tmp18, []any{v2})
							tmp20 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp21 := lang.Apply(tmp20, []any{v6})
							tmp22 := lang.Apply(tmp17, []any{tmp19, tmp21})
							tmp13 = tmp22
						}
						tmp7 = tmp13
						break
					}
				} // end let
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_fisher_DASH_yates = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_fisher_DASH_yates.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shuffle
	{
		tmp0 := sym_shuffle.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(321), kw_column, int(7), kw_end_DASH_line, int(321), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Shuffle coll based on *rnd*", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_fisher_DASH_yates)
			tmp4 := lang.Apply(tmp3, []any{v2})
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_shuffle = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_shuffle.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float-array
	{
		tmp0 := sym_float_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_doc, "Create an array with elements from f and sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_float_DASH_array)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "arr"
					tmp5 := checkDerefVar(var_clojure_DOT_core_float_DASH_array)
					tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
					tmp7 := lang.Apply(tmp6, []any{v3})
					tmp8 := lang.Apply(tmp5, []any{tmp7})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					{ // let
						// let binding "n__0__auto__"
						tmp11 := checkDerefVar(var_clojure_DOT_core_long)
						tmp12 := checkDerefVar(var_clojure_DOT_core_count)
						tmp13 := lang.Apply(tmp12, []any{v9})
						tmp14 := lang.Apply(tmp11, []any{tmp13})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						{ // let
							// let binding "i"
							var v17 any = int64(0)
							_ = v17
							for {
								var tmp18 any
								tmp19 := checkDerefVar(var_clojure_DOT_core__LT_)
								tmp20 := lang.Apply(tmp19, []any{v17, v15})
								if lang.IsTruthy(tmp20) {
									tmp21 := checkDerefVar(var_clojure_DOT_core_aset)
									tmp22 := checkDerefVar(var_clojure_DOT_core_float)
									tmp23 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
									tmp24 := lang.Apply(tmp23, []any{v2})
									tmp25 := lang.Apply(tmp22, []any{tmp24})
									tmp26 := lang.Apply(tmp21, []any{v9, v17, tmp25})
									_ = tmp26
									tmp28 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
									tmp29 := lang.Apply(tmp28, []any{v17})
									var tmp27 any = tmp29
									v17 = tmp27
									continue
								} else {
								}
								tmp16 = tmp18
								break
							}
						} // end let
						tmp10 = tmp16
					} // end let
					_ = tmp10
					tmp4 = v9
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_float_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_float_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// geometric
	{
		tmp0 := sym_geometric.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(45), kw_column, int(7), kw_end_DASH_line, int(45), kw_end_DASH_column, int(15), kw_arglists, lang.NewList(lang.NewVector(sym_p)), kw_doc, "Geometric distribution with mean 1/p.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_long)
			tmp4 := checkDerefVar(var_clojure_DOT_core__SLASH_)
			tmp5 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
			tmp6 := lang.Apply(tmp5, nil)
			tmp7, ok := lang.FieldOrMethod(tmp6, "nextDouble")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp6, "nextDouble")))
			}
			var tmp8 any
			switch reflect.TypeOf(tmp7).Kind() {
			case reflect.Func:
				tmp8 = lang.Apply(tmp7, nil)
			default:
				tmp8 = tmp7
			}
			tmp9 := lang.Apply(nil, []any{tmp8})
			tmp10 := checkDerefVar(var_clojure_DOT_core__DASH_)
			tmp11 := lang.Apply(tmp10, []any{float64(1), v2})
			tmp12 := lang.Apply(nil, []any{tmp11})
			tmp13 := lang.Apply(tmp4, []any{tmp9, tmp12})
			tmp14 := lang.Apply(nil, []any{tmp13})
			tmp15 := lang.Apply(tmp3, []any{tmp14})
			return tmp15
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_geometric = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_geometric.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-map
	{
		tmp0 := sym_hash_DASH_map.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(205), kw_column, int(7), kw_end_DASH_line, int(205), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym_fk, sym_fv), lang.NewVector(sym_fk, sym_fv, sym_sizer)), kw_doc, "Create a hash-map with keys from fk, vals from fv, and\n   sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_hash_DASH_map)
				tmp5 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp6 := lang.Apply(tmp4, []any{v2, v3, tmp5})
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_into)
				tmp6 := lang.NewMap()
				tmp7 := lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(210), kw_column, int(12), kw_end_DASH_line, int(210), kw_end_DASH_column, int(13))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := checkDerefVar(var_clojure_DOT_core_zipmap)
				tmp10 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp11 := lang.Apply(tmp10, []any{v4, v2})
				tmp12 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp13 := lang.Apply(tmp12, []any{v4, v3})
				tmp14 := lang.Apply(tmp9, []any{tmp11, tmp13})
				tmp15 := lang.Apply(tmp5, []any{tmp8, tmp14})
				return tmp15
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_hash_DASH_map = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_hash_DASH_map.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int
	{
		tmp0 := sym_int.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(108), kw_column, int(7), kw_end_DASH_line, int(108), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a int based on *rnd* in the int range.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp3 := checkDerefVar(var_clojure_DOT_core_inc)
			tmp4 := lang.Apply(tmp3, []any{nil})
			tmp5 := lang.Apply(tmp2, []any{nil, tmp4})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_int = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_int.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int-array
	{
		tmp0 := sym_int_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_doc, "Create an array with elements from f and sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_int_DASH_array)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "arr"
					tmp5 := checkDerefVar(var_clojure_DOT_core_int_DASH_array)
					tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
					tmp7 := lang.Apply(tmp6, []any{v3})
					tmp8 := lang.Apply(tmp5, []any{tmp7})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					{ // let
						// let binding "n__0__auto__"
						tmp11 := checkDerefVar(var_clojure_DOT_core_long)
						tmp12 := checkDerefVar(var_clojure_DOT_core_count)
						tmp13 := lang.Apply(tmp12, []any{v9})
						tmp14 := lang.Apply(tmp11, []any{tmp13})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						{ // let
							// let binding "i"
							var v17 any = int64(0)
							_ = v17
							for {
								var tmp18 any
								tmp19 := checkDerefVar(var_clojure_DOT_core__LT_)
								tmp20 := lang.Apply(tmp19, []any{v17, v15})
								if lang.IsTruthy(tmp20) {
									tmp21 := checkDerefVar(var_clojure_DOT_core_aset)
									tmp22 := checkDerefVar(var_clojure_DOT_core_int)
									tmp23 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
									tmp24 := lang.Apply(tmp23, []any{v2})
									tmp25 := lang.Apply(tmp22, []any{tmp24})
									tmp26 := lang.Apply(tmp21, []any{v9, v17, tmp25})
									_ = tmp26
									tmp28 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
									tmp29 := lang.Apply(tmp28, []any{v17})
									var tmp27 any = tmp29
									v17 = tmp27
									continue
								} else {
								}
								tmp16 = tmp18
								break
							}
						} // end let
						tmp10 = tmp16
					} // end let
					_ = tmp10
					tmp4 = v9
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_int_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_int_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keyword
	{
		tmp0 := sym_keyword.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(253), kw_column, int(7), kw_end_DASH_line, int(253), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_sizer)), kw_doc, "Create a non-namespaced keyword sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators_keyword)
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp4 := lang.Apply(tmp2, []any{tmp3})
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_keyword)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp5 := lang.Apply(tmp4, []any{v2})
				tmp6 := lang.Apply(tmp3, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_keyword = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_keyword.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list
	{
		tmp0 := sym_list.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(144), kw_column, int(7), kw_end_DASH_line, int(144), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_doc, "Create a list with elements from f and sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_list)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp5 := lang.Apply(tmp4, []any{v3, v2})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_list = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_list.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// long
	{
		tmp0 := sym_long.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(98), kw_column, int(6), kw_end_DASH_line, int(98), kw_end_DASH_column, int(9), kw_doc, "Returns a long based on *rnd*. Same as uniform.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp3 := lang.Apply(tmp2, nil)
				tmp4, ok := lang.FieldOrMethod(tmp3, "nextLong")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp3, "nextLong")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_long)
				tmp5 := checkDerefVar(var_clojure_DOT_core__PLUS_)
				tmp6 := checkDerefVar(var_clojure_DOT_core__STAR_)
				tmp7 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp8 := lang.Apply(tmp7, nil)
				tmp9, ok := lang.FieldOrMethod(tmp8, "nextDouble")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp8, "nextDouble")))
				}
				var tmp10 any
				switch reflect.TypeOf(tmp9).Kind() {
				case reflect.Func:
					tmp10 = lang.Apply(tmp9, nil)
				default:
					tmp10 = tmp9
				}
				tmp11 := checkDerefVar(var_clojure_DOT_core__DASH_)
				tmp12 := lang.Apply(tmp11, []any{v3, v2})
				tmp13 := lang.Apply(tmp6, []any{tmp10, tmp12})
				tmp14 := lang.Apply(tmp5, []any{v2, tmp13})
				tmp15 := lang.Apply(nil, []any{tmp14})
				tmp16 := lang.Apply(tmp4, []any{tmp15})
				return tmp16
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_long = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_long.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// long-array
	{
		tmp0 := sym_long_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_doc, "Create an array with elements from f and sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long_DASH_array)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "arr"
					tmp5 := checkDerefVar(var_clojure_DOT_core_long_DASH_array)
					tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
					tmp7 := lang.Apply(tmp6, []any{v3})
					tmp8 := lang.Apply(tmp5, []any{tmp7})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					{ // let
						// let binding "n__0__auto__"
						tmp11 := checkDerefVar(var_clojure_DOT_core_long)
						tmp12 := checkDerefVar(var_clojure_DOT_core_count)
						tmp13 := lang.Apply(tmp12, []any{v9})
						tmp14 := lang.Apply(tmp11, []any{tmp13})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						{ // let
							// let binding "i"
							var v17 any = int64(0)
							_ = v17
							for {
								var tmp18 any
								tmp19 := checkDerefVar(var_clojure_DOT_core__LT_)
								tmp20 := lang.Apply(tmp19, []any{v17, v15})
								if lang.IsTruthy(tmp20) {
									tmp21 := checkDerefVar(var_clojure_DOT_core_aset)
									tmp22 := checkDerefVar(var_clojure_DOT_core_long)
									tmp23 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
									tmp24 := lang.Apply(tmp23, []any{v2})
									tmp25 := lang.Apply(tmp22, []any{tmp24})
									tmp26 := lang.Apply(tmp21, []any{v9, v17, tmp25})
									_ = tmp26
									tmp28 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
									tmp29 := lang.Apply(tmp28, []any{v17})
									var tmp27 any = tmp29
									v17 = tmp27
									continue
								} else {
								}
								tmp16 = tmp18
								break
							}
						} // end let
						tmp10 = tmp16
					} // end let
					_ = tmp10
					tmp4 = v9
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_long_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_long_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// name
	{
		tmp0 := sym_name.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(242), kw_column, int(8), kw_end_DASH_line, int(242), kw_end_DASH_column, int(11), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_sizer)), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp4 := lang.Apply(tmp2, []any{tmp3})
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_str)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name_DASH_prefix)
				tmp5 := lang.Apply(tmp4, nil)
				tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name_DASH_body)
				tmp7 := lang.Apply(tmp6, []any{v2})
				tmp8 := lang.Apply(tmp3, []any{tmp5, tmp7})
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_name = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_name.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// name-body
	{
		tmp0 := sym_name_DASH_body.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(238), kw_column, int(8), kw_end_DASH_line, int(238), kw_end_DASH_column, int(16), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_sizer)), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 0)
				tmp5 := checkDerefVar(var_clojure_DOT_core_char)
				tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_rand_DASH_nth)
				tmp7 := checkDerefVar(var_clojure_DOT_data_DOT_generators_symbol_DASH_char)
				tmp8 := lang.Apply(tmp6, []any{tmp7})
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				return tmp9
			})
			tmp5 := lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(240), kw_column, int(11), kw_end_DASH_line, int(240), kw_end_DASH_column, int(45))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp7 := lang.Apply(tmp3, []any{tmp6, v2})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_name_DASH_body = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_name_DASH_body.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// name-prefix
	{
		tmp0 := sym_name_DASH_prefix.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(233), kw_column, int(8), kw_end_DASH_line, int(233), kw_end_DASH_column, int(18), kw_private, true, kw_arglists, lang.NewList(lang.NewVector()), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_core_str)
			tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_rand_DASH_nth)
			tmp4 := checkDerefVar(var_clojure_DOT_core_char)
			tmp5 := checkDerefVar(var_clojure_DOT_data_DOT_generators_rand_DASH_nth)
			tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_symbol_DASH_start)
			tmp7 := lang.Apply(tmp5, []any{tmp6})
			tmp8 := lang.Apply(tmp4, []any{tmp7})
			tmp9 := lang.NewVector(tmp8, "")
			tmp10 := lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(235), kw_column, int(18), kw_end_DASH_line, int(235), kw_end_DASH_column, int(57))
			tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp12 := lang.Apply(tmp3, []any{tmp11})
			tmp13 := checkDerefVar(var_clojure_DOT_core_char)
			tmp14 := checkDerefVar(var_clojure_DOT_data_DOT_generators_rand_DASH_nth)
			tmp15 := checkDerefVar(var_clojure_DOT_data_DOT_generators_ascii_DASH_alpha)
			tmp16 := lang.Apply(tmp14, []any{tmp15})
			tmp17 := lang.Apply(tmp13, []any{tmp16})
			tmp18 := lang.Apply(tmp2, []any{tmp12, tmp17})
			return tmp18
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_name_DASH_prefix = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_name_DASH_prefix.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// one-of
	{
		tmp0 := sym_one_DASH_of.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(93), kw_column, int(7), kw_end_DASH_line, int(93), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_specs)), kw_doc, "Generates one of the specs passed in, with equal probability.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_weighted)
				tmp4 := checkDerefVar(var_clojure_DOT_core_zipmap)
				tmp5 := checkDerefVar(var_clojure_DOT_core_repeat)
				tmp6 := lang.Apply(tmp5, []any{int64(1)})
				tmp7 := lang.Apply(tmp4, []any{v2, tmp6})
				tmp8 := lang.Apply(tmp3, []any{tmp7})
				return tmp8
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_one_DASH_of = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_one_DASH_of.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// primitive-array
	{
		tmp0 := sym_primitive_DASH_array.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(150), kw_column, int(11), kw_end_DASH_line, int(150), kw_end_DASH_column, int(25), kw_arglists, lang.NewList(lang.NewVector(sym_type)), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "fn-name"
				tmp6 := checkDerefVar(var_clojure_DOT_core_symbol)
				tmp7 := checkDerefVar(var_clojure_DOT_core_str)
				tmp8 := lang.Apply(tmp7, []any{v4, "-array"})
				tmp9 := lang.Apply(tmp6, []any{tmp8})
				var v10 any = tmp9
				_ = v10
				// let binding "factory-name"
				tmp11 := checkDerefVar(var_clojure_DOT_core_symbol)
				tmp12 := checkDerefVar(var_clojure_DOT_core_str)
				tmp13 := lang.Apply(tmp12, []any{"core/", v10})
				tmp14 := lang.Apply(tmp11, []any{tmp13})
				var v15 any = tmp14
				_ = v15
				// let binding "cast-name"
				tmp16 := checkDerefVar(var_clojure_DOT_core_symbol)
				tmp17 := checkDerefVar(var_clojure_DOT_core_str)
				tmp18 := lang.Apply(tmp17, []any{"core/", v4})
				tmp19 := lang.Apply(tmp16, []any{tmp18})
				var v20 any = tmp19
				_ = v20
				tmp21 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp22 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp23 := checkDerefVar(var_clojure_DOT_core_list)
				tmp24 := lang.Apply(tmp23, []any{sym_clojure_DOT_core_SLASH_defn})
				tmp25 := checkDerefVar(var_clojure_DOT_core_list)
				tmp26 := lang.Apply(tmp25, []any{v10})
				tmp27 := checkDerefVar(var_clojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{"Create an array with elements from f and sized from sizer."})
				tmp29 := checkDerefVar(var_clojure_DOT_core_list)
				tmp30 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp31 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp32 := checkDerefVar(var_clojure_DOT_core_list)
				tmp33 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp34 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp35 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp36 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp37 := checkDerefVar(var_clojure_DOT_core_list)
				tmp38 := lang.Apply(tmp37, []any{sym_f})
				tmp39 := lang.Apply(tmp36, []any{tmp38})
				tmp40 := lang.Apply(tmp35, []any{tmp39})
				tmp41 := lang.Apply(tmp33, []any{tmp34, tmp40})
				tmp42 := lang.Apply(tmp32, []any{tmp41})
				tmp43 := checkDerefVar(var_clojure_DOT_core_list)
				tmp44 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp45 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp46 := checkDerefVar(var_clojure_DOT_core_list)
				tmp47 := lang.Apply(tmp46, []any{v10})
				tmp48 := checkDerefVar(var_clojure_DOT_core_list)
				tmp49 := lang.Apply(tmp48, []any{sym_f})
				tmp50 := checkDerefVar(var_clojure_DOT_core_list)
				tmp51 := lang.Apply(tmp50, []any{sym_clojure_DOT_data_DOT_generators_SLASH_default_DASH_sizer})
				tmp52 := lang.Apply(tmp45, []any{tmp47, tmp49, tmp51})
				tmp53 := lang.Apply(tmp44, []any{tmp52})
				tmp54 := lang.Apply(tmp43, []any{tmp53})
				tmp55 := lang.Apply(tmp31, []any{tmp42, tmp54})
				tmp56 := lang.Apply(tmp30, []any{tmp55})
				tmp57 := lang.Apply(tmp29, []any{tmp56})
				tmp58 := checkDerefVar(var_clojure_DOT_core_list)
				tmp59 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp60 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp61 := checkDerefVar(var_clojure_DOT_core_list)
				tmp62 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp63 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp64 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp65 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp66 := checkDerefVar(var_clojure_DOT_core_list)
				tmp67 := lang.Apply(tmp66, []any{sym_f})
				tmp68 := checkDerefVar(var_clojure_DOT_core_list)
				tmp69 := lang.Apply(tmp68, []any{sym_sizer})
				tmp70 := lang.Apply(tmp65, []any{tmp67, tmp69})
				tmp71 := lang.Apply(tmp64, []any{tmp70})
				tmp72 := lang.Apply(tmp62, []any{tmp63, tmp71})
				tmp73 := lang.Apply(tmp61, []any{tmp72})
				tmp74 := checkDerefVar(var_clojure_DOT_core_list)
				tmp75 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp76 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp77 := checkDerefVar(var_clojure_DOT_core_list)
				tmp78 := lang.Apply(tmp77, []any{sym_clojure_DOT_core_SLASH_let})
				tmp79 := checkDerefVar(var_clojure_DOT_core_list)
				tmp80 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp81 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp82 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp83 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp84 := checkDerefVar(var_clojure_DOT_core_list)
				tmp85 := lang.Apply(tmp84, []any{sym_arr})
				tmp86 := checkDerefVar(var_clojure_DOT_core_list)
				tmp87 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp88 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp89 := checkDerefVar(var_clojure_DOT_core_list)
				tmp90 := lang.Apply(tmp89, []any{v15})
				tmp91 := checkDerefVar(var_clojure_DOT_core_list)
				tmp92 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp93 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp94 := checkDerefVar(var_clojure_DOT_core_list)
				tmp95 := lang.Apply(tmp94, []any{sym_clojure_DOT_data_DOT_generators_SLASH_call_DASH_through})
				tmp96 := checkDerefVar(var_clojure_DOT_core_list)
				tmp97 := lang.Apply(tmp96, []any{sym_sizer})
				tmp98 := lang.Apply(tmp93, []any{tmp95, tmp97})
				tmp99 := lang.Apply(tmp92, []any{tmp98})
				tmp100 := lang.Apply(tmp91, []any{tmp99})
				tmp101 := lang.Apply(tmp88, []any{tmp90, tmp100})
				tmp102 := lang.Apply(tmp87, []any{tmp101})
				tmp103 := lang.Apply(tmp86, []any{tmp102})
				tmp104 := lang.Apply(tmp83, []any{tmp85, tmp103})
				tmp105 := lang.Apply(tmp82, []any{tmp104})
				tmp106 := lang.Apply(tmp80, []any{tmp81, tmp105})
				tmp107 := lang.Apply(tmp79, []any{tmp106})
				tmp108 := checkDerefVar(var_clojure_DOT_core_list)
				tmp109 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp110 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp111 := checkDerefVar(var_clojure_DOT_core_list)
				tmp112 := lang.Apply(tmp111, []any{sym_clojure_DOT_core_SLASH_dotimes})
				tmp113 := checkDerefVar(var_clojure_DOT_core_list)
				tmp114 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp115 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp116 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp117 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp118 := checkDerefVar(var_clojure_DOT_core_list)
				tmp119 := lang.Apply(tmp118, []any{sym_i})
				tmp120 := checkDerefVar(var_clojure_DOT_core_list)
				tmp121 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp122 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp123 := checkDerefVar(var_clojure_DOT_core_list)
				tmp124 := lang.Apply(tmp123, []any{sym_clojure_DOT_core_SLASH_count})
				tmp125 := checkDerefVar(var_clojure_DOT_core_list)
				tmp126 := lang.Apply(tmp125, []any{sym_arr})
				tmp127 := lang.Apply(tmp122, []any{tmp124, tmp126})
				tmp128 := lang.Apply(tmp121, []any{tmp127})
				tmp129 := lang.Apply(tmp120, []any{tmp128})
				tmp130 := lang.Apply(tmp117, []any{tmp119, tmp129})
				tmp131 := lang.Apply(tmp116, []any{tmp130})
				tmp132 := lang.Apply(tmp114, []any{tmp115, tmp131})
				tmp133 := lang.Apply(tmp113, []any{tmp132})
				tmp134 := checkDerefVar(var_clojure_DOT_core_list)
				tmp135 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp136 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp137 := checkDerefVar(var_clojure_DOT_core_list)
				tmp138 := lang.Apply(tmp137, []any{sym_clojure_DOT_core_SLASH_aset})
				tmp139 := checkDerefVar(var_clojure_DOT_core_list)
				tmp140 := lang.Apply(tmp139, []any{sym_arr})
				tmp141 := checkDerefVar(var_clojure_DOT_core_list)
				tmp142 := lang.Apply(tmp141, []any{sym_i})
				tmp143 := checkDerefVar(var_clojure_DOT_core_list)
				tmp144 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp145 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp146 := checkDerefVar(var_clojure_DOT_core_list)
				tmp147 := lang.Apply(tmp146, []any{v20})
				tmp148 := checkDerefVar(var_clojure_DOT_core_list)
				tmp149 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp150 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp151 := checkDerefVar(var_clojure_DOT_core_list)
				tmp152 := lang.Apply(tmp151, []any{sym_clojure_DOT_data_DOT_generators_SLASH_call_DASH_through})
				tmp153 := checkDerefVar(var_clojure_DOT_core_list)
				tmp154 := lang.Apply(tmp153, []any{sym_f})
				tmp155 := lang.Apply(tmp150, []any{tmp152, tmp154})
				tmp156 := lang.Apply(tmp149, []any{tmp155})
				tmp157 := lang.Apply(tmp148, []any{tmp156})
				tmp158 := lang.Apply(tmp145, []any{tmp147, tmp157})
				tmp159 := lang.Apply(tmp144, []any{tmp158})
				tmp160 := lang.Apply(tmp143, []any{tmp159})
				tmp161 := lang.Apply(tmp136, []any{tmp138, tmp140, tmp142, tmp160})
				tmp162 := lang.Apply(tmp135, []any{tmp161})
				tmp163 := lang.Apply(tmp134, []any{tmp162})
				tmp164 := lang.Apply(tmp110, []any{tmp112, tmp133, tmp163})
				tmp165 := lang.Apply(tmp109, []any{tmp164})
				tmp166 := lang.Apply(tmp108, []any{tmp165})
				tmp167 := checkDerefVar(var_clojure_DOT_core_list)
				tmp168 := lang.Apply(tmp167, []any{sym_arr})
				tmp169 := lang.Apply(tmp76, []any{tmp78, tmp107, tmp166, tmp168})
				tmp170 := lang.Apply(tmp75, []any{tmp169})
				tmp171 := lang.Apply(tmp74, []any{tmp170})
				tmp172 := lang.Apply(tmp60, []any{tmp73, tmp171})
				tmp173 := lang.Apply(tmp59, []any{tmp172})
				tmp174 := lang.Apply(tmp58, []any{tmp173})
				tmp175 := lang.Apply(tmp22, []any{tmp24, tmp26, tmp28, tmp57, tmp174})
				tmp176 := lang.Apply(tmp21, []any{tmp175})
				tmp5 = tmp176
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_primitive_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_primitive_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// primitive-arrays
	{
		tmp0 := sym_primitive_DASH_arrays.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(165), kw_column, int(11), kw_end_DASH_line, int(165), kw_end_DASH_column, int(26), kw_arglists, lang.NewList(lang.NewVector(sym_types)), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
			tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
			tmp7 := checkDerefVar(var_clojure_DOT_core_list)
			tmp8 := lang.Apply(tmp7, []any{sym_do})
			tmp9 := checkDerefVar(var_clojure_DOT_core_map)
			var tmp10 lang.FnFunc
			tmp10 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v11 := args[0]
				_ = v11
				tmp12 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_clojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_clojure_DOT_data_DOT_generators_SLASH_primitive_DASH_array})
				tmp16 := checkDerefVar(var_clojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v11})
				tmp18 := lang.Apply(tmp13, []any{tmp15, tmp17})
				tmp19 := lang.Apply(tmp12, []any{tmp18})
				return tmp19
			})
			tmp11 := lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(167), kw_column, int(15), kw_end_DASH_line, int(167), kw_end_DASH_column, int(50))
			tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp13 := lang.Apply(tmp9, []any{tmp12, v4})
			tmp14 := lang.Apply(tmp6, []any{tmp8, tmp13})
			tmp15 := lang.Apply(tmp5, []any{tmp14})
			return tmp15
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_primitive_DASH_arrays = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_primitive_DASH_arrays.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// printable-ascii-char
	{
		tmp0 := sym_printable_DASH_ascii_DASH_char.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(128), kw_column, int(7), kw_end_DASH_line, int(128), kw_end_DASH_column, int(26), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a char based on *rnd* in the printable ascii range.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_core_char)
			tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp4 := lang.Apply(tmp3, []any{int64(32), int64(127)})
			tmp5 := lang.Apply(tmp2, []any{tmp4})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_printable_DASH_ascii_DASH_char = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_printable_DASH_ascii_DASH_char.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand-nth
	{
		tmp0 := sym_rand_DASH_nth.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(68), kw_column, int(7), kw_end_DASH_line, int(68), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Replacement of core/rand-nth that allows control of the\n   randomization basis (through binding *rnd*).", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_core_nth)
			tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp5 := checkDerefVar(var_clojure_DOT_core_count)
			tmp6 := lang.Apply(tmp5, []any{v2})
			tmp7 := lang.Apply(tmp4, []any{int64(0), tmp6})
			tmp8 := lang.Apply(tmp3, []any{v2, tmp7})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_rand_DASH_nth = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_rand_DASH_nth.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ratio
	{
		tmp0 := sym_ratio.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(102), kw_column, int(7), kw_end_DASH_line, int(102), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_num_DASH_gen, sym_denom_DASH_gen)), kw_doc, "Generate a ratio, with numerator and denominator uniform longs\n   or as specified", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators_ratio)
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp5 := lang.Apply(tmp2, []any{tmp3, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core__SLASH_)
				tmp5 := lang.Apply(v2, nil)
				tmp6 := lang.Apply(v3, nil)
				tmp7 := lang.Apply(tmp4, []any{tmp5, tmp6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_ratio = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_ratio.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reps
	{
		tmp0 := sym_reps.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(37), kw_column, int(7), kw_end_DASH_line, int(37), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_sizer, sym_f)), kw_doc, "Returns sizer repetitions of f (or (f) if f is a fn).", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "count"
				tmp5 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
				tmp6 := lang.Apply(tmp5, []any{v2})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(var_clojure_DOT_core_fn_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v3})
				if lang.IsTruthy(tmp10) {
					tmp11 := checkDerefVar(var_clojure_DOT_core_repeatedly)
					tmp12 := lang.Apply(tmp11, []any{v7, v3})
					tmp8 = tmp12
				} else {
					tmp13 := checkDerefVar(var_clojure_DOT_core_repeat)
					tmp14 := lang.Apply(tmp13, []any{v7, v3})
					tmp8 = tmp14
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_reps = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_reps.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reservoir-sample
	{
		tmp0 := sym_reservoir_DASH_sample.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(328), kw_column, int(7), kw_end_DASH_line, int(328), kw_end_DASH_column, int(22), kw_arglists, lang.NewList(lang.NewVector(sym_ct, sym_coll)), kw_doc, "Reservoir sample ct items from coll, using *rnd*.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "result"
				tmp5 := checkDerefVar(var_clojure_DOT_core_transient)
				tmp6 := checkDerefVar(var_clojure_DOT_core_vec)
				tmp7 := checkDerefVar(var_clojure_DOT_core_take)
				tmp8 := lang.Apply(tmp7, []any{v2, v3})
				tmp9 := lang.Apply(tmp6, []any{tmp8})
				tmp10 := lang.Apply(tmp5, []any{tmp9})
				var v11 any = tmp10
				_ = v11
				// let binding "n"
				var v12 any = v2
				_ = v12
				// let binding "coll"
				tmp13 := checkDerefVar(var_clojure_DOT_core_drop)
				tmp14 := lang.Apply(tmp13, []any{v2, v3})
				var v15 any = tmp14
				_ = v15
				for {
					var tmp16 any
					tmp17 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp18 := lang.Apply(tmp17, []any{v15})
					if lang.IsTruthy(tmp18) {
						var tmp19 any
						{ // let
							// let binding "pos"
							tmp20 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
							tmp21 := checkDerefVar(var_clojure_DOT_core_inc)
							tmp22 := lang.Apply(tmp21, []any{v12})
							tmp23 := lang.Apply(tmp20, []any{int64(0), tmp22})
							var v24 any = tmp23
							_ = v24
							var tmp26 any
							tmp27 := checkDerefVar(var_clojure_DOT_core__LT_)
							tmp28 := lang.Apply(tmp27, []any{v24, v2})
							if lang.IsTruthy(tmp28) {
								tmp29 := checkDerefVar(var_clojure_DOT_core_assoc_BANG_)
								tmp30 := checkDerefVar(var_clojure_DOT_core_first)
								tmp31 := lang.Apply(tmp30, []any{v15})
								tmp32 := lang.Apply(tmp29, []any{v11, v24, tmp31})
								tmp26 = tmp32
							} else {
								tmp26 = v11
							}
							var tmp25 any = tmp26
							tmp34 := checkDerefVar(var_clojure_DOT_core_inc)
							tmp35 := lang.Apply(tmp34, []any{v12})
							var tmp33 any = tmp35
							tmp37 := checkDerefVar(var_clojure_DOT_core_rest)
							tmp38 := lang.Apply(tmp37, []any{v15})
							var tmp36 any = tmp38
							v11 = tmp25
							v12 = tmp33
							v15 = tmp36
							continue
						} // end let
						tmp16 = tmp19
					} else {
						tmp20 := checkDerefVar(var_clojure_DOT_core_persistent_BANG_)
						tmp21 := lang.Apply(tmp20, []any{v11})
						tmp16 = tmp21
					}
					tmp4 = tmp16
					break
				}
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_reservoir_DASH_sample = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_reservoir_DASH_sample.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// scalar
	{
		tmp0 := sym_scalar.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(287), kw_column, int(7), kw_end_DASH_line, int(287), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a scalar based on *rnd*.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
			tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_rand_DASH_nth)
			tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_scalars)
			tmp5 := lang.Apply(tmp3, []any{tmp4})
			tmp6 := lang.Apply(tmp2, []any{tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_scalar = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_scalar.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// scalars
	{
		tmp0 := sym_scalars.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(270), kw_column, int(6), kw_end_DASH_line, int(270), kw_end_DASH_column, int(12), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				return closed0
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "clojure/core.glj", kw_line, int(1443), kw_column, int(7), kw_end_DASH_line, int(1443), kw_end_DASH_column, int(21))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp4 := checkDerefVar(var_clojure_DOT_core_inc)
			tmp5 := checkDerefVar(var_clojure_DOT_core_int)
			tmp6 := lang.Apply(tmp5, []any{nil})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			tmp8 := lang.Apply(tmp3, []any{nil, tmp7})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp5 := lang.Apply(tmp4, nil)
				tmp6, ok := lang.FieldOrMethod(tmp5, "nextLong")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp5, "nextLong")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				return tmp7
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_long)
				tmp7 := checkDerefVar(var_clojure_DOT_core__PLUS_)
				tmp8 := checkDerefVar(var_clojure_DOT_core__STAR_)
				tmp9 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp10 := lang.Apply(tmp9, nil)
				tmp11, ok := lang.FieldOrMethod(tmp10, "nextDouble")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp10, "nextDouble")))
				}
				var tmp12 any
				switch reflect.TypeOf(tmp11).Kind() {
				case reflect.Func:
					tmp12 = lang.Apply(tmp11, nil)
				default:
					tmp12 = tmp11
				}
				tmp13 := checkDerefVar(var_clojure_DOT_core__DASH_)
				tmp14 := lang.Apply(tmp13, []any{v5, v4})
				tmp15 := lang.Apply(tmp8, []any{tmp12, tmp14})
				tmp16 := lang.Apply(tmp7, []any{v4, tmp15})
				tmp17 := lang.Apply(nil, []any{tmp16})
				tmp18 := lang.Apply(tmp6, []any{tmp17})
				return tmp18
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp5 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
			tmp6 := lang.Apply(tmp5, nil)
			tmp7, ok := lang.FieldOrMethod(tmp6, "nextBoolean")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp6, "nextBoolean")))
			}
			var tmp8 any
			switch reflect.TypeOf(tmp7).Kind() {
			case reflect.Func:
				tmp8 = lang.Apply(tmp7, nil)
			default:
				tmp8 = tmp7
			}
			return tmp8
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp6 := checkDerefVar(var_clojure_DOT_core_char)
			tmp7 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp8 := lang.Apply(tmp7, []any{int64(32), int64(127)})
			tmp9 := lang.Apply(tmp6, []any{tmp8})
			return tmp9
		})
		tmp5 = tmp5.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp7 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp8 := checkDerefVar(var_clojure_DOT_data_DOT_generators_printable_DASH_ascii_DASH_char)
				tmp9 := lang.Apply(tmp7, []any{tmp8})
				return tmp9
			case 1:
				v7 := args[0]
				_ = v7
				tmp8 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp9 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp10 := lang.Apply(tmp8, []any{v7, tmp9})
				return tmp10
			case 2:
				v7 := args[0]
				_ = v7
				v8 := args[1]
				_ = v8
				tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp10 := checkDerefVar(var_clojure_DOT_core_str)
				tmp11 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp12 := lang.Apply(tmp11, []any{v8, v7})
				tmp13 := lang.Apply(tmp9, []any{tmp10, tmp12})
				return tmp13
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp6 = tmp6.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp7 lang.FnFunc
		tmp7 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp8 := checkDerefVar(var_clojure_DOT_data_DOT_generators_symbol)
				tmp9 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp10 := lang.Apply(tmp8, []any{tmp9})
				return tmp10
			case 1:
				v8 := args[0]
				_ = v8
				tmp9 := checkDerefVar(var_clojure_DOT_core_symbol)
				tmp10 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp11 := lang.Apply(tmp10, []any{v8})
				tmp12 := lang.Apply(tmp9, []any{tmp11})
				return tmp12
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp7 = tmp7.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp9 := checkDerefVar(var_clojure_DOT_data_DOT_generators_keyword)
				tmp10 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp11 := lang.Apply(tmp9, []any{tmp10})
				return tmp11
			case 1:
				v9 := args[0]
				_ = v9
				tmp10 := checkDerefVar(var_clojure_DOT_core_keyword)
				tmp11 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp12 := lang.Apply(tmp11, []any{v9})
				tmp13 := lang.Apply(tmp10, []any{tmp12})
				return tmp13
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp8 = tmp8.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var tmp9 lang.FnFunc
		tmp9 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp10 := checkDerefVar(var_clojure_DOT_data_DOT_generators_ratio)
				tmp11 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp12 := checkDerefVar(var_clojure_DOT_data_DOT_generators_long)
				tmp13 := lang.Apply(tmp10, []any{tmp11, tmp12})
				return tmp13
			case 2:
				v10 := args[0]
				_ = v10
				v11 := args[1]
				_ = v11
				tmp12 := checkDerefVar(var_clojure_DOT_core__SLASH_)
				tmp13 := lang.Apply(v10, nil)
				tmp14 := lang.Apply(v11, nil)
				tmp15 := lang.Apply(tmp12, []any{tmp13, tmp14})
				return tmp15
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp9 = tmp9.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_scalars = ns.InternWithValue(tmp0, lang.NewVector(tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8, tmp9), true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_scalars.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set
	{
		tmp0 := sym_set.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(199), kw_column, int(7), kw_end_DASH_line, int(199), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_doc, "Create a set with elements from f and sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_set)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_into)
				tmp5 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp6 := lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(203), kw_column, int(12), kw_end_DASH_line, int(203), kw_end_DASH_column, int(14))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp9 := lang.Apply(tmp8, []any{v3, v2})
				tmp10 := lang.Apply(tmp4, []any{tmp7, tmp9})
				return tmp10
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_set = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_set.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// short
	{
		tmp0 := sym_short.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(113), kw_column, int(7), kw_end_DASH_line, int(113), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a short based on *rnd* in the short range.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
			tmp3 := checkDerefVar(var_clojure_DOT_core_inc)
			tmp4 := checkDerefVar(var_clojure_DOT_core_long)
			tmp5 := lang.Apply(tmp4, []any{nil})
			tmp6 := lang.Apply(tmp3, []any{tmp5})
			tmp7 := lang.Apply(tmp2, []any{nil, tmp6})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_short = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_short.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// short-array
	{
		tmp0 := sym_short_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_doc, "Create an array with elements from f and sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_short_DASH_array)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "arr"
					tmp5 := checkDerefVar(var_clojure_DOT_core_short_DASH_array)
					tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
					tmp7 := lang.Apply(tmp6, []any{v3})
					tmp8 := lang.Apply(tmp5, []any{tmp7})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					{ // let
						// let binding "n__0__auto__"
						tmp11 := checkDerefVar(var_clojure_DOT_core_long)
						tmp12 := checkDerefVar(var_clojure_DOT_core_count)
						tmp13 := lang.Apply(tmp12, []any{v9})
						tmp14 := lang.Apply(tmp11, []any{tmp13})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						{ // let
							// let binding "i"
							var v17 any = int64(0)
							_ = v17
							for {
								var tmp18 any
								tmp19 := checkDerefVar(var_clojure_DOT_core__LT_)
								tmp20 := lang.Apply(tmp19, []any{v17, v15})
								if lang.IsTruthy(tmp20) {
									tmp21 := checkDerefVar(var_clojure_DOT_core_aset)
									tmp22 := checkDerefVar(var_clojure_DOT_core_short)
									tmp23 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
									tmp24 := lang.Apply(tmp23, []any{v2})
									tmp25 := lang.Apply(tmp22, []any{tmp24})
									tmp26 := lang.Apply(tmp21, []any{v9, v17, tmp25})
									_ = tmp26
									tmp28 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_inc)
									tmp29 := lang.Apply(tmp28, []any{v17})
									var tmp27 any = tmp29
									v17 = tmp27
									continue
								} else {
								}
								tmp16 = tmp18
								break
							}
						} // end let
						tmp10 = tmp16
					} // end let
					_ = tmp10
					tmp4 = v9
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_short_DASH_array = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_short_DASH_array.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// string
	{
		tmp0 := sym_string.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(214), kw_column, int(7), kw_end_DASH_line, int(214), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_doc, "Create a string with chars from f and sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_printable_DASH_ascii_DASH_char)
				tmp4 := lang.Apply(tmp2, []any{tmp3})
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_string)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp5 := checkDerefVar(var_clojure_DOT_core_str)
				tmp6 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp7 := lang.Apply(tmp6, []any{v3, v2})
				tmp8 := lang.Apply(tmp4, []any{tmp5, tmp7})
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_string = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_string.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// symbol
	{
		tmp0 := sym_symbol.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(248), kw_column, int(7), kw_end_DASH_line, int(248), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_sizer)), kw_doc, "Create a non-namespaced symbol sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators_symbol)
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp4 := lang.Apply(tmp2, []any{tmp3})
				return tmp4
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_symbol)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_name)
				tmp5 := lang.Apply(tmp4, []any{v2})
				tmp6 := lang.Apply(tmp3, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_symbol = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_symbol.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tuple
	{
		tmp0 := sym_tuple.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(74), kw_column, int(7), kw_end_DASH_line, int(74), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_generators)), kw_doc, "Generate a tuple with one element from each generator.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 0)
				restArgs := args[0:]
				var v2 any
				if len(restArgs) > 0 {
					v2 = lang.NewList(restArgs...)
				}
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_into)
				tmp4 := lang.NewVector()
				tmp5 := lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(77), kw_column, int(9), kw_end_DASH_line, int(77), kw_end_DASH_column, int(10))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp7 := checkDerefVar(var_clojure_DOT_core_map)
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v9 := args[0]
					_ = v9
					tmp10 := lang.Apply(v9, nil)
					return tmp10
				})
				tmp9 := lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(77), kw_column, int(17), kw_end_DASH_line, int(77), kw_end_DASH_column, int(20))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := lang.Apply(tmp7, []any{tmp10, v2})
				tmp12 := lang.Apply(tmp3, []any{tmp6, tmp11})
				return tmp12
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_tuple = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_tuple.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// uniform
	{
		tmp0 := sym_uniform.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(51), kw_column, int(7), kw_end_DASH_line, int(51), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_lo, sym_hi)), kw_doc, "Uniform distribution from lo (inclusive) to hi (exclusive).\n   Defaults to range of Java long.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp3 := lang.Apply(tmp2, nil)
				tmp4, ok := lang.FieldOrMethod(tmp3, "nextLong")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp3, "nextLong")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_long)
				tmp5 := checkDerefVar(var_clojure_DOT_core__PLUS_)
				tmp6 := checkDerefVar(var_clojure_DOT_core__STAR_)
				tmp7 := checkDerefVar(var_clojure_DOT_data_DOT_generators__STAR_rnd_STAR__DASH_)
				tmp8 := lang.Apply(tmp7, nil)
				tmp9, ok := lang.FieldOrMethod(tmp8, "nextDouble")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp8, "nextDouble")))
				}
				var tmp10 any
				switch reflect.TypeOf(tmp9).Kind() {
				case reflect.Func:
					tmp10 = lang.Apply(tmp9, nil)
				default:
					tmp10 = tmp9
				}
				tmp11 := checkDerefVar(var_clojure_DOT_core__DASH_)
				tmp12 := lang.Apply(tmp11, []any{v3, v2})
				tmp13 := lang.Apply(tmp6, []any{tmp10, tmp12})
				tmp14 := lang.Apply(tmp5, []any{v2, tmp13})
				tmp15 := lang.Apply(nil, []any{tmp14})
				tmp16 := lang.Apply(tmp4, []any{tmp15})
				return tmp16
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_uniform = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_uniform.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vec
	{
		tmp0 := sym_vec.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(193), kw_column, int(7), kw_end_DASH_line, int(193), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_sizer)), kw_doc, "Create a vec with elements from f and sized from sizer.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_data_DOT_generators_vec)
				tmp4 := checkDerefVar(var_clojure_DOT_data_DOT_generators_default_DASH_sizer)
				tmp5 := lang.Apply(tmp3, []any{v2, tmp4})
				return tmp5
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_into)
				tmp5 := lang.NewVector()
				tmp6 := lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(197), kw_column, int(12), kw_end_DASH_line, int(197), kw_end_DASH_column, int(13))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := checkDerefVar(var_clojure_DOT_data_DOT_generators_reps)
				tmp9 := lang.Apply(tmp8, []any{v3, v2})
				tmp10 := lang.Apply(tmp4, []any{tmp7, tmp9})
				return tmp10
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_vec = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_vec.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// weighted
	{
		tmp0 := sym_weighted.WithMeta(lang.NewMap(kw_file, "clojure/data/generators.glj", kw_line, int(79), kw_column, int(7), kw_end_DASH_line, int(79), kw_end_DASH_column, int(14), kw_arglists, lang.NewList(lang.NewVector(sym_m)), kw_doc, "Given a map of generators and weights, return a value from one of\n   the generators, selecting generator based on weights.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_data_DOT_generators))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "weights"
				tmp4 := checkDerefVar(var_clojure_DOT_core_reductions)
				tmp5 := checkDerefVar(var_clojure_DOT_core__PLUS_)
				tmp6 := checkDerefVar(var_clojure_DOT_core_vals)
				tmp7 := lang.Apply(tmp6, []any{v2})
				tmp8 := lang.Apply(tmp4, []any{tmp5, tmp7})
				var v9 any = tmp8
				_ = v9
				// let binding "total"
				tmp10 := checkDerefVar(var_clojure_DOT_core_last)
				tmp11 := lang.Apply(tmp10, []any{v9})
				var v12 any = tmp11
				_ = v12
				// let binding "choices"
				tmp13 := checkDerefVar(var_clojure_DOT_core_map)
				tmp14 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp15 := checkDerefVar(var_clojure_DOT_core_keys)
				tmp16 := lang.Apply(tmp15, []any{v2})
				tmp17 := lang.Apply(tmp13, []any{tmp14, tmp16, v9})
				var v18 any = tmp17
				_ = v18
				var tmp19 any
				{ // let
					// let binding "choice"
					tmp20 := checkDerefVar(var_clojure_DOT_data_DOT_generators_uniform)
					tmp21 := lang.Apply(tmp20, []any{int64(0), v12})
					var v22 any = tmp21
					_ = v22
					var tmp23 any
					{ // let
						// let binding "G__1024"
						var v24 any = v18
						_ = v24
						// let binding "vec__1025"
						var v25 any = v24
						_ = v25
						// let binding "seq__1026"
						tmp26 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp27 := lang.Apply(tmp26, []any{v25})
						var v28 any = tmp27
						_ = v28
						// let binding "first__1027"
						tmp29 := checkDerefVar(var_clojure_DOT_core_first)
						tmp30 := lang.Apply(tmp29, []any{v28})
						var v31 any = tmp30
						_ = v31
						// let binding "seq__1026"
						tmp32 := checkDerefVar(var_clojure_DOT_core_next)
						tmp33 := lang.Apply(tmp32, []any{v28})
						var v34 any = tmp33
						_ = v34
						// let binding "vec__1028"
						var v35 any = v31
						_ = v35
						// let binding "c"
						tmp36 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp37 := lang.Apply(tmp36, []any{v35, int64(0), nil})
						var v38 any = tmp37
						_ = v38
						// let binding "w"
						tmp39 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp40 := lang.Apply(tmp39, []any{v35, int64(1), nil})
						var v41 any = tmp40
						_ = v41
						// let binding "more"
						var v42 any = v34
						_ = v42
						var tmp43 any
						{ // let
							// let binding "G__1024"
							var v44 any = v24
							_ = v44
							for {
								var tmp45 any
								{ // let
									// let binding "vec__1031"
									var v46 any = v44
									_ = v46
									// let binding "seq__1032"
									tmp47 := checkDerefVar(var_clojure_DOT_core_seq)
									tmp48 := lang.Apply(tmp47, []any{v46})
									var v49 any = tmp48
									_ = v49
									// let binding "first__1033"
									tmp50 := checkDerefVar(var_clojure_DOT_core_first)
									tmp51 := lang.Apply(tmp50, []any{v49})
									var v52 any = tmp51
									_ = v52
									// let binding "seq__1032"
									tmp53 := checkDerefVar(var_clojure_DOT_core_next)
									tmp54 := lang.Apply(tmp53, []any{v49})
									var v55 any = tmp54
									_ = v55
									// let binding "vec__1034"
									var v56 any = v52
									_ = v56
									// let binding "c"
									tmp57 := checkDerefVar(var_clojure_DOT_core_nth)
									tmp58 := lang.Apply(tmp57, []any{v56, int64(0), nil})
									var v59 any = tmp58
									_ = v59
									// let binding "w"
									tmp60 := checkDerefVar(var_clojure_DOT_core_nth)
									tmp61 := lang.Apply(tmp60, []any{v56, int64(1), nil})
									var v62 any = tmp61
									_ = v62
									// let binding "more"
									var v63 any = v55
									_ = v63
									var tmp64 any
									if lang.IsTruthy(v62) {
										var tmp65 any
										tmp66 := checkDerefVar(var_clojure_DOT_core__LT_)
										tmp67 := lang.Apply(tmp66, []any{v22, v62})
										if lang.IsTruthy(tmp67) {
											tmp68 := checkDerefVar(var_clojure_DOT_data_DOT_generators_call_DASH_through)
											tmp69 := lang.Apply(tmp68, []any{v59})
											tmp65 = tmp69
										} else {
											var tmp70 any = v63
											v44 = tmp70
											continue
										}
										tmp64 = tmp65
									} else {
									}
									tmp45 = tmp64
								} // end let
								tmp43 = tmp45
								break
							}
						} // end let
						tmp23 = tmp43
					} // end let
					tmp19 = tmp23
				} // end let
				tmp3 = tmp19
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_data_DOT_generators_weighted = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_data_DOT_generators_weighted.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}

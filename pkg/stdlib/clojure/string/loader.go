// Code generated by glojure codegen. DO NOT EDIT.

package string

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	reflect "reflect"
	regexp6 "regexp"
	strings5 "strings"
	unicode4 "unicode"
)

func init() {
	runtime.RegisterNSLoader("clojure/string", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "clojure.string"
func LoadNS() {
	// Check if already AOT-loaded
	if ns := lang.FindNamespace(lang.NewSymbol("clojure.string")); ns != nil {
		if meta := ns.Meta(); meta != nil {
			if aotLoaded := meta.ValAt(lang.NewKeyword("aot-loaded")); aotLoaded != nil {
				return // Already loaded, skip reinitialization
			}
		}
	}
	sym__PLUS_ := lang.NewSymbol("+")
	sym__LT_ := lang.NewSymbol("<")
	sym__EQ_ := lang.NewSymbol("=")
	sym_apply := lang.NewSymbol("apply")
	sym_atom := lang.NewSymbol("atom")
	sym_blank_QMARK_ := lang.NewSymbol("blank?")
	sym_capitalize := lang.NewSymbol("capitalize")
	sym_check_DASH_string := lang.NewSymbol("check-string")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_string := lang.NewSymbol("clojure.string")
	sym_cmap := lang.NewSymbol("cmap")
	sym_coll := lang.NewSymbol("coll")
	sym_count := lang.NewSymbol("count")
	sym_deref := lang.NewSymbol("deref")
	sym_ends_DASH_with_QMARK_ := lang.NewSymbol("ends-with?")
	sym_escape := lang.NewSymbol("escape")
	sym_f := lang.NewSymbol("f")
	sym_flatten := lang.NewSymbol("flatten")
	sym_from_DASH_index := lang.NewSymbol("from-index")
	sym_inc := lang.NewSymbol("inc")
	sym_includes_QMARK_ := lang.NewSymbol("includes?")
	sym_index_DASH_of := lang.NewSymbol("index-of")
	sym_instance_QMARK_ := lang.NewSymbol("instance?")
	sym_int := lang.NewSymbol("int")
	sym_join := lang.NewSymbol("join")
	sym_last_DASH_index_DASH_of := lang.NewSymbol("last-index-of")
	sym_limit := lang.NewSymbol("limit")
	sym_lower_DASH_case := lang.NewSymbol("lower-case")
	sym_map := lang.NewSymbol("map")
	sym_match := lang.NewSymbol("match")
	sym_max := lang.NewSymbol("max")
	sym_maybe_DASH_s := lang.NewSymbol("maybe-s")
	sym_min := lang.NewSymbol("min")
	sym_nil_QMARK_ := lang.NewSymbol("nil?")
	sym_re := lang.NewSymbol("re")
	sym_re_DASH_groups := lang.NewSymbol("re-groups")
	sym_re_DASH_matcher := lang.NewSymbol("re-matcher")
	sym_re_DASH_pattern := lang.NewSymbol("re-pattern")
	sym_re_DASH_quote_DASH_replacement := lang.NewSymbol("re-quote-replacement")
	sym_replace := lang.NewSymbol("replace")
	sym_replace_DASH_by := lang.NewSymbol("replace-by")
	sym_replace_DASH_first := lang.NewSymbol("replace-first")
	sym_replace_DASH_first_DASH_by := lang.NewSymbol("replace-first-by")
	sym_replace_DASH_first_DASH_char := lang.NewSymbol("replace-first-char")
	sym_replace_DASH_first_DASH_str := lang.NewSymbol("replace-first-str")
	sym_replacement := lang.NewSymbol("replacement")
	sym_reset_BANG_ := lang.NewSymbol("reset!")
	sym_reverse := lang.NewSymbol("reverse")
	sym_s := lang.NewSymbol("s")
	sym_separator := lang.NewSymbol("separator")
	sym_seq := lang.NewSymbol("seq")
	sym_split := lang.NewSymbol("split")
	sym_split_DASH_lines := lang.NewSymbol("split-lines")
	sym_starts_DASH_with_QMARK_ := lang.NewSymbol("starts-with?")
	sym_str := lang.NewSymbol("str")
	sym_subs := lang.NewSymbol("subs")
	sym_substr := lang.NewSymbol("substr")
	sym_trim := lang.NewSymbol("trim")
	sym_trim_DASH_newline := lang.NewSymbol("trim-newline")
	sym_triml := lang.NewSymbol("triml")
	sym_trimr := lang.NewSymbol("trimr")
	sym_unchecked_DASH_int := lang.NewSymbol("unchecked-int")
	sym_upper_DASH_case := lang.NewSymbol("upper-case")
	sym_value := lang.NewSymbol("value")
	kw_added := lang.NewKeyword("added")
	kw_arglists := lang.NewKeyword("arglists")
	kw_column := lang.NewKeyword("column")
	kw_doc := lang.NewKeyword("doc")
	kw_else := lang.NewKeyword("else")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_name := lang.NewKeyword("name")
	kw_ns := lang.NewKeyword("ns")
	kw_private := lang.NewKeyword("private")
	kw_rettag := lang.NewKeyword("rettag")
	kw_tag := lang.NewKeyword("tag")
	// var clojure.core/=
	var_clojure_DOT_core__EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym__EQ_)
	// var clojure.core/<
	var_clojure_DOT_core__LT_ := lang.InternVarName(sym_clojure_DOT_core, sym__LT_)
	// var clojure.core/+
	var_clojure_DOT_core__PLUS_ := lang.InternVarName(sym_clojure_DOT_core, sym__PLUS_)
	// var clojure.core/apply
	var_clojure_DOT_core_apply := lang.InternVarName(sym_clojure_DOT_core, sym_apply)
	// var clojure.core/atom
	var_clojure_DOT_core_atom := lang.InternVarName(sym_clojure_DOT_core, sym_atom)
	// var clojure.core/count
	var_clojure_DOT_core_count := lang.InternVarName(sym_clojure_DOT_core, sym_count)
	// var clojure.core/deref
	var_clojure_DOT_core_deref := lang.InternVarName(sym_clojure_DOT_core, sym_deref)
	// var clojure.core/flatten
	var_clojure_DOT_core_flatten := lang.InternVarName(sym_clojure_DOT_core, sym_flatten)
	// var clojure.core/inc
	var_clojure_DOT_core_inc := lang.InternVarName(sym_clojure_DOT_core, sym_inc)
	// var clojure.core/instance?
	var_clojure_DOT_core_instance_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_instance_QMARK_)
	// var clojure.core/int
	var_clojure_DOT_core_int := lang.InternVarName(sym_clojure_DOT_core, sym_int)
	// var clojure.core/map
	var_clojure_DOT_core_map := lang.InternVarName(sym_clojure_DOT_core, sym_map)
	// var clojure.core/max
	var_clojure_DOT_core_max := lang.InternVarName(sym_clojure_DOT_core, sym_max)
	// var clojure.core/min
	var_clojure_DOT_core_min := lang.InternVarName(sym_clojure_DOT_core, sym_min)
	// var clojure.core/nil?
	var_clojure_DOT_core_nil_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_nil_QMARK_)
	// var clojure.core/re-groups
	var_clojure_DOT_core_re_DASH_groups := lang.InternVarName(sym_clojure_DOT_core, sym_re_DASH_groups)
	// var clojure.core/re-matcher
	var_clojure_DOT_core_re_DASH_matcher := lang.InternVarName(sym_clojure_DOT_core, sym_re_DASH_matcher)
	// var clojure.core/re-pattern
	var_clojure_DOT_core_re_DASH_pattern := lang.InternVarName(sym_clojure_DOT_core, sym_re_DASH_pattern)
	// var clojure.core/reset!
	var_clojure_DOT_core_reset_BANG_ := lang.InternVarName(sym_clojure_DOT_core, sym_reset_BANG_)
	// var clojure.core/reverse
	var_clojure_DOT_core_reverse := lang.InternVarName(sym_clojure_DOT_core, sym_reverse)
	// var clojure.core/seq
	var_clojure_DOT_core_seq := lang.InternVarName(sym_clojure_DOT_core, sym_seq)
	// var clojure.core/str
	var_clojure_DOT_core_str := lang.InternVarName(sym_clojure_DOT_core, sym_str)
	// var clojure.core/subs
	var_clojure_DOT_core_subs := lang.InternVarName(sym_clojure_DOT_core, sym_subs)
	// var clojure.core/unchecked-int
	var_clojure_DOT_core_unchecked_DASH_int := lang.InternVarName(sym_clojure_DOT_core, sym_unchecked_DASH_int)
	// var clojure.string/blank?
	var_clojure_DOT_string_blank_QMARK_ := lang.InternVarName(sym_clojure_DOT_string, sym_blank_QMARK_)
	// var clojure.string/capitalize
	var_clojure_DOT_string_capitalize := lang.InternVarName(sym_clojure_DOT_string, sym_capitalize)
	// var clojure.string/check-string
	var_clojure_DOT_string_check_DASH_string := lang.InternVarName(sym_clojure_DOT_string, sym_check_DASH_string)
	// var clojure.string/ends-with?
	var_clojure_DOT_string_ends_DASH_with_QMARK_ := lang.InternVarName(sym_clojure_DOT_string, sym_ends_DASH_with_QMARK_)
	// var clojure.string/escape
	var_clojure_DOT_string_escape := lang.InternVarName(sym_clojure_DOT_string, sym_escape)
	// var clojure.string/includes?
	var_clojure_DOT_string_includes_QMARK_ := lang.InternVarName(sym_clojure_DOT_string, sym_includes_QMARK_)
	// var clojure.string/index-of
	var_clojure_DOT_string_index_DASH_of := lang.InternVarName(sym_clojure_DOT_string, sym_index_DASH_of)
	// var clojure.string/join
	var_clojure_DOT_string_join := lang.InternVarName(sym_clojure_DOT_string, sym_join)
	// var clojure.string/last-index-of
	var_clojure_DOT_string_last_DASH_index_DASH_of := lang.InternVarName(sym_clojure_DOT_string, sym_last_DASH_index_DASH_of)
	// var clojure.string/lower-case
	var_clojure_DOT_string_lower_DASH_case := lang.InternVarName(sym_clojure_DOT_string, sym_lower_DASH_case)
	// var clojure.string/re-quote-replacement
	var_clojure_DOT_string_re_DASH_quote_DASH_replacement := lang.InternVarName(sym_clojure_DOT_string, sym_re_DASH_quote_DASH_replacement)
	// var clojure.string/replace
	var_clojure_DOT_string_replace := lang.InternVarName(sym_clojure_DOT_string, sym_replace)
	// var clojure.string/replace-by
	var_clojure_DOT_string_replace_DASH_by := lang.InternVarName(sym_clojure_DOT_string, sym_replace_DASH_by)
	// var clojure.string/replace-first
	var_clojure_DOT_string_replace_DASH_first := lang.InternVarName(sym_clojure_DOT_string, sym_replace_DASH_first)
	// var clojure.string/replace-first-by
	var_clojure_DOT_string_replace_DASH_first_DASH_by := lang.InternVarName(sym_clojure_DOT_string, sym_replace_DASH_first_DASH_by)
	// var clojure.string/replace-first-char
	var_clojure_DOT_string_replace_DASH_first_DASH_char := lang.InternVarName(sym_clojure_DOT_string, sym_replace_DASH_first_DASH_char)
	// var clojure.string/replace-first-str
	var_clojure_DOT_string_replace_DASH_first_DASH_str := lang.InternVarName(sym_clojure_DOT_string, sym_replace_DASH_first_DASH_str)
	// var clojure.string/reverse
	var_clojure_DOT_string_reverse := lang.InternVarName(sym_clojure_DOT_string, sym_reverse)
	// var clojure.string/split
	var_clojure_DOT_string_split := lang.InternVarName(sym_clojure_DOT_string, sym_split)
	// var clojure.string/split-lines
	var_clojure_DOT_string_split_DASH_lines := lang.InternVarName(sym_clojure_DOT_string, sym_split_DASH_lines)
	// var clojure.string/starts-with?
	var_clojure_DOT_string_starts_DASH_with_QMARK_ := lang.InternVarName(sym_clojure_DOT_string, sym_starts_DASH_with_QMARK_)
	// var clojure.string/trim
	var_clojure_DOT_string_trim := lang.InternVarName(sym_clojure_DOT_string, sym_trim)
	// var clojure.string/trim-newline
	var_clojure_DOT_string_trim_DASH_newline := lang.InternVarName(sym_clojure_DOT_string, sym_trim_DASH_newline)
	// var clojure.string/triml
	var_clojure_DOT_string_triml := lang.InternVarName(sym_clojure_DOT_string, sym_triml)
	// var clojure.string/trimr
	var_clojure_DOT_string_trimr := lang.InternVarName(sym_clojure_DOT_string, sym_trimr)
	// var clojure.string/upper-case
	var_clojure_DOT_string_upper_DASH_case := lang.InternVarName(sym_clojure_DOT_string, sym_upper_DASH_case)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_clojure_DOT_string)
	_ = ns
	// ends-with?
	{
		tmp0 := sym_ends_DASH_with_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_substr)), kw_doc, "True if s ends with substr.", kw_file, "clojure/string.glj", kw_added, "1.8", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_ends_DASH_with_QMARK_, kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(309), kw_end_DASH_line, int(309))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(lang.ToString, []any{v2})
			tmp5 := lang.Apply(strings5.HasSuffix, []any{tmp4, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_ends_DASH_with_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_ends_DASH_with_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// includes?
	{
		tmp0 := sym_includes_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_substr)), kw_doc, "True if s includes substr.", kw_file, "clojure/string.glj", kw_added, "1.8", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_includes_QMARK_, kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(315), kw_end_DASH_line, int(315))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(lang.ToString, []any{v2})
			tmp5 := lang.Apply(strings5.Contains, []any{tmp4, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_includes_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_includes_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lower-case
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_lower_DASH_case.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Converts string to all lower-case.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_lower_DASH_case, kw_end_DASH_column, int(27), kw_column, int(7), kw_line, int(188), kw_end_DASH_line, int(188))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(strings5.ToLower, []any{v3})
			return tmp4
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_lower_DASH_case = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_lower_DASH_case.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// split
	{
		tmp0 := sym_split.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_re), lang.NewVector(sym_s, sym_re, sym_limit)), kw_doc, "Splits string on a regular expression.  Optional argument limit is\n  the maximum number of parts. Not lazy. Returns vector of the parts.\n  Trailing empty strings are not returned - pass limit of -1 to return all.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_split, kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(194), kw_end_DASH_line, int(194))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(v3, "split")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("split is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v2, int64(-1)})
				tmp6 := lang.Apply(lang.CreateOwningLazilyPersistentVector, []any{tmp5})
				return tmp6
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "split")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("split is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v2, v4})
				tmp7 := lang.Apply(lang.CreateOwningLazilyPersistentVector, []any{tmp6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_split = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_split.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// starts-with?
	{
		tmp0 := sym_starts_DASH_with_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_substr)), kw_doc, "True if s starts with substr.", kw_file, "clojure/string.glj", kw_added, "1.8", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_starts_DASH_with_QMARK_, kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(303), kw_end_DASH_line, int(303))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(lang.ToString, []any{v2})
			tmp5 := lang.Apply(strings5.HasPrefix, []any{tmp4, v3})
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_starts_DASH_with_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_starts_DASH_with_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// trim
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_trim.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Removes whitespace from both ends of string.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_trim, kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(211), kw_end_DASH_line, int(211))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(strings5.TrimSpace, []any{v3})
			return tmp4
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_trim = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_trim.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// trim-newline
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_trim_DASH_newline.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_trim_DASH_newline, kw_end_DASH_column, int(29), kw_column, int(7), kw_line, int(229), kw_end_DASH_line, int(229))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(strings5.TrimRight, []any{v3, "\r\n"})
			return tmp4
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_trim_DASH_newline = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_trim_DASH_newline.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// triml
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_triml.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Removes whitespace from the left side of string.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_triml, kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(217), kw_end_DASH_line, int(217))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(strings5.TrimLeftFunc, []any{v3, unicode4.IsSpace})
			return tmp4
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_triml = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_triml.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// trimr
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_trimr.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Removes whitespace from the right side of string.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_trimr, kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(223), kw_end_DASH_line, int(223))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(strings5.TrimRightFunc, []any{v3, unicode4.IsSpace})
			return tmp4
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_trimr = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_trimr.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// upper-case
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_upper_DASH_case.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Converts string to all upper-case.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_upper_DASH_case, kw_end_DASH_column, int(27), kw_column, int(7), kw_line, int(182), kw_end_DASH_line, int(182))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(strings5.ToUpper, []any{v3})
			return tmp4
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_upper_DASH_case = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_upper_DASH_case.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// blank?
	{
		tmp0 := sym_blank_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "True if s is nil, empty, or contains only whitespace.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_blank_QMARK_, kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(236), kw_end_DASH_line, int(236))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			if lang.IsTruthy(v2) {
				var tmp4 any
				{ // let
					// let binding "index"
					tmp5 := checkDerefVar(var_clojure_DOT_core_int)
					tmp6 := lang.Apply(tmp5, []any{int64(0)})
					var v7 any = tmp6
					_ = v7
					for {
						var tmp8 any
						tmp9 := checkDerefVar(var_clojure_DOT_core__EQ_)
						tmp10 := checkDerefVar(var_clojure_DOT_core_count)
						tmp11 := lang.Apply(tmp10, []any{v2})
						tmp12 := lang.Apply(tmp9, []any{tmp11, v7})
						if lang.IsTruthy(tmp12) {
							tmp8 = true
						} else {
							var tmp13 any
							tmp14 := lang.Apply(lang.CharAt, []any{v2, v7})
							tmp15 := lang.Apply(unicode4.IsSpace, []any{tmp14})
							if lang.IsTruthy(tmp15) {
								tmp17 := checkDerefVar(var_clojure_DOT_core_inc)
								tmp18 := lang.Apply(tmp17, []any{v7})
								var tmp16 any = tmp18
								v7 = tmp16
								continue
							} else {
								tmp13 = false
							}
							tmp8 = tmp13
						}
						tmp4 = tmp8
						break
					}
				} // end let
				tmp3 = tmp4
			} else {
				tmp3 = true
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_blank_QMARK_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_blank_QMARK_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// capitalize
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_capitalize.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Converts first character of the string to upper-case, all other\n  characters to lower-case.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_capitalize, kw_end_DASH_column, int(27), kw_column, int(7), kw_line, int(171), kw_end_DASH_line, int(171))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "s"
				tmp5 := checkDerefVar(var_clojure_DOT_string_check_DASH_string)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(var_clojure_DOT_core__LT_)
				tmp10 := checkDerefVar(var_clojure_DOT_core_count)
				tmp11 := lang.Apply(tmp10, []any{v7})
				tmp12 := lang.Apply(tmp9, []any{tmp11, int64(2)})
				if lang.IsTruthy(tmp12) {
					tmp13 := lang.Apply(strings5.ToUpper, []any{v7})
					tmp8 = tmp13
				} else {
					tmp14 := checkDerefVar(var_clojure_DOT_core_str)
					tmp15 := checkDerefVar(var_clojure_DOT_core_subs)
					tmp16 := lang.Apply(tmp15, []any{v7, int64(0), int64(1)})
					tmp17 := lang.Apply(strings5.ToUpper, []any{tmp16})
					tmp18 := checkDerefVar(var_clojure_DOT_core_subs)
					tmp19 := lang.Apply(tmp18, []any{v7, int64(1)})
					tmp20 := lang.Apply(strings5.ToLower, []any{tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp17, tmp20})
					tmp8 = tmp21
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_capitalize = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_capitalize.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// check-string
	{
		tmp0 := sym_check_DASH_string.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_maybe_DASH_s)), kw_file, "clojure/string.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_check_DASH_string, kw_end_DASH_column, int(19), kw_column, int(8), kw_line, int(17), kw_end_DASH_line, int(17), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			if lang.IsTruthy(tmp5) {
				tmp6 := lang.Apply(lang.NewIllegalArgumentError, []any{"cannot call clojure.string function on nil"})
				panic(tmp6)
			} else {
				tmp3 = v2
			}
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_check_DASH_string = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_check_DASH_string.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-quote-replacement
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_re_DASH_quote_DASH_replacement.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_replacement)), kw_doc, "Given a replacement string that you wish to be a literal\n   replacement for a pattern match in replace or replace-first, do the\n   necessary escaping of special characters in the replacement.", kw_file, "clojure/string.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_re_DASH_quote_DASH_replacement, kw_end_DASH_column, int(37), kw_column, int(7), kw_line, int(29), kw_end_DASH_line, int(29))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_string_check_DASH_string)
			tmp5 := lang.Apply(tmp4, []any{v3})
			tmp6 := lang.Apply(strings5.ReplaceAll, []any{tmp5, "$", "$$"})
			return tmp6
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_re_DASH_quote_DASH_replacement = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_re_DASH_quote_DASH_replacement.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// escape
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_escape.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_cmap)), kw_doc, "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_escape, kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(249), kw_end_DASH_line, int(249))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "repls"
				tmp6 := checkDerefVar(var_clojure_DOT_core_flatten)
				tmp7 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp8 := lang.Apply(tmp7, []any{v4})
				tmp9 := lang.Apply(tmp6, []any{tmp8})
				var v10 any = tmp9
				_ = v10
				// let binding "replacer"
				tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp12 := lang.Apply(tmp11, []any{strings5.NewReplacer, v10})
				var v13 any = tmp12
				_ = v13
				tmp14, _ := lang.FieldOrMethod(v13, "Replace")
				if reflect.TypeOf(tmp14).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Replace is not a function")))
				}
				tmp15 := lang.Apply(tmp14, []any{v3})
				tmp5 = tmp15
			} // end let
			return tmp5
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_escape = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_escape.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// index-of
	{
		tmp0 := sym_index_DASH_of.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_value), lang.NewVector(sym_s, sym_value, sym_from_DASH_index)), kw_doc, "Return index of value (string or char) in s, optionally searching\n  forward from from-index. Return nil if value not found.", kw_file, "clojure/string.glj", kw_added, "1.8", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_index_DASH_of, kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(261), kw_end_DASH_line, int(261))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "s"
					tmp5 := checkDerefVar(var_clojure_DOT_string_check_DASH_string)
					tmp6 := lang.Apply(tmp5, []any{v2})
					var v7 any = tmp6
					_ = v7
					// let binding "result"
					var tmp8 any
					tmp9 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
					tmp10 := reflect.TypeOf(lang.NewChar(0))
					tmp11 := lang.Apply(tmp9, []any{tmp10, v3})
					if lang.IsTruthy(tmp11) {
						tmp12 := lang.Apply(lang.Builtins["rune"], []any{v3})
						tmp13 := lang.Apply(strings5.IndexRune, []any{v7, tmp12})
						tmp8 = tmp13
					} else {
						tmp14 := lang.Apply(strings5.Index, []any{v7, v3})
						tmp8 = tmp14
					}
					var v15 any = tmp8
					_ = v15
					var tmp16 any
					tmp17 := checkDerefVar(var_clojure_DOT_core__EQ_)
					tmp18 := lang.Apply(tmp17, []any{v15, int64(-1)})
					if lang.IsTruthy(tmp18) {
					} else {
						tmp19 := lang.Apply(lang.Builtins["int64"], []any{v15})
						tmp16 = tmp19
					}
					tmp4 = tmp16
				} // end let
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "from-index"
					tmp6 := checkDerefVar(var_clojure_DOT_core_min)
					tmp7 := checkDerefVar(var_clojure_DOT_core_count)
					tmp8 := lang.Apply(tmp7, []any{v2})
					tmp9 := checkDerefVar(var_clojure_DOT_core_max)
					tmp10 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_int)
					tmp11 := lang.Apply(tmp10, []any{v4})
					tmp12 := lang.Apply(tmp9, []any{int64(0), tmp11})
					tmp13 := lang.Apply(tmp6, []any{tmp8, tmp12})
					var v14 any = tmp13
					_ = v14
					// let binding "s"
					tmp15 := checkDerefVar(var_clojure_DOT_core_subs)
					tmp16 := checkDerefVar(var_clojure_DOT_string_check_DASH_string)
					tmp17 := lang.Apply(tmp16, []any{v2})
					tmp18 := lang.Apply(tmp15, []any{tmp17, v14})
					var v19 any = tmp18
					_ = v19
					// let binding "result"
					var tmp20 any
					tmp21 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
					tmp22 := reflect.TypeOf(lang.NewChar(0))
					tmp23 := lang.Apply(tmp21, []any{tmp22, v3})
					if lang.IsTruthy(tmp23) {
						tmp24 := lang.Apply(lang.Builtins["rune"], []any{v3})
						tmp25 := lang.Apply(strings5.IndexRune, []any{v19, tmp24})
						tmp20 = tmp25
					} else {
						tmp26 := lang.Apply(strings5.Index, []any{v19, v3})
						tmp20 = tmp26
					}
					var v27 any = tmp20
					_ = v27
					var tmp28 any
					tmp29 := checkDerefVar(var_clojure_DOT_core__EQ_)
					tmp30 := lang.Apply(tmp29, []any{v27, int64(-1)})
					if lang.IsTruthy(tmp30) {
					} else {
						tmp31 := checkDerefVar(var_clojure_DOT_core__PLUS_)
						tmp32 := lang.Apply(tmp31, []any{v27, v14})
						tmp28 = tmp32
					}
					tmp5 = tmp28
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_index_DASH_of = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_index_DASH_of.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// join
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_join.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_coll), lang.NewVector(sym_separator, sym_coll)), kw_doc, "Returns a string of all elements in coll, as returned by (seq coll),\n   separated by an optional separator.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_join, kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(162), kw_end_DASH_line, int(162))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp5 := checkDerefVar(var_clojure_DOT_core_str)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_map)
				tmp6 := checkDerefVar(var_clojure_DOT_core_str)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v4})
				tmp8 := checkDerefVar(var_clojure_DOT_core_str)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(strings5.Join, []any{tmp7, tmp9})
				return tmp10
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_join = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_join.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// last-index-of
	{
		tmp0 := sym_last_DASH_index_DASH_of.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_value), lang.NewVector(sym_s, sym_value, sym_from_DASH_index)), kw_doc, "Return last index of value (string or char) in s, optionally\n  searching backward from from-index. Return nil if value not found.", kw_file, "clojure/string.glj", kw_added, "1.8", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_last_DASH_index_DASH_of, kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(285), kw_end_DASH_line, int(285))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "s"
					tmp5 := checkDerefVar(var_clojure_DOT_string_check_DASH_string)
					tmp6 := lang.Apply(tmp5, []any{v2})
					var v7 any = tmp6
					_ = v7
					// let binding "result"
					tmp8 := checkDerefVar(var_clojure_DOT_core_str)
					tmp9 := lang.Apply(tmp8, []any{v3})
					tmp10 := lang.Apply(strings5.LastIndex, []any{v7, tmp9})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					tmp13 := checkDerefVar(var_clojure_DOT_core__EQ_)
					tmp14 := lang.Apply(tmp13, []any{v11, int64(-1)})
					if lang.IsTruthy(tmp14) {
					} else {
						tmp15 := lang.Apply(lang.Builtins["int64"], []any{v11})
						tmp12 = tmp15
					}
					tmp4 = tmp12
				} // end let
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "from-index"
					tmp6 := checkDerefVar(var_clojure_DOT_core_min)
					tmp7 := checkDerefVar(var_clojure_DOT_core_count)
					tmp8 := lang.Apply(tmp7, []any{v2})
					tmp9 := checkDerefVar(var_clojure_DOT_core_max)
					tmp10 := checkDerefVar(var_clojure_DOT_core_inc)
					tmp11 := checkDerefVar(var_clojure_DOT_core_unchecked_DASH_int)
					tmp12 := lang.Apply(tmp11, []any{v4})
					tmp13 := lang.Apply(tmp10, []any{tmp12})
					tmp14 := lang.Apply(tmp9, []any{int64(0), tmp13})
					tmp15 := lang.Apply(tmp6, []any{tmp8, tmp14})
					var v16 any = tmp15
					_ = v16
					// let binding "s"
					tmp17 := checkDerefVar(var_clojure_DOT_core_subs)
					tmp18 := checkDerefVar(var_clojure_DOT_string_check_DASH_string)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp17, []any{tmp19, int64(0), v16})
					var v21 any = tmp20
					_ = v21
					// let binding "result"
					tmp22 := checkDerefVar(var_clojure_DOT_core_str)
					tmp23 := lang.Apply(tmp22, []any{v3})
					tmp24 := lang.Apply(strings5.LastIndex, []any{v21, tmp23})
					var v25 any = tmp24
					_ = v25
					var tmp26 any
					tmp27 := checkDerefVar(var_clojure_DOT_core__EQ_)
					tmp28 := lang.Apply(tmp27, []any{v25, int64(-1)})
					if lang.IsTruthy(tmp28) {
					} else {
						tmp29 := lang.Apply(lang.Builtins["int64"], []any{v25})
						tmp26 = tmp29
					}
					tmp5 = tmp26
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_last_DASH_index_DASH_of = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_last_DASH_index_DASH_of.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_replace.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_match, sym_replacement)), kw_doc, "Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   char / char\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (glojure.string/replace \"Almost Pig Latin\" #\"\\b(\\w)(\\w+)\\b\" \"$2$1ay\")\n   -> \"lmostAay igPay atinLay\"", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_replace, kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(52), kw_end_DASH_line, int(52))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "s"
				tmp7 := checkDerefVar(var_clojure_DOT_string_check_DASH_string)
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				tmp11 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
				tmp12 := reflect.TypeOf(lang.NewChar(0))
				tmp13 := lang.Apply(tmp11, []any{tmp12, v4})
				if lang.IsTruthy(tmp13) {
					tmp14 := lang.Apply(strings5.ReplaceAll, []any{v9, v4, v5})
					tmp10 = tmp14
				} else {
					var tmp15 any
					tmp16 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
					tmp17 := lang.Apply(tmp16, []any{lang.Builtins["string"], v4})
					if lang.IsTruthy(tmp17) {
						tmp18 := lang.Apply(strings5.ReplaceAll, []any{v9, v4, v5})
						tmp15 = tmp18
					} else {
						var tmp19 any
						tmp20 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
						tmp21 := reflect.TypeOf((*regexp6.Regexp)(nil))
						tmp22 := lang.Apply(tmp20, []any{tmp21, v4})
						if lang.IsTruthy(tmp22) {
							var tmp23 any
							tmp24 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
							tmp25 := lang.Apply(tmp24, []any{lang.Builtins["string"], v5})
							if lang.IsTruthy(tmp25) {
								tmp26, _ := lang.FieldOrMethod(v4, "replaceAllString")
								if reflect.TypeOf(tmp26).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("replaceAllString is not a function")))
								}
								tmp27 := lang.Apply(tmp26, []any{v9, v5})
								tmp23 = tmp27
							} else {
								tmp28 := checkDerefVar(var_clojure_DOT_string_replace_DASH_by)
								tmp29 := lang.Apply(tmp28, []any{v9, v4, v5})
								tmp23 = tmp29
							}
							tmp19 = tmp23
						} else {
							var tmp30 any
							if lang.IsTruthy(kw_else) {
								tmp31 := checkDerefVar(var_clojure_DOT_core_str)
								tmp32 := lang.Apply(tmp31, []any{"Invalid match arg: ", v4})
								tmp33 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp32})
								panic(tmp33)
							} else {
							}
							tmp19 = tmp30
						}
						tmp15 = tmp19
					}
					tmp10 = tmp15
				}
				tmp6 = tmp10
			} // end let
			return tmp6
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_replace = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_replace.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace-by
	{
		tmp0 := sym_replace_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_re, sym_f)), kw_file, "clojure/string.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_replace_DASH_by, kw_end_DASH_column, int(17), kw_column, int(8), kw_line, int(39), kw_end_DASH_line, int(39), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "m"
				tmp6 := checkDerefVar(var_clojure_DOT_core_re_DASH_matcher)
				tmp7 := lang.Apply(tmp6, []any{v3, v2})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				tmp10, ok := lang.FieldOrMethod(v8, "find")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "find")))
				}
				var tmp11 any
				switch reflect.TypeOf(tmp10).Kind() {
				case reflect.Func:
					tmp11 = lang.Apply(tmp10, nil)
				default:
					tmp11 = tmp10
				}
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					{ // let
						// let binding "buffer"
						tmp13 := new(strings5.Builder)
						var v14 any = tmp13
						_ = v14
						var tmp15 any
						{ // let
							// let binding "found"
							var v16 any = true
							_ = v16
							for {
								var tmp17 any
								if lang.IsTruthy(v16) {
									tmp18 := checkDerefVar(var_clojure_DOT_string_re_DASH_quote_DASH_replacement)
									tmp19 := checkDerefVar(var_clojure_DOT_core_re_DASH_groups)
									tmp20 := lang.Apply(tmp19, []any{v8})
									tmp21 := lang.Apply(v4, []any{tmp20})
									tmp22 := lang.Apply(tmp18, []any{tmp21})
									tmp23, _ := lang.FieldOrMethod(v8, "appendReplacement")
									if reflect.TypeOf(tmp23).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("appendReplacement is not a function")))
									}
									tmp24 := lang.Apply(tmp23, []any{v14, tmp22})
									_ = tmp24
									tmp26, ok := lang.FieldOrMethod(v8, "find")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "find")))
									}
									var tmp27 any
									switch reflect.TypeOf(tmp26).Kind() {
									case reflect.Func:
										tmp27 = lang.Apply(tmp26, nil)
									default:
										tmp27 = tmp26
									}
									var tmp25 any = tmp27
									v16 = tmp25
									continue
								} else {
									tmp28, _ := lang.FieldOrMethod(v8, "appendTail")
									if reflect.TypeOf(tmp28).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("appendTail is not a function")))
									}
									tmp29 := lang.Apply(tmp28, []any{v14})
									_ = tmp29
									tmp30 := lang.Apply(lang.ToString, []any{v14})
									tmp17 = tmp30
								}
								tmp15 = tmp17
								break
							}
						} // end let
						tmp12 = tmp15
					} // end let
					tmp9 = tmp12
				} else {
					tmp9 = v2
				}
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_replace_DASH_by = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_replace_DASH_by.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace-first
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_replace_DASH_first.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_match, sym_replacement)), kw_doc, "Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   char / char\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (glojure.string/replace-first \"swap first two words\"\n                                 #\"(\\w+)(\\s+)(\\w+)\" \"$3$2$1\")\n   -> \"first swap two words\"", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_replace_DASH_first, kw_end_DASH_column, int(30), kw_column, int(7), kw_line, int(114), kw_end_DASH_line, int(114))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "s"
				tmp7 := checkDerefVar(var_clojure_DOT_string_check_DASH_string)
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				tmp11 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
				tmp12 := reflect.TypeOf(lang.NewChar(0))
				tmp13 := lang.Apply(tmp11, []any{tmp12, v4})
				if lang.IsTruthy(tmp13) {
					tmp14 := checkDerefVar(var_clojure_DOT_string_replace_DASH_first_DASH_char)
					tmp15 := lang.Apply(tmp14, []any{v9, v4, v5})
					tmp10 = tmp15
				} else {
					var tmp16 any
					tmp17 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
					tmp18 := lang.Apply(tmp17, []any{lang.Builtins["string"], v4})
					if lang.IsTruthy(tmp18) {
						tmp19 := checkDerefVar(var_clojure_DOT_string_replace_DASH_first_DASH_str)
						tmp20 := lang.Apply(lang.ToString, []any{v4})
						tmp21 := lang.Apply(lang.ToString, []any{v5})
						tmp22 := lang.Apply(tmp19, []any{v9, tmp20, tmp21})
						tmp16 = tmp22
					} else {
						var tmp23 any
						tmp24 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
						tmp25 := reflect.TypeOf((*regexp6.Regexp)(nil))
						tmp26 := lang.Apply(tmp24, []any{tmp25, v4})
						if lang.IsTruthy(tmp26) {
							var tmp27 any
							tmp28 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
							tmp29 := lang.Apply(tmp28, []any{lang.Builtins["string"], v5})
							if lang.IsTruthy(tmp29) {
								var tmp30 any
								{ // let
									// let binding "done"
									tmp31 := checkDerefVar(var_clojure_DOT_core_atom)
									tmp32 := lang.Apply(tmp31, []any{false})
									var v33 any = tmp32
									_ = v33
									var tmp34 lang.FnFunc
									tmp34 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v35 := args[0]
										_ = v35
										var tmp36 any
										tmp37 := checkDerefVar(var_clojure_DOT_core_deref)
										tmp38 := lang.Apply(tmp37, []any{v33})
										if lang.IsTruthy(tmp38) {
											tmp36 = v35
										} else {
											tmp39 := checkDerefVar(var_clojure_DOT_core_reset_BANG_)
											tmp40 := lang.Apply(tmp39, []any{v33, true})
											_ = tmp40
											tmp41, _ := lang.FieldOrMethod(v4, "ReplaceAllString")
											if reflect.TypeOf(tmp41).Kind() != reflect.Func {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReplaceAllString is not a function")))
											}
											tmp42 := lang.Apply(tmp41, []any{v35, v5})
											tmp36 = tmp42
										}
										return tmp36
									})
									tmp35 := lang.NewMap(kw_file, "clojure/string.glj", kw_line, int(152), kw_column, int(33), kw_end_DASH_line, int(157), kw_end_DASH_column, int(89))
									tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp37, _ := lang.FieldOrMethod(v4, "ReplaceAllStringFunc")
									if reflect.TypeOf(tmp37).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReplaceAllStringFunc is not a function")))
									}
									tmp38 := lang.Apply(tmp37, []any{v9, tmp36})
									tmp30 = tmp38
								} // end let
								tmp27 = tmp30
							} else {
								tmp31 := checkDerefVar(var_clojure_DOT_string_replace_DASH_first_DASH_by)
								tmp32 := lang.Apply(tmp31, []any{v9, v4, v5})
								tmp27 = tmp32
							}
							tmp23 = tmp27
						} else {
							var tmp33 any
							if lang.IsTruthy(kw_else) {
								tmp34 := checkDerefVar(var_clojure_DOT_core_str)
								tmp35 := lang.Apply(tmp34, []any{"Invalid match arg: ", v4})
								tmp36 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp35})
								panic(tmp36)
							} else {
							}
							tmp23 = tmp33
						}
						tmp16 = tmp23
					}
					tmp10 = tmp16
				}
				tmp6 = tmp10
			} // end let
			return tmp6
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_replace_DASH_first = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_replace_DASH_first.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace-first-by
	{
		tmp0 := sym_replace_DASH_first_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_re, sym_f)), kw_file, "clojure/string.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_replace_DASH_first_DASH_by, kw_end_DASH_column, int(23), kw_column, int(8), kw_line, int(87), kw_end_DASH_line, int(87), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "m"
				tmp6 := checkDerefVar(var_clojure_DOT_core_re_DASH_matcher)
				tmp7 := lang.Apply(tmp6, []any{v3, v2})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				tmp10, ok := lang.FieldOrMethod(v8, "find")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "find")))
				}
				var tmp11 any
				switch reflect.TypeOf(tmp10).Kind() {
				case reflect.Func:
					tmp11 = lang.Apply(tmp10, nil)
				default:
					tmp11 = tmp10
				}
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					{ // let
						// let binding "buffer"
						tmp13 := new(strings5.Builder)
						var v14 any = tmp13
						_ = v14
						// let binding "rep"
						tmp15 := checkDerefVar(var_clojure_DOT_string_re_DASH_quote_DASH_replacement)
						tmp16 := checkDerefVar(var_clojure_DOT_core_re_DASH_groups)
						tmp17 := lang.Apply(tmp16, []any{v8})
						tmp18 := lang.Apply(v4, []any{tmp17})
						tmp19 := lang.Apply(tmp15, []any{tmp18})
						var v20 any = tmp19
						_ = v20
						tmp21, _ := lang.FieldOrMethod(v8, "appendReplacement")
						if reflect.TypeOf(tmp21).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("appendReplacement is not a function")))
						}
						tmp22 := lang.Apply(tmp21, []any{v14, v20})
						_ = tmp22
						tmp23, _ := lang.FieldOrMethod(v8, "appendTail")
						if reflect.TypeOf(tmp23).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("appendTail is not a function")))
						}
						tmp24 := lang.Apply(tmp23, []any{v14})
						_ = tmp24
						tmp25 := checkDerefVar(var_clojure_DOT_core_str)
						tmp26 := lang.Apply(tmp25, []any{v14})
						tmp12 = tmp26
					} // end let
					tmp9 = tmp12
				} else {
					tmp9 = v2
				}
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_replace_DASH_first_DASH_by = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_replace_DASH_first_DASH_by.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace-first-char
	{
		tmp0 := sym_replace_DASH_first_DASH_char.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_match, sym_replace)), kw_file, "clojure/string.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_replace_DASH_first_DASH_char, kw_end_DASH_column, int(25), kw_column, int(8), kw_line, int(98), kw_end_DASH_line, int(98), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "s"
				tmp6 := lang.Apply(lang.ToString, []any{v2})
				var v7 any = tmp6
				_ = v7
				// let binding "i"
				tmp8 := checkDerefVar(var_clojure_DOT_core_int)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(strings5.Index, []any{v7, tmp9})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				tmp13 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp14 := lang.Apply(tmp13, []any{int64(-1), v11})
				if lang.IsTruthy(tmp14) {
					tmp12 = v7
				} else {
					tmp15 := checkDerefVar(var_clojure_DOT_core_str)
					tmp16 := checkDerefVar(var_clojure_DOT_core_subs)
					tmp17 := lang.Apply(tmp16, []any{v7, int64(0), v11})
					tmp18 := checkDerefVar(var_clojure_DOT_core_subs)
					tmp19 := checkDerefVar(var_clojure_DOT_core_inc)
					tmp20 := lang.Apply(tmp19, []any{v11})
					tmp21 := lang.Apply(tmp18, []any{v7, tmp20})
					tmp22 := lang.Apply(tmp15, []any{tmp17, v4, tmp21})
					tmp12 = tmp22
				}
				tmp5 = tmp12
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_replace_DASH_first_DASH_char = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_replace_DASH_first_DASH_char.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace-first-str
	{
		tmp0 := sym_replace_DASH_first_DASH_str.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_match, sym_replace)), kw_file, "clojure/string.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_replace_DASH_first_DASH_str, kw_end_DASH_column, int(24), kw_column, int(8), kw_line, int(106), kw_end_DASH_line, int(106), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "s"
				tmp6 := lang.Apply(lang.ToString, []any{v2})
				var v7 any = tmp6
				_ = v7
				// let binding "i"
				tmp8 := lang.Apply(strings5.Index, []any{v7, v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				tmp11 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp12 := lang.Apply(tmp11, []any{int64(-1), v9})
				if lang.IsTruthy(tmp12) {
					tmp10 = v7
				} else {
					tmp13 := checkDerefVar(var_clojure_DOT_core_str)
					tmp14 := checkDerefVar(var_clojure_DOT_core_subs)
					tmp15 := lang.Apply(tmp14, []any{v7, int64(0), v9})
					tmp16 := checkDerefVar(var_clojure_DOT_core_subs)
					tmp17 := checkDerefVar(var_clojure_DOT_core__PLUS_)
					tmp18 := checkDerefVar(var_clojure_DOT_core_count)
					tmp19 := lang.Apply(tmp18, []any{v3})
					tmp20 := lang.Apply(tmp17, []any{v9, tmp19})
					tmp21 := lang.Apply(tmp16, []any{v7, tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp15, v4, tmp21})
					tmp10 = tmp22
				}
				tmp5 = tmp10
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_replace_DASH_first_DASH_str = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_replace_DASH_first_DASH_str.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reverse
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_reverse.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Returns s with its characters reversed.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_reverse, kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(23), kw_end_DASH_line, int(23))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_core_apply)
			tmp5 := checkDerefVar(var_clojure_DOT_core_str)
			tmp6 := checkDerefVar(var_clojure_DOT_core_reverse)
			tmp7 := checkDerefVar(var_clojure_DOT_string_check_DASH_string)
			tmp8 := lang.Apply(tmp7, []any{v3})
			tmp9 := lang.Apply(tmp6, []any{tmp8})
			tmp10 := lang.Apply(tmp4, []any{tmp5, tmp9})
			return tmp10
		})
		tmp3 := reflect.TypeOf("")
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, tmp3)).(lang.FnFunc)
		var_clojure_DOT_string_reverse = ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_reverse.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// split-lines
	{
		tmp0 := sym_split_DASH_lines.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Splits s on \\n or \\r\\n. Trailing empty lines are not returned.", kw_file, "clojure/string.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_string), kw_name, sym_split_DASH_lines, kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(204), kw_end_DASH_line, int(204))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_string_split)
			tmp4 := checkDerefVar(var_clojure_DOT_core_re_DASH_pattern)
			tmp5 := lang.Apply(tmp4, []any{"\\r?\\n"})
			tmp6 := lang.Apply(tmp3, []any{v2, tmp5})
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_string_split_DASH_lines = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_string_split_DASH_lines.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}

	// Mark namespace as AOT-loaded
	if ns := lang.FindNamespace(lang.NewSymbol("clojure.string")); ns != nil {
		// Set metadata directly
		meta := ns.Meta()
		if meta == nil {
			meta = lang.NewMap()
		}
		ns.ResetMeta(meta.Assoc(lang.NewKeyword("aot-loaded"), true).(lang.IPersistentMap))
	}
}

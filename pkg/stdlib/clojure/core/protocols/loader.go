// Code generated by glojure codegen. DO NOT EDIT.

package protocols

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	reflect "reflect"
)

func init() {
	runtime.RegisterNSLoader("clojure/core/protocols", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "clojure.core.protocols"
func LoadNS() {
	// Check if already AOT-loaded
	if ns := lang.FindNamespace(lang.NewSymbol("clojure.core.protocols")); ns != nil {
		if meta := ns.Meta(); meta != nil {
			if aotLoaded := meta.ValAt(lang.NewKeyword("aot-loaded")); aotLoaded != nil {
				return // Already loaded, skip reinitialization
			}
		}
	}
	sym_CollReduce := lang.NewSymbol("CollReduce")
	sym_Datafiable := lang.NewSymbol("Datafiable")
	sym_IKVReduce := lang.NewSymbol("IKVReduce")
	sym_InternalReduce := lang.NewSymbol("InternalReduce")
	sym_Navigable := lang.NewSymbol("Navigable")
	sym_amap := lang.NewSymbol("amap")
	sym_apply := lang.NewSymbol("apply")
	sym_chunk_DASH_first := lang.NewSymbol("chunk-first")
	sym_chunk_DASH_next := lang.NewSymbol("chunk-next")
	sym_chunked_DASH_seq_QMARK_ := lang.NewSymbol("chunked-seq?")
	sym_class := lang.NewSymbol("class")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_core_DOT_protocols := lang.NewSymbol("clojure.core.protocols")
	sym_coll := lang.NewSymbol("coll")
	sym_coll_DASH_reduce := lang.NewSymbol("coll-reduce")
	sym_cons := lang.NewSymbol("cons")
	sym_datafy := lang.NewSymbol("datafy")
	sym_deref := lang.NewSymbol("deref")
	sym_f := lang.NewSymbol("f")
	sym_first := lang.NewSymbol("first")
	sym_global_DASH_hierarchy := lang.NewSymbol("global-hierarchy")
	sym_identical_QMARK_ := lang.NewSymbol("identical?")
	sym_init := lang.NewSymbol("init")
	sym_instance_QMARK_ := lang.NewSymbol("instance?")
	sym_interface_DASH_or_DASH_naive_DASH_reduce := lang.NewSymbol("interface-or-naive-reduce")
	sym_internal_DASH_reduce := lang.NewSymbol("internal-reduce")
	sym_iter_DASH_reduce := lang.NewSymbol("iter-reduce")
	sym_k := lang.NewSymbol("k")
	sym_kv_DASH_reduce := lang.NewSymbol("kv-reduce")
	sym_naive_DASH_seq_DASH_reduce := lang.NewSymbol("naive-seq-reduce")
	sym_nav := lang.NewSymbol("nav")
	sym_next := lang.NewSymbol("next")
	sym_o := lang.NewSymbol("o")
	sym_reduced_QMARK_ := lang.NewSymbol("reduced?")
	sym_s := lang.NewSymbol("s")
	sym_seq := lang.NewSymbol("seq")
	sym_seq_DASH_reduce := lang.NewSymbol("seq-reduce")
	sym_start := lang.NewSymbol("start")
	sym_v := lang.NewSymbol("v")
	sym_val := lang.NewSymbol("val")
	kw_arglists := lang.NewKeyword("arglists")
	kw_coll_DASH_reduce := lang.NewKeyword("coll-reduce")
	kw_column := lang.NewKeyword("column")
	kw_datafy := lang.NewKeyword("datafy")
	kw_default := lang.NewKeyword("default")
	kw_doc := lang.NewKeyword("doc")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_file := lang.NewKeyword("file")
	kw_internal_DASH_reduce := lang.NewKeyword("internal-reduce")
	kw_kv_DASH_reduce := lang.NewKeyword("kv-reduce")
	kw_line := lang.NewKeyword("line")
	kw_multis := lang.NewKeyword("multis")
	kw_name := lang.NewKeyword("name")
	kw_nav := lang.NewKeyword("nav")
	kw_ns := lang.NewKeyword("ns")
	kw_on_DASH_interface := lang.NewKeyword("on-interface")
	kw_private := lang.NewKeyword("private")
	kw_rettag := lang.NewKeyword("rettag")
	kw_sigs := lang.NewKeyword("sigs")
	// var clojure.core.protocols/CollReduce
	var_clojure_DOT_core_DOT_protocols_CollReduce := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_CollReduce)
	// var clojure.core.protocols/Datafiable
	var_clojure_DOT_core_DOT_protocols_Datafiable := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_Datafiable)
	// var clojure.core.protocols/IKVReduce
	var_clojure_DOT_core_DOT_protocols_IKVReduce := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_IKVReduce)
	// var clojure.core.protocols/InternalReduce
	var_clojure_DOT_core_DOT_protocols_InternalReduce := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_InternalReduce)
	// var clojure.core.protocols/Navigable
	var_clojure_DOT_core_DOT_protocols_Navigable := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_Navigable)
	// var clojure.core.protocols/coll-reduce
	var_clojure_DOT_core_DOT_protocols_coll_DASH_reduce := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_coll_DASH_reduce)
	// var clojure.core.protocols/datafy
	var_clojure_DOT_core_DOT_protocols_datafy := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_datafy)
	// var clojure.core.protocols/interface-or-naive-reduce
	var_clojure_DOT_core_DOT_protocols_interface_DASH_or_DASH_naive_DASH_reduce := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_interface_DASH_or_DASH_naive_DASH_reduce)
	// var clojure.core.protocols/internal-reduce
	var_clojure_DOT_core_DOT_protocols_internal_DASH_reduce := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_internal_DASH_reduce)
	// var clojure.core.protocols/iter-reduce
	var_clojure_DOT_core_DOT_protocols_iter_DASH_reduce := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_iter_DASH_reduce)
	// var clojure.core.protocols/kv-reduce
	var_clojure_DOT_core_DOT_protocols_kv_DASH_reduce := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_kv_DASH_reduce)
	// var clojure.core.protocols/naive-seq-reduce
	var_clojure_DOT_core_DOT_protocols_naive_DASH_seq_DASH_reduce := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_naive_DASH_seq_DASH_reduce)
	// var clojure.core.protocols/nav
	var_clojure_DOT_core_DOT_protocols_nav := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_nav)
	// var clojure.core.protocols/seq-reduce
	var_clojure_DOT_core_DOT_protocols_seq_DASH_reduce := lang.InternVarName(sym_clojure_DOT_core_DOT_protocols, sym_seq_DASH_reduce)
	// var clojure.core/apply
	var_clojure_DOT_core_apply := lang.InternVarName(sym_clojure_DOT_core, sym_apply)
	// var clojure.core/chunk-first
	var_clojure_DOT_core_chunk_DASH_first := lang.InternVarName(sym_clojure_DOT_core, sym_chunk_DASH_first)
	// var clojure.core/chunk-next
	var_clojure_DOT_core_chunk_DASH_next := lang.InternVarName(sym_clojure_DOT_core, sym_chunk_DASH_next)
	// var clojure.core/chunked-seq?
	var_clojure_DOT_core_chunked_DASH_seq_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_chunked_DASH_seq_QMARK_)
	// var clojure.core/class
	var_clojure_DOT_core_class := lang.InternVarName(sym_clojure_DOT_core, sym_class)
	// var clojure.core/cons
	var_clojure_DOT_core_cons := lang.InternVarName(sym_clojure_DOT_core, sym_cons)
	// var clojure.core/deref
	var_clojure_DOT_core_deref := lang.InternVarName(sym_clojure_DOT_core, sym_deref)
	// var clojure.core/first
	var_clojure_DOT_core_first := lang.InternVarName(sym_clojure_DOT_core, sym_first)
	// var clojure.core/identical?
	var_clojure_DOT_core_identical_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_identical_QMARK_)
	// var clojure.core/instance?
	var_clojure_DOT_core_instance_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_instance_QMARK_)
	// var clojure.core/next
	var_clojure_DOT_core_next := lang.InternVarName(sym_clojure_DOT_core, sym_next)
	// var clojure.core/reduced?
	var_clojure_DOT_core_reduced_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_reduced_QMARK_)
	// var clojure.core/seq
	var_clojure_DOT_core_seq := lang.InternVarName(sym_clojure_DOT_core, sym_seq)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols)
	_ = ns
	var closed0 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := lang.Apply(v2, nil)
				return tmp3
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				return v3
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed0 = tmp0
	}
	var closed1 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3, _ := lang.FieldOrMethod(v1, "Reduce")
				if reflect.TypeOf(tmp3).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Reduce is not a function")))
				}
				tmp4 := lang.Apply(tmp3, []any{v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(v1, "ReduceInit")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed1 = tmp0
	}
	var closed4 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			return nil
		})
		closed4 = tmp0
	}
	var closed5 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
			return v3
		})
		closed5 = tmp0
	}
	var closed2 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp4 := lang.Apply(tmp3, []any{v1, v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp5 := lang.Apply(tmp4, []any{v1, v2, v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed2 = tmp0
	}
	var closed3 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp4 := lang.Apply(tmp3, []any{v1, v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp5 := lang.Apply(tmp4, []any{v1, v2, v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed3 = tmp0
	}
	var closed6 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
		recur_loop_2815:
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := lang.Apply(tmp5, []any{v1})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "s"
						var v10 any = v7
						_ = v10
						var tmp11 any
						tmp12 := checkDerefVar(var_clojure_DOT_core_chunked_DASH_seq_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v10})
						if lang.IsTruthy(tmp13) {
							var tmp14 any
							{ // let
								// let binding "ret"
								tmp15 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_first)
								tmp16 := lang.Apply(tmp15, []any{v10})
								tmp17, _ := lang.FieldOrMethod(tmp16, "ReduceInit")
								if reflect.TypeOf(tmp17).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
								}
								tmp18 := lang.Apply(tmp17, []any{v2, v3})
								var v19 any = tmp18
								_ = v19
								var tmp20 any
								tmp21 := checkDerefVar(var_clojure_DOT_core_reduced_QMARK_)
								tmp22 := lang.Apply(tmp21, []any{v19})
								if lang.IsTruthy(tmp22) {
									tmp23 := checkDerefVar(var_clojure_DOT_core_deref)
									tmp24 := lang.Apply(tmp23, []any{v19})
									tmp20 = tmp24
								} else {
									tmp26 := checkDerefVar(var_clojure_DOT_core_chunk_DASH_next)
									tmp27 := lang.Apply(tmp26, []any{v10})
									var tmp25 any = tmp27
									var tmp28 any = v2
									var tmp29 any = v19
									v1 = tmp25
									v2 = tmp28
									v3 = tmp29
									goto recur_loop_2815
								}
								tmp14 = tmp20
							} // end let
							tmp11 = tmp14
						} else {
							tmp15 := checkDerefVar(var_clojure_DOT_core_DOT_protocols_interface_DASH_or_DASH_naive_DASH_reduce)
							tmp16 := lang.Apply(tmp15, []any{v10, v2, v3})
							tmp11 = tmp16
						}
						tmp9 = tmp11
					} // end let
					tmp8 = tmp9
				} else {
					tmp8 = v3
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		closed6 = tmp0
	}
	var closed7 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "cls"
				tmp5 := checkDerefVar(var_clojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v1})
				var v7 any = tmp6
				_ = v7
				// let binding "s"
				var v8 any = v1
				_ = v8
				// let binding "f"
				var v9 any = v2
				_ = v9
				// let binding "val"
				var v10 any = v3
				_ = v10
				for {
					var tmp11 any
					{ // let
						// let binding "temp__0__auto__"
						tmp12 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp13 := lang.Apply(tmp12, []any{v8})
						var v14 any = tmp13
						_ = v14
						var tmp15 any
						if lang.IsTruthy(v14) {
							var tmp16 any
							{ // let
								// let binding "s"
								var v17 any = v14
								_ = v17
								var tmp18 any
								tmp19 := checkDerefVar(var_clojure_DOT_core_identical_QMARK_)
								tmp20 := checkDerefVar(var_clojure_DOT_core_class)
								tmp21 := lang.Apply(tmp20, []any{v17})
								tmp22 := lang.Apply(tmp19, []any{tmp21, v7})
								if lang.IsTruthy(tmp22) {
									var tmp23 any
									{ // let
										// let binding "ret"
										tmp24 := checkDerefVar(var_clojure_DOT_core_first)
										tmp25 := lang.Apply(tmp24, []any{v17})
										tmp26 := lang.Apply(v9, []any{v10, tmp25})
										var v27 any = tmp26
										_ = v27
										var tmp28 any
										tmp29 := checkDerefVar(var_clojure_DOT_core_reduced_QMARK_)
										tmp30 := lang.Apply(tmp29, []any{v27})
										if lang.IsTruthy(tmp30) {
											tmp31 := checkDerefVar(var_clojure_DOT_core_deref)
											tmp32 := lang.Apply(tmp31, []any{v27})
											tmp28 = tmp32
										} else {
											var tmp33 any = v7
											tmp35 := checkDerefVar(var_clojure_DOT_core_next)
											tmp36 := lang.Apply(tmp35, []any{v17})
											var tmp34 any = tmp36
											var tmp37 any = v9
											var tmp38 any = v27
											v7 = tmp33
											v8 = tmp34
											v9 = tmp37
											v10 = tmp38
											continue
										}
										tmp23 = tmp28
									} // end let
									tmp18 = tmp23
								} else {
									tmp24 := checkDerefVar(var_clojure_DOT_core_DOT_protocols_interface_DASH_or_DASH_naive_DASH_reduce)
									tmp25 := lang.Apply(tmp24, []any{v17, v9, v10})
									tmp18 = tmp25
								}
								tmp16 = tmp18
							} // end let
							tmp15 = tmp16
						} else {
							tmp15 = v10
						}
						tmp11 = tmp15
					} // end let
					tmp4 = tmp11
					break
				}
			} // end let
			return tmp4
		})
		closed7 = tmp0
	}
	// CollReduce
	{
		tmp0 := sym_CollReduce.WithMeta(lang.NewMap(kw_file, "clojure/core/protocols.glj", kw_line, int(13), kw_column, int(14), kw_end_DASH_line, int(13), kw_end_DASH_column, int(23), kw_name, sym_CollReduce, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v4 := args[0]
				_ = v4
				restArgs := args[1:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_class)
				tmp7 := lang.Apply(tmp6, []any{v4})
				return tmp7
			}
		})
		// MultiFn coll-reduce
		tmp2 := lang.NewMultiFn("coll-reduce", tmp3, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v5 := args[0]
				_ = v5
				restArgs := args[1:]
				var v6 any
				if len(restArgs) > 0 {
					v6 = lang.NewList(restArgs...)
				}
				_ = v6
				tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v5, v6})
				tmp10 := lang.Apply(tmp7, []any{closed0, tmp9})
				return tmp10
			}
		})
		tmp2.AddMethod(nil, tmp4)
		tmp5 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v7 := args[0]
				_ = v7
				restArgs := args[1:]
				var v8 any
				if len(restArgs) > 0 {
					v8 = lang.NewList(restArgs...)
				}
				_ = v8
				tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp10 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp11 := lang.Apply(tmp10, []any{v7, v8})
				tmp12 := lang.Apply(tmp9, []any{closed1, tmp11})
				return tmp12
			}
		})
		tmp2.AddMethod(tmp5, tmp6)
		tmp7 := reflect.TypeOf((*lang.LazySeq)(nil))
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v9 := args[0]
				_ = v9
				restArgs := args[1:]
				var v10 any
				if len(restArgs) > 0 {
					v10 = lang.NewList(restArgs...)
				}
				_ = v10
				tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp13 := lang.Apply(tmp12, []any{v9, v10})
				tmp14 := lang.Apply(tmp11, []any{closed2, tmp13})
				return tmp14
			}
		})
		tmp2.AddMethod(tmp7, tmp8)
		tmp9 := reflect.TypeOf((*lang.Vector)(nil))
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v11 := args[0]
				_ = v11
				restArgs := args[1:]
				var v12 any
				if len(restArgs) > 0 {
					v12 = lang.NewList(restArgs...)
				}
				_ = v12
				tmp13 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp14 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp15 := lang.Apply(tmp14, []any{v11, v12})
				tmp16 := lang.Apply(tmp13, []any{closed3, tmp15})
				return tmp16
			}
		})
		tmp2.AddMethod(tmp9, tmp10)
		tmp1 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_coll_DASH_reduce, tmp2), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_coll_DASH_reduce, lang.NewVector(sym_coll, sym_f), lang.NewVector(sym_coll, sym_f, sym_val)))))
		var_clojure_DOT_core_DOT_protocols_CollReduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_CollReduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// Datafiable
	{
		tmp0 := sym_Datafiable.WithMeta(lang.NewMap(kw_file, "clojure/core/protocols.glj", kw_line, int(183), kw_column, int(14), kw_end_DASH_line, int(183), kw_end_DASH_column, int(23), kw_name, sym_Datafiable, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v4 := args[0]
				_ = v4
				restArgs := args[1:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_class)
				tmp7 := lang.Apply(tmp6, []any{v4})
				return tmp7
			}
		})
		// MultiFn datafy
		tmp2 := lang.NewMultiFn("datafy", tmp3, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v5 := args[0]
				_ = v5
				restArgs := args[1:]
				var v6 any
				if len(restArgs) > 0 {
					v6 = lang.NewList(restArgs...)
				}
				_ = v6
				tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v5, v6})
				tmp10 := lang.Apply(tmp7, []any{closed4, tmp9})
				return tmp10
			}
		})
		tmp2.AddMethod(nil, tmp4)
		tmp1 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_datafy, tmp2), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_datafy, lang.NewVector(sym_o), "return a representation of o as data (default identity)"))))
		var_clojure_DOT_core_DOT_protocols_Datafiable = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_Datafiable.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// IKVReduce
	{
		tmp0 := sym_IKVReduce.WithMeta(lang.NewMap(kw_file, "clojure/core/protocols.glj", kw_line, int(176), kw_column, int(14), kw_end_DASH_line, int(176), kw_end_DASH_column, int(22), kw_name, sym_IKVReduce, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v4 := args[0]
				_ = v4
				restArgs := args[1:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_class)
				tmp7 := lang.Apply(tmp6, []any{v4})
				return tmp7
			}
		})
		// MultiFn kv-reduce
		tmp2 := lang.NewMultiFn("kv-reduce", tmp3, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp1 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_kv_DASH_reduce, tmp2), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_kv_DASH_reduce, lang.NewVector(sym_amap, sym_f, sym_init)))))
		var_clojure_DOT_core_DOT_protocols_IKVReduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_IKVReduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// InternalReduce
	{
		tmp0 := sym_InternalReduce.WithMeta(lang.NewMap(kw_file, "clojure/core/protocols.glj", kw_line, int(19), kw_column, int(14), kw_end_DASH_line, int(19), kw_end_DASH_column, int(27), kw_name, sym_InternalReduce, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v4 := args[0]
				_ = v4
				restArgs := args[1:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_class)
				tmp7 := lang.Apply(tmp6, []any{v4})
				return tmp7
			}
		})
		// MultiFn internal-reduce
		tmp2 := lang.NewMultiFn("internal-reduce", tmp3, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v5 := args[0]
				_ = v5
				restArgs := args[1:]
				var v6 any
				if len(restArgs) > 0 {
					v6 = lang.NewList(restArgs...)
				}
				_ = v6
				tmp7 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v5, v6})
				tmp10 := lang.Apply(tmp7, []any{closed5, tmp9})
				return tmp10
			}
		})
		tmp2.AddMethod(nil, tmp4)
		tmp5 := reflect.TypeOf((*lang.IChunkedSeq)(nil)).Elem()
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v7 := args[0]
				_ = v7
				restArgs := args[1:]
				var v8 any
				if len(restArgs) > 0 {
					v8 = lang.NewList(restArgs...)
				}
				_ = v8
				tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp10 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp11 := lang.Apply(tmp10, []any{v7, v8})
				tmp12 := lang.Apply(tmp9, []any{closed6, tmp11})
				return tmp12
			}
		})
		tmp2.AddMethod(tmp5, tmp6)
		tmp7 := reflect.TypeOf((*lang.Object)(nil)).Elem()
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v9 := args[0]
				_ = v9
				restArgs := args[1:]
				var v10 any
				if len(restArgs) > 0 {
					v10 = lang.NewList(restArgs...)
				}
				_ = v10
				tmp11 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp13 := lang.Apply(tmp12, []any{v9, v10})
				tmp14 := lang.Apply(tmp11, []any{closed7, tmp13})
				return tmp14
			}
		})
		tmp2.AddMethod(tmp7, tmp8)
		tmp1 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_internal_DASH_reduce, tmp2), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_internal_DASH_reduce, lang.NewVector(sym_seq, sym_f, sym_start)))))
		var_clojure_DOT_core_DOT_protocols_InternalReduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_InternalReduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// Navigable
	{
		tmp0 := sym_Navigable.WithMeta(lang.NewMap(kw_file, "clojure/core/protocols.glj", kw_line, int(195), kw_column, int(14), kw_end_DASH_line, int(195), kw_end_DASH_column, int(22), kw_name, sym_Navigable, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v4 := args[0]
				_ = v4
				restArgs := args[1:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_class)
				tmp7 := lang.Apply(tmp6, []any{v4})
				return tmp7
			}
		})
		// MultiFn nav
		tmp2 := lang.NewMultiFn("nav", tmp3, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp1 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_nav, tmp2), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_nav, lang.NewVector(sym_coll, sym_k, sym_v), "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v."))))
		var_clojure_DOT_core_DOT_protocols_Navigable = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_Navigable.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// coll-reduce
	{
		tmp0 := sym_coll_DASH_reduce.WithMeta(lang.NewMap(kw_file, "clojure/core/protocols.glj", kw_line, int(17), kw_column, int(4), kw_end_DASH_line, int(17), kw_end_DASH_column, int(14), kw_name, sym_coll_DASH_reduce, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v3})
				return tmp6
			}
		})
		// MultiFn coll-reduce
		tmp1 := lang.NewMultiFn("coll-reduce", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v4 := args[0]
				_ = v4
				restArgs := args[1:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp8 := lang.Apply(tmp7, []any{v4, v5})
				tmp9 := lang.Apply(tmp6, []any{closed0, tmp8})
				return tmp9
			}
		})
		tmp1.AddMethod(nil, tmp3)
		tmp4 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v6 := args[0]
				_ = v6
				restArgs := args[1:]
				var v7 any
				if len(restArgs) > 0 {
					v7 = lang.NewList(restArgs...)
				}
				_ = v7
				tmp8 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp9 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v6, v7})
				tmp11 := lang.Apply(tmp8, []any{closed1, tmp10})
				return tmp11
			}
		})
		tmp1.AddMethod(tmp4, tmp5)
		tmp6 := reflect.TypeOf((*lang.LazySeq)(nil))
		var tmp7 lang.FnFunc
		tmp7 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v8 := args[0]
				_ = v8
				restArgs := args[1:]
				var v9 any
				if len(restArgs) > 0 {
					v9 = lang.NewList(restArgs...)
				}
				_ = v9
				tmp10 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp11 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp12 := lang.Apply(tmp11, []any{v8, v9})
				tmp13 := lang.Apply(tmp10, []any{closed2, tmp12})
				return tmp13
			}
		})
		tmp1.AddMethod(tmp6, tmp7)
		tmp8 := reflect.TypeOf((*lang.Vector)(nil))
		var tmp9 lang.FnFunc
		tmp9 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v10 := args[0]
				_ = v10
				restArgs := args[1:]
				var v11 any
				if len(restArgs) > 0 {
					v11 = lang.NewList(restArgs...)
				}
				_ = v11
				tmp12 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp13 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp14 := lang.Apply(tmp13, []any{v10, v11})
				tmp15 := lang.Apply(tmp12, []any{closed3, tmp14})
				return tmp15
			}
		})
		tmp1.AddMethod(tmp8, tmp9)
		var_clojure_DOT_core_DOT_protocols_coll_DASH_reduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_coll_DASH_reduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// datafy
	{
		tmp0 := sym_datafy.WithMeta(lang.NewMap(kw_file, "clojure/core/protocols.glj", kw_line, int(186), kw_column, int(4), kw_end_DASH_line, int(186), kw_end_DASH_column, int(9), kw_name, sym_datafy, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v3})
				return tmp6
			}
		})
		// MultiFn datafy
		tmp1 := lang.NewMultiFn("datafy", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v4 := args[0]
				_ = v4
				restArgs := args[1:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp8 := lang.Apply(tmp7, []any{v4, v5})
				tmp9 := lang.Apply(tmp6, []any{closed4, tmp8})
				return tmp9
			}
		})
		tmp1.AddMethod(nil, tmp3)
		var_clojure_DOT_core_DOT_protocols_datafy = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_datafy.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// interface-or-naive-reduce
	{
		tmp0 := sym_interface_DASH_or_DASH_naive_DASH_reduce.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_f, sym_val)), kw_doc, "Reduces via IReduceInit if possible, else naively.", kw_file, "clojure/core/protocols.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols), kw_name, sym_interface_DASH_or_DASH_naive_DASH_reduce, kw_end_DASH_column, int(32), kw_column, int(8), kw_line, int(68), kw_end_DASH_line, int(68), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v2})
			if lang.IsTruthy(tmp8) {
				tmp9, _ := lang.FieldOrMethod(v2, "ReduceInit")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp5 = tmp10
			} else {
				tmp11 := checkDerefVar(var_clojure_DOT_core_DOT_protocols_naive_DASH_seq_DASH_reduce)
				tmp12 := lang.Apply(tmp11, []any{v2, v3, v4})
				tmp5 = tmp12
			}
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_protocols_interface_DASH_or_DASH_naive_DASH_reduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_interface_DASH_or_DASH_naive_DASH_reduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// internal-reduce
	{
		tmp0 := sym_internal_DASH_reduce.WithMeta(lang.NewMap(kw_file, "clojure/core/protocols.glj", kw_line, int(22), kw_column, int(4), kw_end_DASH_line, int(22), kw_end_DASH_column, int(18), kw_name, sym_internal_DASH_reduce, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v3})
				return tmp6
			}
		})
		// MultiFn internal-reduce
		tmp1 := lang.NewMultiFn("internal-reduce", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v4 := args[0]
				_ = v4
				restArgs := args[1:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp8 := lang.Apply(tmp7, []any{v4, v5})
				tmp9 := lang.Apply(tmp6, []any{closed5, tmp8})
				return tmp9
			}
		})
		tmp1.AddMethod(nil, tmp3)
		tmp4 := reflect.TypeOf((*lang.IChunkedSeq)(nil)).Elem()
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v6 := args[0]
				_ = v6
				restArgs := args[1:]
				var v7 any
				if len(restArgs) > 0 {
					v7 = lang.NewList(restArgs...)
				}
				_ = v7
				tmp8 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp9 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v6, v7})
				tmp11 := lang.Apply(tmp8, []any{closed6, tmp10})
				return tmp11
			}
		})
		tmp1.AddMethod(tmp4, tmp5)
		tmp6 := reflect.TypeOf((*lang.Object)(nil)).Elem()
		var tmp7 lang.FnFunc
		tmp7 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v8 := args[0]
				_ = v8
				restArgs := args[1:]
				var v9 any
				if len(restArgs) > 0 {
					v9 = lang.NewList(restArgs...)
				}
				_ = v9
				tmp10 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp11 := checkDerefVar(var_clojure_DOT_core_cons)
				tmp12 := lang.Apply(tmp11, []any{v8, v9})
				tmp13 := lang.Apply(tmp10, []any{closed7, tmp12})
				return tmp13
			}
		})
		tmp1.AddMethod(tmp6, tmp7)
		var_clojure_DOT_core_DOT_protocols_internal_DASH_reduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_internal_DASH_reduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iter-reduce
	{
		tmp0 := sym_iter_DASH_reduce.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_f), lang.NewVector(sym_coll, sym_f, sym_val)), kw_file, "clojure/core/protocols.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols), kw_name, sym_iter_DASH_reduce, kw_end_DASH_column, int(18), kw_column, int(8), kw_line, int(33), kw_end_DASH_line, int(33), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "iter"
					tmp5, ok := lang.FieldOrMethod(v2, "iterator")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "iterator")))
					}
					var tmp6 any
					switch reflect.TypeOf(tmp5).Kind() {
					case reflect.Func:
						tmp6 = lang.Apply(tmp5, nil)
					default:
						tmp6 = tmp5
					}
					var v7 any = tmp6
					_ = v7
					var tmp8 any
					tmp9, ok := lang.FieldOrMethod(v7, "hasNext")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "hasNext")))
					}
					var tmp10 any
					switch reflect.TypeOf(tmp9).Kind() {
					case reflect.Func:
						tmp10 = lang.Apply(tmp9, nil)
					default:
						tmp10 = tmp9
					}
					if lang.IsTruthy(tmp10) {
						var tmp11 any
						{ // let
							// let binding "ret"
							tmp12, ok := lang.FieldOrMethod(v7, "next")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "next")))
							}
							var tmp13 any
							switch reflect.TypeOf(tmp12).Kind() {
							case reflect.Func:
								tmp13 = lang.Apply(tmp12, nil)
							default:
								tmp13 = tmp12
							}
							var v14 any = tmp13
							_ = v14
							for {
								var tmp15 any
								tmp16, ok := lang.FieldOrMethod(v7, "hasNext")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "hasNext")))
								}
								var tmp17 any
								switch reflect.TypeOf(tmp16).Kind() {
								case reflect.Func:
									tmp17 = lang.Apply(tmp16, nil)
								default:
									tmp17 = tmp16
								}
								if lang.IsTruthy(tmp17) {
									var tmp18 any
									{ // let
										// let binding "ret"
										tmp19, ok := lang.FieldOrMethod(v7, "next")
										if !ok {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "next")))
										}
										var tmp20 any
										switch reflect.TypeOf(tmp19).Kind() {
										case reflect.Func:
											tmp20 = lang.Apply(tmp19, nil)
										default:
											tmp20 = tmp19
										}
										tmp21 := lang.Apply(v3, []any{v14, tmp20})
										var v22 any = tmp21
										_ = v22
										var tmp23 any
										tmp24 := checkDerefVar(var_clojure_DOT_core_reduced_QMARK_)
										tmp25 := lang.Apply(tmp24, []any{v22})
										if lang.IsTruthy(tmp25) {
											tmp26 := checkDerefVar(var_clojure_DOT_core_deref)
											tmp27 := lang.Apply(tmp26, []any{v22})
											tmp23 = tmp27
										} else {
											var tmp28 any = v22
											v14 = tmp28
											continue
										}
										tmp18 = tmp23
									} // end let
									tmp15 = tmp18
								} else {
									tmp15 = v14
								}
								tmp11 = tmp15
								break
							}
						} // end let
						tmp8 = tmp11
					} else {
						tmp12 := lang.Apply(v3, nil)
						tmp8 = tmp12
					}
					tmp4 = tmp8
				} // end let
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "iter"
					tmp6, ok := lang.FieldOrMethod(v2, "iterator")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v2, "iterator")))
					}
					var tmp7 any
					switch reflect.TypeOf(tmp6).Kind() {
					case reflect.Func:
						tmp7 = lang.Apply(tmp6, nil)
					default:
						tmp7 = tmp6
					}
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					{ // let
						// let binding "ret"
						var v10 any = v4
						_ = v10
						for {
							var tmp11 any
							tmp12, ok := lang.FieldOrMethod(v8, "hasNext")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "hasNext")))
							}
							var tmp13 any
							switch reflect.TypeOf(tmp12).Kind() {
							case reflect.Func:
								tmp13 = lang.Apply(tmp12, nil)
							default:
								tmp13 = tmp12
							}
							if lang.IsTruthy(tmp13) {
								var tmp14 any
								{ // let
									// let binding "ret"
									tmp15, ok := lang.FieldOrMethod(v8, "next")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "next")))
									}
									var tmp16 any
									switch reflect.TypeOf(tmp15).Kind() {
									case reflect.Func:
										tmp16 = lang.Apply(tmp15, nil)
									default:
										tmp16 = tmp15
									}
									tmp17 := lang.Apply(v3, []any{v10, tmp16})
									var v18 any = tmp17
									_ = v18
									var tmp19 any
									tmp20 := checkDerefVar(var_clojure_DOT_core_reduced_QMARK_)
									tmp21 := lang.Apply(tmp20, []any{v18})
									if lang.IsTruthy(tmp21) {
										tmp22 := checkDerefVar(var_clojure_DOT_core_deref)
										tmp23 := lang.Apply(tmp22, []any{v18})
										tmp19 = tmp23
									} else {
										var tmp24 any = v18
										v10 = tmp24
										continue
									}
									tmp14 = tmp19
								} // end let
								tmp11 = tmp14
							} else {
								tmp11 = v10
							}
							tmp9 = tmp11
							break
						}
					} // end let
					tmp5 = tmp9
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_protocols_iter_DASH_reduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_iter_DASH_reduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// kv-reduce
	{
		tmp0 := sym_kv_DASH_reduce.WithMeta(lang.NewMap(kw_file, "clojure/core/protocols.glj", kw_line, int(181), kw_column, int(4), kw_end_DASH_line, int(181), kw_end_DASH_column, int(12), kw_name, sym_kv_DASH_reduce, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v3})
				return tmp6
			}
		})
		// MultiFn kv-reduce
		tmp1 := lang.NewMultiFn("kv-reduce", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var_clojure_DOT_core_DOT_protocols_kv_DASH_reduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_kv_DASH_reduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// naive-seq-reduce
	{
		tmp0 := sym_naive_DASH_seq_DASH_reduce.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_f, sym_val)), kw_doc, "Reduces a seq, ignoring any opportunities to switch to a more\n  specialized implementation.", kw_file, "clojure/core/protocols.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols), kw_name, sym_naive_DASH_seq_DASH_reduce, kw_end_DASH_column, int(23), kw_column, int(8), kw_line, int(55), kw_end_DASH_line, int(55), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "s"
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := lang.Apply(tmp6, []any{v2})
				var v8 any = tmp7
				_ = v8
				// let binding "val"
				var v9 any = v4
				_ = v9
				for {
					var tmp10 any
					if lang.IsTruthy(v8) {
						var tmp11 any
						{ // let
							// let binding "ret"
							tmp12 := checkDerefVar(var_clojure_DOT_core_first)
							tmp13 := lang.Apply(tmp12, []any{v8})
							tmp14 := lang.Apply(v3, []any{v9, tmp13})
							var v15 any = tmp14
							_ = v15
							var tmp16 any
							tmp17 := checkDerefVar(var_clojure_DOT_core_reduced_QMARK_)
							tmp18 := lang.Apply(tmp17, []any{v15})
							if lang.IsTruthy(tmp18) {
								tmp19 := checkDerefVar(var_clojure_DOT_core_deref)
								tmp20 := lang.Apply(tmp19, []any{v15})
								tmp16 = tmp20
							} else {
								tmp22 := checkDerefVar(var_clojure_DOT_core_next)
								tmp23 := lang.Apply(tmp22, []any{v8})
								var tmp21 any = tmp23
								var tmp24 any = v15
								v8 = tmp21
								v9 = tmp24
								continue
							}
							tmp11 = tmp16
						} // end let
						tmp10 = tmp11
					} else {
						tmp10 = v9
					}
					tmp5 = tmp10
					break
				}
			} // end let
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_protocols_naive_DASH_seq_DASH_reduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_naive_DASH_seq_DASH_reduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nav
	{
		tmp0 := sym_nav.WithMeta(lang.NewMap(kw_file, "clojure/core/protocols.glj", kw_line, int(198), kw_column, int(4), kw_end_DASH_line, int(198), kw_end_DASH_column, int(6), kw_name, sym_nav, kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v3 := args[0]
				_ = v3
				restArgs := args[1:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v3})
				return tmp6
			}
		})
		// MultiFn nav
		tmp1 := lang.NewMultiFn("nav", tmp2, kw_default, lang.FindOrCreateNamespace(sym_clojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var_clojure_DOT_core_DOT_protocols_nav = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_nav.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq-reduce
	{
		tmp0 := sym_seq_DASH_reduce.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_f), lang.NewVector(sym_coll, sym_f, sym_val)), kw_file, "clojure/core/protocols.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_protocols), kw_name, sym_seq_DASH_reduce, kw_end_DASH_column, int(17), kw_column, int(8), kw_line, int(24), kw_end_DASH_line, int(24), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "temp__0__auto__"
					tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp6 := lang.Apply(tmp5, []any{v2})
					var v7 any = tmp6
					_ = v7
					var tmp8 any
					if lang.IsTruthy(v7) {
						var tmp9 any
						{ // let
							// let binding "s"
							var v10 any = v7
							_ = v10
							tmp11 := checkDerefVar(var_clojure_DOT_core_DOT_protocols_internal_DASH_reduce)
							tmp12 := checkDerefVar(var_clojure_DOT_core_next)
							tmp13 := lang.Apply(tmp12, []any{v10})
							tmp14 := checkDerefVar(var_clojure_DOT_core_first)
							tmp15 := lang.Apply(tmp14, []any{v10})
							tmp16 := lang.Apply(tmp11, []any{tmp13, v3, tmp15})
							tmp9 = tmp16
						} // end let
						tmp8 = tmp9
					} else {
						tmp10 := lang.Apply(v3, nil)
						tmp8 = tmp10
					}
					tmp4 = tmp8
				} // end let
				return tmp4
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s"
					tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
					tmp7 := lang.Apply(tmp6, []any{v2})
					var v8 any = tmp7
					_ = v8
					tmp9 := checkDerefVar(var_clojure_DOT_core_DOT_protocols_internal_DASH_reduce)
					tmp10 := lang.Apply(tmp9, []any{v8, v3, v4})
					tmp5 = tmp10
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_protocols_seq_DASH_reduce = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_protocols_seq_DASH_reduce.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}

	// Mark namespace as AOT-loaded
	if ns := lang.FindNamespace(lang.NewSymbol("clojure.core.protocols")); ns != nil {
		// Set metadata directly
		meta := ns.Meta()
		if meta == nil {
			meta = lang.NewMap()
		}
		ns.ResetMeta(meta.Assoc(lang.NewKeyword("aot-loaded"), true).(lang.IPersistentMap))
	}
}

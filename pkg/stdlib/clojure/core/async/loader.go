// Code generated by glojure codegen. DO NOT EDIT.

package async

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	reflect "reflect"
	time4 "time"
)

func init() {
	runtime.RegisterNSLoader("clojure/core/async", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "clojure.core.async"
func LoadNS() {
	sym__AMP_ := lang.NewSymbol("&")
	sym__STAR_ := lang.NewSymbol("*")
	sym__LT__BANG_ := lang.NewSymbol("<!")
	sym__LT__BANG__BANG_ := lang.NewSymbol("<!!")
	sym__EQ_ := lang.NewSymbol("=")
	sym__GT__BANG_ := lang.NewSymbol(">!")
	sym__GT__BANG__BANG_ := lang.NewSymbol(">!!")
	sym_alt_BANG_ := lang.NewSymbol("alt!")
	sym_alt_BANG__BANG_ := lang.NewSymbol("alt!!")
	sym_alts := lang.NewSymbol("alts")
	sym_alts_BANG_ := lang.NewSymbol("alts!")
	sym_alts_BANG__BANG_ := lang.NewSymbol("alts!!")
	sym_apply := lang.NewSymbol("apply")
	sym_args := lang.NewSymbol("args")
	sym_bindings := lang.NewSymbol("bindings")
	sym_body := lang.NewSymbol("body")
	sym_buf_DASH_or_DASH_n := lang.NewSymbol("buf-or-n")
	sym_c__0__auto__ := lang.NewSymbol("c__0__auto__")
	sym_chan := lang.NewSymbol("chan")
	sym_check_DASH_unique_DASH_ports_BANG_ := lang.NewSymbol("check-unique-ports!")
	sym_clauses := lang.NewSymbol("clauses")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_core_DOT_async := lang.NewSymbol("clojure.core.async")
	sym_clojure_DOT_core_DOT_async_SLASH__GT__BANG_ := lang.NewSymbol("clojure.core.async/>!")
	sym_clojure_DOT_core_DOT_async_SLASH_alt_BANG_ := lang.NewSymbol("clojure.core.async/alt!")
	sym_clojure_DOT_core_DOT_async_SLASH_alts_BANG_ := lang.NewSymbol("clojure.core.async/alts!")
	sym_clojure_DOT_core_DOT_async_SLASH_chan := lang.NewSymbol("clojure.core.async/chan")
	sym_clojure_DOT_core_DOT_async_SLASH_go := lang.NewSymbol("clojure.core.async/go")
	sym_clojure_DOT_core_SLASH__EQ_ := lang.NewSymbol("clojure.core/=")
	sym_clojure_DOT_core_SLASH_cond := lang.NewSymbol("clojure.core/cond")
	sym_clojure_DOT_core_SLASH_fn := lang.NewSymbol("clojure.core/fn")
	sym_clojure_DOT_core_SLASH_let := lang.NewSymbol("clojure.core/let")
	sym_clojure_DOT_core_SLASH_loop := lang.NewSymbol("clojure.core/loop")
	sym_clojure_DOT_core_SLASH_or := lang.NewSymbol("clojure.core/or")
	sym_close_BANG_ := lang.NewSymbol("close!")
	sym_close_QMARK_ := lang.NewSymbol("close?")
	sym_concat := lang.NewSymbol("concat")
	sym_conj := lang.NewSymbol("conj")
	sym_contains_QMARK_ := lang.NewSymbol("contains?")
	sym_count := lang.NewSymbol("count")
	sym_default_DASH_case := lang.NewSymbol("default-case")
	sym_do := lang.NewSymbol("do")
	sym_do_DASH_alt := lang.NewSymbol("do-alt")
	sym_do_DASH_alts := lang.NewSymbol("do-alts")
	sym_ex_DASH_handler := lang.NewSymbol("ex-handler")
	sym_f__1__auto__ := lang.NewSymbol("f__1__auto__")
	sym_filter := lang.NewSymbol("filter")
	sym_first := lang.NewSymbol("first")
	sym_from := lang.NewSymbol("from")
	sym_gensym := lang.NewSymbol("gensym")
	sym_get := lang.NewSymbol("get")
	sym_go := lang.NewSymbol("go")
	sym_go_DASH_loop := lang.NewSymbol("go-loop")
	sym_go_SLASH__LT__DASH_chan_DASH_of := lang.NewSymbol("go/<-chan-of")
	sym_go_SLASH_any := lang.NewSymbol("go/any")
	sym_go_SLASH_go := lang.NewSymbol("go/go")
	sym_identity := lang.NewSymbol("identity")
	sym_keyword_QMARK_ := lang.NewSymbol("keyword?")
	sym_list := lang.NewSymbol("list")
	sym_map := lang.NewSymbol("map")
	sym_mapcat := lang.NewSymbol("mapcat")
	sym_msecs := lang.NewSymbol("msecs")
	sym_next := lang.NewSymbol("next")
	sym_nil_QMARK_ := lang.NewSymbol("nil?")
	sym_not_EQ_ := lang.NewSymbol("not=")
	sym_nth := lang.NewSymbol("nth")
	sym_offer_BANG_ := lang.NewSymbol("offer!")
	sym_opts := lang.NewSymbol("opts")
	sym_partition := lang.NewSymbol("partition")
	sym_pipe := lang.NewSymbol("pipe")
	sym_poll_BANG_ := lang.NewSymbol("poll!")
	sym_port := lang.NewSymbol("port")
	sym_port_DASH_case := lang.NewSymbol("port-case")
	sym_port_DASH_or_DASH_put := lang.NewSymbol("port-or-put")
	sym_ports := lang.NewSymbol("ports")
	sym_reduce := lang.NewSymbol("reduce")
	sym_remove := lang.NewSymbol("remove")
	sym_res__2__auto__ := lang.NewSymbol("res__2__auto__")
	sym_rest := lang.NewSymbol("rest")
	sym_seq := lang.NewSymbol("seq")
	sym_seq_QMARK_ := lang.NewSymbol("seq?")
	sym_set := lang.NewSymbol("set")
	sym_timeout := lang.NewSymbol("timeout")
	sym_to := lang.NewSymbol("to")
	sym_to_DASH_array := lang.NewSymbol("to-array")
	sym_try_DASH_put := lang.NewSymbol("try-put")
	sym_try_DASH_take := lang.NewSymbol("try-take")
	sym_val := lang.NewSymbol("val")
	sym_val__0__auto__ := lang.NewSymbol("val__0__auto__")
	sym_vec := lang.NewSymbol("vec")
	sym_vector := lang.NewSymbol("vector")
	sym_vector_QMARK_ := lang.NewSymbol("vector?")
	sym_xform := lang.NewSymbol("xform")
	kw_arglists := lang.NewKeyword("arglists")
	kw_as := lang.NewKeyword("as")
	kw_column := lang.NewKeyword("column")
	kw_default := lang.NewKeyword("default")
	kw_doc := lang.NewKeyword("doc")
	kw_else := lang.NewKeyword("else")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_macro := lang.NewKeyword("macro")
	kw_ns := lang.NewKeyword("ns")
	kw_priority := lang.NewKeyword("priority")
	kw_private := lang.NewKeyword("private")
	kw_rettag := lang.NewKeyword("rettag")
	// var clojure.core.async/>!
	var_clojure_DOT_core_DOT_async__GT__BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym__GT__BANG_)
	// var clojure.core.async/>!!
	var_clojure_DOT_core_DOT_async__GT__BANG__BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym__GT__BANG__BANG_)
	// var clojure.core.async/<!
	var_clojure_DOT_core_DOT_async__LT__BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym__LT__BANG_)
	// var clojure.core.async/<!!
	var_clojure_DOT_core_DOT_async__LT__BANG__BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym__LT__BANG__BANG_)
	// var clojure.core.async/alt!
	var_clojure_DOT_core_DOT_async_alt_BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_alt_BANG_)
	// var clojure.core.async/alt!!
	var_clojure_DOT_core_DOT_async_alt_BANG__BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_alt_BANG__BANG_)
	// var clojure.core.async/alts!
	var_clojure_DOT_core_DOT_async_alts_BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_alts_BANG_)
	// var clojure.core.async/alts!!
	var_clojure_DOT_core_DOT_async_alts_BANG__BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_alts_BANG__BANG_)
	// var clojure.core.async/chan
	var_clojure_DOT_core_DOT_async_chan := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_chan)
	// var clojure.core.async/check-unique-ports!
	var_clojure_DOT_core_DOT_async_check_DASH_unique_DASH_ports_BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_check_DASH_unique_DASH_ports_BANG_)
	// var clojure.core.async/close!
	var_clojure_DOT_core_DOT_async_close_BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_close_BANG_)
	// var clojure.core.async/default-case
	var_clojure_DOT_core_DOT_async_default_DASH_case := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_default_DASH_case)
	// var clojure.core.async/do-alt
	var_clojure_DOT_core_DOT_async_do_DASH_alt := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_do_DASH_alt)
	// var clojure.core.async/do-alts
	var_clojure_DOT_core_DOT_async_do_DASH_alts := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_do_DASH_alts)
	// var clojure.core.async/go
	var_clojure_DOT_core_DOT_async_go := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_go)
	// var clojure.core.async/go-loop
	var_clojure_DOT_core_DOT_async_go_DASH_loop := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_go_DASH_loop)
	// var clojure.core.async/offer!
	var_clojure_DOT_core_DOT_async_offer_BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_offer_BANG_)
	// var clojure.core.async/pipe
	var_clojure_DOT_core_DOT_async_pipe := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_pipe)
	// var clojure.core.async/poll!
	var_clojure_DOT_core_DOT_async_poll_BANG_ := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_poll_BANG_)
	// var clojure.core.async/port-case
	var_clojure_DOT_core_DOT_async_port_DASH_case := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_port_DASH_case)
	// var clojure.core.async/timeout
	var_clojure_DOT_core_DOT_async_timeout := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_timeout)
	// var clojure.core.async/try-put
	var_clojure_DOT_core_DOT_async_try_DASH_put := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_try_DASH_put)
	// var clojure.core.async/try-take
	var_clojure_DOT_core_DOT_async_try_DASH_take := lang.InternVarName(sym_clojure_DOT_core_DOT_async, sym_try_DASH_take)
	// var clojure.core/=
	var_clojure_DOT_core__EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym__EQ_)
	// var clojure.core/*
	var_clojure_DOT_core__STAR_ := lang.InternVarName(sym_clojure_DOT_core, sym__STAR_)
	// var clojure.core/apply
	var_clojure_DOT_core_apply := lang.InternVarName(sym_clojure_DOT_core, sym_apply)
	// var clojure.core/concat
	var_clojure_DOT_core_concat := lang.InternVarName(sym_clojure_DOT_core, sym_concat)
	// var clojure.core/conj
	var_clojure_DOT_core_conj := lang.InternVarName(sym_clojure_DOT_core, sym_conj)
	// var clojure.core/contains?
	var_clojure_DOT_core_contains_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_contains_QMARK_)
	// var clojure.core/count
	var_clojure_DOT_core_count := lang.InternVarName(sym_clojure_DOT_core, sym_count)
	// var clojure.core/filter
	var_clojure_DOT_core_filter := lang.InternVarName(sym_clojure_DOT_core, sym_filter)
	// var clojure.core/first
	var_clojure_DOT_core_first := lang.InternVarName(sym_clojure_DOT_core, sym_first)
	// var clojure.core/gensym
	var_clojure_DOT_core_gensym := lang.InternVarName(sym_clojure_DOT_core, sym_gensym)
	// var clojure.core/get
	var_clojure_DOT_core_get := lang.InternVarName(sym_clojure_DOT_core, sym_get)
	// var clojure.core/identity
	var_clojure_DOT_core_identity := lang.InternVarName(sym_clojure_DOT_core, sym_identity)
	// var clojure.core/keyword?
	var_clojure_DOT_core_keyword_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_keyword_QMARK_)
	// var clojure.core/list
	var_clojure_DOT_core_list := lang.InternVarName(sym_clojure_DOT_core, sym_list)
	// var clojure.core/map
	var_clojure_DOT_core_map := lang.InternVarName(sym_clojure_DOT_core, sym_map)
	// var clojure.core/mapcat
	var_clojure_DOT_core_mapcat := lang.InternVarName(sym_clojure_DOT_core, sym_mapcat)
	// var clojure.core/next
	var_clojure_DOT_core_next := lang.InternVarName(sym_clojure_DOT_core, sym_next)
	// var clojure.core/nil?
	var_clojure_DOT_core_nil_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_nil_QMARK_)
	// var clojure.core/not=
	var_clojure_DOT_core_not_EQ_ := lang.InternVarName(sym_clojure_DOT_core, sym_not_EQ_)
	// var clojure.core/nth
	var_clojure_DOT_core_nth := lang.InternVarName(sym_clojure_DOT_core, sym_nth)
	// var clojure.core/partition
	var_clojure_DOT_core_partition := lang.InternVarName(sym_clojure_DOT_core, sym_partition)
	// var clojure.core/reduce
	var_clojure_DOT_core_reduce := lang.InternVarName(sym_clojure_DOT_core, sym_reduce)
	// var clojure.core/remove
	var_clojure_DOT_core_remove := lang.InternVarName(sym_clojure_DOT_core, sym_remove)
	// var clojure.core/rest
	var_clojure_DOT_core_rest := lang.InternVarName(sym_clojure_DOT_core, sym_rest)
	// var clojure.core/seq
	var_clojure_DOT_core_seq := lang.InternVarName(sym_clojure_DOT_core, sym_seq)
	// var clojure.core/seq?
	var_clojure_DOT_core_seq_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_seq_QMARK_)
	// var clojure.core/set
	var_clojure_DOT_core_set := lang.InternVarName(sym_clojure_DOT_core, sym_set)
	// var clojure.core/to-array
	var_clojure_DOT_core_to_DASH_array := lang.InternVarName(sym_clojure_DOT_core, sym_to_DASH_array)
	// var clojure.core/vec
	var_clojure_DOT_core_vec := lang.InternVarName(sym_clojure_DOT_core, sym_vec)
	// var clojure.core/vector
	var_clojure_DOT_core_vector := lang.InternVarName(sym_clojure_DOT_core, sym_vector)
	// var clojure.core/vector?
	var_clojure_DOT_core_vector_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_vector_QMARK_)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async)
	_ = ns
	// >!
	{
		tmp0 := sym__GT__BANG_.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(44), kw_column, int(7), kw_end_DASH_line, int(44), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_port, sym_val)), kw_doc, "puts a val into port. nil values are not allowed. Will park if no buffer space is available.\n  Returns true, or throws if port is already closed.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(lang.Builtins["send"], []any{v2, v3})
			_ = tmp4
			return true
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async__GT__BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async__GT__BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >!!
	{
		tmp0 := sym__GT__BANG__BANG_.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(51), kw_column, int(6), kw_end_DASH_line, int(51), kw_end_DASH_column, int(8), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := lang.Apply(lang.Builtins["send"], []any{v2, v3})
			_ = tmp4
			return true
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async__GT__BANG__BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async__GT__BANG__BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chan
	{
		tmp0 := sym_chan.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(18), kw_column, int(7), kw_end_DASH_line, int(18), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_buf_DASH_or_DASH_n), lang.NewVector(sym_buf_DASH_or_DASH_n, sym_xform), lang.NewVector(sym_buf_DASH_or_DASH_n, sym_xform, sym_ex_DASH_handler)), kw_doc, "Creates a channel with an optional buffer, an optional transducer\n  (like (map f), (filter p) etc or a composition thereof), and an\n  optional exception-handler.  If buf-or-n is a number, will create\n  and use a fixed buffer of that size. If a transducer is supplied a\n  buffer must be specified. ex-handler must be a fn of one argument -\n  if an exception occurs during transformation it will be called with\n  the Throwable as an argument, and any non-nil return value will be\n  placed in the channel.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp2 := checkDerefVar(var_clojure_DOT_core_DOT_async_chan)
				tmp3 := lang.Apply(tmp2, []any{nil})
				return tmp3
			case 1:
				v2 := args[0]
				_ = v2
				tmp3 := checkDerefVar(var_clojure_DOT_core_DOT_async_chan)
				tmp4 := lang.Apply(tmp3, []any{v2, nil})
				return tmp4
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_DOT_async_chan)
				tmp5 := lang.Apply(tmp4, []any{v2, v3, nil})
				return tmp5
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				if lang.IsTruthy(v3) {
				} else {
				}
				_ = tmp5
				var tmp6 any
				if lang.IsTruthy(v3) {
					tmp7 := lang.Apply(fmt.Errorf, []any{"xform and ex-handler not yet supported"})
					panic(tmp7)
				} else {
				}
				_ = tmp6
				tmp8 := lang.Apply(lang.Builtins["chan-of"], []any{lang.Builtins["any"]})
				var tmp9 any
				{ // let
					// let binding "or__0__auto__"
					var v10 any = v2
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						tmp11 = v10
					} else {
						tmp11 = int64(0)
					}
					tmp9 = tmp11
				} // end let
				tmp10 := lang.Apply(lang.Builtins["make"], []any{tmp8, tmp9})
				return tmp10
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_chan = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_chan.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// close!
	{
		tmp0 := sym_close_BANG_.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(53), kw_column, int(7), kw_end_DASH_line, int(53), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_chan)), kw_doc, "Closes a channel. The channel will no longer accept any puts (they\n  will be ignored). Data in the channel remains available for taking,\n  until exhausted, after which takes will return nil. If there are any\n  pending takes, they will be dispatched with nil. Closing a closed\n  channel will throw an exception.\n\n  Logically closing happens after all puts have been\n  delivered. Therefore, any blocked or parked puts will remain\n  blocked/parked until a taker releases them.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := lang.Apply(lang.Builtins["close"], []any{v2})
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_close_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_close_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// default-case
	{
		tmp0 := sym_default_DASH_case.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(100), kw_column, int(8), kw_end_DASH_line, int(100), kw_end_DASH_column, int(19), kw_private, true, kw_arglists, lang.NewList(lang.NewVector()), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			var tmp2 any
			{ // let
				// let binding "def"
				tmp3 := new(reflect.SelectCase)
				var v4 any = tmp3
				_ = v4
				// set! host field
				var tmp5 any
				{
					targetV := reflect.ValueOf(v4)
					if targetV.Kind() == reflect.Ptr {
						targetV = targetV.Elem()
					}
					fieldVal := targetV.FieldByName("Dir")
					if !fieldVal.IsValid() {
						panic(fmt.Errorf("no such field Dir"))
					}
					if !fieldVal.CanSet() {
						panic(fmt.Errorf("cannot set field Dir"))
					}
					valV := reflect.ValueOf(reflect.SelectDefault)
					if !valV.IsValid() {
						switch fieldVal.Kind() {
						case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice, reflect.UnsafePointer:
							fieldVal.Set(reflect.Zero(fieldVal.Type()))
						default:
							panic(fmt.Errorf("cannot set field Dir to nil"))
						}
					} else {
						fieldVal.Set(valV)
					}
					tmp5 = reflect.SelectDefault
				}
				_ = tmp5
				tmp2 = v4
			} // end let
			return tmp2
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_default_DASH_case = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_default_DASH_case.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// <!
	{
		tmp0 := sym__LT__BANG_.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(35), kw_column, int(7), kw_end_DASH_line, int(35), kw_end_DASH_column, int(8), kw_arglists, lang.NewList(lang.NewVector(sym_port)), kw_doc, "takes a val from port. Will return nil if closed. Will park if\n  nothing is available.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "vec__1018"
				tmp4 := lang.Apply(lang.Builtins["recv"], []any{v2})
				var v5 any = tmp4
				_ = v5
				// let binding "val"
				tmp6 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "_"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				tmp3 = v8
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async__LT__BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async__LT__BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// <!!
	{
		tmp0 := sym__LT__BANG__BANG_.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(42), kw_column, int(6), kw_end_DASH_line, int(42), kw_end_DASH_column, int(8), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "vec__1018"
				tmp4 := lang.Apply(lang.Builtins["recv"], []any{v2})
				var v5 any = tmp4
				_ = v5
				// let binding "val"
				tmp6 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "_"
				tmp9 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				tmp3 = v8
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async__LT__BANG__BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async__LT__BANG__BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alt!
	{
		tmp0 := sym_alt_BANG_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_clauses)), kw_doc, "Makes a single choice between one of several channel operations,\n  as if by alts!, returning the value of the result expr corresponding\n  to the operation completed.\n\n  Each clause takes the form of:\n\n  channel-op[s] result-expr\n\n  where channel-ops is one of:\n\n  take-port - a single port to take\n  [take-port | [put-port put-val] ...] - a vector of ports as per alts!\n  :default | :priority - an option for alts!\n\n  and result-expr is either a list beginning with a vector, whereupon that\n  vector will be treated as a binding for the [val port] return of the\n  operation, else any other expression.\n\n  (alt!\n    [c t] ([val ch] (foo ch val))\n    x ([v] v)\n    [[out val]] :wrote\n    :default 42)\n\n  Each option may appear at most once. The choice and parking\n  characteristics are those of alts!.", kw_file, "clojure/core/async.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(250), kw_end_DASH_line, int(250))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_DOT_async_do_DASH_alt)
				tmp6 := lang.Apply(tmp5, []any{sym_clojure_DOT_core_DOT_async_SLASH_alts_BANG_, v4})
				return tmp6
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_alt_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_alt_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alt!!
	{
		tmp0 := sym_alt_BANG__BANG_.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(281), kw_column, int(11), kw_end_DASH_line, int(281), kw_end_DASH_column, int(15), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_args)), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async), kw_macro, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_clojure_DOT_core_DOT_async_SLASH_alt_BANG_})
				tmp9 := lang.Apply(tmp6, []any{tmp8, v4})
				tmp10 := lang.Apply(tmp5, []any{tmp9})
				return tmp10
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_alt_BANG__BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_alt_BANG__BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alts!
	{
		tmp0 := sym_alts_BANG_.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(185), kw_column, int(7), kw_end_DASH_line, int(185), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_ports, sym__AMP_, lang.NewMap(kw_as, sym_opts))), kw_doc, "Completes at most one of several channel operations. Must ports is a\n  vector of channel endpoints, which can be either a channel to take\n  from or a vector of [channel-to-put-to val-to-put], in any\n  combination.  Takes will be made as if by <!, and puts will be made\n  as if by >!. Unless the :priority option is true, if more than one\n  port operation is ready a non-deterministic choice will be made. If\n  no operation is ready and a :default value is\n  supplied, [default-val :default] will be returned, otherwise alts!\n  will park until the first operation to become ready\n  completes. Returns [val port] of the completed operation, where val\n  is the value taken for takes, and true for puts.\n\n  opts are passed as :key val ... Supported options:\n\n  :default val - the value to use if none of the operations are immediately ready\n  :priority true - (default nil) when true, the operations will be tried in order.\n\n  Note: there is no guarantee that the port exps or val exprs will be\n  used, nor in what order should they be, so they should not be\n  depended upon for side effects.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				restArgs := args[1:]
				var v3 any
				if len(restArgs) > 0 {
					v3 = lang.NewList(restArgs...)
				}
				_ = v3
				var tmp4 any
				{ // let
					// let binding "map__1034"
					var v5 any = v3
					_ = v5
					// let binding "map__1034"
					var tmp6 any
					tmp7 := checkDerefVar(var_clojure_DOT_core_seq_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{v5})
					if lang.IsTruthy(tmp8) {
						var tmp9 any
						tmp10 := checkDerefVar(var_clojure_DOT_core_next)
						tmp11 := lang.Apply(tmp10, []any{v5})
						if lang.IsTruthy(tmp11) {
							tmp12 := checkDerefVar(var_clojure_DOT_core_to_DASH_array)
							tmp13 := lang.Apply(tmp12, []any{v5})
							tmp14 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp13})
							tmp9 = tmp14
						} else {
							var tmp15 any
							tmp16 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp17 := lang.Apply(tmp16, []any{v5})
							if lang.IsTruthy(tmp17) {
								tmp18 := checkDerefVar(var_clojure_DOT_core_first)
								tmp19 := lang.Apply(tmp18, []any{v5})
								tmp15 = tmp19
							} else {
							}
							tmp9 = tmp15
						}
						tmp6 = tmp9
					} else {
						tmp6 = v5
					}
					var v20 any = tmp6
					_ = v20
					// let binding "opts"
					var v21 any = v20
					_ = v21
					tmp22 := checkDerefVar(var_clojure_DOT_core_DOT_async_do_DASH_alts)
					tmp23 := lang.Apply(tmp22, []any{v2, v21})
					tmp4 = tmp23
				} // end let
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_alts_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_alts_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alts!!
	{
		tmp0 := sym_alts_BANG__BANG_.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(210), kw_column, int(6), kw_end_DASH_line, int(210), kw_end_DASH_column, int(11), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 1)
				v2 := args[0]
				_ = v2
				restArgs := args[1:]
				var v3 any
				if len(restArgs) > 0 {
					v3 = lang.NewList(restArgs...)
				}
				_ = v3
				var tmp4 any
				{ // let
					// let binding "map__1034"
					var v5 any = v3
					_ = v5
					// let binding "map__1034"
					var tmp6 any
					tmp7 := checkDerefVar(var_clojure_DOT_core_seq_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{v5})
					if lang.IsTruthy(tmp8) {
						var tmp9 any
						tmp10 := checkDerefVar(var_clojure_DOT_core_next)
						tmp11 := lang.Apply(tmp10, []any{v5})
						if lang.IsTruthy(tmp11) {
							tmp12 := checkDerefVar(var_clojure_DOT_core_to_DASH_array)
							tmp13 := lang.Apply(tmp12, []any{v5})
							tmp14 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp13})
							tmp9 = tmp14
						} else {
							var tmp15 any
							tmp16 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp17 := lang.Apply(tmp16, []any{v5})
							if lang.IsTruthy(tmp17) {
								tmp18 := checkDerefVar(var_clojure_DOT_core_first)
								tmp19 := lang.Apply(tmp18, []any{v5})
								tmp15 = tmp19
							} else {
							}
							tmp9 = tmp15
						}
						tmp6 = tmp9
					} else {
						tmp6 = v5
					}
					var v20 any = tmp6
					_ = v20
					// let binding "opts"
					var v21 any = v20
					_ = v21
					tmp22 := checkDerefVar(var_clojure_DOT_core_DOT_async_do_DASH_alts)
					tmp23 := lang.Apply(tmp22, []any{v2, v21})
					tmp4 = tmp23
				} // end let
				return tmp4
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_alts_BANG__BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_alts_BANG__BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// check-unique-ports!
	{
		tmp0 := sym_check_DASH_unique_DASH_ports_BANG_.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(158), kw_column, int(8), kw_end_DASH_line, int(158), kw_end_DASH_column, int(26), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_ports)), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "chans"
				tmp4 := checkDerefVar(var_clojure_DOT_core_map)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v6 := args[0]
					_ = v6
					var tmp7 any
					tmp8 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v6})
					if lang.IsTruthy(tmp9) {
						tmp10 := lang.Apply(v6, []any{int64(0)})
						tmp7 = tmp10
					} else {
						tmp7 = v6
					}
					return tmp7
				})
				tmp6 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(160), kw_column, int(20), kw_end_DASH_line, int(160), kw_end_DASH_column, int(44))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7, v2})
				var v9 any = tmp8
				_ = v9
				// let binding "s"
				tmp10 := checkDerefVar(var_clojure_DOT_core_set)
				tmp11 := lang.Apply(tmp10, []any{v9})
				var v12 any = tmp11
				_ = v12
				var tmp13 any
				tmp14 := checkDerefVar(var_clojure_DOT_core_not_EQ_)
				tmp15 := checkDerefVar(var_clojure_DOT_core_count)
				tmp16 := lang.Apply(tmp15, []any{v12})
				tmp17 := checkDerefVar(var_clojure_DOT_core_count)
				tmp18 := lang.Apply(tmp17, []any{v2})
				tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
				if lang.IsTruthy(tmp19) {
					tmp20 := lang.Apply(fmt.Errorf, []any{"duplicate ports found in alt(s)! operation"})
					panic(tmp20)
				} else {
				}
				tmp3 = tmp13
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_check_DASH_unique_DASH_ports_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_check_DASH_unique_DASH_ports_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// do-alt
	{
		tmp0 := sym_do_DASH_alt.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(212), kw_column, int(7), kw_end_DASH_line, int(212), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_alts, sym_clauses)), kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "clauses"
				tmp5 := checkDerefVar(var_clojure_DOT_core_partition)
				tmp6 := lang.Apply(tmp5, []any{int64(2), v3})
				var v7 any = tmp6
				_ = v7
				// let binding "opt?"
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v9 := args[0]
					_ = v9
					tmp10 := checkDerefVar(var_clojure_DOT_core_keyword_QMARK_)
					tmp11 := checkDerefVar(var_clojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v9})
					tmp13 := lang.Apply(tmp10, []any{tmp12})
					return tmp13
				})
				tmp9 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(215), kw_column, int(14), kw_end_DASH_line, int(215), kw_end_DASH_column, int(34))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v11 any = tmp10
				_ = v11
				// let binding "opts"
				tmp12 := checkDerefVar(var_clojure_DOT_core_filter)
				tmp13 := lang.Apply(tmp12, []any{v11, v7})
				var v14 any = tmp13
				_ = v14
				// let binding "clauses"
				tmp15 := checkDerefVar(var_clojure_DOT_core_remove)
				tmp16 := lang.Apply(tmp15, []any{v11, v7})
				var v17 any = tmp16
				_ = v17
				// let binding "vec__1035"
				tmp18 := checkDerefVar(var_clojure_DOT_core_reduce)
				var tmp19 lang.FnFunc
				tmp19 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v20 := args[0]
					_ = v20
					v21 := args[1]
					_ = v21
					var tmp22 any
					{ // let
						// let binding "vec__1040"
						var v23 any = v20
						_ = v23
						// let binding "clauses"
						tmp24 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp25 := lang.Apply(tmp24, []any{v23, int64(0), nil})
						var v26 any = tmp25
						_ = v26
						// let binding "bindings"
						tmp27 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp28 := lang.Apply(tmp27, []any{v23, int64(1), nil})
						var v29 any = tmp28
						_ = v29
						// let binding "vec__1043"
						var v30 any = v21
						_ = v30
						// let binding "ports"
						tmp31 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp32 := lang.Apply(tmp31, []any{v30, int64(0), nil})
						var v33 any = tmp32
						_ = v33
						// let binding "expr"
						tmp34 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp35 := lang.Apply(tmp34, []any{v30, int64(1), nil})
						var v36 any = tmp35
						_ = v36
						var tmp37 any
						{ // let
							// let binding "ports"
							var tmp38 any
							tmp39 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
							tmp40 := lang.Apply(tmp39, []any{v33})
							if lang.IsTruthy(tmp40) {
								tmp38 = v33
							} else {
								tmp41 := lang.NewVector(v33)
								tmp42 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(221), kw_column, int(50), kw_end_DASH_line, int(221), kw_end_DASH_column, int(56))
								tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp38 = tmp43
							}
							var v44 any = tmp38
							_ = v44
							// let binding "vec__1046"
							tmp45 := checkDerefVar(var_clojure_DOT_core_reduce)
							var tmp46 lang.FnFunc
							tmp46 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v47 := args[0]
								_ = v47
								v48 := args[1]
								_ = v48
								var tmp49 any
								{ // let
									// let binding "vec__1050"
									var v50 any = v47
									_ = v50
									// let binding "ports"
									tmp51 := checkDerefVar(var_clojure_DOT_core_nth)
									tmp52 := lang.Apply(tmp51, []any{v50, int64(0), nil})
									var v53 any = tmp52
									_ = v53
									// let binding "bindings"
									tmp54 := checkDerefVar(var_clojure_DOT_core_nth)
									tmp55 := lang.Apply(tmp54, []any{v50, int64(1), nil})
									var v56 any = tmp55
									_ = v56
									var tmp57 any
									tmp58 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
									tmp59 := lang.Apply(tmp58, []any{v48})
									if lang.IsTruthy(tmp59) {
										var tmp60 any
										{ // let
											// let binding "vec__1053"
											var v61 any = v48
											_ = v61
											// let binding "port"
											tmp62 := checkDerefVar(var_clojure_DOT_core_nth)
											tmp63 := lang.Apply(tmp62, []any{v61, int64(0), nil})
											var v64 any = tmp63
											_ = v64
											// let binding "val"
											tmp65 := checkDerefVar(var_clojure_DOT_core_nth)
											tmp66 := lang.Apply(tmp65, []any{v61, int64(1), nil})
											var v67 any = tmp66
											_ = v67
											// let binding "gp"
											tmp68 := checkDerefVar(var_clojure_DOT_core_gensym)
											tmp69 := lang.Apply(tmp68, nil)
											var v70 any = tmp69
											_ = v70
											// let binding "gv"
											tmp71 := checkDerefVar(var_clojure_DOT_core_gensym)
											tmp72 := lang.Apply(tmp71, nil)
											var v73 any = tmp72
											_ = v73
											tmp74 := checkDerefVar(var_clojure_DOT_core_conj)
											tmp75 := lang.NewVector(v70, v73)
											tmp76 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(229), kw_column, int(38), kw_end_DASH_line, int(229), kw_end_DASH_column, int(44))
											tmp77, err := lang.WithMeta(tmp75, tmp76.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp78 := lang.Apply(tmp74, []any{v53, tmp77})
											tmp79 := checkDerefVar(var_clojure_DOT_core_conj)
											tmp80 := lang.NewVector(v70, v64)
											tmp81 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(229), kw_column, int(62), kw_end_DASH_line, int(229), kw_end_DASH_column, int(70))
											tmp82, err := lang.WithMeta(tmp80, tmp81.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp83 := lang.NewVector(v73, v67)
											tmp84 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(229), kw_column, int(72), kw_end_DASH_line, int(229), kw_end_DASH_column, int(79))
											tmp85, err := lang.WithMeta(tmp83, tmp84.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp86 := lang.Apply(tmp79, []any{v56, tmp82, tmp85})
											tmp87 := lang.NewVector(tmp78, tmp86)
											tmp88 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(229), kw_column, int(25), kw_end_DASH_line, int(229), kw_end_DASH_column, int(81))
											tmp89, err := lang.WithMeta(tmp87, tmp88.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp60 = tmp89
										} // end let
										tmp57 = tmp60
									} else {
										var tmp61 any
										{ // let
											// let binding "gp"
											tmp62 := checkDerefVar(var_clojure_DOT_core_gensym)
											tmp63 := lang.Apply(tmp62, nil)
											var v64 any = tmp63
											_ = v64
											tmp65 := checkDerefVar(var_clojure_DOT_core_conj)
											tmp66 := lang.Apply(tmp65, []any{v53, v64})
											tmp67 := checkDerefVar(var_clojure_DOT_core_conj)
											tmp68 := lang.NewVector(v64, v48)
											tmp69 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(231), kw_column, int(57), kw_end_DASH_line, int(231), kw_end_DASH_column, int(65))
											tmp70, err := lang.WithMeta(tmp68, tmp69.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp71 := lang.Apply(tmp67, []any{v56, tmp70})
											tmp72 := lang.NewVector(tmp66, tmp71)
											tmp73 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(231), kw_column, int(25), kw_end_DASH_line, int(231), kw_end_DASH_column, int(67))
											tmp74, err := lang.WithMeta(tmp72, tmp73.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp61 = tmp74
										} // end let
										tmp57 = tmp61
									}
									tmp49 = tmp57
								} // end let
								return tmp49
							})
							tmp47 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(224), kw_column, int(19), kw_end_DASH_line, int(231), kw_end_DASH_column, int(70))
							tmp48, err := lang.WithMeta(tmp46, tmp47.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp49 := lang.NewVector()
							tmp50 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(232), kw_column, int(20), kw_end_DASH_line, int(232), kw_end_DASH_column, int(21))
							tmp51, err := lang.WithMeta(tmp49, tmp50.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp52 := lang.NewVector(tmp51, v29)
							tmp53 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(232), kw_column, int(19), kw_end_DASH_line, int(232), kw_end_DASH_column, int(31))
							tmp54, err := lang.WithMeta(tmp52, tmp53.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp55 := lang.Apply(tmp45, []any{tmp48, tmp54, v44})
							var v56 any = tmp55
							_ = v56
							// let binding "ports"
							tmp57 := checkDerefVar(var_clojure_DOT_core_nth)
							tmp58 := lang.Apply(tmp57, []any{v56, int64(0), nil})
							var v59 any = tmp58
							_ = v59
							// let binding "bindings"
							tmp60 := checkDerefVar(var_clojure_DOT_core_nth)
							tmp61 := lang.Apply(tmp60, []any{v56, int64(1), nil})
							var v62 any = tmp61
							_ = v62
							tmp63 := checkDerefVar(var_clojure_DOT_core_conj)
							tmp64 := lang.NewVector(v59, v36)
							tmp65 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(233), kw_column, int(29), kw_end_DASH_line, int(233), kw_end_DASH_column, int(40))
							tmp66, err := lang.WithMeta(tmp64, tmp65.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp67 := lang.Apply(tmp63, []any{v26, tmp66})
							tmp68 := lang.NewVector(tmp67, v62)
							tmp69 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(233), kw_column, int(14), kw_end_DASH_line, int(233), kw_end_DASH_column, int(51))
							tmp70, err := lang.WithMeta(tmp68, tmp69.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp37 = tmp70
						} // end let
						tmp22 = tmp37
					} // end let
					return tmp22
				})
				tmp20 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(220), kw_column, int(10), kw_end_DASH_line, int(233), kw_end_DASH_column, int(53))
				tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp22 := lang.NewVector()
				tmp23 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(234), kw_column, int(11), kw_end_DASH_line, int(234), kw_end_DASH_column, int(12))
				tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp25 := lang.NewVector()
				tmp26 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(234), kw_column, int(14), kw_end_DASH_line, int(234), kw_end_DASH_column, int(15))
				tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp28 := lang.NewVector(tmp24, tmp27)
				tmp29 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(234), kw_column, int(10), kw_end_DASH_line, int(234), kw_end_DASH_column, int(16))
				tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp31 := lang.Apply(tmp18, []any{tmp21, tmp30, v17})
				var v32 any = tmp31
				_ = v32
				// let binding "clauses"
				tmp33 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp34 := lang.Apply(tmp33, []any{v32, int64(0), nil})
				var v35 any = tmp34
				_ = v35
				// let binding "bindings"
				tmp36 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp37 := lang.Apply(tmp36, []any{v32, int64(1), nil})
				var v38 any = tmp37
				_ = v38
				// let binding "gch"
				tmp39 := checkDerefVar(var_clojure_DOT_core_gensym)
				tmp40 := lang.Apply(tmp39, []any{"ch"})
				var v41 any = tmp40
				_ = v41
				// let binding "gret"
				tmp42 := checkDerefVar(var_clojure_DOT_core_gensym)
				tmp43 := lang.Apply(tmp42, []any{"ret"})
				var v44 any = tmp43
				_ = v44
				tmp45 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp46 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp47 := checkDerefVar(var_clojure_DOT_core_list)
				tmp48 := lang.Apply(tmp47, []any{sym_clojure_DOT_core_SLASH_let})
				tmp49 := checkDerefVar(var_clojure_DOT_core_list)
				tmp50 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp51 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp52 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp53 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp54 := checkDerefVar(var_clojure_DOT_core_mapcat)
				tmp55 := checkDerefVar(var_clojure_DOT_core_identity)
				tmp56 := lang.Apply(tmp54, []any{tmp55, v38})
				tmp57 := checkDerefVar(var_clojure_DOT_core_list)
				tmp58 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp59 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp60 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp61 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp62 := checkDerefVar(var_clojure_DOT_core_list)
				tmp63 := lang.Apply(tmp62, []any{sym_val__0__auto__})
				tmp64 := checkDerefVar(var_clojure_DOT_core_list)
				tmp65 := lang.Apply(tmp64, []any{v41})
				tmp66 := checkDerefVar(var_clojure_DOT_core_list)
				tmp67 := lang.Apply(tmp66, []any{kw_as})
				tmp68 := checkDerefVar(var_clojure_DOT_core_list)
				tmp69 := lang.Apply(tmp68, []any{v44})
				tmp70 := lang.Apply(tmp61, []any{tmp63, tmp65, tmp67, tmp69})
				tmp71 := lang.Apply(tmp60, []any{tmp70})
				tmp72 := lang.Apply(tmp58, []any{tmp59, tmp71})
				tmp73 := lang.Apply(tmp57, []any{tmp72})
				tmp74 := checkDerefVar(var_clojure_DOT_core_list)
				tmp75 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp76 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp77 := checkDerefVar(var_clojure_DOT_core_list)
				tmp78 := lang.Apply(tmp77, []any{v2})
				tmp79 := checkDerefVar(var_clojure_DOT_core_list)
				tmp80 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp81 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp82 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp83 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp84 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp85 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp86 := checkDerefVar(var_clojure_DOT_core_map)
				tmp87 := checkDerefVar(var_clojure_DOT_core_first)
				tmp88 := lang.Apply(tmp86, []any{tmp87, v35})
				tmp89 := lang.Apply(tmp84, []any{tmp85, tmp88})
				tmp90 := lang.Apply(tmp83, []any{tmp89})
				tmp91 := lang.Apply(tmp82, []any{tmp90})
				tmp92 := lang.Apply(tmp80, []any{tmp81, tmp91})
				tmp93 := lang.Apply(tmp79, []any{tmp92})
				tmp94 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp95 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp96 := lang.Apply(tmp94, []any{tmp95, v14})
				tmp97 := lang.Apply(tmp76, []any{tmp78, tmp93, tmp96})
				tmp98 := lang.Apply(tmp75, []any{tmp97})
				tmp99 := lang.Apply(tmp74, []any{tmp98})
				tmp100 := lang.Apply(tmp53, []any{tmp56, tmp73, tmp99})
				tmp101 := lang.Apply(tmp52, []any{tmp100})
				tmp102 := lang.Apply(tmp50, []any{tmp51, tmp101})
				tmp103 := lang.Apply(tmp49, []any{tmp102})
				tmp104 := checkDerefVar(var_clojure_DOT_core_list)
				tmp105 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp106 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp107 := checkDerefVar(var_clojure_DOT_core_list)
				tmp108 := lang.Apply(tmp107, []any{sym_clojure_DOT_core_SLASH_cond})
				tmp109 := checkDerefVar(var_clojure_DOT_core_mapcat)
				var tmp110 lang.FnFunc
				tmp110 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v111 := args[0]
					_ = v111
					var tmp112 any
					{ // let
						// let binding "vec__1057"
						var v113 any = v111
						_ = v113
						// let binding "ports"
						tmp114 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp115 := lang.Apply(tmp114, []any{v113, int64(0), nil})
						var v116 any = tmp115
						_ = v116
						// let binding "expr"
						tmp117 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp118 := lang.Apply(tmp117, []any{v113, int64(1), nil})
						var v119 any = tmp118
						_ = v119
						tmp120 := checkDerefVar(var_clojure_DOT_core_seq)
						tmp121 := checkDerefVar(var_clojure_DOT_core_concat)
						tmp122 := checkDerefVar(var_clojure_DOT_core_list)
						tmp123 := lang.Apply(tmp122, []any{sym_clojure_DOT_core_SLASH_or})
						tmp124 := checkDerefVar(var_clojure_DOT_core_map)
						var tmp125 lang.FnFunc
						tmp125 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v126 := args[0]
							_ = v126
							tmp127 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp128 := checkDerefVar(var_clojure_DOT_core_concat)
							tmp129 := checkDerefVar(var_clojure_DOT_core_list)
							tmp130 := lang.Apply(tmp129, []any{sym_clojure_DOT_core_SLASH__EQ_})
							tmp131 := checkDerefVar(var_clojure_DOT_core_list)
							tmp132 := lang.Apply(tmp131, []any{v41})
							tmp133 := checkDerefVar(var_clojure_DOT_core_list)
							var tmp134 any
							tmp135 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
							tmp136 := lang.Apply(tmp135, []any{v126})
							if lang.IsTruthy(tmp136) {
								tmp137 := checkDerefVar(var_clojure_DOT_core_first)
								tmp138 := lang.Apply(tmp137, []any{v126})
								tmp134 = tmp138
							} else {
								tmp134 = v126
							}
							tmp139 := lang.Apply(tmp133, []any{tmp134})
							tmp140 := lang.Apply(tmp128, []any{tmp130, tmp132, tmp139})
							tmp141 := lang.Apply(tmp127, []any{tmp140})
							return tmp141
						})
						tmp126 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(241), kw_column, int(39), kw_end_DASH_line, int(242), kw_end_DASH_column, int(84))
						tmp127, err := lang.WithMeta(tmp125, tmp126.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp128 := lang.Apply(tmp124, []any{tmp127, v116})
						tmp129 := lang.Apply(tmp121, []any{tmp123, tmp128})
						tmp130 := lang.Apply(tmp120, []any{tmp129})
						var tmp131 any
						var tmp132 any
						{ // let
							// let binding "and__0__auto__"
							tmp133 := checkDerefVar(var_clojure_DOT_core_seq_QMARK_)
							tmp134 := lang.Apply(tmp133, []any{v119})
							var v135 any = tmp134
							_ = v135
							var tmp136 any
							if lang.IsTruthy(v135) {
								tmp137 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
								tmp138 := checkDerefVar(var_clojure_DOT_core_first)
								tmp139 := lang.Apply(tmp138, []any{v119})
								tmp140 := lang.Apply(tmp137, []any{tmp139})
								tmp136 = tmp140
							} else {
								tmp136 = v135
							}
							tmp132 = tmp136
						} // end let
						if lang.IsTruthy(tmp132) {
							tmp133 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp134 := checkDerefVar(var_clojure_DOT_core_concat)
							tmp135 := checkDerefVar(var_clojure_DOT_core_list)
							tmp136 := lang.Apply(tmp135, []any{sym_clojure_DOT_core_SLASH_let})
							tmp137 := checkDerefVar(var_clojure_DOT_core_list)
							tmp138 := checkDerefVar(var_clojure_DOT_core_apply)
							tmp139 := checkDerefVar(var_clojure_DOT_core_vector)
							tmp140 := checkDerefVar(var_clojure_DOT_core_seq)
							tmp141 := checkDerefVar(var_clojure_DOT_core_concat)
							tmp142 := checkDerefVar(var_clojure_DOT_core_list)
							tmp143 := checkDerefVar(var_clojure_DOT_core_first)
							tmp144 := lang.Apply(tmp143, []any{v119})
							tmp145 := lang.Apply(tmp142, []any{tmp144})
							tmp146 := checkDerefVar(var_clojure_DOT_core_list)
							tmp147 := lang.Apply(tmp146, []any{v44})
							tmp148 := lang.Apply(tmp141, []any{tmp145, tmp147})
							tmp149 := lang.Apply(tmp140, []any{tmp148})
							tmp150 := lang.Apply(tmp138, []any{tmp139, tmp149})
							tmp151 := lang.Apply(tmp137, []any{tmp150})
							tmp152 := checkDerefVar(var_clojure_DOT_core_rest)
							tmp153 := lang.Apply(tmp152, []any{v119})
							tmp154 := lang.Apply(tmp134, []any{tmp136, tmp151, tmp153})
							tmp155 := lang.Apply(tmp133, []any{tmp154})
							tmp131 = tmp155
						} else {
							tmp131 = v119
						}
						tmp156 := lang.NewVector(tmp130, tmp131)
						tmp157 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(241), kw_column, int(21), kw_end_DASH_line, int(246), kw_end_DASH_column, int(29))
						tmp158, err := lang.WithMeta(tmp156, tmp157.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp112 = tmp158
					} // end let
					return tmp112
				})
				tmp111 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(240), kw_column, int(19), kw_end_DASH_line, int(246), kw_end_DASH_column, int(30))
				tmp112, err := lang.WithMeta(tmp110, tmp111.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp113 := lang.Apply(tmp109, []any{tmp112, v35})
				tmp114 := checkDerefVar(var_clojure_DOT_core_list)
				tmp115 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp116 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp117 := checkDerefVar(var_clojure_DOT_core_list)
				tmp118 := lang.Apply(tmp117, []any{sym_clojure_DOT_core_SLASH__EQ_})
				tmp119 := checkDerefVar(var_clojure_DOT_core_list)
				tmp120 := lang.Apply(tmp119, []any{v41})
				tmp121 := checkDerefVar(var_clojure_DOT_core_list)
				tmp122 := lang.Apply(tmp121, []any{kw_default})
				tmp123 := lang.Apply(tmp116, []any{tmp118, tmp120, tmp122})
				tmp124 := lang.Apply(tmp115, []any{tmp123})
				tmp125 := lang.Apply(tmp114, []any{tmp124})
				tmp126 := checkDerefVar(var_clojure_DOT_core_list)
				tmp127 := lang.Apply(tmp126, []any{sym_val__0__auto__})
				tmp128 := lang.Apply(tmp106, []any{tmp108, tmp113, tmp125, tmp127})
				tmp129 := lang.Apply(tmp105, []any{tmp128})
				tmp130 := lang.Apply(tmp104, []any{tmp129})
				tmp131 := lang.Apply(tmp46, []any{tmp48, tmp103, tmp130})
				tmp132 := lang.Apply(tmp45, []any{tmp131})
				tmp4 = tmp132
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_do_DASH_alt = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_do_DASH_alt.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// do-alts
	{
		tmp0 := sym_do_DASH_alts.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ports, sym_opts)), kw_doc, "returns derefable [val port] if immediate, nil if enqueued", kw_file, "clojure/core/async.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async), kw_end_DASH_column, int(14), kw_column, int(8), kw_line, int(165), kw_end_DASH_line, int(165), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_core_DOT_async_check_DASH_unique_DASH_ports_BANG_)
			tmp5 := lang.Apply(tmp4, []any{v2})
			_ = tmp5
			var tmp6 any
			{ // let
				// let binding "ports"
				tmp7 := checkDerefVar(var_clojure_DOT_core_vec)
				tmp8 := lang.Apply(tmp7, []any{v2})
				var v9 any = tmp8
				_ = v9
				// let binding "n"
				tmp10 := checkDerefVar(var_clojure_DOT_core_count)
				tmp11 := lang.Apply(tmp10, []any{v9})
				var v12 any = tmp11
				_ = v12
				// let binding "priority"
				tmp13 := lang.Apply(kw_priority, []any{v3})
				var v14 any = tmp13
				_ = v14
				// let binding "selects"
				tmp15 := checkDerefVar(var_clojure_DOT_core_map)
				tmp16 := checkDerefVar(var_clojure_DOT_core_DOT_async_port_DASH_case)
				tmp17 := lang.Apply(tmp15, []any{tmp16, v9})
				var v18 any = tmp17
				_ = v18
				// let binding "selects"
				var tmp19 any
				tmp20 := checkDerefVar(var_clojure_DOT_core_contains_QMARK_)
				tmp21 := lang.Apply(tmp20, []any{v3, kw_default})
				if lang.IsTruthy(tmp21) {
					tmp22 := checkDerefVar(var_clojure_DOT_core_conj)
					tmp23 := checkDerefVar(var_clojure_DOT_core_vec)
					tmp24 := lang.Apply(tmp23, []any{v18})
					tmp25 := checkDerefVar(var_clojure_DOT_core_DOT_async_default_DASH_case)
					tmp26 := lang.Apply(tmp25, nil)
					tmp27 := lang.Apply(tmp22, []any{tmp24, tmp26})
					tmp19 = tmp27
				} else {
					tmp19 = v18
				}
				var v28 any = tmp19
				_ = v28
				// let binding "def"
				tmp29 := checkDerefVar(var_clojure_DOT_core_DOT_async_default_DASH_case)
				tmp30 := lang.Apply(tmp29, nil)
				var v31 any = tmp30
				_ = v31
				// let binding "vec__1030"
				tmp32 := checkDerefVar(var_clojure_DOT_core_map)
				tmp33 := lang.Apply(tmp32, []any{lang.Builtins["deref"], v28})
				tmp34 := lang.Apply(reflect.Select, []any{tmp33})
				var v35 any = tmp34
				_ = v35
				// let binding "chosen-idx"
				tmp36 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp37 := lang.Apply(tmp36, []any{v35, int64(0), nil})
				var v38 any = tmp37
				_ = v38
				// let binding "val"
				tmp39 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp40 := lang.Apply(tmp39, []any{v35, int64(1), nil})
				var v41 any = tmp40
				_ = v41
				// let binding "ok"
				tmp42 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp43 := lang.Apply(tmp42, []any{v35, int64(2), nil})
				var v44 any = tmp43
				_ = v44
				// let binding "chosen"
				tmp45 := checkDerefVar(var_clojure_DOT_core_get)
				tmp46 := lang.Apply(tmp45, []any{v9, v38})
				var v47 any = tmp46
				_ = v47
				var tmp48 any
				tmp49 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
				tmp50 := lang.Apply(tmp49, []any{v47})
				if lang.IsTruthy(tmp50) {
					tmp51 := lang.Apply(v47, []any{int64(0)})
					tmp52 := lang.NewVector(true, tmp51)
					tmp53 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(181), kw_column, int(24), kw_end_DASH_line, int(181), kw_end_DASH_column, int(40))
					tmp54, err := lang.WithMeta(tmp52, tmp53.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp48 = tmp54
				} else {
					var tmp55 any
					tmp56 := checkDerefVar(var_clojure_DOT_core__EQ_)
					tmp57 := lang.Apply(tmp56, []any{v12, v38})
					if lang.IsTruthy(tmp57) {
						tmp58 := lang.Apply(kw_default, []any{v3})
						tmp59 := lang.NewVector(tmp58, kw_default)
						tmp60 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(182), kw_column, int(24), kw_end_DASH_line, int(182), kw_end_DASH_column, int(49))
						tmp61, err := lang.WithMeta(tmp59, tmp60.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp55 = tmp61
					} else {
						var tmp62 any
						if lang.IsTruthy(kw_else) {
							var tmp63 any
							if lang.IsTruthy(v44) {
								tmp64, ok := lang.FieldOrMethod(v41, "Interface")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v41, "Interface")))
								}
								var tmp65 any
								switch reflect.TypeOf(tmp64).Kind() {
								case reflect.Func:
									tmp65 = lang.Apply(tmp64, nil)
								default:
									tmp65 = tmp64
								}
								tmp63 = tmp65
							} else {
							}
							tmp66 := lang.NewVector(tmp63, v47)
							tmp67 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(183), kw_column, int(13), kw_end_DASH_line, int(183), kw_end_DASH_column, int(47))
							tmp68, err := lang.WithMeta(tmp66, tmp67.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp62 = tmp68
						} else {
						}
						tmp55 = tmp62
					}
					tmp48 = tmp55
				}
				tmp6 = tmp48
			} // end let
			return tmp6
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_do_DASH_alts = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_do_DASH_alts.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// go
	{
		tmp0 := sym_go.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Asynchronously executes the body, returning immediately to the\n  calling thread. Additionally, any visible calls to <!, >! and alt!/alts!\n  channel operations within the body will block (if necessary) by\n  'parking' the calling thread rather than tying up an OS thread (or\n  the only JS thread when in ClojureScript). Upon completion of the\n  operation, the body will be resumed.\n\n  Unlike in Clojure or ClojureScript, go blocks may (either directly\n  or indirectly) perform operations that may block indefinitely, as go\n  blocks are run on goroutines, which relinquish the thread of control\n  when parked.\n\n  Returns a channel which will receive the result of the body when\n  completed", kw_file, "clojure/core/async.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async), kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(67), kw_end_DASH_line, int(67))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				restArgs := args[2:]
				var v4 any
				if len(restArgs) > 0 {
					v4 = lang.NewList(restArgs...)
				}
				_ = v4
				tmp5 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_clojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym_clojure_DOT_core_SLASH_let})
				tmp9 := checkDerefVar(var_clojure_DOT_core_list)
				tmp10 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp11 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp12 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_clojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_c__0__auto__})
				tmp16 := checkDerefVar(var_clojure_DOT_core_list)
				tmp17 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp18 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp19 := checkDerefVar(var_clojure_DOT_core_list)
				tmp20 := lang.Apply(tmp19, []any{sym_clojure_DOT_core_DOT_async_SLASH_chan})
				tmp21 := checkDerefVar(var_clojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{int64(1)})
				tmp23 := lang.Apply(tmp18, []any{tmp20, tmp22})
				tmp24 := lang.Apply(tmp17, []any{tmp23})
				tmp25 := lang.Apply(tmp16, []any{tmp24})
				tmp26 := checkDerefVar(var_clojure_DOT_core_list)
				tmp27 := lang.Apply(tmp26, []any{sym_f__1__auto__})
				tmp28 := checkDerefVar(var_clojure_DOT_core_list)
				tmp29 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp30 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp31 := checkDerefVar(var_clojure_DOT_core_list)
				tmp32 := lang.Apply(tmp31, []any{sym_clojure_DOT_core_SLASH_fn})
				tmp33 := checkDerefVar(var_clojure_DOT_core_list)
				tmp34 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp35 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp36 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp37 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp38 := lang.Apply(tmp37, nil)
				tmp39 := lang.Apply(tmp36, []any{tmp38})
				tmp40 := lang.Apply(tmp34, []any{tmp35, tmp39})
				tmp41 := lang.Apply(tmp33, []any{tmp40})
				tmp42 := checkDerefVar(var_clojure_DOT_core_list)
				tmp43 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp44 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp45 := checkDerefVar(var_clojure_DOT_core_list)
				tmp46 := lang.Apply(tmp45, []any{sym_clojure_DOT_core_SLASH_let})
				tmp47 := checkDerefVar(var_clojure_DOT_core_list)
				tmp48 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp49 := checkDerefVar(var_clojure_DOT_core_vector)
				tmp50 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp51 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp52 := checkDerefVar(var_clojure_DOT_core_list)
				tmp53 := lang.Apply(tmp52, []any{sym_res__2__auto__})
				tmp54 := checkDerefVar(var_clojure_DOT_core_list)
				tmp55 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp56 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp57 := checkDerefVar(var_clojure_DOT_core_list)
				tmp58 := lang.Apply(tmp57, []any{sym_do})
				tmp59 := lang.Apply(tmp56, []any{tmp58, v4})
				tmp60 := lang.Apply(tmp55, []any{tmp59})
				tmp61 := lang.Apply(tmp54, []any{tmp60})
				tmp62 := lang.Apply(tmp51, []any{tmp53, tmp61})
				tmp63 := lang.Apply(tmp50, []any{tmp62})
				tmp64 := lang.Apply(tmp48, []any{tmp49, tmp63})
				tmp65 := lang.Apply(tmp47, []any{tmp64})
				tmp66 := checkDerefVar(var_clojure_DOT_core_list)
				tmp67 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp68 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp69 := checkDerefVar(var_clojure_DOT_core_list)
				tmp70 := lang.Apply(tmp69, []any{sym_clojure_DOT_core_DOT_async_SLASH__GT__BANG_})
				tmp71 := checkDerefVar(var_clojure_DOT_core_list)
				tmp72 := lang.Apply(tmp71, []any{sym_c__0__auto__})
				tmp73 := checkDerefVar(var_clojure_DOT_core_list)
				tmp74 := lang.Apply(tmp73, []any{sym_res__2__auto__})
				tmp75 := lang.Apply(tmp68, []any{tmp70, tmp72, tmp74})
				tmp76 := lang.Apply(tmp67, []any{tmp75})
				tmp77 := lang.Apply(tmp66, []any{tmp76})
				tmp78 := lang.Apply(tmp44, []any{tmp46, tmp65, tmp77})
				tmp79 := lang.Apply(tmp43, []any{tmp78})
				tmp80 := lang.Apply(tmp42, []any{tmp79})
				tmp81 := lang.Apply(tmp30, []any{tmp32, tmp41, tmp80})
				tmp82 := lang.Apply(tmp29, []any{tmp81})
				tmp83 := lang.Apply(tmp28, []any{tmp82})
				tmp84 := lang.Apply(tmp13, []any{tmp15, tmp25, tmp27, tmp83})
				tmp85 := lang.Apply(tmp12, []any{tmp84})
				tmp86 := lang.Apply(tmp10, []any{tmp11, tmp85})
				tmp87 := lang.Apply(tmp9, []any{tmp86})
				tmp88 := checkDerefVar(var_clojure_DOT_core_list)
				tmp89 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp90 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp91 := checkDerefVar(var_clojure_DOT_core_list)
				tmp92 := lang.Apply(tmp91, []any{sym_go_SLASH_go})
				tmp93 := checkDerefVar(var_clojure_DOT_core_list)
				tmp94 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp95 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp96 := checkDerefVar(var_clojure_DOT_core_list)
				tmp97 := lang.Apply(tmp96, []any{sym_f__1__auto__})
				tmp98 := lang.Apply(tmp95, []any{tmp97})
				tmp99 := lang.Apply(tmp94, []any{tmp98})
				tmp100 := lang.Apply(tmp93, []any{tmp99})
				tmp101 := lang.Apply(tmp90, []any{tmp92, tmp100})
				tmp102 := lang.Apply(tmp89, []any{tmp101})
				tmp103 := lang.Apply(tmp88, []any{tmp102})
				tmp104 := checkDerefVar(var_clojure_DOT_core_list)
				tmp105 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp106 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp107 := checkDerefVar(var_clojure_DOT_core_list)
				tmp108 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp109 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp110 := checkDerefVar(var_clojure_DOT_core_list)
				tmp111 := lang.Apply(tmp110, []any{sym_go_SLASH__LT__DASH_chan_DASH_of})
				tmp112 := checkDerefVar(var_clojure_DOT_core_list)
				tmp113 := lang.Apply(tmp112, []any{sym_go_SLASH_any})
				tmp114 := lang.Apply(tmp109, []any{tmp111, tmp113})
				tmp115 := lang.Apply(tmp108, []any{tmp114})
				tmp116 := lang.Apply(tmp107, []any{tmp115})
				tmp117 := checkDerefVar(var_clojure_DOT_core_list)
				tmp118 := lang.Apply(tmp117, []any{sym_c__0__auto__})
				tmp119 := lang.Apply(tmp106, []any{tmp116, tmp118})
				tmp120 := lang.Apply(tmp105, []any{tmp119})
				tmp121 := lang.Apply(tmp104, []any{tmp120})
				tmp122 := lang.Apply(tmp6, []any{tmp8, tmp87, tmp103, tmp121})
				tmp123 := lang.Apply(tmp5, []any{tmp122})
				return tmp123
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_go = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_go.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// go-loop
	{
		tmp0 := sym_go_DASH_loop.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "Like (go (loop ...))", kw_file, "clojure/core/async.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(287), kw_end_DASH_line, int(287))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArityGTE(args, 3)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				restArgs := args[3:]
				var v5 any
				if len(restArgs) > 0 {
					v5 = lang.NewList(restArgs...)
				}
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_clojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_clojure_DOT_core_DOT_async_SLASH_go})
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := checkDerefVar(var_clojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_clojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_clojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_clojure_DOT_core_SLASH_loop})
				tmp15 := checkDerefVar(var_clojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16, v5})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp7, []any{tmp9, tmp19})
				tmp21 := lang.Apply(tmp6, []any{tmp20})
				return tmp21
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_go_DASH_loop = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_go_DASH_loop.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// offer!
	{
		tmp0 := sym_offer_BANG_.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(143), kw_column, int(7), kw_end_DASH_line, int(143), kw_end_DASH_column, int(12), kw_arglists, lang.NewList(lang.NewVector(sym_port, sym_val)), kw_doc, "Puts a val into port if it's possible to do so immediately.\n   nil values are not allowed. Never blocks. Returns true if offer succeeds.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := checkDerefVar(var_clojure_DOT_core_DOT_async_try_DASH_put)
				tmp6 := lang.Apply(tmp5, []any{v2, v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp8 = v7
				} else {
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_offer_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_offer_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pipe
	{
		tmp0 := sym_pipe.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(292), kw_column, int(7), kw_end_DASH_line, int(292), kw_end_DASH_column, int(10), kw_arglists, lang.NewList(lang.NewVector(sym_from, sym_to), lang.NewVector(sym_from, sym_to, sym_close_QMARK_)), kw_doc, "Takes elements from the from channel and supplies them to the to\n  channel. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				tmp4 := checkDerefVar(var_clojure_DOT_core_DOT_async_pipe)
				tmp5 := lang.Apply(tmp4, []any{v2, v3, true})
				return tmp5
			case 3:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				v4 := args[2]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "c__0__auto__"
					tmp6 := checkDerefVar(var_clojure_DOT_core_DOT_async_chan)
					tmp7 := lang.Apply(tmp6, []any{int64(1)})
					var v8 any = tmp7
					_ = v8
					// let binding "f__1__auto__"
					var tmp9 lang.FnFunc
					tmp9 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						var tmp10 any
						{ // let
							// let binding "res__2__auto__"
							var tmp11 any
							{ // let
								for {
									var tmp12 any
									{ // let
										// let binding "v"
										tmp13 := checkDerefVar(var_clojure_DOT_core_DOT_async__LT__BANG_)
										tmp14 := lang.Apply(tmp13, []any{v2})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										tmp17 := checkDerefVar(var_clojure_DOT_core_nil_QMARK_)
										tmp18 := lang.Apply(tmp17, []any{v15})
										if lang.IsTruthy(tmp18) {
											var tmp19 any
											if lang.IsTruthy(v4) {
												tmp20 := checkDerefVar(var_clojure_DOT_core_DOT_async_close_BANG_)
												tmp21 := lang.Apply(tmp20, []any{v3})
												tmp19 = tmp21
											} else {
											}
											tmp16 = tmp19
										} else {
											var tmp22 any
											tmp23 := checkDerefVar(var_clojure_DOT_core_DOT_async__GT__BANG_)
											tmp24 := lang.Apply(tmp23, []any{v3, v15})
											if lang.IsTruthy(tmp24) {
												continue
											} else {
											}
											tmp16 = tmp22
										}
										tmp12 = tmp16
									} // end let
									tmp11 = tmp12
									break
								}
							} // end let
							var v12 any = tmp11
							_ = v12
							tmp13 := checkDerefVar(var_clojure_DOT_core_DOT_async__GT__BANG_)
							tmp14 := lang.Apply(tmp13, []any{v8, v12})
							tmp10 = tmp14
						} // end let
						return tmp10
					})
					var v10 any = tmp9
					_ = v10
					go lang.Apply(v10, []any{})
					tmp11 := lang.Apply(lang.Builtins["<-chan-of"], []any{lang.Builtins["any"]})
					tmp12 := lang.Apply(tmp11, []any{v8})
					tmp5 = tmp12
				} // end let
				_ = tmp5
				return v3
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_pipe = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_pipe.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// poll!
	{
		tmp0 := sym_poll_BANG_.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(150), kw_column, int(7), kw_end_DASH_line, int(150), kw_end_DASH_column, int(11), kw_arglists, lang.NewList(lang.NewVector(sym_port)), kw_doc, "Takes a val from port if it's possible to do so immediately.\n   Never blocks. Returns value if successful, nil otherwise.", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "res"
				tmp4 := checkDerefVar(var_clojure_DOT_core_DOT_async_try_DASH_take)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				// let binding "vec__1027"
				var v7 any = v6
				_ = v7
				// let binding "val"
				tmp8 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp9 := lang.Apply(tmp8, []any{v7, int64(0), nil})
				var v10 any = tmp9
				_ = v10
				// let binding "ok"
				tmp11 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp12 := lang.Apply(tmp11, []any{v7, int64(1), nil})
				var v13 any = tmp12
				_ = v13
				var tmp14 any
				if lang.IsTruthy(v13) {
					tmp14 = v10
				} else {
				}
				tmp3 = tmp14
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_poll_BANG_ = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_poll_BANG_.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// port-case
	{
		tmp0 := sym_port_DASH_case.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_port_DASH_or_DASH_put)), kw_doc, "Returns a *reflect.SelectCase for the given channel operation.", kw_file, "clojure/core/async.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async), kw_end_DASH_column, int(16), kw_column, int(8), kw_line, int(106), kw_end_DASH_line, int(106), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "wport"
				var tmp4 any
				tmp5 := checkDerefVar(var_clojure_DOT_core_vector_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v2})
				if lang.IsTruthy(tmp6) {
					tmp7 := lang.Apply(v2, []any{int64(0)})
					tmp4 = tmp7
				} else {
				}
				var v8 any = tmp4
				_ = v8
				// let binding "port"
				var tmp9 any
				{ // let
					// let binding "or__0__auto__"
					var v10 any = v8
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						tmp11 = v10
					} else {
						tmp11 = v2
					}
					tmp9 = tmp11
				} // end let
				var v10 any = tmp9
				_ = v10
				// let binding "val"
				var tmp11 any
				if lang.IsTruthy(v8) {
					tmp12 := lang.Apply(v2, []any{int64(1)})
					tmp13 := lang.Apply(reflect.ValueOf, []any{tmp12})
					tmp11 = tmp13
				} else {
				}
				var v14 any = tmp11
				_ = v14
				// let binding "select-case"
				tmp15 := new(reflect.SelectCase)
				var v16 any = tmp15
				_ = v16
				tmp17 := lang.Apply(reflect.ValueOf, []any{v10})
				// set! host field
				var tmp18 any
				{
					targetV := reflect.ValueOf(v16)
					if targetV.Kind() == reflect.Ptr {
						targetV = targetV.Elem()
					}
					fieldVal := targetV.FieldByName("Chan")
					if !fieldVal.IsValid() {
						panic(fmt.Errorf("no such field Chan"))
					}
					if !fieldVal.CanSet() {
						panic(fmt.Errorf("cannot set field Chan"))
					}
					valV := reflect.ValueOf(tmp17)
					if !valV.IsValid() {
						switch fieldVal.Kind() {
						case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice, reflect.UnsafePointer:
							fieldVal.Set(reflect.Zero(fieldVal.Type()))
						default:
							panic(fmt.Errorf("cannot set field Chan to nil"))
						}
					} else {
						fieldVal.Set(valV)
					}
					tmp18 = tmp17
				}
				_ = tmp18
				var tmp19 any
				if lang.IsTruthy(v8) {
					tmp19 = reflect.SelectSend
				} else {
					tmp19 = reflect.SelectRecv
				}
				// set! host field
				var tmp20 any
				{
					targetV := reflect.ValueOf(v16)
					if targetV.Kind() == reflect.Ptr {
						targetV = targetV.Elem()
					}
					fieldVal := targetV.FieldByName("Dir")
					if !fieldVal.IsValid() {
						panic(fmt.Errorf("no such field Dir"))
					}
					if !fieldVal.CanSet() {
						panic(fmt.Errorf("cannot set field Dir"))
					}
					valV := reflect.ValueOf(tmp19)
					if !valV.IsValid() {
						switch fieldVal.Kind() {
						case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice, reflect.UnsafePointer:
							fieldVal.Set(reflect.Zero(fieldVal.Type()))
						default:
							panic(fmt.Errorf("cannot set field Dir to nil"))
						}
					} else {
						fieldVal.Set(valV)
					}
					tmp20 = tmp19
				}
				_ = tmp20
				var tmp21 any
				if lang.IsTruthy(v8) {
					// set! host field
					var tmp22 any
					{
						targetV := reflect.ValueOf(v16)
						if targetV.Kind() == reflect.Ptr {
							targetV = targetV.Elem()
						}
						fieldVal := targetV.FieldByName("Send")
						if !fieldVal.IsValid() {
							panic(fmt.Errorf("no such field Send"))
						}
						if !fieldVal.CanSet() {
							panic(fmt.Errorf("cannot set field Send"))
						}
						valV := reflect.ValueOf(v14)
						if !valV.IsValid() {
							switch fieldVal.Kind() {
							case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice, reflect.UnsafePointer:
								fieldVal.Set(reflect.Zero(fieldVal.Type()))
							default:
								panic(fmt.Errorf("cannot set field Send to nil"))
							}
						} else {
							fieldVal.Set(valV)
						}
						tmp22 = v14
					}
					tmp21 = tmp22
				} else {
				}
				_ = tmp21
				tmp3 = v16
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_port_DASH_case = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_port_DASH_case.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// timeout
	{
		tmp0 := sym_timeout.WithMeta(lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(91), kw_column, int(7), kw_end_DASH_line, int(91), kw_end_DASH_column, int(13), kw_arglists, lang.NewList(lang.NewVector(sym_msecs)), kw_doc, "Returns a channel that will close after msecs", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "ret"
				tmp4 := checkDerefVar(var_clojure_DOT_core_DOT_async_chan)
				tmp5 := lang.Apply(tmp4, nil)
				var v6 any = tmp5
				_ = v6
				// let binding "after"
				tmp7 := checkDerefVar(var_clojure_DOT_core__STAR_)
				tmp8 := lang.Apply(lang.Builtins["int64"], []any{time4.Millisecond})
				tmp9 := lang.Apply(tmp7, []any{v2, tmp8})
				tmp10 := lang.Apply(time4.After, []any{tmp9})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				{ // let
					// let binding "c__0__auto__"
					tmp13 := checkDerefVar(var_clojure_DOT_core_DOT_async_chan)
					tmp14 := lang.Apply(tmp13, []any{int64(1)})
					var v15 any = tmp14
					_ = v15
					// let binding "f__1__auto__"
					var tmp16 lang.FnFunc
					tmp16 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						var tmp17 any
						{ // let
							// let binding "res__2__auto__"
							tmp18 := checkDerefVar(var_clojure_DOT_core_DOT_async__LT__BANG_)
							tmp19 := lang.Apply(tmp18, []any{v11})
							_ = tmp19
							tmp20 := checkDerefVar(var_clojure_DOT_core_DOT_async_close_BANG_)
							tmp21 := lang.Apply(tmp20, []any{v6})
							var v22 any = tmp21
							_ = v22
							tmp23 := checkDerefVar(var_clojure_DOT_core_DOT_async__GT__BANG_)
							tmp24 := lang.Apply(tmp23, []any{v15, v22})
							tmp17 = tmp24
						} // end let
						return tmp17
					})
					var v17 any = tmp16
					_ = v17
					go lang.Apply(v17, []any{})
					tmp18 := lang.Apply(lang.Builtins["<-chan-of"], []any{lang.Builtins["any"]})
					tmp19 := lang.Apply(tmp18, []any{v15})
					tmp12 = tmp19
				} // end let
				_ = tmp12
				tmp3 = v6
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_timeout = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_timeout.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// try-put
	{
		tmp0 := sym_try_DASH_put.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_port, sym_val)), kw_doc, "Returns true if val was sent on the port, false if sending would\n  block", kw_file, "clojure/core/async.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async), kw_end_DASH_column, int(14), kw_column, int(8), kw_line, int(118), kw_end_DASH_line, int(118), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "sc"
				tmp5 := checkDerefVar(var_clojure_DOT_core_DOT_async_port_DASH_case)
				tmp6 := lang.NewVector(v2, v3)
				tmp7 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(122), kw_column, int(23), kw_end_DASH_line, int(122), kw_end_DASH_column, int(32))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				var v10 any = tmp9
				_ = v10
				// let binding "def"
				tmp11 := checkDerefVar(var_clojure_DOT_core_DOT_async_default_DASH_case)
				tmp12 := lang.Apply(tmp11, nil)
				var v13 any = tmp12
				_ = v13
				// let binding "vec__1021"
				tmp14 := checkDerefVar(var_clojure_DOT_core_map)
				tmp15 := lang.NewVector(v10, v13)
				tmp16 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(124), kw_column, int(55), kw_end_DASH_line, int(124), kw_end_DASH_column, int(62))
				tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp18 := lang.Apply(tmp14, []any{lang.Builtins["deref"], tmp17})
				tmp19 := lang.Apply(reflect.Select, []any{tmp18})
				var v20 any = tmp19
				_ = v20
				// let binding "chosen"
				tmp21 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp22 := lang.Apply(tmp21, []any{v20, int64(0), nil})
				var v23 any = tmp22
				_ = v23
				// let binding "val"
				tmp24 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp25 := lang.Apply(tmp24, []any{v20, int64(1), nil})
				var v26 any = tmp25
				_ = v26
				// let binding "ok"
				tmp27 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp28 := lang.Apply(tmp27, []any{v20, int64(2), nil})
				var v29 any = tmp28
				_ = v29
				tmp30 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp31 := lang.Apply(tmp30, []any{int64(0), v23})
				tmp4 = tmp31
			} // end let
			return tmp4
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_try_DASH_put = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_try_DASH_put.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// try-take
	{
		tmp0 := sym_try_DASH_take.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_port)), kw_doc, "Returns [val true] if val was received from the port, [nil false] if the channel was closed,\n  and nil if receiving would block.", kw_file, "clojure/core/async.glj", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_core_DOT_async), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(127), kw_end_DASH_line, int(127), kw_private, true)).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "sc"
				tmp4 := new(reflect.SelectCase)
				var v5 any = tmp4
				_ = v5
				// let binding "_"
				// set! host field
				var tmp6 any
				{
					targetV := reflect.ValueOf(v5)
					if targetV.Kind() == reflect.Ptr {
						targetV = targetV.Elem()
					}
					fieldVal := targetV.FieldByName("Dir")
					if !fieldVal.IsValid() {
						panic(fmt.Errorf("no such field Dir"))
					}
					if !fieldVal.CanSet() {
						panic(fmt.Errorf("cannot set field Dir"))
					}
					valV := reflect.ValueOf(reflect.SelectRecv)
					if !valV.IsValid() {
						switch fieldVal.Kind() {
						case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice, reflect.UnsafePointer:
							fieldVal.Set(reflect.Zero(fieldVal.Type()))
						default:
							panic(fmt.Errorf("cannot set field Dir to nil"))
						}
					} else {
						fieldVal.Set(valV)
					}
					tmp6 = reflect.SelectRecv
				}
				_ = tmp6
				tmp7 := lang.Apply(reflect.ValueOf, []any{v2})
				// set! host field
				var tmp8 any
				{
					targetV := reflect.ValueOf(v5)
					if targetV.Kind() == reflect.Ptr {
						targetV = targetV.Elem()
					}
					fieldVal := targetV.FieldByName("Chan")
					if !fieldVal.IsValid() {
						panic(fmt.Errorf("no such field Chan"))
					}
					if !fieldVal.CanSet() {
						panic(fmt.Errorf("cannot set field Chan"))
					}
					valV := reflect.ValueOf(tmp7)
					if !valV.IsValid() {
						switch fieldVal.Kind() {
						case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice, reflect.UnsafePointer:
							fieldVal.Set(reflect.Zero(fieldVal.Type()))
						default:
							panic(fmt.Errorf("cannot set field Chan to nil"))
						}
					} else {
						fieldVal.Set(valV)
					}
					tmp8 = tmp7
				}
				var v9 any = tmp8
				_ = v9
				// let binding "def"
				tmp10 := new(reflect.SelectCase)
				var v11 any = tmp10
				_ = v11
				// let binding "_"
				// set! host field
				var tmp12 any
				{
					targetV := reflect.ValueOf(v11)
					if targetV.Kind() == reflect.Ptr {
						targetV = targetV.Elem()
					}
					fieldVal := targetV.FieldByName("Dir")
					if !fieldVal.IsValid() {
						panic(fmt.Errorf("no such field Dir"))
					}
					if !fieldVal.CanSet() {
						panic(fmt.Errorf("cannot set field Dir"))
					}
					valV := reflect.ValueOf(reflect.SelectDefault)
					if !valV.IsValid() {
						switch fieldVal.Kind() {
						case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice, reflect.UnsafePointer:
							fieldVal.Set(reflect.Zero(fieldVal.Type()))
						default:
							panic(fmt.Errorf("cannot set field Dir to nil"))
						}
					} else {
						fieldVal.Set(valV)
					}
					tmp12 = reflect.SelectDefault
				}
				var v13 any = tmp12
				_ = v13
				// let binding "vec__1024"
				tmp14 := checkDerefVar(var_clojure_DOT_core_map)
				tmp15 := lang.NewVector(v5, v11)
				tmp16 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(138), kw_column, int(55), kw_end_DASH_line, int(138), kw_end_DASH_column, int(62))
				tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp18 := lang.Apply(tmp14, []any{lang.Builtins["deref"], tmp17})
				tmp19 := lang.Apply(reflect.Select, []any{tmp18})
				var v20 any = tmp19
				_ = v20
				// let binding "chosen"
				tmp21 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp22 := lang.Apply(tmp21, []any{v20, int64(0), nil})
				var v23 any = tmp22
				_ = v23
				// let binding "val"
				tmp24 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp25 := lang.Apply(tmp24, []any{v20, int64(1), nil})
				var v26 any = tmp25
				_ = v26
				// let binding "ok"
				tmp27 := checkDerefVar(var_clojure_DOT_core_nth)
				tmp28 := lang.Apply(tmp27, []any{v20, int64(2), nil})
				var v29 any = tmp28
				_ = v29
				var tmp30 any
				tmp31 := checkDerefVar(var_clojure_DOT_core__EQ_)
				tmp32 := lang.Apply(tmp31, []any{int64(1), v23})
				if lang.IsTruthy(tmp32) {
				} else {
					var tmp33 any
					if lang.IsTruthy(v29) {
						tmp34, ok := lang.FieldOrMethod(v26, "Interface")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v26, "Interface")))
						}
						var tmp35 any
						switch reflect.TypeOf(tmp34).Kind() {
						case reflect.Func:
							tmp35 = lang.Apply(tmp34, nil)
						default:
							tmp35 = tmp34
						}
						tmp36 := lang.NewVector(tmp35, true)
						tmp37 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(140), kw_column, int(14), kw_end_DASH_line, int(140), kw_end_DASH_column, int(36))
						tmp38, err := lang.WithMeta(tmp36, tmp37.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp33 = tmp38
					} else {
						var tmp39 any
						if lang.IsTruthy(kw_else) {
							tmp40 := lang.NewVector(nil, false)
							tmp41 := lang.NewMap(kw_file, "clojure/core/async.glj", kw_line, int(141), kw_column, int(17), kw_end_DASH_line, int(141), kw_end_DASH_column, int(27))
							tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp39 = tmp42
						} else {
						}
						tmp33 = tmp39
					}
					tmp30 = tmp33
				}
				tmp3 = tmp30
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_core_DOT_async_try_DASH_take = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_core_DOT_async_try_DASH_take.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}

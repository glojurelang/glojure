// Code generated by glojure codegen. DO NOT EDIT.

package walk

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	reflect "reflect"
)

func init() {
	runtime.RegisterNSLoader("clojure/walk", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

func checkArityGTE(args []any, min int) {
	if len(args) < min {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "clojure.walk"
func LoadNS() {
	sym_apply := lang.NewSymbol("apply")
	sym_clojure_DOT_core := lang.NewSymbol("clojure.core")
	sym_clojure_DOT_walk := lang.NewSymbol("clojure.walk")
	sym_coll_QMARK_ := lang.NewSymbol("coll?")
	sym_conj := lang.NewSymbol("conj")
	sym_contains_QMARK_ := lang.NewSymbol("contains?")
	sym_doall := lang.NewSymbol("doall")
	sym_empty := lang.NewSymbol("empty")
	sym_f := lang.NewSymbol("f")
	sym_form := lang.NewSymbol("form")
	sym_identity := lang.NewSymbol("identity")
	sym_inner := lang.NewSymbol("inner")
	sym_instance_QMARK_ := lang.NewSymbol("instance?")
	sym_into := lang.NewSymbol("into")
	sym_key := lang.NewSymbol("key")
	sym_keyword := lang.NewSymbol("keyword")
	sym_keyword_QMARK_ := lang.NewSymbol("keyword?")
	sym_keywordize_DASH_keys := lang.NewSymbol("keywordize-keys")
	sym_list := lang.NewSymbol("list")
	sym_list_QMARK_ := lang.NewSymbol("list?")
	sym_m := lang.NewSymbol("m")
	sym_macroexpand := lang.NewSymbol("macroexpand")
	sym_macroexpand_DASH_all := lang.NewSymbol("macroexpand-all")
	sym_map := lang.NewSymbol("map")
	sym_map_QMARK_ := lang.NewSymbol("map?")
	sym_meta := lang.NewSymbol("meta")
	sym_name := lang.NewSymbol("name")
	sym_nth := lang.NewSymbol("nth")
	sym_outer := lang.NewSymbol("outer")
	sym_partial := lang.NewSymbol("partial")
	sym_postwalk := lang.NewSymbol("postwalk")
	sym_postwalk_DASH_demo := lang.NewSymbol("postwalk-demo")
	sym_postwalk_DASH_replace := lang.NewSymbol("postwalk-replace")
	sym_prewalk := lang.NewSymbol("prewalk")
	sym_prewalk_DASH_demo := lang.NewSymbol("prewalk-demo")
	sym_prewalk_DASH_replace := lang.NewSymbol("prewalk-replace")
	sym_print := lang.NewSymbol("print")
	sym_prn := lang.NewSymbol("prn")
	sym_reduce := lang.NewSymbol("reduce")
	sym_seq_QMARK_ := lang.NewSymbol("seq?")
	sym_smap := lang.NewSymbol("smap")
	sym_string_QMARK_ := lang.NewSymbol("string?")
	sym_stringify_DASH_keys := lang.NewSymbol("stringify-keys")
	sym_val := lang.NewSymbol("val")
	sym_walk := lang.NewSymbol("walk")
	sym_with_DASH_meta := lang.NewSymbol("with-meta")
	kw_added := lang.NewKeyword("added")
	kw_arglists := lang.NewKeyword("arglists")
	kw_column := lang.NewKeyword("column")
	kw_doc := lang.NewKeyword("doc")
	kw_else := lang.NewKeyword("else")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_ns := lang.NewKeyword("ns")
	kw_rettag := lang.NewKeyword("rettag")
	// var clojure.core/apply
	var_clojure_DOT_core_apply := lang.InternVarName(sym_clojure_DOT_core, sym_apply)
	// var clojure.core/coll?
	var_clojure_DOT_core_coll_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_coll_QMARK_)
	// var clojure.core/conj
	var_clojure_DOT_core_conj := lang.InternVarName(sym_clojure_DOT_core, sym_conj)
	// var clojure.core/contains?
	var_clojure_DOT_core_contains_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_contains_QMARK_)
	// var clojure.core/doall
	var_clojure_DOT_core_doall := lang.InternVarName(sym_clojure_DOT_core, sym_doall)
	// var clojure.core/empty
	var_clojure_DOT_core_empty := lang.InternVarName(sym_clojure_DOT_core, sym_empty)
	// var clojure.core/identity
	var_clojure_DOT_core_identity := lang.InternVarName(sym_clojure_DOT_core, sym_identity)
	// var clojure.core/instance?
	var_clojure_DOT_core_instance_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_instance_QMARK_)
	// var clojure.core/into
	var_clojure_DOT_core_into := lang.InternVarName(sym_clojure_DOT_core, sym_into)
	// var clojure.core/key
	var_clojure_DOT_core_key := lang.InternVarName(sym_clojure_DOT_core, sym_key)
	// var clojure.core/keyword
	var_clojure_DOT_core_keyword := lang.InternVarName(sym_clojure_DOT_core, sym_keyword)
	// var clojure.core/keyword?
	var_clojure_DOT_core_keyword_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_keyword_QMARK_)
	// var clojure.core/list
	var_clojure_DOT_core_list := lang.InternVarName(sym_clojure_DOT_core, sym_list)
	// var clojure.core/list?
	var_clojure_DOT_core_list_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_list_QMARK_)
	// var clojure.core/macroexpand
	var_clojure_DOT_core_macroexpand := lang.InternVarName(sym_clojure_DOT_core, sym_macroexpand)
	// var clojure.core/map
	var_clojure_DOT_core_map := lang.InternVarName(sym_clojure_DOT_core, sym_map)
	// var clojure.core/map?
	var_clojure_DOT_core_map_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_map_QMARK_)
	// var clojure.core/meta
	var_clojure_DOT_core_meta := lang.InternVarName(sym_clojure_DOT_core, sym_meta)
	// var clojure.core/name
	var_clojure_DOT_core_name := lang.InternVarName(sym_clojure_DOT_core, sym_name)
	// var clojure.core/nth
	var_clojure_DOT_core_nth := lang.InternVarName(sym_clojure_DOT_core, sym_nth)
	// var clojure.core/partial
	var_clojure_DOT_core_partial := lang.InternVarName(sym_clojure_DOT_core, sym_partial)
	// var clojure.core/print
	var_clojure_DOT_core_print := lang.InternVarName(sym_clojure_DOT_core, sym_print)
	// var clojure.core/prn
	var_clojure_DOT_core_prn := lang.InternVarName(sym_clojure_DOT_core, sym_prn)
	// var clojure.core/reduce
	var_clojure_DOT_core_reduce := lang.InternVarName(sym_clojure_DOT_core, sym_reduce)
	// var clojure.core/seq?
	var_clojure_DOT_core_seq_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_seq_QMARK_)
	// var clojure.core/string?
	var_clojure_DOT_core_string_QMARK_ := lang.InternVarName(sym_clojure_DOT_core, sym_string_QMARK_)
	// var clojure.core/val
	var_clojure_DOT_core_val := lang.InternVarName(sym_clojure_DOT_core, sym_val)
	// var clojure.core/with-meta
	var_clojure_DOT_core_with_DASH_meta := lang.InternVarName(sym_clojure_DOT_core, sym_with_DASH_meta)
	// var clojure.walk/keywordize-keys
	var_clojure_DOT_walk_keywordize_DASH_keys := lang.InternVarName(sym_clojure_DOT_walk, sym_keywordize_DASH_keys)
	// var clojure.walk/macroexpand-all
	var_clojure_DOT_walk_macroexpand_DASH_all := lang.InternVarName(sym_clojure_DOT_walk, sym_macroexpand_DASH_all)
	// var clojure.walk/postwalk
	var_clojure_DOT_walk_postwalk := lang.InternVarName(sym_clojure_DOT_walk, sym_postwalk)
	// var clojure.walk/postwalk-demo
	var_clojure_DOT_walk_postwalk_DASH_demo := lang.InternVarName(sym_clojure_DOT_walk, sym_postwalk_DASH_demo)
	// var clojure.walk/postwalk-replace
	var_clojure_DOT_walk_postwalk_DASH_replace := lang.InternVarName(sym_clojure_DOT_walk, sym_postwalk_DASH_replace)
	// var clojure.walk/prewalk
	var_clojure_DOT_walk_prewalk := lang.InternVarName(sym_clojure_DOT_walk, sym_prewalk)
	// var clojure.walk/prewalk-demo
	var_clojure_DOT_walk_prewalk_DASH_demo := lang.InternVarName(sym_clojure_DOT_walk, sym_prewalk_DASH_demo)
	// var clojure.walk/prewalk-replace
	var_clojure_DOT_walk_prewalk_DASH_replace := lang.InternVarName(sym_clojure_DOT_walk, sym_prewalk_DASH_replace)
	// var clojure.walk/stringify-keys
	var_clojure_DOT_walk_stringify_DASH_keys := lang.InternVarName(sym_clojure_DOT_walk, sym_stringify_DASH_keys)
	// var clojure.walk/walk
	var_clojure_DOT_walk_walk := lang.InternVarName(sym_clojure_DOT_walk, sym_walk)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	// reference reflect to avoid unused import error
	_ = reflect.TypeOf
	ns := lang.FindOrCreateNamespace(sym_clojure_DOT_walk)
	_ = ns
	// keywordize-keys
	{
		tmp0 := sym_keywordize_DASH_keys.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m)), kw_doc, "Recursively transforms all map keys from strings to keywords.", kw_file, "clojure/walk.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_walk), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(94), kw_end_DASH_line, int(94))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "f"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "vec__1089"
						var v7 any = v5
						_ = v7
						// let binding "k"
						tmp8 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp9 := lang.Apply(tmp8, []any{v7, int64(0), nil})
						var v10 any = tmp9
						_ = v10
						// let binding "v"
						tmp11 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp12 := lang.Apply(tmp11, []any{v7, int64(1), nil})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						tmp15 := checkDerefVar(var_clojure_DOT_core_string_QMARK_)
						tmp16 := lang.Apply(tmp15, []any{v10})
						if lang.IsTruthy(tmp16) {
							tmp17 := checkDerefVar(var_clojure_DOT_core_keyword)
							tmp18 := lang.Apply(tmp17, []any{v10})
							tmp19 := lang.NewVector(tmp18, v13)
							tmp20 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(98), kw_column, int(39), kw_end_DASH_line, int(98), kw_end_DASH_column, int(53))
							tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp14 = tmp21
						} else {
							tmp22 := lang.NewVector(v10, v13)
							tmp23 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(98), kw_column, int(55), kw_end_DASH_line, int(98), kw_end_DASH_column, int(59))
							tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp14 = tmp24
						}
						tmp6 = tmp14
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(98), kw_column, int(11), kw_end_DASH_line, int(98), kw_end_DASH_column, int(61))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(var_clojure_DOT_walk_postwalk)
				var tmp9 lang.FnFunc
				tmp9 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v10 := args[0]
					_ = v10
					var tmp11 any
					tmp12 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
					tmp13 := lang.Apply(tmp12, []any{v10})
					if lang.IsTruthy(tmp13) {
						tmp14 := checkDerefVar(var_clojure_DOT_core_into)
						tmp15 := lang.NewMap()
						tmp16 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(100), kw_column, int(42), kw_end_DASH_line, int(100), kw_end_DASH_column, int(43))
						tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp18 := checkDerefVar(var_clojure_DOT_core_map)
						tmp19 := lang.Apply(tmp18, []any{v7, v10})
						tmp20 := lang.Apply(tmp14, []any{tmp17, tmp19})
						tmp11 = tmp20
					} else {
						tmp11 = v10
					}
					return tmp11
				})
				tmp10 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(100), kw_column, int(15), kw_end_DASH_line, int(100), kw_end_DASH_column, int(58))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := lang.Apply(tmp8, []any{tmp11, v2})
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_walk_keywordize_DASH_keys = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_walk_keywordize_DASH_keys.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// macroexpand-all
	{
		tmp0 := sym_macroexpand_DASH_all.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_form)), kw_doc, "Recursively performs all possible macroexpansions in form.", kw_file, "clojure/walk.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_walk), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(126), kw_end_DASH_line, int(126))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_walk_prewalk)
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v5 := args[0]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_clojure_DOT_core_seq_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v5})
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(var_clojure_DOT_core_macroexpand)
					tmp10 := lang.Apply(tmp9, []any{v5})
					tmp6 = tmp10
				} else {
					tmp6 = v5
				}
				return tmp6
			})
			tmp5 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(130), kw_column, int(12), kw_end_DASH_line, int(130), kw_end_DASH_column, int(51))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp7 := lang.Apply(tmp3, []any{tmp6, v2})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_walk_macroexpand_DASH_all = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_walk_macroexpand_DASH_all.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// postwalk
	{
		tmp0 := sym_postwalk.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_form)), kw_doc, "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", kw_file, "clojure/walk.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_walk), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(53), kw_end_DASH_line, int(53))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_walk_walk)
			tmp5 := checkDerefVar(var_clojure_DOT_core_partial)
			tmp6 := checkDerefVar(var_clojure_DOT_walk_postwalk)
			tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
			tmp8 := lang.Apply(tmp4, []any{tmp7, v2, v3})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_walk_postwalk = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_walk_postwalk.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// postwalk-demo
	{
		tmp0 := sym_postwalk_DASH_demo.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_form)), kw_doc, "Demonstrates the behavior of postwalk by printing each form as it is\n  walked.  Returns form.", kw_file, "clojure/walk.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_walk), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(80), kw_end_DASH_line, int(80))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_walk_postwalk)
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v5 := args[0]
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_print)
				tmp7 := lang.Apply(tmp6, []any{"Walked: "})
				_ = tmp7
				tmp8 := checkDerefVar(var_clojure_DOT_core_prn)
				tmp9 := lang.Apply(tmp8, []any{v5})
				_ = tmp9
				return v5
			})
			tmp5 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(85), kw_column, int(13), kw_end_DASH_line, int(85), kw_end_DASH_column, int(49))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp7 := lang.Apply(tmp3, []any{tmp6, v2})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_walk_postwalk_DASH_demo = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_walk_postwalk_DASH_demo.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// postwalk-replace
	{
		tmp0 := sym_postwalk_DASH_replace.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_smap, sym_form)), kw_doc, "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", kw_file, "clojure/walk.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_walk), kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(118), kw_end_DASH_line, int(118))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_walk_postwalk)
			var tmp5 lang.FnFunc
			tmp5 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v6 := args[0]
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_contains_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v2, v6})
				if lang.IsTruthy(tmp9) {
					tmp10 := lang.Apply(v2, []any{v6})
					tmp7 = tmp10
				} else {
					tmp7 = v6
				}
				return tmp7
			})
			tmp6 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(124), kw_column, int(13), kw_end_DASH_line, int(124), kw_end_DASH_column, int(55))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp8 := lang.Apply(tmp4, []any{tmp7, v3})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_walk_postwalk_DASH_replace = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_walk_postwalk_DASH_replace.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prewalk
	{
		tmp0 := sym_prewalk.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_form)), kw_doc, "Like postwalk, but does pre-order traversal.", kw_file, "clojure/walk.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_walk), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(61), kw_end_DASH_line, int(61))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_walk_walk)
			tmp5 := checkDerefVar(var_clojure_DOT_core_partial)
			tmp6 := checkDerefVar(var_clojure_DOT_walk_prewalk)
			tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
			tmp8 := checkDerefVar(var_clojure_DOT_core_identity)
			tmp9 := lang.Apply(v2, []any{v3})
			tmp10 := lang.Apply(tmp4, []any{tmp7, tmp8, tmp9})
			return tmp10
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_walk_prewalk = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_walk_prewalk.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prewalk-demo
	{
		tmp0 := sym_prewalk_DASH_demo.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_form)), kw_doc, "Demonstrates the behavior of prewalk by printing each form as it is\n  walked.  Returns form.", kw_file, "clojure/walk.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_walk), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(87), kw_end_DASH_line, int(87))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			tmp3 := checkDerefVar(var_clojure_DOT_walk_prewalk)
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v5 := args[0]
				_ = v5
				tmp6 := checkDerefVar(var_clojure_DOT_core_print)
				tmp7 := lang.Apply(tmp6, []any{"Walked: "})
				_ = tmp7
				tmp8 := checkDerefVar(var_clojure_DOT_core_prn)
				tmp9 := lang.Apply(tmp8, []any{v5})
				_ = tmp9
				return v5
			})
			tmp5 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(92), kw_column, int(12), kw_end_DASH_line, int(92), kw_end_DASH_column, int(48))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp7 := lang.Apply(tmp3, []any{tmp6, v2})
			return tmp7
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_walk_prewalk_DASH_demo = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_walk_prewalk_DASH_demo.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prewalk-replace
	{
		tmp0 := sym_prewalk_DASH_replace.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_smap, sym_form)), kw_doc, "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", kw_file, "clojure/walk.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_walk), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(110), kw_end_DASH_line, int(110))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			tmp4 := checkDerefVar(var_clojure_DOT_walk_prewalk)
			var tmp5 lang.FnFunc
			tmp5 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v6 := args[0]
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_clojure_DOT_core_contains_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v2, v6})
				if lang.IsTruthy(tmp9) {
					tmp10 := lang.Apply(v2, []any{v6})
					tmp7 = tmp10
				} else {
					tmp7 = v6
				}
				return tmp7
			})
			tmp6 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(116), kw_column, int(12), kw_end_DASH_line, int(116), kw_end_DASH_column, int(54))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp8 := lang.Apply(tmp4, []any{tmp7, v3})
			return tmp8
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_walk_prewalk_DASH_replace = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_walk_prewalk_DASH_replace.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stringify-keys
	{
		tmp0 := sym_stringify_DASH_keys.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m)), kw_doc, "Recursively transforms all map keys from keywords to strings.", kw_file, "clojure/walk.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_walk), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(102), kw_end_DASH_line, int(102))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v2 := args[0]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "f"
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "vec__1093"
						var v7 any = v5
						_ = v7
						// let binding "k"
						tmp8 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp9 := lang.Apply(tmp8, []any{v7, int64(0), nil})
						var v10 any = tmp9
						_ = v10
						// let binding "v"
						tmp11 := checkDerefVar(var_clojure_DOT_core_nth)
						tmp12 := lang.Apply(tmp11, []any{v7, int64(1), nil})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						tmp15 := checkDerefVar(var_clojure_DOT_core_keyword_QMARK_)
						tmp16 := lang.Apply(tmp15, []any{v10})
						if lang.IsTruthy(tmp16) {
							tmp17 := checkDerefVar(var_clojure_DOT_core_name)
							tmp18 := lang.Apply(tmp17, []any{v10})
							tmp19 := lang.NewVector(tmp18, v13)
							tmp20 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(106), kw_column, int(40), kw_end_DASH_line, int(106), kw_end_DASH_column, int(51))
							tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp14 = tmp21
						} else {
							tmp22 := lang.NewVector(v10, v13)
							tmp23 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(106), kw_column, int(53), kw_end_DASH_line, int(106), kw_end_DASH_column, int(57))
							tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp14 = tmp24
						}
						tmp6 = tmp14
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(106), kw_column, int(11), kw_end_DASH_line, int(106), kw_end_DASH_column, int(59))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(var_clojure_DOT_walk_postwalk)
				var tmp9 lang.FnFunc
				tmp9 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v10 := args[0]
					_ = v10
					var tmp11 any
					tmp12 := checkDerefVar(var_clojure_DOT_core_map_QMARK_)
					tmp13 := lang.Apply(tmp12, []any{v10})
					if lang.IsTruthy(tmp13) {
						tmp14 := checkDerefVar(var_clojure_DOT_core_into)
						tmp15 := lang.NewMap()
						tmp16 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(108), kw_column, int(42), kw_end_DASH_line, int(108), kw_end_DASH_column, int(43))
						tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp18 := checkDerefVar(var_clojure_DOT_core_map)
						tmp19 := lang.Apply(tmp18, []any{v7, v10})
						tmp20 := lang.Apply(tmp14, []any{tmp17, tmp19})
						tmp11 = tmp20
					} else {
						tmp11 = v10
					}
					return tmp11
				})
				tmp10 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(108), kw_column, int(15), kw_end_DASH_line, int(108), kw_end_DASH_column, int(58))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := lang.Apply(tmp8, []any{tmp11, v2})
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_walk_stringify_DASH_keys = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_walk_stringify_DASH_keys.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// walk
	{
		tmp0 := sym_walk.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_inner, sym_outer, sym_form)), kw_doc, "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", kw_file, "clojure/walk.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_clojure_DOT_walk), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(35), kw_end_DASH_line, int(35))).(*lang.Symbol)
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v2 := args[0]
			_ = v2
			v3 := args[1]
			_ = v3
			v4 := args[2]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_clojure_DOT_core_list_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_clojure_DOT_core_with_DASH_meta)
				tmp9 := checkDerefVar(var_clojure_DOT_core_apply)
				tmp10 := checkDerefVar(var_clojure_DOT_core_list)
				tmp11 := checkDerefVar(var_clojure_DOT_core_map)
				tmp12 := lang.Apply(tmp11, []any{v2, v4})
				tmp13 := lang.Apply(tmp9, []any{tmp10, tmp12})
				tmp14 := checkDerefVar(var_clojure_DOT_core_meta)
				tmp15 := lang.Apply(tmp14, []any{v4})
				tmp16 := lang.Apply(tmp8, []any{tmp13, tmp15})
				tmp17 := lang.Apply(v3, []any{tmp16})
				tmp5 = tmp17
			} else {
				var tmp18 any
				tmp19 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
				tmp20 := reflect.TypeOf((*lang.IMapEntry)(nil)).Elem()
				tmp21 := lang.Apply(tmp19, []any{tmp20, v4})
				if lang.IsTruthy(tmp21) {
					tmp22 := checkDerefVar(var_clojure_DOT_core_key)
					tmp23 := lang.Apply(tmp22, []any{v4})
					tmp24 := lang.Apply(v2, []any{tmp23})
					tmp25 := checkDerefVar(var_clojure_DOT_core_val)
					tmp26 := lang.Apply(tmp25, []any{v4})
					tmp27 := lang.Apply(v2, []any{tmp26})
					tmp28 := lang.Apply(nil, []any{tmp24, tmp27})
					tmp29 := lang.Apply(v3, []any{tmp28})
					tmp18 = tmp29
				} else {
					var tmp30 any
					tmp31 := checkDerefVar(var_clojure_DOT_core_seq_QMARK_)
					tmp32 := lang.Apply(tmp31, []any{v4})
					if lang.IsTruthy(tmp32) {
						tmp33 := checkDerefVar(var_clojure_DOT_core_with_DASH_meta)
						tmp34 := checkDerefVar(var_clojure_DOT_core_doall)
						tmp35 := checkDerefVar(var_clojure_DOT_core_map)
						tmp36 := lang.Apply(tmp35, []any{v2, v4})
						tmp37 := lang.Apply(tmp34, []any{tmp36})
						tmp38 := checkDerefVar(var_clojure_DOT_core_meta)
						tmp39 := lang.Apply(tmp38, []any{v4})
						tmp40 := lang.Apply(tmp33, []any{tmp37, tmp39})
						tmp41 := lang.Apply(v3, []any{tmp40})
						tmp30 = tmp41
					} else {
						var tmp42 any
						tmp43 := checkDerefVar(var_clojure_DOT_core_instance_QMARK_)
						tmp44 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
						tmp45 := lang.Apply(tmp43, []any{tmp44, v4})
						if lang.IsTruthy(tmp45) {
							tmp46 := checkDerefVar(var_clojure_DOT_core_reduce)
							var tmp47 lang.FnFunc
							tmp47 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v48 := args[0]
								_ = v48
								v49 := args[1]
								_ = v49
								tmp50 := checkDerefVar(var_clojure_DOT_core_conj)
								tmp51 := lang.Apply(v2, []any{v49})
								tmp52 := lang.Apply(tmp50, []any{v48, tmp51})
								return tmp52
							})
							tmp48 := lang.NewMap(kw_file, "clojure/walk.glj", kw_line, int(49), kw_column, int(21), kw_end_DASH_line, int(49), kw_end_DASH_column, int(49))
							tmp49, err := lang.WithMeta(tmp47, tmp48.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp50 := lang.Apply(tmp46, []any{tmp49, v4, v4})
							tmp51 := lang.Apply(v3, []any{tmp50})
							tmp42 = tmp51
						} else {
							var tmp52 any
							tmp53 := checkDerefVar(var_clojure_DOT_core_coll_QMARK_)
							tmp54 := lang.Apply(tmp53, []any{v4})
							if lang.IsTruthy(tmp54) {
								tmp55 := checkDerefVar(var_clojure_DOT_core_into)
								tmp56 := checkDerefVar(var_clojure_DOT_core_empty)
								tmp57 := lang.Apply(tmp56, []any{v4})
								tmp58 := checkDerefVar(var_clojure_DOT_core_map)
								tmp59 := lang.Apply(tmp58, []any{v2, v4})
								tmp60 := lang.Apply(tmp55, []any{tmp57, tmp59})
								tmp61 := lang.Apply(v3, []any{tmp60})
								tmp52 = tmp61
							} else {
								var tmp62 any
								if lang.IsTruthy(kw_else) {
									tmp63 := lang.Apply(v3, []any{v4})
									tmp62 = tmp63
								} else {
								}
								tmp52 = tmp62
							}
							tmp42 = tmp52
						}
						tmp30 = tmp42
					}
					tmp18 = tmp30
				}
				tmp5 = tmp18
			}
			return tmp5
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		var_clojure_DOT_walk_walk = ns.InternWithValue(tmp0, tmp1, true)
		if tmp0.Meta() != nil {
			var_clojure_DOT_walk_walk.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}

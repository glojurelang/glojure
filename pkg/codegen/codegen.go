package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"strings"

	"github.com/glojurelang/glojure/pkg/ast"
	"github.com/glojurelang/glojure/pkg/lang"
)

// Generator handles the conversion of AST nodes to Go code
type Generator struct {
	originalWriter io.Writer
	w              io.Writer
	indent         int
}

// New creates a new code generator
func New(w io.Writer) *Generator {
	return &Generator{originalWriter: w, w: w}
}

// Generate takes analyzed AST nodes and generates Go code
func (g *Generator) Generate(nodes []*ast.Node) error {
	// Generate to a buffer first so we can format
	var buf bytes.Buffer
	g.w = &buf

	// Write package header
	if err := g.writeHeader(); err != nil {
		return err
	}

	// Generate code for each top-level form
	for i, node := range nodes {
		if err := g.generateTopLevel(node, i); err != nil {
			return fmt.Errorf("error generating form %d: %w", i, err)
		}

		// Add newline between functions, but not after the last one
		if i < len(nodes)-1 {
			if _, err := io.WriteString(g.w, "\n"); err != nil {
				return err
			}
		}
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, write the unformatted code with the error
		return fmt.Errorf("formatting failed: %w\n\nGenerated code:\n%s", err, buf.String())
	}

	// Write formatted code to the original writer
	_, err = g.originalWriter.Write(formatted)
	return err
}

func (g *Generator) writeHeader() error {
	header := `// Code generated by glojure codegen. DO NOT EDIT.

package generated

import (
  "github.com/glojurelang/glojure/pkg/lang"
)

`
	_, err := io.WriteString(g.w, header)
	return err
}

func (g *Generator) generateTopLevel(node *ast.Node, index int) error {
	// Generate a function for each top-level form
	funcName := fmt.Sprintf("Form_%d", index)

	if err := g.writef("// %s\n", formatForm(node.Form)); err != nil {
		return err
	}

	if err := g.writef("func %s() interface{} {\n", funcName); err != nil {
		return err
	}

	g.indent++

	// Generate the actual code
	if err := g.generateNode(node); err != nil {
		return err
	}

	g.indent--

	if err := g.writef("}\n"); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateNode(node *ast.Node) error {
	switch node.Op {
	case ast.OpConst:
		return g.generateConst(node)
	default:
		// For now, generate a placeholder for unsupported nodes
		return g.writef("return nil // TODO: OpCode %d\n", node.Op)
	}
}

func (g *Generator) generateConst(node *ast.Node) error {
	constNode := node.Sub.(*ast.ConstNode)
	val := constNode.Value

	switch v := val.(type) {
	case int64:
		return g.writef("return int64(%d)\n", v)
	case float64:
		return g.writef("return float64(%f)\n", v)
	case string:
		return g.writef("return %q\n", v)
	case bool:
		return g.writef("return %t\n", v)
	case nil:
		return g.writef("return nil\n")
	case *lang.Keyword:
		return g.writef("return lang.NewKeyword(%q)\n", v.Name())
	case lang.Keyword:
		// Handle non-pointer keyword type
		return g.writef("return lang.NewKeyword(%q)\n", v.Name())
	default:
		// Placeholder for other constant types
		return g.writef("return nil // TODO: const type %T\n", v)
	}
}

////////////////////////////////////////////////////////////////////////////////

func (g *Generator) writef(format string, args ...interface{}) error {
	// Handle indentation
	if g.indent > 0 && len(format) > 0 && format[0] != '\n' {
		if _, err := io.WriteString(g.w, strings.Repeat("\t", g.indent)); err != nil {
			return err
		}
	}

	_, err := fmt.Fprintf(g.w, format, args...)
	return err
}

// formatForm returns a string representation of a form for comments
func formatForm(form interface{}) string {
	// Simple string representation for now
	return fmt.Sprintf("%v", form)
}

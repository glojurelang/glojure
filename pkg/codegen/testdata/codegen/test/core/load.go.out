// Code generated by glojure codegen. DO NOT EDIT.

package core

import (
	errors8 "errors"
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime7 "github.com/glojurelang/glojure/pkg/runtime"
	uuid13 "github.com/google/uuid"
	io3 "io"
	math6 "math"
	big9 "math/big"
	rand16 "math/rand"
	http17 "net/http"
	url4 "net/url"
	os5 "os"
	reflect "reflect"
	regexp15 "regexp"
	runtime14 "runtime"
	strconv12 "strconv"
	strings11 "strings"
	time10 "time"
)

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

// LoadNS initializes the namespace "glojure.core"
func LoadNS() {
	// var glojure.core.protocols/coll-reduce
	glojure_DOT_core_DOT_protocols_coll_reduce := lang.InternVarName(lang.NewSymbol("glojure.core.protocols"), lang.NewSymbol("coll-reduce"))
	// var glojure.core.protocols/interface-or-naive-reduce
	glojure_DOT_core_DOT_protocols_interface_or_naive_reduce := lang.InternVarName(lang.NewSymbol("glojure.core.protocols"), lang.NewSymbol("interface-or-naive-reduce"))
	// var glojure.core.protocols/kv-reduce
	glojure_DOT_core_DOT_protocols_kv_reduce := lang.InternVarName(lang.NewSymbol("glojure.core.protocols"), lang.NewSymbol("kv-reduce"))
	// var glojure.core.protocols/seq-reduce
	glojure_DOT_core_DOT_protocols_seq_reduce := lang.InternVarName(lang.NewSymbol("glojure.core.protocols"), lang.NewSymbol("seq-reduce"))
	// var glojure.core/StackTraceElement->vec
	glojure_DOT_core_StackTraceElement__GT_vec := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("StackTraceElement->vec"))
	// var glojure.core/Throwable->map
	glojure_DOT_core_Throwable__GT_map := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("Throwable->map"))
	// var glojure.core/-
	glojure_DOT_core__ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("-"))
	// var glojure.core/=
	glojure_DOT_core__EQ_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("="))
	// var glojure.core/==
	glojure_DOT_core__EQ__EQ_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("=="))
	// var glojure.core/>
	glojure_DOT_core__GT_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol(">"))
	// var glojure.core/>=
	glojure_DOT_core__GT__EQ_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol(">="))
	// var glojure.core/<
	glojure_DOT_core__LT_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("<"))
	// var glojure.core/<=
	glojure_DOT_core__LT__EQ_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("<="))
	// var glojure.core/+
	glojure_DOT_core__PLUS_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("+"))
	// var glojure.core/+'
	glojure_DOT_core__PLUS__U0027_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("+'"))
	// var glojure.core//
	glojure_DOT_core__SLASH_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("/"))
	// var glojure.core/*
	glojure_DOT_core__STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*"))
	// var glojure.core/*'
	glojure_DOT_core__STAR__U0027_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*'"))
	// var glojure.core/*agent*
	glojure_DOT_core__STAR_agent_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*agent*"))
	// var glojure.core/*assert*
	glojure_DOT_core__STAR_assert_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*assert*"))
	// var glojure.core/*file*
	glojure_DOT_core__STAR_file_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*file*"))
	// var glojure.core/*flush-on-newline*
	glojure_DOT_core__STAR_flush_on_newline_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*flush-on-newline*"))
	// var glojure.core/*in*
	glojure_DOT_core__STAR_in_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*in*"))
	// var glojure.core/*loaded-libs*
	glojure_DOT_core__STAR_loaded_libs_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*loaded-libs*"))
	// var glojure.core/*loading-verbosely*
	glojure_DOT_core__STAR_loading_verbosely_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*loading-verbosely*"))
	// var glojure.core/*ns*
	glojure_DOT_core__STAR_ns_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*ns*"))
	// var glojure.core/*out*
	glojure_DOT_core__STAR_out_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*out*"))
	// var glojure.core/*pending-paths*
	glojure_DOT_core__STAR_pending_paths_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*pending-paths*"))
	// var glojure.core/*print-dup*
	glojure_DOT_core__STAR_print_dup_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-dup*"))
	// var glojure.core/*print-length*
	glojure_DOT_core__STAR_print_length_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-length*"))
	// var glojure.core/*print-level*
	glojure_DOT_core__STAR_print_level_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-level*"))
	// var glojure.core/*print-meta*
	glojure_DOT_core__STAR_print_meta_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-meta*"))
	// var glojure.core/*print-namespace-maps*
	glojure_DOT_core__STAR_print_namespace_maps_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-namespace-maps*"))
	// var glojure.core/*print-readably*
	glojure_DOT_core__STAR_print_readably_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-readably*"))
	// var glojure.core/*unchecked-math*
	glojure_DOT_core__STAR_unchecked_math_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*unchecked-math*"))
	// var glojure.core/*verbose-defrecords*
	glojure_DOT_core__STAR_verbose_defrecords_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*verbose-defrecords*"))
	// var glojure.core/-'
	glojure_DOT_core___U0027_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("-'"))
	// var glojure.core/agent
	glojure_DOT_core_agent := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("agent"))
	// var glojure.core/agent-error
	glojure_DOT_core_agent_error := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("agent-error"))
	// var glojure.core/aget
	glojure_DOT_core_aget := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("aget"))
	// var glojure.core/alength
	glojure_DOT_core_alength := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("alength"))
	// var glojure.core/alias
	glojure_DOT_core_alias := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("alias"))
	// var glojure.core/alter-var-root
	glojure_DOT_core_alter_var_root := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("alter-var-root"))
	// var glojure.core/ancestors
	glojure_DOT_core_ancestors := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ancestors"))
	// var glojure.core/apply
	glojure_DOT_core_apply := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("apply"))
	// var glojure.core/aset
	glojure_DOT_core_aset := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("aset"))
	// var glojure.core/aset-boolean
	glojure_DOT_core_aset_boolean := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("aset-boolean"))
	// var glojure.core/aset-byte
	glojure_DOT_core_aset_byte := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("aset-byte"))
	// var glojure.core/aset-char
	glojure_DOT_core_aset_char := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("aset-char"))
	// var glojure.core/aset-double
	glojure_DOT_core_aset_double := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("aset-double"))
	// var glojure.core/aset-float
	glojure_DOT_core_aset_float := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("aset-float"))
	// var glojure.core/aset-int
	glojure_DOT_core_aset_int := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("aset-int"))
	// var glojure.core/aset-long
	glojure_DOT_core_aset_long := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("aset-long"))
	// var glojure.core/aset-short
	glojure_DOT_core_aset_short := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("aset-short"))
	// var glojure.core/assert-valid-fdecl
	glojure_DOT_core_assert_valid_fdecl := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("assert-valid-fdecl"))
	// var glojure.core/assoc
	glojure_DOT_core_assoc := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("assoc"))
	// var glojure.core/assoc!
	glojure_DOT_core_assoc_BANG_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("assoc!"))
	// var glojure.core/assoc-in
	glojure_DOT_core_assoc_in := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("assoc-in"))
	// var glojure.core/atom
	glojure_DOT_core_atom := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("atom"))
	// var glojure.core/await
	glojure_DOT_core_await := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("await"))
	// var glojure.core/bases
	glojure_DOT_core_bases := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("bases"))
	// var glojure.core/bigint
	glojure_DOT_core_bigint := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("bigint"))
	// var glojure.core/binding-conveyor-fn
	glojure_DOT_core_binding_conveyor_fn := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("binding-conveyor-fn"))
	// var glojure.core/bit-and
	glojure_DOT_core_bit_and := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("bit-and"))
	// var glojure.core/bit-and-not
	glojure_DOT_core_bit_and_not := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("bit-and-not"))
	// var glojure.core/bit-or
	glojure_DOT_core_bit_or := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("bit-or"))
	// var glojure.core/bit-shift-left
	glojure_DOT_core_bit_shift_left := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("bit-shift-left"))
	// var glojure.core/bit-shift-right
	glojure_DOT_core_bit_shift_right := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("bit-shift-right"))
	// var glojure.core/bit-xor
	glojure_DOT_core_bit_xor := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("bit-xor"))
	// var glojure.core/boolean
	glojure_DOT_core_boolean := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("boolean"))
	// var glojure.core/butlast
	glojure_DOT_core_butlast := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("butlast"))
	// var glojure.core/byte
	glojure_DOT_core_byte := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("byte"))
	// var glojure.core/case-map
	glojure_DOT_core_case_map := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("case-map"))
	// var glojure.core/cat
	glojure_DOT_core_cat := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("cat"))
	// var glojure.core/char
	glojure_DOT_core_char := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("char"))
	// var glojure.core/char-escape-string
	glojure_DOT_core_char_escape_string := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("char-escape-string"))
	// var glojure.core/char-name-string
	glojure_DOT_core_char_name_string := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("char-name-string"))
	// var glojure.core/check-cyclic-dependency
	glojure_DOT_core_check_cyclic_dependency := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("check-cyclic-dependency"))
	// var glojure.core/check-valid-options
	glojure_DOT_core_check_valid_options := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("check-valid-options"))
	// var glojure.core/chunk
	glojure_DOT_core_chunk := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("chunk"))
	// var glojure.core/chunk-append
	glojure_DOT_core_chunk_append := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("chunk-append"))
	// var glojure.core/chunk-buffer
	glojure_DOT_core_chunk_buffer := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("chunk-buffer"))
	// var glojure.core/chunk-cons
	glojure_DOT_core_chunk_cons := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("chunk-cons"))
	// var glojure.core/chunk-first
	glojure_DOT_core_chunk_first := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("chunk-first"))
	// var glojure.core/chunk-next
	glojure_DOT_core_chunk_next := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("chunk-next"))
	// var glojure.core/chunk-rest
	glojure_DOT_core_chunk_rest := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("chunk-rest"))
	// var glojure.core/chunked-seq?
	glojure_DOT_core_chunked_seq_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("chunked-seq?"))
	// var glojure.core/class
	glojure_DOT_core_class := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("class"))
	// var glojure.core/class?
	glojure_DOT_core_class_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("class?"))
	// var glojure.core/commute
	glojure_DOT_core_commute := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("commute"))
	// var glojure.core/comp
	glojure_DOT_core_comp := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("comp"))
	// var glojure.core/compare
	glojure_DOT_core_compare := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("compare"))
	// var glojure.core/compare-and-set!
	glojure_DOT_core_compare_and_set_BANG_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("compare-and-set!"))
	// var glojure.core/complement
	glojure_DOT_core_complement := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("complement"))
	// var glojure.core/completing
	glojure_DOT_core_completing := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("completing"))
	// var glojure.core/concat
	glojure_DOT_core_concat := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("concat"))
	// var glojure.core/conj
	glojure_DOT_core_conj := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("conj"))
	// var glojure.core/conj!
	glojure_DOT_core_conj_BANG_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("conj!"))
	// var glojure.core/cons
	glojure_DOT_core_cons := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("cons"))
	// var glojure.core/contains?
	glojure_DOT_core_contains_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("contains?"))
	// var glojure.core/count
	glojure_DOT_core_count := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("count"))
	// var glojure.core/counted?
	glojure_DOT_core_counted_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("counted?"))
	// var glojure.core/create-ns
	glojure_DOT_core_create_ns := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("create-ns"))
	// var glojure.core/create-struct
	glojure_DOT_core_create_struct := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("create-struct"))
	// var glojure.core/data-reader-urls
	glojure_DOT_core_data_reader_urls := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("data-reader-urls"))
	// var glojure.core/data-reader-var
	glojure_DOT_core_data_reader_var := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("data-reader-var"))
	// var glojure.core/dec
	glojure_DOT_core_dec := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("dec"))
	// var glojure.core/decimal?
	glojure_DOT_core_decimal_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("decimal?"))
	// var glojure.core/dedupe
	glojure_DOT_core_dedupe := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("dedupe"))
	// var glojure.core/deref
	glojure_DOT_core_deref := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("deref"))
	// var glojure.core/deref-as-map
	glojure_DOT_core_deref_as_map := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("deref-as-map"))
	// var glojure.core/deref-future
	glojure_DOT_core_deref_future := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("deref-future"))
	// var glojure.core/derive
	glojure_DOT_core_derive := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("derive"))
	// var glojure.core/descendants
	glojure_DOT_core_descendants := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("descendants"))
	// var glojure.core/destructure
	glojure_DOT_core_destructure := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("destructure"))
	// var glojure.core/disj
	glojure_DOT_core_disj := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("disj"))
	// var glojure.core/dissoc
	glojure_DOT_core_dissoc := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("dissoc"))
	// var glojure.core/distinct?
	glojure_DOT_core_distinct_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("distinct?"))
	// var glojure.core/doall
	glojure_DOT_core_doall := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("doall"))
	// var glojure.core/dorun
	glojure_DOT_core_dorun := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("dorun"))
	// var glojure.core/double
	glojure_DOT_core_double := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("double"))
	// var glojure.core/drop
	glojure_DOT_core_drop := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("drop"))
	// var glojure.core/drop-last
	glojure_DOT_core_drop_last := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("drop-last"))
	// var glojure.core/drop-while
	glojure_DOT_core_drop_while := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("drop-while"))
	// var glojure.core/elide-top-frames
	glojure_DOT_core_elide_top_frames := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("elide-top-frames"))
	// var glojure.core/emit-extend-protocol
	glojure_DOT_core_emit_extend_protocol := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("emit-extend-protocol"))
	// var glojure.core/emit-extend-type
	glojure_DOT_core_emit_extend_type := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("emit-extend-type"))
	// var glojure.core/emit-hinted-impl
	glojure_DOT_core_emit_hinted_impl := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("emit-hinted-impl"))
	// var glojure.core/empty?
	glojure_DOT_core_empty_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("empty?"))
	// var glojure.core/ensure-reduced
	glojure_DOT_core_ensure_reduced := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ensure-reduced"))
	// var glojure.core/eval
	glojure_DOT_core_eval := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("eval"))
	// var glojure.core/even?
	glojure_DOT_core_even_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("even?"))
	// var glojure.core/every?
	glojure_DOT_core_every_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("every?"))
	// var glojure.core/ex-data
	glojure_DOT_core_ex_data := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ex-data"))
	// var glojure.core/ex-info
	glojure_DOT_core_ex_info := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ex-info"))
	// var glojure.core/ffirst
	glojure_DOT_core_ffirst := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ffirst"))
	// var glojure.core/filter
	glojure_DOT_core_filter := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("filter"))
	// var glojure.core/filter-key
	glojure_DOT_core_filter_key := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("filter-key"))
	// var glojure.core/find
	glojure_DOT_core_find := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("find"))
	// var glojure.core/find-ns
	glojure_DOT_core_find_ns := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("find-ns"))
	// var glojure.core/first
	glojure_DOT_core_first := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("first"))
	// var glojure.core/fits-table?
	glojure_DOT_core_fits_table_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("fits-table?"))
	// var glojure.core/flatten
	glojure_DOT_core_flatten := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("flatten"))
	// var glojure.core/float
	glojure_DOT_core_float := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("float"))
	// var glojure.core/float?
	glojure_DOT_core_float_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("float?"))
	// var glojure.core/flush
	glojure_DOT_core_flush := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("flush"))
	// var glojure.core/fn?
	glojure_DOT_core_fn_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("fn?"))
	// var glojure.core/fnil
	glojure_DOT_core_fnil := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("fnil"))
	// var glojure.core/format
	glojure_DOT_core_format := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("format"))
	// var glojure.core/future-call
	glojure_DOT_core_future_call := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("future-call"))
	// var glojure.core/gensym
	glojure_DOT_core_gensym := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("gensym"))
	// var glojure.core/get
	glojure_DOT_core_get := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("get"))
	// var glojure.core/get-in
	glojure_DOT_core_get_in := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("get-in"))
	// var glojure.core/get-thread-bindings
	glojure_DOT_core_get_thread_bindings := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("get-thread-bindings"))
	// var glojure.core/global-hierarchy
	glojure_DOT_core_global_hierarchy := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("global-hierarchy"))
	// var glojure.core/halt-when
	glojure_DOT_core_halt_when := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("halt-when"))
	// var glojure.core/hash-map
	glojure_DOT_core_hash_map := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("hash-map"))
	// var glojure.core/hash-set
	glojure_DOT_core_hash_set := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("hash-set"))
	// var glojure.core/ident?
	glojure_DOT_core_ident_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ident?"))
	// var glojure.core/identical?
	glojure_DOT_core_identical_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("identical?"))
	// var glojure.core/identity
	glojure_DOT_core_identity := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("identity"))
	// var glojure.core/inc
	glojure_DOT_core_inc := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("inc"))
	// var glojure.core/inc'
	glojure_DOT_core_inc_U0027_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("inc'"))
	// var glojure.core/instance?
	glojure_DOT_core_instance_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("instance?"))
	// var glojure.core/int
	glojure_DOT_core_int := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("int"))
	// var glojure.core/int?
	glojure_DOT_core_int_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("int?"))
	// var glojure.core/integer?
	glojure_DOT_core_integer_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("integer?"))
	// var glojure.core/interleave
	glojure_DOT_core_interleave := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("interleave"))
	// var glojure.core/intern
	glojure_DOT_core_intern := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("intern"))
	// var glojure.core/interpose
	glojure_DOT_core_interpose := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("interpose"))
	// var glojure.core/into
	glojure_DOT_core_into := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("into"))
	// var glojure.core/into1
	glojure_DOT_core_into1 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("into1"))
	// var glojure.core/into-array
	glojure_DOT_core_into_array := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("into-array"))
	// var glojure.core/isa?
	glojure_DOT_core_isa_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("isa?"))
	// var glojure.core/iterate
	glojure_DOT_core_iterate := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("iterate"))
	// var glojure.core/iterator-seq
	glojure_DOT_core_iterator_seq := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("iterator-seq"))
	// var glojure.core/keep
	glojure_DOT_core_keep := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("keep"))
	// var glojure.core/key
	glojure_DOT_core_key := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("key"))
	// var glojure.core/keys
	glojure_DOT_core_keys := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("keys"))
	// var glojure.core/keyword
	glojure_DOT_core_keyword := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("keyword"))
	// var glojure.core/keyword?
	glojure_DOT_core_keyword_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("keyword?"))
	// var glojure.core/last
	glojure_DOT_core_last := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("last"))
	// var glojure.core/libspec?
	glojure_DOT_core_libspec_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("libspec?"))
	// var glojure.core/lift-ns
	glojure_DOT_core_lift_ns := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("lift-ns"))
	// var glojure.core/line-seq
	glojure_DOT_core_line_seq := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("line-seq"))
	// var glojure.core/list
	glojure_DOT_core_list := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("list"))
	// var glojure.core/list*
	glojure_DOT_core_list_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("list*"))
	// var glojure.core/load
	glojure_DOT_core_load := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("load"))
	// var glojure.core/load-all
	glojure_DOT_core_load_all := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("load-all"))
	// var glojure.core/load-data-reader-file
	glojure_DOT_core_load_data_reader_file := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("load-data-reader-file"))
	// var glojure.core/load-lib
	glojure_DOT_core_load_lib := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("load-lib"))
	// var glojure.core/load-libs
	glojure_DOT_core_load_libs := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("load-libs"))
	// var glojure.core/load-one
	glojure_DOT_core_load_one := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("load-one"))
	// var glojure.core/load-reader
	glojure_DOT_core_load_reader := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("load-reader"))
	// var glojure.core/long
	glojure_DOT_core_long := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("long"))
	// var glojure.core/macroexpand
	glojure_DOT_core_macroexpand := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("macroexpand"))
	// var glojure.core/macroexpand-1
	glojure_DOT_core_macroexpand_1 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("macroexpand-1"))
	// var glojure.core/make-array
	glojure_DOT_core_make_array := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("make-array"))
	// var glojure.core/make-hierarchy
	glojure_DOT_core_make_hierarchy := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("make-hierarchy"))
	// var glojure.core/map
	glojure_DOT_core_map := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("map"))
	// var glojure.core/map?
	glojure_DOT_core_map_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("map?"))
	// var glojure.core/mapcat
	glojure_DOT_core_mapcat := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("mapcat"))
	// var glojure.core/max
	glojure_DOT_core_max := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("max"))
	// var glojure.core/max-mask-bits
	glojure_DOT_core_max_mask_bits := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("max-mask-bits"))
	// var glojure.core/max-switch-table-size
	glojure_DOT_core_max_switch_table_size := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("max-switch-table-size"))
	// var glojure.core/maybe-destructured
	glojure_DOT_core_maybe_destructured := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("maybe-destructured"))
	// var glojure.core/maybe-min-hash
	glojure_DOT_core_maybe_min_hash := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("maybe-min-hash"))
	// var glojure.core/merge
	glojure_DOT_core_merge := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("merge"))
	// var glojure.core/merge-hash-collisions
	glojure_DOT_core_merge_hash_collisions := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("merge-hash-collisions"))
	// var glojure.core/meta
	glojure_DOT_core_meta := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("meta"))
	// var glojure.core/min
	glojure_DOT_core_min := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("min"))
	// var glojure.core/mk-bound-fn
	glojure_DOT_core_mk_bound_fn := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("mk-bound-fn"))
	// var glojure.core/name
	glojure_DOT_core_name := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("name"))
	// var glojure.core/namespace
	glojure_DOT_core_namespace := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("namespace"))
	// var glojure.core/nary-inline
	glojure_DOT_core_nary_inline := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("nary-inline"))
	// var glojure.core/neg?
	glojure_DOT_core_neg_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("neg?"))
	// var glojure.core/newline
	glojure_DOT_core_newline := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("newline"))
	// var glojure.core/next
	glojure_DOT_core_next := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("next"))
	// var glojure.core/nil?
	glojure_DOT_core_nil_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("nil?"))
	// var glojure.core/nnext
	glojure_DOT_core_nnext := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("nnext"))
	// var glojure.core/normalize-slurp-opts
	glojure_DOT_core_normalize_slurp_opts := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("normalize-slurp-opts"))
	// var glojure.core/not
	glojure_DOT_core_not := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("not"))
	// var glojure.core/not=
	glojure_DOT_core_not_EQ_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("not="))
	// var glojure.core/not-any?
	glojure_DOT_core_not_any_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("not-any?"))
	// var glojure.core/not-empty
	glojure_DOT_core_not_empty := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("not-empty"))
	// var glojure.core/ns-map
	glojure_DOT_core_ns_map := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ns-map"))
	// var glojure.core/ns-name
	glojure_DOT_core_ns_name := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ns-name"))
	// var glojure.core/ns-publics
	glojure_DOT_core_ns_publics := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ns-publics"))
	// var glojure.core/ns-resolve
	glojure_DOT_core_ns_resolve := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ns-resolve"))
	// var glojure.core/nth
	glojure_DOT_core_nth := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("nth"))
	// var glojure.core/nthrest
	glojure_DOT_core_nthrest := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("nthrest"))
	// var glojure.core/number?
	glojure_DOT_core_number_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("number?"))
	// var glojure.core/odd?
	glojure_DOT_core_odd_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("odd?"))
	// var glojure.core/parents
	glojure_DOT_core_parents := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("parents"))
	// var glojure.core/parse-impls
	glojure_DOT_core_parse_impls := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("parse-impls"))
	// var glojure.core/parsing-err
	glojure_DOT_core_parsing_err := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("parsing-err"))
	// var glojure.core/partial
	glojure_DOT_core_partial := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("partial"))
	// var glojure.core/partition
	glojure_DOT_core_partition := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("partition"))
	// var glojure.core/partition-all
	glojure_DOT_core_partition_all := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("partition-all"))
	// var glojure.core/partition-by
	glojure_DOT_core_partition_by := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("partition-by"))
	// var glojure.core/partitionv
	glojure_DOT_core_partitionv := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("partitionv"))
	// var glojure.core/partitionv-all
	glojure_DOT_core_partitionv_all := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("partitionv-all"))
	// var glojure.core/peek
	glojure_DOT_core_peek := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("peek"))
	// var glojure.core/persistent!
	glojure_DOT_core_persistent_BANG_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("persistent!"))
	// var glojure.core/pmap
	glojure_DOT_core_pmap := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("pmap"))
	// var glojure.core/pop
	glojure_DOT_core_pop := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("pop"))
	// var glojure.core/pop-thread-bindings
	glojure_DOT_core_pop_thread_bindings := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("pop-thread-bindings"))
	// var glojure.core/pos?
	glojure_DOT_core_pos_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("pos?"))
	// var glojure.core/pr
	glojure_DOT_core_pr := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("pr"))
	// var glojure.core/pr-on
	glojure_DOT_core_pr_on := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("pr-on"))
	// var glojure.core/pr-str
	glojure_DOT_core_pr_str := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("pr-str"))
	// var glojure.core/prep-hashes
	glojure_DOT_core_prep_hashes := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("prep-hashes"))
	// var glojure.core/prep-ints
	glojure_DOT_core_prep_ints := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("prep-ints"))
	// var glojure.core/prependss
	glojure_DOT_core_prependss := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("prependss"))
	// var glojure.core/preserving-reduced
	glojure_DOT_core_preserving_reduced := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("preserving-reduced"))
	// var glojure.core/print
	glojure_DOT_core_print := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print"))
	// var glojure.core/print-ctor
	glojure_DOT_core_print_ctor := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print-ctor"))
	// var glojure.core/print-dup
	glojure_DOT_core_print_dup := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print-dup"))
	// var glojure.core/print-map
	glojure_DOT_core_print_map := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print-map"))
	// var glojure.core/print-meta
	glojure_DOT_core_print_meta := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print-meta"))
	// var glojure.core/print-method
	glojure_DOT_core_print_method := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print-method"))
	// var glojure.core/print-object
	glojure_DOT_core_print_object := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print-object"))
	// var glojure.core/print-prefix-map
	glojure_DOT_core_print_prefix_map := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print-prefix-map"))
	// var glojure.core/print-sequential
	glojure_DOT_core_print_sequential := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print-sequential"))
	// var glojure.core/print-simple
	glojure_DOT_core_print_simple := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print-simple"))
	// var glojure.core/print-str
	glojure_DOT_core_print_str := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print-str"))
	// var glojure.core/print-tagged-object
	glojure_DOT_core_print_tagged_object := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("print-tagged-object"))
	// var glojure.core/printf
	glojure_DOT_core_printf := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("printf"))
	// var glojure.core/println
	glojure_DOT_core_println := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("println"))
	// var glojure.core/prn
	glojure_DOT_core_prn := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("prn"))
	// var glojure.core/protocol?
	glojure_DOT_core_protocol_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("protocol?"))
	// var glojure.core/push-thread-bindings
	glojure_DOT_core_push_thread_bindings := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("push-thread-bindings"))
	// var glojure.core/qualified-ident?
	glojure_DOT_core_qualified_ident_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("qualified-ident?"))
	// var glojure.core/qualified-symbol?
	glojure_DOT_core_qualified_symbol_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("qualified-symbol?"))
	// var glojure.core/rand
	glojure_DOT_core_rand := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("rand"))
	// var glojure.core/rand-int
	glojure_DOT_core_rand_int := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("rand-int"))
	// var glojure.core/range
	glojure_DOT_core_range := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("range"))
	// var glojure.core/ratio?
	glojure_DOT_core_ratio_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ratio?"))
	// var glojure.core/re-find
	glojure_DOT_core_re_find := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("re-find"))
	// var glojure.core/re-groups
	glojure_DOT_core_re_groups := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("re-groups"))
	// var glojure.core/re-matcher
	glojure_DOT_core_re_matcher := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("re-matcher"))
	// var glojure.core/read
	glojure_DOT_core_read := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("read"))
	// var glojure.core/read+string
	glojure_DOT_core_read_PLUS_string := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("read+string"))
	// var glojure.core/reduce
	glojure_DOT_core_reduce := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("reduce"))
	// var glojure.core/reduce1
	glojure_DOT_core_reduce1 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("reduce1"))
	// var glojure.core/reduce-kv
	glojure_DOT_core_reduce_kv := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("reduce-kv"))
	// var glojure.core/reduced
	glojure_DOT_core_reduced := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("reduced"))
	// var glojure.core/reduced?
	glojure_DOT_core_reduced_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("reduced?"))
	// var glojure.core/reductions
	glojure_DOT_core_reductions := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("reductions"))
	// var glojure.core/ref
	glojure_DOT_core_ref := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("ref"))
	// var glojure.core/refer
	glojure_DOT_core_refer := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("refer"))
	// var glojure.core/release-pending-sends
	glojure_DOT_core_release_pending_sends := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("release-pending-sends"))
	// var glojure.core/rem
	glojure_DOT_core_rem := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("rem"))
	// var glojure.core/remove
	glojure_DOT_core_remove := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("remove"))
	// var glojure.core/remove-ns
	glojure_DOT_core_remove_ns := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("remove-ns"))
	// var glojure.core/repeat
	glojure_DOT_core_repeat := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("repeat"))
	// var glojure.core/repeatedly
	glojure_DOT_core_repeatedly := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("repeatedly"))
	// var glojure.core/require
	glojure_DOT_core_require := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("require"))
	// var glojure.core/resolve
	glojure_DOT_core_resolve := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("resolve"))
	// var glojure.core/rest
	glojure_DOT_core_rest := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("rest"))
	// var glojure.core/restart-agent
	glojure_DOT_core_restart_agent := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("restart-agent"))
	// var glojure.core/root-directory
	glojure_DOT_core_root_directory := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("root-directory"))
	// var glojure.core/root-resource
	glojure_DOT_core_root_resource := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("root-resource"))
	// var glojure.core/second
	glojure_DOT_core_second := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("second"))
	// var glojure.core/select-keys
	glojure_DOT_core_select_keys := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("select-keys"))
	// var glojure.core/send
	glojure_DOT_core_send := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("send"))
	// var glojure.core/send-off
	glojure_DOT_core_send_off := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("send-off"))
	// var glojure.core/send-via
	glojure_DOT_core_send_via := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("send-via"))
	// var glojure.core/seq
	glojure_DOT_core_seq := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("seq"))
	// var glojure.core/seq?
	glojure_DOT_core_seq_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("seq?"))
	// var glojure.core/seque
	glojure_DOT_core_seque := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("seque"))
	// var glojure.core/sequence
	glojure_DOT_core_sequence := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("sequence"))
	// var glojure.core/sequential?
	glojure_DOT_core_sequential_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("sequential?"))
	// var glojure.core/serialized-require
	glojure_DOT_core_serialized_require := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("serialized-require"))
	// var glojure.core/set
	glojure_DOT_core_set := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("set"))
	// var glojure.core/set?
	glojure_DOT_core_set_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("set?"))
	// var glojure.core/setup-reference
	glojure_DOT_core_setup_reference := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("setup-reference"))
	// var glojure.core/shift-mask
	glojure_DOT_core_shift_mask := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("shift-mask"))
	// var glojure.core/short
	glojure_DOT_core_short := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("short"))
	// var glojure.core/sigs
	glojure_DOT_core_sigs := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("sigs"))
	// var glojure.core/some
	glojure_DOT_core_some := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("some"))
	// var glojure.core/some?
	glojure_DOT_core_some_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("some?"))
	// var glojure.core/sort
	glojure_DOT_core_sort := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("sort"))
	// var glojure.core/sort-by
	glojure_DOT_core_sort_by := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("sort-by"))
	// var glojure.core/sorted-map
	glojure_DOT_core_sorted_map := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("sorted-map"))
	// var glojure.core/sorted-set
	glojure_DOT_core_sorted_set := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("sorted-set"))
	// var glojure.core/split-at
	glojure_DOT_core_split_at := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("split-at"))
	// var glojure.core/split-with
	glojure_DOT_core_split_with := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("split-with"))
	// var glojure.core/spread
	glojure_DOT_core_spread := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("spread"))
	// var glojure.core/str
	glojure_DOT_core_str := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("str"))
	// var glojure.core/stream-reduce!
	glojure_DOT_core_stream_reduce_BANG_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("stream-reduce!"))
	// var glojure.core/stream-transduce!
	glojure_DOT_core_stream_transduce_BANG_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("stream-transduce!"))
	// var glojure.core/string?
	glojure_DOT_core_string_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("string?"))
	// var glojure.core/strip-ns
	glojure_DOT_core_strip_ns := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("strip-ns"))
	// var glojure.core/struct
	glojure_DOT_core_struct := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("struct"))
	// var glojure.core/subs
	glojure_DOT_core_subs := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("subs"))
	// var glojure.core/subvec
	glojure_DOT_core_subvec := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("subvec"))
	// var glojure.core/supers
	glojure_DOT_core_supers := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("supers"))
	// var glojure.core/swap!
	glojure_DOT_core_swap_BANG_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("swap!"))
	// var glojure.core/symbol
	glojure_DOT_core_symbol := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("symbol"))
	// var glojure.core/symbol?
	glojure_DOT_core_symbol_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("symbol?"))
	// var glojure.core/system-newline
	glojure_DOT_core_system_newline := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("system-newline"))
	// var glojure.core/take
	glojure_DOT_core_take := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("take"))
	// var glojure.core/take-nth
	glojure_DOT_core_take_nth := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("take-nth"))
	// var glojure.core/take-while
	glojure_DOT_core_take_while := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("take-while"))
	// var glojure.core/tapset
	glojure_DOT_core_tapset := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("tapset"))
	// var glojure.core/the-ns
	glojure_DOT_core_the_ns := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("the-ns"))
	// var glojure.core/throw-if
	glojure_DOT_core_throw_if := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("throw-if"))
	// var glojure.core/to-array
	glojure_DOT_core_to_array := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("to-array"))
	// var glojure.core/trampoline
	glojure_DOT_core_trampoline := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("trampoline"))
	// var glojure.core/transduce
	glojure_DOT_core_transduce := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("transduce"))
	// var glojure.core/transient
	glojure_DOT_core_transient := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("transient"))
	// var glojure.core/tree-seq
	glojure_DOT_core_tree_seq := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("tree-seq"))
	// var glojure.core/unchecked-inc
	glojure_DOT_core_unchecked_inc := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("unchecked-inc"))
	// var glojure.core/underive
	glojure_DOT_core_underive := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("underive"))
	// var glojure.core/unreduced
	glojure_DOT_core_unreduced := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("unreduced"))
	// var glojure.core/update
	glojure_DOT_core_update := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("update"))
	// var glojure.core/val
	glojure_DOT_core_val := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("val"))
	// var glojure.core/vals
	glojure_DOT_core_vals := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("vals"))
	// var glojure.core/vary-meta
	glojure_DOT_core_vary_meta := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("vary-meta"))
	// var glojure.core/vec
	glojure_DOT_core_vec := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("vec"))
	// var glojure.core/vector
	glojure_DOT_core_vector := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("vector"))
	// var glojure.core/vector?
	glojure_DOT_core_vector_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("vector?"))
	// var glojure.core/volatile!
	glojure_DOT_core_volatile_BANG_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("volatile!"))
	// var glojure.core/vreset!
	glojure_DOT_core_vreset_BANG_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("vreset!"))
	// var glojure.core/with-bindings*
	glojure_DOT_core_with_bindings_STAR_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("with-bindings*"))
	// var glojure.core/with-meta
	glojure_DOT_core_with_meta := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("with-meta"))
	// var glojure.core/zero?
	glojure_DOT_core_zero_QMARK_ := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("zero?"))
	// var glojure.core/zipmap
	glojure_DOT_core_zipmap := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("zipmap"))
	// var glojure.go.io/copy
	glojure_DOT_go_DOT_io_copy := lang.InternVarName(lang.NewSymbol("glojure.go.io"), lang.NewSymbol("copy"))
	// var glojure.go.io/make-input-stream
	glojure_DOT_go_DOT_io_make_input_stream := lang.InternVarName(lang.NewSymbol("glojure.go.io"), lang.NewSymbol("make-input-stream"))
	// var glojure.go.io/make-output-stream
	glojure_DOT_go_DOT_io_make_output_stream := lang.InternVarName(lang.NewSymbol("glojure.go.io"), lang.NewSymbol("make-output-stream"))
	// var glojure.go.io/make-writer
	glojure_DOT_go_DOT_io_make_writer := lang.InternVarName(lang.NewSymbol("glojure.go.io"), lang.NewSymbol("make-writer"))
	// var glojure.go.io/reader
	glojure_DOT_go_DOT_io_reader := lang.InternVarName(lang.NewSymbol("glojure.go.io"), lang.NewSymbol("reader"))
	// //////////////////////////////////////////////////////////////////////////////// Closed-over values
	var closed0 any
	{
		closed0 = lang.NewSymbol("unchecked_multiply")
	}
	var closed1 any
	{
		closed1 = lang.NewSymbol("multiply")
	}
	var closed10 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3, _ := lang.FieldOrMethod(v1, "Reduce")
				if reflect.TypeOf(tmp3).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Reduce is not a function")))
				}
				tmp4 := lang.Apply(tmp3, []any{v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(v1, "ReduceInit")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		closed10 = tmp0
	}
	var closed11 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := checkDerefVar(glojure_DOT_core_DOT_protocols_seq_reduce)
				tmp4 := lang.Apply(tmp3, []any{v1, v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_DOT_protocols_seq_reduce)
				tmp5 := lang.Apply(tmp4, []any{v1, v2, v3})
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		closed11 = tmp0
	}
	var closed12 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := checkDerefVar(glojure_DOT_core_DOT_protocols_seq_reduce)
				tmp4 := lang.Apply(tmp3, []any{v1, v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_DOT_protocols_seq_reduce)
				tmp5 := lang.Apply(tmp4, []any{v1, v2, v3})
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		closed12 = tmp0
	}
	var closed13 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
			return v3
		})
		closed13 = tmp0
	}
	var closed14 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
		recur_loop_1275:
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := lang.Apply(tmp5, []any{v1})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "s"
						var v10 any = v7
						_ = v10
						var tmp11 any
						tmp12 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v10})
						if lang.IsTruthy(tmp13) {
							var tmp14 any
							{ // let
								// let binding "ret"
								tmp15 := checkDerefVar(glojure_DOT_core_chunk_first)
								tmp16 := lang.Apply(tmp15, []any{v10})
								tmp17, _ := lang.FieldOrMethod(tmp16, "ReduceInit")
								if reflect.TypeOf(tmp17).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
								}
								tmp18 := lang.Apply(tmp17, []any{v2, v3})
								var v19 any = tmp18
								_ = v19
								var tmp20 any
								tmp21 := checkDerefVar(glojure_DOT_core_reduced_QMARK_)
								tmp22 := lang.Apply(tmp21, []any{v19})
								if lang.IsTruthy(tmp22) {
									tmp23 := checkDerefVar(glojure_DOT_core_deref)
									tmp24 := lang.Apply(tmp23, []any{v19})
									tmp20 = tmp24
								} else {
									tmp26 := checkDerefVar(glojure_DOT_core_chunk_next)
									tmp27 := lang.Apply(tmp26, []any{v10})
									var tmp25 any = tmp27
									var tmp28 any = v2
									var tmp29 any = v19
									v1 = tmp25
									v2 = tmp28
									v3 = tmp29
									goto recur_loop_1275
								}
								tmp14 = tmp20
							} // end let
							tmp11 = tmp14
						} else {
							tmp15 := checkDerefVar(glojure_DOT_core_DOT_protocols_interface_or_naive_reduce)
							tmp16 := lang.Apply(tmp15, []any{v10, v2, v3})
							tmp11 = tmp16
						}
						tmp9 = tmp11
					} // end let
					tmp8 = tmp9
				} else {
					tmp8 = v3
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		closed14 = tmp0
	}
	var closed15 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "cls"
				tmp5 := checkDerefVar(glojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v1})
				var v7 any = tmp6
				_ = v7
				// let binding "s"
				var v8 any = v1
				_ = v8
				// let binding "f"
				var v9 any = v2
				_ = v9
				// let binding "val"
				var v10 any = v3
				_ = v10
				for {
					var tmp11 any
					{ // let
						// let binding "temp__0__auto__"
						tmp12 := checkDerefVar(glojure_DOT_core_seq)
						tmp13 := lang.Apply(tmp12, []any{v8})
						var v14 any = tmp13
						_ = v14
						var tmp15 any
						if lang.IsTruthy(v14) {
							var tmp16 any
							{ // let
								// let binding "s"
								var v17 any = v14
								_ = v17
								var tmp18 any
								tmp19 := checkDerefVar(glojure_DOT_core_identical_QMARK_)
								tmp20 := checkDerefVar(glojure_DOT_core_class)
								tmp21 := lang.Apply(tmp20, []any{v17})
								tmp22 := lang.Apply(tmp19, []any{tmp21, v7})
								if lang.IsTruthy(tmp22) {
									var tmp23 any
									{ // let
										// let binding "ret"
										tmp24 := checkDerefVar(glojure_DOT_core_first)
										tmp25 := lang.Apply(tmp24, []any{v17})
										tmp26 := lang.Apply(v9, []any{v10, tmp25})
										var v27 any = tmp26
										_ = v27
										var tmp28 any
										tmp29 := checkDerefVar(glojure_DOT_core_reduced_QMARK_)
										tmp30 := lang.Apply(tmp29, []any{v27})
										if lang.IsTruthy(tmp30) {
											tmp31 := checkDerefVar(glojure_DOT_core_deref)
											tmp32 := lang.Apply(tmp31, []any{v27})
											tmp28 = tmp32
										} else {
											var tmp33 any = v7
											tmp35 := checkDerefVar(glojure_DOT_core_next)
											tmp36 := lang.Apply(tmp35, []any{v17})
											var tmp34 any = tmp36
											var tmp37 any = v9
											var tmp38 any = v27
											v7 = tmp33
											v8 = tmp34
											v9 = tmp37
											v10 = tmp38
											continue
										}
										tmp23 = tmp28
									} // end let
									tmp18 = tmp23
								} else {
									tmp24 := checkDerefVar(glojure_DOT_core_DOT_protocols_interface_or_naive_reduce)
									tmp25 := lang.Apply(tmp24, []any{v17, v9, v10})
									tmp18 = tmp25
								}
								tmp16 = tmp18
							} // end let
							tmp15 = tmp16
						} else {
							tmp15 = v10
						}
						tmp11 = tmp15
					} // end let
					tmp4 = tmp11
					break
				}
			} // end let
			return tmp4
		})
		closed15 = tmp0
	}
	var closed16 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			return nil
		})
		closed16 = tmp0
	}
	var closed17 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/go/io.glj", lang.NewKeyword("line"), int(188), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(188), lang.NewKeyword("end-column"), int(32))).(lang.FnFunc)
		closed17 = tmp0
	}
	var closed18 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(glojure_DOT_go_DOT_io_make_input_stream)
			tmp4 := lang.Apply(tmp3, []any{v1, v2})
			return tmp4
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/go/io.glj", lang.NewKeyword("line"), int(167), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(167), lang.NewKeyword("end-column"), int(56))).(lang.FnFunc)
		closed18 = tmp0
	}
	var closed19 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(glojure_DOT_go_DOT_io_make_writer)
			tmp4 := checkDerefVar(glojure_DOT_go_DOT_io_make_output_stream)
			tmp5 := lang.Apply(tmp4, []any{v1, v2})
			tmp6 := lang.Apply(tmp3, []any{tmp5, v2})
			return tmp6
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/go/io.glj", lang.NewKeyword("line"), int(168), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(168), lang.NewKeyword("end-column"), int(76))).(lang.FnFunc)
		closed19 = tmp0
	}
	var closed2 any
	{
		closed2 = lang.NewSymbol("multiplyP")
	}
	var closed20 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/go/io.glj", lang.NewKeyword("line"), int(187), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(187), lang.NewKeyword("end-column"), int(38))).(lang.FnFunc)
		closed20 = tmp0
	}
	var closed21 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/go/io.glj", lang.NewKeyword("line"), int(226), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(226), lang.NewKeyword("end-column"), int(48))).(lang.FnFunc)
		closed21 = tmp0
	}
	var closed22 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(glojure_DOT_go_DOT_io_make_input_stream)
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core__EQ_)
			tmp6, ok := lang.FieldOrMethod(v1, "scheme")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "scheme")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			tmp8 := lang.Apply(tmp5, []any{"file", tmp7})
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.Apply(nil, []any{v1})
				tmp4 = tmp9
			} else {
				var tmp10 any
				{ // let
					// let binding "req"
					var tmp11 any
					{ // let
						// let binding "res__0__auto__"
						tmp12, ok := lang.FieldOrMethod(v1, "String")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "String")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						tmp14 := lang.Apply(http17.NewRequest, []any{http17.MethodGet, tmp13, nil})
						var v15 any = tmp14
						_ = v15
						// let binding "vec__295"
						var tmp16 any
						tmp17 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
						tmp18 := lang.Apply(tmp17, []any{v15})
						if lang.IsTruthy(tmp18) {
							tmp19 := checkDerefVar(glojure_DOT_core_pop)
							tmp20 := lang.Apply(tmp19, []any{v15})
							tmp21 := checkDerefVar(glojure_DOT_core_last)
							tmp22 := lang.Apply(tmp21, []any{v15})
							tmp23 := lang.NewVector(tmp20, tmp22)
							tmp24 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
							tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 = tmp25
						} else {
							tmp26 := lang.NewVector(nil, v15)
							tmp27 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
							tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 = tmp28
						}
						var v29 any = tmp16
						_ = v29
						// let binding "vec__298"
						tmp30 := checkDerefVar(glojure_DOT_core_nth)
						tmp31 := lang.Apply(tmp30, []any{v29, int64(0), nil})
						var v32 any = tmp31
						_ = v32
						// let binding "seq__299"
						tmp33 := checkDerefVar(glojure_DOT_core_seq)
						tmp34 := lang.Apply(tmp33, []any{v32})
						var v35 any = tmp34
						_ = v35
						// let binding "first__300"
						tmp36 := checkDerefVar(glojure_DOT_core_first)
						tmp37 := lang.Apply(tmp36, []any{v35})
						var v38 any = tmp37
						_ = v38
						// let binding "seq__299"
						tmp39 := checkDerefVar(glojure_DOT_core_next)
						tmp40 := lang.Apply(tmp39, []any{v35})
						var v41 any = tmp40
						_ = v41
						// let binding "fst__1__auto__"
						var v42 any = v38
						_ = v42
						// let binding "rst__2__auto__"
						var v43 any = v41
						_ = v43
						// let binding "res__0__auto__"
						var v44 any = v32
						_ = v44
						// let binding "err__3__auto__"
						tmp45 := checkDerefVar(glojure_DOT_core_nth)
						tmp46 := lang.Apply(tmp45, []any{v29, int64(1), nil})
						var v47 any = tmp46
						_ = v47
						// let binding "res__0__auto__"
						var tmp48 any
						tmp49 := checkDerefVar(glojure_DOT_core_not_empty)
						tmp50 := lang.Apply(tmp49, []any{v43})
						if lang.IsTruthy(tmp50) {
							tmp48 = v44
						} else {
							tmp48 = v42
						}
						var v51 any = tmp48
						_ = v51
						var tmp52 any
						if lang.IsTruthy(v47) {
							panic(v47)
						} else {
						}
						_ = tmp52
						tmp11 = v51
					} // end let
					var v12 any = tmp11
					_ = v12
					// let binding "res"
					var tmp13 any
					{ // let
						// let binding "res__0__auto__"
						tmp14, _ := lang.FieldOrMethod(http17.DefaultClient, "Do")
						if reflect.TypeOf(tmp14).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("Do is not a function")))
						}
						tmp15 := lang.Apply(tmp14, []any{v12})
						var v16 any = tmp15
						_ = v16
						// let binding "vec__301"
						var tmp17 any
						tmp18 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v16})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(glojure_DOT_core_pop)
							tmp21 := lang.Apply(tmp20, []any{v16})
							tmp22 := checkDerefVar(glojure_DOT_core_last)
							tmp23 := lang.Apply(tmp22, []any{v16})
							tmp24 := lang.NewVector(tmp21, tmp23)
							tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp26
						} else {
							tmp27 := lang.NewVector(nil, v16)
							tmp28 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
							tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp29
						}
						var v30 any = tmp17
						_ = v30
						// let binding "vec__304"
						tmp31 := checkDerefVar(glojure_DOT_core_nth)
						tmp32 := lang.Apply(tmp31, []any{v30, int64(0), nil})
						var v33 any = tmp32
						_ = v33
						// let binding "seq__305"
						tmp34 := checkDerefVar(glojure_DOT_core_seq)
						tmp35 := lang.Apply(tmp34, []any{v33})
						var v36 any = tmp35
						_ = v36
						// let binding "first__306"
						tmp37 := checkDerefVar(glojure_DOT_core_first)
						tmp38 := lang.Apply(tmp37, []any{v36})
						var v39 any = tmp38
						_ = v39
						// let binding "seq__305"
						tmp40 := checkDerefVar(glojure_DOT_core_next)
						tmp41 := lang.Apply(tmp40, []any{v36})
						var v42 any = tmp41
						_ = v42
						// let binding "fst__1__auto__"
						var v43 any = v39
						_ = v43
						// let binding "rst__2__auto__"
						var v44 any = v42
						_ = v44
						// let binding "res__0__auto__"
						var v45 any = v33
						_ = v45
						// let binding "err__3__auto__"
						tmp46 := checkDerefVar(glojure_DOT_core_nth)
						tmp47 := lang.Apply(tmp46, []any{v30, int64(1), nil})
						var v48 any = tmp47
						_ = v48
						// let binding "res__0__auto__"
						var tmp49 any
						tmp50 := checkDerefVar(glojure_DOT_core_not_empty)
						tmp51 := lang.Apply(tmp50, []any{v44})
						if lang.IsTruthy(tmp51) {
							tmp49 = v45
						} else {
							tmp49 = v43
						}
						var v52 any = tmp49
						_ = v52
						var tmp53 any
						if lang.IsTruthy(v48) {
							panic(v48)
						} else {
						}
						_ = tmp53
						tmp13 = v52
					} // end let
					var v14 any = tmp13
					_ = v14
					// let binding "status"
					tmp15, ok := lang.FieldOrMethod(v14, "StatusCode")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "StatusCode")))
					}
					var tmp16 any
					switch reflect.TypeOf(tmp15).Kind() {
					case reflect.Func:
						tmp16 = lang.Apply(tmp15, nil)
					default:
						tmp16 = tmp15
					}
					var v17 any = tmp16
					_ = v17
					// let binding "body"
					tmp18, ok := lang.FieldOrMethod(v14, "Body")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "Body")))
					}
					var tmp19 any
					switch reflect.TypeOf(tmp18).Kind() {
					case reflect.Func:
						tmp19 = lang.Apply(tmp18, nil)
					default:
						tmp19 = tmp18
					}
					var v20 any = tmp19
					_ = v20
					var tmp21 any
					tmp22 := checkDerefVar(glojure_DOT_core_not_EQ_)
					tmp23 := lang.Apply(tmp22, []any{int64(200), v17})
					if lang.IsTruthy(tmp23) {
						tmp24, ok := lang.FieldOrMethod(v20, "Close")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v20, "Close")))
						}
						var tmp25 any
						switch reflect.TypeOf(tmp24).Kind() {
						case reflect.Func:
							tmp25 = lang.Apply(tmp24, nil)
						default:
							tmp25 = tmp24
						}
						_ = tmp25
						tmp26 := lang.Apply(fmt.Errorf, []any{"http error: %s", v17})
						panic(tmp26)
					} else {
					}
					_ = tmp21
					tmp10 = v20
				} // end let
				tmp4 = tmp10
			}
			tmp11 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp11
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/go/io.glj", lang.NewKeyword("line"), int(232), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(244), lang.NewKeyword("end-column"), int(32))).(lang.FnFunc)
		closed22 = tmp0
	}
	var closed23 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "vec__307"
				tmp4 := lang.Apply(url4.ParseRequestURI, []any{v1})
				var v5 any = tmp4
				_ = v5
				// let binding "url"
				tmp6 := checkDerefVar(glojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(glojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				if lang.IsTruthy(v11) {
					tmp13 := checkDerefVar(glojure_DOT_go_DOT_io_make_input_stream)
					var tmp14 any
					{ // let
						// let binding "res__0__auto__"
						tmp15 := lang.Apply(os5.Open, []any{v1})
						var v16 any = tmp15
						_ = v16
						// let binding "vec__310"
						var tmp17 any
						tmp18 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v16})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(glojure_DOT_core_pop)
							tmp21 := lang.Apply(tmp20, []any{v16})
							tmp22 := checkDerefVar(glojure_DOT_core_last)
							tmp23 := lang.Apply(tmp22, []any{v16})
							tmp24 := lang.NewVector(tmp21, tmp23)
							tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp26
						} else {
							tmp27 := lang.NewVector(nil, v16)
							tmp28 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
							tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp29
						}
						var v30 any = tmp17
						_ = v30
						// let binding "vec__313"
						tmp31 := checkDerefVar(glojure_DOT_core_nth)
						tmp32 := lang.Apply(tmp31, []any{v30, int64(0), nil})
						var v33 any = tmp32
						_ = v33
						// let binding "seq__314"
						tmp34 := checkDerefVar(glojure_DOT_core_seq)
						tmp35 := lang.Apply(tmp34, []any{v33})
						var v36 any = tmp35
						_ = v36
						// let binding "first__315"
						tmp37 := checkDerefVar(glojure_DOT_core_first)
						tmp38 := lang.Apply(tmp37, []any{v36})
						var v39 any = tmp38
						_ = v39
						// let binding "seq__314"
						tmp40 := checkDerefVar(glojure_DOT_core_next)
						tmp41 := lang.Apply(tmp40, []any{v36})
						var v42 any = tmp41
						_ = v42
						// let binding "fst__1__auto__"
						var v43 any = v39
						_ = v43
						// let binding "rst__2__auto__"
						var v44 any = v42
						_ = v44
						// let binding "res__0__auto__"
						var v45 any = v33
						_ = v45
						// let binding "err__3__auto__"
						tmp46 := checkDerefVar(glojure_DOT_core_nth)
						tmp47 := lang.Apply(tmp46, []any{v30, int64(1), nil})
						var v48 any = tmp47
						_ = v48
						// let binding "res__0__auto__"
						var tmp49 any
						tmp50 := checkDerefVar(glojure_DOT_core_not_empty)
						tmp51 := lang.Apply(tmp50, []any{v44})
						if lang.IsTruthy(tmp51) {
							tmp49 = v45
						} else {
							tmp49 = v43
						}
						var v52 any = tmp49
						_ = v52
						var tmp53 any
						if lang.IsTruthy(v48) {
							panic(v48)
						} else {
						}
						_ = tmp53
						tmp14 = v52
					} // end let
					tmp15 := lang.Apply(tmp13, []any{tmp14, v2})
					tmp12 = tmp15
				} else {
					tmp16 := checkDerefVar(glojure_DOT_go_DOT_io_make_input_stream)
					tmp17 := lang.Apply(tmp16, []any{v8, v2})
					tmp12 = tmp17
				}
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/go/io.glj", lang.NewKeyword("line"), int(259), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(263), lang.NewKeyword("end-column"), int(60))).(lang.FnFunc)
		closed23 = tmp0
	}
	var closed24 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(glojure_DOT_core_str)
			tmp4 := checkDerefVar(glojure_DOT_core_pr_str)
			tmp5 := lang.Apply(tmp4, []any{v1})
			tmp6 := lang.Apply(tmp3, []any{"Cannot open <", tmp5, "> as an OutputStream."})
			tmp7 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp6})
			panic(tmp7)
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/go/io.glj", lang.NewKeyword("line"), int(172), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(174), lang.NewKeyword("end-column"), int(92))).(lang.FnFunc)
		closed24 = tmp0
	}
	var closed25 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/go/io.glj", lang.NewKeyword("line"), int(227), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(227), lang.NewKeyword("end-column"), int(49))).(lang.FnFunc)
		closed25 = tmp0
	}
	var closed26 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(glojure_DOT_core__EQ_)
			tmp5, ok := lang.FieldOrMethod(v1, "scheme")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "scheme")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{"file", tmp6})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(glojure_DOT_go_DOT_io_make_output_stream)
				tmp9 := lang.Apply(nil, []any{v1})
				tmp10 := lang.Apply(tmp8, []any{tmp9, v2})
				tmp3 = tmp10
			} else {
				tmp11 := checkDerefVar(glojure_DOT_core_str)
				tmp12 := lang.Apply(tmp11, []any{"Can not write to non-file URL <", v1, ">"})
				tmp13 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp12})
				panic(tmp13)
			}
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/go/io.glj", lang.NewKeyword("line"), int(245), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(248), lang.NewKeyword("end-column"), int(149))).(lang.FnFunc)
		closed26 = tmp0
	}
	var closed27 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						if lang.CatchMatches(r, lang.Builtins["any"]) {
							v4 := r
							_ = v4
							tmp5 := checkDerefVar(glojure_DOT_go_DOT_io_make_output_stream)
							var tmp6 any
							{ // let
								// let binding "res__0__auto__"
								tmp7 := lang.Apply(os5.Open, []any{v1})
								tmp8 := lang.Apply(tmp7, nil)
								var v9 any = tmp8
								_ = v9
								// let binding "vec__322"
								var tmp10 any
								tmp11 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
								tmp12 := lang.Apply(tmp11, []any{v9})
								if lang.IsTruthy(tmp12) {
									tmp13 := checkDerefVar(glojure_DOT_core_pop)
									tmp14 := lang.Apply(tmp13, []any{v9})
									tmp15 := checkDerefVar(glojure_DOT_core_last)
									tmp16 := lang.Apply(tmp15, []any{v9})
									tmp17 := lang.NewVector(tmp14, tmp16)
									tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
									tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp10 = tmp19
								} else {
									tmp20 := lang.NewVector(nil, v9)
									tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
									tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp10 = tmp22
								}
								var v23 any = tmp10
								_ = v23
								// let binding "vec__325"
								tmp24 := checkDerefVar(glojure_DOT_core_nth)
								tmp25 := lang.Apply(tmp24, []any{v23, int64(0), nil})
								var v26 any = tmp25
								_ = v26
								// let binding "seq__326"
								tmp27 := checkDerefVar(glojure_DOT_core_seq)
								tmp28 := lang.Apply(tmp27, []any{v26})
								var v29 any = tmp28
								_ = v29
								// let binding "first__327"
								tmp30 := checkDerefVar(glojure_DOT_core_first)
								tmp31 := lang.Apply(tmp30, []any{v29})
								var v32 any = tmp31
								_ = v32
								// let binding "seq__326"
								tmp33 := checkDerefVar(glojure_DOT_core_next)
								tmp34 := lang.Apply(tmp33, []any{v29})
								var v35 any = tmp34
								_ = v35
								// let binding "fst__1__auto__"
								var v36 any = v32
								_ = v36
								// let binding "rst__2__auto__"
								var v37 any = v35
								_ = v37
								// let binding "res__0__auto__"
								var v38 any = v26
								_ = v38
								// let binding "err__3__auto__"
								tmp39 := checkDerefVar(glojure_DOT_core_nth)
								tmp40 := lang.Apply(tmp39, []any{v23, int64(1), nil})
								var v41 any = tmp40
								_ = v41
								// let binding "res__0__auto__"
								var tmp42 any
								tmp43 := checkDerefVar(glojure_DOT_core_not_empty)
								tmp44 := lang.Apply(tmp43, []any{v37})
								if lang.IsTruthy(tmp44) {
									tmp42 = v38
								} else {
									tmp42 = v36
								}
								var v45 any = tmp42
								_ = v45
								var tmp46 any
								if lang.IsTruthy(v41) {
									panic(v41)
								} else {
								}
								_ = tmp46
								tmp6 = v45
							} // end let
							tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
							tmp3 = tmp7
						} else {
							panic(r)
						}
					}
				}()
				tmp4 := checkDerefVar(glojure_DOT_go_DOT_io_make_output_stream)
				var tmp5 any
				{ // let
					// let binding "res__0__auto__"
					tmp6 := lang.Apply(url4.Parse, []any{v1})
					tmp7 := lang.Apply(tmp6, nil)
					var v8 any = tmp7
					_ = v8
					// let binding "vec__316"
					var tmp9 any
					tmp10 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
					tmp11 := lang.Apply(tmp10, []any{v8})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(glojure_DOT_core_pop)
						tmp13 := lang.Apply(tmp12, []any{v8})
						tmp14 := checkDerefVar(glojure_DOT_core_last)
						tmp15 := lang.Apply(tmp14, []any{v8})
						tmp16 := lang.NewVector(tmp13, tmp15)
						tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
						tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp18
					} else {
						tmp19 := lang.NewVector(nil, v8)
						tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
						tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp21
					}
					var v22 any = tmp9
					_ = v22
					// let binding "vec__319"
					tmp23 := checkDerefVar(glojure_DOT_core_nth)
					tmp24 := lang.Apply(tmp23, []any{v22, int64(0), nil})
					var v25 any = tmp24
					_ = v25
					// let binding "seq__320"
					tmp26 := checkDerefVar(glojure_DOT_core_seq)
					tmp27 := lang.Apply(tmp26, []any{v25})
					var v28 any = tmp27
					_ = v28
					// let binding "first__321"
					tmp29 := checkDerefVar(glojure_DOT_core_first)
					tmp30 := lang.Apply(tmp29, []any{v28})
					var v31 any = tmp30
					_ = v31
					// let binding "seq__320"
					tmp32 := checkDerefVar(glojure_DOT_core_next)
					tmp33 := lang.Apply(tmp32, []any{v28})
					var v34 any = tmp33
					_ = v34
					// let binding "fst__1__auto__"
					var v35 any = v31
					_ = v35
					// let binding "rst__2__auto__"
					var v36 any = v34
					_ = v36
					// let binding "res__0__auto__"
					var v37 any = v25
					_ = v37
					// let binding "err__3__auto__"
					tmp38 := checkDerefVar(glojure_DOT_core_nth)
					tmp39 := lang.Apply(tmp38, []any{v22, int64(1), nil})
					var v40 any = tmp39
					_ = v40
					// let binding "res__0__auto__"
					var tmp41 any
					tmp42 := checkDerefVar(glojure_DOT_core_not_empty)
					tmp43 := lang.Apply(tmp42, []any{v36})
					if lang.IsTruthy(tmp43) {
						tmp41 = v37
					} else {
						tmp41 = v35
					}
					var v44 any = tmp41
					_ = v44
					var tmp45 any
					if lang.IsTruthy(v40) {
						panic(v40)
					} else {
					}
					_ = tmp45
					tmp5 = v44
				} // end let
				tmp6 := lang.Apply(tmp4, []any{tmp5, v2})
				tmp3 = tmp6
			}()
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/go/io.glj", lang.NewKeyword("line"), int(264), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(268), lang.NewKeyword("end-column"), int(79))).(lang.FnFunc)
		closed27 = tmp0
	}
	var closed28 any
	{
		closed28 = lang.NewSymbol("divide")
	}
	var closed29 any
	{
		closed29 = lang.NewSymbol("and")
	}
	var closed3 any
	{
		closed3 = lang.NewSymbol("unchecked_add")
	}
	var closed30 any
	{
		closed30 = lang.NewSymbol("andNot")
	}
	var closed31 any
	{
		closed31 = lang.NewSymbol("or")
	}
	var closed32 any
	{
		closed32 = lang.NewSymbol("xor")
	}
	var closed33 any
	{
		closed33 = lang.NewSymbol("max")
	}
	var closed34 any
	{
		closed34 = lang.NewSymbol("min")
	}
	var closed35 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			var tmp2 any
			if lang.IsTruthy(v1) {
				tmp2 = false
			} else {
				tmp2 = true
			}
			return tmp2
		})
		tmp1 := reflect.TypeOf(false)
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp1)).(lang.FnFunc)
		closed35 = tmp0
	}
	var closed36 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
		recur_loop_481:
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "s"
						var v9 any = v6
						_ = v9
						var tmp10 any
						{ // let
							// let binding "or__0__auto__"
							tmp11 := checkDerefVar(glojure_DOT_core_first)
							tmp12 := lang.Apply(tmp11, []any{v9})
							tmp13 := lang.Apply(v1, []any{tmp12})
							var v14 any = tmp13
							_ = v14
							var tmp15 any
							if lang.IsTruthy(v14) {
								tmp15 = v14
							} else {
								var tmp16 any = v1
								tmp18 := checkDerefVar(glojure_DOT_core_next)
								tmp19 := lang.Apply(tmp18, []any{v9})
								var tmp17 any = tmp19
								v1 = tmp16
								v2 = tmp17
								goto recur_loop_481
							}
							tmp10 = tmp15
						} // end let
						tmp8 = tmp10
					} // end let
					tmp7 = tmp8
				} else {
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		closed36 = tmp0
	}
	var closed37 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
		recur_loop_480:
			var tmp3 any
			tmp4 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
			tmp5 := checkDerefVar(glojure_DOT_core_seq)
			tmp6 := lang.Apply(tmp5, []any{v2})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			if lang.IsTruthy(tmp7) {
				tmp3 = true
			} else {
				var tmp8 any
				tmp9 := checkDerefVar(glojure_DOT_core_first)
				tmp10 := lang.Apply(tmp9, []any{v2})
				tmp11 := lang.Apply(v1, []any{tmp10})
				if lang.IsTruthy(tmp11) {
					var tmp12 any = v1
					tmp14 := checkDerefVar(glojure_DOT_core_next)
					tmp15 := lang.Apply(tmp14, []any{v2})
					var tmp13 any = tmp15
					v1 = tmp12
					v2 = tmp13
					goto recur_loop_480
				} else {
					var tmp16 any
					if lang.IsTruthy(lang.NewKeyword("else")) {
						tmp16 = false
					} else {
					}
					tmp8 = tmp16
				}
				tmp3 = tmp8
			}
			return tmp3
		})
		tmp1 := reflect.TypeOf(false)
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp1)).(lang.FnFunc)
		closed37 = tmp0
	}
	var closed4 any
	{
		closed4 = lang.NewSymbol("add")
	}
	var closed5 any
	{
		closed5 = lang.NewSymbol("addP")
	}
	var closed6 any
	{
		closed6 = lang.NewSymbol("unchecked_minus")
	}
	var closed7 any
	{
		closed7 = lang.NewSymbol("minus")
	}
	var closed8 any
	{
		closed8 = lang.NewSymbol("minusP")
	}
	var closed9 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := lang.Apply(v2, nil)
				return tmp3
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				return v3
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		closed9 = tmp0
	}

	// reference fmt to avoid unused import error
	_ = fmt.Printf
	ns := lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core"))
	_ = ns
	// *
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed0
					} else {
						tmp4 = closed1
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed0
					} else {
						tmp5 = closed1
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed0
					} else {
						tmp6 = closed1
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("*").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the product of nums. (*) returns 1. Does not auto-promote\n  longs, will throw on overflow. See also: *'", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1001), lang.NewKeyword("end-line"), int(1001))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(1)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Multiply")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Multiply is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core__STAR_)
				tmp10 := checkDerefVar(glojure_DOT_core__STAR_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed2
					} else {
						tmp4 = closed2
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed2
					} else {
						tmp5 = closed2
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed2
					} else {
						tmp6 = closed2
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("*'").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the product of nums. (*') returns 1. Supports arbitrary precision.\n  See also: *", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(989), lang.NewKeyword("end-line"), int(989))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(1)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "MultiplyP")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("MultiplyP is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core__STAR__U0027_)
				tmp10 := checkDerefVar(glojure_DOT_core__STAR__U0027_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *1
	{
		tmp0 := lang.NewSymbol("*1").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *2
	{
		tmp0 := lang.NewSymbol("*2").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *3
	{
		tmp0 := lang.NewSymbol("*3").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *agent*
	{
		tmp0 := lang.NewSymbol("*agent*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *assert*
	{
		tmp0 := lang.NewSymbol("*assert*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "When set to logical false, 'assert' will omit assertion checks in\n  compiled code. Defaults to true.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *command-line-args*
	{
		tmp0 := lang.NewSymbol("*command-line-args*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "A sequence of the supplied command line arguments, or nil if\n  none were supplied", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compile-files*
	{
		tmp0 := lang.NewSymbol("*compile-files*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "Set to true when compiling files, false otherwise.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compile-path*
	{
		tmp0 := lang.NewSymbol("*compile-path*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "Specifies the directory where 'compile' will write out .class\n  files. This directory must be in the classpath for 'compile' to\n  work.\n\n  Defaults to \"classes\"", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compiler-options*
	{
		tmp0 := lang.NewSymbol("*compiler-options*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.4", lang.NewKeyword("doc"), "A map of keys to options.\n  Note, when binding dynamically make sure to merge with previous value.\n  Supported options:\n  :elide-meta - a collection of metadata keys to elide during compilation.\n  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger\n  :direct-linking - set to true to use direct static invocation of functions, rather than vars\n    Note that call sites compiled with direct linking will not be affected by var redefinition.\n    Use ^:redef (or ^:dynamic) on a var to prevent direct linking and allow redefinition.\n  See https://glojure.org/reference/compilation for more information.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *data-readers*
	{
		tmp0 := lang.NewSymbol("*data-readers*").WithMeta(lang.NewMap(lang.NewKeyword("doc"), "Map from reader tag symbols to data reader Vars.\n\n  When Clojure starts, it searches for files named 'data_readers.clj'\n  and 'data_readers.cljc' at the root of the classpath. Each such file\n  must contain a literal map of symbols, like this:\n\n      {foo/bar my.project.foo/bar\n       foo/baz my.project/baz}\n\n  The first symbol in each pair is a tag that will be recognized by\n  the Clojure reader. The second symbol in the pair is the\n  fully-qualified name of a Var which will be invoked by the reader to\n  parse the form following the tag. For example, given the\n  data_readers.clj file above, the Clojure reader would parse this\n  form:\n\n      #foo/bar [1 2 3]\n\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\n  data reader function is invoked on the form AFTER it has been read\n  as a normal Clojure data structure by the reader.\n\n  Reader tags without namespace qualifiers are reserved for\n  Clojure. Default reader tags are defined in\n  glojure.core/default-data-readers but may be overridden in\n  data_readers.clj, data_readers.cljc, or by rebinding this Var.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(49), lang.NewKeyword("column"), int(6), lang.NewKeyword("line"), int(7794), lang.NewKeyword("end-line"), int(7794), lang.NewKeyword("dynamic"), true)).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.NewMap(), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *default-data-reader-fn*
	{
		tmp0 := lang.NewSymbol("*default-data-reader-fn*").WithMeta(lang.NewMap(lang.NewKeyword("doc"), "When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments,\n  the tag and the value.  If *default-data-reader-fn* is nil (the\n  default), an exception will be thrown for the unknown tag.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(59), lang.NewKeyword("column"), int(6), lang.NewKeyword("line"), int(7823), lang.NewKeyword("end-line"), int(7823), lang.NewKeyword("dynamic"), true)).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *e
	{
		tmp0 := lang.NewSymbol("*e").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *err*
	{
		tmp0 := lang.NewSymbol("*err*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "A java.io.Writer object representing standard error for print operations.\n\n  Defaults to System/err, wrapped in a PrintWriter", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *file*
	{
		tmp0 := lang.NewSymbol("*file*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "The path of the file being evaluated, as a String.\n\n  When there is no file, e.g. in the REPL, the value is not defined.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, "NO_SOURCE_FILE", true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *flush-on-newline*
	{
		tmp0 := lang.NewSymbol("*flush-on-newline*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *loaded-libs*
	{
		tmp0 := lang.NewSymbol("*loaded-libs*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5817), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(5820), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp2 := lang.NewRef(lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{lang.NewSymbol("glojure.core.protocols"), lang.NewSymbol("glojure.string"), lang.NewSymbol("glojure.go.io")})))
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *loading-verbosely*
	{
		tmp0 := lang.NewSymbol("*loading-verbosely*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5827), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(5830), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *ns*
	{
		tmp0 := lang.NewSymbol("*ns*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "A glojure.lang.Namespace object representing the current namespace.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *pending-paths*
	{
		tmp0 := lang.NewSymbol("*pending-paths*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5822), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(5825), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.NewList(), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-dup*
	{
		tmp0 := lang.NewSymbol("*print-dup*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-length*
	{
		tmp0 := lang.NewSymbol("*print-length*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(14), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(23), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-level*
	{
		tmp0 := lang.NewSymbol("*print-level*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(25), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(35), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-meta*
	{
		tmp0 := lang.NewSymbol("*print-meta*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-namespace-maps*
	{
		tmp0 := lang.NewSymbol("*print-namespace-maps*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(39), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(44), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-readably*
	{
		tmp0 := lang.NewSymbol("*print-readably*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, true, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *read-eval*
	{
		tmp0 := lang.NewSymbol("*read-eval*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "Defaults to true (or value specified by system property, see below)\n  ***This setting implies that the full power of the reader is in play,\n  including syntax that can cause code to execute. It should never be\n  used with untrusted sources. See also: glojure.edn/read.***\n\n  When set to logical false in the thread-local binding,\n  the eval reader (#=) and record/type literal syntax are disabled in read/load.\n  Example (will fail): (binding [*read-eval* false] (read-string \"#=(* 2 21)\"))\n\n  The default binding can be controlled by the system property\n  'glojure.read.eval' System properties can be set on the command line\n  like this:\n\n  java -Dglojure.read.eval=false ...\n\n  The system property can also be set to 'unknown' via\n  -Dglojure.read.eval=unknown, in which case the default binding\n  is :unknown and all reads will fail in contexts where *read-eval*\n  has not been explicitly bound to either true or false. This setting\n  can be a useful diagnostic tool to ensure that all of your reads\n  occur in considered contexts. You can also accomplish this in a\n  particular scope by binding *read-eval* to :unknown\n  ", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *repl*
	{
		tmp0 := lang.NewSymbol("*repl*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6288), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(6291), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *unchecked-math*
	{
		tmp0 := lang.NewSymbol("*unchecked-math*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.3", lang.NewKeyword("doc"), "While bound to true, compilations of +, -, *, inc, dec and the\n  coercions will be done without overflow checks. While bound\n  to :warn-on-boxed, same behavior as true, and a warning is emitted\n  when compilation uses boxed math. Default: false.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *verbose-defrecords*
	{
		tmp0 := lang.NewSymbol("*verbose-defrecords*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(37), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(37), lang.NewKeyword("end-column"), int(35), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *warn-on-reflection*
	{
		tmp0 := lang.NewSymbol("*warn-on-reflection*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "When set to true, the compiler will emit warnings when reflection is\n  needed to resolve Java method calls or field accesses.\n\n  Defaults to false.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed3
					} else {
						tmp4 = closed4
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed3
					} else {
						tmp5 = closed4
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed3
					} else {
						tmp6 = closed4
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("+").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(977), lang.NewKeyword("end-line"), int(977))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(0)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Add")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Add is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core__PLUS_)
				tmp10 := checkDerefVar(glojure_DOT_core__PLUS_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed5
					} else {
						tmp4 = closed5
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed5
					} else {
						tmp5 = closed5
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed5
					} else {
						tmp6 = closed5
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("+'").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the sum of nums. (+') returns 0. Supports arbitrary precision.\n  See also: +", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(965), lang.NewKeyword("end-line"), int(965))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(0)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "AddP")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddP is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core__PLUS__U0027_)
				tmp10 := checkDerefVar(glojure_DOT_core__PLUS__U0027_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed6
					} else {
						tmp4 = closed7
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed6
					} else {
						tmp5 = closed7
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed6
					} else {
						tmp6 = closed7
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(0)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("-").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Does not auto-promote\n  longs, will throw on overflow. See also: -'", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1036), lang.NewKeyword("end-line"), int(1036))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core__STAR_)
				tmp7 := lang.Apply(tmp6, []any{int64(-1), v5})
				return tmp7
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Minus")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Minus is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core__)
				tmp10 := checkDerefVar(glojure_DOT_core__)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed8
					} else {
						tmp4 = closed8
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed8
					} else {
						tmp5 = closed8
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed8
					} else {
						tmp6 = closed8
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(0)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("-'").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Supports arbitrary precision.\n  See also: -", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1024), lang.NewKeyword("end-line"), int(1024))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core__STAR__U0027_)
				tmp7 := lang.Apply(tmp6, []any{int64(-1), v5})
				return tmp7
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "MinusP")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("MinusP is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core___U0027_)
				tmp10 := checkDerefVar(glojure_DOT_core___U0027_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ->
	{
		tmp0 := lang.NewSymbol("->").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1675), lang.NewKeyword("end-line"), int(1675))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "x"
					var v8 any = v5
					_ = v8
					// let binding "forms"
					var v9 any = v6
					_ = v9
					for {
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "form"
								tmp12 := checkDerefVar(glojure_DOT_core_first)
								tmp13 := lang.Apply(tmp12, []any{v9})
								var v14 any = tmp13
								_ = v14
								// let binding "threaded"
								var tmp15 any
								tmp16 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
								tmp17 := lang.Apply(tmp16, []any{v14})
								if lang.IsTruthy(tmp17) {
									tmp18 := checkDerefVar(glojure_DOT_core_with_meta)
									tmp19 := checkDerefVar(glojure_DOT_core_seq)
									tmp20 := checkDerefVar(glojure_DOT_core_concat)
									tmp21 := checkDerefVar(glojure_DOT_core_list)
									tmp22 := checkDerefVar(glojure_DOT_core_first)
									tmp23 := lang.Apply(tmp22, []any{v14})
									tmp24 := lang.Apply(tmp21, []any{tmp23})
									tmp25 := checkDerefVar(glojure_DOT_core_list)
									tmp26 := lang.Apply(tmp25, []any{v8})
									tmp27 := checkDerefVar(glojure_DOT_core_next)
									tmp28 := lang.Apply(tmp27, []any{v14})
									tmp29 := lang.Apply(tmp20, []any{tmp24, tmp26, tmp28})
									tmp30 := lang.Apply(tmp19, []any{tmp29})
									tmp31 := checkDerefVar(glojure_DOT_core_meta)
									tmp32 := lang.Apply(tmp31, []any{v14})
									tmp33 := lang.Apply(tmp18, []any{tmp30, tmp32})
									tmp15 = tmp33
								} else {
									tmp34 := checkDerefVar(glojure_DOT_core_list)
									tmp35 := lang.Apply(tmp34, []any{v14, v8})
									tmp15 = tmp35
								}
								var v36 any = tmp15
								_ = v36
								var tmp37 any = v36
								tmp39 := checkDerefVar(glojure_DOT_core_next)
								tmp40 := lang.Apply(tmp39, []any{v9})
								var tmp38 any = tmp40
								v8 = tmp37
								v9 = tmp38
								continue
							} // end let
							tmp10 = tmp11
						} else {
							tmp10 = v8
						}
						tmp7 = tmp10
						break
					}
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ->>
	{
		tmp0 := lang.NewSymbol("->>").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1691), lang.NewKeyword("end-line"), int(1691))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "x"
					var v8 any = v5
					_ = v8
					// let binding "forms"
					var v9 any = v6
					_ = v9
					for {
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "form"
								tmp12 := checkDerefVar(glojure_DOT_core_first)
								tmp13 := lang.Apply(tmp12, []any{v9})
								var v14 any = tmp13
								_ = v14
								// let binding "threaded"
								var tmp15 any
								tmp16 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
								tmp17 := lang.Apply(tmp16, []any{v14})
								if lang.IsTruthy(tmp17) {
									tmp18 := checkDerefVar(glojure_DOT_core_with_meta)
									tmp19 := checkDerefVar(glojure_DOT_core_seq)
									tmp20 := checkDerefVar(glojure_DOT_core_concat)
									tmp21 := checkDerefVar(glojure_DOT_core_list)
									tmp22 := checkDerefVar(glojure_DOT_core_first)
									tmp23 := lang.Apply(tmp22, []any{v14})
									tmp24 := lang.Apply(tmp21, []any{tmp23})
									tmp25 := checkDerefVar(glojure_DOT_core_next)
									tmp26 := lang.Apply(tmp25, []any{v14})
									tmp27 := checkDerefVar(glojure_DOT_core_list)
									tmp28 := lang.Apply(tmp27, []any{v8})
									tmp29 := lang.Apply(tmp20, []any{tmp24, tmp26, tmp28})
									tmp30 := lang.Apply(tmp19, []any{tmp29})
									tmp31 := checkDerefVar(glojure_DOT_core_meta)
									tmp32 := lang.Apply(tmp31, []any{v14})
									tmp33 := lang.Apply(tmp18, []any{tmp30, tmp32})
									tmp15 = tmp33
								} else {
									tmp34 := checkDerefVar(glojure_DOT_core_list)
									tmp35 := lang.Apply(tmp34, []any{v14, v8})
									tmp15 = tmp35
								}
								var v36 any = tmp15
								_ = v36
								var tmp37 any = v36
								tmp39 := checkDerefVar(glojure_DOT_core_next)
								tmp40 := lang.Apply(tmp39, []any{v9})
								var tmp38 any = tmp40
								v8 = tmp37
								v9 = tmp38
								continue
							} // end let
							tmp10 = tmp11
						} else {
							tmp10 = v8
						}
						tmp7 = tmp10
						break
					}
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -protocols
	{
		tmp0 := lang.NewSymbol("-protocols").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("doc"), "Private store of protocols. Go's reflection capabilities\n    don't yet support a native interface-based implementation, so\n    protocols are implemented in Glojure as maps from type to protocol\n    method implementations.", lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(21), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(26), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v6 := args[0]
				_ = v6
				var v7 any = lang.NewList(args[1:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_class)
				tmp9 := lang.Apply(tmp8, []any{v6})
				return tmp9
			}
		})
		tmp4 := lang.NewMultiFn("coll-reduce", tmp5, lang.NewKeyword("default"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")).FindInternedVar(lang.NewSymbol("global-hierarchy")))
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v7 := args[0]
				_ = v7
				var v8 any = lang.NewList(args[1:]...)
				_ = v8
				tmp9 := checkDerefVar(glojure_DOT_core_apply)
				tmp10 := checkDerefVar(glojure_DOT_core_cons)
				tmp11 := lang.Apply(tmp10, []any{v7, v8})
				tmp12 := lang.Apply(tmp9, []any{closed9, tmp11})
				return tmp12
			}
		})
		tmp4.AddMethod(nil, tmp6)
		tmp7 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v9 := args[0]
				_ = v9
				var v10 any = lang.NewList(args[1:]...)
				_ = v10
				tmp11 := checkDerefVar(glojure_DOT_core_apply)
				tmp12 := checkDerefVar(glojure_DOT_core_cons)
				tmp13 := lang.Apply(tmp12, []any{v9, v10})
				tmp14 := lang.Apply(tmp11, []any{closed10, tmp13})
				return tmp14
			}
		})
		tmp4.AddMethod(tmp7, tmp8)
		tmp9 := reflect.TypeOf((*lang.LazySeq)(nil))
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v11 := args[0]
				_ = v11
				var v12 any = lang.NewList(args[1:]...)
				_ = v12
				tmp13 := checkDerefVar(glojure_DOT_core_apply)
				tmp14 := checkDerefVar(glojure_DOT_core_cons)
				tmp15 := lang.Apply(tmp14, []any{v11, v12})
				tmp16 := lang.Apply(tmp13, []any{closed11, tmp15})
				return tmp16
			}
		})
		tmp4.AddMethod(tmp9, tmp10)
		tmp11 := reflect.TypeOf((*lang.Vector)(nil))
		var tmp12 lang.FnFunc
		tmp12 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v13 := args[0]
				_ = v13
				var v14 any = lang.NewList(args[1:]...)
				_ = v14
				tmp15 := checkDerefVar(glojure_DOT_core_apply)
				tmp16 := checkDerefVar(glojure_DOT_core_cons)
				tmp17 := lang.Apply(tmp16, []any{v13, v14})
				tmp18 := lang.Apply(tmp15, []any{closed12, tmp17})
				return tmp18
			}
		})
		tmp4.AddMethod(tmp11, tmp12)
		tmp3 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("coll-reduce"), tmp4), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("coll-reduce"), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("f"), lang.NewSymbol("val"))))))
		var tmp15 lang.FnFunc
		tmp15 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v16 := args[0]
				_ = v16
				var v17 any = lang.NewList(args[1:]...)
				_ = v17
				tmp18 := checkDerefVar(glojure_DOT_core_class)
				tmp19 := lang.Apply(tmp18, []any{v16})
				return tmp19
			}
		})
		tmp14 := lang.NewMultiFn("internal-reduce", tmp15, lang.NewKeyword("default"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")).FindInternedVar(lang.NewSymbol("global-hierarchy")))
		var tmp16 lang.FnFunc
		tmp16 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v17 := args[0]
				_ = v17
				var v18 any = lang.NewList(args[1:]...)
				_ = v18
				tmp19 := checkDerefVar(glojure_DOT_core_apply)
				tmp20 := checkDerefVar(glojure_DOT_core_cons)
				tmp21 := lang.Apply(tmp20, []any{v17, v18})
				tmp22 := lang.Apply(tmp19, []any{closed13, tmp21})
				return tmp22
			}
		})
		tmp14.AddMethod(nil, tmp16)
		tmp17 := reflect.TypeOf((*lang.IChunkedSeq)(nil)).Elem()
		var tmp18 lang.FnFunc
		tmp18 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v19 := args[0]
				_ = v19
				var v20 any = lang.NewList(args[1:]...)
				_ = v20
				tmp21 := checkDerefVar(glojure_DOT_core_apply)
				tmp22 := checkDerefVar(glojure_DOT_core_cons)
				tmp23 := lang.Apply(tmp22, []any{v19, v20})
				tmp24 := lang.Apply(tmp21, []any{closed14, tmp23})
				return tmp24
			}
		})
		tmp14.AddMethod(tmp17, tmp18)
		tmp19 := reflect.TypeOf((*lang.Object)(nil)).Elem()
		var tmp20 lang.FnFunc
		tmp20 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v21 := args[0]
				_ = v21
				var v22 any = lang.NewList(args[1:]...)
				_ = v22
				tmp23 := checkDerefVar(glojure_DOT_core_apply)
				tmp24 := checkDerefVar(glojure_DOT_core_cons)
				tmp25 := lang.Apply(tmp24, []any{v21, v22})
				tmp26 := lang.Apply(tmp23, []any{closed15, tmp25})
				return tmp26
			}
		})
		tmp14.AddMethod(tmp19, tmp20)
		tmp13 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("internal-reduce"), tmp14), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("internal-reduce"), lang.NewVector(lang.NewSymbol("seq"), lang.NewSymbol("f"), lang.NewSymbol("start"))))))
		var tmp23 lang.FnFunc
		tmp23 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v24 := args[0]
				_ = v24
				var v25 any = lang.NewList(args[1:]...)
				_ = v25
				tmp26 := checkDerefVar(glojure_DOT_core_class)
				tmp27 := lang.Apply(tmp26, []any{v24})
				return tmp27
			}
		})
		tmp22 := lang.NewMultiFn("kv-reduce", tmp23, lang.NewKeyword("default"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")).FindInternedVar(lang.NewSymbol("global-hierarchy")))
		tmp21 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("kv-reduce"), tmp22), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("kv-reduce"), lang.NewVector(lang.NewSymbol("amap"), lang.NewSymbol("f"), lang.NewSymbol("init"))))))
		var tmp26 lang.FnFunc
		tmp26 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v27 := args[0]
				_ = v27
				var v28 any = lang.NewList(args[1:]...)
				_ = v28
				tmp29 := checkDerefVar(glojure_DOT_core_class)
				tmp30 := lang.Apply(tmp29, []any{v27})
				return tmp30
			}
		})
		tmp25 := lang.NewMultiFn("datafy", tmp26, lang.NewKeyword("default"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")).FindInternedVar(lang.NewSymbol("global-hierarchy")))
		var tmp27 lang.FnFunc
		tmp27 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v28 := args[0]
				_ = v28
				var v29 any = lang.NewList(args[1:]...)
				_ = v29
				tmp30 := checkDerefVar(glojure_DOT_core_apply)
				tmp31 := checkDerefVar(glojure_DOT_core_cons)
				tmp32 := lang.Apply(tmp31, []any{v28, v29})
				tmp33 := lang.Apply(tmp30, []any{closed16, tmp32})
				return tmp33
			}
		})
		tmp25.AddMethod(nil, tmp27)
		tmp24 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("datafy"), tmp25), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("datafy"), lang.NewVector(lang.NewSymbol("o")), "return a representation of o as data (default identity)"))))
		var tmp30 lang.FnFunc
		tmp30 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v31 := args[0]
				_ = v31
				var v32 any = lang.NewList(args[1:]...)
				_ = v32
				tmp33 := checkDerefVar(glojure_DOT_core_class)
				tmp34 := lang.Apply(tmp33, []any{v31})
				return tmp34
			}
		})
		tmp29 := lang.NewMultiFn("nav", tmp30, lang.NewKeyword("default"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")).FindInternedVar(lang.NewSymbol("global-hierarchy")))
		tmp28 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("nav"), tmp29), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("nav"), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("k"), lang.NewSymbol("v")), "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v."))))
		var tmp33 lang.FnFunc
		tmp33 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v34 := args[0]
				_ = v34
				var v35 any = lang.NewList(args[1:]...)
				_ = v35
				tmp36 := checkDerefVar(glojure_DOT_core_class)
				tmp37 := lang.Apply(tmp36, []any{v34})
				return tmp37
			}
		})
		tmp32 := lang.NewMultiFn("make-reader", tmp33, lang.NewKeyword("default"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")).FindInternedVar(lang.NewSymbol("global-hierarchy")))
		tmp34 := reflect.TypeOf((*io3.Reader)(nil)).Elem()
		var tmp35 lang.FnFunc
		tmp35 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v36 := args[0]
				_ = v36
				var v37 any = lang.NewList(args[1:]...)
				_ = v37
				tmp38 := checkDerefVar(glojure_DOT_core_apply)
				tmp39 := checkDerefVar(glojure_DOT_core_cons)
				tmp40 := lang.Apply(tmp39, []any{v36, v37})
				tmp41 := lang.Apply(tmp38, []any{closed17, tmp40})
				return tmp41
			}
		})
		tmp32.AddMethod(tmp34, tmp35)
		tmp36 := reflect.TypeOf((*url4.URL)(nil))
		var tmp37 lang.FnFunc
		tmp37 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v38 := args[0]
				_ = v38
				var v39 any = lang.NewList(args[1:]...)
				_ = v39
				tmp40 := checkDerefVar(glojure_DOT_core_apply)
				tmp41 := checkDerefVar(glojure_DOT_core_cons)
				tmp42 := lang.Apply(tmp41, []any{v38, v39})
				tmp43 := lang.Apply(tmp40, []any{closed18, tmp42})
				return tmp43
			}
		})
		tmp32.AddMethod(tmp36, tmp37)
		tmp38 := reflect.TypeOf("")
		var tmp39 lang.FnFunc
		tmp39 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v40 := args[0]
				_ = v40
				var v41 any = lang.NewList(args[1:]...)
				_ = v41
				tmp42 := checkDerefVar(glojure_DOT_core_apply)
				tmp43 := checkDerefVar(glojure_DOT_core_cons)
				tmp44 := lang.Apply(tmp43, []any{v40, v41})
				tmp45 := lang.Apply(tmp42, []any{closed18, tmp44})
				return tmp45
			}
		})
		tmp32.AddMethod(tmp38, tmp39)
		var tmp41 lang.FnFunc
		tmp41 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v42 := args[0]
				_ = v42
				var v43 any = lang.NewList(args[1:]...)
				_ = v43
				tmp44 := checkDerefVar(glojure_DOT_core_class)
				tmp45 := lang.Apply(tmp44, []any{v42})
				return tmp45
			}
		})
		tmp40 := lang.NewMultiFn("make-writer", tmp41, lang.NewKeyword("default"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")).FindInternedVar(lang.NewSymbol("global-hierarchy")))
		tmp42 := reflect.TypeOf((*io3.Reader)(nil)).Elem()
		var tmp43 lang.FnFunc
		tmp43 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v44 := args[0]
				_ = v44
				var v45 any = lang.NewList(args[1:]...)
				_ = v45
				tmp46 := checkDerefVar(glojure_DOT_core_apply)
				tmp47 := checkDerefVar(glojure_DOT_core_cons)
				tmp48 := lang.Apply(tmp47, []any{v44, v45})
				tmp49 := lang.Apply(tmp46, []any{closed19, tmp48})
				return tmp49
			}
		})
		tmp40.AddMethod(tmp42, tmp43)
		tmp44 := reflect.TypeOf((*url4.URL)(nil))
		var tmp45 lang.FnFunc
		tmp45 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v46 := args[0]
				_ = v46
				var v47 any = lang.NewList(args[1:]...)
				_ = v47
				tmp48 := checkDerefVar(glojure_DOT_core_apply)
				tmp49 := checkDerefVar(glojure_DOT_core_cons)
				tmp50 := lang.Apply(tmp49, []any{v46, v47})
				tmp51 := lang.Apply(tmp48, []any{closed19, tmp50})
				return tmp51
			}
		})
		tmp40.AddMethod(tmp44, tmp45)
		tmp46 := reflect.TypeOf("")
		var tmp47 lang.FnFunc
		tmp47 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v48 := args[0]
				_ = v48
				var v49 any = lang.NewList(args[1:]...)
				_ = v49
				tmp50 := checkDerefVar(glojure_DOT_core_apply)
				tmp51 := checkDerefVar(glojure_DOT_core_cons)
				tmp52 := lang.Apply(tmp51, []any{v48, v49})
				tmp53 := lang.Apply(tmp50, []any{closed19, tmp52})
				return tmp53
			}
		})
		tmp40.AddMethod(tmp46, tmp47)
		var tmp49 lang.FnFunc
		tmp49 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v50 := args[0]
				_ = v50
				var v51 any = lang.NewList(args[1:]...)
				_ = v51
				tmp52 := checkDerefVar(glojure_DOT_core_class)
				tmp53 := lang.Apply(tmp52, []any{v50})
				return tmp53
			}
		})
		tmp48 := lang.NewMultiFn("make-input-stream", tmp49, lang.NewKeyword("default"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")).FindInternedVar(lang.NewSymbol("global-hierarchy")))
		tmp50 := reflect.TypeOf((*io3.Reader)(nil)).Elem()
		var tmp51 lang.FnFunc
		tmp51 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v52 := args[0]
				_ = v52
				var v53 any = lang.NewList(args[1:]...)
				_ = v53
				tmp54 := checkDerefVar(glojure_DOT_core_apply)
				tmp55 := checkDerefVar(glojure_DOT_core_cons)
				tmp56 := lang.Apply(tmp55, []any{v52, v53})
				tmp57 := lang.Apply(tmp54, []any{closed20, tmp56})
				return tmp57
			}
		})
		tmp48.AddMethod(tmp50, tmp51)
		tmp52 := reflect.TypeOf((*os5.File)(nil))
		var tmp53 lang.FnFunc
		tmp53 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v54 := args[0]
				_ = v54
				var v55 any = lang.NewList(args[1:]...)
				_ = v55
				tmp56 := checkDerefVar(glojure_DOT_core_apply)
				tmp57 := checkDerefVar(glojure_DOT_core_cons)
				tmp58 := lang.Apply(tmp57, []any{v54, v55})
				tmp59 := lang.Apply(tmp56, []any{closed21, tmp58})
				return tmp59
			}
		})
		tmp48.AddMethod(tmp52, tmp53)
		tmp54 := reflect.TypeOf((*url4.URL)(nil))
		var tmp55 lang.FnFunc
		tmp55 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v56 := args[0]
				_ = v56
				var v57 any = lang.NewList(args[1:]...)
				_ = v57
				tmp58 := checkDerefVar(glojure_DOT_core_apply)
				tmp59 := checkDerefVar(glojure_DOT_core_cons)
				tmp60 := lang.Apply(tmp59, []any{v56, v57})
				tmp61 := lang.Apply(tmp58, []any{closed22, tmp60})
				return tmp61
			}
		})
		tmp48.AddMethod(tmp54, tmp55)
		tmp56 := reflect.TypeOf("")
		var tmp57 lang.FnFunc
		tmp57 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v58 := args[0]
				_ = v58
				var v59 any = lang.NewList(args[1:]...)
				_ = v59
				tmp60 := checkDerefVar(glojure_DOT_core_apply)
				tmp61 := checkDerefVar(glojure_DOT_core_cons)
				tmp62 := lang.Apply(tmp61, []any{v58, v59})
				tmp63 := lang.Apply(tmp60, []any{closed23, tmp62})
				return tmp63
			}
		})
		tmp48.AddMethod(tmp56, tmp57)
		var tmp59 lang.FnFunc
		tmp59 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v60 := args[0]
				_ = v60
				var v61 any = lang.NewList(args[1:]...)
				_ = v61
				tmp62 := checkDerefVar(glojure_DOT_core_class)
				tmp63 := lang.Apply(tmp62, []any{v60})
				return tmp63
			}
		})
		tmp58 := lang.NewMultiFn("make-output-stream", tmp59, lang.NewKeyword("default"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")).FindInternedVar(lang.NewSymbol("global-hierarchy")))
		tmp60 := reflect.TypeOf((*io3.Reader)(nil)).Elem()
		var tmp61 lang.FnFunc
		tmp61 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v62 := args[0]
				_ = v62
				var v63 any = lang.NewList(args[1:]...)
				_ = v63
				tmp64 := checkDerefVar(glojure_DOT_core_apply)
				tmp65 := checkDerefVar(glojure_DOT_core_cons)
				tmp66 := lang.Apply(tmp65, []any{v62, v63})
				tmp67 := lang.Apply(tmp64, []any{closed24, tmp66})
				return tmp67
			}
		})
		tmp58.AddMethod(tmp60, tmp61)
		tmp62 := reflect.TypeOf((*os5.File)(nil))
		var tmp63 lang.FnFunc
		tmp63 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v64 := args[0]
				_ = v64
				var v65 any = lang.NewList(args[1:]...)
				_ = v65
				tmp66 := checkDerefVar(glojure_DOT_core_apply)
				tmp67 := checkDerefVar(glojure_DOT_core_cons)
				tmp68 := lang.Apply(tmp67, []any{v64, v65})
				tmp69 := lang.Apply(tmp66, []any{closed25, tmp68})
				return tmp69
			}
		})
		tmp58.AddMethod(tmp62, tmp63)
		tmp64 := reflect.TypeOf((*url4.URL)(nil))
		var tmp65 lang.FnFunc
		tmp65 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v66 := args[0]
				_ = v66
				var v67 any = lang.NewList(args[1:]...)
				_ = v67
				tmp68 := checkDerefVar(glojure_DOT_core_apply)
				tmp69 := checkDerefVar(glojure_DOT_core_cons)
				tmp70 := lang.Apply(tmp69, []any{v66, v67})
				tmp71 := lang.Apply(tmp68, []any{closed26, tmp70})
				return tmp71
			}
		})
		tmp58.AddMethod(tmp64, tmp65)
		tmp66 := reflect.TypeOf("")
		var tmp67 lang.FnFunc
		tmp67 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v68 := args[0]
				_ = v68
				var v69 any = lang.NewList(args[1:]...)
				_ = v69
				tmp70 := checkDerefVar(glojure_DOT_core_apply)
				tmp71 := checkDerefVar(glojure_DOT_core_cons)
				tmp72 := lang.Apply(tmp71, []any{v68, v69})
				tmp73 := lang.Apply(tmp70, []any{closed27, tmp72})
				return tmp73
			}
		})
		tmp58.AddMethod(tmp66, tmp67)
		tmp31 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("make-reader"), tmp32, lang.NewKeyword("make-writer"), tmp40, lang.NewKeyword("make-input-stream"), tmp48, lang.NewKeyword("make-output-stream"), tmp58), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("make-reader"), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("opts")), "Creates an io.Reader. See also IOFactory docs."), lang.NewList(lang.NewSymbol("make-writer"), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("opts")), "Creates an io.Reader. See also IOFactory docs."), lang.NewList(lang.NewSymbol("make-input-stream"), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("opts")), "Creates a BufferedInputStream. See also IOFactory docs."), lang.NewList(lang.NewSymbol("make-output-stream"), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("opts")), "Creates a BufferedOutputStream. See also IOFactory docs."))))
		tmp2 := lang.NewAtom(lang.NewMap(lang.NewSymbol("CollReduce"), tmp3, lang.NewSymbol("InternalReduce"), tmp13, lang.NewSymbol("IKVReduce"), tmp21, lang.NewSymbol("Datafiable"), tmp24, lang.NewSymbol("Navigable"), tmp28, lang.NewSymbol("IOFactory"), tmp31))
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ..
	{
		tmp0 := lang.NewSymbol("..").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("form")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("form"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \"os.name\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \"os.name\"))\n\n  but is easier to write, read, and understand.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1657), lang.NewKeyword("end-line"), int(1657))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v6})
				tmp15 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp14})
				tmp16 := lang.Apply(tmp7, []any{tmp15})
				return tmp16
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_seq)
				tmp9 := checkDerefVar(glojure_DOT_core_concat)
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("..")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := checkDerefVar(glojure_DOT_core_seq)
				tmp14 := checkDerefVar(glojure_DOT_core_concat)
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v5})
				tmp19 := checkDerefVar(glojure_DOT_core_list)
				tmp20 := lang.Apply(tmp19, []any{v6})
				tmp21 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp20})
				tmp22 := lang.Apply(tmp13, []any{tmp21})
				tmp23 := lang.Apply(tmp12, []any{tmp22})
				tmp24 := lang.Apply(tmp9, []any{tmp11, tmp23, v7})
				tmp25 := lang.Apply(tmp8, []any{tmp24})
				return tmp25
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// /
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed28
					} else {
						tmp4 = closed28
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed28
					} else {
						tmp5 = closed28
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed28
					} else {
						tmp6 = closed28
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("/").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1013), lang.NewKeyword("end-line"), int(1013))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core__SLASH_)
				tmp7 := lang.Apply(tmp6, []any{int64(1), v5})
				return tmp7
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Divide")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Divide is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core__SLASH_)
				tmp10 := checkDerefVar(glojure_DOT_core__SLASH_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// <
	{
		var tmp1 lang.FnFunc
		{ // function <__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Lt")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("<").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(893), lang.NewKeyword("end-line"), int(893))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Lt")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Lt is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_150:
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core__LT_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v6})
					if lang.IsTruthy(tmp12) {
						var tmp13 any = v5
						tmp15 := checkDerefVar(glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var tmp14 any = tmp16
						tmp18 := checkDerefVar(glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp17 any = tmp19
						v4 = tmp13
						v5 = tmp14
						v6 = tmp17
						goto recur_loop_150
					} else {
						tmp20 := checkDerefVar(glojure_DOT_core__LT_)
						tmp21 := checkDerefVar(glojure_DOT_core_first)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp23 := lang.Apply(tmp20, []any{v5, tmp22})
						tmp10 = tmp23
					}
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// <=
	{
		var tmp1 lang.FnFunc
		{ // function <=__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Lte")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("<=").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1048), lang.NewKeyword("end-line"), int(1048))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Lte")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Lte is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_194:
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core__LT__EQ_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v6})
					if lang.IsTruthy(tmp12) {
						var tmp13 any = v5
						tmp15 := checkDerefVar(glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var tmp14 any = tmp16
						tmp18 := checkDerefVar(glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp17 any = tmp19
						v4 = tmp13
						v5 = tmp14
						v6 = tmp17
						goto recur_loop_194
					} else {
						tmp20 := checkDerefVar(glojure_DOT_core__LT__EQ_)
						tmp21 := checkDerefVar(glojure_DOT_core_first)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp23 := lang.Apply(tmp20, []any{v5, tmp22})
						tmp10 = tmp23
					}
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// =
	{
		var tmp1 lang.FnFunc
		{ // function =__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.lang.Util")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("glojure.core/equiv")})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp5, []any{tmp17})
				return tmp18
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("=").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Equality. Returns true if x equals y, false if not. Same as\n  Java x.equals(y) except it also works for nil, and compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define equals() (and thus =) as a value, not an identity,\n  comparison.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(776), lang.NewKeyword("end-line"), int(776))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.Equiv, []any{v4, v5})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_126:
				var tmp7 any
				tmp8 := lang.Apply(lang.Equiv, []any{v4, v5})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					tmp10 := checkDerefVar(glojure_DOT_core_next)
					tmp11 := lang.Apply(tmp10, []any{v6})
					if lang.IsTruthy(tmp11) {
						var tmp12 any = v5
						tmp14 := checkDerefVar(glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v6})
						var tmp13 any = tmp15
						tmp17 := checkDerefVar(glojure_DOT_core_next)
						tmp18 := lang.Apply(tmp17, []any{v6})
						var tmp16 any = tmp18
						v4 = tmp12
						v5 = tmp13
						v6 = tmp16
						goto recur_loop_126
					} else {
						tmp19 := checkDerefVar(glojure_DOT_core_first)
						tmp20 := lang.Apply(tmp19, []any{v6})
						tmp21 := lang.Apply(lang.Equiv, []any{v5, tmp20})
						tmp9 = tmp21
					}
					tmp7 = tmp9
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ==
	{
		var tmp1 lang.FnFunc
		{ // function ==__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Equiv")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("==").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns non-nil if nums all have the equivalent\n  value (type-independent), otherwise false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1093), lang.NewKeyword("end-line"), int(1093))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Equiv")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Equiv is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_206:
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core__EQ__EQ_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v6})
					if lang.IsTruthy(tmp12) {
						var tmp13 any = v5
						tmp15 := checkDerefVar(glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var tmp14 any = tmp16
						tmp18 := checkDerefVar(glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp17 any = tmp19
						v4 = tmp13
						v5 = tmp14
						v6 = tmp17
						goto recur_loop_206
					} else {
						tmp20 := checkDerefVar(glojure_DOT_core__EQ__EQ_)
						tmp21 := checkDerefVar(glojure_DOT_core_first)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp23 := lang.Apply(tmp20, []any{v5, tmp22})
						tmp10 = tmp23
					}
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >
	{
		var tmp1 lang.FnFunc
		{ // function >__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Gt")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol(">").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1063), lang.NewKeyword("end-line"), int(1063))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_198:
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core__GT_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v6})
					if lang.IsTruthy(tmp12) {
						var tmp13 any = v5
						tmp15 := checkDerefVar(glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var tmp14 any = tmp16
						tmp18 := checkDerefVar(glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp17 any = tmp19
						v4 = tmp13
						v5 = tmp14
						v6 = tmp17
						goto recur_loop_198
					} else {
						tmp20 := checkDerefVar(glojure_DOT_core__GT_)
						tmp21 := checkDerefVar(glojure_DOT_core_first)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp23 := lang.Apply(tmp20, []any{v5, tmp22})
						tmp10 = tmp23
					}
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >0?
	{
		tmp0 := lang.NewSymbol(">0?").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(963), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(963), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(0)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >1?
	{
		tmp0 := lang.NewSymbol(">1?").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(962), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(962), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >=
	{
		var tmp1 lang.FnFunc
		{ // function >=__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Gte")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol(">=").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1078), lang.NewKeyword("end-line"), int(1078))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Gte")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gte is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_202:
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core__GT__EQ_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v6})
					if lang.IsTruthy(tmp12) {
						var tmp13 any = v5
						tmp15 := checkDerefVar(glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var tmp14 any = tmp16
						tmp18 := checkDerefVar(glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp17 any = tmp19
						v4 = tmp13
						v5 = tmp14
						v6 = tmp17
						goto recur_loop_202
					} else {
						tmp20 := checkDerefVar(glojure_DOT_core__GT__EQ_)
						tmp21 := checkDerefVar(glojure_DOT_core_first)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp23 := lang.Apply(tmp20, []any{v5, tmp22})
						tmp10 = tmp23
					}
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// NaN?
	{
		var tmp1 lang.FnFunc
		{ // function NaN?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol("math.IsNaN")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("NaN?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if num is NaN, else false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7968), lang.NewKeyword("end-line"), int(7968))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(math6.IsNaN, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// StackTraceElement->vec
	{
		tmp0 := lang.NewSymbol("StackTraceElement->vec").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"))), lang.NewKeyword("doc"), "Constructs a data representation for a StackTraceElement: [class method file line]", lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(436), lang.NewKeyword("end-line"), int(436))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_symbol)
			tmp5, ok := lang.FieldOrMethod(v3, "getClassName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getClassName")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			tmp8 := checkDerefVar(glojure_DOT_core_symbol)
			tmp9, ok := lang.FieldOrMethod(v3, "getMethodName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMethodName")))
			}
			var tmp10 any
			switch reflect.TypeOf(tmp9).Kind() {
			case reflect.Func:
				tmp10 = lang.Apply(tmp9, nil)
			default:
				tmp10 = tmp9
			}
			tmp11 := lang.Apply(tmp8, []any{tmp10})
			tmp12, ok := lang.FieldOrMethod(v3, "getFileName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getFileName")))
			}
			var tmp13 any
			switch reflect.TypeOf(tmp12).Kind() {
			case reflect.Func:
				tmp13 = lang.Apply(tmp12, nil)
			default:
				tmp13 = tmp12
			}
			tmp14, ok := lang.FieldOrMethod(v3, "getLineNumber")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getLineNumber")))
			}
			var tmp15 any
			switch reflect.TypeOf(tmp14).Kind() {
			case reflect.Func:
				tmp15 = lang.Apply(tmp14, nil)
			default:
				tmp15 = tmp14
			}
			tmp16 := lang.NewVector(tmp7, tmp11, tmp13, tmp15)
			tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(440), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(440), lang.NewKeyword("end-column"), int(94))
			tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp18
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// Throwable->map
	{
		tmp0 := lang.NewSymbol("Throwable->map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"))), lang.NewKeyword("doc"), "Constructs a data representation for a Throwable with keys:\n    :cause - root cause message\n    :phase - error phase\n    :via - cause chain, with cause keys:\n             :type - exception class symbol\n             :message - exception message\n             :data - ex-data\n             :at - top stack element\n    :trace - root cause stack elements", lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(442), lang.NewKeyword("end-line"), int(442))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "base"
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v6 := args[0]
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_merge)
					tmp8 := checkDerefVar(glojure_DOT_core_symbol)
					tmp9 := checkDerefVar(glojure_DOT_core_class)
					tmp10 := lang.Apply(tmp9, []any{v6})
					tmp11, ok := lang.FieldOrMethod(tmp10, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp10, "Name")))
					}
					var tmp12 any
					switch reflect.TypeOf(tmp11).Kind() {
					case reflect.Func:
						tmp12 = lang.Apply(tmp11, nil)
					default:
						tmp12 = tmp11
					}
					tmp13 := lang.Apply(tmp8, []any{tmp12})
					tmp14 := lang.NewMap(lang.NewKeyword("type"), tmp13)
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(455), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(455), lang.NewKeyword("end-column"), int(56))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp17 any
					{ // let
						// let binding "temp__0__auto__"
						tmp18, ok := lang.FieldOrMethod(v6, "getLocalizedMessage")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "getLocalizedMessage")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						var v20 any = tmp19
						_ = v20
						var tmp21 any
						if lang.IsTruthy(v20) {
							var tmp22 any
							{ // let
								// let binding "msg"
								var v23 any = v20
								_ = v23
								tmp24 := lang.NewMap(lang.NewKeyword("message"), v23)
								tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(457), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(457), lang.NewKeyword("end-column"), int(33))
								tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp22 = tmp26
							} // end let
							tmp21 = tmp22
						} else {
						}
						tmp17 = tmp21
					} // end let
					var tmp18 any
					{ // let
						// let binding "temp__0__auto__"
						tmp19 := checkDerefVar(glojure_DOT_core_ex_data)
						tmp20 := lang.Apply(tmp19, []any{v6})
						var v21 any = tmp20
						_ = v21
						var tmp22 any
						if lang.IsTruthy(v21) {
							var tmp23 any
							{ // let
								// let binding "ed"
								var v24 any = v21
								_ = v24
								tmp25 := lang.NewMap(lang.NewKeyword("data"), v24)
								tmp26 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(459), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(459), lang.NewKeyword("end-column"), int(29))
								tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp23 = tmp27
							} // end let
							tmp22 = tmp23
						} else {
						}
						tmp18 = tmp22
					} // end let
					var tmp19 any
					{ // let
						// let binding "st"
						tmp20, ok := lang.FieldOrMethod(v6, "getStackTrace")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "getStackTrace")))
						}
						var tmp21 any
						switch reflect.TypeOf(tmp20).Kind() {
						case reflect.Func:
							tmp21 = lang.Apply(tmp20, nil)
						default:
							tmp21 = tmp20
						}
						var v22 any = tmp21
						_ = v22
						var tmp23 any
						tmp24 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
						tmp25 := checkDerefVar(glojure_DOT_core_alength)
						tmp26 := lang.Apply(tmp25, []any{v22})
						tmp27 := lang.Apply(tmp24, []any{tmp26})
						if lang.IsTruthy(tmp27) {
							tmp28 := checkDerefVar(glojure_DOT_core_StackTraceElement__GT_vec)
							tmp29 := checkDerefVar(glojure_DOT_core_aget)
							tmp30 := lang.Apply(tmp29, []any{v22, int64(0)})
							tmp31 := lang.Apply(tmp28, []any{tmp30})
							tmp32 := lang.NewMap(lang.NewKeyword("at"), tmp31)
							tmp33 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(462), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(462), lang.NewKeyword("end-column"), int(63))
							tmp34, err := lang.WithMeta(tmp32, tmp33.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp23 = tmp34
						} else {
						}
						tmp19 = tmp23
					} // end let
					tmp20 := lang.Apply(tmp7, []any{tmp16, tmp17, tmp18, tmp19})
					return tmp20
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(454), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(462), lang.NewKeyword("end-column"), int(67))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v8 any = tmp7
				_ = v8
				// let binding "via"
				var tmp9 any
				{ // let
					// let binding "via"
					tmp10 := lang.NewVector()
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(463), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(463), lang.NewKeyword("end-column"), int(25))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v13 any = tmp12
					_ = v13
					// let binding "t"
					var v14 any = v3
					_ = v14
					for {
						var tmp15 any
						if lang.IsTruthy(v14) {
							tmp17 := checkDerefVar(glojure_DOT_core_conj)
							tmp18 := lang.Apply(tmp17, []any{v13, v14})
							var tmp16 any = tmp18
							tmp20, ok := lang.FieldOrMethod(v14, "getCause")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "getCause")))
							}
							var tmp21 any
							switch reflect.TypeOf(tmp20).Kind() {
							case reflect.Func:
								tmp21 = lang.Apply(tmp20, nil)
							default:
								tmp21 = tmp20
							}
							var tmp19 any = tmp21
							v13 = tmp16
							v14 = tmp19
							continue
						} else {
							tmp15 = v13
						}
						tmp9 = tmp15
						break
					}
				} // end let
				var v10 any = tmp9
				_ = v10
				// let binding "root"
				tmp11 := checkDerefVar(glojure_DOT_core_peek)
				tmp12 := lang.Apply(tmp11, []any{v10})
				var v13 any = tmp12
				_ = v13
				tmp14 := checkDerefVar(glojure_DOT_core_merge)
				tmp15 := checkDerefVar(glojure_DOT_core_vec)
				tmp16 := checkDerefVar(glojure_DOT_core_map)
				tmp17 := lang.Apply(tmp16, []any{v8, v10})
				tmp18 := lang.Apply(tmp15, []any{tmp17})
				tmp19 := checkDerefVar(glojure_DOT_core_vec)
				tmp20 := checkDerefVar(glojure_DOT_core_map)
				tmp21 := checkDerefVar(glojure_DOT_core_StackTraceElement__GT_vec)
				var tmp22 any
				{ // let
					// let binding "or__0__auto__"
					var v23 any = v13
					_ = v23
					var tmp24 any
					if lang.IsTruthy(v23) {
						tmp24 = v23
					} else {
						tmp24 = v3
					}
					tmp22 = tmp24
				} // end let
				tmp23, ok := lang.FieldOrMethod(tmp22, "getStackTrace")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp22, "getStackTrace")))
				}
				var tmp24 any
				switch reflect.TypeOf(tmp23).Kind() {
				case reflect.Func:
					tmp24 = lang.Apply(tmp23, nil)
				default:
					tmp24 = tmp23
				}
				tmp25 := lang.Apply(tmp20, []any{tmp21, tmp24})
				tmp26 := lang.Apply(tmp19, []any{tmp25})
				tmp27 := lang.NewMap(lang.NewKeyword("via"), tmp18, lang.NewKeyword("trace"), tmp26)
				tmp28 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(468), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(470), lang.NewKeyword("end-column"), int(111))
				tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp30 any
				{ // let
					// let binding "temp__0__auto__"
					tmp31, ok := lang.FieldOrMethod(v13, "getLocalizedMessage")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v13, "getLocalizedMessage")))
					}
					var tmp32 any
					switch reflect.TypeOf(tmp31).Kind() {
					case reflect.Func:
						tmp32 = lang.Apply(tmp31, nil)
					default:
						tmp32 = tmp31
					}
					var v33 any = tmp32
					_ = v33
					var tmp34 any
					if lang.IsTruthy(v33) {
						var tmp35 any
						{ // let
							// let binding "root-msg"
							var v36 any = v33
							_ = v36
							tmp37 := lang.NewMap(lang.NewKeyword("cause"), v36)
							tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(472), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(472), lang.NewKeyword("end-column"), int(25))
							tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp35 = tmp39
						} // end let
						tmp34 = tmp35
					} else {
					}
					tmp30 = tmp34
				} // end let
				var tmp31 any
				{ // let
					// let binding "temp__0__auto__"
					tmp32 := checkDerefVar(glojure_DOT_core_ex_data)
					tmp33 := lang.Apply(tmp32, []any{v13})
					var v34 any = tmp33
					_ = v34
					var tmp35 any
					if lang.IsTruthy(v34) {
						var tmp36 any
						{ // let
							// let binding "data"
							var v37 any = v34
							_ = v37
							tmp38 := lang.NewMap(lang.NewKeyword("data"), v37)
							tmp39 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(474), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(474), lang.NewKeyword("end-column"), int(20))
							tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp36 = tmp40
						} // end let
						tmp35 = tmp36
					} else {
					}
					tmp31 = tmp35
				} // end let
				var tmp32 any
				{ // let
					// let binding "temp__0__auto__"
					tmp33 := checkDerefVar(glojure_DOT_core_ex_data)
					tmp34 := lang.Apply(tmp33, []any{v3})
					tmp35 := lang.Apply(lang.NewKeyword("glojure.error/phase"), []any{tmp34})
					var v36 any = tmp35
					_ = v36
					var tmp37 any
					if lang.IsTruthy(v36) {
						var tmp38 any
						{ // let
							// let binding "phase"
							var v39 any = v36
							_ = v39
							tmp40 := lang.NewMap(lang.NewKeyword("phase"), v39)
							tmp41 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(476), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(476), lang.NewKeyword("end-column"), int(22))
							tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp38 = tmp42
						} // end let
						tmp37 = tmp38
					} else {
					}
					tmp32 = tmp37
				} // end let
				tmp33 := lang.Apply(tmp14, []any{tmp29, tmp30, tmp31, tmp32})
				tmp4 = tmp33
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// abs
	{
		var tmp1 lang.FnFunc
		{ // function abs__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Abs")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("abs").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the absolute value of a.\n  If a is Long/MIN_VALUE => Long/MIN_VALUE\n  If a is a double and zero => +0.0\n  If a is a double and ##Inf or ##-Inf => ##Inf\n  If a is a double and ##NaN => ##NaN", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1128), lang.NewKeyword("end-line"), int(1128))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Abs, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// accessor
	{
		tmp0 := lang.NewSymbol("accessor").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("key"))), lang.NewKeyword("doc"), "Returns a fn that, given an instance of a structmap with the basis,\n  returns the value at the key.  The key must be in the basis. The\n  returned function should be (slightly) more efficient than using\n  get, but such use of accessors should be limited to known\n  performance-critical areas.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4070), lang.NewKeyword("end-line"), int(4070))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(nil, "getAccessor")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("getAccessor is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aclone
	{
		var tmp1 lang.FnFunc
		{ // function aclone__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/Aclone")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("aclone").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a clone of the Java array. Works on arrays of known\n  types.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3904), lang.NewKeyword("end-line"), int(3904))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime7.RT, "Aclone")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Aclone is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-classpath
	{
		tmp0 := lang.NewSymbol("add-classpath").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("url"))), lang.NewKeyword("doc"), "DEPRECATED \n\n  Adds the url (String or URL object) to the classpath per\n  URLClassLoader.addURL", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("deprecated"), "1.1", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5176), lang.NewKeyword("end-line"), int(5176))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_println)
			tmp5 := lang.Apply(tmp4, []any{"WARNING: add-classpath is deprecated"})
			_ = tmp5
			tmp6 := lang.Apply(nil, []any{v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-doc-and-meta
	{
		tmp0 := lang.NewSymbol("add-doc-and-meta").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("docstring"), lang.NewSymbol("meta"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(26), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(6400), lang.NewKeyword("end-line"), int(6400), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 5 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			tmp8 := checkDerefVar(glojure_DOT_core_seq)
			tmp9 := checkDerefVar(glojure_DOT_core_concat)
			tmp10 := checkDerefVar(glojure_DOT_core_list)
			tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/alter-meta!")})
			tmp12 := checkDerefVar(glojure_DOT_core_list)
			tmp13 := checkDerefVar(glojure_DOT_core_seq)
			tmp14 := checkDerefVar(glojure_DOT_core_concat)
			tmp15 := checkDerefVar(glojure_DOT_core_list)
			tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("var")})
			tmp17 := checkDerefVar(glojure_DOT_core_list)
			tmp18 := lang.Apply(tmp17, []any{v5})
			tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
			tmp20 := lang.Apply(tmp13, []any{tmp19})
			tmp21 := lang.Apply(tmp12, []any{tmp20})
			tmp22 := checkDerefVar(glojure_DOT_core_list)
			tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("glojure.core/merge")})
			tmp24 := checkDerefVar(glojure_DOT_core_list)
			tmp25 := checkDerefVar(glojure_DOT_core_seq)
			tmp26 := checkDerefVar(glojure_DOT_core_concat)
			tmp27 := checkDerefVar(glojure_DOT_core_list)
			tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("glojure.core/assoc")})
			tmp29 := checkDerefVar(glojure_DOT_core_list)
			tmp30 := lang.Apply(tmp29, []any{v7})
			tmp31 := checkDerefVar(glojure_DOT_core_list)
			tmp32 := lang.Apply(tmp31, []any{lang.NewKeyword("doc")})
			tmp33 := checkDerefVar(glojure_DOT_core_list)
			tmp34 := lang.Apply(tmp33, []any{v6})
			tmp35 := lang.Apply(tmp26, []any{tmp28, tmp30, tmp32, tmp34})
			tmp36 := lang.Apply(tmp25, []any{tmp35})
			tmp37 := lang.Apply(tmp24, []any{tmp36})
			tmp38 := lang.Apply(tmp9, []any{tmp11, tmp21, tmp23, tmp37})
			tmp39 := lang.Apply(tmp8, []any{tmp38})
			return tmp39
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-watch
	{
		tmp0 := lang.NewSymbol("add-watch").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("reference"), lang.NewSymbol("key"), lang.NewSymbol("fn"))), lang.NewKeyword("doc"), "Adds a watch function to an agent/atom/var/ref reference. The watch\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch fn\n  will be called synchronously, on the agent's thread if an agent,\n  before any pending sends if agent or ref. Note that an atom's or\n  ref's state may have changed again prior to the fn call, so use\n  old/new-state rather than derefing the reference. Note also that watch\n  fns may be called from multiple threads simultaneously. Var watchers\n  are triggered only by root binding changes, not thread-local\n  set!s. Keys must be unique per reference, and can be used to remove\n  the watch with remove-watch, but are otherwise considered opaque by\n  the watch mechanism.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2142), lang.NewKeyword("end-line"), int(2142))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(v3, "addWatch")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("addWatch is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// agent
	{
		tmp0 := lang.NewSymbol("agent").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("state"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Creates and returns an agent with an initial value of state and\n  zero or more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :error-handler handler-fn\n\n  :error-mode mode-keyword\n\n  If metadata-map is supplied, it will become the metadata on the\n  agent. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.  handler-fn is called if an\n  action throws an exception or if validate-fn rejects a new state --\n  see set-error-handler! for details.  The mode-keyword may be either\n  :continue (the default if an error-handler is given) or :fail (the\n  default if no error-handler is given) -- see set-error-mode! for\n  details.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2052), lang.NewKeyword("end-line"), int(2052))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "a"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					// let binding "opts"
					tmp7 := checkDerefVar(glojure_DOT_core_apply)
					tmp8 := checkDerefVar(glojure_DOT_core_hash_map)
					tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
					var v10 any = tmp9
					_ = v10
					tmp11 := checkDerefVar(glojure_DOT_core_setup_reference)
					tmp12 := lang.Apply(tmp11, []any{v6, v4})
					_ = tmp12
					var tmp13 any
					tmp14 := lang.Apply(lang.NewKeyword("error-handler"), []any{v10})
					if lang.IsTruthy(tmp14) {
						tmp15 := lang.Apply(lang.NewKeyword("error-handler"), []any{v10})
						tmp16, _ := lang.FieldOrMethod(v6, "setErrorHandler")
						if reflect.TypeOf(tmp16).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorHandler is not a function")))
						}
						tmp17 := lang.Apply(tmp16, []any{tmp15})
						tmp13 = tmp17
					} else {
					}
					_ = tmp13
					var tmp18 any
					{ // let
						// let binding "or__0__auto__"
						tmp19 := lang.Apply(lang.NewKeyword("error-mode"), []any{v10})
						var v20 any = tmp19
						_ = v20
						var tmp21 any
						if lang.IsTruthy(v20) {
							tmp21 = v20
						} else {
							var tmp22 any
							tmp23 := lang.Apply(lang.NewKeyword("error-handler"), []any{v10})
							if lang.IsTruthy(tmp23) {
								tmp22 = lang.NewKeyword("continue")
							} else {
								tmp22 = lang.NewKeyword("fail")
							}
							tmp21 = tmp22
						}
						tmp18 = tmp21
					} // end let
					tmp19, _ := lang.FieldOrMethod(v6, "setErrorMode")
					if reflect.TypeOf(tmp19).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorMode is not a function")))
					}
					tmp20 := lang.Apply(tmp19, []any{tmp18})
					_ = tmp20
					tmp5 = v6
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// agent-error
	{
		tmp0 := lang.NewSymbol("agent-error").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("doc"), "Returns the exception thrown during an asynchronous action of the\n  agent if the agent is failed.  Returns nil if the agent is not\n  failed.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2167), lang.NewKeyword("end-line"), int(2167))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getError")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getError")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// agent-errors
	{
		tmp0 := lang.NewSymbol("agent-errors").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("doc"), "DEPRECATED: Use 'agent-error' instead.\n  Returns a sequence of the exceptions thrown during asynchronous\n  actions of the agent.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("deprecated"), "1.2", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2234), lang.NewKeyword("end-line"), int(2234))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_agent_error)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "e"
						var v10 any = v7
						_ = v10
						tmp11 := checkDerefVar(glojure_DOT_core_list)
						tmp12 := lang.Apply(tmp11, []any{v10})
						tmp9 = tmp12
					} // end let
					tmp8 = tmp9
				} else {
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aget
	{
		var tmp1 lang.FnFunc
		{ // function aget__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Aget")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := checkDerefVar(glojure_DOT_core_seq)
				tmp20 := checkDerefVar(glojure_DOT_core_concat)
				tmp21 := checkDerefVar(glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/int")})
				tmp23 := checkDerefVar(glojure_DOT_core_list)
				tmp24 := lang.Apply(tmp23, []any{v4})
				tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
				tmp26 := lang.Apply(tmp19, []any{tmp25})
				tmp27 := lang.Apply(tmp18, []any{tmp26})
				tmp28 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp27})
				tmp29 := lang.Apply(tmp12, []any{tmp28})
				tmp30 := lang.Apply(tmp11, []any{tmp29})
				tmp31 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp30})
				tmp32 := lang.Apply(tmp5, []any{tmp31})
				return tmp32
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("aget").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("&"), lang.NewSymbol("idxs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the value at the index/indices. Works on Java arrays of all\n  types.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3911), lang.NewKeyword("end-line"), int(3911))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.Get, []any{v4, v5})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_aget)
				tmp9 := checkDerefVar(glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alength
	{
		var tmp1 lang.FnFunc
		{ // function alength__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/Alength")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("alength").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the length of the Java array. Works on arrays of all\n  types.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3897), lang.NewKeyword("end-line"), int(3897))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime7.RT, "Alength")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Alength is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alias
	{
		tmp0 := lang.NewSymbol("alias").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("alias"), lang.NewSymbol("namespace-sym"))), lang.NewKeyword("doc"), "Add an alias in the current namespace to another\n  namespace. Arguments are two symbols: the alias to be used, and\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\n  to calling this directly.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4263), lang.NewKeyword("end-line"), int(4263))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
			tmp6 := checkDerefVar(glojure_DOT_core_the_ns)
			tmp7 := lang.Apply(tmp6, []any{v4})
			tmp8, _ := lang.FieldOrMethod(tmp5, "AddAlias")
			if reflect.TypeOf(tmp8).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddAlias is not a function")))
			}
			tmp9 := lang.Apply(tmp8, []any{v3, tmp7})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// all-ns
	{
		tmp0 := lang.NewSymbol("all-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Returns a sequence of all namespaces.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4146), lang.NewKeyword("end-line"), int(4146))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(nil, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter
	{
		tmp0 := lang.NewSymbol("alter").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("fun"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2435), lang.NewKeyword("end-line"), int(2435))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "alter")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("alter is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter-meta!
	{
		tmp0 := lang.NewSymbol("alter-meta!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("iref"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2398), lang.NewKeyword("end-line"), int(2398))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "AlterMeta")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("AlterMeta is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter-var-root
	{
		tmp0 := lang.NewSymbol("alter-var-root").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("v"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Atomically alters the root binding of var v by applying f to its\n  current value plus any args", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5484), lang.NewKeyword("end-line"), int(5484))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "alterRoot")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("alterRoot is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// amap
	{
		tmp0 := lang.NewSymbol("amap").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("idx"), lang.NewSymbol("ret"), lang.NewSymbol("expr"))), lang.NewKeyword("doc"), "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting \n  each element of ret to the evaluation of expr, returning the new \n  array ret.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5273), lang.NewKeyword("end-line"), int(5273))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 6 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			v8 := args[5]
			_ = v8
			tmp9 := checkDerefVar(glojure_DOT_core_seq)
			tmp10 := checkDerefVar(glojure_DOT_core_concat)
			tmp11 := checkDerefVar(glojure_DOT_core_list)
			tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("glojure.core/let")})
			tmp13 := checkDerefVar(glojure_DOT_core_list)
			tmp14 := checkDerefVar(glojure_DOT_core_apply)
			tmp15 := checkDerefVar(glojure_DOT_core_vector)
			tmp16 := checkDerefVar(glojure_DOT_core_seq)
			tmp17 := checkDerefVar(glojure_DOT_core_concat)
			tmp18 := checkDerefVar(glojure_DOT_core_list)
			tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol("a__0__auto__")})
			tmp20 := checkDerefVar(glojure_DOT_core_list)
			tmp21 := lang.Apply(tmp20, []any{v5})
			tmp22 := checkDerefVar(glojure_DOT_core_list)
			tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("l__1__auto__")})
			tmp24 := checkDerefVar(glojure_DOT_core_list)
			tmp25 := checkDerefVar(glojure_DOT_core_seq)
			tmp26 := checkDerefVar(glojure_DOT_core_concat)
			tmp27 := checkDerefVar(glojure_DOT_core_list)
			tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("glojure.core/alength")})
			tmp29 := checkDerefVar(glojure_DOT_core_list)
			tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("a__0__auto__")})
			tmp31 := lang.Apply(tmp26, []any{tmp28, tmp30})
			tmp32 := lang.Apply(tmp25, []any{tmp31})
			tmp33 := lang.Apply(tmp24, []any{tmp32})
			tmp34 := checkDerefVar(glojure_DOT_core_list)
			tmp35 := lang.Apply(tmp34, []any{v7})
			tmp36 := checkDerefVar(glojure_DOT_core_list)
			tmp37 := checkDerefVar(glojure_DOT_core_seq)
			tmp38 := checkDerefVar(glojure_DOT_core_concat)
			tmp39 := checkDerefVar(glojure_DOT_core_list)
			tmp40 := lang.Apply(tmp39, []any{lang.NewSymbol("glojure.core/aclone")})
			tmp41 := checkDerefVar(glojure_DOT_core_list)
			tmp42 := lang.Apply(tmp41, []any{lang.NewSymbol("a__0__auto__")})
			tmp43 := lang.Apply(tmp38, []any{tmp40, tmp42})
			tmp44 := lang.Apply(tmp37, []any{tmp43})
			tmp45 := lang.Apply(tmp36, []any{tmp44})
			tmp46 := lang.Apply(tmp17, []any{tmp19, tmp21, tmp23, tmp33, tmp35, tmp45})
			tmp47 := lang.Apply(tmp16, []any{tmp46})
			tmp48 := lang.Apply(tmp14, []any{tmp15, tmp47})
			tmp49 := lang.Apply(tmp13, []any{tmp48})
			tmp50 := checkDerefVar(glojure_DOT_core_list)
			tmp51 := checkDerefVar(glojure_DOT_core_seq)
			tmp52 := checkDerefVar(glojure_DOT_core_concat)
			tmp53 := checkDerefVar(glojure_DOT_core_list)
			tmp54 := lang.Apply(tmp53, []any{lang.NewSymbol("glojure.core/loop")})
			tmp55 := checkDerefVar(glojure_DOT_core_list)
			tmp56 := checkDerefVar(glojure_DOT_core_apply)
			tmp57 := checkDerefVar(glojure_DOT_core_vector)
			tmp58 := checkDerefVar(glojure_DOT_core_seq)
			tmp59 := checkDerefVar(glojure_DOT_core_concat)
			tmp60 := checkDerefVar(glojure_DOT_core_list)
			tmp61 := lang.Apply(tmp60, []any{v6})
			tmp62 := checkDerefVar(glojure_DOT_core_list)
			tmp63 := lang.Apply(tmp62, []any{int64(0)})
			tmp64 := lang.Apply(tmp59, []any{tmp61, tmp63})
			tmp65 := lang.Apply(tmp58, []any{tmp64})
			tmp66 := lang.Apply(tmp56, []any{tmp57, tmp65})
			tmp67 := lang.Apply(tmp55, []any{tmp66})
			tmp68 := checkDerefVar(glojure_DOT_core_list)
			tmp69 := checkDerefVar(glojure_DOT_core_seq)
			tmp70 := checkDerefVar(glojure_DOT_core_concat)
			tmp71 := checkDerefVar(glojure_DOT_core_list)
			tmp72 := lang.Apply(tmp71, []any{lang.NewSymbol("if")})
			tmp73 := checkDerefVar(glojure_DOT_core_list)
			tmp74 := checkDerefVar(glojure_DOT_core_seq)
			tmp75 := checkDerefVar(glojure_DOT_core_concat)
			tmp76 := checkDerefVar(glojure_DOT_core_list)
			tmp77 := lang.Apply(tmp76, []any{lang.NewSymbol("glojure.core/<")})
			tmp78 := checkDerefVar(glojure_DOT_core_list)
			tmp79 := lang.Apply(tmp78, []any{v6})
			tmp80 := checkDerefVar(glojure_DOT_core_list)
			tmp81 := lang.Apply(tmp80, []any{lang.NewSymbol("l__1__auto__")})
			tmp82 := lang.Apply(tmp75, []any{tmp77, tmp79, tmp81})
			tmp83 := lang.Apply(tmp74, []any{tmp82})
			tmp84 := lang.Apply(tmp73, []any{tmp83})
			tmp85 := checkDerefVar(glojure_DOT_core_list)
			tmp86 := checkDerefVar(glojure_DOT_core_seq)
			tmp87 := checkDerefVar(glojure_DOT_core_concat)
			tmp88 := checkDerefVar(glojure_DOT_core_list)
			tmp89 := lang.Apply(tmp88, []any{lang.NewSymbol("do")})
			tmp90 := checkDerefVar(glojure_DOT_core_list)
			tmp91 := checkDerefVar(glojure_DOT_core_seq)
			tmp92 := checkDerefVar(glojure_DOT_core_concat)
			tmp93 := checkDerefVar(glojure_DOT_core_list)
			tmp94 := lang.Apply(tmp93, []any{lang.NewSymbol("glojure.core/aset")})
			tmp95 := checkDerefVar(glojure_DOT_core_list)
			tmp96 := lang.Apply(tmp95, []any{v7})
			tmp97 := checkDerefVar(glojure_DOT_core_list)
			tmp98 := lang.Apply(tmp97, []any{v6})
			tmp99 := checkDerefVar(glojure_DOT_core_list)
			tmp100 := lang.Apply(tmp99, []any{v8})
			tmp101 := lang.Apply(tmp92, []any{tmp94, tmp96, tmp98, tmp100})
			tmp102 := lang.Apply(tmp91, []any{tmp101})
			tmp103 := lang.Apply(tmp90, []any{tmp102})
			tmp104 := checkDerefVar(glojure_DOT_core_list)
			tmp105 := checkDerefVar(glojure_DOT_core_seq)
			tmp106 := checkDerefVar(glojure_DOT_core_concat)
			tmp107 := checkDerefVar(glojure_DOT_core_list)
			tmp108 := lang.Apply(tmp107, []any{lang.NewSymbol("recur")})
			tmp109 := checkDerefVar(glojure_DOT_core_list)
			tmp110 := checkDerefVar(glojure_DOT_core_seq)
			tmp111 := checkDerefVar(glojure_DOT_core_concat)
			tmp112 := checkDerefVar(glojure_DOT_core_list)
			tmp113 := lang.Apply(tmp112, []any{lang.NewSymbol("glojure.core/unchecked-inc")})
			tmp114 := checkDerefVar(glojure_DOT_core_list)
			tmp115 := lang.Apply(tmp114, []any{v6})
			tmp116 := lang.Apply(tmp111, []any{tmp113, tmp115})
			tmp117 := lang.Apply(tmp110, []any{tmp116})
			tmp118 := lang.Apply(tmp109, []any{tmp117})
			tmp119 := lang.Apply(tmp106, []any{tmp108, tmp118})
			tmp120 := lang.Apply(tmp105, []any{tmp119})
			tmp121 := lang.Apply(tmp104, []any{tmp120})
			tmp122 := lang.Apply(tmp87, []any{tmp89, tmp103, tmp121})
			tmp123 := lang.Apply(tmp86, []any{tmp122})
			tmp124 := lang.Apply(tmp85, []any{tmp123})
			tmp125 := checkDerefVar(glojure_DOT_core_list)
			tmp126 := lang.Apply(tmp125, []any{v7})
			tmp127 := lang.Apply(tmp70, []any{tmp72, tmp84, tmp124, tmp126})
			tmp128 := lang.Apply(tmp69, []any{tmp127})
			tmp129 := lang.Apply(tmp68, []any{tmp128})
			tmp130 := lang.Apply(tmp52, []any{tmp54, tmp67, tmp129})
			tmp131 := lang.Apply(tmp51, []any{tmp130})
			tmp132 := lang.Apply(tmp50, []any{tmp131})
			tmp133 := lang.Apply(tmp10, []any{tmp12, tmp49, tmp132})
			tmp134 := lang.Apply(tmp9, []any{tmp133})
			return tmp134
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ancestors
	{
		tmp0 := lang.NewSymbol("ancestors").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("tag"))), lang.NewKeyword("doc"), "Returns the immediate and indirect parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5577), lang.NewKeyword("end-line"), int(5577))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_ancestors)
				tmp5 := checkDerefVar(glojure_DOT_core_global_hierarchy)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_not_empty)
				var tmp6 any
				{ // let
					// let binding "ta"
					tmp7 := checkDerefVar(glojure_DOT_core_get)
					tmp8 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
					tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					tmp12 := checkDerefVar(glojure_DOT_core_class_QMARK_)
					tmp13 := lang.Apply(tmp12, []any{v4})
					if lang.IsTruthy(tmp13) {
						var tmp14 any
						{ // let
							// let binding "superclasses"
							tmp15 := checkDerefVar(glojure_DOT_core_set)
							tmp16 := checkDerefVar(glojure_DOT_core_supers)
							tmp17 := lang.Apply(tmp16, []any{v4})
							tmp18 := lang.Apply(tmp15, []any{tmp17})
							var v19 any = tmp18
							_ = v19
							tmp20 := checkDerefVar(glojure_DOT_core_reduce1)
							tmp21 := checkDerefVar(glojure_DOT_core_into1)
							tmp22 := checkDerefVar(glojure_DOT_core_cons)
							tmp23 := checkDerefVar(glojure_DOT_core_map)
							var tmp24 lang.FnFunc
							tmp24 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v25 := args[0]
								_ = v25
								tmp26 := checkDerefVar(glojure_DOT_core_get)
								tmp27 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
								tmp28 := lang.Apply(tmp26, []any{tmp27, v25})
								return tmp28
							})
							tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5590), lang.NewKeyword("column"), int(32), lang.NewKeyword("end-line"), int(5590), lang.NewKeyword("end-column"), int(54))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp27 := lang.Apply(tmp23, []any{tmp26, v19})
							tmp28 := lang.Apply(tmp22, []any{v10, tmp27})
							tmp29 := lang.Apply(tmp20, []any{tmp21, v19, tmp28})
							tmp14 = tmp29
						} // end let
						tmp11 = tmp14
					} else {
						tmp11 = v10
					}
					tmp6 = tmp11
				} // end let
				tmp7 := lang.Apply(tmp5, []any{tmp6})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// and
	{
		tmp0 := lang.NewSymbol("and").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("next"))), lang.NewKeyword("doc"), "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(835), lang.NewKeyword("end-line"), int(835))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return true
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/let")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_apply)
				tmp13 := checkDerefVar(glojure_DOT_core_vector)
				tmp14 := checkDerefVar(glojure_DOT_core_seq)
				tmp15 := checkDerefVar(glojure_DOT_core_concat)
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("and__0__auto__")})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v5})
				tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
				tmp21 := lang.Apply(tmp14, []any{tmp20})
				tmp22 := lang.Apply(tmp12, []any{tmp13, tmp21})
				tmp23 := lang.Apply(tmp11, []any{tmp22})
				tmp24 := checkDerefVar(glojure_DOT_core_list)
				tmp25 := checkDerefVar(glojure_DOT_core_seq)
				tmp26 := checkDerefVar(glojure_DOT_core_concat)
				tmp27 := checkDerefVar(glojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("if")})
				tmp29 := checkDerefVar(glojure_DOT_core_list)
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("and__0__auto__")})
				tmp31 := checkDerefVar(glojure_DOT_core_list)
				tmp32 := checkDerefVar(glojure_DOT_core_seq)
				tmp33 := checkDerefVar(glojure_DOT_core_concat)
				tmp34 := checkDerefVar(glojure_DOT_core_list)
				tmp35 := lang.Apply(tmp34, []any{lang.NewSymbol("glojure.core/and")})
				tmp36 := lang.Apply(tmp33, []any{tmp35, v6})
				tmp37 := lang.Apply(tmp32, []any{tmp36})
				tmp38 := lang.Apply(tmp31, []any{tmp37})
				tmp39 := checkDerefVar(glojure_DOT_core_list)
				tmp40 := lang.Apply(tmp39, []any{lang.NewSymbol("and__0__auto__")})
				tmp41 := lang.Apply(tmp26, []any{tmp28, tmp30, tmp38, tmp40})
				tmp42 := lang.Apply(tmp25, []any{tmp41})
				tmp43 := lang.Apply(tmp24, []any{tmp42})
				tmp44 := lang.Apply(tmp8, []any{tmp10, tmp23, tmp43})
				tmp45 := lang.Apply(tmp7, []any{tmp44})
				return tmp45
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// any?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("any?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true given any argument.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(537), lang.NewKeyword("end-line"), int(537))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			return true
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// apply
	{
		tmp0 := lang.NewSymbol("apply").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("z"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Applies fn f to the argument list formed by prepending intervening arguments to args.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(653), lang.NewKeyword("end-line"), int(653))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7 := lang.Apply(lang.Apply, []any{v3, tmp6})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_list_STAR_)
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				tmp8 := lang.Apply(lang.Apply, []any{v3, tmp7})
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_list_STAR_)
				tmp8 := lang.Apply(tmp7, []any{v4, v5, v6})
				tmp9 := lang.Apply(lang.Apply, []any{v3, tmp8})
				return tmp9
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_list_STAR_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5, v6, v7})
				tmp10 := lang.Apply(lang.Apply, []any{v3, tmp9})
				return tmp10
			default:
				if len(args) < 5 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var v8 any = lang.NewList(args[5:]...)
				_ = v8
				tmp9 := checkDerefVar(glojure_DOT_core_cons)
				tmp10 := checkDerefVar(glojure_DOT_core_cons)
				tmp11 := checkDerefVar(glojure_DOT_core_cons)
				tmp12 := checkDerefVar(glojure_DOT_core_cons)
				tmp13 := checkDerefVar(glojure_DOT_core_spread)
				tmp14 := lang.Apply(tmp13, []any{v8})
				tmp15 := lang.Apply(tmp12, []any{v7, tmp14})
				tmp16 := lang.Apply(tmp11, []any{v6, tmp15})
				tmp17 := lang.Apply(tmp10, []any{v5, tmp16})
				tmp18 := lang.Apply(tmp9, []any{v4, tmp17})
				tmp19 := lang.Apply(lang.Apply, []any{v3, tmp18})
				return tmp19
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// areduce
	{
		tmp0 := lang.NewSymbol("areduce").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("idx"), lang.NewSymbol("ret"), lang.NewSymbol("init"), lang.NewSymbol("expr"))), lang.NewKeyword("doc"), "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the \n  evaluation of expr at each step, returning ret.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5289), lang.NewKeyword("end-line"), int(5289))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 7 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			v8 := args[5]
			_ = v8
			v9 := args[6]
			_ = v9
			tmp10 := checkDerefVar(glojure_DOT_core_seq)
			tmp11 := checkDerefVar(glojure_DOT_core_concat)
			tmp12 := checkDerefVar(glojure_DOT_core_list)
			tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("glojure.core/let")})
			tmp14 := checkDerefVar(glojure_DOT_core_list)
			tmp15 := checkDerefVar(glojure_DOT_core_apply)
			tmp16 := checkDerefVar(glojure_DOT_core_vector)
			tmp17 := checkDerefVar(glojure_DOT_core_seq)
			tmp18 := checkDerefVar(glojure_DOT_core_concat)
			tmp19 := checkDerefVar(glojure_DOT_core_list)
			tmp20 := lang.Apply(tmp19, []any{lang.NewSymbol("a__0__auto__")})
			tmp21 := checkDerefVar(glojure_DOT_core_list)
			tmp22 := lang.Apply(tmp21, []any{v5})
			tmp23 := checkDerefVar(glojure_DOT_core_list)
			tmp24 := lang.Apply(tmp23, []any{lang.NewSymbol("l__1__auto__")})
			tmp25 := checkDerefVar(glojure_DOT_core_list)
			tmp26 := checkDerefVar(glojure_DOT_core_seq)
			tmp27 := checkDerefVar(glojure_DOT_core_concat)
			tmp28 := checkDerefVar(glojure_DOT_core_list)
			tmp29 := lang.Apply(tmp28, []any{lang.NewSymbol("glojure.core/alength")})
			tmp30 := checkDerefVar(glojure_DOT_core_list)
			tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("a__0__auto__")})
			tmp32 := lang.Apply(tmp27, []any{tmp29, tmp31})
			tmp33 := lang.Apply(tmp26, []any{tmp32})
			tmp34 := lang.Apply(tmp25, []any{tmp33})
			tmp35 := lang.Apply(tmp18, []any{tmp20, tmp22, tmp24, tmp34})
			tmp36 := lang.Apply(tmp17, []any{tmp35})
			tmp37 := lang.Apply(tmp15, []any{tmp16, tmp36})
			tmp38 := lang.Apply(tmp14, []any{tmp37})
			tmp39 := checkDerefVar(glojure_DOT_core_list)
			tmp40 := checkDerefVar(glojure_DOT_core_seq)
			tmp41 := checkDerefVar(glojure_DOT_core_concat)
			tmp42 := checkDerefVar(glojure_DOT_core_list)
			tmp43 := lang.Apply(tmp42, []any{lang.NewSymbol("glojure.core/loop")})
			tmp44 := checkDerefVar(glojure_DOT_core_list)
			tmp45 := checkDerefVar(glojure_DOT_core_apply)
			tmp46 := checkDerefVar(glojure_DOT_core_vector)
			tmp47 := checkDerefVar(glojure_DOT_core_seq)
			tmp48 := checkDerefVar(glojure_DOT_core_concat)
			tmp49 := checkDerefVar(glojure_DOT_core_list)
			tmp50 := lang.Apply(tmp49, []any{v6})
			tmp51 := checkDerefVar(glojure_DOT_core_list)
			tmp52 := lang.Apply(tmp51, []any{int64(0)})
			tmp53 := checkDerefVar(glojure_DOT_core_list)
			tmp54 := lang.Apply(tmp53, []any{v7})
			tmp55 := checkDerefVar(glojure_DOT_core_list)
			tmp56 := lang.Apply(tmp55, []any{v8})
			tmp57 := lang.Apply(tmp48, []any{tmp50, tmp52, tmp54, tmp56})
			tmp58 := lang.Apply(tmp47, []any{tmp57})
			tmp59 := lang.Apply(tmp45, []any{tmp46, tmp58})
			tmp60 := lang.Apply(tmp44, []any{tmp59})
			tmp61 := checkDerefVar(glojure_DOT_core_list)
			tmp62 := checkDerefVar(glojure_DOT_core_seq)
			tmp63 := checkDerefVar(glojure_DOT_core_concat)
			tmp64 := checkDerefVar(glojure_DOT_core_list)
			tmp65 := lang.Apply(tmp64, []any{lang.NewSymbol("if")})
			tmp66 := checkDerefVar(glojure_DOT_core_list)
			tmp67 := checkDerefVar(glojure_DOT_core_seq)
			tmp68 := checkDerefVar(glojure_DOT_core_concat)
			tmp69 := checkDerefVar(glojure_DOT_core_list)
			tmp70 := lang.Apply(tmp69, []any{lang.NewSymbol("glojure.core/<")})
			tmp71 := checkDerefVar(glojure_DOT_core_list)
			tmp72 := lang.Apply(tmp71, []any{v6})
			tmp73 := checkDerefVar(glojure_DOT_core_list)
			tmp74 := lang.Apply(tmp73, []any{lang.NewSymbol("l__1__auto__")})
			tmp75 := lang.Apply(tmp68, []any{tmp70, tmp72, tmp74})
			tmp76 := lang.Apply(tmp67, []any{tmp75})
			tmp77 := lang.Apply(tmp66, []any{tmp76})
			tmp78 := checkDerefVar(glojure_DOT_core_list)
			tmp79 := checkDerefVar(glojure_DOT_core_seq)
			tmp80 := checkDerefVar(glojure_DOT_core_concat)
			tmp81 := checkDerefVar(glojure_DOT_core_list)
			tmp82 := lang.Apply(tmp81, []any{lang.NewSymbol("recur")})
			tmp83 := checkDerefVar(glojure_DOT_core_list)
			tmp84 := checkDerefVar(glojure_DOT_core_seq)
			tmp85 := checkDerefVar(glojure_DOT_core_concat)
			tmp86 := checkDerefVar(glojure_DOT_core_list)
			tmp87 := lang.Apply(tmp86, []any{lang.NewSymbol("glojure.core/unchecked-inc-int")})
			tmp88 := checkDerefVar(glojure_DOT_core_list)
			tmp89 := lang.Apply(tmp88, []any{v6})
			tmp90 := lang.Apply(tmp85, []any{tmp87, tmp89})
			tmp91 := lang.Apply(tmp84, []any{tmp90})
			tmp92 := lang.Apply(tmp83, []any{tmp91})
			tmp93 := checkDerefVar(glojure_DOT_core_list)
			tmp94 := lang.Apply(tmp93, []any{v9})
			tmp95 := lang.Apply(tmp80, []any{tmp82, tmp92, tmp94})
			tmp96 := lang.Apply(tmp79, []any{tmp95})
			tmp97 := lang.Apply(tmp78, []any{tmp96})
			tmp98 := checkDerefVar(glojure_DOT_core_list)
			tmp99 := lang.Apply(tmp98, []any{v7})
			tmp100 := lang.Apply(tmp63, []any{tmp65, tmp77, tmp97, tmp99})
			tmp101 := lang.Apply(tmp62, []any{tmp100})
			tmp102 := lang.Apply(tmp61, []any{tmp101})
			tmp103 := lang.Apply(tmp41, []any{tmp43, tmp60, tmp102})
			tmp104 := lang.Apply(tmp40, []any{tmp103})
			tmp105 := lang.Apply(tmp39, []any{tmp104})
			tmp106 := lang.Apply(tmp11, []any{tmp13, tmp38, tmp105})
			tmp107 := lang.Apply(tmp10, []any{tmp106})
			return tmp107
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// array
	{
		tmp0 := lang.NewSymbol("array").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3457), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(3458), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("items"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_into_array)
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// array-map
	{
		tmp0 := lang.NewSymbol("array-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keyvals"))), lang.NewKeyword("doc"), "Constructs an array-map. If any keys are equal, they are handled as\n  if by repeated uses of assoc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4378), lang.NewKeyword("end-line"), int(4378))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3, ok := lang.FieldOrMethod(nil, "EMPTY")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "EMPTY")))
				}
				var tmp4 any
				switch reflect.TypeOf(tmp3).Kind() {
				case reflect.Func:
					tmp4 = lang.Apply(tmp3, nil)
				default:
					tmp4 = tmp3
				}
				return tmp4
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "ary"
					tmp5 := checkDerefVar(glojure_DOT_core_to_array)
					tmp6 := lang.Apply(tmp5, []any{v3})
					var v7 any = tmp6
					_ = v7
					var tmp8 any
					tmp9 := checkDerefVar(glojure_DOT_core_odd_QMARK_)
					tmp10 := checkDerefVar(glojure_DOT_core_alength)
					tmp11 := lang.Apply(tmp10, []any{v7})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(glojure_DOT_core_str)
						tmp14 := checkDerefVar(glojure_DOT_core_last)
						tmp15 := lang.Apply(tmp14, []any{v3})
						tmp16 := lang.Apply(tmp13, []any{"No value supplied for key: ", tmp15})
						tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
						panic(tmp17)
					} else {
						tmp18 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{v7})
						tmp8 = tmp18
					}
					tmp4 = tmp8
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// as->
	{
		tmp0 := lang.NewSymbol("as->").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"), lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7598), lang.NewKeyword("end-line"), int(7598))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_seq)
				tmp9 := checkDerefVar(glojure_DOT_core_concat)
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/let")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := checkDerefVar(glojure_DOT_core_apply)
				tmp14 := checkDerefVar(glojure_DOT_core_vector)
				tmp15 := checkDerefVar(glojure_DOT_core_seq)
				tmp16 := checkDerefVar(glojure_DOT_core_concat)
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v6})
				tmp19 := checkDerefVar(glojure_DOT_core_list)
				tmp20 := lang.Apply(tmp19, []any{v5})
				tmp21 := checkDerefVar(glojure_DOT_core_interleave)
				tmp22 := checkDerefVar(glojure_DOT_core_repeat)
				tmp23 := lang.Apply(tmp22, []any{v6})
				tmp24 := checkDerefVar(glojure_DOT_core_butlast)
				tmp25 := lang.Apply(tmp24, []any{v7})
				tmp26 := lang.Apply(tmp21, []any{tmp23, tmp25})
				tmp27 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp26})
				tmp28 := lang.Apply(tmp15, []any{tmp27})
				tmp29 := lang.Apply(tmp13, []any{tmp14, tmp28})
				tmp30 := lang.Apply(tmp12, []any{tmp29})
				tmp31 := checkDerefVar(glojure_DOT_core_list)
				var tmp32 any
				tmp33 := checkDerefVar(glojure_DOT_core_empty_QMARK_)
				tmp34 := lang.Apply(tmp33, []any{v7})
				if lang.IsTruthy(tmp34) {
					tmp32 = v6
				} else {
					tmp35 := checkDerefVar(glojure_DOT_core_last)
					tmp36 := lang.Apply(tmp35, []any{v7})
					tmp32 = tmp36
				}
				tmp37 := lang.Apply(tmp31, []any{tmp32})
				tmp38 := lang.Apply(tmp9, []any{tmp11, tmp30, tmp37})
				tmp39 := lang.Apply(tmp8, []any{tmp38})
				return tmp39
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset
	{
		var tmp1 lang.FnFunc
		{ // function aset__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_concat)
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol(".")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := checkDerefVar(glojure_DOT_core_seq)
				tmp14 := checkDerefVar(glojure_DOT_core_concat)
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/Aset")})
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := checkDerefVar(glojure_DOT_core_list)
				tmp20 := checkDerefVar(glojure_DOT_core_seq)
				tmp21 := checkDerefVar(glojure_DOT_core_concat)
				tmp22 := checkDerefVar(glojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("glojure.core/int")})
				tmp24 := checkDerefVar(glojure_DOT_core_list)
				tmp25 := lang.Apply(tmp24, []any{v4})
				tmp26 := lang.Apply(tmp21, []any{tmp23, tmp25})
				tmp27 := lang.Apply(tmp20, []any{tmp26})
				tmp28 := lang.Apply(tmp19, []any{tmp27})
				tmp29 := checkDerefVar(glojure_DOT_core_list)
				tmp30 := lang.Apply(tmp29, []any{v5})
				tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp28, tmp30})
				tmp32 := lang.Apply(tmp13, []any{tmp31})
				tmp33 := lang.Apply(tmp12, []any{tmp32})
				tmp34 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp33})
				tmp35 := lang.Apply(tmp6, []any{tmp34})
				return tmp35
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("aset").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on Java arrays of\n  reference types. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(3)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3922), lang.NewKeyword("end-line"), int(3922))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(lang.SliceSet, []any{v4, v5, v6})
				_ = tmp7
				return v6
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				var v7 any = lang.NewList(args[3:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_apply)
				tmp9 := checkDerefVar(glojure_DOT_core_aset)
				tmp10 := checkDerefVar(glojure_DOT_core_aget)
				tmp11 := lang.Apply(tmp10, []any{v4, v5})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v6, v7})
				return tmp12
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-boolean
	{
		tmp0 := lang.NewSymbol("aset-boolean").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of boolean. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3956), lang.NewKeyword("end-line"), int(3958))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_boolean)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setBoolean")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setBoolean is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_aset_boolean)
				tmp9 := checkDerefVar(glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-byte
	{
		tmp0 := lang.NewSymbol("aset-byte").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of byte. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3976), lang.NewKeyword("end-line"), int(3978))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_byte)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setByte")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setByte is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_aset_byte)
				tmp9 := checkDerefVar(glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-char
	{
		tmp0 := lang.NewSymbol("aset-char").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of char. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3981), lang.NewKeyword("end-line"), int(3983))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_char)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setChar")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setChar is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_aset_char)
				tmp9 := checkDerefVar(glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-double
	{
		tmp0 := lang.NewSymbol("aset-double").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of double. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3966), lang.NewKeyword("end-line"), int(3968))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_double)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setDouble")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setDouble is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_aset_double)
				tmp9 := checkDerefVar(glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-float
	{
		tmp0 := lang.NewSymbol("aset-float").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of float. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3961), lang.NewKeyword("end-line"), int(3963))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_float)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setFloat")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setFloat is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_aset_float)
				tmp9 := checkDerefVar(glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-int
	{
		tmp0 := lang.NewSymbol("aset-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of int. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3946), lang.NewKeyword("end-line"), int(3948))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_int)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setInt")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setInt is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_aset_int)
				tmp9 := checkDerefVar(glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-long
	{
		tmp0 := lang.NewSymbol("aset-long").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of long. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3951), lang.NewKeyword("end-line"), int(3953))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_long)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setLong")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setLong is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_aset_long)
				tmp9 := checkDerefVar(glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-short
	{
		tmp0 := lang.NewSymbol("aset-short").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of short. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3971), lang.NewKeyword("end-line"), int(3973))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_short)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setShort")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setShort is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_aset_short)
				tmp9 := checkDerefVar(glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert
	{
		tmp0 := lang.NewSymbol("assert").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("message"))), lang.NewKeyword("doc"), "Evaluates expression x and throws an AssertionError with optional\n  message if x does not evaluate to logical true.\n\n  Assertion checks are omitted from compiled code if '*assert*' is\n  false.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4837), lang.NewKeyword("end-line"), int(4837))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(glojure_DOT_core__STAR_assert_STAR_)
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/when-not")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{v5})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("throw")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("new")})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{lang.NewSymbol("glojure.core/AssertionError")})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := checkDerefVar(glojure_DOT_core_seq)
					tmp28 := checkDerefVar(glojure_DOT_core_concat)
					tmp29 := checkDerefVar(glojure_DOT_core_list)
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/str")})
					tmp31 := checkDerefVar(glojure_DOT_core_list)
					tmp32 := lang.Apply(tmp31, []any{"Assert failed: "})
					tmp33 := checkDerefVar(glojure_DOT_core_list)
					tmp34 := checkDerefVar(glojure_DOT_core_seq)
					tmp35 := checkDerefVar(glojure_DOT_core_concat)
					tmp36 := checkDerefVar(glojure_DOT_core_list)
					tmp37 := lang.Apply(tmp36, []any{lang.NewSymbol("glojure.core/pr-str")})
					tmp38 := checkDerefVar(glojure_DOT_core_list)
					tmp39 := checkDerefVar(glojure_DOT_core_seq)
					tmp40 := checkDerefVar(glojure_DOT_core_concat)
					tmp41 := checkDerefVar(glojure_DOT_core_list)
					tmp42 := lang.Apply(tmp41, []any{lang.NewSymbol("quote")})
					tmp43 := checkDerefVar(glojure_DOT_core_list)
					tmp44 := lang.Apply(tmp43, []any{v5})
					tmp45 := lang.Apply(tmp40, []any{tmp42, tmp44})
					tmp46 := lang.Apply(tmp39, []any{tmp45})
					tmp47 := lang.Apply(tmp38, []any{tmp46})
					tmp48 := lang.Apply(tmp35, []any{tmp37, tmp47})
					tmp49 := lang.Apply(tmp34, []any{tmp48})
					tmp50 := lang.Apply(tmp33, []any{tmp49})
					tmp51 := lang.Apply(tmp28, []any{tmp30, tmp32, tmp50})
					tmp52 := lang.Apply(tmp27, []any{tmp51})
					tmp53 := lang.Apply(tmp26, []any{tmp52})
					tmp54 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp53})
					tmp55 := lang.Apply(tmp20, []any{tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp16, []any{tmp18, tmp56})
					tmp58 := lang.Apply(tmp15, []any{tmp57})
					tmp59 := lang.Apply(tmp14, []any{tmp58})
					tmp60 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp59})
					tmp61 := lang.Apply(tmp8, []any{tmp60})
					tmp6 = tmp61
				} else {
				}
				return tmp6
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core__STAR_assert_STAR_)
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(glojure_DOT_core_seq)
					tmp10 := checkDerefVar(glojure_DOT_core_concat)
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("glojure.core/when-not")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := lang.Apply(tmp13, []any{v5})
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := checkDerefVar(glojure_DOT_core_seq)
					tmp17 := checkDerefVar(glojure_DOT_core_concat)
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol("throw")})
					tmp20 := checkDerefVar(glojure_DOT_core_list)
					tmp21 := checkDerefVar(glojure_DOT_core_seq)
					tmp22 := checkDerefVar(glojure_DOT_core_concat)
					tmp23 := checkDerefVar(glojure_DOT_core_list)
					tmp24 := lang.Apply(tmp23, []any{lang.NewSymbol("new")})
					tmp25 := checkDerefVar(glojure_DOT_core_list)
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol("glojure.core/AssertionError")})
					tmp27 := checkDerefVar(glojure_DOT_core_list)
					tmp28 := checkDerefVar(glojure_DOT_core_seq)
					tmp29 := checkDerefVar(glojure_DOT_core_concat)
					tmp30 := checkDerefVar(glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/str")})
					tmp32 := checkDerefVar(glojure_DOT_core_list)
					tmp33 := lang.Apply(tmp32, []any{"Assert failed: "})
					tmp34 := checkDerefVar(glojure_DOT_core_list)
					tmp35 := lang.Apply(tmp34, []any{v6})
					tmp36 := checkDerefVar(glojure_DOT_core_list)
					tmp37 := lang.Apply(tmp36, []any{"\n"})
					tmp38 := checkDerefVar(glojure_DOT_core_list)
					tmp39 := checkDerefVar(glojure_DOT_core_seq)
					tmp40 := checkDerefVar(glojure_DOT_core_concat)
					tmp41 := checkDerefVar(glojure_DOT_core_list)
					tmp42 := lang.Apply(tmp41, []any{lang.NewSymbol("glojure.core/pr-str")})
					tmp43 := checkDerefVar(glojure_DOT_core_list)
					tmp44 := checkDerefVar(glojure_DOT_core_seq)
					tmp45 := checkDerefVar(glojure_DOT_core_concat)
					tmp46 := checkDerefVar(glojure_DOT_core_list)
					tmp47 := lang.Apply(tmp46, []any{lang.NewSymbol("quote")})
					tmp48 := checkDerefVar(glojure_DOT_core_list)
					tmp49 := lang.Apply(tmp48, []any{v5})
					tmp50 := lang.Apply(tmp45, []any{tmp47, tmp49})
					tmp51 := lang.Apply(tmp44, []any{tmp50})
					tmp52 := lang.Apply(tmp43, []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp42, tmp52})
					tmp54 := lang.Apply(tmp39, []any{tmp53})
					tmp55 := lang.Apply(tmp38, []any{tmp54})
					tmp56 := lang.Apply(tmp29, []any{tmp31, tmp33, tmp35, tmp37, tmp55})
					tmp57 := lang.Apply(tmp28, []any{tmp56})
					tmp58 := lang.Apply(tmp27, []any{tmp57})
					tmp59 := lang.Apply(tmp22, []any{tmp24, tmp26, tmp58})
					tmp60 := lang.Apply(tmp21, []any{tmp59})
					tmp61 := lang.Apply(tmp20, []any{tmp60})
					tmp62 := lang.Apply(tmp17, []any{tmp19, tmp61})
					tmp63 := lang.Apply(tmp16, []any{tmp62})
					tmp64 := lang.Apply(tmp15, []any{tmp63})
					tmp65 := lang.Apply(tmp10, []any{tmp12, tmp14, tmp64})
					tmp66 := lang.Apply(tmp9, []any{tmp65})
					tmp7 = tmp66
				} else {
				}
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert-args
	{
		tmp0 := lang.NewSymbol("assert-args").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("pairs"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(38), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1830), lang.NewKeyword("end-line"), int(1830), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_concat)
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("do")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/when-not")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := checkDerefVar(glojure_DOT_core_first)
				tmp17 := lang.Apply(tmp16, []any{v5})
				tmp18 := lang.Apply(tmp15, []any{tmp17})
				tmp19 := checkDerefVar(glojure_DOT_core_list)
				tmp20 := checkDerefVar(glojure_DOT_core_seq)
				tmp21 := checkDerefVar(glojure_DOT_core_concat)
				tmp22 := checkDerefVar(glojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("throw")})
				tmp24 := checkDerefVar(glojure_DOT_core_list)
				tmp25 := checkDerefVar(glojure_DOT_core_seq)
				tmp26 := checkDerefVar(glojure_DOT_core_concat)
				tmp27 := checkDerefVar(glojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewIllegalArgumentError")})
				tmp29 := checkDerefVar(glojure_DOT_core_list)
				tmp30 := checkDerefVar(glojure_DOT_core_seq)
				tmp31 := checkDerefVar(glojure_DOT_core_concat)
				tmp32 := checkDerefVar(glojure_DOT_core_list)
				tmp33 := lang.Apply(tmp32, []any{lang.NewSymbol("glojure.core/str")})
				tmp34 := checkDerefVar(glojure_DOT_core_list)
				tmp35 := checkDerefVar(glojure_DOT_core_seq)
				tmp36 := checkDerefVar(glojure_DOT_core_concat)
				tmp37 := checkDerefVar(glojure_DOT_core_list)
				tmp38 := lang.Apply(tmp37, []any{lang.NewSymbol("glojure.core/first")})
				tmp39 := checkDerefVar(glojure_DOT_core_list)
				tmp40 := lang.Apply(tmp39, []any{lang.NewSymbol("&form")})
				tmp41 := lang.Apply(tmp36, []any{tmp38, tmp40})
				tmp42 := lang.Apply(tmp35, []any{tmp41})
				tmp43 := lang.Apply(tmp34, []any{tmp42})
				tmp44 := checkDerefVar(glojure_DOT_core_list)
				tmp45 := lang.Apply(tmp44, []any{" requires "})
				tmp46 := checkDerefVar(glojure_DOT_core_list)
				tmp47 := checkDerefVar(glojure_DOT_core_second)
				tmp48 := lang.Apply(tmp47, []any{v5})
				tmp49 := lang.Apply(tmp46, []any{tmp48})
				tmp50 := checkDerefVar(glojure_DOT_core_list)
				tmp51 := lang.Apply(tmp50, []any{" in "})
				tmp52 := checkDerefVar(glojure_DOT_core_list)
				tmp53 := lang.Apply(tmp52, []any{lang.NewSymbol("*ns*")})
				tmp54 := checkDerefVar(glojure_DOT_core_list)
				tmp55 := lang.Apply(tmp54, []any{":"})
				tmp56 := checkDerefVar(glojure_DOT_core_list)
				tmp57 := checkDerefVar(glojure_DOT_core_seq)
				tmp58 := checkDerefVar(glojure_DOT_core_concat)
				tmp59 := checkDerefVar(glojure_DOT_core_list)
				tmp60 := lang.Apply(tmp59, []any{lang.NewKeyword("line")})
				tmp61 := checkDerefVar(glojure_DOT_core_list)
				tmp62 := checkDerefVar(glojure_DOT_core_seq)
				tmp63 := checkDerefVar(glojure_DOT_core_concat)
				tmp64 := checkDerefVar(glojure_DOT_core_list)
				tmp65 := lang.Apply(tmp64, []any{lang.NewSymbol("glojure.core/meta")})
				tmp66 := checkDerefVar(glojure_DOT_core_list)
				tmp67 := lang.Apply(tmp66, []any{lang.NewSymbol("&form")})
				tmp68 := lang.Apply(tmp63, []any{tmp65, tmp67})
				tmp69 := lang.Apply(tmp62, []any{tmp68})
				tmp70 := lang.Apply(tmp61, []any{tmp69})
				tmp71 := lang.Apply(tmp58, []any{tmp60, tmp70})
				tmp72 := lang.Apply(tmp57, []any{tmp71})
				tmp73 := lang.Apply(tmp56, []any{tmp72})
				tmp74 := lang.Apply(tmp31, []any{tmp33, tmp43, tmp45, tmp49, tmp51, tmp53, tmp55, tmp73})
				tmp75 := lang.Apply(tmp30, []any{tmp74})
				tmp76 := lang.Apply(tmp29, []any{tmp75})
				tmp77 := lang.Apply(tmp26, []any{tmp28, tmp76})
				tmp78 := lang.Apply(tmp25, []any{tmp77})
				tmp79 := lang.Apply(tmp24, []any{tmp78})
				tmp80 := lang.Apply(tmp21, []any{tmp23, tmp79})
				tmp81 := lang.Apply(tmp20, []any{tmp80})
				tmp82 := lang.Apply(tmp19, []any{tmp81})
				tmp83 := lang.Apply(tmp12, []any{tmp14, tmp18, tmp82})
				tmp84 := lang.Apply(tmp11, []any{tmp83})
				tmp85 := lang.Apply(tmp10, []any{tmp84})
				tmp86 := checkDerefVar(glojure_DOT_core_list)
				var tmp87 any
				{ // let
					// let binding "more"
					tmp88 := checkDerefVar(glojure_DOT_core_nnext)
					tmp89 := lang.Apply(tmp88, []any{v5})
					var v90 any = tmp89
					_ = v90
					var tmp91 any
					if lang.IsTruthy(v90) {
						tmp92 := checkDerefVar(glojure_DOT_core_list_STAR_)
						tmp93 := lang.Apply(tmp92, []any{lang.NewSymbol("glojure.core/assert-args"), v90})
						tmp91 = tmp93
					} else {
					}
					tmp87 = tmp91
				} // end let
				tmp88 := lang.Apply(tmp86, []any{tmp87})
				tmp89 := lang.Apply(tmp7, []any{tmp9, tmp85, tmp88})
				tmp90 := lang.Apply(tmp6, []any{tmp89})
				return tmp90
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert-valid-fdecl
	{
		tmp0 := lang.NewSymbol("assert-valid-fdecl").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("fdecl"))), lang.NewKeyword("doc"), "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(42), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(7502), lang.NewKeyword("end-line"), int(7502), lang.NewKeyword("private"), true, lang.NewKeyword("dynamic"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_empty_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := lang.Apply(lang.NewIllegalArgumentError, []any{"Parameter declaration missing"})
				panic(tmp7)
			} else {
			}
			_ = tmp4
			var tmp8 any
			{ // let
				// let binding "argdecls"
				tmp9 := checkDerefVar(glojure_DOT_core_map)
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v11 := args[0]
					_ = v11
					var tmp12 any
					tmp13 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
					tmp14 := lang.Apply(tmp13, []any{v11})
					if lang.IsTruthy(tmp14) {
						tmp15 := checkDerefVar(glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v11})
						tmp12 = tmp16
					} else {
						var tmp17 any
						tmp18 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
						tmp19 := checkDerefVar(glojure_DOT_core_first)
						tmp20 := lang.Apply(tmp19, []any{v3})
						tmp21 := lang.Apply(tmp18, []any{tmp20})
						if lang.IsTruthy(tmp21) {
							tmp22 := checkDerefVar(glojure_DOT_core_str)
							tmp23 := lang.Apply(tmp22, []any{"Invalid signature \"", v11, "\" should be a list"})
							tmp17 = tmp23
						} else {
							tmp24 := checkDerefVar(glojure_DOT_core_str)
							tmp25 := lang.Apply(tmp24, []any{"Parameter declaration \"", v11, "\" should be a vector"})
							tmp17 = tmp25
						}
						tmp26 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
						panic(tmp26)
					}
					return tmp12
				})
				tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7508), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7517), lang.NewKeyword("end-column"), int(59))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := lang.Apply(tmp9, []any{tmp12, v3})
				var v14 any = tmp13
				_ = v14
				// let binding "bad-args"
				tmp15 := checkDerefVar(glojure_DOT_core_seq)
				tmp16 := checkDerefVar(glojure_DOT_core_remove)
				var tmp17 lang.FnFunc
				tmp17 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v18 := args[0]
					_ = v18
					tmp19 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
					tmp20 := lang.Apply(tmp19, []any{v18})
					return tmp20
				})
				tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7519), lang.NewKeyword("column"), int(31), lang.NewKeyword("end-line"), int(7519), lang.NewKeyword("end-column"), int(42))
				tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp20 := lang.Apply(tmp16, []any{tmp19, v14})
				tmp21 := lang.Apply(tmp15, []any{tmp20})
				var v22 any = tmp21
				_ = v22
				var tmp23 any
				if lang.IsTruthy(v22) {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v22})
					tmp27 := lang.Apply(tmp24, []any{"Parameter declaration \"", tmp26, "\" should be a vector"})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				} else {
				}
				tmp8 = tmp23
			} // end let
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc
	{
		tmp0 := lang.NewSymbol("assoc").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"), lang.NewSymbol("val"), lang.NewSymbol("&"), lang.NewSymbol("kvs"))), lang.NewKeyword("doc"), "assoc[iate]. When applied to a map, returns a new map of the\n    same (hashed/sorted) type, that contains the mapping of key(s) to\n    val(s). When applied to a vector, returns a new vector that\n    contains val at index. Note - index must be <= (count vector).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(181), lang.NewKeyword("end-line"), int(188))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function assoc
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 3:
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					tmp7 := lang.Apply(lang.Assoc, []any{v4, v5, v6})
					return tmp7
				default:
					if len(args) < 3 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					var v7 any = lang.NewList(args[3:]...)
					_ = v7
				recur_loop_24:
					var tmp8 any
					{ // let
						// let binding "ret"
						tmp9 := lang.Apply(lang.Assoc, []any{v4, v5, v6})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v7) {
							var tmp12 any
							tmp13 := checkDerefVar(glojure_DOT_core_next)
							tmp14 := lang.Apply(tmp13, []any{v7})
							if lang.IsTruthy(tmp14) {
								var tmp15 any = v10
								tmp17 := checkDerefVar(glojure_DOT_core_first)
								tmp18 := lang.Apply(tmp17, []any{v7})
								var tmp16 any = tmp18
								tmp20 := checkDerefVar(glojure_DOT_core_second)
								tmp21 := lang.Apply(tmp20, []any{v7})
								var tmp19 any = tmp21
								tmp23 := checkDerefVar(glojure_DOT_core_nnext)
								tmp24 := lang.Apply(tmp23, []any{v7})
								var tmp22 any = tmp24
								v4 = tmp15
								v5 = tmp16
								v6 = tmp19
								v7 = tmp22
								goto recur_loop_24
							} else {
								tmp25 := lang.Apply(lang.NewIllegalArgumentError, []any{"assoc expects even number of arguments after map/vector, found odd number"})
								panic(tmp25)
							}
							tmp11 = tmp12
						} else {
							tmp11 = v10
						}
						tmp8 = tmp11
					} // end let
					return tmp8
				}
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(189), lang.NewKeyword("column"), int(2), lang.NewKeyword("end-line"), int(198), lang.NewKeyword("end-column"), int(15))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc!
	{
		tmp0 := lang.NewSymbol("assoc!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("key"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("key"), lang.NewSymbol("val"), lang.NewSymbol("&"), lang.NewSymbol("kvs"))), lang.NewKeyword("doc"), "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3369), lang.NewKeyword("end-line"), int(3369))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "Assoc")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Assoc is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
			recur_loop_609:
				var tmp7 any
				{ // let
					// let binding "ret"
					tmp8, _ := lang.FieldOrMethod(v3, "Assoc")
					if reflect.TypeOf(tmp8).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Assoc is not a function")))
					}
					tmp9 := lang.Apply(tmp8, []any{v4, v5})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v6) {
						var tmp12 any = v10
						tmp14 := checkDerefVar(glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v6})
						var tmp13 any = tmp15
						tmp17 := checkDerefVar(glojure_DOT_core_second)
						tmp18 := lang.Apply(tmp17, []any{v6})
						var tmp16 any = tmp18
						tmp20 := checkDerefVar(glojure_DOT_core_nnext)
						tmp21 := lang.Apply(tmp20, []any{v6})
						var tmp19 any = tmp21
						v3 = tmp12
						v4 = tmp13
						v5 = tmp16
						v6 = tmp19
						goto recur_loop_609
					} else {
						tmp11 = v10
					}
					tmp7 = tmp11
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc-in
	{
		tmp0 := lang.NewSymbol("assoc-in").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("&"), lang.NewSymbol("ks")), lang.NewSymbol("v"))), lang.NewKeyword("doc"), "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6147), lang.NewKeyword("end-line"), int(6147))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "vec__138"
				var v7 any = v4
				_ = v7
				// let binding "seq__139"
				tmp8 := checkDerefVar(glojure_DOT_core_seq)
				tmp9 := lang.Apply(tmp8, []any{v7})
				var v10 any = tmp9
				_ = v10
				// let binding "first__140"
				tmp11 := checkDerefVar(glojure_DOT_core_first)
				tmp12 := lang.Apply(tmp11, []any{v10})
				var v13 any = tmp12
				_ = v13
				// let binding "seq__139"
				tmp14 := checkDerefVar(glojure_DOT_core_next)
				tmp15 := lang.Apply(tmp14, []any{v10})
				var v16 any = tmp15
				_ = v16
				// let binding "k"
				var v17 any = v13
				_ = v17
				// let binding "ks"
				var v18 any = v16
				_ = v18
				var tmp19 any
				if lang.IsTruthy(v18) {
					tmp20 := checkDerefVar(glojure_DOT_core_assoc)
					tmp21 := checkDerefVar(glojure_DOT_core_assoc_in)
					tmp22 := checkDerefVar(glojure_DOT_core_get)
					tmp23 := lang.Apply(tmp22, []any{v3, v17})
					tmp24 := lang.Apply(tmp21, []any{tmp23, v18, v5})
					tmp25 := lang.Apply(tmp20, []any{v3, v17, tmp24})
					tmp19 = tmp25
				} else {
					tmp26 := checkDerefVar(glojure_DOT_core_assoc)
					tmp27 := lang.Apply(tmp26, []any{v3, v17, v5})
					tmp19 = tmp27
				}
				tmp6 = tmp19
			} // end let
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// associative?
	{
		tmp0 := lang.NewSymbol("associative?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll implements Associative", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6223), lang.NewKeyword("end-line"), int(6223))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// atom
	{
		tmp0 := lang.NewSymbol("atom").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2325), lang.NewKeyword("end-line"), int(2325))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(lang.NewAtom, []any{v3})
				return tmp4
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_setup_reference)
				tmp6 := checkDerefVar(glojure_DOT_core_atom)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := lang.Apply(tmp5, []any{tmp7, v4})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await
	{
		tmp0 := lang.NewSymbol("await").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("agents"))), lang.NewKeyword("doc"), "Blocks the current thread (indefinitely!) until all actions\n  dispatched thus far, from this thread or agent, to the agent(s) have\n  occurred.  Will block on failed agents.  Will never return if\n  a failed agent is restarted with :clear-actions true or shutdown-agents was called.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3267), lang.NewKeyword("end-line"), int(3267))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				tmp5 := lang.Apply(nil, nil)
				if lang.IsTruthy(tmp5) {
					panic("unimplemented: new with non-constant class type")
				} else {
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_agent_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp8 := lang.Apply(errors8.New, []any{"Can't await in agent action"})
						panic(tmp8)
					} else {
					}
					_ = tmp6
					var tmp9 any
					{ // let
						// let binding "latch"
						var v10 any = "unimplemented: new with non-constant class type"
						_ = v10
						// let binding "count-down"
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v12 := args[0]
							_ = v12
							tmp13, _ := lang.FieldOrMethod(v10, "countDown")
							if reflect.TypeOf(tmp13).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("countDown is not a function")))
							}
							tmp14 := lang.Apply(tmp13, []any{})
							_ = tmp14
							return v12
						})
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3279), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(3279), lang.NewKeyword("end-column"), int(61))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v14 any = tmp13
						_ = v14
						var tmp15 any
						{ // let
							// let binding "seq_1"
							tmp16 := checkDerefVar(glojure_DOT_core_seq)
							tmp17 := lang.Apply(tmp16, []any{v3})
							var v18 any = tmp17
							_ = v18
							// let binding "chunk_2"
							var v19 any = nil
							_ = v19
							// let binding "count_3"
							var v20 any = int64(0)
							_ = v20
							// let binding "i_4"
							var v21 any = int64(0)
							_ = v21
							for {
								var tmp22 any
								tmp23 := checkDerefVar(glojure_DOT_core__LT_)
								tmp24 := lang.Apply(tmp23, []any{v21, v20})
								if lang.IsTruthy(tmp24) {
									var tmp25 any
									{ // let
										// let binding "agent"
										tmp26, _ := lang.FieldOrMethod(v19, "nth")
										if reflect.TypeOf(tmp26).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
										}
										tmp27 := lang.Apply(tmp26, []any{v21})
										var v28 any = tmp27
										_ = v28
										tmp29 := checkDerefVar(glojure_DOT_core_send)
										tmp30 := lang.Apply(tmp29, []any{v28, v14})
										_ = tmp30
										var tmp31 any = v18
										var tmp32 any = v19
										var tmp33 any = v20
										tmp35 := checkDerefVar(glojure_DOT_core_unchecked_inc)
										tmp36 := lang.Apply(tmp35, []any{v21})
										var tmp34 any = tmp36
										v18 = tmp31
										v19 = tmp32
										v20 = tmp33
										v21 = tmp34
										continue
									} // end let
									tmp22 = tmp25
								} else {
									var tmp26 any
									{ // let
										// let binding "temp__0__auto__"
										tmp27 := checkDerefVar(glojure_DOT_core_seq)
										tmp28 := lang.Apply(tmp27, []any{v18})
										var v29 any = tmp28
										_ = v29
										var tmp30 any
										if lang.IsTruthy(v29) {
											var tmp31 any
											{ // let
												// let binding "seq_1"
												var v32 any = v29
												_ = v32
												var tmp33 any
												tmp34 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
												tmp35 := lang.Apply(tmp34, []any{v32})
												if lang.IsTruthy(tmp35) {
													var tmp36 any
													{ // let
														// let binding "c__0__auto__"
														tmp37 := checkDerefVar(glojure_DOT_core_chunk_first)
														tmp38 := lang.Apply(tmp37, []any{v32})
														var v39 any = tmp38
														_ = v39
														tmp41 := checkDerefVar(glojure_DOT_core_chunk_rest)
														tmp42 := lang.Apply(tmp41, []any{v32})
														var tmp40 any = tmp42
														var tmp43 any = v39
														tmp45 := checkDerefVar(glojure_DOT_core_int)
														tmp46 := checkDerefVar(glojure_DOT_core_count)
														tmp47 := lang.Apply(tmp46, []any{v39})
														tmp48 := lang.Apply(tmp45, []any{tmp47})
														var tmp44 any = tmp48
														tmp50 := checkDerefVar(glojure_DOT_core_int)
														tmp51 := lang.Apply(tmp50, []any{int64(0)})
														var tmp49 any = tmp51
														v18 = tmp40
														v19 = tmp43
														v20 = tmp44
														v21 = tmp49
														continue
													} // end let
													tmp33 = tmp36
												} else {
													var tmp37 any
													{ // let
														// let binding "agent"
														tmp38 := checkDerefVar(glojure_DOT_core_first)
														tmp39 := lang.Apply(tmp38, []any{v32})
														var v40 any = tmp39
														_ = v40
														tmp41 := checkDerefVar(glojure_DOT_core_send)
														tmp42 := lang.Apply(tmp41, []any{v40, v14})
														_ = tmp42
														tmp44 := checkDerefVar(glojure_DOT_core_next)
														tmp45 := lang.Apply(tmp44, []any{v32})
														var tmp43 any = tmp45
														var tmp46 any = nil
														var tmp47 any = int64(0)
														var tmp48 any = int64(0)
														v18 = tmp43
														v19 = tmp46
														v20 = tmp47
														v21 = tmp48
														continue
													} // end let
													tmp33 = tmp37
												}
												tmp31 = tmp33
											} // end let
											tmp30 = tmp31
										} else {
										}
										tmp26 = tmp30
									} // end let
									tmp22 = tmp26
								}
								tmp15 = tmp22
								break
							}
						} // end let
						_ = tmp15
						tmp16, _ := lang.FieldOrMethod(v10, "await")
						if reflect.TypeOf(tmp16).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
						}
						tmp17 := lang.Apply(tmp16, []any{})
						tmp9 = tmp17
					} // end let
					tmp4 = tmp9
				}
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await-for
	{
		tmp0 := lang.NewSymbol("await-for").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("timeout-ms"), lang.NewSymbol("&"), lang.NewSymbol("agents"))), lang.NewKeyword("doc"), "Blocks the current thread until all actions dispatched thus\n  far (from this thread or agent) to the agents have occurred, or the\n  timeout (in milliseconds) has elapsed. Returns logical false if\n  returning due to timeout, logical true otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3289), lang.NewKeyword("end-line"), int(3289))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				tmp6 := lang.Apply(nil, nil)
				if lang.IsTruthy(tmp6) {
					panic("unimplemented: new with non-constant class type")
				} else {
					var tmp7 any
					tmp8 := checkDerefVar(glojure_DOT_core__STAR_agent_STAR_)
					if lang.IsTruthy(tmp8) {
						tmp9 := lang.Apply(errors8.New, []any{"Can't await in agent action"})
						panic(tmp9)
					} else {
					}
					_ = tmp7
					var tmp10 any
					{ // let
						// let binding "latch"
						var v11 any = "unimplemented: new with non-constant class type"
						_ = v11
						// let binding "count-down"
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v13 := args[0]
							_ = v13
							tmp14, _ := lang.FieldOrMethod(v11, "countDown")
							if reflect.TypeOf(tmp14).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("countDown is not a function")))
							}
							tmp15 := lang.Apply(tmp14, []any{})
							_ = tmp15
							return v13
						})
						tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3301), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(3301), lang.NewKeyword("end-column"), int(62))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						{ // let
							// let binding "seq_5"
							tmp17 := checkDerefVar(glojure_DOT_core_seq)
							tmp18 := lang.Apply(tmp17, []any{v4})
							var v19 any = tmp18
							_ = v19
							// let binding "chunk_6"
							var v20 any = nil
							_ = v20
							// let binding "count_7"
							var v21 any = int64(0)
							_ = v21
							// let binding "i_8"
							var v22 any = int64(0)
							_ = v22
							for {
								var tmp23 any
								tmp24 := checkDerefVar(glojure_DOT_core__LT_)
								tmp25 := lang.Apply(tmp24, []any{v22, v21})
								if lang.IsTruthy(tmp25) {
									var tmp26 any
									{ // let
										// let binding "agent"
										tmp27, _ := lang.FieldOrMethod(v20, "nth")
										if reflect.TypeOf(tmp27).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
										}
										tmp28 := lang.Apply(tmp27, []any{v22})
										var v29 any = tmp28
										_ = v29
										tmp30 := checkDerefVar(glojure_DOT_core_send)
										tmp31 := lang.Apply(tmp30, []any{v29, v15})
										_ = tmp31
										var tmp32 any = v19
										var tmp33 any = v20
										var tmp34 any = v21
										tmp36 := checkDerefVar(glojure_DOT_core_unchecked_inc)
										tmp37 := lang.Apply(tmp36, []any{v22})
										var tmp35 any = tmp37
										v19 = tmp32
										v20 = tmp33
										v21 = tmp34
										v22 = tmp35
										continue
									} // end let
									tmp23 = tmp26
								} else {
									var tmp27 any
									{ // let
										// let binding "temp__0__auto__"
										tmp28 := checkDerefVar(glojure_DOT_core_seq)
										tmp29 := lang.Apply(tmp28, []any{v19})
										var v30 any = tmp29
										_ = v30
										var tmp31 any
										if lang.IsTruthy(v30) {
											var tmp32 any
											{ // let
												// let binding "seq_5"
												var v33 any = v30
												_ = v33
												var tmp34 any
												tmp35 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
												tmp36 := lang.Apply(tmp35, []any{v33})
												if lang.IsTruthy(tmp36) {
													var tmp37 any
													{ // let
														// let binding "c__0__auto__"
														tmp38 := checkDerefVar(glojure_DOT_core_chunk_first)
														tmp39 := lang.Apply(tmp38, []any{v33})
														var v40 any = tmp39
														_ = v40
														tmp42 := checkDerefVar(glojure_DOT_core_chunk_rest)
														tmp43 := lang.Apply(tmp42, []any{v33})
														var tmp41 any = tmp43
														var tmp44 any = v40
														tmp46 := checkDerefVar(glojure_DOT_core_int)
														tmp47 := checkDerefVar(glojure_DOT_core_count)
														tmp48 := lang.Apply(tmp47, []any{v40})
														tmp49 := lang.Apply(tmp46, []any{tmp48})
														var tmp45 any = tmp49
														tmp51 := checkDerefVar(glojure_DOT_core_int)
														tmp52 := lang.Apply(tmp51, []any{int64(0)})
														var tmp50 any = tmp52
														v19 = tmp41
														v20 = tmp44
														v21 = tmp45
														v22 = tmp50
														continue
													} // end let
													tmp34 = tmp37
												} else {
													var tmp38 any
													{ // let
														// let binding "agent"
														tmp39 := checkDerefVar(glojure_DOT_core_first)
														tmp40 := lang.Apply(tmp39, []any{v33})
														var v41 any = tmp40
														_ = v41
														tmp42 := checkDerefVar(glojure_DOT_core_send)
														tmp43 := lang.Apply(tmp42, []any{v41, v15})
														_ = tmp43
														tmp45 := checkDerefVar(glojure_DOT_core_next)
														tmp46 := lang.Apply(tmp45, []any{v33})
														var tmp44 any = tmp46
														var tmp47 any = nil
														var tmp48 any = int64(0)
														var tmp49 any = int64(0)
														v19 = tmp44
														v20 = tmp47
														v21 = tmp48
														v22 = tmp49
														continue
													} // end let
													tmp34 = tmp38
												}
												tmp32 = tmp34
											} // end let
											tmp31 = tmp32
										} else {
										}
										tmp27 = tmp31
									} // end let
									tmp23 = tmp27
								}
								tmp16 = tmp23
								break
							}
						} // end let
						_ = tmp16
						tmp17, ok := lang.FieldOrMethod(nil, "MILLISECONDS")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "MILLISECONDS")))
						}
						var tmp18 any
						switch reflect.TypeOf(tmp17).Kind() {
						case reflect.Func:
							tmp18 = lang.Apply(tmp17, nil)
						default:
							tmp18 = tmp17
						}
						tmp19, _ := lang.FieldOrMethod(v11, "await")
						if reflect.TypeOf(tmp19).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
						}
						tmp20 := lang.Apply(tmp19, []any{v3, tmp18})
						tmp10 = tmp20
					} // end let
					tmp5 = tmp10
				}
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await1
	{
		tmp0 := lang.NewSymbol("await1").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3284), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(3284), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
			tmp6, ok := lang.FieldOrMethod(v3, "getQueueCount")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getQueueCount")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			tmp8 := lang.Apply(tmp5, []any{tmp7})
			if lang.IsTruthy(tmp8) {
				tmp9 := checkDerefVar(glojure_DOT_core_await)
				tmp10 := lang.Apply(tmp9, []any{v3})
				tmp4 = tmp10
			} else {
			}
			_ = tmp4
			return v3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bases
	{
		tmp0 := lang.NewSymbol("bases").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("c"))), lang.NewKeyword("doc"), "Returns the immediate superclass and direct interfaces of c, if any", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5522), lang.NewKeyword("end-line"), int(5522))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			if lang.IsTruthy(v3) {
				var tmp5 any
				{ // let
					// let binding "i"
					tmp6 := checkDerefVar(glojure_DOT_core_seq)
					tmp7 := lang.Apply(tmp6, []any{nil})
					var v8 any = tmp7
					_ = v8
					// let binding "s"
					var v9 any = nil
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp11 := checkDerefVar(glojure_DOT_core_cons)
						tmp12 := lang.Apply(tmp11, []any{v9, v8})
						tmp10 = tmp12
					} else {
						tmp10 = v8
					}
					tmp5 = tmp10
				} // end let
				tmp4 = tmp5
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bigdec
	{
		tmp1 := reflect.TypeOf((*lang.BigDecimal)(nil))
		tmp0 := lang.NewSymbol("bigdec").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Coerce to BigDecimal", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3648), lang.NewKeyword("end-line"), int(3648))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_decimal_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			if lang.IsTruthy(tmp7) {
				tmp5 = v4
			} else {
				var tmp8 any
				tmp9 := checkDerefVar(glojure_DOT_core_float_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v4})
				if lang.IsTruthy(tmp10) {
					tmp11 := checkDerefVar(glojure_DOT_core_double)
					tmp12 := lang.Apply(tmp11, []any{v4})
					tmp13 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp12})
					tmp8 = tmp13
				} else {
					var tmp14 any
					tmp15 := checkDerefVar(glojure_DOT_core_ratio_QMARK_)
					tmp16 := lang.Apply(tmp15, []any{v4})
					if lang.IsTruthy(tmp16) {
						tmp17 := checkDerefVar(glojure_DOT_core__SLASH_)
						tmp18 := lang.Apply(lang.NewBigDecimalFromRatio, []any{v4})
						tmp19, ok := lang.FieldOrMethod(v4, "denominator")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "denominator")))
						}
						var tmp20 any
						switch reflect.TypeOf(tmp19).Kind() {
						case reflect.Func:
							tmp20 = lang.Apply(tmp19, nil)
						default:
							tmp20 = tmp19
						}
						tmp21 := lang.Apply(tmp17, []any{tmp18, tmp20})
						tmp14 = tmp21
					} else {
						var tmp22 any
						tmp23 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
						tmp24 := reflect.TypeOf((*lang.BigInt)(nil))
						tmp25 := lang.Apply(tmp23, []any{tmp24, v4})
						if lang.IsTruthy(tmp25) {
							tmp26, ok := lang.FieldOrMethod(v4, "toBigDecimal")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigDecimal")))
							}
							var tmp27 any
							switch reflect.TypeOf(tmp26).Kind() {
							case reflect.Func:
								tmp27 = lang.Apply(tmp26, nil)
							default:
								tmp27 = tmp26
							}
							tmp22 = tmp27
						} else {
							var tmp28 any
							tmp29 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
							tmp30 := reflect.TypeOf((*big9.Int)(nil))
							tmp31 := lang.Apply(tmp29, []any{tmp30, v4})
							if lang.IsTruthy(tmp31) {
								tmp32 := lang.Apply(lang.NewBigDecimal, []any{v4})
								tmp28 = tmp32
							} else {
								var tmp33 any
								tmp34 := checkDerefVar(glojure_DOT_core_number_QMARK_)
								tmp35 := lang.Apply(tmp34, []any{v4})
								if lang.IsTruthy(tmp35) {
									tmp36 := checkDerefVar(glojure_DOT_core_long)
									tmp37 := lang.Apply(tmp36, []any{v4})
									tmp38 := lang.Apply(lang.NewBigDecimalFromInt64, []any{tmp37})
									tmp33 = tmp38
								} else {
									var tmp39 any
									if lang.IsTruthy(lang.NewKeyword("else")) {
										tmp40 := lang.Apply(lang.NewBigDecimal, []any{v4})
										tmp39 = tmp40
									} else {
									}
									tmp33 = tmp39
								}
								tmp28 = tmp33
							}
							tmp22 = tmp28
						}
						tmp14 = tmp22
					}
					tmp8 = tmp14
				}
				tmp5 = tmp8
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*lang.BigDecimal)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bigint
	{
		tmp1 := reflect.TypeOf((*lang.BigInt)(nil))
		tmp0 := lang.NewSymbol("bigint").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Coerce to BigInt", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3620), lang.NewKeyword("end-line"), int(3620))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*lang.BigInt)(nil))
			tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
			if lang.IsTruthy(tmp8) {
				tmp5 = v4
			} else {
				var tmp9 any
				tmp10 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp11 := reflect.TypeOf((*big9.Int)(nil))
				tmp12 := lang.Apply(tmp10, []any{tmp11, v4})
				if lang.IsTruthy(tmp12) {
					tmp13 := lang.Apply(lang.NewBigIntFromGoBigInt, []any{v4})
					tmp9 = tmp13
				} else {
					var tmp14 any
					tmp15 := checkDerefVar(glojure_DOT_core_decimal_QMARK_)
					tmp16 := lang.Apply(tmp15, []any{v4})
					if lang.IsTruthy(tmp16) {
						tmp17 := checkDerefVar(glojure_DOT_core_bigint)
						tmp18, ok := lang.FieldOrMethod(v4, "toBigInteger")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigInteger")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						tmp20 := lang.Apply(tmp17, []any{tmp19})
						tmp14 = tmp20
					} else {
						var tmp21 any
						tmp22 := checkDerefVar(glojure_DOT_core_float_QMARK_)
						tmp23 := lang.Apply(tmp22, []any{v4})
						if lang.IsTruthy(tmp23) {
							tmp24 := checkDerefVar(glojure_DOT_core_bigint)
							tmp25 := checkDerefVar(glojure_DOT_core_double)
							tmp26 := lang.Apply(tmp25, []any{v4})
							tmp27 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp26})
							tmp28 := lang.Apply(tmp24, []any{tmp27})
							tmp21 = tmp28
						} else {
							var tmp29 any
							tmp30 := checkDerefVar(glojure_DOT_core_ratio_QMARK_)
							tmp31 := lang.Apply(tmp30, []any{v4})
							if lang.IsTruthy(tmp31) {
								tmp32 := checkDerefVar(glojure_DOT_core_bigint)
								tmp33, ok := lang.FieldOrMethod(v4, "bigIntegerValue")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "bigIntegerValue")))
								}
								var tmp34 any
								switch reflect.TypeOf(tmp33).Kind() {
								case reflect.Func:
									tmp34 = lang.Apply(tmp33, nil)
								default:
									tmp34 = tmp33
								}
								tmp35 := lang.Apply(tmp32, []any{tmp34})
								tmp29 = tmp35
							} else {
								var tmp36 any
								tmp37 := checkDerefVar(glojure_DOT_core_number_QMARK_)
								tmp38 := lang.Apply(tmp37, []any{v4})
								if lang.IsTruthy(tmp38) {
									tmp39 := checkDerefVar(glojure_DOT_core_long)
									tmp40 := lang.Apply(tmp39, []any{v4})
									tmp41 := lang.Apply(lang.NewBigIntFromInt64, []any{tmp40})
									tmp36 = tmp41
								} else {
									var tmp42 any
									if lang.IsTruthy(lang.NewKeyword("else")) {
										tmp43 := checkDerefVar(glojure_DOT_core_bigint)
										tmp44 := lang.Apply(lang.NewBigInt, []any{v4})
										tmp45 := lang.Apply(tmp43, []any{tmp44})
										tmp42 = tmp45
									} else {
									}
									tmp36 = tmp42
								}
								tmp29 = tmp36
							}
							tmp21 = tmp29
						}
						tmp14 = tmp21
					}
					tmp9 = tmp14
				}
				tmp5 = tmp9
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*lang.BigInt)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// biginteger
	{
		tmp1 := reflect.TypeOf((*big9.Int)(nil))
		tmp0 := lang.NewSymbol("biginteger").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Coerce to BigInteger", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3634), lang.NewKeyword("end-line"), int(3634))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*big9.Int)(nil))
			tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
			if lang.IsTruthy(tmp8) {
				tmp5 = v4
			} else {
				var tmp9 any
				tmp10 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp11 := reflect.TypeOf((*lang.BigInt)(nil))
				tmp12 := lang.Apply(tmp10, []any{tmp11, v4})
				if lang.IsTruthy(tmp12) {
					tmp13, ok := lang.FieldOrMethod(v4, "toBigInteger")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigInteger")))
					}
					var tmp14 any
					switch reflect.TypeOf(tmp13).Kind() {
					case reflect.Func:
						tmp14 = lang.Apply(tmp13, nil)
					default:
						tmp14 = tmp13
					}
					tmp9 = tmp14
				} else {
					var tmp15 any
					tmp16 := checkDerefVar(glojure_DOT_core_decimal_QMARK_)
					tmp17 := lang.Apply(tmp16, []any{v4})
					if lang.IsTruthy(tmp17) {
						tmp18, ok := lang.FieldOrMethod(v4, "toBigInteger")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigInteger")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						tmp15 = tmp19
					} else {
						var tmp20 any
						tmp21 := checkDerefVar(glojure_DOT_core_float_QMARK_)
						tmp22 := lang.Apply(tmp21, []any{v4})
						if lang.IsTruthy(tmp22) {
							tmp23 := checkDerefVar(glojure_DOT_core_double)
							tmp24 := lang.Apply(tmp23, []any{v4})
							tmp25 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp24})
							tmp26, ok := lang.FieldOrMethod(tmp25, "toBigInteger")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp25, "toBigInteger")))
							}
							var tmp27 any
							switch reflect.TypeOf(tmp26).Kind() {
							case reflect.Func:
								tmp27 = lang.Apply(tmp26, nil)
							default:
								tmp27 = tmp26
							}
							tmp20 = tmp27
						} else {
							var tmp28 any
							tmp29 := checkDerefVar(glojure_DOT_core_ratio_QMARK_)
							tmp30 := lang.Apply(tmp29, []any{v4})
							if lang.IsTruthy(tmp30) {
								tmp31, ok := lang.FieldOrMethod(v4, "bigIntegerValue")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "bigIntegerValue")))
								}
								var tmp32 any
								switch reflect.TypeOf(tmp31).Kind() {
								case reflect.Func:
									tmp32 = lang.Apply(tmp31, nil)
								default:
									tmp32 = tmp31
								}
								tmp28 = tmp32
							} else {
								var tmp33 any
								tmp34 := checkDerefVar(glojure_DOT_core_number_QMARK_)
								tmp35 := lang.Apply(tmp34, []any{v4})
								if lang.IsTruthy(tmp35) {
									tmp36 := checkDerefVar(glojure_DOT_core_long)
									tmp37 := lang.Apply(tmp36, []any{v4})
									tmp38 := lang.Apply(big9.NewInt, []any{tmp37})
									tmp33 = tmp38
								} else {
									var tmp39 any
									if lang.IsTruthy(lang.NewKeyword("else")) {
										tmp40 := lang.Apply(lang.NewBigInt, []any{v4})
										tmp39 = tmp40
									} else {
									}
									tmp33 = tmp39
								}
								tmp28 = tmp33
							}
							tmp20 = tmp28
						}
						tmp15 = tmp20
					}
					tmp9 = tmp15
				}
				tmp5 = tmp9
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*big9.Int)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// binding
	{
		tmp0 := lang.NewSymbol("binding").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1945), lang.NewKeyword("end-line"), int(1945))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(glojure_DOT_core_str)
					tmp11 := checkDerefVar(glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(lang.NewKeyword("line"), []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "var-ize"
					var tmp34 lang.FnFunc
					tmp34 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v35 := args[0]
						_ = v35
						var tmp36 any
						{ // let
							// let binding "ret"
							tmp37 := lang.NewVector()
							tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1959), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(1959), lang.NewKeyword("end-column"), int(31))
							tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v40 any = tmp39
							_ = v40
							// let binding "vvs"
							tmp41 := checkDerefVar(glojure_DOT_core_seq)
							tmp42 := lang.Apply(tmp41, []any{v35})
							var v43 any = tmp42
							_ = v43
							for {
								var tmp44 any
								if lang.IsTruthy(v43) {
									tmp46 := checkDerefVar(glojure_DOT_core_conj)
									tmp47 := checkDerefVar(glojure_DOT_core_conj)
									tmp48 := checkDerefVar(glojure_DOT_core_seq)
									tmp49 := checkDerefVar(glojure_DOT_core_concat)
									tmp50 := checkDerefVar(glojure_DOT_core_list)
									tmp51 := lang.Apply(tmp50, []any{lang.NewSymbol("var")})
									tmp52 := checkDerefVar(glojure_DOT_core_list)
									tmp53 := checkDerefVar(glojure_DOT_core_first)
									tmp54 := lang.Apply(tmp53, []any{v43})
									tmp55 := lang.Apply(tmp52, []any{tmp54})
									tmp56 := lang.Apply(tmp49, []any{tmp51, tmp55})
									tmp57 := lang.Apply(tmp48, []any{tmp56})
									tmp58 := lang.Apply(tmp47, []any{v40, tmp57})
									tmp59 := checkDerefVar(glojure_DOT_core_second)
									tmp60 := lang.Apply(tmp59, []any{v43})
									tmp61 := lang.Apply(tmp46, []any{tmp58, tmp60})
									var tmp45 any = tmp61
									tmp63 := checkDerefVar(glojure_DOT_core_next)
									tmp64 := checkDerefVar(glojure_DOT_core_next)
									tmp65 := lang.Apply(tmp64, []any{v43})
									tmp66 := lang.Apply(tmp63, []any{tmp65})
									var tmp62 any = tmp66
									v40 = tmp45
									v43 = tmp62
									continue
								} else {
									tmp67 := checkDerefVar(glojure_DOT_core_seq)
									tmp68 := lang.Apply(tmp67, []any{v40})
									tmp44 = tmp68
								}
								tmp36 = tmp44
								break
							}
						} // end let
						return tmp36
					})
					tmp35 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1958), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(1963), lang.NewKeyword("end-column"), int(34))
					tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v37 any = tmp36
					_ = v37
					tmp38 := checkDerefVar(glojure_DOT_core_seq)
					tmp39 := checkDerefVar(glojure_DOT_core_concat)
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{lang.NewSymbol("glojure.core/let")})
					tmp42 := checkDerefVar(glojure_DOT_core_list)
					tmp43 := checkDerefVar(glojure_DOT_core_apply)
					tmp44 := checkDerefVar(glojure_DOT_core_vector)
					tmp45 := checkDerefVar(glojure_DOT_core_seq)
					tmp46 := checkDerefVar(glojure_DOT_core_concat)
					tmp47 := lang.Apply(tmp46, nil)
					tmp48 := lang.Apply(tmp45, []any{tmp47})
					tmp49 := lang.Apply(tmp43, []any{tmp44, tmp48})
					tmp50 := lang.Apply(tmp42, []any{tmp49})
					tmp51 := checkDerefVar(glojure_DOT_core_list)
					tmp52 := checkDerefVar(glojure_DOT_core_seq)
					tmp53 := checkDerefVar(glojure_DOT_core_concat)
					tmp54 := checkDerefVar(glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{lang.NewSymbol("glojure.core/push-thread-bindings")})
					tmp56 := checkDerefVar(glojure_DOT_core_list)
					tmp57 := checkDerefVar(glojure_DOT_core_seq)
					tmp58 := checkDerefVar(glojure_DOT_core_concat)
					tmp59 := checkDerefVar(glojure_DOT_core_list)
					tmp60 := lang.Apply(tmp59, []any{lang.NewSymbol("glojure.core/hash-map")})
					tmp61 := lang.Apply(v37, []any{v5})
					tmp62 := lang.Apply(tmp58, []any{tmp60, tmp61})
					tmp63 := lang.Apply(tmp57, []any{tmp62})
					tmp64 := lang.Apply(tmp56, []any{tmp63})
					tmp65 := lang.Apply(tmp53, []any{tmp55, tmp64})
					tmp66 := lang.Apply(tmp52, []any{tmp65})
					tmp67 := lang.Apply(tmp51, []any{tmp66})
					tmp68 := checkDerefVar(glojure_DOT_core_list)
					tmp69 := checkDerefVar(glojure_DOT_core_seq)
					tmp70 := checkDerefVar(glojure_DOT_core_concat)
					tmp71 := checkDerefVar(glojure_DOT_core_list)
					tmp72 := lang.Apply(tmp71, []any{lang.NewSymbol("try")})
					tmp73 := checkDerefVar(glojure_DOT_core_list)
					tmp74 := checkDerefVar(glojure_DOT_core_seq)
					tmp75 := checkDerefVar(glojure_DOT_core_concat)
					tmp76 := checkDerefVar(glojure_DOT_core_list)
					tmp77 := lang.Apply(tmp76, []any{lang.NewSymbol("finally")})
					tmp78 := checkDerefVar(glojure_DOT_core_list)
					tmp79 := checkDerefVar(glojure_DOT_core_seq)
					tmp80 := checkDerefVar(glojure_DOT_core_concat)
					tmp81 := checkDerefVar(glojure_DOT_core_list)
					tmp82 := lang.Apply(tmp81, []any{lang.NewSymbol("glojure.core/pop-thread-bindings")})
					tmp83 := lang.Apply(tmp80, []any{tmp82})
					tmp84 := lang.Apply(tmp79, []any{tmp83})
					tmp85 := lang.Apply(tmp78, []any{tmp84})
					tmp86 := lang.Apply(tmp75, []any{tmp77, tmp85})
					tmp87 := lang.Apply(tmp74, []any{tmp86})
					tmp88 := lang.Apply(tmp73, []any{tmp87})
					tmp89 := lang.Apply(tmp70, []any{tmp72, v6, tmp88})
					tmp90 := lang.Apply(tmp69, []any{tmp89})
					tmp91 := lang.Apply(tmp68, []any{tmp90})
					tmp92 := lang.Apply(tmp39, []any{tmp41, tmp50, tmp67, tmp91})
					tmp93 := lang.Apply(tmp38, []any{tmp92})
					tmp33 = tmp93
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// binding-conveyor-fn
	{
		tmp0 := lang.NewSymbol("binding-conveyor-fn").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2020), lang.NewKeyword("end-line"), int(2020), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "frame"
				tmp5 := lang.Apply(lang.CloneThreadBindingFrame, nil)
				var v6 any = tmp5
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp8 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp8
						tmp9 := lang.Apply(v3, nil)
						return tmp9
					case 1:
						v8 := args[0]
						_ = v8
						tmp9 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp9
						tmp10 := lang.Apply(v3, []any{v8})
						return tmp10
					case 2:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						tmp10 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp10
						tmp11 := lang.Apply(v3, []any{v8, v9})
						return tmp11
					case 3:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						tmp11 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp11
						tmp12 := lang.Apply(v3, []any{v8, v9, v10})
						return tmp12
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var v11 any = lang.NewList(args[3:]...)
						_ = v11
						tmp12 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp12
						tmp13 := checkDerefVar(glojure_DOT_core_apply)
						tmp14 := lang.Apply(tmp13, []any{v3, v8, v9, v10, v11})
						return tmp14
					}
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2025), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2040), lang.NewKeyword("end-column"), int(31))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp9
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-and
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed29
					} else {
						tmp4 = closed29
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed29
					} else {
						tmp5 = closed29
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed29
					} else {
						tmp6 = closed29
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("bit-and").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise and", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1298), lang.NewKeyword("end-line"), int(1298))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "And")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("And is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core_bit_and)
				tmp10 := checkDerefVar(glojure_DOT_core_bit_and)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-and-not
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed30
					} else {
						tmp4 = closed30
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed30
					} else {
						tmp5 = closed30
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed30
					} else {
						tmp6 = closed30
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("bit-and-not").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise and with complement", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1325), lang.NewKeyword("end-line"), int(1325))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "AndNot")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("AndNot is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core_bit_and_not)
				tmp10 := checkDerefVar(glojure_DOT_core_bit_and_not)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-clear
	{
		tmp0 := lang.NewSymbol("bit-clear").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Clear bit at index n", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1336), lang.NewKeyword("end-line"), int(1336))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "ClearBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ClearBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-flip
	{
		tmp0 := lang.NewSymbol("bit-flip").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Flip bit at index n", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1348), lang.NewKeyword("end-line"), int(1348))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "FlipBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("FlipBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-not
	{
		var tmp1 lang.FnFunc
		{ // function bit-not__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/Not")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("bit-not").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise complement", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1291), lang.NewKeyword("end-line"), int(1291))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Not")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Not is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-or
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed31
					} else {
						tmp4 = closed31
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed31
					} else {
						tmp5 = closed31
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed31
					} else {
						tmp6 = closed31
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("bit-or").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise or", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1307), lang.NewKeyword("end-line"), int(1307))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Or")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Or is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core_bit_or)
				tmp10 := checkDerefVar(glojure_DOT_core_bit_or)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-set
	{
		tmp0 := lang.NewSymbol("bit-set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Set bit at index n", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1342), lang.NewKeyword("end-line"), int(1342))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "SetBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("SetBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-shift-left
	{
		var tmp1 lang.FnFunc
		{ // function bit-shift-left__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/ShiftLeft")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("bit-shift-left").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise shift left", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1361), lang.NewKeyword("end-line"), int(1361))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ShiftLeft")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShiftLeft is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-shift-right
	{
		var tmp1 lang.FnFunc
		{ // function bit-shift-right__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/ShiftRight")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("bit-shift-right").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise shift right", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1367), lang.NewKeyword("end-line"), int(1367))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ShiftRight")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShiftRight is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-test
	{
		tmp0 := lang.NewSymbol("bit-test").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Test bit at index n", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1354), lang.NewKeyword("end-line"), int(1354))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "TestBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("TestBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-xor
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed32
					} else {
						tmp4 = closed32
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed32
					} else {
						tmp5 = closed32
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed32
					} else {
						tmp6 = closed32
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("bit-xor").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise exclusive or", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1316), lang.NewKeyword("end-line"), int(1316))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Xor")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Xor is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core_bit_xor)
				tmp10 := checkDerefVar(glojure_DOT_core_bit_xor)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean
	{
		var tmp1 lang.FnFunc
		{ // function boolean__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/BooleanCast")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("boolean").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to boolean", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1601), lang.NewKeyword("end-line"), int(1601))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime7.RT, "BooleanCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("BooleanCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean-array
	{
		var tmp1 lang.FnFunc
		{ // function boolean-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(glojure_DOT_core_seq)
					tmp5 := checkDerefVar(glojure_DOT_core_concat)
					tmp6 := checkDerefVar(glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
					tmp8 := checkDerefVar(glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/BooleanArray")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.core/args")})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("boolean-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of booleans", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5309), lang.NewKeyword("end-line"), int(5309))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "BooleanArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("BooleanArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "BooleanArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("BooleanArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean?
	{
		tmp0 := lang.NewSymbol("boolean?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a Boolean", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(518), lang.NewKeyword("end-line"), int(518))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{lang.Builtins["bool"], v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// booleans
	{
		var tmp1 lang.FnFunc
		{ // function booleans
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/Booleans")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("booleans").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to boolean[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5372), lang.NewKeyword("end-line"), int(5372))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Booleans")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Booleans is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound-fn
	{
		tmp0 := lang.NewSymbol("bound-fn").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("fntail"))), lang.NewKeyword("doc"), "Returns a function defined by the given fntail, which will install the\n  same bindings in effect as in the thread at the time bound-fn was called.\n  This may be used to define a helper function which runs on a different\n  thread, but needs the same bindings in place.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(2004), lang.NewKeyword("end-line"), int(2004))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_concat)
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("glojure.core/bound-fn*")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/fn")})
				tmp15 := lang.Apply(tmp12, []any{tmp14, v5})
				tmp16 := lang.Apply(tmp11, []any{tmp15})
				tmp17 := lang.Apply(tmp10, []any{tmp16})
				tmp18 := lang.Apply(tmp7, []any{tmp9, tmp17})
				tmp19 := lang.Apply(tmp6, []any{tmp18})
				return tmp19
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound-fn*
	{
		tmp0 := lang.NewSymbol("bound-fn*").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Returns a function, which will install the same bindings in effect as in\n  the thread at the time bound-fn* was called and then call f with any given\n  arguments. This may be used to define a helper function which runs on a\n  different thread, but needs the same bindings in place.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1992), lang.NewKeyword("end-line"), int(1992))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "bindings"
				tmp5 := checkDerefVar(glojure_DOT_core_get_thread_bindings)
				tmp6 := lang.Apply(tmp5, nil)
				var v7 any = tmp6
				_ = v7
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						if len(args) < 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var v9 any = lang.NewList(args[0:]...)
						_ = v9
						tmp10 := checkDerefVar(glojure_DOT_core_apply)
						tmp11 := checkDerefVar(glojure_DOT_core_with_bindings_STAR_)
						tmp12 := lang.Apply(tmp10, []any{tmp11, v7, v3, v9})
						return tmp12
					}
				})
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2001), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2002), lang.NewKeyword("end-column"), int(45))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound?
	{
		tmp0 := lang.NewSymbol("bound?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("vars"))), lang.NewKeyword("doc"), "Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5491), lang.NewKeyword("end-line"), int(5491))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_every_QMARK_)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v6 := args[0]
					_ = v6
					tmp7, ok := lang.FieldOrMethod(v6, "isBound")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "isBound")))
					}
					var tmp8 any
					switch reflect.TypeOf(tmp7).Kind() {
					case reflect.Func:
						tmp8 = lang.Apply(tmp7, nil)
					default:
						tmp8 = tmp7
					}
					return tmp8
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5497), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5497), lang.NewKeyword("end-column"), int(69))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7, v3})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bounded-count
	{
		tmp0 := lang.NewSymbol("bounded-count").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "If coll is counted? returns its count, else will count at most the first n\n  elements of coll using its seq", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7410), lang.NewKeyword("end-line"), int(7410))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_counted_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(glojure_DOT_core_count)
				tmp9 := lang.Apply(tmp8, []any{v4})
				tmp5 = tmp9
			} else {
				var tmp10 any
				{ // let
					// let binding "i"
					var v11 any = int64(0)
					_ = v11
					// let binding "s"
					tmp12 := checkDerefVar(glojure_DOT_core_seq)
					tmp13 := lang.Apply(tmp12, []any{v4})
					var v14 any = tmp13
					_ = v14
					for {
						var tmp15 any
						var tmp16 any
						{ // let
							// let binding "and__0__auto__"
							var v17 any = v14
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								tmp19 := checkDerefVar(glojure_DOT_core__LT_)
								tmp20 := lang.Apply(tmp19, []any{v11, v3})
								tmp18 = tmp20
							} else {
								tmp18 = v17
							}
							tmp16 = tmp18
						} // end let
						if lang.IsTruthy(tmp16) {
							tmp18 := checkDerefVar(glojure_DOT_core_inc)
							tmp19 := lang.Apply(tmp18, []any{v11})
							var tmp17 any = tmp19
							tmp21 := checkDerefVar(glojure_DOT_core_next)
							tmp22 := lang.Apply(tmp21, []any{v14})
							var tmp20 any = tmp22
							v11 = tmp17
							v14 = tmp20
							continue
						} else {
							tmp15 = v11
						}
						tmp10 = tmp15
						break
					}
				} // end let
				tmp5 = tmp10
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// butlast
	{
		tmp0 := lang.NewSymbol("butlast").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return a seq of all but the last item in coll, in linear time", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(272), lang.NewKeyword("end-line"), int(276))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function butlast
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "ret"
					tmp6 := lang.NewVector()
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(277), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(277), lang.NewKeyword("end-column"), int(24))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v9 any = tmp8
					_ = v9
					// let binding "s"
					var v10 any = v4
					_ = v10
					for {
						var tmp11 any
						tmp12 := checkDerefVar(glojure_DOT_core_next)
						tmp13 := lang.Apply(tmp12, []any{v10})
						if lang.IsTruthy(tmp13) {
							tmp15 := checkDerefVar(glojure_DOT_core_conj)
							tmp16 := checkDerefVar(glojure_DOT_core_first)
							tmp17 := lang.Apply(tmp16, []any{v10})
							tmp18 := lang.Apply(tmp15, []any{v9, tmp17})
							var tmp14 any = tmp18
							tmp20 := checkDerefVar(glojure_DOT_core_next)
							tmp21 := lang.Apply(tmp20, []any{v10})
							var tmp19 any = tmp21
							v9 = tmp14
							v10 = tmp19
							continue
						} else {
							tmp22 := checkDerefVar(glojure_DOT_core_seq)
							tmp23 := lang.Apply(tmp22, []any{v9})
							tmp11 = tmp23
						}
						tmp5 = tmp11
						break
					}
				} // end let
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(276), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(280), lang.NewKeyword("end-column"), int(27))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// byte
	{
		var tmp1 lang.FnFunc
		{ // function byte__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = lang.NewSymbol("uncheckedByteCast")
				} else {
					tmp14 = lang.NewSymbol("byteCast")
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("byte").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to byte", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3505), lang.NewKeyword("end-line"), int(3505))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.ByteCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// byte-array
	{
		var tmp1 lang.FnFunc
		{ // function byte-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(glojure_DOT_core_seq)
					tmp5 := checkDerefVar(glojure_DOT_core_concat)
					tmp6 := checkDerefVar(glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
					tmp8 := checkDerefVar(glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/ByteArray")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.core/args")})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("byte-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of bytes", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5317), lang.NewKeyword("end-line"), int(5317))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "ByteArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ByteArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ByteArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ByteArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bytes
	{
		var tmp1 lang.FnFunc
		{ // function bytes
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/Bytes")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("bytes").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to bytes[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5377), lang.NewKeyword("end-line"), int(5377))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Bytes")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Bytes is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bytes?
	{
		tmp0 := lang.NewSymbol("bytes?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a byte array", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5412), lang.NewKeyword("end-line"), int(5412))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp4 = false
			} else {
				tmp7 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp8 := checkDerefVar(glojure_DOT_core_class)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10, ok := lang.FieldOrMethod(tmp9, "getComponentType")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp9, "getComponentType")))
				}
				var tmp11 any
				switch reflect.TypeOf(tmp10).Kind() {
				case reflect.Func:
					tmp11 = lang.Apply(tmp10, nil)
				default:
					tmp11 = tmp10
				}
				tmp12 := lang.Apply(tmp7, []any{tmp11, nil})
				tmp4 = tmp12
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// case
	{
		tmp0 := lang.NewSymbol("case").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("e"), lang.NewSymbol("&"), lang.NewSymbol("clauses"))), lang.NewKeyword("doc"), "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(6712), lang.NewKeyword("end-line"), int(6712))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ge"
					tmp8 := checkDerefVar(glojure_DOT_core_with_meta)
					tmp9 := checkDerefVar(glojure_DOT_core_gensym)
					tmp10 := lang.Apply(tmp9, nil)
					tmp11 := reflect.TypeOf((*lang.Object)(nil)).Elem()
					tmp12 := lang.NewMap(lang.NewKeyword("tag"), tmp11)
					tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6738), lang.NewKeyword("column"), int(32), lang.NewKeyword("end-line"), int(6738), lang.NewKeyword("end-column"), int(84))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := lang.Apply(tmp8, []any{tmp10, tmp14})
					var v16 any = tmp15
					_ = v16
					// let binding "default"
					var tmp17 any
					tmp18 := checkDerefVar(glojure_DOT_core_odd_QMARK_)
					tmp19 := checkDerefVar(glojure_DOT_core_count)
					tmp20 := lang.Apply(tmp19, []any{v6})
					tmp21 := lang.Apply(tmp18, []any{tmp20})
					if lang.IsTruthy(tmp21) {
						tmp22 := checkDerefVar(glojure_DOT_core_last)
						tmp23 := lang.Apply(tmp22, []any{v6})
						tmp17 = tmp23
					} else {
						tmp24 := checkDerefVar(glojure_DOT_core_seq)
						tmp25 := checkDerefVar(glojure_DOT_core_concat)
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{lang.NewSymbol("throw")})
						tmp28 := checkDerefVar(glojure_DOT_core_list)
						tmp29 := checkDerefVar(glojure_DOT_core_seq)
						tmp30 := checkDerefVar(glojure_DOT_core_concat)
						tmp31 := checkDerefVar(glojure_DOT_core_list)
						tmp32 := lang.Apply(tmp31, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewIllegalArgumentError")})
						tmp33 := checkDerefVar(glojure_DOT_core_list)
						tmp34 := checkDerefVar(glojure_DOT_core_seq)
						tmp35 := checkDerefVar(glojure_DOT_core_concat)
						tmp36 := checkDerefVar(glojure_DOT_core_list)
						tmp37 := lang.Apply(tmp36, []any{lang.NewSymbol("glojure.core/str")})
						tmp38 := checkDerefVar(glojure_DOT_core_list)
						tmp39 := lang.Apply(tmp38, []any{"No matching clause: "})
						tmp40 := checkDerefVar(glojure_DOT_core_list)
						tmp41 := lang.Apply(tmp40, []any{v16})
						tmp42 := lang.Apply(tmp35, []any{tmp37, tmp39, tmp41})
						tmp43 := lang.Apply(tmp34, []any{tmp42})
						tmp44 := lang.Apply(tmp33, []any{tmp43})
						tmp45 := lang.Apply(tmp30, []any{tmp32, tmp44})
						tmp46 := lang.Apply(tmp29, []any{tmp45})
						tmp47 := lang.Apply(tmp28, []any{tmp46})
						tmp48 := lang.Apply(tmp25, []any{tmp27, tmp47})
						tmp49 := lang.Apply(tmp24, []any{tmp48})
						tmp17 = tmp49
					}
					var v50 any = tmp17
					_ = v50
					var tmp51 any
					tmp52 := checkDerefVar(glojure_DOT_core__GT_)
					tmp53 := checkDerefVar(glojure_DOT_core_count)
					tmp54 := lang.Apply(tmp53, []any{v6})
					tmp55 := lang.Apply(tmp52, []any{int64(2), tmp54})
					if lang.IsTruthy(tmp55) {
						tmp56 := checkDerefVar(glojure_DOT_core_seq)
						tmp57 := checkDerefVar(glojure_DOT_core_concat)
						tmp58 := checkDerefVar(glojure_DOT_core_list)
						tmp59 := lang.Apply(tmp58, []any{lang.NewSymbol("glojure.core/let")})
						tmp60 := checkDerefVar(glojure_DOT_core_list)
						tmp61 := checkDerefVar(glojure_DOT_core_apply)
						tmp62 := checkDerefVar(glojure_DOT_core_vector)
						tmp63 := checkDerefVar(glojure_DOT_core_seq)
						tmp64 := checkDerefVar(glojure_DOT_core_concat)
						tmp65 := checkDerefVar(glojure_DOT_core_list)
						tmp66 := lang.Apply(tmp65, []any{v16})
						tmp67 := checkDerefVar(glojure_DOT_core_list)
						tmp68 := lang.Apply(tmp67, []any{v5})
						tmp69 := lang.Apply(tmp64, []any{tmp66, tmp68})
						tmp70 := lang.Apply(tmp63, []any{tmp69})
						tmp71 := lang.Apply(tmp61, []any{tmp62, tmp70})
						tmp72 := lang.Apply(tmp60, []any{tmp71})
						tmp73 := checkDerefVar(glojure_DOT_core_list)
						tmp74 := lang.Apply(tmp73, []any{v50})
						tmp75 := lang.Apply(tmp57, []any{tmp59, tmp72, tmp74})
						tmp76 := lang.Apply(tmp56, []any{tmp75})
						tmp51 = tmp76
					} else {
						var tmp77 any
						{ // let
							// let binding "pairs"
							tmp78 := checkDerefVar(glojure_DOT_core_partition)
							tmp79 := lang.Apply(tmp78, []any{int64(2), v6})
							var v80 any = tmp79
							_ = v80
							// let binding "assoc-test"
							var tmp81 lang.FnFunc
							{ // function assoc-test
								var v82 lang.FnFunc
								tmp81 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 3 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v83 := args[0]
									_ = v83
									v84 := args[1]
									_ = v84
									v85 := args[2]
									_ = v85
									var tmp86 any
									tmp87 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
									tmp88 := lang.Apply(tmp87, []any{v83, v84})
									if lang.IsTruthy(tmp88) {
										tmp89 := checkDerefVar(glojure_DOT_core_str)
										tmp90 := lang.Apply(tmp89, []any{"Duplicate case test constant: ", v84})
										tmp91 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp90})
										panic(tmp91)
									} else {
										tmp92 := checkDerefVar(glojure_DOT_core_assoc)
										tmp93 := lang.Apply(tmp92, []any{v83, v84, v85})
										tmp86 = tmp93
									}
									return tmp86
								})
								v82 = tmp81
								_ = v82
							}
							tmp82 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6745), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(6748), lang.NewKeyword("end-column"), int(48))
							tmp83, err := lang.WithMeta(tmp81, tmp82.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v84 any = tmp83
							_ = v84
							// let binding "pairs"
							tmp85 := checkDerefVar(glojure_DOT_core_reduce1)
							var tmp86 lang.FnFunc
							tmp86 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v87 := args[0]
								_ = v87
								v88 := args[1]
								_ = v88
								var tmp89 any
								{ // let
									// let binding "vec__177"
									var v90 any = v88
									_ = v90
									// let binding "test"
									tmp91 := checkDerefVar(glojure_DOT_core_nth)
									tmp92 := lang.Apply(tmp91, []any{v90, int64(0), nil})
									var v93 any = tmp92
									_ = v93
									// let binding "expr"
									tmp94 := checkDerefVar(glojure_DOT_core_nth)
									tmp95 := lang.Apply(tmp94, []any{v90, int64(1), nil})
									var v96 any = tmp95
									_ = v96
									var tmp97 any
									tmp98 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
									tmp99 := lang.Apply(tmp98, []any{v93})
									if lang.IsTruthy(tmp99) {
										tmp100 := checkDerefVar(glojure_DOT_core_reduce1)
										var tmp101 lang.FnFunc
										tmp101 = lang.NewFnFunc(func(args ...any) any {
											if len(args) != 2 {
												panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
											}
											v102 := args[0]
											_ = v102
											v103 := args[1]
											_ = v103
											tmp104 := lang.Apply(v84, []any{v102, v103, v96})
											return tmp104
										})
										tmp102 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6752), lang.NewKeyword("column"), int(37), lang.NewKeyword("end-line"), int(6752), lang.NewKeyword("end-column"), int(60))
										tmp103, err := lang.WithMeta(tmp101, tmp102.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp104 := lang.Apply(tmp100, []any{tmp103, v87, v93})
										tmp97 = tmp104
									} else {
										tmp105 := lang.Apply(v84, []any{v87, v93, v96})
										tmp97 = tmp105
									}
									tmp89 = tmp97
								} // end let
								return tmp89
							})
							tmp87 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6750), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(6753), lang.NewKeyword("end-column"), int(53))
							tmp88, err := lang.WithMeta(tmp86, tmp87.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp89 := lang.NewMap()
							tmp90 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6754), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(6754), lang.NewKeyword("end-column"), int(25))
							tmp91, err := lang.WithMeta(tmp89, tmp90.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp92 := lang.Apply(tmp85, []any{tmp88, tmp91, v80})
							var v93 any = tmp92
							_ = v93
							// let binding "tests"
							tmp94 := checkDerefVar(glojure_DOT_core_keys)
							tmp95 := lang.Apply(tmp94, []any{v93})
							var v96 any = tmp95
							_ = v96
							// let binding "thens"
							tmp97 := checkDerefVar(glojure_DOT_core_vals)
							tmp98 := lang.Apply(tmp97, []any{v93})
							var v99 any = tmp98
							_ = v99
							// let binding "mode"
							var tmp100 any
							tmp101 := checkDerefVar(glojure_DOT_core_every_QMARK_)
							var tmp102 lang.FnFunc
							tmp102 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v103 := args[0]
								_ = v103
								var tmp104 any
								{ // let
									// let binding "and__0__auto__"
									tmp105 := checkDerefVar(glojure_DOT_core_integer_QMARK_)
									tmp106 := lang.Apply(tmp105, []any{v103})
									var v107 any = tmp106
									_ = v107
									var tmp108 any
									if lang.IsTruthy(v107) {
										tmp109 := checkDerefVar(glojure_DOT_core__LT__EQ_)
										tmp110 := lang.Apply(tmp109, []any{math6.MinInt, v103, math6.MaxInt})
										tmp108 = tmp110
									} else {
										tmp108 = v107
									}
									tmp104 = tmp108
								} // end let
								return tmp104
							})
							tmp103 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6758), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(6758), lang.NewKeyword("end-column"), int(77))
							tmp104, err := lang.WithMeta(tmp102, tmp103.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp105 := lang.Apply(tmp101, []any{tmp104, v96})
							if lang.IsTruthy(tmp105) {
								tmp100 = lang.NewKeyword("ints")
							} else {
								var tmp106 any
								tmp107 := checkDerefVar(glojure_DOT_core_every_QMARK_)
								tmp108 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
								tmp109 := lang.Apply(tmp107, []any{tmp108, v96})
								if lang.IsTruthy(tmp109) {
									tmp106 = lang.NewKeyword("identity")
								} else {
									var tmp110 any
									if lang.IsTruthy(lang.NewKeyword("else")) {
										tmp110 = lang.NewKeyword("hashes")
									} else {
									}
									tmp106 = tmp110
								}
								tmp100 = tmp106
							}
							var v111 any = tmp100
							_ = v111
							var tmp112 any
							{ // let
								// let binding "pred__180"
								tmp113 := checkDerefVar(glojure_DOT_core__EQ_)
								var v114 any = tmp113
								_ = v114
								// let binding "expr__181"
								var v115 any = v111
								_ = v115
								var tmp116 any
								tmp117 := lang.Apply(v114, []any{lang.NewKeyword("ints"), v115})
								if lang.IsTruthy(tmp117) {
									var tmp118 any
									{ // let
										// let binding "vec__182"
										tmp119 := checkDerefVar(glojure_DOT_core_prep_ints)
										tmp120 := lang.Apply(tmp119, []any{v96, v99})
										var v121 any = tmp120
										_ = v121
										// let binding "shift"
										tmp122 := checkDerefVar(glojure_DOT_core_nth)
										tmp123 := lang.Apply(tmp122, []any{v121, int64(0), nil})
										var v124 any = tmp123
										_ = v124
										// let binding "mask"
										tmp125 := checkDerefVar(glojure_DOT_core_nth)
										tmp126 := lang.Apply(tmp125, []any{v121, int64(1), nil})
										var v127 any = tmp126
										_ = v127
										// let binding "imap"
										tmp128 := checkDerefVar(glojure_DOT_core_nth)
										tmp129 := lang.Apply(tmp128, []any{v121, int64(2), nil})
										var v130 any = tmp129
										_ = v130
										// let binding "switch-type"
										tmp131 := checkDerefVar(glojure_DOT_core_nth)
										tmp132 := lang.Apply(tmp131, []any{v121, int64(3), nil})
										var v133 any = tmp132
										_ = v133
										tmp134 := checkDerefVar(glojure_DOT_core_seq)
										tmp135 := checkDerefVar(glojure_DOT_core_concat)
										tmp136 := checkDerefVar(glojure_DOT_core_list)
										tmp137 := lang.Apply(tmp136, []any{lang.NewSymbol("glojure.core/let")})
										tmp138 := checkDerefVar(glojure_DOT_core_list)
										tmp139 := checkDerefVar(glojure_DOT_core_apply)
										tmp140 := checkDerefVar(glojure_DOT_core_vector)
										tmp141 := checkDerefVar(glojure_DOT_core_seq)
										tmp142 := checkDerefVar(glojure_DOT_core_concat)
										tmp143 := checkDerefVar(glojure_DOT_core_list)
										tmp144 := lang.Apply(tmp143, []any{v16})
										tmp145 := checkDerefVar(glojure_DOT_core_list)
										tmp146 := lang.Apply(tmp145, []any{v5})
										tmp147 := lang.Apply(tmp142, []any{tmp144, tmp146})
										tmp148 := lang.Apply(tmp141, []any{tmp147})
										tmp149 := lang.Apply(tmp139, []any{tmp140, tmp148})
										tmp150 := lang.Apply(tmp138, []any{tmp149})
										tmp151 := checkDerefVar(glojure_DOT_core_list)
										tmp152 := checkDerefVar(glojure_DOT_core_seq)
										tmp153 := checkDerefVar(glojure_DOT_core_concat)
										tmp154 := checkDerefVar(glojure_DOT_core_list)
										tmp155 := lang.Apply(tmp154, []any{lang.NewSymbol("case*")})
										tmp156 := checkDerefVar(glojure_DOT_core_list)
										tmp157 := lang.Apply(tmp156, []any{v16})
										tmp158 := checkDerefVar(glojure_DOT_core_list)
										tmp159 := lang.Apply(tmp158, []any{v124})
										tmp160 := checkDerefVar(glojure_DOT_core_list)
										tmp161 := lang.Apply(tmp160, []any{v127})
										tmp162 := checkDerefVar(glojure_DOT_core_list)
										tmp163 := lang.Apply(tmp162, []any{v50})
										tmp164 := checkDerefVar(glojure_DOT_core_list)
										tmp165 := lang.Apply(tmp164, []any{v130})
										tmp166 := checkDerefVar(glojure_DOT_core_list)
										tmp167 := lang.Apply(tmp166, []any{v133})
										tmp168 := checkDerefVar(glojure_DOT_core_list)
										tmp169 := lang.Apply(tmp168, []any{lang.NewKeyword("int")})
										tmp170 := lang.Apply(tmp153, []any{tmp155, tmp157, tmp159, tmp161, tmp163, tmp165, tmp167, tmp169})
										tmp171 := lang.Apply(tmp152, []any{tmp170})
										tmp172 := lang.Apply(tmp151, []any{tmp171})
										tmp173 := lang.Apply(tmp135, []any{tmp137, tmp150, tmp172})
										tmp174 := lang.Apply(tmp134, []any{tmp173})
										tmp118 = tmp174
									} // end let
									tmp116 = tmp118
								} else {
									var tmp119 any
									tmp120 := lang.Apply(v114, []any{lang.NewKeyword("hashes"), v115})
									if lang.IsTruthy(tmp120) {
										var tmp121 any
										{ // let
											// let binding "vec__185"
											tmp122 := checkDerefVar(glojure_DOT_core_prep_hashes)
											tmp123 := lang.Apply(tmp122, []any{v16, v50, v96, v99})
											var v124 any = tmp123
											_ = v124
											// let binding "shift"
											tmp125 := checkDerefVar(glojure_DOT_core_nth)
											tmp126 := lang.Apply(tmp125, []any{v124, int64(0), nil})
											var v127 any = tmp126
											_ = v127
											// let binding "mask"
											tmp128 := checkDerefVar(glojure_DOT_core_nth)
											tmp129 := lang.Apply(tmp128, []any{v124, int64(1), nil})
											var v130 any = tmp129
											_ = v130
											// let binding "imap"
											tmp131 := checkDerefVar(glojure_DOT_core_nth)
											tmp132 := lang.Apply(tmp131, []any{v124, int64(2), nil})
											var v133 any = tmp132
											_ = v133
											// let binding "switch-type"
											tmp134 := checkDerefVar(glojure_DOT_core_nth)
											tmp135 := lang.Apply(tmp134, []any{v124, int64(3), nil})
											var v136 any = tmp135
											_ = v136
											// let binding "skip-check"
											tmp137 := checkDerefVar(glojure_DOT_core_nth)
											tmp138 := lang.Apply(tmp137, []any{v124, int64(4), nil})
											var v139 any = tmp138
											_ = v139
											tmp140 := checkDerefVar(glojure_DOT_core_seq)
											tmp141 := checkDerefVar(glojure_DOT_core_concat)
											tmp142 := checkDerefVar(glojure_DOT_core_list)
											tmp143 := lang.Apply(tmp142, []any{lang.NewSymbol("glojure.core/let")})
											tmp144 := checkDerefVar(glojure_DOT_core_list)
											tmp145 := checkDerefVar(glojure_DOT_core_apply)
											tmp146 := checkDerefVar(glojure_DOT_core_vector)
											tmp147 := checkDerefVar(glojure_DOT_core_seq)
											tmp148 := checkDerefVar(glojure_DOT_core_concat)
											tmp149 := checkDerefVar(glojure_DOT_core_list)
											tmp150 := lang.Apply(tmp149, []any{v16})
											tmp151 := checkDerefVar(glojure_DOT_core_list)
											tmp152 := lang.Apply(tmp151, []any{v5})
											tmp153 := lang.Apply(tmp148, []any{tmp150, tmp152})
											tmp154 := lang.Apply(tmp147, []any{tmp153})
											tmp155 := lang.Apply(tmp145, []any{tmp146, tmp154})
											tmp156 := lang.Apply(tmp144, []any{tmp155})
											tmp157 := checkDerefVar(glojure_DOT_core_list)
											tmp158 := checkDerefVar(glojure_DOT_core_seq)
											tmp159 := checkDerefVar(glojure_DOT_core_concat)
											tmp160 := checkDerefVar(glojure_DOT_core_list)
											tmp161 := lang.Apply(tmp160, []any{lang.NewSymbol("case*")})
											tmp162 := checkDerefVar(glojure_DOT_core_list)
											tmp163 := lang.Apply(tmp162, []any{v16})
											tmp164 := checkDerefVar(glojure_DOT_core_list)
											tmp165 := lang.Apply(tmp164, []any{v127})
											tmp166 := checkDerefVar(glojure_DOT_core_list)
											tmp167 := lang.Apply(tmp166, []any{v130})
											tmp168 := checkDerefVar(glojure_DOT_core_list)
											tmp169 := lang.Apply(tmp168, []any{v50})
											tmp170 := checkDerefVar(glojure_DOT_core_list)
											tmp171 := lang.Apply(tmp170, []any{v133})
											tmp172 := checkDerefVar(glojure_DOT_core_list)
											tmp173 := lang.Apply(tmp172, []any{v136})
											tmp174 := checkDerefVar(glojure_DOT_core_list)
											tmp175 := lang.Apply(tmp174, []any{lang.NewKeyword("hash-equiv")})
											tmp176 := checkDerefVar(glojure_DOT_core_list)
											tmp177 := lang.Apply(tmp176, []any{v139})
											tmp178 := lang.Apply(tmp159, []any{tmp161, tmp163, tmp165, tmp167, tmp169, tmp171, tmp173, tmp175, tmp177})
											tmp179 := lang.Apply(tmp158, []any{tmp178})
											tmp180 := lang.Apply(tmp157, []any{tmp179})
											tmp181 := lang.Apply(tmp141, []any{tmp143, tmp156, tmp180})
											tmp182 := lang.Apply(tmp140, []any{tmp181})
											tmp121 = tmp182
										} // end let
										tmp119 = tmp121
									} else {
										var tmp122 any
										tmp123 := lang.Apply(v114, []any{lang.NewKeyword("identity"), v115})
										if lang.IsTruthy(tmp123) {
											var tmp124 any
											{ // let
												// let binding "vec__188"
												tmp125 := checkDerefVar(glojure_DOT_core_prep_hashes)
												tmp126 := lang.Apply(tmp125, []any{v16, v50, v96, v99})
												var v127 any = tmp126
												_ = v127
												// let binding "shift"
												tmp128 := checkDerefVar(glojure_DOT_core_nth)
												tmp129 := lang.Apply(tmp128, []any{v127, int64(0), nil})
												var v130 any = tmp129
												_ = v130
												// let binding "mask"
												tmp131 := checkDerefVar(glojure_DOT_core_nth)
												tmp132 := lang.Apply(tmp131, []any{v127, int64(1), nil})
												var v133 any = tmp132
												_ = v133
												// let binding "imap"
												tmp134 := checkDerefVar(glojure_DOT_core_nth)
												tmp135 := lang.Apply(tmp134, []any{v127, int64(2), nil})
												var v136 any = tmp135
												_ = v136
												// let binding "switch-type"
												tmp137 := checkDerefVar(glojure_DOT_core_nth)
												tmp138 := lang.Apply(tmp137, []any{v127, int64(3), nil})
												var v139 any = tmp138
												_ = v139
												// let binding "skip-check"
												tmp140 := checkDerefVar(glojure_DOT_core_nth)
												tmp141 := lang.Apply(tmp140, []any{v127, int64(4), nil})
												var v142 any = tmp141
												_ = v142
												tmp143 := checkDerefVar(glojure_DOT_core_seq)
												tmp144 := checkDerefVar(glojure_DOT_core_concat)
												tmp145 := checkDerefVar(glojure_DOT_core_list)
												tmp146 := lang.Apply(tmp145, []any{lang.NewSymbol("glojure.core/let")})
												tmp147 := checkDerefVar(glojure_DOT_core_list)
												tmp148 := checkDerefVar(glojure_DOT_core_apply)
												tmp149 := checkDerefVar(glojure_DOT_core_vector)
												tmp150 := checkDerefVar(glojure_DOT_core_seq)
												tmp151 := checkDerefVar(glojure_DOT_core_concat)
												tmp152 := checkDerefVar(glojure_DOT_core_list)
												tmp153 := lang.Apply(tmp152, []any{v16})
												tmp154 := checkDerefVar(glojure_DOT_core_list)
												tmp155 := lang.Apply(tmp154, []any{v5})
												tmp156 := lang.Apply(tmp151, []any{tmp153, tmp155})
												tmp157 := lang.Apply(tmp150, []any{tmp156})
												tmp158 := lang.Apply(tmp148, []any{tmp149, tmp157})
												tmp159 := lang.Apply(tmp147, []any{tmp158})
												tmp160 := checkDerefVar(glojure_DOT_core_list)
												tmp161 := checkDerefVar(glojure_DOT_core_seq)
												tmp162 := checkDerefVar(glojure_DOT_core_concat)
												tmp163 := checkDerefVar(glojure_DOT_core_list)
												tmp164 := lang.Apply(tmp163, []any{lang.NewSymbol("case*")})
												tmp165 := checkDerefVar(glojure_DOT_core_list)
												tmp166 := lang.Apply(tmp165, []any{v16})
												tmp167 := checkDerefVar(glojure_DOT_core_list)
												tmp168 := lang.Apply(tmp167, []any{v130})
												tmp169 := checkDerefVar(glojure_DOT_core_list)
												tmp170 := lang.Apply(tmp169, []any{v133})
												tmp171 := checkDerefVar(glojure_DOT_core_list)
												tmp172 := lang.Apply(tmp171, []any{v50})
												tmp173 := checkDerefVar(glojure_DOT_core_list)
												tmp174 := lang.Apply(tmp173, []any{v136})
												tmp175 := checkDerefVar(glojure_DOT_core_list)
												tmp176 := lang.Apply(tmp175, []any{v139})
												tmp177 := checkDerefVar(glojure_DOT_core_list)
												tmp178 := lang.Apply(tmp177, []any{lang.NewKeyword("hash-identity")})
												tmp179 := checkDerefVar(glojure_DOT_core_list)
												tmp180 := lang.Apply(tmp179, []any{v142})
												tmp181 := lang.Apply(tmp162, []any{tmp164, tmp166, tmp168, tmp170, tmp172, tmp174, tmp176, tmp178, tmp180})
												tmp182 := lang.Apply(tmp161, []any{tmp181})
												tmp183 := lang.Apply(tmp160, []any{tmp182})
												tmp184 := lang.Apply(tmp144, []any{tmp146, tmp159, tmp183})
												tmp185 := lang.Apply(tmp143, []any{tmp184})
												tmp124 = tmp185
											} // end let
											tmp122 = tmp124
										} else {
											tmp125 := checkDerefVar(glojure_DOT_core_str)
											tmp126 := lang.Apply(tmp125, []any{"No matching clause: ", v115})
											tmp127 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp126})
											panic(tmp127)
										}
										tmp119 = tmp122
									}
									tmp116 = tmp119
								}
								tmp112 = tmp116
							} // end let
							tmp77 = tmp112
						} // end let
						tmp51 = tmp77
					}
					tmp7 = tmp51
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// case-map
	{
		tmp0 := lang.NewSymbol("case-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("case-f"), lang.NewSymbol("test-f"), lang.NewSymbol("tests"), lang.NewSymbol("thens"))), lang.NewKeyword("doc"), "Transforms a sequence of test constants and a corresponding sequence of then\n  expressions into a sorted map to be consumed by case*. The form of the map\n  entries are {(case-f test) [(test-f test) then]}.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6614), lang.NewKeyword("end-line"), int(6614), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			tmp7 := checkDerefVar(glojure_DOT_core_into1)
			tmp8 := checkDerefVar(glojure_DOT_core_sorted_map)
			tmp9 := lang.Apply(tmp8, nil)
			tmp10 := checkDerefVar(glojure_DOT_core_zipmap)
			tmp11 := checkDerefVar(glojure_DOT_core_map)
			tmp12 := lang.Apply(tmp11, []any{v3, v5})
			tmp13 := checkDerefVar(glojure_DOT_core_map)
			tmp14 := checkDerefVar(glojure_DOT_core_vector)
			tmp15 := checkDerefVar(glojure_DOT_core_map)
			tmp16 := lang.Apply(tmp15, []any{v4, v5})
			tmp17 := lang.Apply(tmp13, []any{tmp14, tmp16, v6})
			tmp18 := lang.Apply(tmp10, []any{tmp12, tmp17})
			tmp19 := lang.Apply(tmp7, []any{tmp9, tmp18})
			return tmp19
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cast
	{
		tmp0 := lang.NewSymbol("cast").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("c"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Throws a ClassCastException if x is not a c, else returns x.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(345), lang.NewKeyword("end-line"), int(345))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "cast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("cast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cat
	{
		tmp0 := lang.NewSymbol("cat").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rf"))), lang.NewKeyword("doc"), "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7645), lang.NewKeyword("end-line"), int(7645))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "rrf"
				tmp5 := checkDerefVar(glojure_DOT_core_preserving_reduced)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp9 := lang.Apply(v3, nil)
						return tmp9
					case 1:
						v9 := args[0]
						_ = v9
						tmp10 := lang.Apply(v3, []any{v9})
						return tmp10
					case 2:
						v9 := args[0]
						_ = v9
						v10 := args[1]
						_ = v10
						tmp11 := checkDerefVar(glojure_DOT_core_reduce)
						tmp12 := lang.Apply(tmp11, []any{v7, v9, v10})
						return tmp12
					default:
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
				})
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7651), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(7655), lang.NewKeyword("end-column"), int(36))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char
	{
		var tmp1 lang.FnFunc
		{ // function char__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = lang.NewSymbol("uncheckedCharCast")
				} else {
					tmp14 = lang.NewSymbol("charCast")
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("char").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to char", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3511), lang.NewKeyword("end-line"), int(3511))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime7.RT, "CharCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("CharCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-array
	{
		var tmp1 lang.FnFunc
		{ // function char-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(glojure_DOT_core_seq)
					tmp5 := checkDerefVar(glojure_DOT_core_concat)
					tmp6 := checkDerefVar(glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
					tmp8 := checkDerefVar(glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/CharArray")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.core/args")})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("char-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of chars", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5325), lang.NewKeyword("end-line"), int(5325))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "CharArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("CharArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "CharArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("CharArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-escape-string
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("char-escape-string").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("doc"), "Returns escape string for char or nil if none", lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(6), lang.NewKeyword("line"), int(214), lang.NewKeyword("end-line"), int(217))).(*lang.Symbol)
		tmp2 := ns.InternWithValue(tmp0, lang.NewMap(lang.NewChar(10), "\\n", lang.NewChar(9), "\\t", lang.NewChar(13), "\\r", lang.NewChar(34), "\\\"", lang.NewChar(92), "\\\\", lang.NewChar(12), "\\f", lang.NewChar(8), "\\b"), true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-name-string
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("char-name-string").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("doc"), "Returns name string for char or nil if none", lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(6), lang.NewKeyword("line"), int(335), lang.NewKeyword("end-line"), int(338))).(*lang.Symbol)
		tmp2 := ns.InternWithValue(tmp0, lang.NewMap(lang.NewChar(10), "newline", lang.NewChar(9), "tab", lang.NewChar(32), "space", lang.NewChar(8), "backspace", lang.NewChar(12), "formfeed", lang.NewChar(13), "return"), true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char?
	{
		tmp0 := lang.NewSymbol("char?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a Character", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(153), lang.NewKeyword("end-line"), int(157))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function char?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf(int32(0))
				tmp7 := lang.Apply(tmp5, []any{tmp6, v4})
				return tmp7
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(157), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(157), lang.NewKeyword("end-column"), int(89))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chars
	{
		var tmp1 lang.FnFunc
		{ // function chars
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/Chars")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("chars").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to chars[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5382), lang.NewKeyword("end-line"), int(5382))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Chars")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Chars is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// check-cyclic-dependency
	{
		tmp0 := lang.NewSymbol("check-cyclic-dependency").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("path"))), lang.NewKeyword("doc"), "Detects and rejects non-trivial cyclic load dependencies. The\n  exception message shows the dependency chain with the cycle\n  highlighted. Ignores the trivial case of a file attempting to load\n  itself because that can occur when a gen-class'd class loads its\n  implementation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(30), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5974), lang.NewKeyword("end-line"), int(5974), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_some)
			tmp6 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{v3}))
			tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5981), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(5981), lang.NewKeyword("end-column"), int(21))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := checkDerefVar(glojure_DOT_core_rest)
			tmp10 := checkDerefVar(glojure_DOT_core__STAR_pending_paths_STAR_)
			tmp11 := lang.Apply(tmp9, []any{tmp10})
			tmp12 := lang.Apply(tmp5, []any{tmp8, tmp11})
			if lang.IsTruthy(tmp12) {
				var tmp13 any
				{ // let
					// let binding "pending"
					tmp14 := checkDerefVar(glojure_DOT_core_map)
					var tmp15 lang.FnFunc
					tmp15 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v16 := args[0]
						_ = v16
						var tmp17 any
						tmp18 := checkDerefVar(glojure_DOT_core__EQ_)
						tmp19 := lang.Apply(tmp18, []any{v16, v3})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(glojure_DOT_core_str)
							tmp21 := lang.Apply(tmp20, []any{"[ ", v16, " ]"})
							tmp17 = tmp21
						} else {
							tmp17 = v16
						}
						return tmp17
					})
					tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5982), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(5982), lang.NewKeyword("end-column"), int(59))
					tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp18 := checkDerefVar(glojure_DOT_core_cons)
					tmp19 := checkDerefVar(glojure_DOT_core__STAR_pending_paths_STAR_)
					tmp20 := lang.Apply(tmp18, []any{v3, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp17, tmp20})
					var v22 any = tmp21
					_ = v22
					// let binding "chain"
					tmp23 := checkDerefVar(glojure_DOT_core_apply)
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_interpose)
					tmp26 := lang.Apply(tmp25, []any{"->", v22})
					tmp27 := lang.Apply(tmp23, []any{tmp24, tmp26})
					var v28 any = tmp27
					_ = v28
					tmp29 := checkDerefVar(glojure_DOT_core_throw_if)
					tmp30 := lang.Apply(tmp29, []any{true, "Cyclic load dependency: %s", v28})
					tmp13 = tmp30
				} // end let
				tmp4 = tmp13
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// check-valid-options
	{
		tmp0 := lang.NewSymbol("check-valid-options").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("options"), lang.NewSymbol("&"), lang.NewSymbol("valid-keys"))), lang.NewKeyword("doc"), "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(35), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1709), lang.NewKeyword("end-line"), int(1709), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_disj)
				tmp9 := checkDerefVar(glojure_DOT_core_apply)
				tmp10 := checkDerefVar(glojure_DOT_core_hash_set)
				tmp11 := checkDerefVar(glojure_DOT_core_keys)
				tmp12 := lang.Apply(tmp11, []any{v3})
				tmp13 := lang.Apply(tmp9, []any{tmp10, tmp12})
				tmp14 := lang.Apply(tmp7, []any{tmp8, tmp13, v4})
				tmp15 := lang.Apply(tmp6, []any{tmp14})
				if lang.IsTruthy(tmp15) {
					tmp16 := checkDerefVar(glojure_DOT_core_apply)
					tmp17 := checkDerefVar(glojure_DOT_core_str)
					tmp18 := checkDerefVar(glojure_DOT_core_first)
					tmp19 := lang.Apply(tmp18, []any{v4})
					tmp20 := checkDerefVar(glojure_DOT_core_map)
					var tmp21 lang.FnFunc
					tmp21 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v22 := args[0]
						_ = v22
						tmp23 := checkDerefVar(glojure_DOT_core_str)
						tmp24 := lang.Apply(tmp23, []any{", ", v22})
						return tmp24
					})
					tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1718), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(1718), lang.NewKeyword("end-column"), int(28))
					tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp24 := checkDerefVar(glojure_DOT_core_rest)
					tmp25 := lang.Apply(tmp24, []any{v4})
					tmp26 := lang.Apply(tmp20, []any{tmp23, tmp25})
					tmp27 := lang.Apply(tmp16, []any{tmp17, "Only these options are valid: ", tmp19, tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				} else {
				}
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk
	{
		tmp0 := lang.NewSymbol("chunk").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(691), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(691), lang.NewKeyword("end-column"), int(41), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("b"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunk")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunk")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-append
	{
		tmp0 := lang.NewSymbol("chunk-append").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(688), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(688), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("b"), lang.NewSymbol("x"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "add")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-buffer
	{
		tmp0 := lang.NewSymbol("chunk-buffer").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(685), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(685), lang.NewKeyword("end-column"), int(53), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("capacity"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.NewChunkBuffer, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-cons
	{
		tmp0 := lang.NewSymbol("chunk-cons").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(703), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(703), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("chunk"), lang.NewSymbol("rest"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := lang.Apply(lang.Count, []any{v3})
			tmp7 := lang.Apply(lang.IsZero, []any{tmp6})
			if lang.IsTruthy(tmp7) {
				tmp5 = v4
			} else {
				tmp8 := lang.Apply(lang.NewChunkedCons, []any{v3, v4})
				tmp5 = tmp8
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-first
	{
		tmp0 := lang.NewSymbol("chunk-first").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(694), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(694), lang.NewKeyword("end-column"), int(48), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunkedFirst")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunkedFirst")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-next
	{
		tmp0 := lang.NewSymbol("chunk-next").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(700), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(700), lang.NewKeyword("end-column"), int(71), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunkedNext")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunkedNext")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-rest
	{
		tmp0 := lang.NewSymbol("chunk-rest").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(697), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(697), lang.NewKeyword("end-column"), int(71), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunkedMore")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunkedMore")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunked-seq?
	{
		tmp0 := lang.NewSymbol("chunked-seq?").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(708), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(708), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.IChunkedSeq)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// class
	{
		tmp0 := lang.NewSymbol("class").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns the Class of x", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3461), lang.NewKeyword("end-line"), int(3461))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp4 = v3
			} else {
				tmp7 := lang.Apply(lang.TypeOf, []any{v3})
				tmp4 = tmp7
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// class?
	{
		tmp0 := lang.NewSymbol("class?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is an instance of Class", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5465), lang.NewKeyword("end-line"), int(5465))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// clear-agent-errors
	{
		tmp0 := lang.NewSymbol("clear-agent-errors").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("doc"), "DEPRECATED: Use 'restart-agent' instead.\n  Clears any exceptions thrown during asynchronous actions of the\n  agent, allowing subsequent actions to occur.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("deprecated"), "1.2", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2244), lang.NewKeyword("end-line"), int(2244))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_restart_agent)
			tmp5, ok := lang.FieldOrMethod(v3, "Deref")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Deref")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{v3, tmp6})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// coll?
	{
		tmp0 := lang.NewSymbol("coll?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x implements IPersistentCollection", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6192), lang.NewKeyword("end-line"), int(6192))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comment
	{
		tmp0 := lang.NewSymbol("comment").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Ignores body, yields nil", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4733), lang.NewKeyword("end-line"), int(4733))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				return nil
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// commute
	{
		tmp0 := lang.NewSymbol("commute").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("fun"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2414), lang.NewKeyword("end-line"), int(2414))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "Commute")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Commute is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comp
	{
		tmp0 := lang.NewSymbol("comp").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("g")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("g"), lang.NewSymbol("&"), lang.NewSymbol("fs"))), lang.NewKeyword("doc"), "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2549), lang.NewKeyword("end-line"), int(2549))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(glojure_DOT_core_identity)
				return tmp3
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v4, nil)
						tmp7 := lang.Apply(v3, []any{tmp6})
						return tmp7
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v4, []any{v6})
						tmp8 := lang.Apply(v3, []any{tmp7})
						return tmp8
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v4, []any{v6, v7})
						tmp9 := lang.Apply(v3, []any{tmp8})
						return tmp9
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						tmp9 := lang.Apply(v4, []any{v6, v7, v8})
						tmp10 := lang.Apply(v3, []any{tmp9})
						return tmp10
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := checkDerefVar(glojure_DOT_core_apply)
						tmp11 := lang.Apply(tmp10, []any{v4, v6, v7, v8, v9})
						tmp12 := lang.Apply(v3, []any{tmp11})
						return tmp12
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2559), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2564), lang.NewKeyword("end-column"), int(49))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp7 := checkDerefVar(glojure_DOT_core_comp)
				tmp8 := checkDerefVar(glojure_DOT_core_list_STAR_)
				tmp9 := lang.Apply(tmp8, []any{v3, v4, v5})
				tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comparator
	{
		tmp0 := lang.NewSymbol("comparator").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"))), lang.NewKeyword("doc"), "Returns an implementation of java.util.Comparator based upon pred.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3077), lang.NewKeyword("end-line"), int(3077))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var tmp7 any
				tmp8 := lang.Apply(v3, []any{v5, v6})
				if lang.IsTruthy(tmp8) {
					tmp7 = int64(-1)
				} else {
					var tmp9 any
					tmp10 := lang.Apply(v3, []any{v6, v5})
					if lang.IsTruthy(tmp10) {
						tmp9 = int64(1)
					} else {
						var tmp11 any
						if lang.IsTruthy(lang.NewKeyword("else")) {
							tmp11 = int64(0)
						} else {
						}
						tmp9 = tmp11
					}
					tmp7 = tmp9
				}
				return tmp7
			})
			tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3082), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(3083), lang.NewKeyword("end-column"), int(48))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compare
	{
		var tmp1 lang.FnFunc
		{ // function compare__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.lang.Util")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("glojure.core/compare")})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp5, []any{tmp17})
				return tmp18
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("compare").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Same as Java x.compareTo(y) except it also works for nil, and\n  compares numbers and collections in a type-independent manner. x\n  must implement Comparable", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(824), lang.NewKeyword("end-line"), int(824))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := lang.Apply(lang.Compare, []any{v4, v5})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compare-and-set!
	{
		tmp0 := lang.NewSymbol("compare-and-set!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atom"), lang.NewSymbol("oldval"), lang.NewSymbol("newval"))), lang.NewKeyword("doc"), "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2360), lang.NewKeyword("end-line"), int(2360))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(v3, "compareAndSet")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("compareAndSet is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compile
	{
		tmp0 := lang.NewSymbol("compile").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("lib"))), lang.NewKeyword("doc"), "Compiles the namespace named by the symbol lib into a set of\n  classfiles. The source for the lib must be in a proper\n  classpath-relative directory. The output files will go into the\n  directory specified by *compile-path*, and that directory too must\n  be in the classpath.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6114), lang.NewKeyword("end-line"), int(6114))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				tmp5 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
				tmp6 := checkDerefVar(glojure_DOT_core_hash_map)
				tmp7 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*compile-files*"))
				tmp8 := lang.Apply(tmp6, []any{tmp7, true})
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				_ = tmp9
				var tmp10 any
				func() {
					defer func() {
						tmp11 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
						tmp12 := lang.Apply(tmp11, nil)
						_ = tmp12
					}()
					tmp13 := checkDerefVar(glojure_DOT_core_load_one)
					tmp14 := lang.Apply(tmp13, []any{v3, true, true})
					tmp10 = tmp14
				}()
				tmp4 = tmp10
			} // end let
			_ = tmp4
			return v3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// complement
	{
		tmp0 := lang.NewSymbol("complement").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1428), lang.NewKeyword("end-line"), int(1428))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 0:
					tmp5 := checkDerefVar(glojure_DOT_core_not)
					tmp6 := lang.Apply(v3, nil)
					tmp7 := lang.Apply(tmp5, []any{tmp6})
					return tmp7
				case 1:
					v5 := args[0]
					_ = v5
					tmp6 := checkDerefVar(glojure_DOT_core_not)
					tmp7 := lang.Apply(v3, []any{v5})
					tmp8 := lang.Apply(tmp6, []any{tmp7})
					return tmp8
				case 2:
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_not)
					tmp8 := lang.Apply(v3, []any{v5, v6})
					tmp9 := lang.Apply(tmp7, []any{tmp8})
					return tmp9
				default:
					if len(args) < 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					var v7 any = lang.NewList(args[2:]...)
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_not)
					tmp9 := checkDerefVar(glojure_DOT_core_apply)
					tmp10 := lang.Apply(tmp9, []any{v3, v5, v6, v7})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					return tmp11
				}
			})
			tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1434), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(1438), lang.NewKeyword("end-column"), int(40))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// completing
	{
		tmp0 := lang.NewSymbol("completing").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("cf"))), lang.NewKeyword("doc"), "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6893), lang.NewKeyword("end-line"), int(6893))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_completing)
				tmp5 := checkDerefVar(glojure_DOT_core_identity)
				tmp6 := lang.Apply(tmp4, []any{v3, tmp5})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v3, nil)
						return tmp6
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v4, []any{v6})
						return tmp7
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v6, v7})
						return tmp8
					default:
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6900), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(6903), lang.NewKeyword("end-column"), int(23))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// concat
	{
		tmp0 := lang.NewSymbol("concat").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("zs"))), lang.NewKeyword("doc"), "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(711), lang.NewKeyword("end-line"), int(711))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					return nil
				})
				tmp4 := lang.Apply(lang.NewLazySeq, []any{tmp3})
				return tmp4
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					return v3
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "s"
						tmp7 := checkDerefVar(glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v3})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							tmp12 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
							tmp13 := lang.Apply(tmp12, []any{v9})
							if lang.IsTruthy(tmp13) {
								tmp14 := checkDerefVar(glojure_DOT_core_chunk_cons)
								tmp15 := checkDerefVar(glojure_DOT_core_chunk_first)
								tmp16 := lang.Apply(tmp15, []any{v9})
								tmp17 := checkDerefVar(glojure_DOT_core_concat)
								tmp18 := checkDerefVar(glojure_DOT_core_chunk_rest)
								tmp19 := lang.Apply(tmp18, []any{v9})
								tmp20 := lang.Apply(tmp17, []any{tmp19, v4})
								tmp21 := lang.Apply(tmp14, []any{tmp16, tmp20})
								tmp11 = tmp21
							} else {
								tmp22 := checkDerefVar(glojure_DOT_core_cons)
								tmp23 := checkDerefVar(glojure_DOT_core_first)
								tmp24 := lang.Apply(tmp23, []any{v9})
								tmp25 := checkDerefVar(glojure_DOT_core_concat)
								tmp26 := checkDerefVar(glojure_DOT_core_rest)
								tmp27 := lang.Apply(tmp26, []any{v9})
								tmp28 := lang.Apply(tmp25, []any{tmp27, v4})
								tmp29 := lang.Apply(tmp22, []any{tmp24, tmp28})
								tmp11 = tmp29
							}
							tmp10 = tmp11
						} else {
							tmp10 = v4
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "cat"
					var tmp7 lang.FnFunc
					{ // function cat
						var v8 lang.FnFunc
						tmp7 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v9 := args[0]
							_ = v9
							v10 := args[1]
							_ = v10
							var tmp11 lang.FnFunc
							tmp11 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								var tmp12 any
								{ // let
									// let binding "xys"
									tmp13 := checkDerefVar(glojure_DOT_core_seq)
									tmp14 := lang.Apply(tmp13, []any{v9})
									var v15 any = tmp14
									_ = v15
									var tmp16 any
									if lang.IsTruthy(v15) {
										var tmp17 any
										tmp18 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
										tmp19 := lang.Apply(tmp18, []any{v15})
										if lang.IsTruthy(tmp19) {
											tmp20 := checkDerefVar(glojure_DOT_core_chunk_cons)
											tmp21 := checkDerefVar(glojure_DOT_core_chunk_first)
											tmp22 := lang.Apply(tmp21, []any{v15})
											tmp23 := checkDerefVar(glojure_DOT_core_chunk_rest)
											tmp24 := lang.Apply(tmp23, []any{v15})
											tmp25 := lang.Apply(v8, []any{tmp24, v10})
											tmp26 := lang.Apply(tmp20, []any{tmp22, tmp25})
											tmp17 = tmp26
										} else {
											tmp27 := checkDerefVar(glojure_DOT_core_cons)
											tmp28 := checkDerefVar(glojure_DOT_core_first)
											tmp29 := lang.Apply(tmp28, []any{v15})
											tmp30 := checkDerefVar(glojure_DOT_core_rest)
											tmp31 := lang.Apply(tmp30, []any{v15})
											tmp32 := lang.Apply(v8, []any{tmp31, v10})
											tmp33 := lang.Apply(tmp27, []any{tmp29, tmp32})
											tmp17 = tmp33
										}
										tmp16 = tmp17
									} else {
										var tmp34 any
										if lang.IsTruthy(v10) {
											tmp35 := checkDerefVar(glojure_DOT_core_first)
											tmp36 := lang.Apply(tmp35, []any{v10})
											tmp37 := checkDerefVar(glojure_DOT_core_next)
											tmp38 := lang.Apply(tmp37, []any{v10})
											tmp39 := lang.Apply(v8, []any{tmp36, tmp38})
											tmp34 = tmp39
										} else {
										}
										tmp16 = tmp34
									}
									tmp12 = tmp16
								} // end let
								return tmp12
							})
							tmp12 := lang.Apply(lang.NewLazySeq, []any{tmp11})
							return tmp12
						})
						v8 = tmp7
						_ = v8
					}
					tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(726), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(735), lang.NewKeyword("end-column"), int(56))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v10 any = tmp9
					_ = v10
					tmp11 := checkDerefVar(glojure_DOT_core_concat)
					tmp12 := lang.Apply(tmp11, []any{v3, v4})
					tmp13 := lang.Apply(v10, []any{tmp12, v5})
					tmp6 = tmp13
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond
	{
		tmp0 := lang.NewSymbol("cond").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("clauses"))), lang.NewKeyword("doc"), "Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(569), lang.NewKeyword("end-line"), int(569))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v5) {
					tmp7 := checkDerefVar(glojure_DOT_core_list)
					tmp8 := checkDerefVar(glojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v5})
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v5})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(glojure_DOT_core_second)
						tmp14 := lang.Apply(tmp13, []any{v5})
						tmp10 = tmp14
					} else {
						tmp15 := lang.Apply(lang.NewIllegalArgumentError, []any{"cond requires an even number of forms"})
						panic(tmp15)
					}
					tmp16 := checkDerefVar(glojure_DOT_core_cons)
					tmp17 := checkDerefVar(glojure_DOT_core_next)
					tmp18 := checkDerefVar(glojure_DOT_core_next)
					tmp19 := lang.Apply(tmp18, []any{v5})
					tmp20 := lang.Apply(tmp17, []any{tmp19})
					tmp21 := lang.Apply(tmp16, []any{lang.NewSymbol("glojure.core/cond"), tmp20})
					tmp22 := lang.Apply(tmp7, []any{lang.NewSymbol("if"), tmp9, tmp10, tmp21})
					tmp6 = tmp22
				} else {
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond->
	{
		tmp0 := lang.NewSymbol("cond->").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"), lang.NewSymbol("&"), lang.NewSymbol("clauses"))), lang.NewKeyword("doc"), "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7564), lang.NewKeyword("end-line"), int(7564))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := checkDerefVar(glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, nil)
					var v10 any = tmp9
					_ = v10
					// let binding "steps"
					tmp11 := checkDerefVar(glojure_DOT_core_map)
					var tmp12 lang.FnFunc
					tmp12 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v13 := args[0]
						_ = v13
						var tmp14 any
						{ // let
							// let binding "vec__349"
							var v15 any = v13
							_ = v15
							// let binding "test"
							tmp16 := checkDerefVar(glojure_DOT_core_nth)
							tmp17 := lang.Apply(tmp16, []any{v15, int64(0), nil})
							var v18 any = tmp17
							_ = v18
							// let binding "step"
							tmp19 := checkDerefVar(glojure_DOT_core_nth)
							tmp20 := lang.Apply(tmp19, []any{v15, int64(1), nil})
							var v21 any = tmp20
							_ = v21
							tmp22 := checkDerefVar(glojure_DOT_core_seq)
							tmp23 := checkDerefVar(glojure_DOT_core_concat)
							tmp24 := checkDerefVar(glojure_DOT_core_list)
							tmp25 := lang.Apply(tmp24, []any{lang.NewSymbol("if")})
							tmp26 := checkDerefVar(glojure_DOT_core_list)
							tmp27 := lang.Apply(tmp26, []any{v18})
							tmp28 := checkDerefVar(glojure_DOT_core_list)
							tmp29 := checkDerefVar(glojure_DOT_core_seq)
							tmp30 := checkDerefVar(glojure_DOT_core_concat)
							tmp31 := checkDerefVar(glojure_DOT_core_list)
							tmp32 := lang.Apply(tmp31, []any{lang.NewSymbol("glojure.core/->")})
							tmp33 := checkDerefVar(glojure_DOT_core_list)
							tmp34 := lang.Apply(tmp33, []any{v10})
							tmp35 := checkDerefVar(glojure_DOT_core_list)
							tmp36 := lang.Apply(tmp35, []any{v21})
							tmp37 := lang.Apply(tmp30, []any{tmp32, tmp34, tmp36})
							tmp38 := lang.Apply(tmp29, []any{tmp37})
							tmp39 := lang.Apply(tmp28, []any{tmp38})
							tmp40 := checkDerefVar(glojure_DOT_core_list)
							tmp41 := lang.Apply(tmp40, []any{v10})
							tmp42 := lang.Apply(tmp23, []any{tmp25, tmp27, tmp39, tmp41})
							tmp43 := lang.Apply(tmp22, []any{tmp42})
							tmp14 = tmp43
						} // end let
						return tmp14
					})
					tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7573), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7573), lang.NewKeyword("end-column"), int(66))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := checkDerefVar(glojure_DOT_core_partition)
					tmp16 := lang.Apply(tmp15, []any{int64(2), v6})
					tmp17 := lang.Apply(tmp11, []any{tmp14, tmp16})
					var v18 any = tmp17
					_ = v18
					tmp19 := checkDerefVar(glojure_DOT_core_seq)
					tmp20 := checkDerefVar(glojure_DOT_core_concat)
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/let")})
					tmp23 := checkDerefVar(glojure_DOT_core_list)
					tmp24 := checkDerefVar(glojure_DOT_core_apply)
					tmp25 := checkDerefVar(glojure_DOT_core_vector)
					tmp26 := checkDerefVar(glojure_DOT_core_seq)
					tmp27 := checkDerefVar(glojure_DOT_core_concat)
					tmp28 := checkDerefVar(glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{v10})
					tmp30 := checkDerefVar(glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{v5})
					tmp32 := checkDerefVar(glojure_DOT_core_interleave)
					tmp33 := checkDerefVar(glojure_DOT_core_repeat)
					tmp34 := lang.Apply(tmp33, []any{v10})
					tmp35 := checkDerefVar(glojure_DOT_core_butlast)
					tmp36 := lang.Apply(tmp35, []any{v18})
					tmp37 := lang.Apply(tmp32, []any{tmp34, tmp36})
					tmp38 := lang.Apply(tmp27, []any{tmp29, tmp31, tmp37})
					tmp39 := lang.Apply(tmp26, []any{tmp38})
					tmp40 := lang.Apply(tmp24, []any{tmp25, tmp39})
					tmp41 := lang.Apply(tmp23, []any{tmp40})
					tmp42 := checkDerefVar(glojure_DOT_core_list)
					var tmp43 any
					tmp44 := checkDerefVar(glojure_DOT_core_empty_QMARK_)
					tmp45 := lang.Apply(tmp44, []any{v18})
					if lang.IsTruthy(tmp45) {
						tmp43 = v10
					} else {
						tmp46 := checkDerefVar(glojure_DOT_core_last)
						tmp47 := lang.Apply(tmp46, []any{v18})
						tmp43 = tmp47
					}
					tmp48 := lang.Apply(tmp42, []any{tmp43})
					tmp49 := lang.Apply(tmp20, []any{tmp22, tmp41, tmp48})
					tmp50 := lang.Apply(tmp19, []any{tmp49})
					tmp7 = tmp50
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond->>
	{
		tmp0 := lang.NewSymbol("cond->>").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"), lang.NewSymbol("&"), lang.NewSymbol("clauses"))), lang.NewKeyword("doc"), "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7581), lang.NewKeyword("end-line"), int(7581))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := checkDerefVar(glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, nil)
					var v10 any = tmp9
					_ = v10
					// let binding "steps"
					tmp11 := checkDerefVar(glojure_DOT_core_map)
					var tmp12 lang.FnFunc
					tmp12 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v13 := args[0]
						_ = v13
						var tmp14 any
						{ // let
							// let binding "vec__353"
							var v15 any = v13
							_ = v15
							// let binding "test"
							tmp16 := checkDerefVar(glojure_DOT_core_nth)
							tmp17 := lang.Apply(tmp16, []any{v15, int64(0), nil})
							var v18 any = tmp17
							_ = v18
							// let binding "step"
							tmp19 := checkDerefVar(glojure_DOT_core_nth)
							tmp20 := lang.Apply(tmp19, []any{v15, int64(1), nil})
							var v21 any = tmp20
							_ = v21
							tmp22 := checkDerefVar(glojure_DOT_core_seq)
							tmp23 := checkDerefVar(glojure_DOT_core_concat)
							tmp24 := checkDerefVar(glojure_DOT_core_list)
							tmp25 := lang.Apply(tmp24, []any{lang.NewSymbol("if")})
							tmp26 := checkDerefVar(glojure_DOT_core_list)
							tmp27 := lang.Apply(tmp26, []any{v18})
							tmp28 := checkDerefVar(glojure_DOT_core_list)
							tmp29 := checkDerefVar(glojure_DOT_core_seq)
							tmp30 := checkDerefVar(glojure_DOT_core_concat)
							tmp31 := checkDerefVar(glojure_DOT_core_list)
							tmp32 := lang.Apply(tmp31, []any{lang.NewSymbol("glojure.core/->>")})
							tmp33 := checkDerefVar(glojure_DOT_core_list)
							tmp34 := lang.Apply(tmp33, []any{v10})
							tmp35 := checkDerefVar(glojure_DOT_core_list)
							tmp36 := lang.Apply(tmp35, []any{v21})
							tmp37 := lang.Apply(tmp30, []any{tmp32, tmp34, tmp36})
							tmp38 := lang.Apply(tmp29, []any{tmp37})
							tmp39 := lang.Apply(tmp28, []any{tmp38})
							tmp40 := checkDerefVar(glojure_DOT_core_list)
							tmp41 := lang.Apply(tmp40, []any{v10})
							tmp42 := lang.Apply(tmp23, []any{tmp25, tmp27, tmp39, tmp41})
							tmp43 := lang.Apply(tmp22, []any{tmp42})
							tmp14 = tmp43
						} // end let
						return tmp14
					})
					tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7590), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7590), lang.NewKeyword("end-column"), int(67))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := checkDerefVar(glojure_DOT_core_partition)
					tmp16 := lang.Apply(tmp15, []any{int64(2), v6})
					tmp17 := lang.Apply(tmp11, []any{tmp14, tmp16})
					var v18 any = tmp17
					_ = v18
					tmp19 := checkDerefVar(glojure_DOT_core_seq)
					tmp20 := checkDerefVar(glojure_DOT_core_concat)
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/let")})
					tmp23 := checkDerefVar(glojure_DOT_core_list)
					tmp24 := checkDerefVar(glojure_DOT_core_apply)
					tmp25 := checkDerefVar(glojure_DOT_core_vector)
					tmp26 := checkDerefVar(glojure_DOT_core_seq)
					tmp27 := checkDerefVar(glojure_DOT_core_concat)
					tmp28 := checkDerefVar(glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{v10})
					tmp30 := checkDerefVar(glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{v5})
					tmp32 := checkDerefVar(glojure_DOT_core_interleave)
					tmp33 := checkDerefVar(glojure_DOT_core_repeat)
					tmp34 := lang.Apply(tmp33, []any{v10})
					tmp35 := checkDerefVar(glojure_DOT_core_butlast)
					tmp36 := lang.Apply(tmp35, []any{v18})
					tmp37 := lang.Apply(tmp32, []any{tmp34, tmp36})
					tmp38 := lang.Apply(tmp27, []any{tmp29, tmp31, tmp37})
					tmp39 := lang.Apply(tmp26, []any{tmp38})
					tmp40 := lang.Apply(tmp24, []any{tmp25, tmp39})
					tmp41 := lang.Apply(tmp23, []any{tmp40})
					tmp42 := checkDerefVar(glojure_DOT_core_list)
					var tmp43 any
					tmp44 := checkDerefVar(glojure_DOT_core_empty_QMARK_)
					tmp45 := lang.Apply(tmp44, []any{v18})
					if lang.IsTruthy(tmp45) {
						tmp43 = v10
					} else {
						tmp46 := checkDerefVar(glojure_DOT_core_last)
						tmp47 := lang.Apply(tmp46, []any{v18})
						tmp43 = tmp47
					}
					tmp48 := lang.Apply(tmp42, []any{tmp43})
					tmp49 := lang.Apply(tmp20, []any{tmp22, tmp41, tmp48})
					tmp50 := lang.Apply(tmp19, []any{tmp49})
					tmp7 = tmp50
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// condp
	{
		tmp0 := lang.NewSymbol("condp").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("expr"), lang.NewSymbol("&"), lang.NewSymbol("clauses"))), lang.NewKeyword("doc"), "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(6353), lang.NewKeyword("end-line"), int(6353))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 any
				{ // let
					// let binding "gpred"
					tmp9 := checkDerefVar(glojure_DOT_core_gensym)
					tmp10 := lang.Apply(tmp9, []any{"pred__"})
					var v11 any = tmp10
					_ = v11
					// let binding "gexpr"
					tmp12 := checkDerefVar(glojure_DOT_core_gensym)
					tmp13 := lang.Apply(tmp12, []any{"expr__"})
					var v14 any = tmp13
					_ = v14
					// let binding "emit"
					var tmp15 lang.FnFunc
					{ // function emit
						var v16 lang.FnFunc
						tmp15 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v17 := args[0]
							_ = v17
							v18 := args[1]
							_ = v18
							v19 := args[2]
							_ = v19
							var tmp20 any
							{ // let
								// let binding "vec__144"
								tmp21 := checkDerefVar(glojure_DOT_core_split_at)
								var tmp22 any
								tmp23 := checkDerefVar(glojure_DOT_core__EQ_)
								tmp24 := checkDerefVar(glojure_DOT_core_second)
								tmp25 := lang.Apply(tmp24, []any{v19})
								tmp26 := lang.Apply(tmp23, []any{lang.NewKeyword(">>"), tmp25})
								if lang.IsTruthy(tmp26) {
									tmp22 = int64(3)
								} else {
									tmp22 = int64(2)
								}
								tmp27 := lang.Apply(tmp21, []any{tmp22, v19})
								var v28 any = tmp27
								_ = v28
								// let binding "vec__147"
								tmp29 := checkDerefVar(glojure_DOT_core_nth)
								tmp30 := lang.Apply(tmp29, []any{v28, int64(0), nil})
								var v31 any = tmp30
								_ = v31
								// let binding "a"
								tmp32 := checkDerefVar(glojure_DOT_core_nth)
								tmp33 := lang.Apply(tmp32, []any{v31, int64(0), nil})
								var v34 any = tmp33
								_ = v34
								// let binding "b"
								tmp35 := checkDerefVar(glojure_DOT_core_nth)
								tmp36 := lang.Apply(tmp35, []any{v31, int64(1), nil})
								var v37 any = tmp36
								_ = v37
								// let binding "c"
								tmp38 := checkDerefVar(glojure_DOT_core_nth)
								tmp39 := lang.Apply(tmp38, []any{v31, int64(2), nil})
								var v40 any = tmp39
								_ = v40
								// let binding "clause"
								var v41 any = v31
								_ = v41
								// let binding "more"
								tmp42 := checkDerefVar(glojure_DOT_core_nth)
								tmp43 := lang.Apply(tmp42, []any{v28, int64(1), nil})
								var v44 any = tmp43
								_ = v44
								// let binding "n"
								tmp45 := checkDerefVar(glojure_DOT_core_count)
								tmp46 := lang.Apply(tmp45, []any{v41})
								var v47 any = tmp46
								_ = v47
								var tmp48 any
								tmp49 := checkDerefVar(glojure_DOT_core__EQ_)
								tmp50 := lang.Apply(tmp49, []any{int64(0), v47})
								if lang.IsTruthy(tmp50) {
									tmp51 := checkDerefVar(glojure_DOT_core_seq)
									tmp52 := checkDerefVar(glojure_DOT_core_concat)
									tmp53 := checkDerefVar(glojure_DOT_core_list)
									tmp54 := lang.Apply(tmp53, []any{lang.NewSymbol("throw")})
									tmp55 := checkDerefVar(glojure_DOT_core_list)
									tmp56 := checkDerefVar(glojure_DOT_core_seq)
									tmp57 := checkDerefVar(glojure_DOT_core_concat)
									tmp58 := checkDerefVar(glojure_DOT_core_list)
									tmp59 := lang.Apply(tmp58, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewIllegalArgumentError")})
									tmp60 := checkDerefVar(glojure_DOT_core_list)
									tmp61 := checkDerefVar(glojure_DOT_core_seq)
									tmp62 := checkDerefVar(glojure_DOT_core_concat)
									tmp63 := checkDerefVar(glojure_DOT_core_list)
									tmp64 := lang.Apply(tmp63, []any{lang.NewSymbol("glojure.core/str")})
									tmp65 := checkDerefVar(glojure_DOT_core_list)
									tmp66 := lang.Apply(tmp65, []any{"No matching clause: "})
									tmp67 := checkDerefVar(glojure_DOT_core_list)
									tmp68 := lang.Apply(tmp67, []any{v18})
									tmp69 := lang.Apply(tmp62, []any{tmp64, tmp66, tmp68})
									tmp70 := lang.Apply(tmp61, []any{tmp69})
									tmp71 := lang.Apply(tmp60, []any{tmp70})
									tmp72 := lang.Apply(tmp57, []any{tmp59, tmp71})
									tmp73 := lang.Apply(tmp56, []any{tmp72})
									tmp74 := lang.Apply(tmp55, []any{tmp73})
									tmp75 := lang.Apply(tmp52, []any{tmp54, tmp74})
									tmp76 := lang.Apply(tmp51, []any{tmp75})
									tmp48 = tmp76
								} else {
									var tmp77 any
									tmp78 := checkDerefVar(glojure_DOT_core__EQ_)
									tmp79 := lang.Apply(tmp78, []any{int64(1), v47})
									if lang.IsTruthy(tmp79) {
										tmp77 = v34
									} else {
										var tmp80 any
										tmp81 := checkDerefVar(glojure_DOT_core__EQ_)
										tmp82 := lang.Apply(tmp81, []any{int64(2), v47})
										if lang.IsTruthy(tmp82) {
											tmp83 := checkDerefVar(glojure_DOT_core_seq)
											tmp84 := checkDerefVar(glojure_DOT_core_concat)
											tmp85 := checkDerefVar(glojure_DOT_core_list)
											tmp86 := lang.Apply(tmp85, []any{lang.NewSymbol("if")})
											tmp87 := checkDerefVar(glojure_DOT_core_list)
											tmp88 := checkDerefVar(glojure_DOT_core_seq)
											tmp89 := checkDerefVar(glojure_DOT_core_concat)
											tmp90 := checkDerefVar(glojure_DOT_core_list)
											tmp91 := lang.Apply(tmp90, []any{v17})
											tmp92 := checkDerefVar(glojure_DOT_core_list)
											tmp93 := lang.Apply(tmp92, []any{v34})
											tmp94 := checkDerefVar(glojure_DOT_core_list)
											tmp95 := lang.Apply(tmp94, []any{v18})
											tmp96 := lang.Apply(tmp89, []any{tmp91, tmp93, tmp95})
											tmp97 := lang.Apply(tmp88, []any{tmp96})
											tmp98 := lang.Apply(tmp87, []any{tmp97})
											tmp99 := checkDerefVar(glojure_DOT_core_list)
											tmp100 := lang.Apply(tmp99, []any{v37})
											tmp101 := checkDerefVar(glojure_DOT_core_list)
											tmp102 := lang.Apply(v16, []any{v17, v18, v44})
											tmp103 := lang.Apply(tmp101, []any{tmp102})
											tmp104 := lang.Apply(tmp84, []any{tmp86, tmp98, tmp100, tmp103})
											tmp105 := lang.Apply(tmp83, []any{tmp104})
											tmp80 = tmp105
										} else {
											var tmp106 any
											if lang.IsTruthy(lang.NewKeyword("else")) {
												tmp107 := checkDerefVar(glojure_DOT_core_seq)
												tmp108 := checkDerefVar(glojure_DOT_core_concat)
												tmp109 := checkDerefVar(glojure_DOT_core_list)
												tmp110 := lang.Apply(tmp109, []any{lang.NewSymbol("glojure.core/if-let")})
												tmp111 := checkDerefVar(glojure_DOT_core_list)
												tmp112 := checkDerefVar(glojure_DOT_core_apply)
												tmp113 := checkDerefVar(glojure_DOT_core_vector)
												tmp114 := checkDerefVar(glojure_DOT_core_seq)
												tmp115 := checkDerefVar(glojure_DOT_core_concat)
												tmp116 := checkDerefVar(glojure_DOT_core_list)
												tmp117 := lang.Apply(tmp116, []any{lang.NewSymbol("p__0__auto__")})
												tmp118 := checkDerefVar(glojure_DOT_core_list)
												tmp119 := checkDerefVar(glojure_DOT_core_seq)
												tmp120 := checkDerefVar(glojure_DOT_core_concat)
												tmp121 := checkDerefVar(glojure_DOT_core_list)
												tmp122 := lang.Apply(tmp121, []any{v17})
												tmp123 := checkDerefVar(glojure_DOT_core_list)
												tmp124 := lang.Apply(tmp123, []any{v34})
												tmp125 := checkDerefVar(glojure_DOT_core_list)
												tmp126 := lang.Apply(tmp125, []any{v18})
												tmp127 := lang.Apply(tmp120, []any{tmp122, tmp124, tmp126})
												tmp128 := lang.Apply(tmp119, []any{tmp127})
												tmp129 := lang.Apply(tmp118, []any{tmp128})
												tmp130 := lang.Apply(tmp115, []any{tmp117, tmp129})
												tmp131 := lang.Apply(tmp114, []any{tmp130})
												tmp132 := lang.Apply(tmp112, []any{tmp113, tmp131})
												tmp133 := lang.Apply(tmp111, []any{tmp132})
												tmp134 := checkDerefVar(glojure_DOT_core_list)
												tmp135 := checkDerefVar(glojure_DOT_core_seq)
												tmp136 := checkDerefVar(glojure_DOT_core_concat)
												tmp137 := checkDerefVar(glojure_DOT_core_list)
												tmp138 := lang.Apply(tmp137, []any{v40})
												tmp139 := checkDerefVar(glojure_DOT_core_list)
												tmp140 := lang.Apply(tmp139, []any{lang.NewSymbol("p__0__auto__")})
												tmp141 := lang.Apply(tmp136, []any{tmp138, tmp140})
												tmp142 := lang.Apply(tmp135, []any{tmp141})
												tmp143 := lang.Apply(tmp134, []any{tmp142})
												tmp144 := checkDerefVar(glojure_DOT_core_list)
												tmp145 := lang.Apply(v16, []any{v17, v18, v44})
												tmp146 := lang.Apply(tmp144, []any{tmp145})
												tmp147 := lang.Apply(tmp108, []any{tmp110, tmp133, tmp143, tmp146})
												tmp148 := lang.Apply(tmp107, []any{tmp147})
												tmp106 = tmp148
											} else {
											}
											tmp80 = tmp106
										}
										tmp77 = tmp80
									}
									tmp48 = tmp77
								}
								tmp20 = tmp48
							} // end let
							return tmp20
						})
						v16 = tmp15
						_ = v16
					}
					tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6377), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(6389), lang.NewKeyword("end-column"), int(53))
					tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v18 any = tmp17
					_ = v18
					tmp19 := checkDerefVar(glojure_DOT_core_seq)
					tmp20 := checkDerefVar(glojure_DOT_core_concat)
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/let")})
					tmp23 := checkDerefVar(glojure_DOT_core_list)
					tmp24 := checkDerefVar(glojure_DOT_core_apply)
					tmp25 := checkDerefVar(glojure_DOT_core_vector)
					tmp26 := checkDerefVar(glojure_DOT_core_seq)
					tmp27 := checkDerefVar(glojure_DOT_core_concat)
					tmp28 := checkDerefVar(glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{v11})
					tmp30 := checkDerefVar(glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{v5})
					tmp32 := checkDerefVar(glojure_DOT_core_list)
					tmp33 := lang.Apply(tmp32, []any{v14})
					tmp34 := checkDerefVar(glojure_DOT_core_list)
					tmp35 := lang.Apply(tmp34, []any{v6})
					tmp36 := lang.Apply(tmp27, []any{tmp29, tmp31, tmp33, tmp35})
					tmp37 := lang.Apply(tmp26, []any{tmp36})
					tmp38 := lang.Apply(tmp24, []any{tmp25, tmp37})
					tmp39 := lang.Apply(tmp23, []any{tmp38})
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					tmp41 := lang.Apply(v18, []any{v11, v14, v7})
					tmp42 := lang.Apply(tmp40, []any{tmp41})
					tmp43 := lang.Apply(tmp20, []any{tmp22, tmp39, tmp42})
					tmp44 := lang.Apply(tmp19, []any{tmp43})
					tmp8 = tmp44
				} // end let
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// conj
	{
		tmp0 := lang.NewSymbol("conj").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("xs"))), lang.NewKeyword("doc"), "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).\n    (conj coll) returns coll. (conj) returns [].\n    The 'addition' may happen at different 'places' depending\n    on the concrete type.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(73), lang.NewKeyword("end-line"), int(81))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function conj
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 0:
					tmp4 := lang.NewVector()
					tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(82), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(82), lang.NewKeyword("end-column"), int(14))
					tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp6
				case 1:
					v4 := args[0]
					_ = v4
					return v4
				case 2:
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					tmp6 := lang.Apply(lang.Conj, []any{v4, v5})
					return tmp6
				default:
					if len(args) < 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					var v6 any = lang.NewList(args[2:]...)
					_ = v6
				recur_loop_10:
					var tmp7 any
					if lang.IsTruthy(v6) {
						tmp9 := lang.Apply(lang.Conj, []any{v4, v5})
						var tmp8 any = tmp9
						tmp11 := checkDerefVar(glojure_DOT_core_first)
						tmp12 := lang.Apply(tmp11, []any{v6})
						var tmp10 any = tmp12
						tmp14 := checkDerefVar(glojure_DOT_core_next)
						tmp15 := lang.Apply(tmp14, []any{v6})
						var tmp13 any = tmp15
						v4 = tmp8
						v5 = tmp10
						v6 = tmp13
						goto recur_loop_10
					} else {
						tmp16 := lang.Apply(lang.Conj, []any{v4, v5})
						tmp7 = tmp16
					}
					return tmp7
				}
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(81), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(88), lang.NewKeyword("end-column"), int(67))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// conj!
	{
		tmp0 := lang.NewSymbol("conj!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3359), lang.NewKeyword("end-line"), int(3359))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(glojure_DOT_core_transient)
				tmp4 := lang.NewVector()
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3364), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(3364), lang.NewKeyword("end-column"), int(19))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp7 := lang.Apply(tmp3, []any{tmp6})
				return tmp7
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "Conj")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Conj is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cons
	{
		tmp0 := lang.NewSymbol("cons").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("seq"))), lang.NewKeyword("doc"), "Returns a new seq where x is the first element and seq is\n    the rest.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(21), lang.NewKeyword("end-line"), int(27))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function cons
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.NewCons, []any{v4, v5})
				return tmp6
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(27), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(27), lang.NewKeyword("end-column"), int(89))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// constantly
	{
		tmp0 := lang.NewSymbol("constantly").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns a function that takes any number of arguments and returns x.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1440), lang.NewKeyword("end-line"), int(1440))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v5 any = lang.NewList(args[0:]...)
					_ = v5
					return v3
				}
			})
			tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1444), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(1444), lang.NewKeyword("end-column"), int(21))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// contains?
	{
		tmp0 := lang.NewSymbol("contains?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("key"))), lang.NewKeyword("doc"), "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and Java arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1479), lang.NewKeyword("end-line"), int(1479))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime7.RT, "Contains")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Contains is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// count
	{
		var tmp1 lang.FnFunc
		{ // function count__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/Count")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("count").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Java Collections and Maps", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(867), lang.NewKeyword("end-line"), int(867))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Count, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// counted?
	{
		tmp0 := lang.NewSymbol("counted?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll implements count in constant time", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6241), lang.NewKeyword("end-line"), int(6241))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Counted)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// create-ns
	{
		tmp0 := lang.NewSymbol("create-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Create a new namespace named by the symbol if one doesn't already\n  exist, returns it or the already-existing namespace of the same\n  name.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4131), lang.NewKeyword("end-line"), int(4131))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// create-struct
	{
		tmp0 := lang.NewSymbol("create-struct").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keys"))), lang.NewKeyword("doc"), "Returns a structure basis object.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4037), lang.NewKeyword("end-line"), int(4037))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentStructMapSlotMap, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cycle
	{
		tmp0 := lang.NewSymbol("cycle").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2977), lang.NewKeyword("end-line"), int(2977))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_seq)
			tmp5 := lang.Apply(tmp4, []any{v3})
			tmp6 := lang.Apply(lang.NewCycle, []any{tmp5})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// data-reader-urls
	{
		tmp0 := lang.NewSymbol("data-reader-urls").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7830), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7830), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			return lang.NewList()
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// data-reader-var
	{
		tmp0 := lang.NewSymbol("data-reader-var").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7832), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7832), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_intern)
			tmp5 := checkDerefVar(glojure_DOT_core_create_ns)
			tmp6 := checkDerefVar(glojure_DOT_core_symbol)
			tmp7 := checkDerefVar(glojure_DOT_core_namespace)
			tmp8 := lang.Apply(tmp7, []any{v3})
			tmp9 := lang.Apply(tmp6, []any{tmp8})
			tmp10 := lang.Apply(tmp5, []any{tmp9})
			tmp11 := checkDerefVar(glojure_DOT_core_symbol)
			tmp12 := checkDerefVar(glojure_DOT_core_name)
			tmp13 := lang.Apply(tmp12, []any{v3})
			tmp14 := lang.Apply(tmp11, []any{tmp13})
			tmp15 := lang.Apply(tmp4, []any{tmp10, tmp14})
			return tmp15
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dec
	{
		var tmp1 lang.FnFunc
		{ // function dec__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = lang.NewSymbol("unchecked_dec")
				} else {
					tmp14 = lang.NewSymbol("dec")
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("dec").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one less than num. Does not auto-promote\n  longs, will throw on overflow. See also: dec'", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1147), lang.NewKeyword("end-line"), int(1147))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Dec")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Dec is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dec'
	{
		var tmp1 lang.FnFunc
		{ // function dec'__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/DecP")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("dec'").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one less than num. Supports arbitrary precision.\n  See also: dec", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1140), lang.NewKeyword("end-line"), int(1140))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "DecP")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("DecP is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// decimal?
	{
		tmp0 := lang.NewSymbol("decimal?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is a BigDecimal", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3599), lang.NewKeyword("end-line"), int(3599))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.BigDecimal)(nil))
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// declare
	{
		tmp0 := lang.NewSymbol("declare").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("names"))), lang.NewKeyword("doc"), "defs the supplied var names with no bindings, useful for making forward declarations.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(2768), lang.NewKeyword("end-line"), int(2768))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_concat)
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("do")})
				tmp10 := checkDerefVar(glojure_DOT_core_map)
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v12 := args[0]
					_ = v12
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_vary_meta)
					tmp15 := checkDerefVar(glojure_DOT_core_assoc)
					tmp16 := lang.Apply(tmp14, []any{v12, tmp15, lang.NewKeyword("declared"), true})
					tmp17 := lang.Apply(tmp13, []any{lang.NewSymbol("def"), tmp16})
					return tmp17
				})
				tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2771), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(2771), lang.NewKeyword("end-column"), int(71))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.Apply(tmp10, []any{tmp13, v5})
				tmp15 := lang.Apply(tmp7, []any{tmp9, tmp14})
				tmp16 := lang.Apply(tmp6, []any{tmp15})
				return tmp16
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dedupe
	{
		tmp0 := lang.NewSymbol("dedupe").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7681), lang.NewKeyword("end-line"), int(7681))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "pv"
						tmp6 := checkDerefVar(glojure_DOT_core_volatile_BANG_)
						tmp7 := lang.Apply(tmp6, []any{lang.NewKeyword("glojure.core/none")})
						var v8 any = tmp7
						_ = v8
						var tmp9 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp10 := lang.Apply(v4, nil)
								return tmp10
							case 1:
								v10 := args[0]
								_ = v10
								tmp11 := lang.Apply(v4, []any{v10})
								return tmp11
							case 2:
								v10 := args[0]
								_ = v10
								v11 := args[1]
								_ = v11
								var tmp12 any
								{ // let
									// let binding "prior"
									tmp13 := checkDerefVar(glojure_DOT_core_deref)
									tmp14 := lang.Apply(tmp13, []any{v8})
									var v15 any = tmp14
									_ = v15
									tmp16 := checkDerefVar(glojure_DOT_core_vreset_BANG_)
									tmp17 := lang.Apply(tmp16, []any{v8, v11})
									_ = tmp17
									var tmp18 any
									tmp19 := checkDerefVar(glojure_DOT_core__EQ_)
									tmp20 := lang.Apply(tmp19, []any{v15, v11})
									if lang.IsTruthy(tmp20) {
										tmp18 = v10
									} else {
										tmp21 := lang.Apply(v4, []any{v10, v11})
										tmp18 = tmp21
									}
									tmp12 = tmp18
								} // end let
								return tmp12
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7688), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7696), lang.NewKeyword("end-column"), int(37))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp11
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7686), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(7696), lang.NewKeyword("end-column"), int(39))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_sequence)
				tmp5 := checkDerefVar(glojure_DOT_core_dedupe)
				tmp6 := lang.Apply(tmp5, nil)
				tmp7 := lang.Apply(tmp4, []any{tmp6, v3})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// def-aset
	{
		tmp0 := lang.NewSymbol("def-aset").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("method"), lang.NewSymbol("coerce"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3935), lang.NewKeyword("end-line"), int(3936), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 5 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			tmp8 := checkDerefVar(glojure_DOT_core_seq)
			tmp9 := checkDerefVar(glojure_DOT_core_concat)
			tmp10 := checkDerefVar(glojure_DOT_core_list)
			tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/defn")})
			tmp12 := checkDerefVar(glojure_DOT_core_list)
			tmp13 := lang.Apply(tmp12, []any{v5})
			tmp14 := checkDerefVar(glojure_DOT_core_list)
			tmp15 := checkDerefVar(glojure_DOT_core_apply)
			tmp16 := checkDerefVar(glojure_DOT_core_hash_map)
			tmp17 := checkDerefVar(glojure_DOT_core_seq)
			tmp18 := checkDerefVar(glojure_DOT_core_concat)
			tmp19 := checkDerefVar(glojure_DOT_core_list)
			tmp20 := lang.Apply(tmp19, []any{lang.NewKeyword("arglists")})
			tmp21 := checkDerefVar(glojure_DOT_core_list)
			tmp22 := checkDerefVar(glojure_DOT_core_seq)
			tmp23 := checkDerefVar(glojure_DOT_core_concat)
			tmp24 := checkDerefVar(glojure_DOT_core_list)
			tmp25 := lang.Apply(tmp24, []any{lang.NewSymbol("quote")})
			tmp26 := checkDerefVar(glojure_DOT_core_list)
			tmp27 := checkDerefVar(glojure_DOT_core_seq)
			tmp28 := checkDerefVar(glojure_DOT_core_concat)
			tmp29 := checkDerefVar(glojure_DOT_core_list)
			tmp30 := checkDerefVar(glojure_DOT_core_apply)
			tmp31 := checkDerefVar(glojure_DOT_core_vector)
			tmp32 := checkDerefVar(glojure_DOT_core_seq)
			tmp33 := checkDerefVar(glojure_DOT_core_concat)
			tmp34 := checkDerefVar(glojure_DOT_core_list)
			tmp35 := lang.Apply(tmp34, []any{lang.NewSymbol("array")})
			tmp36 := checkDerefVar(glojure_DOT_core_list)
			tmp37 := lang.Apply(tmp36, []any{lang.NewSymbol("idx")})
			tmp38 := checkDerefVar(glojure_DOT_core_list)
			tmp39 := lang.Apply(tmp38, []any{lang.NewSymbol("val")})
			tmp40 := lang.Apply(tmp33, []any{tmp35, tmp37, tmp39})
			tmp41 := lang.Apply(tmp32, []any{tmp40})
			tmp42 := lang.Apply(tmp30, []any{tmp31, tmp41})
			tmp43 := lang.Apply(tmp29, []any{tmp42})
			tmp44 := checkDerefVar(glojure_DOT_core_list)
			tmp45 := checkDerefVar(glojure_DOT_core_apply)
			tmp46 := checkDerefVar(glojure_DOT_core_vector)
			tmp47 := checkDerefVar(glojure_DOT_core_seq)
			tmp48 := checkDerefVar(glojure_DOT_core_concat)
			tmp49 := checkDerefVar(glojure_DOT_core_list)
			tmp50 := lang.Apply(tmp49, []any{lang.NewSymbol("array")})
			tmp51 := checkDerefVar(glojure_DOT_core_list)
			tmp52 := lang.Apply(tmp51, []any{lang.NewSymbol("idx")})
			tmp53 := checkDerefVar(glojure_DOT_core_list)
			tmp54 := lang.Apply(tmp53, []any{lang.NewSymbol("idx2")})
			tmp55 := checkDerefVar(glojure_DOT_core_list)
			tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("&")})
			tmp57 := checkDerefVar(glojure_DOT_core_list)
			tmp58 := lang.Apply(tmp57, []any{lang.NewSymbol("idxv")})
			tmp59 := lang.Apply(tmp48, []any{tmp50, tmp52, tmp54, tmp56, tmp58})
			tmp60 := lang.Apply(tmp47, []any{tmp59})
			tmp61 := lang.Apply(tmp45, []any{tmp46, tmp60})
			tmp62 := lang.Apply(tmp44, []any{tmp61})
			tmp63 := lang.Apply(tmp28, []any{tmp43, tmp62})
			tmp64 := lang.Apply(tmp27, []any{tmp63})
			tmp65 := lang.Apply(tmp26, []any{tmp64})
			tmp66 := lang.Apply(tmp23, []any{tmp25, tmp65})
			tmp67 := lang.Apply(tmp22, []any{tmp66})
			tmp68 := lang.Apply(tmp21, []any{tmp67})
			tmp69 := lang.Apply(tmp18, []any{tmp20, tmp68})
			tmp70 := lang.Apply(tmp17, []any{tmp69})
			tmp71 := lang.Apply(tmp15, []any{tmp16, tmp70})
			tmp72 := lang.Apply(tmp14, []any{tmp71})
			tmp73 := checkDerefVar(glojure_DOT_core_list)
			tmp74 := checkDerefVar(glojure_DOT_core_seq)
			tmp75 := checkDerefVar(glojure_DOT_core_concat)
			tmp76 := checkDerefVar(glojure_DOT_core_list)
			tmp77 := checkDerefVar(glojure_DOT_core_apply)
			tmp78 := checkDerefVar(glojure_DOT_core_vector)
			tmp79 := checkDerefVar(glojure_DOT_core_seq)
			tmp80 := checkDerefVar(glojure_DOT_core_concat)
			tmp81 := checkDerefVar(glojure_DOT_core_list)
			tmp82 := lang.Apply(tmp81, []any{lang.NewSymbol("array__0__auto__")})
			tmp83 := checkDerefVar(glojure_DOT_core_list)
			tmp84 := lang.Apply(tmp83, []any{lang.NewSymbol("idx__1__auto__")})
			tmp85 := checkDerefVar(glojure_DOT_core_list)
			tmp86 := lang.Apply(tmp85, []any{lang.NewSymbol("val__2__auto__")})
			tmp87 := lang.Apply(tmp80, []any{tmp82, tmp84, tmp86})
			tmp88 := lang.Apply(tmp79, []any{tmp87})
			tmp89 := lang.Apply(tmp77, []any{tmp78, tmp88})
			tmp90 := lang.Apply(tmp76, []any{tmp89})
			tmp91 := checkDerefVar(glojure_DOT_core_list)
			tmp92 := checkDerefVar(glojure_DOT_core_seq)
			tmp93 := checkDerefVar(glojure_DOT_core_concat)
			tmp94 := checkDerefVar(glojure_DOT_core_list)
			tmp95 := lang.Apply(tmp94, []any{lang.NewSymbol(".")})
			tmp96 := checkDerefVar(glojure_DOT_core_list)
			tmp97 := lang.Apply(tmp96, []any{lang.NewSymbol("glojure.core/Array")})
			tmp98 := checkDerefVar(glojure_DOT_core_list)
			tmp99 := checkDerefVar(glojure_DOT_core_seq)
			tmp100 := checkDerefVar(glojure_DOT_core_concat)
			tmp101 := checkDerefVar(glojure_DOT_core_list)
			tmp102 := lang.Apply(tmp101, []any{v6})
			tmp103 := checkDerefVar(glojure_DOT_core_list)
			tmp104 := lang.Apply(tmp103, []any{lang.NewSymbol("array__0__auto__")})
			tmp105 := checkDerefVar(glojure_DOT_core_list)
			tmp106 := lang.Apply(tmp105, []any{lang.NewSymbol("idx__1__auto__")})
			tmp107 := checkDerefVar(glojure_DOT_core_list)
			tmp108 := checkDerefVar(glojure_DOT_core_seq)
			tmp109 := checkDerefVar(glojure_DOT_core_concat)
			tmp110 := checkDerefVar(glojure_DOT_core_list)
			tmp111 := lang.Apply(tmp110, []any{v7})
			tmp112 := checkDerefVar(glojure_DOT_core_list)
			tmp113 := lang.Apply(tmp112, []any{lang.NewSymbol("val__2__auto__")})
			tmp114 := lang.Apply(tmp109, []any{tmp111, tmp113})
			tmp115 := lang.Apply(tmp108, []any{tmp114})
			tmp116 := lang.Apply(tmp107, []any{tmp115})
			tmp117 := lang.Apply(tmp100, []any{tmp102, tmp104, tmp106, tmp116})
			tmp118 := lang.Apply(tmp99, []any{tmp117})
			tmp119 := lang.Apply(tmp98, []any{tmp118})
			tmp120 := lang.Apply(tmp93, []any{tmp95, tmp97, tmp119})
			tmp121 := lang.Apply(tmp92, []any{tmp120})
			tmp122 := lang.Apply(tmp91, []any{tmp121})
			tmp123 := checkDerefVar(glojure_DOT_core_list)
			tmp124 := lang.Apply(tmp123, []any{lang.NewSymbol("val__2__auto__")})
			tmp125 := lang.Apply(tmp75, []any{tmp90, tmp122, tmp124})
			tmp126 := lang.Apply(tmp74, []any{tmp125})
			tmp127 := lang.Apply(tmp73, []any{tmp126})
			tmp128 := checkDerefVar(glojure_DOT_core_list)
			tmp129 := checkDerefVar(glojure_DOT_core_seq)
			tmp130 := checkDerefVar(glojure_DOT_core_concat)
			tmp131 := checkDerefVar(glojure_DOT_core_list)
			tmp132 := checkDerefVar(glojure_DOT_core_apply)
			tmp133 := checkDerefVar(glojure_DOT_core_vector)
			tmp134 := checkDerefVar(glojure_DOT_core_seq)
			tmp135 := checkDerefVar(glojure_DOT_core_concat)
			tmp136 := checkDerefVar(glojure_DOT_core_list)
			tmp137 := lang.Apply(tmp136, []any{lang.NewSymbol("array__0__auto__")})
			tmp138 := checkDerefVar(glojure_DOT_core_list)
			tmp139 := lang.Apply(tmp138, []any{lang.NewSymbol("idx__1__auto__")})
			tmp140 := checkDerefVar(glojure_DOT_core_list)
			tmp141 := lang.Apply(tmp140, []any{lang.NewSymbol("idx2__3__auto__")})
			tmp142 := checkDerefVar(glojure_DOT_core_list)
			tmp143 := lang.Apply(tmp142, []any{lang.NewSymbol("&")})
			tmp144 := checkDerefVar(glojure_DOT_core_list)
			tmp145 := lang.Apply(tmp144, []any{lang.NewSymbol("idxv__4__auto__")})
			tmp146 := lang.Apply(tmp135, []any{tmp137, tmp139, tmp141, tmp143, tmp145})
			tmp147 := lang.Apply(tmp134, []any{tmp146})
			tmp148 := lang.Apply(tmp132, []any{tmp133, tmp147})
			tmp149 := lang.Apply(tmp131, []any{tmp148})
			tmp150 := checkDerefVar(glojure_DOT_core_list)
			tmp151 := checkDerefVar(glojure_DOT_core_seq)
			tmp152 := checkDerefVar(glojure_DOT_core_concat)
			tmp153 := checkDerefVar(glojure_DOT_core_list)
			tmp154 := lang.Apply(tmp153, []any{lang.NewSymbol("glojure.core/apply")})
			tmp155 := checkDerefVar(glojure_DOT_core_list)
			tmp156 := lang.Apply(tmp155, []any{v5})
			tmp157 := checkDerefVar(glojure_DOT_core_list)
			tmp158 := checkDerefVar(glojure_DOT_core_seq)
			tmp159 := checkDerefVar(glojure_DOT_core_concat)
			tmp160 := checkDerefVar(glojure_DOT_core_list)
			tmp161 := lang.Apply(tmp160, []any{lang.NewSymbol("glojure.core/aget")})
			tmp162 := checkDerefVar(glojure_DOT_core_list)
			tmp163 := lang.Apply(tmp162, []any{lang.NewSymbol("array__0__auto__")})
			tmp164 := checkDerefVar(glojure_DOT_core_list)
			tmp165 := lang.Apply(tmp164, []any{lang.NewSymbol("idx__1__auto__")})
			tmp166 := lang.Apply(tmp159, []any{tmp161, tmp163, tmp165})
			tmp167 := lang.Apply(tmp158, []any{tmp166})
			tmp168 := lang.Apply(tmp157, []any{tmp167})
			tmp169 := checkDerefVar(glojure_DOT_core_list)
			tmp170 := lang.Apply(tmp169, []any{lang.NewSymbol("idx2__3__auto__")})
			tmp171 := checkDerefVar(glojure_DOT_core_list)
			tmp172 := lang.Apply(tmp171, []any{lang.NewSymbol("idxv__4__auto__")})
			tmp173 := lang.Apply(tmp152, []any{tmp154, tmp156, tmp168, tmp170, tmp172})
			tmp174 := lang.Apply(tmp151, []any{tmp173})
			tmp175 := lang.Apply(tmp150, []any{tmp174})
			tmp176 := lang.Apply(tmp130, []any{tmp149, tmp175})
			tmp177 := lang.Apply(tmp129, []any{tmp176})
			tmp178 := lang.Apply(tmp128, []any{tmp177})
			tmp179 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp72, tmp127, tmp178})
			tmp180 := lang.Apply(tmp8, []any{tmp179})
			return tmp180
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// definline
	{
		tmp0 := lang.NewSymbol("definline").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("decl"))), lang.NewKeyword("doc"), "Experimental - like defmacro, except defines a named function whose\n  body is the expansion, calls to which may be expanded inline as if\n  it were a macro. Cannot be used with variadic (&) args.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5253), lang.NewKeyword("end-line"), int(5253))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "vec__80"
					tmp8 := checkDerefVar(glojure_DOT_core_split_with)
					tmp9 := checkDerefVar(glojure_DOT_core_comp)
					tmp10 := checkDerefVar(glojure_DOT_core_not)
					tmp11 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
					tmp12 := lang.Apply(tmp9, []any{tmp10, tmp11})
					tmp13 := lang.Apply(tmp8, []any{tmp12, v6})
					var v14 any = tmp13
					_ = v14
					// let binding "pre-args"
					tmp15 := checkDerefVar(glojure_DOT_core_nth)
					tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
					var v17 any = tmp16
					_ = v17
					// let binding "vec__83"
					tmp18 := checkDerefVar(glojure_DOT_core_nth)
					tmp19 := lang.Apply(tmp18, []any{v14, int64(1), nil})
					var v20 any = tmp19
					_ = v20
					// let binding "args"
					tmp21 := checkDerefVar(glojure_DOT_core_nth)
					tmp22 := lang.Apply(tmp21, []any{v20, int64(0), nil})
					var v23 any = tmp22
					_ = v23
					// let binding "expr"
					tmp24 := checkDerefVar(glojure_DOT_core_nth)
					tmp25 := lang.Apply(tmp24, []any{v20, int64(1), nil})
					var v26 any = tmp25
					_ = v26
					tmp27 := checkDerefVar(glojure_DOT_core_seq)
					tmp28 := checkDerefVar(glojure_DOT_core_concat)
					tmp29 := checkDerefVar(glojure_DOT_core_list)
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("do")})
					tmp31 := checkDerefVar(glojure_DOT_core_list)
					tmp32 := checkDerefVar(glojure_DOT_core_seq)
					tmp33 := checkDerefVar(glojure_DOT_core_concat)
					tmp34 := checkDerefVar(glojure_DOT_core_list)
					tmp35 := lang.Apply(tmp34, []any{lang.NewSymbol("glojure.core/defn")})
					tmp36 := checkDerefVar(glojure_DOT_core_list)
					tmp37 := lang.Apply(tmp36, []any{v5})
					tmp38 := checkDerefVar(glojure_DOT_core_list)
					tmp39 := lang.Apply(tmp38, []any{v23})
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					tmp41 := checkDerefVar(glojure_DOT_core_apply)
					tmp42 := checkDerefVar(glojure_DOT_core_eval)
					tmp43 := checkDerefVar(glojure_DOT_core_list)
					tmp44 := lang.Apply(tmp43, []any{lang.NewSymbol("glojure.core/fn"), v23, v26})
					tmp45 := lang.Apply(tmp42, []any{tmp44})
					tmp46 := lang.Apply(tmp41, []any{tmp45, v23})
					tmp47 := lang.Apply(tmp40, []any{tmp46})
					tmp48 := lang.Apply(tmp33, []any{tmp35, tmp37, v17, tmp39, tmp47})
					tmp49 := lang.Apply(tmp32, []any{tmp48})
					tmp50 := lang.Apply(tmp31, []any{tmp49})
					tmp51 := checkDerefVar(glojure_DOT_core_list)
					tmp52 := checkDerefVar(glojure_DOT_core_seq)
					tmp53 := checkDerefVar(glojure_DOT_core_concat)
					tmp54 := checkDerefVar(glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{lang.NewSymbol("glojure.core/alter-meta!")})
					tmp56 := checkDerefVar(glojure_DOT_core_list)
					tmp57 := checkDerefVar(glojure_DOT_core_seq)
					tmp58 := checkDerefVar(glojure_DOT_core_concat)
					tmp59 := checkDerefVar(glojure_DOT_core_list)
					tmp60 := lang.Apply(tmp59, []any{lang.NewSymbol("var")})
					tmp61 := checkDerefVar(glojure_DOT_core_list)
					tmp62 := lang.Apply(tmp61, []any{v5})
					tmp63 := lang.Apply(tmp58, []any{tmp60, tmp62})
					tmp64 := lang.Apply(tmp57, []any{tmp63})
					tmp65 := lang.Apply(tmp56, []any{tmp64})
					tmp66 := checkDerefVar(glojure_DOT_core_list)
					tmp67 := lang.Apply(tmp66, []any{lang.NewSymbol("glojure.core/assoc")})
					tmp68 := checkDerefVar(glojure_DOT_core_list)
					tmp69 := lang.Apply(tmp68, []any{lang.NewKeyword("inline")})
					tmp70 := checkDerefVar(glojure_DOT_core_list)
					tmp71 := checkDerefVar(glojure_DOT_core_seq)
					tmp72 := checkDerefVar(glojure_DOT_core_concat)
					tmp73 := checkDerefVar(glojure_DOT_core_list)
					tmp74 := lang.Apply(tmp73, []any{lang.NewSymbol("glojure.core/fn")})
					tmp75 := checkDerefVar(glojure_DOT_core_list)
					tmp76 := lang.Apply(tmp75, []any{v5})
					tmp77 := checkDerefVar(glojure_DOT_core_list)
					tmp78 := lang.Apply(tmp77, []any{v23})
					tmp79 := checkDerefVar(glojure_DOT_core_list)
					tmp80 := lang.Apply(tmp79, []any{v26})
					tmp81 := lang.Apply(tmp72, []any{tmp74, tmp76, tmp78, tmp80})
					tmp82 := lang.Apply(tmp71, []any{tmp81})
					tmp83 := lang.Apply(tmp70, []any{tmp82})
					tmp84 := lang.Apply(tmp53, []any{tmp55, tmp65, tmp67, tmp69, tmp83})
					tmp85 := lang.Apply(tmp52, []any{tmp84})
					tmp86 := lang.Apply(tmp51, []any{tmp85})
					tmp87 := checkDerefVar(glojure_DOT_core_list)
					tmp88 := checkDerefVar(glojure_DOT_core_seq)
					tmp89 := checkDerefVar(glojure_DOT_core_concat)
					tmp90 := checkDerefVar(glojure_DOT_core_list)
					tmp91 := lang.Apply(tmp90, []any{lang.NewSymbol("var")})
					tmp92 := checkDerefVar(glojure_DOT_core_list)
					tmp93 := lang.Apply(tmp92, []any{v5})
					tmp94 := lang.Apply(tmp89, []any{tmp91, tmp93})
					tmp95 := lang.Apply(tmp88, []any{tmp94})
					tmp96 := lang.Apply(tmp87, []any{tmp95})
					tmp97 := lang.Apply(tmp28, []any{tmp30, tmp50, tmp86, tmp96})
					tmp98 := lang.Apply(tmp27, []any{tmp97})
					tmp7 = tmp98
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmacro
	{
		tmp0 := lang.NewSymbol("defmacro").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("doc-string?"), lang.NewSymbol("attr-map?"), lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("body")), lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("doc-string?"), lang.NewSymbol("attr-map?"), lang.NewList(lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("body")), lang.NewSymbol("+"), lang.NewSymbol("attr-map?"))), lang.NewKeyword("doc"), "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(445), lang.NewKeyword("end-line"), int(451))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "prefix"
					var tmp8 any
					{ // let
						// let binding "p"
						tmp9 := checkDerefVar(glojure_DOT_core_list)
						tmp10 := lang.Apply(tmp9, []any{v5})
						var v11 any = tmp10
						_ = v11
						// let binding "args"
						var v12 any = v6
						_ = v12
						for {
							var tmp13 any
							{ // let
								// let binding "f"
								tmp14 := checkDerefVar(glojure_DOT_core_first)
								tmp15 := lang.Apply(tmp14, []any{v12})
								var v16 any = tmp15
								_ = v16
								var tmp17 any
								tmp18 := checkDerefVar(glojure_DOT_core_string_QMARK_)
								tmp19 := lang.Apply(tmp18, []any{v16})
								if lang.IsTruthy(tmp19) {
									tmp21 := checkDerefVar(glojure_DOT_core_cons)
									tmp22 := lang.Apply(tmp21, []any{v16, v11})
									var tmp20 any = tmp22
									tmp24 := checkDerefVar(glojure_DOT_core_next)
									tmp25 := lang.Apply(tmp24, []any{v12})
									var tmp23 any = tmp25
									v11 = tmp20
									v12 = tmp23
									continue
								} else {
									var tmp26 any
									tmp27 := checkDerefVar(glojure_DOT_core_map_QMARK_)
									tmp28 := lang.Apply(tmp27, []any{v16})
									if lang.IsTruthy(tmp28) {
										tmp30 := checkDerefVar(glojure_DOT_core_cons)
										tmp31 := lang.Apply(tmp30, []any{v16, v11})
										var tmp29 any = tmp31
										tmp33 := checkDerefVar(glojure_DOT_core_next)
										tmp34 := lang.Apply(tmp33, []any{v12})
										var tmp32 any = tmp34
										v11 = tmp29
										v12 = tmp32
										continue
									} else {
										tmp26 = v11
									}
									tmp17 = tmp26
								}
								tmp13 = tmp17
							} // end let
							tmp8 = tmp13
							break
						}
					} // end let
					var v9 any = tmp8
					_ = v9
					// let binding "fdecl"
					var tmp10 any
					{ // let
						// let binding "fd"
						var v11 any = v6
						_ = v11
						for {
							var tmp12 any
							tmp13 := checkDerefVar(glojure_DOT_core_string_QMARK_)
							tmp14 := checkDerefVar(glojure_DOT_core_first)
							tmp15 := lang.Apply(tmp14, []any{v11})
							tmp16 := lang.Apply(tmp13, []any{tmp15})
							if lang.IsTruthy(tmp16) {
								tmp18 := checkDerefVar(glojure_DOT_core_next)
								tmp19 := lang.Apply(tmp18, []any{v11})
								var tmp17 any = tmp19
								v11 = tmp17
								continue
							} else {
								var tmp20 any
								tmp21 := checkDerefVar(glojure_DOT_core_map_QMARK_)
								tmp22 := checkDerefVar(glojure_DOT_core_first)
								tmp23 := lang.Apply(tmp22, []any{v11})
								tmp24 := lang.Apply(tmp21, []any{tmp23})
								if lang.IsTruthy(tmp24) {
									tmp26 := checkDerefVar(glojure_DOT_core_next)
									tmp27 := lang.Apply(tmp26, []any{v11})
									var tmp25 any = tmp27
									v11 = tmp25
									continue
								} else {
									tmp20 = v11
								}
								tmp12 = tmp20
							}
							tmp10 = tmp12
							break
						}
					} // end let
					var v11 any = tmp10
					_ = v11
					// let binding "fdecl"
					var tmp12 any
					tmp13 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
					tmp14 := checkDerefVar(glojure_DOT_core_first)
					tmp15 := lang.Apply(tmp14, []any{v11})
					tmp16 := lang.Apply(tmp13, []any{tmp15})
					if lang.IsTruthy(tmp16) {
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{v11})
						tmp12 = tmp18
					} else {
						tmp12 = v11
					}
					var v19 any = tmp12
					_ = v19
					// let binding "add-implicit-args"
					var tmp20 lang.FnFunc
					tmp20 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v21 := args[0]
						_ = v21
						var tmp22 any
						{ // let
							// let binding "args"
							tmp23 := checkDerefVar(glojure_DOT_core_first)
							tmp24 := lang.Apply(tmp23, []any{v21})
							var v25 any = tmp24
							_ = v25
							tmp26 := checkDerefVar(glojure_DOT_core_cons)
							tmp27 := checkDerefVar(glojure_DOT_core_vec)
							tmp28 := checkDerefVar(glojure_DOT_core_cons)
							tmp29 := checkDerefVar(glojure_DOT_core_cons)
							tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("&env"), v25})
							tmp31 := lang.Apply(tmp28, []any{lang.NewSymbol("&form"), tmp30})
							tmp32 := lang.Apply(tmp27, []any{tmp31})
							tmp33 := checkDerefVar(glojure_DOT_core_next)
							tmp34 := lang.Apply(tmp33, []any{v21})
							tmp35 := lang.Apply(tmp26, []any{tmp32, tmp34})
							tmp22 = tmp35
						} // end let
						return tmp22
					})
					tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(469), lang.NewKeyword("column"), int(38), lang.NewKeyword("end-line"), int(471), lang.NewKeyword("end-column"), int(87))
					tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v23 any = tmp22
					_ = v23
					// let binding "add-args"
					var tmp24 lang.FnFunc
					tmp24 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v25 := args[0]
						_ = v25
						v26 := args[1]
						_ = v26
					recur_loop_61:
						var tmp27 any
						tmp28 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp29 := lang.Apply(tmp28, []any{v26})
						if lang.IsTruthy(tmp29) {
							tmp27 = v25
						} else {
							var tmp30 any
							{ // let
								// let binding "d"
								tmp31 := checkDerefVar(glojure_DOT_core_first)
								tmp32 := lang.Apply(tmp31, []any{v26})
								var v33 any = tmp32
								_ = v33
								var tmp34 any
								tmp35 := checkDerefVar(glojure_DOT_core_map_QMARK_)
								tmp36 := lang.Apply(tmp35, []any{v33})
								if lang.IsTruthy(tmp36) {
									tmp37 := checkDerefVar(glojure_DOT_core_conj)
									tmp38 := lang.Apply(tmp37, []any{v25, v33})
									tmp34 = tmp38
								} else {
									tmp40 := checkDerefVar(glojure_DOT_core_conj)
									tmp41 := lang.Apply(v23, []any{v33})
									tmp42 := lang.Apply(tmp40, []any{v25, tmp41})
									var tmp39 any = tmp42
									tmp44 := checkDerefVar(glojure_DOT_core_next)
									tmp45 := lang.Apply(tmp44, []any{v26})
									var tmp43 any = tmp45
									v25 = tmp39
									v26 = tmp43
									goto recur_loop_61
								}
								tmp30 = tmp34
							} // end let
							tmp27 = tmp30
						}
						return tmp27
					})
					tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(472), lang.NewKeyword("column"), int(29), lang.NewKeyword("end-line"), int(478), lang.NewKeyword("end-column"), int(90))
					tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v27 any = tmp26
					_ = v27
					// let binding "fdecl"
					tmp28 := checkDerefVar(glojure_DOT_core_seq)
					tmp29 := lang.NewVector()
					tmp30 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(479), lang.NewKeyword("column"), int(41), lang.NewKeyword("end-line"), int(479), lang.NewKeyword("end-column"), int(42))
					tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp32 := lang.Apply(v27, []any{tmp31, v19})
					tmp33 := lang.Apply(tmp28, []any{tmp32})
					var v34 any = tmp33
					_ = v34
					// let binding "decl"
					var tmp35 any
					{ // let
						// let binding "p"
						var v36 any = v9
						_ = v36
						// let binding "d"
						var v37 any = v34
						_ = v37
						for {
							var tmp38 any
							if lang.IsTruthy(v36) {
								tmp40 := checkDerefVar(glojure_DOT_core_next)
								tmp41 := lang.Apply(tmp40, []any{v36})
								var tmp39 any = tmp41
								tmp43 := checkDerefVar(glojure_DOT_core_cons)
								tmp44 := checkDerefVar(glojure_DOT_core_first)
								tmp45 := lang.Apply(tmp44, []any{v36})
								tmp46 := lang.Apply(tmp43, []any{tmp45, v37})
								var tmp42 any = tmp46
								v36 = tmp39
								v37 = tmp42
								continue
							} else {
								tmp38 = v37
							}
							tmp35 = tmp38
							break
						}
					} // end let
					var v36 any = tmp35
					_ = v36
					tmp37 := checkDerefVar(glojure_DOT_core_list)
					tmp38 := checkDerefVar(glojure_DOT_core_cons)
					tmp39 := lang.Apply(tmp38, []any{lang.NewSymbol("glojure.core/defn"), v36})
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					tmp41 := checkDerefVar(glojure_DOT_core_list)
					tmp42 := lang.Apply(tmp41, []any{lang.NewSymbol("var"), v5})
					tmp43 := lang.Apply(tmp40, []any{lang.NewSymbol("."), tmp42, lang.NewList(lang.NewSymbol("SetMacro"))})
					tmp44 := checkDerefVar(glojure_DOT_core_list)
					tmp45 := lang.Apply(tmp44, []any{lang.NewSymbol("var"), v5})
					tmp46 := lang.Apply(tmp37, []any{lang.NewSymbol("do"), tmp39, tmp43, tmp45})
					tmp7 = tmp46
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(451), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(487), lang.NewKeyword("end-column"), int(40))).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmethod
	{
		tmp0 := lang.NewSymbol("defmethod").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"), lang.NewSymbol("dispatch-val"), lang.NewSymbol("&"), lang.NewSymbol("fn-tail"))), lang.NewKeyword("doc"), "Creates and installs a new method of multimethod associated with dispatch-value. ", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1781), lang.NewKeyword("end-line"), int(1781))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_seq)
				tmp9 := checkDerefVar(glojure_DOT_core_concat)
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := checkDerefVar(glojure_DOT_core_with_meta)
				tmp14 := lang.NewMap(lang.NewKeyword("tag"), lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.*MultiFn"))
				tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1785), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(1785), lang.NewKeyword("end-column"), int(82))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp17 := lang.Apply(tmp13, []any{v5, tmp16})
				tmp18 := lang.Apply(tmp12, []any{tmp17})
				tmp19 := checkDerefVar(glojure_DOT_core_list)
				tmp20 := lang.Apply(tmp19, []any{lang.NewSymbol("glojure.core/AddMethod")})
				tmp21 := checkDerefVar(glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{v6})
				tmp23 := checkDerefVar(glojure_DOT_core_list)
				tmp24 := checkDerefVar(glojure_DOT_core_seq)
				tmp25 := checkDerefVar(glojure_DOT_core_concat)
				tmp26 := checkDerefVar(glojure_DOT_core_list)
				tmp27 := lang.Apply(tmp26, []any{lang.NewSymbol("glojure.core/fn")})
				tmp28 := lang.Apply(tmp25, []any{tmp27, v7})
				tmp29 := lang.Apply(tmp24, []any{tmp28})
				tmp30 := lang.Apply(tmp23, []any{tmp29})
				tmp31 := lang.Apply(tmp9, []any{tmp11, tmp18, tmp20, tmp22, tmp30})
				tmp32 := lang.Apply(tmp8, []any{tmp31})
				return tmp32
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmulti
	{
		tmp0 := lang.NewSymbol("defmulti").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("docstring?"), lang.NewSymbol("attr-map?"), lang.NewSymbol("dispatch-fn"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Creates a new multimethod with the associated dispatch function.\n  The docstring and attr-map are optional.\n\n  Options are key-value pairs and may be one of:\n\n  :default\n\n  The default dispatch value, defaults to :default\n\n  :hierarchy\n\n  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)\n\n  Hierarchies are type-like relationships that do not depend upon type\n  inheritance. By default Clojure's multimethods dispatch off of a\n  global hierarchy map.  However, a hierarchy relationship can be\n  created with the derive function used to augment the root ancestor\n  created with make-hierarchy.\n\n  Multimethods expect the value of the hierarchy option to be supplied as\n  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'\n  or the var special form).", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1723), lang.NewKeyword("end-line"), int(1723))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "docstring"
					var tmp8 any
					tmp9 := checkDerefVar(glojure_DOT_core_string_QMARK_)
					tmp10 := checkDerefVar(glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v6})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v6})
						tmp8 = tmp14
					} else {
					}
					var v15 any = tmp8
					_ = v15
					// let binding "options"
					var tmp16 any
					tmp17 := checkDerefVar(glojure_DOT_core_string_QMARK_)
					tmp18 := checkDerefVar(glojure_DOT_core_first)
					tmp19 := lang.Apply(tmp18, []any{v6})
					tmp20 := lang.Apply(tmp17, []any{tmp19})
					if lang.IsTruthy(tmp20) {
						tmp21 := checkDerefVar(glojure_DOT_core_next)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp16 = tmp22
					} else {
						tmp16 = v6
					}
					var v23 any = tmp16
					_ = v23
					// let binding "m"
					var tmp24 any
					tmp25 := checkDerefVar(glojure_DOT_core_map_QMARK_)
					tmp26 := checkDerefVar(glojure_DOT_core_first)
					tmp27 := lang.Apply(tmp26, []any{v23})
					tmp28 := lang.Apply(tmp25, []any{tmp27})
					if lang.IsTruthy(tmp28) {
						tmp29 := checkDerefVar(glojure_DOT_core_first)
						tmp30 := lang.Apply(tmp29, []any{v23})
						tmp24 = tmp30
					} else {
						tmp31 := lang.NewMap()
						tmp32 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1757), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(1757), lang.NewKeyword("end-column"), int(24))
						tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp24 = tmp33
					}
					var v34 any = tmp24
					_ = v34
					// let binding "options"
					var tmp35 any
					tmp36 := checkDerefVar(glojure_DOT_core_map_QMARK_)
					tmp37 := checkDerefVar(glojure_DOT_core_first)
					tmp38 := lang.Apply(tmp37, []any{v23})
					tmp39 := lang.Apply(tmp36, []any{tmp38})
					if lang.IsTruthy(tmp39) {
						tmp40 := checkDerefVar(glojure_DOT_core_next)
						tmp41 := lang.Apply(tmp40, []any{v23})
						tmp35 = tmp41
					} else {
						tmp35 = v23
					}
					var v42 any = tmp35
					_ = v42
					// let binding "dispatch-fn"
					tmp43 := checkDerefVar(glojure_DOT_core_first)
					tmp44 := lang.Apply(tmp43, []any{v42})
					var v45 any = tmp44
					_ = v45
					// let binding "options"
					tmp46 := checkDerefVar(glojure_DOT_core_next)
					tmp47 := lang.Apply(tmp46, []any{v42})
					var v48 any = tmp47
					_ = v48
					// let binding "m"
					var tmp49 any
					if lang.IsTruthy(v15) {
						tmp50 := checkDerefVar(glojure_DOT_core_assoc)
						tmp51 := lang.Apply(tmp50, []any{v34, lang.NewKeyword("doc"), v15})
						tmp49 = tmp51
					} else {
						tmp49 = v34
					}
					var v52 any = tmp49
					_ = v52
					// let binding "m"
					var tmp53 any
					tmp54 := checkDerefVar(glojure_DOT_core_meta)
					tmp55 := lang.Apply(tmp54, []any{v5})
					if lang.IsTruthy(tmp55) {
						tmp56 := checkDerefVar(glojure_DOT_core_conj)
						tmp57 := checkDerefVar(glojure_DOT_core_meta)
						tmp58 := lang.Apply(tmp57, []any{v5})
						tmp59 := lang.Apply(tmp56, []any{tmp58, v52})
						tmp53 = tmp59
					} else {
						tmp53 = v52
					}
					var v60 any = tmp53
					_ = v60
					// let binding "mm-name"
					tmp61 := checkDerefVar(glojure_DOT_core_with_meta)
					tmp62 := lang.Apply(tmp61, []any{v5, v60})
					var v63 any = tmp62
					_ = v63
					var tmp64 any
					tmp65 := checkDerefVar(glojure_DOT_core__EQ_)
					tmp66 := checkDerefVar(glojure_DOT_core_count)
					tmp67 := lang.Apply(tmp66, []any{v48})
					tmp68 := lang.Apply(tmp65, []any{tmp67, int64(1)})
					if lang.IsTruthy(tmp68) {
						tmp69 := lang.Apply(lang.NewError, []any{"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)"})
						panic(tmp69)
					} else {
					}
					_ = tmp64
					var tmp70 any
					{ // let
						// let binding "options"
						tmp71 := checkDerefVar(glojure_DOT_core_apply)
						tmp72 := checkDerefVar(glojure_DOT_core_hash_map)
						tmp73 := lang.Apply(tmp71, []any{tmp72, v48})
						var v74 any = tmp73
						_ = v74
						// let binding "default"
						tmp75 := checkDerefVar(glojure_DOT_core_get)
						tmp76 := lang.Apply(tmp75, []any{v74, lang.NewKeyword("default"), lang.NewKeyword("default")})
						var v77 any = tmp76
						_ = v77
						// let binding "hierarchy"
						tmp78 := checkDerefVar(glojure_DOT_core_get)
						tmp79 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("global-hierarchy"))
						tmp80 := lang.Apply(tmp78, []any{v74, lang.NewKeyword("hierarchy"), tmp79})
						var v81 any = tmp80
						_ = v81
						tmp82 := checkDerefVar(glojure_DOT_core_check_valid_options)
						tmp83 := lang.Apply(tmp82, []any{v74, lang.NewKeyword("default"), lang.NewKeyword("hierarchy")})
						_ = tmp83
						tmp84 := checkDerefVar(glojure_DOT_core_seq)
						tmp85 := checkDerefVar(glojure_DOT_core_concat)
						tmp86 := checkDerefVar(glojure_DOT_core_list)
						tmp87 := lang.Apply(tmp86, []any{lang.NewSymbol("glojure.core/let")})
						tmp88 := checkDerefVar(glojure_DOT_core_list)
						tmp89 := checkDerefVar(glojure_DOT_core_apply)
						tmp90 := checkDerefVar(glojure_DOT_core_vector)
						tmp91 := checkDerefVar(glojure_DOT_core_seq)
						tmp92 := checkDerefVar(glojure_DOT_core_concat)
						tmp93 := checkDerefVar(glojure_DOT_core_list)
						tmp94 := lang.Apply(tmp93, []any{lang.NewSymbol("v__0__auto__")})
						tmp95 := checkDerefVar(glojure_DOT_core_list)
						tmp96 := checkDerefVar(glojure_DOT_core_seq)
						tmp97 := checkDerefVar(glojure_DOT_core_concat)
						tmp98 := checkDerefVar(glojure_DOT_core_list)
						tmp99 := lang.Apply(tmp98, []any{lang.NewSymbol("def")})
						tmp100 := checkDerefVar(glojure_DOT_core_list)
						tmp101 := lang.Apply(tmp100, []any{v63})
						tmp102 := lang.Apply(tmp97, []any{tmp99, tmp101})
						tmp103 := lang.Apply(tmp96, []any{tmp102})
						tmp104 := lang.Apply(tmp95, []any{tmp103})
						tmp105 := lang.Apply(tmp92, []any{tmp94, tmp104})
						tmp106 := lang.Apply(tmp91, []any{tmp105})
						tmp107 := lang.Apply(tmp89, []any{tmp90, tmp106})
						tmp108 := lang.Apply(tmp88, []any{tmp107})
						tmp109 := checkDerefVar(glojure_DOT_core_list)
						tmp110 := checkDerefVar(glojure_DOT_core_seq)
						tmp111 := checkDerefVar(glojure_DOT_core_concat)
						tmp112 := checkDerefVar(glojure_DOT_core_list)
						tmp113 := lang.Apply(tmp112, []any{lang.NewSymbol("glojure.core/when-not")})
						tmp114 := checkDerefVar(glojure_DOT_core_list)
						tmp115 := checkDerefVar(glojure_DOT_core_seq)
						tmp116 := checkDerefVar(glojure_DOT_core_concat)
						tmp117 := checkDerefVar(glojure_DOT_core_list)
						tmp118 := lang.Apply(tmp117, []any{lang.NewSymbol("glojure.core/and")})
						tmp119 := checkDerefVar(glojure_DOT_core_list)
						tmp120 := checkDerefVar(glojure_DOT_core_seq)
						tmp121 := checkDerefVar(glojure_DOT_core_concat)
						tmp122 := checkDerefVar(glojure_DOT_core_list)
						tmp123 := lang.Apply(tmp122, []any{lang.NewSymbol(".HasRoot")})
						tmp124 := checkDerefVar(glojure_DOT_core_list)
						tmp125 := lang.Apply(tmp124, []any{lang.NewSymbol("v__0__auto__")})
						tmp126 := lang.Apply(tmp121, []any{tmp123, tmp125})
						tmp127 := lang.Apply(tmp120, []any{tmp126})
						tmp128 := lang.Apply(tmp119, []any{tmp127})
						tmp129 := checkDerefVar(glojure_DOT_core_list)
						tmp130 := checkDerefVar(glojure_DOT_core_seq)
						tmp131 := checkDerefVar(glojure_DOT_core_concat)
						tmp132 := checkDerefVar(glojure_DOT_core_list)
						tmp133 := lang.Apply(tmp132, []any{lang.NewSymbol("glojure.core/instance?")})
						tmp134 := checkDerefVar(glojure_DOT_core_list)
						tmp135 := lang.Apply(tmp134, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.*MultiFn")})
						tmp136 := checkDerefVar(glojure_DOT_core_list)
						tmp137 := checkDerefVar(glojure_DOT_core_seq)
						tmp138 := checkDerefVar(glojure_DOT_core_concat)
						tmp139 := checkDerefVar(glojure_DOT_core_list)
						tmp140 := lang.Apply(tmp139, []any{lang.NewSymbol("glojure.core/deref")})
						tmp141 := checkDerefVar(glojure_DOT_core_list)
						tmp142 := lang.Apply(tmp141, []any{lang.NewSymbol("v__0__auto__")})
						tmp143 := lang.Apply(tmp138, []any{tmp140, tmp142})
						tmp144 := lang.Apply(tmp137, []any{tmp143})
						tmp145 := lang.Apply(tmp136, []any{tmp144})
						tmp146 := lang.Apply(tmp131, []any{tmp133, tmp135, tmp145})
						tmp147 := lang.Apply(tmp130, []any{tmp146})
						tmp148 := lang.Apply(tmp129, []any{tmp147})
						tmp149 := lang.Apply(tmp116, []any{tmp118, tmp128, tmp148})
						tmp150 := lang.Apply(tmp115, []any{tmp149})
						tmp151 := lang.Apply(tmp114, []any{tmp150})
						tmp152 := checkDerefVar(glojure_DOT_core_list)
						tmp153 := checkDerefVar(glojure_DOT_core_seq)
						tmp154 := checkDerefVar(glojure_DOT_core_concat)
						tmp155 := checkDerefVar(glojure_DOT_core_list)
						tmp156 := lang.Apply(tmp155, []any{lang.NewSymbol("def")})
						tmp157 := checkDerefVar(glojure_DOT_core_list)
						tmp158 := lang.Apply(tmp157, []any{v63})
						tmp159 := checkDerefVar(glojure_DOT_core_list)
						tmp160 := checkDerefVar(glojure_DOT_core_seq)
						tmp161 := checkDerefVar(glojure_DOT_core_concat)
						tmp162 := checkDerefVar(glojure_DOT_core_list)
						tmp163 := lang.Apply(tmp162, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewMultiFn")})
						tmp164 := checkDerefVar(glojure_DOT_core_list)
						tmp165 := checkDerefVar(glojure_DOT_core_name)
						tmp166 := lang.Apply(tmp165, []any{v63})
						tmp167 := lang.Apply(tmp164, []any{tmp166})
						tmp168 := checkDerefVar(glojure_DOT_core_list)
						tmp169 := lang.Apply(tmp168, []any{v45})
						tmp170 := checkDerefVar(glojure_DOT_core_list)
						tmp171 := lang.Apply(tmp170, []any{v77})
						tmp172 := checkDerefVar(glojure_DOT_core_list)
						tmp173 := lang.Apply(tmp172, []any{v81})
						tmp174 := lang.Apply(tmp161, []any{tmp163, tmp167, tmp169, tmp171, tmp173})
						tmp175 := lang.Apply(tmp160, []any{tmp174})
						tmp176 := lang.Apply(tmp159, []any{tmp175})
						tmp177 := lang.Apply(tmp154, []any{tmp156, tmp158, tmp176})
						tmp178 := lang.Apply(tmp153, []any{tmp177})
						tmp179 := lang.Apply(tmp152, []any{tmp178})
						tmp180 := lang.Apply(tmp111, []any{tmp113, tmp151, tmp179})
						tmp181 := lang.Apply(tmp110, []any{tmp180})
						tmp182 := lang.Apply(tmp109, []any{tmp181})
						tmp183 := lang.Apply(tmp85, []any{tmp87, tmp108, tmp182})
						tmp184 := lang.Apply(tmp84, []any{tmp183})
						tmp70 = tmp184
					} // end let
					tmp7 = tmp70
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defn
	{
		tmp0 := lang.NewSymbol("defn").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("doc-string?"), lang.NewSymbol("attr-map?"), lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("prepost-map?"), lang.NewSymbol("body")), lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("doc-string?"), lang.NewSymbol("attr-map?"), lang.NewList(lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("prepost-map?"), lang.NewSymbol("body")), lang.NewSymbol("+"), lang.NewSymbol("attr-map?"))), lang.NewKeyword("doc"), "Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(284), lang.NewKeyword("end-line"), int(291))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function defn
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 3 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					var v7 any = lang.NewList(args[3:]...)
					_ = v7
					var tmp8 any
					tmp9 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
					tmp10 := reflect.TypeOf((*lang.Symbol)(nil))
					tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
					if lang.IsTruthy(tmp11) {
					} else {
						tmp12 := lang.Apply(lang.NewIllegalArgumentError, []any{"First argument to defn must be a symbol"})
						panic(tmp12)
					}
					_ = tmp8
					var tmp13 any
					{ // let
						// let binding "m"
						var tmp14 any
						tmp15 := checkDerefVar(glojure_DOT_core_string_QMARK_)
						tmp16 := checkDerefVar(glojure_DOT_core_first)
						tmp17 := lang.Apply(tmp16, []any{v7})
						tmp18 := lang.Apply(tmp15, []any{tmp17})
						if lang.IsTruthy(tmp18) {
							tmp19 := checkDerefVar(glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v7})
							tmp21 := lang.NewMap(lang.NewKeyword("doc"), tmp20)
							tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(297), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(297), lang.NewKeyword("end-column"), int(38))
							tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp14 = tmp23
						} else {
							tmp24 := lang.NewMap()
							tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(298), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(298), lang.NewKeyword("end-column"), int(20))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp14 = tmp26
						}
						var v27 any = tmp14
						_ = v27
						// let binding "fdecl"
						var tmp28 any
						tmp29 := checkDerefVar(glojure_DOT_core_string_QMARK_)
						tmp30 := checkDerefVar(glojure_DOT_core_first)
						tmp31 := lang.Apply(tmp30, []any{v7})
						tmp32 := lang.Apply(tmp29, []any{tmp31})
						if lang.IsTruthy(tmp32) {
							tmp33 := checkDerefVar(glojure_DOT_core_next)
							tmp34 := lang.Apply(tmp33, []any{v7})
							tmp28 = tmp34
						} else {
							tmp28 = v7
						}
						var v35 any = tmp28
						_ = v35
						// let binding "m"
						var tmp36 any
						tmp37 := checkDerefVar(glojure_DOT_core_map_QMARK_)
						tmp38 := checkDerefVar(glojure_DOT_core_first)
						tmp39 := lang.Apply(tmp38, []any{v35})
						tmp40 := lang.Apply(tmp37, []any{tmp39})
						if lang.IsTruthy(tmp40) {
							tmp41 := checkDerefVar(glojure_DOT_core_conj)
							tmp42 := checkDerefVar(glojure_DOT_core_first)
							tmp43 := lang.Apply(tmp42, []any{v35})
							tmp44 := lang.Apply(tmp41, []any{v27, tmp43})
							tmp36 = tmp44
						} else {
							tmp36 = v27
						}
						var v45 any = tmp36
						_ = v45
						// let binding "fdecl"
						var tmp46 any
						tmp47 := checkDerefVar(glojure_DOT_core_map_QMARK_)
						tmp48 := checkDerefVar(glojure_DOT_core_first)
						tmp49 := lang.Apply(tmp48, []any{v35})
						tmp50 := lang.Apply(tmp47, []any{tmp49})
						if lang.IsTruthy(tmp50) {
							tmp51 := checkDerefVar(glojure_DOT_core_next)
							tmp52 := lang.Apply(tmp51, []any{v35})
							tmp46 = tmp52
						} else {
							tmp46 = v35
						}
						var v53 any = tmp46
						_ = v53
						// let binding "fdecl"
						var tmp54 any
						tmp55 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
						tmp56 := checkDerefVar(glojure_DOT_core_first)
						tmp57 := lang.Apply(tmp56, []any{v53})
						tmp58 := lang.Apply(tmp55, []any{tmp57})
						if lang.IsTruthy(tmp58) {
							tmp59 := checkDerefVar(glojure_DOT_core_list)
							tmp60 := lang.Apply(tmp59, []any{v53})
							tmp54 = tmp60
						} else {
							tmp54 = v53
						}
						var v61 any = tmp54
						_ = v61
						// let binding "m"
						var tmp62 any
						tmp63 := checkDerefVar(glojure_DOT_core_map_QMARK_)
						tmp64 := checkDerefVar(glojure_DOT_core_last)
						tmp65 := lang.Apply(tmp64, []any{v61})
						tmp66 := lang.Apply(tmp63, []any{tmp65})
						if lang.IsTruthy(tmp66) {
							tmp67 := checkDerefVar(glojure_DOT_core_conj)
							tmp68 := checkDerefVar(glojure_DOT_core_last)
							tmp69 := lang.Apply(tmp68, []any{v61})
							tmp70 := lang.Apply(tmp67, []any{v45, tmp69})
							tmp62 = tmp70
						} else {
							tmp62 = v45
						}
						var v71 any = tmp62
						_ = v71
						// let binding "fdecl"
						var tmp72 any
						tmp73 := checkDerefVar(glojure_DOT_core_map_QMARK_)
						tmp74 := checkDerefVar(glojure_DOT_core_last)
						tmp75 := lang.Apply(tmp74, []any{v61})
						tmp76 := lang.Apply(tmp73, []any{tmp75})
						if lang.IsTruthy(tmp76) {
							tmp77 := checkDerefVar(glojure_DOT_core_butlast)
							tmp78 := lang.Apply(tmp77, []any{v61})
							tmp72 = tmp78
						} else {
							tmp72 = v61
						}
						var v79 any = tmp72
						_ = v79
						// let binding "m"
						tmp80 := checkDerefVar(glojure_DOT_core_conj)
						tmp81 := checkDerefVar(glojure_DOT_core_list)
						tmp82 := checkDerefVar(glojure_DOT_core_sigs)
						tmp83 := lang.Apply(tmp82, []any{v79})
						tmp84 := lang.Apply(tmp81, []any{lang.NewSymbol("quote"), tmp83})
						tmp85 := lang.NewMap(lang.NewKeyword("arglists"), tmp84)
						tmp86 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(317), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(317), lang.NewKeyword("end-column"), int(60))
						tmp87, err := lang.WithMeta(tmp85, tmp86.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp88 := lang.Apply(tmp80, []any{tmp87, v71})
						var v89 any = tmp88
						_ = v89
						// let binding "m"
						var tmp90 any
						{ // let
							// let binding "inline"
							tmp91 := lang.Apply(lang.NewKeyword("inline"), []any{v89})
							var v92 any = tmp91
							_ = v92
							// let binding "ifn"
							tmp93 := checkDerefVar(glojure_DOT_core_first)
							tmp94 := lang.Apply(tmp93, []any{v92})
							var v95 any = tmp94
							_ = v95
							// let binding "iname"
							tmp96 := checkDerefVar(glojure_DOT_core_second)
							tmp97 := lang.Apply(tmp96, []any{v92})
							var v98 any = tmp97
							_ = v98
							var tmp99 any
							var tmp100 any
							tmp101 := lang.Apply(lang.Equiv, []any{lang.NewSymbol("fn"), v95})
							if lang.IsTruthy(tmp101) {
								var tmp102 any
								tmp103 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
								tmp104 := reflect.TypeOf((*lang.Symbol)(nil))
								tmp105 := lang.Apply(tmp103, []any{tmp104, v98})
								if lang.IsTruthy(tmp105) {
									tmp102 = false
								} else {
									tmp102 = true
								}
								tmp100 = tmp102
							} else {
							}
							if lang.IsTruthy(tmp100) {
								tmp106 := checkDerefVar(glojure_DOT_core_assoc)
								tmp107 := checkDerefVar(glojure_DOT_core_cons)
								tmp108 := checkDerefVar(glojure_DOT_core_cons)
								tmp109, ok := lang.FieldOrMethod(v6, "Name")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "Name")))
								}
								var tmp110 any
								switch reflect.TypeOf(tmp109).Kind() {
								case reflect.Func:
									tmp110 = lang.Apply(tmp109, nil)
								default:
									tmp110 = tmp109
								}
								tmp111 := lang.Apply(lang.ConcatStrings, []any{tmp110, "__inliner"})
								tmp112 := lang.Apply(lang.NewSymbol, []any{tmp111})
								tmp113 := checkDerefVar(glojure_DOT_core_next)
								tmp114 := lang.Apply(tmp113, []any{v92})
								tmp115 := lang.Apply(tmp108, []any{tmp112, tmp114})
								tmp116 := lang.Apply(tmp107, []any{v95, tmp115})
								tmp117 := lang.Apply(tmp106, []any{v89, lang.NewKeyword("inline"), tmp116})
								tmp99 = tmp117
							} else {
								tmp99 = v89
							}
							tmp90 = tmp99
						} // end let
						var v91 any = tmp90
						_ = v91
						// let binding "m"
						tmp92 := checkDerefVar(glojure_DOT_core_conj)
						var tmp93 any
						tmp94 := checkDerefVar(glojure_DOT_core_meta)
						tmp95 := lang.Apply(tmp94, []any{v6})
						if lang.IsTruthy(tmp95) {
							tmp96 := checkDerefVar(glojure_DOT_core_meta)
							tmp97 := lang.Apply(tmp96, []any{v6})
							tmp93 = tmp97
						} else {
							tmp98 := lang.NewMap()
							tmp99 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(328), lang.NewKeyword("column"), int(51), lang.NewKeyword("end-line"), int(328), lang.NewKeyword("end-column"), int(52))
							tmp100, err := lang.WithMeta(tmp98, tmp99.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp93 = tmp100
						}
						tmp101 := lang.Apply(tmp92, []any{tmp93, v91})
						var v102 any = tmp101
						_ = v102
						tmp103 := checkDerefVar(glojure_DOT_core_list)
						tmp104 := checkDerefVar(glojure_DOT_core_with_meta)
						tmp105 := lang.Apply(tmp104, []any{v6, v102})
						tmp106 := checkDerefVar(glojure_DOT_core_with_meta)
						tmp107 := checkDerefVar(glojure_DOT_core_cons)
						tmp108 := lang.Apply(tmp107, []any{lang.NewSymbol("glojure.core/fn"), v79})
						tmp109 := lang.Apply(lang.NewKeyword("tag"), []any{v102})
						tmp110 := lang.NewMap(lang.NewKeyword("rettag"), tmp109)
						tmp111 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(333), lang.NewKeyword("column"), int(37), lang.NewKeyword("end-line"), int(333), lang.NewKeyword("end-column"), int(54))
						tmp112, err := lang.WithMeta(tmp110, tmp111.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp113 := lang.Apply(tmp106, []any{tmp108, tmp112})
						tmp114 := lang.Apply(tmp103, []any{lang.NewSymbol("def"), tmp105, tmp113})
						tmp13 = tmp114
					} // end let
					return tmp13
				}
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(291), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(333), lang.NewKeyword("end-column"), int(58))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defn-
	{
		tmp0 := lang.NewSymbol("defn-").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("decls"))), lang.NewKeyword("doc"), "same as defn, yielding non-public def", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4949), lang.NewKeyword("end-line"), int(4949))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_list_STAR_)
				tmp8 := checkDerefVar(glojure_DOT_core_with_meta)
				tmp9 := checkDerefVar(glojure_DOT_core_assoc)
				tmp10 := checkDerefVar(glojure_DOT_core_meta)
				tmp11 := lang.Apply(tmp10, []any{v5})
				tmp12 := lang.Apply(tmp9, []any{tmp11, lang.NewKeyword("private"), true})
				tmp13 := lang.Apply(tmp8, []any{v5, tmp12})
				tmp14 := lang.Apply(tmp7, []any{lang.NewSymbol("glojure.core/defn"), tmp13, v6})
				return tmp14
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defonce
	{
		tmp0 := lang.NewSymbol("defonce").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("expr"))), lang.NewKeyword("doc"), "defs name to have the root value of the expr iff the named var has no root value,\n  else expr is unevaluated", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5806), lang.NewKeyword("end-line"), int(5806))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			tmp7 := checkDerefVar(glojure_DOT_core_seq)
			tmp8 := checkDerefVar(glojure_DOT_core_concat)
			tmp9 := checkDerefVar(glojure_DOT_core_list)
			tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/let")})
			tmp11 := checkDerefVar(glojure_DOT_core_list)
			tmp12 := checkDerefVar(glojure_DOT_core_apply)
			tmp13 := checkDerefVar(glojure_DOT_core_vector)
			tmp14 := checkDerefVar(glojure_DOT_core_seq)
			tmp15 := checkDerefVar(glojure_DOT_core_concat)
			tmp16 := checkDerefVar(glojure_DOT_core_list)
			tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("v__0__auto__")})
			tmp18 := checkDerefVar(glojure_DOT_core_list)
			tmp19 := checkDerefVar(glojure_DOT_core_seq)
			tmp20 := checkDerefVar(glojure_DOT_core_concat)
			tmp21 := checkDerefVar(glojure_DOT_core_list)
			tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("def")})
			tmp23 := checkDerefVar(glojure_DOT_core_list)
			tmp24 := lang.Apply(tmp23, []any{v5})
			tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
			tmp26 := lang.Apply(tmp19, []any{tmp25})
			tmp27 := lang.Apply(tmp18, []any{tmp26})
			tmp28 := lang.Apply(tmp15, []any{tmp17, tmp27})
			tmp29 := lang.Apply(tmp14, []any{tmp28})
			tmp30 := lang.Apply(tmp12, []any{tmp13, tmp29})
			tmp31 := lang.Apply(tmp11, []any{tmp30})
			tmp32 := checkDerefVar(glojure_DOT_core_list)
			tmp33 := checkDerefVar(glojure_DOT_core_seq)
			tmp34 := checkDerefVar(glojure_DOT_core_concat)
			tmp35 := checkDerefVar(glojure_DOT_core_list)
			tmp36 := lang.Apply(tmp35, []any{lang.NewSymbol("glojure.core/when-not")})
			tmp37 := checkDerefVar(glojure_DOT_core_list)
			tmp38 := checkDerefVar(glojure_DOT_core_seq)
			tmp39 := checkDerefVar(glojure_DOT_core_concat)
			tmp40 := checkDerefVar(glojure_DOT_core_list)
			tmp41 := lang.Apply(tmp40, []any{lang.NewSymbol(".HasRoot")})
			tmp42 := checkDerefVar(glojure_DOT_core_list)
			tmp43 := lang.Apply(tmp42, []any{lang.NewSymbol("v__0__auto__")})
			tmp44 := lang.Apply(tmp39, []any{tmp41, tmp43})
			tmp45 := lang.Apply(tmp38, []any{tmp44})
			tmp46 := lang.Apply(tmp37, []any{tmp45})
			tmp47 := checkDerefVar(glojure_DOT_core_list)
			tmp48 := checkDerefVar(glojure_DOT_core_seq)
			tmp49 := checkDerefVar(glojure_DOT_core_concat)
			tmp50 := checkDerefVar(glojure_DOT_core_list)
			tmp51 := lang.Apply(tmp50, []any{lang.NewSymbol("def")})
			tmp52 := checkDerefVar(glojure_DOT_core_list)
			tmp53 := lang.Apply(tmp52, []any{v5})
			tmp54 := checkDerefVar(glojure_DOT_core_list)
			tmp55 := lang.Apply(tmp54, []any{v6})
			tmp56 := lang.Apply(tmp49, []any{tmp51, tmp53, tmp55})
			tmp57 := lang.Apply(tmp48, []any{tmp56})
			tmp58 := lang.Apply(tmp47, []any{tmp57})
			tmp59 := lang.Apply(tmp34, []any{tmp36, tmp46, tmp58})
			tmp60 := lang.Apply(tmp33, []any{tmp59})
			tmp61 := lang.Apply(tmp32, []any{tmp60})
			tmp62 := lang.Apply(tmp8, []any{tmp10, tmp31, tmp61})
			tmp63 := lang.Apply(tmp7, []any{tmp62})
			return tmp63
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defprotocol
	{
		tmp0 := lang.NewSymbol("defprotocol").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("opts+sigs"))), lang.NewKeyword("doc"), "A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n   ;options\n   :extend-via-metadata true\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in \n  Java parlance). defprotocol is dynamic, has no special compile-time \n  effect, and defines no new types or classes. Implementations of \n  the protocol methods can be provided using extend.\n\n  When :extend-via-metadata is true, values can extend protocols by\n  adding metadata where keys are fully-qualified protocol function\n  symbols and values are function implementations. Protocol\n  implementations are checked first for direct definitions (defrecord,\n  deftype, reify), then metadata definitions, then external\n  extensions (extend, extend-type, extend-protocol)\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P \n    (foo [this]) \n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c] \n   P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n  \n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo \n    (let [x 42]\n      (reify P \n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(28), lang.NewKeyword("end-line"), int(28))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "doc"
					var tmp8 any
					tmp9 := checkDerefVar(glojure_DOT_core_string_QMARK_)
					tmp10 := checkDerefVar(glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v6})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v6})
						tmp8 = tmp14
					} else {
					}
					var v15 any = tmp8
					_ = v15
					// let binding "opts+sigs"
					var tmp16 any
					if lang.IsTruthy(v15) {
						tmp17 := checkDerefVar(glojure_DOT_core_rest)
						tmp18 := lang.Apply(tmp17, []any{v6})
						tmp16 = tmp18
					} else {
						tmp16 = v6
					}
					var v19 any = tmp16
					_ = v19
					// let binding "opts"
					tmp20 := checkDerefVar(glojure_DOT_core_take_while)
					var tmp21 lang.FnFunc
					tmp21 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v22 := args[0]
						_ = v22
						tmp23 := checkDerefVar(glojure_DOT_core_not)
						tmp24 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
						tmp25 := lang.Apply(tmp24, []any{v22})
						tmp26 := lang.Apply(tmp23, []any{tmp25})
						return tmp26
					})
					tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(92), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(92), lang.NewKeyword("end-column"), int(40))
					tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp24 := lang.Apply(tmp20, []any{tmp23, v19})
					var v25 any = tmp24
					_ = v25
					// let binding "sigs"
					tmp26 := checkDerefVar(glojure_DOT_core_drop_while)
					var tmp27 lang.FnFunc
					tmp27 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v28 := args[0]
						_ = v28
						tmp29 := checkDerefVar(glojure_DOT_core_not)
						tmp30 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
						tmp31 := lang.Apply(tmp30, []any{v28})
						tmp32 := lang.Apply(tmp29, []any{tmp31})
						return tmp32
					})
					tmp28 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(93), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(93), lang.NewKeyword("end-column"), int(40))
					tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp30 := lang.Apply(tmp26, []any{tmp29, v19})
					var v31 any = tmp30
					_ = v31
					// let binding "opts"
					var tmp32 any
					tmp33 := checkDerefVar(glojure_DOT_core__EQ_)
					tmp34 := lang.Apply(tmp33, []any{v31, v25})
					if lang.IsTruthy(tmp34) {
					} else {
						tmp32 = v25
					}
					var v35 any = tmp32
					_ = v35
					tmp36 := checkDerefVar(glojure_DOT_core_seq)
					tmp37 := checkDerefVar(glojure_DOT_core_concat)
					tmp38 := checkDerefVar(glojure_DOT_core_list)
					tmp39 := lang.Apply(tmp38, []any{lang.NewSymbol("do")})
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					tmp41 := checkDerefVar(glojure_DOT_core_seq)
					tmp42 := checkDerefVar(glojure_DOT_core_concat)
					tmp43 := checkDerefVar(glojure_DOT_core_list)
					tmp44 := lang.Apply(tmp43, []any{lang.NewSymbol("def")})
					tmp45 := checkDerefVar(glojure_DOT_core_list)
					tmp46 := lang.Apply(tmp45, []any{v5})
					tmp47 := checkDerefVar(glojure_DOT_core_list)
					tmp48 := checkDerefVar(glojure_DOT_core_seq)
					tmp49 := checkDerefVar(glojure_DOT_core_concat)
					tmp50 := checkDerefVar(glojure_DOT_core_list)
					tmp51 := lang.Apply(tmp50, []any{lang.NewSymbol("glojure.core/atom")})
					tmp52 := checkDerefVar(glojure_DOT_core_list)
					tmp53 := checkDerefVar(glojure_DOT_core_apply)
					tmp54 := checkDerefVar(glojure_DOT_core_hash_map)
					tmp55 := checkDerefVar(glojure_DOT_core_seq)
					tmp56 := checkDerefVar(glojure_DOT_core_concat)
					tmp57 := checkDerefVar(glojure_DOT_core_list)
					tmp58 := lang.Apply(tmp57, []any{lang.NewKeyword("on-interface")})
					tmp59 := checkDerefVar(glojure_DOT_core_list)
					tmp60 := lang.Apply(tmp59, []any{true})
					tmp61 := checkDerefVar(glojure_DOT_core_list)
					tmp62 := lang.Apply(tmp61, []any{lang.NewKeyword("sigs")})
					tmp63 := checkDerefVar(glojure_DOT_core_list)
					tmp64 := checkDerefVar(glojure_DOT_core_seq)
					tmp65 := checkDerefVar(glojure_DOT_core_concat)
					tmp66 := checkDerefVar(glojure_DOT_core_list)
					tmp67 := lang.Apply(tmp66, []any{lang.NewSymbol("quote")})
					tmp68 := checkDerefVar(glojure_DOT_core_list)
					tmp69 := lang.Apply(tmp68, []any{v31})
					tmp70 := lang.Apply(tmp65, []any{tmp67, tmp69})
					tmp71 := lang.Apply(tmp64, []any{tmp70})
					tmp72 := lang.Apply(tmp63, []any{tmp71})
					tmp73 := checkDerefVar(glojure_DOT_core_list)
					tmp74 := lang.Apply(tmp73, []any{lang.NewKeyword("multis")})
					tmp75 := checkDerefVar(glojure_DOT_core_list)
					tmp76 := checkDerefVar(glojure_DOT_core_apply)
					tmp77 := checkDerefVar(glojure_DOT_core_hash_map)
					tmp78 := checkDerefVar(glojure_DOT_core_seq)
					tmp79 := checkDerefVar(glojure_DOT_core_concat)
					tmp80 := lang.Apply(tmp79, nil)
					tmp81 := lang.Apply(tmp78, []any{tmp80})
					tmp82 := lang.Apply(tmp76, []any{tmp77, tmp81})
					tmp83 := lang.Apply(tmp75, []any{tmp82})
					tmp84 := lang.Apply(tmp56, []any{tmp58, tmp60, tmp62, tmp72, tmp74, tmp83})
					tmp85 := lang.Apply(tmp55, []any{tmp84})
					tmp86 := lang.Apply(tmp53, []any{tmp54, tmp85})
					tmp87 := lang.Apply(tmp52, []any{tmp86})
					tmp88 := lang.Apply(tmp49, []any{tmp51, tmp87})
					tmp89 := lang.Apply(tmp48, []any{tmp88})
					tmp90 := lang.Apply(tmp47, []any{tmp89})
					tmp91 := lang.Apply(tmp42, []any{tmp44, tmp46, tmp90})
					tmp92 := lang.Apply(tmp41, []any{tmp91})
					tmp93 := lang.Apply(tmp40, []any{tmp92})
					tmp94 := checkDerefVar(glojure_DOT_core_list)
					tmp95 := checkDerefVar(glojure_DOT_core_seq)
					tmp96 := checkDerefVar(glojure_DOT_core_concat)
					tmp97 := checkDerefVar(glojure_DOT_core_list)
					tmp98 := lang.Apply(tmp97, []any{lang.NewSymbol("glojure.core/swap!")})
					tmp99 := checkDerefVar(glojure_DOT_core_list)
					tmp100 := lang.Apply(tmp99, []any{lang.NewSymbol("glojure.core/-protocols")})
					tmp101 := checkDerefVar(glojure_DOT_core_list)
					tmp102 := lang.Apply(tmp101, []any{lang.NewSymbol("glojure.core/assoc")})
					tmp103 := checkDerefVar(glojure_DOT_core_list)
					tmp104 := checkDerefVar(glojure_DOT_core_seq)
					tmp105 := checkDerefVar(glojure_DOT_core_concat)
					tmp106 := checkDerefVar(glojure_DOT_core_list)
					tmp107 := lang.Apply(tmp106, []any{lang.NewSymbol("quote")})
					tmp108 := checkDerefVar(glojure_DOT_core_list)
					tmp109 := lang.Apply(tmp108, []any{v5})
					tmp110 := lang.Apply(tmp105, []any{tmp107, tmp109})
					tmp111 := lang.Apply(tmp104, []any{tmp110})
					tmp112 := lang.Apply(tmp103, []any{tmp111})
					tmp113 := checkDerefVar(glojure_DOT_core_list)
					tmp114 := lang.Apply(tmp113, []any{v5})
					tmp115 := lang.Apply(tmp96, []any{tmp98, tmp100, tmp102, tmp112, tmp114})
					tmp116 := lang.Apply(tmp95, []any{tmp115})
					tmp117 := lang.Apply(tmp94, []any{tmp116})
					tmp118 := checkDerefVar(glojure_DOT_core_map)
					var tmp119 lang.FnFunc
					tmp119 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v120 := args[0]
						_ = v120
						tmp121 := checkDerefVar(glojure_DOT_core_seq)
						tmp122 := checkDerefVar(glojure_DOT_core_concat)
						tmp123 := checkDerefVar(glojure_DOT_core_list)
						tmp124 := lang.Apply(tmp123, []any{lang.NewSymbol("do")})
						tmp125 := checkDerefVar(glojure_DOT_core_list)
						tmp126 := checkDerefVar(glojure_DOT_core_seq)
						tmp127 := checkDerefVar(glojure_DOT_core_concat)
						tmp128 := checkDerefVar(glojure_DOT_core_list)
						tmp129 := lang.Apply(tmp128, []any{lang.NewSymbol("glojure.core/defmulti")})
						tmp130 := checkDerefVar(glojure_DOT_core_list)
						tmp131 := checkDerefVar(glojure_DOT_core_first)
						tmp132 := lang.Apply(tmp131, []any{v120})
						tmp133 := lang.Apply(tmp130, []any{tmp132})
						tmp134 := checkDerefVar(glojure_DOT_core_list)
						tmp135 := checkDerefVar(glojure_DOT_core_seq)
						tmp136 := checkDerefVar(glojure_DOT_core_concat)
						tmp137 := checkDerefVar(glojure_DOT_core_list)
						tmp138 := lang.Apply(tmp137, []any{lang.NewSymbol("glojure.core/fn")})
						tmp139 := checkDerefVar(glojure_DOT_core_list)
						tmp140 := checkDerefVar(glojure_DOT_core_apply)
						tmp141 := checkDerefVar(glojure_DOT_core_vector)
						tmp142 := checkDerefVar(glojure_DOT_core_seq)
						tmp143 := checkDerefVar(glojure_DOT_core_concat)
						tmp144 := checkDerefVar(glojure_DOT_core_list)
						tmp145 := lang.Apply(tmp144, []any{lang.NewSymbol("this")})
						tmp146 := checkDerefVar(glojure_DOT_core_list)
						tmp147 := lang.Apply(tmp146, []any{lang.NewSymbol("&")})
						tmp148 := checkDerefVar(glojure_DOT_core_list)
						tmp149 := lang.Apply(tmp148, []any{lang.NewSymbol("args")})
						tmp150 := lang.Apply(tmp143, []any{tmp145, tmp147, tmp149})
						tmp151 := lang.Apply(tmp142, []any{tmp150})
						tmp152 := lang.Apply(tmp140, []any{tmp141, tmp151})
						tmp153 := lang.Apply(tmp139, []any{tmp152})
						tmp154 := checkDerefVar(glojure_DOT_core_list)
						tmp155 := checkDerefVar(glojure_DOT_core_seq)
						tmp156 := checkDerefVar(glojure_DOT_core_concat)
						tmp157 := checkDerefVar(glojure_DOT_core_list)
						tmp158 := lang.Apply(tmp157, []any{lang.NewSymbol("glojure.core/class")})
						tmp159 := checkDerefVar(glojure_DOT_core_list)
						tmp160 := lang.Apply(tmp159, []any{lang.NewSymbol("this")})
						tmp161 := lang.Apply(tmp156, []any{tmp158, tmp160})
						tmp162 := lang.Apply(tmp155, []any{tmp161})
						tmp163 := lang.Apply(tmp154, []any{tmp162})
						tmp164 := lang.Apply(tmp136, []any{tmp138, tmp153, tmp163})
						tmp165 := lang.Apply(tmp135, []any{tmp164})
						tmp166 := lang.Apply(tmp134, []any{tmp165})
						tmp167 := lang.Apply(tmp127, []any{tmp129, tmp133, tmp166})
						tmp168 := lang.Apply(tmp126, []any{tmp167})
						tmp169 := lang.Apply(tmp125, []any{tmp168})
						tmp170 := checkDerefVar(glojure_DOT_core_list)
						tmp171 := checkDerefVar(glojure_DOT_core_seq)
						tmp172 := checkDerefVar(glojure_DOT_core_concat)
						tmp173 := checkDerefVar(glojure_DOT_core_list)
						tmp174 := lang.Apply(tmp173, []any{lang.NewSymbol("glojure.core/swap!")})
						tmp175 := checkDerefVar(glojure_DOT_core_list)
						tmp176 := lang.Apply(tmp175, []any{v5})
						tmp177 := checkDerefVar(glojure_DOT_core_list)
						tmp178 := lang.Apply(tmp177, []any{lang.NewSymbol("glojure.core/assoc-in")})
						tmp179 := checkDerefVar(glojure_DOT_core_list)
						tmp180 := checkDerefVar(glojure_DOT_core_apply)
						tmp181 := checkDerefVar(glojure_DOT_core_vector)
						tmp182 := checkDerefVar(glojure_DOT_core_seq)
						tmp183 := checkDerefVar(glojure_DOT_core_concat)
						tmp184 := checkDerefVar(glojure_DOT_core_list)
						tmp185 := lang.Apply(tmp184, []any{lang.NewKeyword("multis")})
						tmp186 := checkDerefVar(glojure_DOT_core_list)
						tmp187 := checkDerefVar(glojure_DOT_core_seq)
						tmp188 := checkDerefVar(glojure_DOT_core_concat)
						tmp189 := checkDerefVar(glojure_DOT_core_list)
						tmp190 := lang.Apply(tmp189, []any{lang.NewSymbol("glojure.core/keyword")})
						tmp191 := checkDerefVar(glojure_DOT_core_list)
						tmp192 := checkDerefVar(glojure_DOT_core_seq)
						tmp193 := checkDerefVar(glojure_DOT_core_concat)
						tmp194 := checkDerefVar(glojure_DOT_core_list)
						tmp195 := lang.Apply(tmp194, []any{lang.NewSymbol("quote")})
						tmp196 := checkDerefVar(glojure_DOT_core_list)
						tmp197 := checkDerefVar(glojure_DOT_core_first)
						tmp198 := lang.Apply(tmp197, []any{v120})
						tmp199 := lang.Apply(tmp196, []any{tmp198})
						tmp200 := lang.Apply(tmp193, []any{tmp195, tmp199})
						tmp201 := lang.Apply(tmp192, []any{tmp200})
						tmp202 := lang.Apply(tmp191, []any{tmp201})
						tmp203 := lang.Apply(tmp188, []any{tmp190, tmp202})
						tmp204 := lang.Apply(tmp187, []any{tmp203})
						tmp205 := lang.Apply(tmp186, []any{tmp204})
						tmp206 := lang.Apply(tmp183, []any{tmp185, tmp205})
						tmp207 := lang.Apply(tmp182, []any{tmp206})
						tmp208 := lang.Apply(tmp180, []any{tmp181, tmp207})
						tmp209 := lang.Apply(tmp179, []any{tmp208})
						tmp210 := checkDerefVar(glojure_DOT_core_list)
						tmp211 := checkDerefVar(glojure_DOT_core_first)
						tmp212 := lang.Apply(tmp211, []any{v120})
						tmp213 := lang.Apply(tmp210, []any{tmp212})
						tmp214 := lang.Apply(tmp172, []any{tmp174, tmp176, tmp178, tmp209, tmp213})
						tmp215 := lang.Apply(tmp171, []any{tmp214})
						tmp216 := lang.Apply(tmp170, []any{tmp215})
						tmp217 := lang.Apply(tmp122, []any{tmp124, tmp169, tmp216})
						tmp218 := lang.Apply(tmp121, []any{tmp217})
						return tmp218
					})
					tmp120 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(102), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(104), lang.NewKeyword("end-column"), int(90))
					tmp121, err := lang.WithMeta(tmp119, tmp120.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp122 := lang.Apply(tmp118, []any{tmp121, v31})
					tmp123 := checkDerefVar(glojure_DOT_core_list)
					tmp124 := checkDerefVar(glojure_DOT_core_seq)
					tmp125 := checkDerefVar(glojure_DOT_core_concat)
					tmp126 := checkDerefVar(glojure_DOT_core_list)
					tmp127 := lang.Apply(tmp126, []any{lang.NewSymbol("var")})
					tmp128 := checkDerefVar(glojure_DOT_core_list)
					tmp129 := lang.Apply(tmp128, []any{v5})
					tmp130 := lang.Apply(tmp125, []any{tmp127, tmp129})
					tmp131 := lang.Apply(tmp124, []any{tmp130})
					tmp132 := lang.Apply(tmp123, []any{tmp131})
					tmp133 := lang.Apply(tmp37, []any{tmp39, tmp93, tmp117, tmp122, tmp132})
					tmp134 := lang.Apply(tmp36, []any{tmp133})
					tmp7 = tmp134
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defstruct
	{
		tmp0 := lang.NewSymbol("defstruct").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("keys"))), lang.NewKeyword("doc"), "Same as (def name (create-struct keys...))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4044), lang.NewKeyword("end-line"), int(4044))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("def")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := checkDerefVar(glojure_DOT_core_seq)
				tmp15 := checkDerefVar(glojure_DOT_core_concat)
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("glojure.core/create-struct")})
				tmp18 := lang.Apply(tmp15, []any{tmp17, v6})
				tmp19 := lang.Apply(tmp14, []any{tmp18})
				tmp20 := lang.Apply(tmp13, []any{tmp19})
				tmp21 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp20})
				tmp22 := lang.Apply(tmp7, []any{tmp21})
				return tmp22
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// delay
	{
		tmp0 := lang.NewSymbol("delay").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls. See also - realized?", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(739), lang.NewKeyword("end-line"), int(739))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := checkDerefVar(glojure_DOT_core_list_STAR_)
				tmp8 := lang.NewVector()
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(746), lang.NewKeyword("column"), int(62), lang.NewKeyword("end-line"), int(746), lang.NewKeyword("end-column"), int(63))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := lang.Apply(tmp7, []any{lang.NewSymbol("fn*"), tmp10, v5})
				tmp12 := lang.Apply(tmp6, []any{lang.NewSymbol("new"), lang.NewSymbol("glojure.lang.Delay"), tmp11})
				return tmp12
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// delay?
	{
		tmp0 := lang.NewSymbol("delay?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "returns true if x is a Delay created with delay", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(748), lang.NewKeyword("end-line"), int(748))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deliver
	{
		tmp0 := lang.NewSymbol("deliver").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("promise"), lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Delivers the supplied value to the promise, releasing any pending\n  derefs. A subsequent call to deliver on a promise will have no effect.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7109), lang.NewKeyword("end-line"), int(7109))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(v3, []any{v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// denominator
	{
		tmp1 := reflect.TypeOf((*big9.Int)(nil))
		tmp0 := lang.NewSymbol("denominator").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("r"))), lang.NewKeyword("doc"), "Returns the denominator part of a Ratio.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3591), lang.NewKeyword("end-line"), int(3591))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, ok := lang.FieldOrMethod(v4, "denominator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "denominator")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			return tmp6
		})
		tmp4 := reflect.TypeOf((*big9.Int)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref
	{
		tmp0 := lang.NewSymbol("deref").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref")), lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("timeout-ms"), lang.NewSymbol("timeout-val"))), lang.NewKeyword("doc"), "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2304), lang.NewKeyword("end-line"), int(2304))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.IDeref)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
				if lang.IsTruthy(tmp7) {
					tmp8, ok := lang.FieldOrMethod(v3, "Deref")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Deref")))
					}
					var tmp9 any
					switch reflect.TypeOf(tmp8).Kind() {
					case reflect.Func:
						tmp9 = lang.Apply(tmp8, nil)
					default:
						tmp9 = tmp8
					}
					tmp4 = tmp9
				} else {
					tmp10 := checkDerefVar(glojure_DOT_core_deref_future)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp4 = tmp11
				}
				return tmp4
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp8 := reflect.TypeOf((*lang.IBlockingDeref)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
				if lang.IsTruthy(tmp9) {
					tmp10, _ := lang.FieldOrMethod(v3, "DerefWithTimeout")
					if reflect.TypeOf(tmp10).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("DerefWithTimeout is not a function")))
					}
					tmp11 := lang.Apply(tmp10, []any{v4, v5})
					tmp6 = tmp11
				} else {
					tmp12 := checkDerefVar(glojure_DOT_core_deref_future)
					tmp13 := lang.Apply(tmp12, []any{v3, v4, v5})
					tmp6 = tmp13
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref-as-map
	{
		tmp0 := lang.NewSymbol("deref-as-map").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(408), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(408), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "pending"
				var tmp5 any
				{ // let
					// let binding "and__0__auto__"
					tmp6 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
					tmp7 := reflect.TypeOf((*lang.IPending)(nil)).Elem()
					tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp11 := checkDerefVar(glojure_DOT_core_not)
						tmp12, ok := lang.FieldOrMethod(v3, "isRealized")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isRealized")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						tmp14 := lang.Apply(tmp11, []any{tmp13})
						tmp10 = tmp14
					} else {
						tmp10 = v9
					}
					tmp5 = tmp10
				} // end let
				var v6 any = tmp5
				_ = v6
				// let binding "vec__250"
				var tmp7 any
				if lang.IsTruthy(v6) {
				} else {
					var tmp8 any
					func() {
						defer func() {
							if r := recover(); r != nil {
								if lang.CatchMatches(r, lang.Throwable) {
									v9 := r
									_ = v9
									tmp10 := lang.NewVector(true, v9)
									tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(415), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(415), lang.NewKeyword("end-column"), int(25))
									tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp8 = tmp12
								} else {
									panic(r)
								}
							}
						}()
						tmp9 := checkDerefVar(glojure_DOT_core_deref)
						tmp10 := lang.Apply(tmp9, []any{v3})
						tmp11 := lang.NewVector(false, tmp10)
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(413), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(413), lang.NewKeyword("end-column"), int(32))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp13
					}()
					tmp7 = tmp8
				}
				var v14 any = tmp7
				_ = v14
				// let binding "ex"
				tmp15 := checkDerefVar(glojure_DOT_core_nth)
				tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
				var v17 any = tmp16
				_ = v17
				// let binding "val"
				tmp18 := checkDerefVar(glojure_DOT_core_nth)
				tmp19 := lang.Apply(tmp18, []any{v14, int64(1), nil})
				var v20 any = tmp19
				_ = v20
				var tmp21 any
				var tmp22 any
				{ // let
					// let binding "or__0__auto__"
					var v23 any = v17
					_ = v23
					var tmp24 any
					if lang.IsTruthy(v23) {
						tmp24 = v23
					} else {
						var tmp25 any
						{ // let
							// let binding "and__0__auto__"
							tmp26 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
							tmp27 := reflect.TypeOf((*lang.Agent)(nil))
							tmp28 := lang.Apply(tmp26, []any{tmp27, v3})
							var v29 any = tmp28
							_ = v29
							var tmp30 any
							if lang.IsTruthy(v29) {
								tmp31 := checkDerefVar(glojure_DOT_core_agent_error)
								tmp32 := lang.Apply(tmp31, []any{v3})
								tmp30 = tmp32
							} else {
								tmp30 = v29
							}
							tmp25 = tmp30
						} // end let
						tmp24 = tmp25
					}
					tmp22 = tmp24
				} // end let
				if lang.IsTruthy(tmp22) {
					tmp21 = lang.NewKeyword("failed")
				} else {
					var tmp23 any
					if lang.IsTruthy(v6) {
						tmp23 = lang.NewKeyword("pending")
					} else {
						var tmp24 any
						if lang.IsTruthy(lang.NewKeyword("else")) {
							tmp24 = lang.NewKeyword("ready")
						} else {
						}
						tmp23 = tmp24
					}
					tmp21 = tmp23
				}
				tmp25 := lang.NewMap(lang.NewKeyword("status"), tmp21, lang.NewKeyword("val"), v20)
				tmp26 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(416), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(429), lang.NewKeyword("end-column"), int(14))
				tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp27
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref-future
	{
		tmp0 := lang.NewSymbol("deref-future").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2296), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(2296), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("fut")), lang.NewVector(lang.NewSymbol("fut"), lang.NewSymbol("timeout-ms"), lang.NewSymbol("timeout-val"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, ok := lang.FieldOrMethod(v3, "Get")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Get")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							tmp7 := reflect.TypeOf((*lang.TimeoutError)(nil)).Elem()
							if lang.CatchMatches(r, tmp7) {
								v8 := r
								_ = v8
								tmp6 = v5
							} else {
								panic(r)
							}
						}
					}()
					tmp8, _ := lang.FieldOrMethod(v3, "Get")
					if reflect.TypeOf(tmp8).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Get is not a function")))
					}
					tmp9 := lang.Apply(tmp8, []any{v4, time10.Millisecond})
					tmp6 = tmp9
				}()
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// derive
	{
		tmp0 := lang.NewSymbol("derive").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag"), lang.NewSymbol("parent")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("tag"), lang.NewSymbol("parent"))), lang.NewKeyword("doc"), "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5605), lang.NewKeyword("end-line"), int(5605))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_alter_var_root)
				tmp6 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("global-hierarchy"))
				tmp7 := checkDerefVar(glojure_DOT_core_derive)
				tmp8 := lang.Apply(tmp5, []any{tmp6, tmp7, v3, v4})
				_ = tmp8
				return nil
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "tp"
					tmp7 := lang.Apply(lang.NewKeyword("parents"), []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "td"
					tmp9 := lang.Apply(lang.NewKeyword("descendants"), []any{v3})
					var v10 any = tmp9
					_ = v10
					// let binding "ta"
					tmp11 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
					var v12 any = tmp11
					_ = v12
					// let binding "tf"
					var tmp13 lang.FnFunc
					tmp13 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 5 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v14 := args[0]
						_ = v14
						v15 := args[1]
						_ = v15
						v16 := args[2]
						_ = v16
						v17 := args[3]
						_ = v17
						v18 := args[4]
						_ = v18
						tmp19 := checkDerefVar(glojure_DOT_core_reduce1)
						var tmp20 lang.FnFunc
						tmp20 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v21 := args[0]
							_ = v21
							v22 := args[1]
							_ = v22
							tmp23 := checkDerefVar(glojure_DOT_core_assoc)
							tmp24 := checkDerefVar(glojure_DOT_core_reduce1)
							tmp25 := checkDerefVar(glojure_DOT_core_conj)
							tmp26 := checkDerefVar(glojure_DOT_core_get)
							tmp27 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp28 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5628), lang.NewKeyword("column"), int(61), lang.NewKeyword("end-line"), int(5628), lang.NewKeyword("end-column"), int(63))
							tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp30 := lang.Apply(tmp26, []any{v18, v22, tmp29})
							tmp31 := checkDerefVar(glojure_DOT_core_cons)
							tmp32 := lang.Apply(v18, []any{v17})
							tmp33 := lang.Apply(tmp31, []any{v17, tmp32})
							tmp34 := lang.Apply(tmp24, []any{tmp25, tmp30, tmp33})
							tmp35 := lang.Apply(tmp23, []any{v21, v22, tmp34})
							return tmp35
						})
						tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5626), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(5628), lang.NewKeyword("end-column"), int(98))
						tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp23 := checkDerefVar(glojure_DOT_core_cons)
						tmp24 := lang.Apply(v16, []any{v15})
						tmp25 := lang.Apply(tmp23, []any{v15, tmp24})
						tmp26 := lang.Apply(tmp19, []any{tmp22, v14, tmp25})
						return tmp26
					})
					tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5625), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(5629), lang.NewKeyword("end-column"), int(56))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v16 any = tmp15
					_ = v16
					var tmp17 any
					{ // let
						// let binding "or__0__auto__"
						var tmp18 any
						tmp19 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
						tmp20 := lang.Apply(v8, []any{v4})
						tmp21 := lang.Apply(tmp19, []any{tmp20, v5})
						if lang.IsTruthy(tmp21) {
						} else {
							var tmp22 any
							tmp23 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
							tmp24 := lang.Apply(v12, []any{v4})
							tmp25 := lang.Apply(tmp23, []any{tmp24, v5})
							if lang.IsTruthy(tmp25) {
								tmp26 := checkDerefVar(glojure_DOT_core_print_str)
								tmp27 := lang.Apply(tmp26, []any{v4, "already has", v5, "as ancestor"})
								tmp28 := lang.Apply(lang.NewError, []any{tmp27})
								panic(tmp28)
							} else {
							}
							_ = tmp22
							var tmp29 any
							tmp30 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
							tmp31 := lang.Apply(v12, []any{v5})
							tmp32 := lang.Apply(tmp30, []any{tmp31, v4})
							if lang.IsTruthy(tmp32) {
								tmp33 := checkDerefVar(glojure_DOT_core_print_str)
								tmp34 := lang.Apply(tmp33, []any{"Cyclic derivation:", v5, "has", v4, "as ancestor"})
								tmp35 := lang.Apply(lang.NewError, []any{tmp34})
								panic(tmp35)
							} else {
							}
							_ = tmp29
							tmp36 := checkDerefVar(glojure_DOT_core_assoc)
							tmp37 := lang.Apply(lang.NewKeyword("parents"), []any{v3})
							tmp38 := checkDerefVar(glojure_DOT_core_conj)
							tmp39 := checkDerefVar(glojure_DOT_core_get)
							tmp40 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp41 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5636), lang.NewKeyword("column"), int(61), lang.NewKeyword("end-line"), int(5636), lang.NewKeyword("end-column"), int(63))
							tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp43 := lang.Apply(tmp39, []any{v8, v4, tmp42})
							tmp44 := lang.Apply(tmp38, []any{tmp43, v5})
							tmp45 := lang.Apply(tmp36, []any{tmp37, v4, tmp44})
							tmp46 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
							tmp47 := lang.Apply(v16, []any{tmp46, v4, v10, v5, v12})
							tmp48 := lang.Apply(lang.NewKeyword("descendants"), []any{v3})
							tmp49 := lang.Apply(v16, []any{tmp48, v5, v12, v4, v10})
							tmp50 := lang.NewMap(lang.NewKeyword("parents"), tmp45, lang.NewKeyword("ancestors"), tmp47, lang.NewKeyword("descendants"), tmp49)
							tmp51 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5636), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(5638), lang.NewKeyword("end-column"), int(61))
							tmp52, err := lang.WithMeta(tmp50, tmp51.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp18 = tmp52
						}
						var v53 any = tmp18
						_ = v53
						var tmp54 any
						if lang.IsTruthy(v53) {
							tmp54 = v53
						} else {
							tmp54 = v3
						}
						tmp17 = tmp54
					} // end let
					tmp6 = tmp17
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// descendants
	{
		tmp0 := lang.NewSymbol("descendants").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("tag"))), lang.NewKeyword("doc"), "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on Java type inheritance\n  relationships.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5593), lang.NewKeyword("end-line"), int(5593))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_descendants)
				tmp5 := checkDerefVar(glojure_DOT_core_global_hierarchy)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_class_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp8 := lang.Apply(lang.NewUnsupportedOperationError, []any{"Can't get descendants of classes"})
					panic(tmp8)
				} else {
					tmp9 := checkDerefVar(glojure_DOT_core_not_empty)
					tmp10 := checkDerefVar(glojure_DOT_core_get)
					tmp11 := lang.Apply(lang.NewKeyword("descendants"), []any{v3})
					tmp12 := lang.Apply(tmp10, []any{tmp11, v4})
					tmp13 := lang.Apply(tmp9, []any{tmp12})
					tmp5 = tmp13
				}
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// destructure
	{
		tmp0 := lang.NewSymbol("destructure").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4400), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(4400), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "bents"
				tmp5 := checkDerefVar(glojure_DOT_core_partition)
				tmp6 := lang.Apply(tmp5, []any{int64(2), v3})
				var v7 any = tmp6
				_ = v7
				// let binding "pb"
				var tmp8 lang.FnFunc
				{ // function pb
					var v9 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v10 := args[0]
						_ = v10
						v11 := args[1]
						_ = v11
						v12 := args[2]
						_ = v12
						var tmp13 any
						{ // let
							// let binding "pvec"
							var tmp14 lang.FnFunc
							tmp14 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 3 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								v17 := args[2]
								_ = v17
								var tmp18 any
								{ // let
									// let binding "gvec"
									tmp19 := checkDerefVar(glojure_DOT_core_gensym)
									tmp20 := lang.Apply(tmp19, []any{"vec__"})
									var v21 any = tmp20
									_ = v21
									// let binding "gseq"
									tmp22 := checkDerefVar(glojure_DOT_core_gensym)
									tmp23 := lang.Apply(tmp22, []any{"seq__"})
									var v24 any = tmp23
									_ = v24
									// let binding "gfirst"
									tmp25 := checkDerefVar(glojure_DOT_core_gensym)
									tmp26 := lang.Apply(tmp25, []any{"first__"})
									var v27 any = tmp26
									_ = v27
									// let binding "has-rest"
									tmp28 := checkDerefVar(glojure_DOT_core_some)
									tmp29 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{lang.NewSymbol("&")}))
									tmp30 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4408), lang.NewKeyword("column"), int(43), lang.NewKeyword("end-line"), int(4408), lang.NewKeyword("end-column"), int(47))
									tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp32 := lang.Apply(tmp28, []any{tmp31, v16})
									var v33 any = tmp32
									_ = v33
									var tmp34 any
									{ // let
										// let binding "ret"
										var tmp35 any
										{ // let
											// let binding "ret"
											tmp36 := checkDerefVar(glojure_DOT_core_conj)
											tmp37 := lang.Apply(tmp36, []any{v15, v21, v17})
											var v38 any = tmp37
											_ = v38
											var tmp39 any
											if lang.IsTruthy(v33) {
												tmp40 := checkDerefVar(glojure_DOT_core_conj)
												tmp41 := checkDerefVar(glojure_DOT_core_list)
												tmp42 := lang.Apply(tmp41, []any{lang.NewSymbol("glojure.core/seq"), v21})
												tmp43 := lang.Apply(tmp40, []any{v38, v24, tmp42})
												tmp39 = tmp43
											} else {
												tmp39 = v38
											}
											tmp35 = tmp39
										} // end let
										var v36 any = tmp35
										_ = v36
										// let binding "n"
										var v37 any = int64(0)
										_ = v37
										// let binding "bs"
										var v38 any = v16
										_ = v38
										// let binding "seen-rest?"
										var v39 any = false
										_ = v39
										for {
											var tmp40 any
											tmp41 := checkDerefVar(glojure_DOT_core_seq)
											tmp42 := lang.Apply(tmp41, []any{v38})
											if lang.IsTruthy(tmp42) {
												var tmp43 any
												{ // let
													// let binding "firstb"
													tmp44 := checkDerefVar(glojure_DOT_core_first)
													tmp45 := lang.Apply(tmp44, []any{v38})
													var v46 any = tmp45
													_ = v46
													var tmp47 any
													tmp48 := checkDerefVar(glojure_DOT_core__EQ_)
													tmp49 := lang.Apply(tmp48, []any{v46, lang.NewSymbol("&")})
													if lang.IsTruthy(tmp49) {
														tmp51 := checkDerefVar(glojure_DOT_core_second)
														tmp52 := lang.Apply(tmp51, []any{v38})
														tmp53 := lang.Apply(v9, []any{v36, tmp52, v24})
														var tmp50 any = tmp53
														var tmp54 any = v37
														tmp56 := checkDerefVar(glojure_DOT_core_nnext)
														tmp57 := lang.Apply(tmp56, []any{v38})
														var tmp55 any = tmp57
														var tmp58 any = true
														v36 = tmp50
														v37 = tmp54
														v38 = tmp55
														v39 = tmp58
														continue
													} else {
														var tmp59 any
														tmp60 := checkDerefVar(glojure_DOT_core__EQ_)
														tmp61 := lang.Apply(tmp60, []any{v46, lang.NewKeyword("as")})
														if lang.IsTruthy(tmp61) {
															tmp62 := checkDerefVar(glojure_DOT_core_second)
															tmp63 := lang.Apply(tmp62, []any{v38})
															tmp64 := lang.Apply(v9, []any{v36, tmp63, v21})
															tmp59 = tmp64
														} else {
															var tmp65 any
															if lang.IsTruthy(lang.NewKeyword("else")) {
																var tmp66 any
																if lang.IsTruthy(v39) {
																	tmp67 := lang.Apply(errors8.New, []any{"Unsupported binding form, only :as can follow & parameter"})
																	panic(tmp67)
																} else {
																	var tmp69 any
																	if lang.IsTruthy(v33) {
																		tmp70 := checkDerefVar(glojure_DOT_core_conj)
																		tmp71 := checkDerefVar(glojure_DOT_core_seq)
																		tmp72 := checkDerefVar(glojure_DOT_core_concat)
																		tmp73 := checkDerefVar(glojure_DOT_core_list)
																		tmp74 := lang.Apply(tmp73, []any{lang.NewSymbol("glojure.core/first")})
																		tmp75 := checkDerefVar(glojure_DOT_core_list)
																		tmp76 := lang.Apply(tmp75, []any{v24})
																		tmp77 := lang.Apply(tmp72, []any{tmp74, tmp76})
																		tmp78 := lang.Apply(tmp71, []any{tmp77})
																		tmp79 := checkDerefVar(glojure_DOT_core_seq)
																		tmp80 := checkDerefVar(glojure_DOT_core_concat)
																		tmp81 := checkDerefVar(glojure_DOT_core_list)
																		tmp82 := lang.Apply(tmp81, []any{lang.NewSymbol("glojure.core/next")})
																		tmp83 := checkDerefVar(glojure_DOT_core_list)
																		tmp84 := lang.Apply(tmp83, []any{v24})
																		tmp85 := lang.Apply(tmp80, []any{tmp82, tmp84})
																		tmp86 := lang.Apply(tmp79, []any{tmp85})
																		tmp87 := lang.Apply(tmp70, []any{v36, v27, tmp78, v24, tmp86})
																		tmp69 = tmp87
																	} else {
																		tmp69 = v36
																	}
																	var tmp88 any
																	if lang.IsTruthy(v33) {
																		tmp88 = v27
																	} else {
																		tmp89 := checkDerefVar(glojure_DOT_core_list)
																		tmp90 := lang.Apply(tmp89, []any{lang.NewSymbol("glojure.core/nth"), v21, v37, nil})
																		tmp88 = tmp90
																	}
																	tmp91 := lang.Apply(v9, []any{tmp69, v46, tmp88})
																	var tmp68 any = tmp91
																	tmp93 := checkDerefVar(glojure_DOT_core_inc)
																	tmp94 := lang.Apply(tmp93, []any{v37})
																	var tmp92 any = tmp94
																	tmp96 := checkDerefVar(glojure_DOT_core_next)
																	tmp97 := lang.Apply(tmp96, []any{v38})
																	var tmp95 any = tmp97
																	var tmp98 any = v39
																	v36 = tmp68
																	v37 = tmp92
																	v38 = tmp95
																	v39 = tmp98
																	continue
																}
																tmp65 = tmp66
															} else {
															}
															tmp59 = tmp65
														}
														tmp47 = tmp59
													}
													tmp43 = tmp47
												} // end let
												tmp40 = tmp43
											} else {
												tmp40 = v36
											}
											tmp34 = tmp40
											break
										}
									} // end let
									tmp18 = tmp34
								} // end let
								return tmp18
							})
							tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4404), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(4438), lang.NewKeyword("end-column"), int(34))
							tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v17 any = tmp16
							_ = v17
							// let binding "pmap"
							var tmp18 lang.FnFunc
							tmp18 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 3 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v19 := args[0]
								_ = v19
								v20 := args[1]
								_ = v20
								v21 := args[2]
								_ = v21
								var tmp22 any
								{ // let
									// let binding "gmap"
									tmp23 := checkDerefVar(glojure_DOT_core_gensym)
									tmp24 := lang.Apply(tmp23, []any{"map__"})
									var v25 any = tmp24
									_ = v25
									// let binding "gmapseq"
									tmp26 := checkDerefVar(glojure_DOT_core_with_meta)
									tmp27 := lang.NewMap(lang.NewKeyword("tag"), lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.ISeq"))
									tmp28 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4442), lang.NewKeyword("column"), int(52), lang.NewKeyword("end-line"), int(4442), lang.NewKeyword("end-column"), int(103))
									tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp30 := lang.Apply(tmp26, []any{v25, tmp29})
									var v31 any = tmp30
									_ = v31
									// let binding "defaults"
									tmp32 := lang.Apply(lang.NewKeyword("or"), []any{v20})
									var v33 any = tmp32
									_ = v33
									var tmp34 any
									{ // let
										// let binding "ret"
										var tmp35 lang.FnFunc
										tmp35 = lang.NewFnFunc(func(args ...any) any {
											if len(args) != 1 {
												panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
											}
											v36 := args[0]
											_ = v36
											var tmp37 any
											tmp38 := lang.Apply(lang.NewKeyword("as"), []any{v20})
											if lang.IsTruthy(tmp38) {
												tmp39 := checkDerefVar(glojure_DOT_core_conj)
												tmp40 := lang.Apply(lang.NewKeyword("as"), []any{v20})
												tmp41 := lang.Apply(tmp39, []any{v36, tmp40, v25})
												tmp37 = tmp41
											} else {
												tmp37 = v36
											}
											return tmp37
										})
										tmp36 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4450), lang.NewKeyword("column"), int(40), lang.NewKeyword("end-line"), int(4453), lang.NewKeyword("end-column"), int(48))
										tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp38 := checkDerefVar(glojure_DOT_core_conj)
										tmp39 := checkDerefVar(glojure_DOT_core_conj)
										tmp40 := checkDerefVar(glojure_DOT_core_conj)
										tmp41 := checkDerefVar(glojure_DOT_core_conj)
										tmp42 := lang.Apply(tmp41, []any{v19, v25})
										tmp43 := lang.Apply(tmp40, []any{tmp42, v21})
										tmp44 := lang.Apply(tmp39, []any{tmp43, v25})
										tmp45 := checkDerefVar(glojure_DOT_core_seq)
										tmp46 := checkDerefVar(glojure_DOT_core_concat)
										tmp47 := checkDerefVar(glojure_DOT_core_list)
										tmp48 := lang.Apply(tmp47, []any{lang.NewSymbol("if")})
										tmp49 := checkDerefVar(glojure_DOT_core_list)
										tmp50 := checkDerefVar(glojure_DOT_core_seq)
										tmp51 := checkDerefVar(glojure_DOT_core_concat)
										tmp52 := checkDerefVar(glojure_DOT_core_list)
										tmp53 := lang.Apply(tmp52, []any{lang.NewSymbol("glojure.core/seq?")})
										tmp54 := checkDerefVar(glojure_DOT_core_list)
										tmp55 := lang.Apply(tmp54, []any{v25})
										tmp56 := lang.Apply(tmp51, []any{tmp53, tmp55})
										tmp57 := lang.Apply(tmp50, []any{tmp56})
										tmp58 := lang.Apply(tmp49, []any{tmp57})
										tmp59 := checkDerefVar(glojure_DOT_core_list)
										tmp60 := checkDerefVar(glojure_DOT_core_seq)
										tmp61 := checkDerefVar(glojure_DOT_core_concat)
										tmp62 := checkDerefVar(glojure_DOT_core_list)
										tmp63 := lang.Apply(tmp62, []any{lang.NewSymbol("if")})
										tmp64 := checkDerefVar(glojure_DOT_core_list)
										tmp65 := checkDerefVar(glojure_DOT_core_seq)
										tmp66 := checkDerefVar(glojure_DOT_core_concat)
										tmp67 := checkDerefVar(glojure_DOT_core_list)
										tmp68 := lang.Apply(tmp67, []any{lang.NewSymbol("glojure.core/next")})
										tmp69 := checkDerefVar(glojure_DOT_core_list)
										tmp70 := lang.Apply(tmp69, []any{v31})
										tmp71 := lang.Apply(tmp66, []any{tmp68, tmp70})
										tmp72 := lang.Apply(tmp65, []any{tmp71})
										tmp73 := lang.Apply(tmp64, []any{tmp72})
										tmp74 := checkDerefVar(glojure_DOT_core_list)
										tmp75 := checkDerefVar(glojure_DOT_core_seq)
										tmp76 := checkDerefVar(glojure_DOT_core_concat)
										tmp77 := checkDerefVar(glojure_DOT_core_list)
										tmp78 := lang.Apply(tmp77, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewPersistentArrayMapAsIfByAssoc")})
										tmp79 := checkDerefVar(glojure_DOT_core_list)
										tmp80 := checkDerefVar(glojure_DOT_core_seq)
										tmp81 := checkDerefVar(glojure_DOT_core_concat)
										tmp82 := checkDerefVar(glojure_DOT_core_list)
										tmp83 := lang.Apply(tmp82, []any{lang.NewSymbol("glojure.core/to-array")})
										tmp84 := checkDerefVar(glojure_DOT_core_list)
										tmp85 := lang.Apply(tmp84, []any{v31})
										tmp86 := lang.Apply(tmp81, []any{tmp83, tmp85})
										tmp87 := lang.Apply(tmp80, []any{tmp86})
										tmp88 := lang.Apply(tmp79, []any{tmp87})
										tmp89 := lang.Apply(tmp76, []any{tmp78, tmp88})
										tmp90 := lang.Apply(tmp75, []any{tmp89})
										tmp91 := lang.Apply(tmp74, []any{tmp90})
										tmp92 := checkDerefVar(glojure_DOT_core_list)
										tmp93 := checkDerefVar(glojure_DOT_core_seq)
										tmp94 := checkDerefVar(glojure_DOT_core_concat)
										tmp95 := checkDerefVar(glojure_DOT_core_list)
										tmp96 := lang.Apply(tmp95, []any{lang.NewSymbol("if")})
										tmp97 := checkDerefVar(glojure_DOT_core_list)
										tmp98 := checkDerefVar(glojure_DOT_core_seq)
										tmp99 := checkDerefVar(glojure_DOT_core_concat)
										tmp100 := checkDerefVar(glojure_DOT_core_list)
										tmp101 := lang.Apply(tmp100, []any{lang.NewSymbol("glojure.core/seq")})
										tmp102 := checkDerefVar(glojure_DOT_core_list)
										tmp103 := lang.Apply(tmp102, []any{v31})
										tmp104 := lang.Apply(tmp99, []any{tmp101, tmp103})
										tmp105 := lang.Apply(tmp98, []any{tmp104})
										tmp106 := lang.Apply(tmp97, []any{tmp105})
										tmp107 := checkDerefVar(glojure_DOT_core_list)
										tmp108 := checkDerefVar(glojure_DOT_core_seq)
										tmp109 := checkDerefVar(glojure_DOT_core_concat)
										tmp110 := checkDerefVar(glojure_DOT_core_list)
										tmp111 := lang.Apply(tmp110, []any{lang.NewSymbol("glojure.core/first")})
										tmp112 := checkDerefVar(glojure_DOT_core_list)
										tmp113 := lang.Apply(tmp112, []any{v31})
										tmp114 := lang.Apply(tmp109, []any{tmp111, tmp113})
										tmp115 := lang.Apply(tmp108, []any{tmp114})
										tmp116 := lang.Apply(tmp107, []any{tmp115})
										tmp117 := checkDerefVar(glojure_DOT_core_list)
										tmp118 := lang.Apply(tmp117, []any{lang.NewSymbol("glojure.lang.PersistentArrayMap/EMPTY")})
										tmp119 := lang.Apply(tmp94, []any{tmp96, tmp106, tmp116, tmp118})
										tmp120 := lang.Apply(tmp93, []any{tmp119})
										tmp121 := lang.Apply(tmp92, []any{tmp120})
										tmp122 := lang.Apply(tmp61, []any{tmp63, tmp73, tmp91, tmp121})
										tmp123 := lang.Apply(tmp60, []any{tmp122})
										tmp124 := lang.Apply(tmp59, []any{tmp123})
										tmp125 := checkDerefVar(glojure_DOT_core_list)
										tmp126 := lang.Apply(tmp125, []any{v25})
										tmp127 := lang.Apply(tmp46, []any{tmp48, tmp58, tmp124, tmp126})
										tmp128 := lang.Apply(tmp45, []any{tmp127})
										tmp129 := lang.Apply(tmp38, []any{tmp44, tmp128})
										tmp130 := lang.Apply(tmp37, []any{tmp129})
										var v131 any = tmp130
										_ = v131
										// let binding "bes"
										var tmp132 any
										{ // let
											// let binding "transforms"
											tmp133 := checkDerefVar(glojure_DOT_core_reduce1)
											var tmp134 lang.FnFunc
											tmp134 = lang.NewFnFunc(func(args ...any) any {
												if len(args) != 2 {
													panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
												}
												v135 := args[0]
												_ = v135
												v136 := args[1]
												_ = v136
												var tmp137 any
												tmp138 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
												tmp139 := lang.Apply(tmp138, []any{v136})
												if lang.IsTruthy(tmp139) {
													var tmp140 any
													{ // let
														// let binding "mkns"
														tmp141 := checkDerefVar(glojure_DOT_core_namespace)
														tmp142 := lang.Apply(tmp141, []any{v136})
														var v143 any = tmp142
														_ = v143
														// let binding "mkn"
														tmp144 := checkDerefVar(glojure_DOT_core_name)
														tmp145 := lang.Apply(tmp144, []any{v136})
														var v146 any = tmp145
														_ = v146
														var tmp147 any
														tmp148 := checkDerefVar(glojure_DOT_core__EQ_)
														tmp149 := lang.Apply(tmp148, []any{v146, "keys"})
														if lang.IsTruthy(tmp149) {
															tmp150 := checkDerefVar(glojure_DOT_core_assoc)
															var tmp151 lang.FnFunc
															tmp151 = lang.NewFnFunc(func(args ...any) any {
																if len(args) != 1 {
																	panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
																}
																v152 := args[0]
																_ = v152
																tmp153 := checkDerefVar(glojure_DOT_core_keyword)
																var tmp154 any
																{ // let
																	// let binding "or__0__auto__"
																	var v155 any = v143
																	_ = v155
																	var tmp156 any
																	if lang.IsTruthy(v155) {
																		tmp156 = v155
																	} else {
																		tmp157 := checkDerefVar(glojure_DOT_core_namespace)
																		tmp158 := lang.Apply(tmp157, []any{v152})
																		tmp156 = tmp158
																	}
																	tmp154 = tmp156
																} // end let
																tmp155 := checkDerefVar(glojure_DOT_core_name)
																tmp156 := lang.Apply(tmp155, []any{v152})
																tmp157 := lang.Apply(tmp153, []any{tmp154, tmp156})
																return tmp157
															})
															tmp152 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4460), lang.NewKeyword("column"), int(93), lang.NewKeyword("end-line"), int(4460), lang.NewKeyword("end-column"), int(135))
															tmp153, err := lang.WithMeta(tmp151, tmp152.(lang.IPersistentMap))
															if err != nil {
																panic(err)
															}
															tmp154 := lang.Apply(tmp150, []any{v135, v136, tmp153})
															tmp147 = tmp154
														} else {
															var tmp155 any
															tmp156 := checkDerefVar(glojure_DOT_core__EQ_)
															tmp157 := lang.Apply(tmp156, []any{v146, "syms"})
															if lang.IsTruthy(tmp157) {
																tmp158 := checkDerefVar(glojure_DOT_core_assoc)
																var tmp159 lang.FnFunc
																tmp159 = lang.NewFnFunc(func(args ...any) any {
																	if len(args) != 1 {
																		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
																	}
																	v160 := args[0]
																	_ = v160
																	tmp161 := checkDerefVar(glojure_DOT_core_list)
																	tmp162 := checkDerefVar(glojure_DOT_core_symbol)
																	var tmp163 any
																	{ // let
																		// let binding "or__0__auto__"
																		var v164 any = v143
																		_ = v164
																		var tmp165 any
																		if lang.IsTruthy(v164) {
																			tmp165 = v164
																		} else {
																			tmp166 := checkDerefVar(glojure_DOT_core_namespace)
																			tmp167 := lang.Apply(tmp166, []any{v160})
																			tmp165 = tmp167
																		}
																		tmp163 = tmp165
																	} // end let
																	tmp164 := checkDerefVar(glojure_DOT_core_name)
																	tmp165 := lang.Apply(tmp164, []any{v160})
																	tmp166 := lang.Apply(tmp162, []any{tmp163, tmp165})
																	tmp167 := lang.Apply(tmp161, []any{lang.NewSymbol("quote"), tmp166})
																	return tmp167
																})
																tmp160 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4461), lang.NewKeyword("column"), int(93), lang.NewKeyword("end-line"), int(4461), lang.NewKeyword("end-column"), int(148))
																tmp161, err := lang.WithMeta(tmp159, tmp160.(lang.IPersistentMap))
																if err != nil {
																	panic(err)
																}
																tmp162 := lang.Apply(tmp158, []any{v135, v136, tmp161})
																tmp155 = tmp162
															} else {
																var tmp163 any
																tmp164 := checkDerefVar(glojure_DOT_core__EQ_)
																tmp165 := lang.Apply(tmp164, []any{v146, "strs"})
																if lang.IsTruthy(tmp165) {
																	tmp166 := checkDerefVar(glojure_DOT_core_assoc)
																	tmp167 := checkDerefVar(glojure_DOT_core_str)
																	tmp168 := lang.Apply(tmp166, []any{v135, v136, tmp167})
																	tmp163 = tmp168
																} else {
																	var tmp169 any
																	if lang.IsTruthy(lang.NewKeyword("else")) {
																		tmp169 = v135
																	} else {
																	}
																	tmp163 = tmp169
																}
																tmp155 = tmp163
															}
															tmp147 = tmp155
														}
														tmp140 = tmp147
													} // end let
													tmp137 = tmp140
												} else {
													tmp137 = v135
												}
												return tmp137
											})
											tmp135 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4456), lang.NewKeyword("column"), int(45), lang.NewKeyword("end-line"), int(4464), lang.NewKeyword("end-column"), int(60))
											tmp136, err := lang.WithMeta(tmp134, tmp135.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp137 := lang.NewMap()
											tmp138 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4465), lang.NewKeyword("column"), int(45), lang.NewKeyword("end-line"), int(4465), lang.NewKeyword("end-column"), int(46))
											tmp139, err := lang.WithMeta(tmp137, tmp138.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp140 := checkDerefVar(glojure_DOT_core_keys)
											tmp141 := lang.Apply(tmp140, []any{v20})
											tmp142 := lang.Apply(tmp133, []any{tmp136, tmp139, tmp141})
											var v143 any = tmp142
											_ = v143
											tmp144 := checkDerefVar(glojure_DOT_core_reduce1)
											var tmp145 lang.FnFunc
											tmp145 = lang.NewFnFunc(func(args ...any) any {
												if len(args) != 2 {
													panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
												}
												v146 := args[0]
												_ = v146
												v147 := args[1]
												_ = v147
												tmp148 := checkDerefVar(glojure_DOT_core_reduce1)
												var tmp149 lang.FnFunc
												tmp149 = lang.NewFnFunc(func(args ...any) any {
													if len(args) != 2 {
														panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
													}
													v150 := args[0]
													_ = v150
													v151 := args[1]
													_ = v151
													tmp152 := checkDerefVar(glojure_DOT_core_assoc)
													tmp153 := checkDerefVar(glojure_DOT_core_val)
													tmp154 := lang.Apply(tmp153, []any{v147})
													tmp155 := lang.Apply(tmp154, []any{v151})
													tmp156 := lang.Apply(tmp152, []any{v150, v151, tmp155})
													return tmp156
												})
												tmp150 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4469), lang.NewKeyword("column"), int(52), lang.NewKeyword("end-line"), int(4469), lang.NewKeyword("end-column"), int(82))
												tmp151, err := lang.WithMeta(tmp149, tmp150.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp152 := checkDerefVar(glojure_DOT_core_dissoc)
												tmp153 := checkDerefVar(glojure_DOT_core_key)
												tmp154 := lang.Apply(tmp153, []any{v147})
												tmp155 := lang.Apply(tmp152, []any{v146, tmp154})
												tmp156 := checkDerefVar(glojure_DOT_core_key)
												tmp157 := lang.Apply(tmp156, []any{v147})
												tmp158 := lang.Apply(tmp157, []any{v146})
												tmp159 := lang.Apply(tmp148, []any{tmp151, tmp155, tmp158})
												return tmp159
											})
											tmp146 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4468), lang.NewKeyword("column"), int(41), lang.NewKeyword("end-line"), int(4471), lang.NewKeyword("end-column"), int(70))
											tmp147, err := lang.WithMeta(tmp145, tmp146.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp148 := checkDerefVar(glojure_DOT_core_dissoc)
											tmp149 := lang.Apply(tmp148, []any{v20, lang.NewKeyword("as"), lang.NewKeyword("or")})
											tmp150 := lang.Apply(tmp144, []any{tmp147, tmp149, v143})
											tmp132 = tmp150
										} // end let
										var v133 any = tmp132
										_ = v133
										for {
											var tmp134 any
											tmp135 := checkDerefVar(glojure_DOT_core_seq)
											tmp136 := lang.Apply(tmp135, []any{v133})
											if lang.IsTruthy(tmp136) {
												var tmp137 any
												{ // let
													// let binding "bb"
													tmp138 := checkDerefVar(glojure_DOT_core_key)
													tmp139 := checkDerefVar(glojure_DOT_core_first)
													tmp140 := lang.Apply(tmp139, []any{v133})
													tmp141 := lang.Apply(tmp138, []any{tmp140})
													var v142 any = tmp141
													_ = v142
													// let binding "bk"
													tmp143 := checkDerefVar(glojure_DOT_core_val)
													tmp144 := checkDerefVar(glojure_DOT_core_first)
													tmp145 := lang.Apply(tmp144, []any{v133})
													tmp146 := lang.Apply(tmp143, []any{tmp145})
													var v147 any = tmp146
													_ = v147
													// let binding "local"
													var tmp148 any
													tmp149 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
													tmp150 := reflect.TypeOf((*lang.Named)(nil)).Elem()
													tmp151 := lang.Apply(tmp149, []any{tmp150, v142})
													if lang.IsTruthy(tmp151) {
														tmp152 := checkDerefVar(glojure_DOT_core_with_meta)
														tmp153 := checkDerefVar(glojure_DOT_core_symbol)
														tmp154 := checkDerefVar(glojure_DOT_core_name)
														tmp155 := lang.Apply(tmp154, []any{v142})
														tmp156 := lang.Apply(tmp153, []any{nil, tmp155})
														tmp157 := checkDerefVar(glojure_DOT_core_meta)
														tmp158 := lang.Apply(tmp157, []any{v142})
														tmp159 := lang.Apply(tmp152, []any{tmp156, tmp158})
														tmp148 = tmp159
													} else {
														tmp148 = v142
													}
													var v160 any = tmp148
													_ = v160
													// let binding "bv"
													var tmp161 any
													tmp162 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
													tmp163 := lang.Apply(tmp162, []any{v33, v160})
													if lang.IsTruthy(tmp163) {
														tmp164 := checkDerefVar(glojure_DOT_core_list)
														tmp165 := lang.Apply(v33, []any{v160})
														tmp166 := lang.Apply(tmp164, []any{lang.NewSymbol("glojure.core/get"), v25, v147, tmp165})
														tmp161 = tmp166
													} else {
														tmp167 := checkDerefVar(glojure_DOT_core_list)
														tmp168 := lang.Apply(tmp167, []any{lang.NewSymbol("glojure.core/get"), v25, v147})
														tmp161 = tmp168
													}
													var v169 any = tmp161
													_ = v169
													var tmp171 any
													tmp172 := checkDerefVar(glojure_DOT_core_ident_QMARK_)
													tmp173 := lang.Apply(tmp172, []any{v142})
													if lang.IsTruthy(tmp173) {
														tmp174 := checkDerefVar(glojure_DOT_core_conj)
														tmp175 := lang.Apply(tmp174, []any{v131, v160, v169})
														tmp171 = tmp175
													} else {
														tmp176 := lang.Apply(v9, []any{v131, v142, v169})
														tmp171 = tmp176
													}
													var tmp170 any = tmp171
													tmp178 := checkDerefVar(glojure_DOT_core_next)
													tmp179 := lang.Apply(tmp178, []any{v133})
													var tmp177 any = tmp179
													v131 = tmp170
													v133 = tmp177
													continue
												} // end let
												tmp134 = tmp137
											} else {
												tmp134 = v131
											}
											tmp34 = tmp134
											break
										}
									} // end let
									tmp22 = tmp34
								} // end let
								return tmp22
							})
							tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4440), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(4485), lang.NewKeyword("end-column"), int(34))
							tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v21 any = tmp20
							_ = v21
							var tmp22 any
							tmp23 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
							tmp24 := lang.Apply(tmp23, []any{v11})
							if lang.IsTruthy(tmp24) {
								tmp25 := checkDerefVar(glojure_DOT_core_conj)
								tmp26 := checkDerefVar(glojure_DOT_core_conj)
								tmp27 := lang.Apply(tmp26, []any{v10, v11})
								tmp28 := lang.Apply(tmp25, []any{tmp27, v12})
								tmp22 = tmp28
							} else {
								var tmp29 any
								tmp30 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
								tmp31 := lang.Apply(tmp30, []any{v11})
								if lang.IsTruthy(tmp31) {
									tmp32 := lang.Apply(v17, []any{v10, v11, v12})
									tmp29 = tmp32
								} else {
									var tmp33 any
									tmp34 := checkDerefVar(glojure_DOT_core_map_QMARK_)
									tmp35 := lang.Apply(tmp34, []any{v11})
									if lang.IsTruthy(tmp35) {
										tmp36 := lang.Apply(v21, []any{v10, v11, v12})
										tmp33 = tmp36
									} else {
										var tmp37 any
										if lang.IsTruthy(lang.NewKeyword("else")) {
											tmp38 := checkDerefVar(glojure_DOT_core_str)
											tmp39 := lang.Apply(tmp38, []any{"Unsupported binding form: ", v11})
											tmp40 := lang.Apply(errors8.New, []any{tmp39})
											panic(tmp40)
										} else {
										}
										tmp33 = tmp37
									}
									tmp29 = tmp33
								}
								tmp22 = tmp29
							}
							tmp13 = tmp22
						} // end let
						return tmp13
					})
					v9 = tmp8
					_ = v9
				}
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4402), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(4490), lang.NewKeyword("end-column"), int(82))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v11 any = tmp10
				_ = v11
				// let binding "process-entry"
				var tmp12 lang.FnFunc
				tmp12 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v13 := args[0]
					_ = v13
					v14 := args[1]
					_ = v14
					tmp15 := checkDerefVar(glojure_DOT_core_first)
					tmp16 := lang.Apply(tmp15, []any{v14})
					tmp17 := checkDerefVar(glojure_DOT_core_second)
					tmp18 := lang.Apply(tmp17, []any{v14})
					tmp19 := lang.Apply(v11, []any{v13, tmp16, tmp18})
					return tmp19
				})
				tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4491), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(4491), lang.NewKeyword("end-column"), int(66))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v15 any = tmp14
				_ = v15
				var tmp16 any
				tmp17 := checkDerefVar(glojure_DOT_core_every_QMARK_)
				tmp18 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
				tmp19 := checkDerefVar(glojure_DOT_core_map)
				tmp20 := checkDerefVar(glojure_DOT_core_first)
				tmp21 := lang.Apply(tmp19, []any{tmp20, v7})
				tmp22 := lang.Apply(tmp17, []any{tmp18, tmp21})
				if lang.IsTruthy(tmp22) {
					tmp16 = v3
				} else {
					tmp23 := checkDerefVar(glojure_DOT_core_reduce1)
					tmp24 := lang.NewVector()
					tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4494), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(4494), lang.NewKeyword("end-column"), int(31))
					tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp27 := lang.Apply(tmp23, []any{v15, tmp26, v7})
					tmp16 = tmp27
				}
				tmp4 = tmp16
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// disj
	{
		tmp0 := lang.NewSymbol("disj").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("set")), lang.NewVector(lang.NewSymbol("set"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("set"), lang.NewSymbol("key"), lang.NewSymbol("&"), lang.NewSymbol("ks"))), lang.NewKeyword("doc"), "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1514), lang.NewKeyword("end-line"), int(1514))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				if lang.IsTruthy(v3) {
					tmp6, _ := lang.FieldOrMethod(v3, "Disjoin")
					if reflect.TypeOf(tmp6).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
					}
					tmp7 := lang.Apply(tmp6, []any{v4})
					tmp5 = tmp7
				} else {
				}
				return tmp5
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_304:
				var tmp6 any
				if lang.IsTruthy(v3) {
					var tmp7 any
					{ // let
						// let binding "ret"
						tmp8 := checkDerefVar(glojure_DOT_core_disj)
						tmp9 := lang.Apply(tmp8, []any{v3, v4})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v5) {
							var tmp12 any = v10
							tmp14 := checkDerefVar(glojure_DOT_core_first)
							tmp15 := lang.Apply(tmp14, []any{v5})
							var tmp13 any = tmp15
							tmp17 := checkDerefVar(glojure_DOT_core_next)
							tmp18 := lang.Apply(tmp17, []any{v5})
							var tmp16 any = tmp18
							v3 = tmp12
							v4 = tmp13
							v5 = tmp16
							goto recur_loop_304
						} else {
							tmp11 = v10
						}
						tmp7 = tmp11
					} // end let
					tmp6 = tmp7
				} else {
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// disj!
	{
		tmp0 := lang.NewSymbol("disj!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("set")), lang.NewVector(lang.NewSymbol("set"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("set"), lang.NewSymbol("key"), lang.NewSymbol("&"), lang.NewSymbol("ks"))), lang.NewKeyword("doc"), "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3401), lang.NewKeyword("end-line"), int(3401))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "Disjoin")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_615:
				var tmp6 any
				{ // let
					// let binding "ret"
					tmp7, _ := lang.FieldOrMethod(v3, "Disjoin")
					if reflect.TypeOf(tmp7).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
					}
					tmp8 := lang.Apply(tmp7, []any{v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v5) {
						var tmp11 any = v9
						tmp13 := checkDerefVar(glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v5})
						var tmp12 any = tmp14
						tmp16 := checkDerefVar(glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v5})
						var tmp15 any = tmp17
						v3 = tmp11
						v4 = tmp12
						v5 = tmp15
						goto recur_loop_615
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dissoc
	{
		tmp0 := lang.NewSymbol("dissoc").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map")), lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"), lang.NewSymbol("&"), lang.NewSymbol("ks"))), lang.NewKeyword("doc"), "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1500), lang.NewKeyword("end-line"), int(1500))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(runtime7.RT, "Dissoc")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Dissoc is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_301:
				var tmp6 any
				{ // let
					// let binding "ret"
					tmp7 := checkDerefVar(glojure_DOT_core_dissoc)
					tmp8 := lang.Apply(tmp7, []any{v3, v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v5) {
						var tmp11 any = v9
						tmp13 := checkDerefVar(glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v5})
						var tmp12 any = tmp14
						tmp16 := checkDerefVar(glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v5})
						var tmp15 any = tmp17
						v3 = tmp11
						v4 = tmp12
						v5 = tmp15
						goto recur_loop_301
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dissoc!
	{
		tmp0 := lang.NewSymbol("dissoc!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"), lang.NewSymbol("&"), lang.NewSymbol("ks"))), lang.NewKeyword("doc"), "Returns a transient map that doesn't contain a mapping for key(s).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3382), lang.NewKeyword("end-line"), int(3382))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "without")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("without is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_611:
				var tmp6 any
				{ // let
					// let binding "ret"
					tmp7, _ := lang.FieldOrMethod(v3, "without")
					if reflect.TypeOf(tmp7).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("without is not a function")))
					}
					tmp8 := lang.Apply(tmp7, []any{v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v5) {
						var tmp11 any = v9
						tmp13 := checkDerefVar(glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v5})
						var tmp12 any = tmp14
						tmp16 := checkDerefVar(glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v5})
						var tmp15 any = tmp17
						v3 = tmp11
						v4 = tmp12
						v5 = tmp15
						goto recur_loop_611
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// distinct
	{
		tmp0 := lang.NewSymbol("distinct").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5053), lang.NewKeyword("end-line"), int(5053))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "seen"
						tmp6 := checkDerefVar(glojure_DOT_core_volatile_BANG_)
						tmp7 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
						tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5060), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(5060), lang.NewKeyword("end-column"), int(30))
						tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp10 := lang.Apply(tmp6, []any{tmp9})
						var v11 any = tmp10
						_ = v11
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp13 := lang.Apply(v4, nil)
								return tmp13
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := lang.Apply(v4, []any{v13})
								return tmp14
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								var tmp15 any
								tmp16 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
								tmp17 := checkDerefVar(glojure_DOT_core_deref)
								tmp18 := lang.Apply(tmp17, []any{v11})
								tmp19 := lang.Apply(tmp16, []any{tmp18, v14})
								if lang.IsTruthy(tmp19) {
									tmp15 = v13
								} else {
									tmp20 := checkDerefVar(glojure_DOT_core_conj)
									tmp21, ok := lang.FieldOrMethod(v11, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Deref")))
									}
									var tmp22 any
									switch reflect.TypeOf(tmp21).Kind() {
									case reflect.Func:
										tmp22 = lang.Apply(tmp21, nil)
									default:
										tmp22 = tmp21
									}
									tmp23 := lang.Apply(tmp20, []any{tmp22, v14})
									tmp24, _ := lang.FieldOrMethod(v11, "reset")
									if reflect.TypeOf(tmp24).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp25 := lang.Apply(tmp24, []any{tmp23})
									_ = tmp25
									tmp26 := lang.Apply(v4, []any{v13, v14})
									tmp15 = tmp26
								}
								return tmp15
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5061), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(5068), lang.NewKeyword("end-column"), int(37))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp14
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5059), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(5068), lang.NewKeyword("end-column"), int(39))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "step"
					var tmp5 lang.FnFunc
					{ // function step
						var v6 lang.FnFunc
						tmp5 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 lang.FnFunc
							tmp9 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								var tmp10 lang.FnFunc
								tmp10 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 2 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v11 := args[0]
									_ = v11
									v12 := args[1]
									_ = v12
								recur_loop_877:
									var tmp13 any
									{ // let
										// let binding "vec__62"
										var v14 any = v11
										_ = v14
										// let binding "f"
										tmp15 := checkDerefVar(glojure_DOT_core_nth)
										tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
										var v17 any = tmp16
										_ = v17
										// let binding "xs"
										var v18 any = v14
										_ = v18
										var tmp19 any
										{ // let
											// let binding "temp__0__auto__"
											tmp20 := checkDerefVar(glojure_DOT_core_seq)
											tmp21 := lang.Apply(tmp20, []any{v18})
											var v22 any = tmp21
											_ = v22
											var tmp23 any
											if lang.IsTruthy(v22) {
												var tmp24 any
												{ // let
													// let binding "s"
													var v25 any = v22
													_ = v25
													var tmp26 any
													tmp27 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
													tmp28 := lang.Apply(tmp27, []any{v12, v17})
													if lang.IsTruthy(tmp28) {
														tmp30 := checkDerefVar(glojure_DOT_core_rest)
														tmp31 := lang.Apply(tmp30, []any{v25})
														var tmp29 any = tmp31
														var tmp32 any = v12
														v11 = tmp29
														v12 = tmp32
														goto recur_loop_877
													} else {
														tmp33 := checkDerefVar(glojure_DOT_core_cons)
														tmp34 := checkDerefVar(glojure_DOT_core_rest)
														tmp35 := lang.Apply(tmp34, []any{v25})
														tmp36 := checkDerefVar(glojure_DOT_core_conj)
														tmp37 := lang.Apply(tmp36, []any{v12, v17})
														tmp38 := lang.Apply(v6, []any{tmp35, tmp37})
														tmp39 := lang.Apply(tmp33, []any{v17, tmp38})
														tmp26 = tmp39
													}
													tmp24 = tmp26
												} // end let
												tmp23 = tmp24
											} else {
											}
											tmp19 = tmp23
										} // end let
										tmp13 = tmp19
									} // end let
									return tmp13
								})
								tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5072), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(5076), lang.NewKeyword("end-column"), int(66))
								tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp13 := lang.Apply(tmp12, []any{v7, v8})
								return tmp13
							})
							tmp10 := lang.Apply(lang.NewLazySeq, []any{tmp9})
							return tmp10
						})
						v6 = tmp5
						_ = v6
					}
					tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5070), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(5077), lang.NewKeyword("end-column"), int(29))
					tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v8 any = tmp7
					_ = v8
					tmp9 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5078), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(5078), lang.NewKeyword("end-column"), int(19))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 := lang.Apply(v8, []any{v3, tmp11})
					tmp4 = tmp12
				} // end let
				return tmp4
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// distinct?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("distinct?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Returns true if no two of the arguments are =", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5664), lang.NewKeyword("end-line"), int(5664))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_not)
				tmp7 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp8 := lang.Apply(tmp7, []any{v4, v5})
				tmp9 := lang.Apply(tmp6, []any{tmp8})
				return tmp9
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_not_EQ_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					{ // let
						// let binding "s"
						tmp11 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{v4, v5}))
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5673), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(5673), lang.NewKeyword("end-column"), int(20))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v14 any = tmp13
						_ = v14
						// let binding "G__99"
						var v15 any = v6
						_ = v15
						// let binding "vec__100"
						var v16 any = v15
						_ = v16
						// let binding "seq__101"
						tmp17 := checkDerefVar(glojure_DOT_core_seq)
						tmp18 := lang.Apply(tmp17, []any{v16})
						var v19 any = tmp18
						_ = v19
						// let binding "first__102"
						tmp20 := checkDerefVar(glojure_DOT_core_first)
						tmp21 := lang.Apply(tmp20, []any{v19})
						var v22 any = tmp21
						_ = v22
						// let binding "seq__101"
						tmp23 := checkDerefVar(glojure_DOT_core_next)
						tmp24 := lang.Apply(tmp23, []any{v19})
						var v25 any = tmp24
						_ = v25
						// let binding "x"
						var v26 any = v22
						_ = v26
						// let binding "etc"
						var v27 any = v25
						_ = v27
						// let binding "xs"
						var v28 any = v16
						_ = v28
						var tmp29 any
						{ // let
							// let binding "s"
							var v30 any = v14
							_ = v30
							// let binding "G__99"
							var v31 any = v15
							_ = v31
							for {
								var tmp32 any
								{ // let
									// let binding "s"
									var v33 any = v30
									_ = v33
									// let binding "vec__103"
									var v34 any = v31
									_ = v34
									// let binding "seq__104"
									tmp35 := checkDerefVar(glojure_DOT_core_seq)
									tmp36 := lang.Apply(tmp35, []any{v34})
									var v37 any = tmp36
									_ = v37
									// let binding "first__105"
									tmp38 := checkDerefVar(glojure_DOT_core_first)
									tmp39 := lang.Apply(tmp38, []any{v37})
									var v40 any = tmp39
									_ = v40
									// let binding "seq__104"
									tmp41 := checkDerefVar(glojure_DOT_core_next)
									tmp42 := lang.Apply(tmp41, []any{v37})
									var v43 any = tmp42
									_ = v43
									// let binding "x"
									var v44 any = v40
									_ = v44
									// let binding "etc"
									var v45 any = v43
									_ = v45
									// let binding "xs"
									var v46 any = v34
									_ = v46
									var tmp47 any
									if lang.IsTruthy(v46) {
										var tmp48 any
										tmp49 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
										tmp50 := lang.Apply(tmp49, []any{v33, v44})
										if lang.IsTruthy(tmp50) {
											tmp48 = false
										} else {
											tmp52 := checkDerefVar(glojure_DOT_core_conj)
											tmp53 := lang.Apply(tmp52, []any{v33, v44})
											var tmp51 any = tmp53
											var tmp54 any = v45
											v30 = tmp51
											v31 = tmp54
											continue
										}
										tmp47 = tmp48
									} else {
										tmp47 = true
									}
									tmp32 = tmp47
								} // end let
								tmp29 = tmp32
								break
							}
						} // end let
						tmp10 = tmp29
					} // end let
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doall
	{
		tmp0 := lang.NewSymbol("doall").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3131), lang.NewKeyword("end-line"), int(3131))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_dorun)
				tmp5 := lang.Apply(tmp4, []any{v3})
				_ = tmp5
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_dorun)
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				_ = tmp6
				return v4
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dorun
	{
		tmp0 := lang.NewSymbol("dorun").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3116), lang.NewKeyword("end-line"), int(3116))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
			recur_loop_579:
				var tmp4 any
				{ // let
					// let binding "temp__0__auto__"
					tmp5 := checkDerefVar(glojure_DOT_core_seq)
					tmp6 := lang.Apply(tmp5, []any{v3})
					var v7 any = tmp6
					_ = v7
					var tmp8 any
					if lang.IsTruthy(v7) {
						var tmp9 any
						{ // let
							// let binding "s"
							var v10 any = v7
							_ = v10
							tmp12 := checkDerefVar(glojure_DOT_core_next)
							tmp13 := lang.Apply(tmp12, []any{v10})
							var tmp11 any = tmp13
							v3 = tmp11
							goto recur_loop_579
						} // end let
						tmp8 = tmp9
					} else {
					}
					tmp4 = tmp8
				} // end let
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
			recur_loop_580:
				var tmp5 any
				var tmp6 any
				{ // let
					// let binding "and__0__auto__"
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := lang.Apply(tmp7, []any{v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp11 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v3})
						tmp10 = tmp12
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				if lang.IsTruthy(tmp6) {
					tmp8 := checkDerefVar(glojure_DOT_core_dec)
					tmp9 := lang.Apply(tmp8, []any{v3})
					var tmp7 any = tmp9
					tmp11 := checkDerefVar(glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v4})
					var tmp10 any = tmp12
					v3 = tmp7
					v4 = tmp10
					goto recur_loop_580
				} else {
				}
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doseq
	{
		tmp0 := lang.NewSymbol("doseq").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("seq-exprs"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3209), lang.NewKeyword("end-line"), int(3209))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(glojure_DOT_core_str)
					tmp11 := checkDerefVar(glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(lang.NewKeyword("line"), []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "step"
					var tmp34 lang.FnFunc
					{ // function step
						var v35 lang.FnFunc
						tmp34 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v36 := args[0]
							_ = v36
							v37 := args[1]
							_ = v37
							var tmp38 any
							tmp39 := checkDerefVar(glojure_DOT_core_not)
							tmp40 := lang.Apply(tmp39, []any{v37})
							if lang.IsTruthy(tmp40) {
								tmp41 := checkDerefVar(glojure_DOT_core_seq)
								tmp42 := checkDerefVar(glojure_DOT_core_concat)
								tmp43 := checkDerefVar(glojure_DOT_core_list)
								tmp44 := lang.Apply(tmp43, []any{lang.NewSymbol("do")})
								tmp45 := lang.Apply(tmp42, []any{tmp44, v6})
								tmp46 := lang.Apply(tmp41, []any{tmp45})
								tmp47 := lang.NewVector(true, tmp46)
								tmp48 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3220), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(3220), lang.NewKeyword("end-column"), int(36))
								tmp49, err := lang.WithMeta(tmp47, tmp48.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp38 = tmp49
							} else {
								var tmp50 any
								{ // let
									// let binding "k"
									tmp51 := checkDerefVar(glojure_DOT_core_first)
									tmp52 := lang.Apply(tmp51, []any{v37})
									var v53 any = tmp52
									_ = v53
									// let binding "v"
									tmp54 := checkDerefVar(glojure_DOT_core_second)
									tmp55 := lang.Apply(tmp54, []any{v37})
									var v56 any = tmp55
									_ = v56
									var tmp57 any
									tmp58 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
									tmp59 := lang.Apply(tmp58, []any{v53})
									if lang.IsTruthy(tmp59) {
										var tmp60 any
										{ // let
											// let binding "steppair"
											tmp61 := checkDerefVar(glojure_DOT_core_nnext)
											tmp62 := lang.Apply(tmp61, []any{v37})
											tmp63 := lang.Apply(v35, []any{v36, tmp62})
											var v64 any = tmp63
											_ = v64
											// let binding "needrec"
											tmp65 := lang.Apply(v64, []any{int64(0)})
											var v66 any = tmp65
											_ = v66
											// let binding "subform"
											tmp67 := lang.Apply(v64, []any{int64(1)})
											var v68 any = tmp67
											_ = v68
											var tmp69 any
											tmp70 := checkDerefVar(glojure_DOT_core__EQ_)
											tmp71 := lang.Apply(tmp70, []any{v53, lang.NewKeyword("let")})
											if lang.IsTruthy(tmp71) {
												tmp72 := checkDerefVar(glojure_DOT_core_seq)
												tmp73 := checkDerefVar(glojure_DOT_core_concat)
												tmp74 := checkDerefVar(glojure_DOT_core_list)
												tmp75 := lang.Apply(tmp74, []any{lang.NewSymbol("glojure.core/let")})
												tmp76 := checkDerefVar(glojure_DOT_core_list)
												tmp77 := lang.Apply(tmp76, []any{v56})
												tmp78 := checkDerefVar(glojure_DOT_core_list)
												tmp79 := lang.Apply(tmp78, []any{v68})
												tmp80 := lang.Apply(tmp73, []any{tmp75, tmp77, tmp79})
												tmp81 := lang.Apply(tmp72, []any{tmp80})
												tmp82 := lang.NewVector(v66, tmp81)
												tmp83 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3228), lang.NewKeyword("column"), int(37), lang.NewKeyword("end-line"), int(3228), lang.NewKeyword("end-column"), int(64))
												tmp84, err := lang.WithMeta(tmp82, tmp83.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp69 = tmp84
											} else {
												var tmp85 any
												tmp86 := checkDerefVar(glojure_DOT_core__EQ_)
												tmp87 := lang.Apply(tmp86, []any{v53, lang.NewKeyword("while")})
												if lang.IsTruthy(tmp87) {
													tmp88 := checkDerefVar(glojure_DOT_core_seq)
													tmp89 := checkDerefVar(glojure_DOT_core_concat)
													tmp90 := checkDerefVar(glojure_DOT_core_list)
													tmp91 := lang.Apply(tmp90, []any{lang.NewSymbol("glojure.core/when")})
													tmp92 := checkDerefVar(glojure_DOT_core_list)
													tmp93 := lang.Apply(tmp92, []any{v56})
													tmp94 := checkDerefVar(glojure_DOT_core_list)
													tmp95 := lang.Apply(tmp94, []any{v68})
													var tmp96 any
													if lang.IsTruthy(v66) {
														tmp97 := lang.NewVector(v36)
														tmp98 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3231), lang.NewKeyword("column"), int(65), lang.NewKeyword("end-line"), int(3231), lang.NewKeyword("end-column"), int(73))
														tmp99, err := lang.WithMeta(tmp97, tmp98.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp96 = tmp99
													} else {
													}
													tmp100 := lang.Apply(tmp89, []any{tmp91, tmp93, tmp95, tmp96})
													tmp101 := lang.Apply(tmp88, []any{tmp100})
													tmp102 := lang.NewVector(false, tmp101)
													tmp103 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3229), lang.NewKeyword("column"), int(39), lang.NewKeyword("end-line"), int(3231), lang.NewKeyword("end-column"), int(76))
													tmp104, err := lang.WithMeta(tmp102, tmp103.(lang.IPersistentMap))
													if err != nil {
														panic(err)
													}
													tmp85 = tmp104
												} else {
													var tmp105 any
													tmp106 := checkDerefVar(glojure_DOT_core__EQ_)
													tmp107 := lang.Apply(tmp106, []any{v53, lang.NewKeyword("when")})
													if lang.IsTruthy(tmp107) {
														tmp108 := checkDerefVar(glojure_DOT_core_seq)
														tmp109 := checkDerefVar(glojure_DOT_core_concat)
														tmp110 := checkDerefVar(glojure_DOT_core_list)
														tmp111 := lang.Apply(tmp110, []any{lang.NewSymbol("if")})
														tmp112 := checkDerefVar(glojure_DOT_core_list)
														tmp113 := lang.Apply(tmp112, []any{v56})
														tmp114 := checkDerefVar(glojure_DOT_core_list)
														tmp115 := checkDerefVar(glojure_DOT_core_seq)
														tmp116 := checkDerefVar(glojure_DOT_core_concat)
														tmp117 := checkDerefVar(glojure_DOT_core_list)
														tmp118 := lang.Apply(tmp117, []any{lang.NewSymbol("do")})
														tmp119 := checkDerefVar(glojure_DOT_core_list)
														tmp120 := lang.Apply(tmp119, []any{v68})
														var tmp121 any
														if lang.IsTruthy(v66) {
															tmp122 := lang.NewVector(v36)
															tmp123 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3235), lang.NewKeyword("column"), int(66), lang.NewKeyword("end-line"), int(3235), lang.NewKeyword("end-column"), int(74))
															tmp124, err := lang.WithMeta(tmp122, tmp123.(lang.IPersistentMap))
															if err != nil {
																panic(err)
															}
															tmp121 = tmp124
														} else {
														}
														tmp125 := lang.Apply(tmp116, []any{tmp118, tmp120, tmp121})
														tmp126 := lang.Apply(tmp115, []any{tmp125})
														tmp127 := lang.Apply(tmp114, []any{tmp126})
														tmp128 := checkDerefVar(glojure_DOT_core_list)
														tmp129 := lang.Apply(tmp128, []any{v36})
														tmp130 := lang.Apply(tmp109, []any{tmp111, tmp113, tmp127, tmp129})
														tmp131 := lang.Apply(tmp108, []any{tmp130})
														tmp132 := lang.NewVector(false, tmp131)
														tmp133 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3232), lang.NewKeyword("column"), int(38), lang.NewKeyword("end-line"), int(3236), lang.NewKeyword("end-column"), int(57))
														tmp134, err := lang.WithMeta(tmp132, tmp133.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp105 = tmp134
													} else {
													}
													tmp85 = tmp105
												}
												tmp69 = tmp85
											}
											tmp60 = tmp69
										} // end let
										tmp57 = tmp60
									} else {
										var tmp61 any
										{ // let
											// let binding "seq-"
											tmp62 := checkDerefVar(glojure_DOT_core_gensym)
											tmp63 := lang.Apply(tmp62, []any{"seq_"})
											var v64 any = tmp63
											_ = v64
											// let binding "chunk-"
											tmp65 := checkDerefVar(glojure_DOT_core_with_meta)
											tmp66 := checkDerefVar(glojure_DOT_core_gensym)
											tmp67 := lang.Apply(tmp66, []any{"chunk_"})
											tmp68 := lang.NewMap(lang.NewKeyword("tag"), lang.NewSymbol("glojure.lang.IChunk"))
											tmp69 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3239), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(3239), lang.NewKeyword("end-column"), int(72))
											tmp70, err := lang.WithMeta(tmp68, tmp69.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp71 := lang.Apply(tmp65, []any{tmp67, tmp70})
											var v72 any = tmp71
											_ = v72
											// let binding "count-"
											tmp73 := checkDerefVar(glojure_DOT_core_gensym)
											tmp74 := lang.Apply(tmp73, []any{"count_"})
											var v75 any = tmp74
											_ = v75
											// let binding "i-"
											tmp76 := checkDerefVar(glojure_DOT_core_gensym)
											tmp77 := lang.Apply(tmp76, []any{"i_"})
											var v78 any = tmp77
											_ = v78
											// let binding "recform"
											tmp79 := checkDerefVar(glojure_DOT_core_seq)
											tmp80 := checkDerefVar(glojure_DOT_core_concat)
											tmp81 := checkDerefVar(glojure_DOT_core_list)
											tmp82 := lang.Apply(tmp81, []any{lang.NewSymbol("recur")})
											tmp83 := checkDerefVar(glojure_DOT_core_list)
											tmp84 := checkDerefVar(glojure_DOT_core_seq)
											tmp85 := checkDerefVar(glojure_DOT_core_concat)
											tmp86 := checkDerefVar(glojure_DOT_core_list)
											tmp87 := lang.Apply(tmp86, []any{lang.NewSymbol("glojure.core/next")})
											tmp88 := checkDerefVar(glojure_DOT_core_list)
											tmp89 := lang.Apply(tmp88, []any{v64})
											tmp90 := lang.Apply(tmp85, []any{tmp87, tmp89})
											tmp91 := lang.Apply(tmp84, []any{tmp90})
											tmp92 := lang.Apply(tmp83, []any{tmp91})
											tmp93 := checkDerefVar(glojure_DOT_core_list)
											tmp94 := lang.Apply(tmp93, []any{nil})
											tmp95 := checkDerefVar(glojure_DOT_core_list)
											tmp96 := lang.Apply(tmp95, []any{int64(0)})
											tmp97 := checkDerefVar(glojure_DOT_core_list)
											tmp98 := lang.Apply(tmp97, []any{int64(0)})
											tmp99 := lang.Apply(tmp80, []any{tmp82, tmp92, tmp94, tmp96, tmp98})
											tmp100 := lang.Apply(tmp79, []any{tmp99})
											var v101 any = tmp100
											_ = v101
											// let binding "steppair"
											tmp102 := checkDerefVar(glojure_DOT_core_nnext)
											tmp103 := lang.Apply(tmp102, []any{v37})
											tmp104 := lang.Apply(v35, []any{v101, tmp103})
											var v105 any = tmp104
											_ = v105
											// let binding "needrec"
											tmp106 := lang.Apply(v105, []any{int64(0)})
											var v107 any = tmp106
											_ = v107
											// let binding "subform"
											tmp108 := lang.Apply(v105, []any{int64(1)})
											var v109 any = tmp108
											_ = v109
											// let binding "recform-chunk"
											tmp110 := checkDerefVar(glojure_DOT_core_seq)
											tmp111 := checkDerefVar(glojure_DOT_core_concat)
											tmp112 := checkDerefVar(glojure_DOT_core_list)
											tmp113 := lang.Apply(tmp112, []any{lang.NewSymbol("recur")})
											tmp114 := checkDerefVar(glojure_DOT_core_list)
											tmp115 := lang.Apply(tmp114, []any{v64})
											tmp116 := checkDerefVar(glojure_DOT_core_list)
											tmp117 := lang.Apply(tmp116, []any{v72})
											tmp118 := checkDerefVar(glojure_DOT_core_list)
											tmp119 := lang.Apply(tmp118, []any{v75})
											tmp120 := checkDerefVar(glojure_DOT_core_list)
											tmp121 := checkDerefVar(glojure_DOT_core_seq)
											tmp122 := checkDerefVar(glojure_DOT_core_concat)
											tmp123 := checkDerefVar(glojure_DOT_core_list)
											tmp124 := lang.Apply(tmp123, []any{lang.NewSymbol("glojure.core/unchecked-inc")})
											tmp125 := checkDerefVar(glojure_DOT_core_list)
											tmp126 := lang.Apply(tmp125, []any{v78})
											tmp127 := lang.Apply(tmp122, []any{tmp124, tmp126})
											tmp128 := lang.Apply(tmp121, []any{tmp127})
											tmp129 := lang.Apply(tmp120, []any{tmp128})
											tmp130 := lang.Apply(tmp111, []any{tmp113, tmp115, tmp117, tmp119, tmp129})
											tmp131 := lang.Apply(tmp110, []any{tmp130})
											var v132 any = tmp131
											_ = v132
											// let binding "steppair-chunk"
											tmp133 := checkDerefVar(glojure_DOT_core_nnext)
											tmp134 := lang.Apply(tmp133, []any{v37})
											tmp135 := lang.Apply(v35, []any{v132, tmp134})
											var v136 any = tmp135
											_ = v136
											// let binding "subform-chunk"
											tmp137 := lang.Apply(v136, []any{int64(1)})
											var v138 any = tmp137
											_ = v138
											tmp139 := checkDerefVar(glojure_DOT_core_seq)
											tmp140 := checkDerefVar(glojure_DOT_core_concat)
											tmp141 := checkDerefVar(glojure_DOT_core_list)
											tmp142 := lang.Apply(tmp141, []any{lang.NewSymbol("glojure.core/loop")})
											tmp143 := checkDerefVar(glojure_DOT_core_list)
											tmp144 := checkDerefVar(glojure_DOT_core_apply)
											tmp145 := checkDerefVar(glojure_DOT_core_vector)
											tmp146 := checkDerefVar(glojure_DOT_core_seq)
											tmp147 := checkDerefVar(glojure_DOT_core_concat)
											tmp148 := checkDerefVar(glojure_DOT_core_list)
											tmp149 := lang.Apply(tmp148, []any{v64})
											tmp150 := checkDerefVar(glojure_DOT_core_list)
											tmp151 := checkDerefVar(glojure_DOT_core_seq)
											tmp152 := checkDerefVar(glojure_DOT_core_concat)
											tmp153 := checkDerefVar(glojure_DOT_core_list)
											tmp154 := lang.Apply(tmp153, []any{lang.NewSymbol("glojure.core/seq")})
											tmp155 := checkDerefVar(glojure_DOT_core_list)
											tmp156 := lang.Apply(tmp155, []any{v56})
											tmp157 := lang.Apply(tmp152, []any{tmp154, tmp156})
											tmp158 := lang.Apply(tmp151, []any{tmp157})
											tmp159 := lang.Apply(tmp150, []any{tmp158})
											tmp160 := checkDerefVar(glojure_DOT_core_list)
											tmp161 := lang.Apply(tmp160, []any{v72})
											tmp162 := checkDerefVar(glojure_DOT_core_list)
											tmp163 := lang.Apply(tmp162, []any{nil})
											tmp164 := checkDerefVar(glojure_DOT_core_list)
											tmp165 := lang.Apply(tmp164, []any{v75})
											tmp166 := checkDerefVar(glojure_DOT_core_list)
											tmp167 := lang.Apply(tmp166, []any{int64(0)})
											tmp168 := checkDerefVar(glojure_DOT_core_list)
											tmp169 := lang.Apply(tmp168, []any{v78})
											tmp170 := checkDerefVar(glojure_DOT_core_list)
											tmp171 := lang.Apply(tmp170, []any{int64(0)})
											tmp172 := lang.Apply(tmp147, []any{tmp149, tmp159, tmp161, tmp163, tmp165, tmp167, tmp169, tmp171})
											tmp173 := lang.Apply(tmp146, []any{tmp172})
											tmp174 := lang.Apply(tmp144, []any{tmp145, tmp173})
											tmp175 := lang.Apply(tmp143, []any{tmp174})
											tmp176 := checkDerefVar(glojure_DOT_core_list)
											tmp177 := checkDerefVar(glojure_DOT_core_seq)
											tmp178 := checkDerefVar(glojure_DOT_core_concat)
											tmp179 := checkDerefVar(glojure_DOT_core_list)
											tmp180 := lang.Apply(tmp179, []any{lang.NewSymbol("if")})
											tmp181 := checkDerefVar(glojure_DOT_core_list)
											tmp182 := checkDerefVar(glojure_DOT_core_seq)
											tmp183 := checkDerefVar(glojure_DOT_core_concat)
											tmp184 := checkDerefVar(glojure_DOT_core_list)
											tmp185 := lang.Apply(tmp184, []any{lang.NewSymbol("glojure.core/<")})
											tmp186 := checkDerefVar(glojure_DOT_core_list)
											tmp187 := lang.Apply(tmp186, []any{v78})
											tmp188 := checkDerefVar(glojure_DOT_core_list)
											tmp189 := lang.Apply(tmp188, []any{v75})
											tmp190 := lang.Apply(tmp183, []any{tmp185, tmp187, tmp189})
											tmp191 := lang.Apply(tmp182, []any{tmp190})
											tmp192 := lang.Apply(tmp181, []any{tmp191})
											tmp193 := checkDerefVar(glojure_DOT_core_list)
											tmp194 := checkDerefVar(glojure_DOT_core_seq)
											tmp195 := checkDerefVar(glojure_DOT_core_concat)
											tmp196 := checkDerefVar(glojure_DOT_core_list)
											tmp197 := lang.Apply(tmp196, []any{lang.NewSymbol("glojure.core/let")})
											tmp198 := checkDerefVar(glojure_DOT_core_list)
											tmp199 := checkDerefVar(glojure_DOT_core_apply)
											tmp200 := checkDerefVar(glojure_DOT_core_vector)
											tmp201 := checkDerefVar(glojure_DOT_core_seq)
											tmp202 := checkDerefVar(glojure_DOT_core_concat)
											tmp203 := checkDerefVar(glojure_DOT_core_list)
											tmp204 := lang.Apply(tmp203, []any{v53})
											tmp205 := checkDerefVar(glojure_DOT_core_list)
											tmp206 := checkDerefVar(glojure_DOT_core_seq)
											tmp207 := checkDerefVar(glojure_DOT_core_concat)
											tmp208 := checkDerefVar(glojure_DOT_core_list)
											tmp209 := lang.Apply(tmp208, []any{lang.NewSymbol(".nth")})
											tmp210 := checkDerefVar(glojure_DOT_core_list)
											tmp211 := lang.Apply(tmp210, []any{v72})
											tmp212 := checkDerefVar(glojure_DOT_core_list)
											tmp213 := lang.Apply(tmp212, []any{v78})
											tmp214 := lang.Apply(tmp207, []any{tmp209, tmp211, tmp213})
											tmp215 := lang.Apply(tmp206, []any{tmp214})
											tmp216 := lang.Apply(tmp205, []any{tmp215})
											tmp217 := lang.Apply(tmp202, []any{tmp204, tmp216})
											tmp218 := lang.Apply(tmp201, []any{tmp217})
											tmp219 := lang.Apply(tmp199, []any{tmp200, tmp218})
											tmp220 := lang.Apply(tmp198, []any{tmp219})
											tmp221 := checkDerefVar(glojure_DOT_core_list)
											tmp222 := lang.Apply(tmp221, []any{v138})
											var tmp223 any
											if lang.IsTruthy(v107) {
												tmp224 := lang.NewVector(v132)
												tmp225 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3256), lang.NewKeyword("column"), int(48), lang.NewKeyword("end-line"), int(3256), lang.NewKeyword("end-column"), int(62))
												tmp226, err := lang.WithMeta(tmp224, tmp225.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp223 = tmp226
											} else {
											}
											tmp227 := lang.Apply(tmp195, []any{tmp197, tmp220, tmp222, tmp223})
											tmp228 := lang.Apply(tmp194, []any{tmp227})
											tmp229 := lang.Apply(tmp193, []any{tmp228})
											tmp230 := checkDerefVar(glojure_DOT_core_list)
											tmp231 := checkDerefVar(glojure_DOT_core_seq)
											tmp232 := checkDerefVar(glojure_DOT_core_concat)
											tmp233 := checkDerefVar(glojure_DOT_core_list)
											tmp234 := lang.Apply(tmp233, []any{lang.NewSymbol("glojure.core/when-let")})
											tmp235 := checkDerefVar(glojure_DOT_core_list)
											tmp236 := checkDerefVar(glojure_DOT_core_apply)
											tmp237 := checkDerefVar(glojure_DOT_core_vector)
											tmp238 := checkDerefVar(glojure_DOT_core_seq)
											tmp239 := checkDerefVar(glojure_DOT_core_concat)
											tmp240 := checkDerefVar(glojure_DOT_core_list)
											tmp241 := lang.Apply(tmp240, []any{v64})
											tmp242 := checkDerefVar(glojure_DOT_core_list)
											tmp243 := checkDerefVar(glojure_DOT_core_seq)
											tmp244 := checkDerefVar(glojure_DOT_core_concat)
											tmp245 := checkDerefVar(glojure_DOT_core_list)
											tmp246 := lang.Apply(tmp245, []any{lang.NewSymbol("glojure.core/seq")})
											tmp247 := checkDerefVar(glojure_DOT_core_list)
											tmp248 := lang.Apply(tmp247, []any{v64})
											tmp249 := lang.Apply(tmp244, []any{tmp246, tmp248})
											tmp250 := lang.Apply(tmp243, []any{tmp249})
											tmp251 := lang.Apply(tmp242, []any{tmp250})
											tmp252 := lang.Apply(tmp239, []any{tmp241, tmp251})
											tmp253 := lang.Apply(tmp238, []any{tmp252})
											tmp254 := lang.Apply(tmp236, []any{tmp237, tmp253})
											tmp255 := lang.Apply(tmp235, []any{tmp254})
											tmp256 := checkDerefVar(glojure_DOT_core_list)
											tmp257 := checkDerefVar(glojure_DOT_core_seq)
											tmp258 := checkDerefVar(glojure_DOT_core_concat)
											tmp259 := checkDerefVar(glojure_DOT_core_list)
											tmp260 := lang.Apply(tmp259, []any{lang.NewSymbol("if")})
											tmp261 := checkDerefVar(glojure_DOT_core_list)
											tmp262 := checkDerefVar(glojure_DOT_core_seq)
											tmp263 := checkDerefVar(glojure_DOT_core_concat)
											tmp264 := checkDerefVar(glojure_DOT_core_list)
											tmp265 := lang.Apply(tmp264, []any{lang.NewSymbol("glojure.core/chunked-seq?")})
											tmp266 := checkDerefVar(glojure_DOT_core_list)
											tmp267 := lang.Apply(tmp266, []any{v64})
											tmp268 := lang.Apply(tmp263, []any{tmp265, tmp267})
											tmp269 := lang.Apply(tmp262, []any{tmp268})
											tmp270 := lang.Apply(tmp261, []any{tmp269})
											tmp271 := checkDerefVar(glojure_DOT_core_list)
											tmp272 := checkDerefVar(glojure_DOT_core_seq)
											tmp273 := checkDerefVar(glojure_DOT_core_concat)
											tmp274 := checkDerefVar(glojure_DOT_core_list)
											tmp275 := lang.Apply(tmp274, []any{lang.NewSymbol("glojure.core/let")})
											tmp276 := checkDerefVar(glojure_DOT_core_list)
											tmp277 := checkDerefVar(glojure_DOT_core_apply)
											tmp278 := checkDerefVar(glojure_DOT_core_vector)
											tmp279 := checkDerefVar(glojure_DOT_core_seq)
											tmp280 := checkDerefVar(glojure_DOT_core_concat)
											tmp281 := checkDerefVar(glojure_DOT_core_list)
											tmp282 := lang.Apply(tmp281, []any{lang.NewSymbol("c__0__auto__")})
											tmp283 := checkDerefVar(glojure_DOT_core_list)
											tmp284 := checkDerefVar(glojure_DOT_core_seq)
											tmp285 := checkDerefVar(glojure_DOT_core_concat)
											tmp286 := checkDerefVar(glojure_DOT_core_list)
											tmp287 := lang.Apply(tmp286, []any{lang.NewSymbol("glojure.core/chunk-first")})
											tmp288 := checkDerefVar(glojure_DOT_core_list)
											tmp289 := lang.Apply(tmp288, []any{v64})
											tmp290 := lang.Apply(tmp285, []any{tmp287, tmp289})
											tmp291 := lang.Apply(tmp284, []any{tmp290})
											tmp292 := lang.Apply(tmp283, []any{tmp291})
											tmp293 := lang.Apply(tmp280, []any{tmp282, tmp292})
											tmp294 := lang.Apply(tmp279, []any{tmp293})
											tmp295 := lang.Apply(tmp277, []any{tmp278, tmp294})
											tmp296 := lang.Apply(tmp276, []any{tmp295})
											tmp297 := checkDerefVar(glojure_DOT_core_list)
											tmp298 := checkDerefVar(glojure_DOT_core_seq)
											tmp299 := checkDerefVar(glojure_DOT_core_concat)
											tmp300 := checkDerefVar(glojure_DOT_core_list)
											tmp301 := lang.Apply(tmp300, []any{lang.NewSymbol("recur")})
											tmp302 := checkDerefVar(glojure_DOT_core_list)
											tmp303 := checkDerefVar(glojure_DOT_core_seq)
											tmp304 := checkDerefVar(glojure_DOT_core_concat)
											tmp305 := checkDerefVar(glojure_DOT_core_list)
											tmp306 := lang.Apply(tmp305, []any{lang.NewSymbol("glojure.core/chunk-rest")})
											tmp307 := checkDerefVar(glojure_DOT_core_list)
											tmp308 := lang.Apply(tmp307, []any{v64})
											tmp309 := lang.Apply(tmp304, []any{tmp306, tmp308})
											tmp310 := lang.Apply(tmp303, []any{tmp309})
											tmp311 := lang.Apply(tmp302, []any{tmp310})
											tmp312 := checkDerefVar(glojure_DOT_core_list)
											tmp313 := lang.Apply(tmp312, []any{lang.NewSymbol("c__0__auto__")})
											tmp314 := checkDerefVar(glojure_DOT_core_list)
											tmp315 := checkDerefVar(glojure_DOT_core_seq)
											tmp316 := checkDerefVar(glojure_DOT_core_concat)
											tmp317 := checkDerefVar(glojure_DOT_core_list)
											tmp318 := lang.Apply(tmp317, []any{lang.NewSymbol("glojure.core/int")})
											tmp319 := checkDerefVar(glojure_DOT_core_list)
											tmp320 := checkDerefVar(glojure_DOT_core_seq)
											tmp321 := checkDerefVar(glojure_DOT_core_concat)
											tmp322 := checkDerefVar(glojure_DOT_core_list)
											tmp323 := lang.Apply(tmp322, []any{lang.NewSymbol("glojure.core/count")})
											tmp324 := checkDerefVar(glojure_DOT_core_list)
											tmp325 := lang.Apply(tmp324, []any{lang.NewSymbol("c__0__auto__")})
											tmp326 := lang.Apply(tmp321, []any{tmp323, tmp325})
											tmp327 := lang.Apply(tmp320, []any{tmp326})
											tmp328 := lang.Apply(tmp319, []any{tmp327})
											tmp329 := lang.Apply(tmp316, []any{tmp318, tmp328})
											tmp330 := lang.Apply(tmp315, []any{tmp329})
											tmp331 := lang.Apply(tmp314, []any{tmp330})
											tmp332 := checkDerefVar(glojure_DOT_core_list)
											tmp333 := checkDerefVar(glojure_DOT_core_seq)
											tmp334 := checkDerefVar(glojure_DOT_core_concat)
											tmp335 := checkDerefVar(glojure_DOT_core_list)
											tmp336 := lang.Apply(tmp335, []any{lang.NewSymbol("glojure.core/int")})
											tmp337 := checkDerefVar(glojure_DOT_core_list)
											tmp338 := lang.Apply(tmp337, []any{int64(0)})
											tmp339 := lang.Apply(tmp334, []any{tmp336, tmp338})
											tmp340 := lang.Apply(tmp333, []any{tmp339})
											tmp341 := lang.Apply(tmp332, []any{tmp340})
											tmp342 := lang.Apply(tmp299, []any{tmp301, tmp311, tmp313, tmp331, tmp341})
											tmp343 := lang.Apply(tmp298, []any{tmp342})
											tmp344 := lang.Apply(tmp297, []any{tmp343})
											tmp345 := lang.Apply(tmp273, []any{tmp275, tmp296, tmp344})
											tmp346 := lang.Apply(tmp272, []any{tmp345})
											tmp347 := lang.Apply(tmp271, []any{tmp346})
											tmp348 := checkDerefVar(glojure_DOT_core_list)
											tmp349 := checkDerefVar(glojure_DOT_core_seq)
											tmp350 := checkDerefVar(glojure_DOT_core_concat)
											tmp351 := checkDerefVar(glojure_DOT_core_list)
											tmp352 := lang.Apply(tmp351, []any{lang.NewSymbol("glojure.core/let")})
											tmp353 := checkDerefVar(glojure_DOT_core_list)
											tmp354 := checkDerefVar(glojure_DOT_core_apply)
											tmp355 := checkDerefVar(glojure_DOT_core_vector)
											tmp356 := checkDerefVar(glojure_DOT_core_seq)
											tmp357 := checkDerefVar(glojure_DOT_core_concat)
											tmp358 := checkDerefVar(glojure_DOT_core_list)
											tmp359 := lang.Apply(tmp358, []any{v53})
											tmp360 := checkDerefVar(glojure_DOT_core_list)
											tmp361 := checkDerefVar(glojure_DOT_core_seq)
											tmp362 := checkDerefVar(glojure_DOT_core_concat)
											tmp363 := checkDerefVar(glojure_DOT_core_list)
											tmp364 := lang.Apply(tmp363, []any{lang.NewSymbol("glojure.core/first")})
											tmp365 := checkDerefVar(glojure_DOT_core_list)
											tmp366 := lang.Apply(tmp365, []any{v64})
											tmp367 := lang.Apply(tmp362, []any{tmp364, tmp366})
											tmp368 := lang.Apply(tmp361, []any{tmp367})
											tmp369 := lang.Apply(tmp360, []any{tmp368})
											tmp370 := lang.Apply(tmp357, []any{tmp359, tmp369})
											tmp371 := lang.Apply(tmp356, []any{tmp370})
											tmp372 := lang.Apply(tmp354, []any{tmp355, tmp371})
											tmp373 := lang.Apply(tmp353, []any{tmp372})
											tmp374 := checkDerefVar(glojure_DOT_core_list)
											tmp375 := lang.Apply(tmp374, []any{v109})
											var tmp376 any
											if lang.IsTruthy(v107) {
												tmp377 := lang.NewVector(v101)
												tmp378 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3264), lang.NewKeyword("column"), int(52), lang.NewKeyword("end-line"), int(3264), lang.NewKeyword("end-column"), int(60))
												tmp379, err := lang.WithMeta(tmp377, tmp378.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp376 = tmp379
											} else {
											}
											tmp380 := lang.Apply(tmp350, []any{tmp352, tmp373, tmp375, tmp376})
											tmp381 := lang.Apply(tmp349, []any{tmp380})
											tmp382 := lang.Apply(tmp348, []any{tmp381})
											tmp383 := lang.Apply(tmp258, []any{tmp260, tmp270, tmp347, tmp382})
											tmp384 := lang.Apply(tmp257, []any{tmp383})
											tmp385 := lang.Apply(tmp256, []any{tmp384})
											tmp386 := lang.Apply(tmp232, []any{tmp234, tmp255, tmp385})
											tmp387 := lang.Apply(tmp231, []any{tmp386})
											tmp388 := lang.Apply(tmp230, []any{tmp387})
											tmp389 := lang.Apply(tmp178, []any{tmp180, tmp192, tmp229, tmp388})
											tmp390 := lang.Apply(tmp177, []any{tmp389})
											tmp391 := lang.Apply(tmp176, []any{tmp390})
											tmp392 := lang.Apply(tmp140, []any{tmp142, tmp175, tmp391})
											tmp393 := lang.Apply(tmp139, []any{tmp392})
											tmp394 := lang.NewVector(true, tmp393)
											tmp395 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3250), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(3264), lang.NewKeyword("end-column"), int(67))
											tmp396, err := lang.WithMeta(tmp394, tmp395.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp61 = tmp396
										} // end let
										tmp57 = tmp61
									}
									tmp50 = tmp57
								} // end let
								tmp38 = tmp50
							}
							return tmp38
						})
						v35 = tmp34
						_ = v35
					}
					tmp35 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3218), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(3264), lang.NewKeyword("end-column"), int(72))
					tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v37 any = tmp36
					_ = v37
					tmp38 := checkDerefVar(glojure_DOT_core_nth)
					tmp39 := checkDerefVar(glojure_DOT_core_seq)
					tmp40 := lang.Apply(tmp39, []any{v5})
					tmp41 := lang.Apply(v37, []any{nil, tmp40})
					tmp42 := lang.Apply(tmp38, []any{tmp41, int64(1)})
					tmp33 = tmp42
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dosync
	{
		tmp0 := lang.NewSymbol("dosync").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("exprs"))), lang.NewKeyword("doc"), "Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of dosync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5100), lang.NewKeyword("end-line"), int(5100))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_concat)
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("glojure.core/sync")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{nil})
				tmp12 := lang.Apply(tmp7, []any{tmp9, tmp11, v5})
				tmp13 := lang.Apply(tmp6, []any{tmp12})
				return tmp13
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dotimes
	{
		tmp0 := lang.NewSymbol("dotimes").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3306), lang.NewKeyword("end-line"), int(3306))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(glojure_DOT_core_str)
					tmp11 := checkDerefVar(glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(lang.NewKeyword("line"), []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp21 := checkDerefVar(glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{int64(2), tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "exactly 2 forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "i"
					tmp34 := checkDerefVar(glojure_DOT_core_first)
					tmp35 := lang.Apply(tmp34, []any{v5})
					var v36 any = tmp35
					_ = v36
					// let binding "n"
					tmp37 := checkDerefVar(glojure_DOT_core_second)
					tmp38 := lang.Apply(tmp37, []any{v5})
					var v39 any = tmp38
					_ = v39
					tmp40 := checkDerefVar(glojure_DOT_core_seq)
					tmp41 := checkDerefVar(glojure_DOT_core_concat)
					tmp42 := checkDerefVar(glojure_DOT_core_list)
					tmp43 := lang.Apply(tmp42, []any{lang.NewSymbol("glojure.core/let")})
					tmp44 := checkDerefVar(glojure_DOT_core_list)
					tmp45 := checkDerefVar(glojure_DOT_core_apply)
					tmp46 := checkDerefVar(glojure_DOT_core_vector)
					tmp47 := checkDerefVar(glojure_DOT_core_seq)
					tmp48 := checkDerefVar(glojure_DOT_core_concat)
					tmp49 := checkDerefVar(glojure_DOT_core_list)
					tmp50 := lang.Apply(tmp49, []any{lang.NewSymbol("n__0__auto__")})
					tmp51 := checkDerefVar(glojure_DOT_core_list)
					tmp52 := checkDerefVar(glojure_DOT_core_seq)
					tmp53 := checkDerefVar(glojure_DOT_core_concat)
					tmp54 := checkDerefVar(glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{lang.NewSymbol("glojure.core/long")})
					tmp56 := checkDerefVar(glojure_DOT_core_list)
					tmp57 := lang.Apply(tmp56, []any{v39})
					tmp58 := lang.Apply(tmp53, []any{tmp55, tmp57})
					tmp59 := lang.Apply(tmp52, []any{tmp58})
					tmp60 := lang.Apply(tmp51, []any{tmp59})
					tmp61 := lang.Apply(tmp48, []any{tmp50, tmp60})
					tmp62 := lang.Apply(tmp47, []any{tmp61})
					tmp63 := lang.Apply(tmp45, []any{tmp46, tmp62})
					tmp64 := lang.Apply(tmp44, []any{tmp63})
					tmp65 := checkDerefVar(glojure_DOT_core_list)
					tmp66 := checkDerefVar(glojure_DOT_core_seq)
					tmp67 := checkDerefVar(glojure_DOT_core_concat)
					tmp68 := checkDerefVar(glojure_DOT_core_list)
					tmp69 := lang.Apply(tmp68, []any{lang.NewSymbol("glojure.core/loop")})
					tmp70 := checkDerefVar(glojure_DOT_core_list)
					tmp71 := checkDerefVar(glojure_DOT_core_apply)
					tmp72 := checkDerefVar(glojure_DOT_core_vector)
					tmp73 := checkDerefVar(glojure_DOT_core_seq)
					tmp74 := checkDerefVar(glojure_DOT_core_concat)
					tmp75 := checkDerefVar(glojure_DOT_core_list)
					tmp76 := lang.Apply(tmp75, []any{v36})
					tmp77 := checkDerefVar(glojure_DOT_core_list)
					tmp78 := lang.Apply(tmp77, []any{int64(0)})
					tmp79 := lang.Apply(tmp74, []any{tmp76, tmp78})
					tmp80 := lang.Apply(tmp73, []any{tmp79})
					tmp81 := lang.Apply(tmp71, []any{tmp72, tmp80})
					tmp82 := lang.Apply(tmp70, []any{tmp81})
					tmp83 := checkDerefVar(glojure_DOT_core_list)
					tmp84 := checkDerefVar(glojure_DOT_core_seq)
					tmp85 := checkDerefVar(glojure_DOT_core_concat)
					tmp86 := checkDerefVar(glojure_DOT_core_list)
					tmp87 := lang.Apply(tmp86, []any{lang.NewSymbol("glojure.core/when")})
					tmp88 := checkDerefVar(glojure_DOT_core_list)
					tmp89 := checkDerefVar(glojure_DOT_core_seq)
					tmp90 := checkDerefVar(glojure_DOT_core_concat)
					tmp91 := checkDerefVar(glojure_DOT_core_list)
					tmp92 := lang.Apply(tmp91, []any{lang.NewSymbol("glojure.core/<")})
					tmp93 := checkDerefVar(glojure_DOT_core_list)
					tmp94 := lang.Apply(tmp93, []any{v36})
					tmp95 := checkDerefVar(glojure_DOT_core_list)
					tmp96 := lang.Apply(tmp95, []any{lang.NewSymbol("n__0__auto__")})
					tmp97 := lang.Apply(tmp90, []any{tmp92, tmp94, tmp96})
					tmp98 := lang.Apply(tmp89, []any{tmp97})
					tmp99 := lang.Apply(tmp88, []any{tmp98})
					tmp100 := checkDerefVar(glojure_DOT_core_list)
					tmp101 := checkDerefVar(glojure_DOT_core_seq)
					tmp102 := checkDerefVar(glojure_DOT_core_concat)
					tmp103 := checkDerefVar(glojure_DOT_core_list)
					tmp104 := lang.Apply(tmp103, []any{lang.NewSymbol("recur")})
					tmp105 := checkDerefVar(glojure_DOT_core_list)
					tmp106 := checkDerefVar(glojure_DOT_core_seq)
					tmp107 := checkDerefVar(glojure_DOT_core_concat)
					tmp108 := checkDerefVar(glojure_DOT_core_list)
					tmp109 := lang.Apply(tmp108, []any{lang.NewSymbol("glojure.core/unchecked-inc")})
					tmp110 := checkDerefVar(glojure_DOT_core_list)
					tmp111 := lang.Apply(tmp110, []any{v36})
					tmp112 := lang.Apply(tmp107, []any{tmp109, tmp111})
					tmp113 := lang.Apply(tmp106, []any{tmp112})
					tmp114 := lang.Apply(tmp105, []any{tmp113})
					tmp115 := lang.Apply(tmp102, []any{tmp104, tmp114})
					tmp116 := lang.Apply(tmp101, []any{tmp115})
					tmp117 := lang.Apply(tmp100, []any{tmp116})
					tmp118 := lang.Apply(tmp85, []any{tmp87, tmp99, v6, tmp117})
					tmp119 := lang.Apply(tmp84, []any{tmp118})
					tmp120 := lang.Apply(tmp83, []any{tmp119})
					tmp121 := lang.Apply(tmp67, []any{tmp69, tmp82, tmp120})
					tmp122 := lang.Apply(tmp66, []any{tmp121})
					tmp123 := lang.Apply(tmp65, []any{tmp122})
					tmp124 := lang.Apply(tmp41, []any{tmp43, tmp64, tmp123})
					tmp125 := lang.Apply(tmp40, []any{tmp124})
					tmp33 = tmp125
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doto
	{
		tmp0 := lang.NewSymbol("doto").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3853), lang.NewKeyword("end-line"), int(3853))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "gx"
					tmp8 := checkDerefVar(glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, nil)
					var v10 any = tmp9
					_ = v10
					tmp11 := checkDerefVar(glojure_DOT_core_seq)
					tmp12 := checkDerefVar(glojure_DOT_core_concat)
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/let")})
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := checkDerefVar(glojure_DOT_core_apply)
					tmp17 := checkDerefVar(glojure_DOT_core_vector)
					tmp18 := checkDerefVar(glojure_DOT_core_seq)
					tmp19 := checkDerefVar(glojure_DOT_core_concat)
					tmp20 := checkDerefVar(glojure_DOT_core_list)
					tmp21 := lang.Apply(tmp20, []any{v10})
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v5})
					tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
					tmp25 := lang.Apply(tmp18, []any{tmp24})
					tmp26 := lang.Apply(tmp16, []any{tmp17, tmp25})
					tmp27 := lang.Apply(tmp15, []any{tmp26})
					tmp28 := checkDerefVar(glojure_DOT_core_map)
					var tmp29 lang.FnFunc
					tmp29 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v30 := args[0]
						_ = v30
						tmp31 := checkDerefVar(glojure_DOT_core_with_meta)
						var tmp32 any
						tmp33 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
						tmp34 := lang.Apply(tmp33, []any{v30})
						if lang.IsTruthy(tmp34) {
							tmp35 := checkDerefVar(glojure_DOT_core_seq)
							tmp36 := checkDerefVar(glojure_DOT_core_concat)
							tmp37 := checkDerefVar(glojure_DOT_core_list)
							tmp38 := checkDerefVar(glojure_DOT_core_first)
							tmp39 := lang.Apply(tmp38, []any{v30})
							tmp40 := lang.Apply(tmp37, []any{tmp39})
							tmp41 := checkDerefVar(glojure_DOT_core_list)
							tmp42 := lang.Apply(tmp41, []any{v10})
							tmp43 := checkDerefVar(glojure_DOT_core_next)
							tmp44 := lang.Apply(tmp43, []any{v30})
							tmp45 := lang.Apply(tmp36, []any{tmp40, tmp42, tmp44})
							tmp46 := lang.Apply(tmp35, []any{tmp45})
							tmp32 = tmp46
						} else {
							tmp47 := checkDerefVar(glojure_DOT_core_seq)
							tmp48 := checkDerefVar(glojure_DOT_core_concat)
							tmp49 := checkDerefVar(glojure_DOT_core_list)
							tmp50 := lang.Apply(tmp49, []any{v30})
							tmp51 := checkDerefVar(glojure_DOT_core_list)
							tmp52 := lang.Apply(tmp51, []any{v10})
							tmp53 := lang.Apply(tmp48, []any{tmp50, tmp52})
							tmp54 := lang.Apply(tmp47, []any{tmp53})
							tmp32 = tmp54
						}
						tmp55 := checkDerefVar(glojure_DOT_core_meta)
						tmp56 := lang.Apply(tmp55, []any{v30})
						tmp57 := lang.Apply(tmp31, []any{tmp32, tmp56})
						return tmp57
					})
					tmp30 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3863), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(3868), lang.NewKeyword("end-column"), int(30))
					tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp32 := lang.Apply(tmp28, []any{tmp31, v6})
					tmp33 := checkDerefVar(glojure_DOT_core_list)
					tmp34 := lang.Apply(tmp33, []any{v10})
					tmp35 := lang.Apply(tmp12, []any{tmp14, tmp27, tmp32, tmp34})
					tmp36 := lang.Apply(tmp11, []any{tmp35})
					tmp7 = tmp36
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double
	{
		var tmp1 lang.FnFunc
		{ // function double__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/DoubleCast")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("double").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to double", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3493), lang.NewKeyword("end-line"), int(3493))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.AsFloat64, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double-array
	{
		var tmp1 lang.FnFunc
		{ // function double-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(glojure_DOT_core_seq)
					tmp5 := checkDerefVar(glojure_DOT_core_concat)
					tmp6 := checkDerefVar(glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
					tmp8 := checkDerefVar(glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/DoubleArray")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.core/args")})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("double-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of doubles", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5341), lang.NewKeyword("end-line"), int(5341))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "DoubleArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("DoubleArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "DoubleArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("DoubleArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double?
	{
		tmp0 := lang.NewSymbol("double?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a Double", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1421), lang.NewKeyword("end-line"), int(1421))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{lang.Builtins["float64"], v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doubles
	{
		var tmp1 lang.FnFunc
		{ // function doubles
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/Doubles")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("doubles").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to double[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5402), lang.NewKeyword("end-line"), int(5402))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Doubles")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Doubles is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop
	{
		tmp0 := lang.NewSymbol("drop").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a laziness-preserving sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2901), lang.NewKeyword("end-line"), int(2901))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "nv"
						tmp7 := checkDerefVar(glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{v3})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "n"
									tmp14 := checkDerefVar(glojure_DOT_core_deref)
									tmp15 := lang.Apply(tmp14, []any{v9})
									var v16 any = tmp15
									_ = v16
									tmp17 := checkDerefVar(glojure_DOT_core_dec)
									tmp18, ok := lang.FieldOrMethod(v9, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Deref")))
									}
									var tmp19 any
									switch reflect.TypeOf(tmp18).Kind() {
									case reflect.Func:
										tmp19 = lang.Apply(tmp18, nil)
									default:
										tmp19 = tmp18
									}
									tmp20 := lang.Apply(tmp17, []any{tmp19})
									tmp21, _ := lang.FieldOrMethod(v9, "reset")
									if reflect.TypeOf(tmp21).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp22 := lang.Apply(tmp21, []any{tmp20})
									_ = tmp22
									var tmp23 any
									tmp24 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
									tmp25 := lang.Apply(tmp24, []any{v16})
									if lang.IsTruthy(tmp25) {
										tmp23 = v11
									} else {
										tmp26 := lang.Apply(v5, []any{v11, v12})
										tmp23 = tmp26
									}
									tmp13 = tmp23
								} // end let
								return tmp13
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2909), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(2917), lang.NewKeyword("end-column"), int(39))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2907), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2917), lang.NewKeyword("end-column"), int(41))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					{ // let
						// let binding "or__0__auto__"
						var tmp10 any
						tmp11 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v3})
						if lang.IsTruthy(tmp12) {
							var tmp13 any
							tmp14 := checkDerefVar(glojure_DOT_core_int_QMARK_)
							tmp15 := lang.Apply(tmp14, []any{v3})
							if lang.IsTruthy(tmp15) {
								tmp13 = v3
							} else {
								tmp16 := lang.Apply(nil, []any{v3})
								tmp13 = tmp16
							}
							tmp17, _ := lang.FieldOrMethod(v4, "drop")
							if reflect.TypeOf(tmp17).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
							}
							tmp18 := lang.Apply(tmp17, []any{tmp13})
							tmp10 = tmp18
						} else {
							tmp19 := checkDerefVar(glojure_DOT_core_seq)
							tmp20 := lang.Apply(tmp19, []any{v4})
							tmp10 = tmp20
						}
						var v21 any = tmp10
						_ = v21
						var tmp22 any
						if lang.IsTruthy(v21) {
							tmp22 = v21
						} else {
							tmp22 = lang.NewList()
						}
						tmp9 = tmp22
					} // end let
					tmp5 = tmp9
				} else {
					var tmp10 any
					{ // let
						// let binding "step"
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v12 := args[0]
							_ = v12
							v13 := args[1]
							_ = v13
						recur_loop_539:
							var tmp14 any
							{ // let
								// let binding "s"
								tmp15 := checkDerefVar(glojure_DOT_core_seq)
								tmp16 := lang.Apply(tmp15, []any{v13})
								var v17 any = tmp16
								_ = v17
								var tmp18 any
								var tmp19 any
								{ // let
									// let binding "and__0__auto__"
									tmp20 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
									tmp21 := lang.Apply(tmp20, []any{v12})
									var v22 any = tmp21
									_ = v22
									var tmp23 any
									if lang.IsTruthy(v22) {
										tmp23 = v17
									} else {
										tmp23 = v22
									}
									tmp19 = tmp23
								} // end let
								if lang.IsTruthy(tmp19) {
									tmp21 := checkDerefVar(glojure_DOT_core_dec)
									tmp22 := lang.Apply(tmp21, []any{v12})
									var tmp20 any = tmp22
									tmp24 := checkDerefVar(glojure_DOT_core_rest)
									tmp25 := lang.Apply(tmp24, []any{v17})
									var tmp23 any = tmp25
									v12 = tmp20
									v13 = tmp23
									goto recur_loop_539
								} else {
									tmp18 = v17
								}
								tmp14 = tmp18
							} // end let
							return tmp14
						})
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2925), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(2929), lang.NewKeyword("end-column"), int(28))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v14 any = tmp13
						_ = v14
						var tmp15 lang.FnFunc
						tmp15 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							tmp16 := lang.Apply(v14, []any{v3, v4})
							return tmp16
						})
						tmp16 := lang.Apply(lang.NewLazySeq, []any{tmp15})
						tmp10 = tmp16
					} // end let
					tmp5 = tmp10
				}
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop-last
	{
		tmp0 := lang.NewSymbol("drop-last").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return a lazy sequence of all but the last n (default 1) items in coll", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2932), lang.NewKeyword("end-line"), int(2932))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_drop_last)
				tmp5 := lang.Apply(tmp4, []any{int64(1), v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_map)
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v7 := args[0]
					_ = v7
					v8 := args[1]
					_ = v8
					return v7
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2937), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(2937), lang.NewKeyword("end-column"), int(29))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := checkDerefVar(glojure_DOT_core_drop)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp5, []any{tmp8, v4, tmp10})
				return tmp11
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop-while
	{
		tmp0 := lang.NewSymbol("drop-while").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred")), lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2950), lang.NewKeyword("end-line"), int(2950))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "dv"
						tmp7 := checkDerefVar(glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{true})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "drop?"
									tmp14 := checkDerefVar(glojure_DOT_core_deref)
									tmp15 := lang.Apply(tmp14, []any{v9})
									var v16 any = tmp15
									_ = v16
									var tmp17 any
									var tmp18 any
									{ // let
										// let binding "and__0__auto__"
										var v19 any = v16
										_ = v19
										var tmp20 any
										if lang.IsTruthy(v19) {
											tmp21 := lang.Apply(v3, []any{v12})
											tmp20 = tmp21
										} else {
											tmp20 = v19
										}
										tmp18 = tmp20
									} // end let
									if lang.IsTruthy(tmp18) {
										tmp17 = v11
									} else {
										tmp19 := checkDerefVar(glojure_DOT_core_vreset_BANG_)
										tmp20 := lang.Apply(tmp19, []any{v9, nil})
										_ = tmp20
										tmp21 := lang.Apply(v5, []any{v11, v12})
										tmp17 = tmp21
									}
									tmp13 = tmp17
								} // end let
								return tmp13
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2959), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(2968), lang.NewKeyword("end-column"), int(42))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2957), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2968), lang.NewKeyword("end-column"), int(44))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "step"
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
					recur_loop_552:
						var tmp9 any
						{ // let
							// let binding "s"
							tmp10 := checkDerefVar(glojure_DOT_core_seq)
							tmp11 := lang.Apply(tmp10, []any{v8})
							var v12 any = tmp11
							_ = v12
							var tmp13 any
							var tmp14 any
							{ // let
								// let binding "and__0__auto__"
								var v15 any = v12
								_ = v15
								var tmp16 any
								if lang.IsTruthy(v15) {
									tmp17 := checkDerefVar(glojure_DOT_core_first)
									tmp18 := lang.Apply(tmp17, []any{v12})
									tmp19 := lang.Apply(v7, []any{tmp18})
									tmp16 = tmp19
								} else {
									tmp16 = v15
								}
								tmp14 = tmp16
							} // end let
							if lang.IsTruthy(tmp14) {
								var tmp15 any = v7
								tmp17 := checkDerefVar(glojure_DOT_core_rest)
								tmp18 := lang.Apply(tmp17, []any{v12})
								var tmp16 any = tmp18
								v7 = tmp15
								v8 = tmp16
								goto recur_loop_552
							} else {
								tmp13 = v12
							}
							tmp9 = tmp13
						} // end let
						return tmp9
					})
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2970), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(2974), lang.NewKeyword("end-column"), int(26))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v9 any = tmp8
					_ = v9
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						tmp11 := lang.Apply(v9, []any{v3, v4})
						return tmp11
					})
					tmp11 := lang.Apply(lang.NewLazySeq, []any{tmp10})
					tmp5 = tmp11
				} // end let
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// elide-top-frames
	{
		tmp0 := lang.NewSymbol("elide-top-frames").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4794), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(4794), lang.NewKeyword("end-column"), int(32), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ex"), lang.NewSymbol("class-name"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "tr"
				tmp6, ok := lang.FieldOrMethod(v3, "getStackTrace")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getStackTrace")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				{ // let
					// let binding "G__54"
					var v10 any = v3
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v8) {
						tmp12 := checkDerefVar(glojure_DOT_core_into_array)
						tmp13 := checkDerefVar(glojure_DOT_core_drop_while)
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v15 := args[0]
							_ = v15
							tmp16 := checkDerefVar(glojure_DOT_core__EQ_)
							tmp17, ok := lang.FieldOrMethod(v15, "getClassName")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v15, "getClassName")))
							}
							var tmp18 any
							switch reflect.TypeOf(tmp17).Kind() {
							case reflect.Func:
								tmp18 = lang.Apply(tmp17, nil)
							default:
								tmp18 = tmp17
							}
							tmp19 := lang.Apply(tmp16, []any{v4, tmp18})
							return tmp19
						})
						tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4801), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(4801), lang.NewKeyword("end-column"), int(77))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp17 := lang.Apply(tmp13, []any{tmp16, v8})
						tmp18 := lang.Apply(tmp12, []any{nil, tmp17})
						tmp11 = tmp18
					} else {
					}
					tmp19, _ := lang.FieldOrMethod(v10, "setStackTrace")
					if reflect.TypeOf(tmp19).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setStackTrace is not a function")))
					}
					tmp20 := lang.Apply(tmp19, []any{tmp11})
					_ = tmp20
					tmp9 = v10
				} // end let
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-extend-protocol
	{
		tmp0 := lang.NewSymbol("emit-extend-protocol").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(205), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(205), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("p"), lang.NewSymbol("specs"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "impls"
				tmp6 := checkDerefVar(glojure_DOT_core_parse_impls)
				tmp7 := lang.Apply(tmp6, []any{v4})
				var v8 any = tmp7
				_ = v8
				tmp9 := checkDerefVar(glojure_DOT_core_seq)
				tmp10 := checkDerefVar(glojure_DOT_core_concat)
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("do")})
				tmp13 := checkDerefVar(glojure_DOT_core_map)
				var tmp14 lang.FnFunc
				tmp14 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v15 := args[0]
					_ = v15
					var tmp16 any
					{ // let
						// let binding "vec__292"
						var v17 any = v15
						_ = v17
						// let binding "t"
						tmp18 := checkDerefVar(glojure_DOT_core_nth)
						tmp19 := lang.Apply(tmp18, []any{v17, int64(0), nil})
						var v20 any = tmp19
						_ = v20
						// let binding "fs"
						tmp21 := checkDerefVar(glojure_DOT_core_nth)
						tmp22 := lang.Apply(tmp21, []any{v17, int64(1), nil})
						var v23 any = tmp22
						_ = v23
						tmp24 := checkDerefVar(glojure_DOT_core_seq)
						tmp25 := checkDerefVar(glojure_DOT_core_concat)
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{lang.NewSymbol("glojure.core/extend-type")})
						tmp28 := checkDerefVar(glojure_DOT_core_list)
						tmp29 := lang.Apply(tmp28, []any{v20})
						tmp30 := checkDerefVar(glojure_DOT_core_list)
						tmp31 := lang.Apply(tmp30, []any{v3})
						tmp32 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp31, v23})
						tmp33 := lang.Apply(tmp24, []any{tmp32})
						tmp16 = tmp33
					} // end let
					return tmp16
				})
				tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(208), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(209), lang.NewKeyword("end-column"), int(42))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp17 := lang.Apply(tmp13, []any{tmp16, v8})
				tmp18 := lang.Apply(tmp10, []any{tmp12, tmp17})
				tmp19 := lang.Apply(tmp9, []any{tmp18})
				tmp5 = tmp19
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-extend-type
	{
		tmp0 := lang.NewSymbol("emit-extend-type").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(175), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(175), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("c"), lang.NewSymbol("specs"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "impls"
				tmp6 := checkDerefVar(glojure_DOT_core_parse_impls)
				tmp7 := lang.Apply(tmp6, []any{v4})
				var v8 any = tmp7
				_ = v8
				tmp9 := checkDerefVar(glojure_DOT_core_seq)
				tmp10 := checkDerefVar(glojure_DOT_core_concat)
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("glojure.core/extend")})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := checkDerefVar(glojure_DOT_core_mapcat)
				tmp16 := checkDerefVar(glojure_DOT_core_partial)
				tmp17 := checkDerefVar(glojure_DOT_core_emit_hinted_impl)
				tmp18 := lang.Apply(tmp16, []any{tmp17, v3})
				tmp19 := lang.Apply(tmp15, []any{tmp18, v8})
				tmp20 := lang.Apply(tmp10, []any{tmp12, tmp14, tmp19})
				tmp21 := lang.Apply(tmp9, []any{tmp20})
				tmp5 = tmp21
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-hinted-impl
	{
		tmp0 := lang.NewSymbol("emit-hinted-impl").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(163), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(163), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("c"), lang.NewVector(lang.NewSymbol("p"), lang.NewSymbol("fs")))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "vec__281"
				var v6 any = v4
				_ = v6
				// let binding "p"
				tmp7 := checkDerefVar(glojure_DOT_core_nth)
				tmp8 := lang.Apply(tmp7, []any{v6, int64(0), nil})
				var v9 any = tmp8
				_ = v9
				// let binding "fs"
				tmp10 := checkDerefVar(glojure_DOT_core_nth)
				tmp11 := lang.Apply(tmp10, []any{v6, int64(1), nil})
				var v12 any = tmp11
				_ = v12
				var tmp13 any
				{ // let
					// let binding "hint"
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						var tmp16 any
						{ // let
							// let binding "specs"
							var tmp17 any
							tmp18 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
							tmp19 := checkDerefVar(glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v15})
							tmp21 := lang.Apply(tmp18, []any{tmp20})
							if lang.IsTruthy(tmp21) {
								tmp22 := checkDerefVar(glojure_DOT_core_list)
								tmp23 := lang.Apply(tmp22, []any{v15})
								tmp17 = tmp23
							} else {
								tmp17 = v15
							}
							var v24 any = tmp17
							_ = v24
							tmp25 := checkDerefVar(glojure_DOT_core_map)
							var tmp26 lang.FnFunc
							tmp26 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v27 := args[0]
								_ = v27
								var tmp28 any
								{ // let
									// let binding "vec__285"
									var v29 any = v27
									_ = v29
									// let binding "seq__286"
									tmp30 := checkDerefVar(glojure_DOT_core_seq)
									tmp31 := lang.Apply(tmp30, []any{v29})
									var v32 any = tmp31
									_ = v32
									// let binding "first__287"
									tmp33 := checkDerefVar(glojure_DOT_core_first)
									tmp34 := lang.Apply(tmp33, []any{v32})
									var v35 any = tmp34
									_ = v35
									// let binding "seq__286"
									tmp36 := checkDerefVar(glojure_DOT_core_next)
									tmp37 := lang.Apply(tmp36, []any{v32})
									var v38 any = tmp37
									_ = v38
									// let binding "vec__288"
									var v39 any = v35
									_ = v39
									// let binding "seq__289"
									tmp40 := checkDerefVar(glojure_DOT_core_seq)
									tmp41 := lang.Apply(tmp40, []any{v39})
									var v42 any = tmp41
									_ = v42
									// let binding "first__290"
									tmp43 := checkDerefVar(glojure_DOT_core_first)
									tmp44 := lang.Apply(tmp43, []any{v42})
									var v45 any = tmp44
									_ = v45
									// let binding "seq__289"
									tmp46 := checkDerefVar(glojure_DOT_core_next)
									tmp47 := lang.Apply(tmp46, []any{v42})
									var v48 any = tmp47
									_ = v48
									// let binding "target"
									var v49 any = v45
									_ = v49
									// let binding "args"
									var v50 any = v48
									_ = v50
									// let binding "body"
									var v51 any = v38
									_ = v51
									tmp52 := checkDerefVar(glojure_DOT_core_cons)
									tmp53 := checkDerefVar(glojure_DOT_core_apply)
									tmp54 := checkDerefVar(glojure_DOT_core_vector)
									tmp55 := checkDerefVar(glojure_DOT_core_vary_meta)
									tmp56 := checkDerefVar(glojure_DOT_core_assoc)
									tmp57 := lang.Apply(tmp55, []any{v49, tmp56, lang.NewKeyword("tag"), v3})
									tmp58 := lang.Apply(tmp53, []any{tmp54, tmp57, v50})
									tmp59 := lang.Apply(tmp52, []any{tmp58, v51})
									tmp28 = tmp59
								} // end let
								return tmp28
							})
							tmp27 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(168), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(170), lang.NewKeyword("end-column"), int(36))
							tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp29 := lang.Apply(tmp25, []any{tmp28, v24})
							tmp16 = tmp29
						} // end let
						return tmp16
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(164), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(171), lang.NewKeyword("end-column"), int(30))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v17 any = tmp16
					_ = v17
					tmp18 := checkDerefVar(glojure_DOT_core_zipmap)
					tmp19 := checkDerefVar(glojure_DOT_core_map)
					var tmp20 lang.FnFunc
					tmp20 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v21 := args[0]
						_ = v21
						tmp22 := checkDerefVar(glojure_DOT_core_keyword)
						tmp23 := checkDerefVar(glojure_DOT_core_name)
						tmp24 := checkDerefVar(glojure_DOT_core_first)
						tmp25 := lang.Apply(tmp24, []any{v21})
						tmp26 := lang.Apply(tmp23, []any{tmp25})
						tmp27 := lang.Apply(tmp22, []any{tmp26})
						return tmp27
					})
					tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(172), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(172), lang.NewKeyword("end-column"), int(46))
					tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp23 := lang.Apply(tmp19, []any{tmp22, v12})
					tmp24 := checkDerefVar(glojure_DOT_core_map)
					var tmp25 lang.FnFunc
					tmp25 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v26 := args[0]
						_ = v26
						tmp27 := checkDerefVar(glojure_DOT_core_cons)
						tmp28 := checkDerefVar(glojure_DOT_core_drop)
						tmp29 := lang.Apply(tmp28, []any{int64(1), v26})
						tmp30 := lang.Apply(v17, []any{tmp29})
						tmp31 := lang.Apply(tmp27, []any{lang.NewSymbol("glojure.core/fn"), tmp30})
						return tmp31
					})
					tmp26 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(173), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(173), lang.NewKeyword("end-column"), int(49))
					tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp28 := lang.Apply(tmp24, []any{tmp27, v12})
					tmp29 := lang.Apply(tmp18, []any{tmp23, tmp28})
					tmp30 := lang.NewVector(v9, tmp29)
					tmp31 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(172), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(173), lang.NewKeyword("end-column"), int(55))
					tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 = tmp32
				} // end let
				tmp5 = tmp13
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// empty
	{
		tmp0 := lang.NewSymbol("empty").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns an empty collection of the same category as coll, or nil", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5265), lang.NewKeyword("end-line"), int(5265))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp6 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
			tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
			if lang.IsTruthy(tmp7) {
				tmp8, ok := lang.FieldOrMethod(v3, "empty")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "empty")))
				}
				var tmp9 any
				switch reflect.TypeOf(tmp8).Kind() {
				case reflect.Func:
					tmp9 = lang.Apply(tmp8, nil)
				default:
					tmp9 = tmp8
				}
				tmp4 = tmp9
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// empty?
	{
		tmp0 := lang.NewSymbol("empty?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll has no items. To check the emptiness of a seq,\n  please use the idiom (seq x) rather than (not (empty? x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6247), lang.NewKeyword("end-line"), int(6247))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_counted_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(glojure_DOT_core_zero_QMARK_)
				tmp8 := checkDerefVar(glojure_DOT_core_count)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp7, []any{tmp9})
				tmp4 = tmp10
			} else {
				tmp11 := checkDerefVar(glojure_DOT_core_not)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp11, []any{tmp13})
				tmp4 = tmp14
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ensure
	{
		tmp0 := lang.NewSymbol("ensure").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref"))), lang.NewKeyword("doc"), "Must be called in a transaction. Protects the ref from modification\n  by other transactions.  Returns the in-transaction-value of\n  ref. Allows for more concurrency than (ref-set ref @ref)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2480), lang.NewKeyword("end-line"), int(2480))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "touch")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("touch is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			_ = tmp5
			tmp6, _ := lang.FieldOrMethod(v3, "deref")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("deref is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ensure-reduced
	{
		tmp0 := lang.NewSymbol("ensure-reduced").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "If x is already reduced?, returns it, else returns (reduced x)", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2841), lang.NewKeyword("end-line"), int(2841))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_reduced_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp4 = v3
			} else {
				tmp7 := checkDerefVar(glojure_DOT_core_reduced)
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp4 = tmp8
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// enumeration-seq
	{
		tmp0 := lang.NewSymbol("enumeration-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("e"))), lang.NewKeyword("doc"), "Returns a seq on a java.util.Enumeration", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5710), lang.NewKeyword("end-line"), int(5710))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// error-handler
	{
		tmp0 := lang.NewSymbol("error-handler").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("doc"), "Returns the error-handler of agent a, or nil if there is none.\n  See set-error-handler!", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2202), lang.NewKeyword("end-line"), int(2202))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getErrorHandler")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getErrorHandler")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// error-mode
	{
		tmp0 := lang.NewSymbol("error-mode").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("doc"), "Returns the error-mode of agent a.  See set-error-mode!", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2227), lang.NewKeyword("end-line"), int(2227))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getErrorMode")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getErrorMode")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// eval
	{
		tmp0 := lang.NewSymbol("eval").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("form"))), lang.NewKeyword("doc"), "Evaluates the form data structure (not text!) and returns the result.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3203), lang.NewKeyword("end-line"), int(3203))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime7.Compiler, "Eval")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Eval is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// even?
	{
		tmp0 := lang.NewSymbol("even?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is even, throws an exception if n is not an integer", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1381), lang.NewKeyword("end-line"), int(1381))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_integer_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(glojure_DOT_core_zero_QMARK_)
				tmp8 := checkDerefVar(glojure_DOT_core_bit_and)
				tmp9 := lang.Apply(lang.UncheckedLongCast, []any{v3})
				tmp10 := lang.Apply(tmp8, []any{tmp9, int64(1)})
				tmp11 := lang.Apply(tmp7, []any{tmp10})
				tmp4 = tmp11
			} else {
				tmp12 := checkDerefVar(glojure_DOT_core_str)
				tmp13 := lang.Apply(tmp12, []any{"Argument must be an integer: ", v3})
				tmp14 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp13})
				panic(tmp14)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// every-pred
	{
		tmp0 := lang.NewSymbol("every-pred").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("p")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2"), lang.NewSymbol("p3")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2"), lang.NewSymbol("p3"), lang.NewSymbol("&"), lang.NewSymbol("ps"))), lang.NewKeyword("doc"), "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7422), lang.NewKeyword("end-line"), int(7422))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				{ // function ep1
					var v5 lang.FnFunc
					tmp4 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v6 := args[0]
							_ = v6
							tmp7 := checkDerefVar(glojure_DOT_core_boolean)
							tmp8 := lang.Apply(v3, []any{v6})
							tmp9 := lang.Apply(tmp7, []any{tmp8})
							return tmp9
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							tmp8 := checkDerefVar(glojure_DOT_core_boolean)
							var tmp9 any
							{ // let
								// let binding "and__0__auto__"
								tmp10 := lang.Apply(v3, []any{v6})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp13 := lang.Apply(v3, []any{v7})
									tmp12 = tmp13
								} else {
									tmp12 = v11
								}
								tmp9 = tmp12
							} // end let
							tmp10 := lang.Apply(tmp8, []any{tmp9})
							return tmp10
						case 3:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							tmp9 := checkDerefVar(glojure_DOT_core_boolean)
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := lang.Apply(v3, []any{v6})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									var tmp14 any
									{ // let
										// let binding "and__0__auto__"
										tmp15 := lang.Apply(v3, []any{v7})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											tmp18 := lang.Apply(v3, []any{v8})
											tmp17 = tmp18
										} else {
											tmp17 = v16
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								} else {
									tmp13 = v12
								}
								tmp10 = tmp13
							} // end let
							tmp11 := lang.Apply(tmp9, []any{tmp10})
							return tmp11
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var v9 any = lang.NewList(args[3:]...)
							_ = v9
							tmp10 := checkDerefVar(glojure_DOT_core_boolean)
							var tmp11 any
							{ // let
								// let binding "and__0__auto__"
								tmp12 := lang.Apply(v5, []any{v6, v7, v8})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp15 := checkDerefVar(glojure_DOT_core_every_QMARK_)
									tmp16 := lang.Apply(tmp15, []any{v3, v9})
									tmp14 = tmp16
								} else {
									tmp14 = v13
								}
								tmp11 = tmp14
							} // end let
							tmp12 := lang.Apply(tmp10, []any{tmp11})
							return tmp12
						}
					})
					v5 = tmp4
					_ = v5
				}
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7429), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7435), lang.NewKeyword("end-column"), int(56))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				{ // function ep2
					var v6 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := checkDerefVar(glojure_DOT_core_boolean)
							var tmp9 any
							{ // let
								// let binding "and__0__auto__"
								tmp10 := lang.Apply(v3, []any{v7})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp13 := lang.Apply(v4, []any{v7})
									tmp12 = tmp13
								} else {
									tmp12 = v11
								}
								tmp9 = tmp12
							} // end let
							tmp10 := lang.Apply(tmp8, []any{tmp9})
							return tmp10
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							tmp9 := checkDerefVar(glojure_DOT_core_boolean)
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := lang.Apply(v3, []any{v7})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									var tmp14 any
									{ // let
										// let binding "and__0__auto__"
										tmp15 := lang.Apply(v3, []any{v8})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											var tmp18 any
											{ // let
												// let binding "and__0__auto__"
												tmp19 := lang.Apply(v4, []any{v7})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													tmp22 := lang.Apply(v4, []any{v8})
													tmp21 = tmp22
												} else {
													tmp21 = v20
												}
												tmp18 = tmp21
											} // end let
											tmp17 = tmp18
										} else {
											tmp17 = v16
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								} else {
									tmp13 = v12
								}
								tmp10 = tmp13
							} // end let
							tmp11 := lang.Apply(tmp9, []any{tmp10})
							return tmp11
						case 3:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							tmp10 := checkDerefVar(glojure_DOT_core_boolean)
							var tmp11 any
							{ // let
								// let binding "and__0__auto__"
								tmp12 := lang.Apply(v3, []any{v7})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									var tmp15 any
									{ // let
										// let binding "and__0__auto__"
										tmp16 := lang.Apply(v3, []any{v8})
										var v17 any = tmp16
										_ = v17
										var tmp18 any
										if lang.IsTruthy(v17) {
											var tmp19 any
											{ // let
												// let binding "and__0__auto__"
												tmp20 := lang.Apply(v3, []any{v9})
												var v21 any = tmp20
												_ = v21
												var tmp22 any
												if lang.IsTruthy(v21) {
													var tmp23 any
													{ // let
														// let binding "and__0__auto__"
														tmp24 := lang.Apply(v4, []any{v7})
														var v25 any = tmp24
														_ = v25
														var tmp26 any
														if lang.IsTruthy(v25) {
															var tmp27 any
															{ // let
																// let binding "and__0__auto__"
																tmp28 := lang.Apply(v4, []any{v8})
																var v29 any = tmp28
																_ = v29
																var tmp30 any
																if lang.IsTruthy(v29) {
																	tmp31 := lang.Apply(v4, []any{v9})
																	tmp30 = tmp31
																} else {
																	tmp30 = v29
																}
																tmp27 = tmp30
															} // end let
															tmp26 = tmp27
														} else {
															tmp26 = v25
														}
														tmp23 = tmp26
													} // end let
													tmp22 = tmp23
												} else {
													tmp22 = v21
												}
												tmp19 = tmp22
											} // end let
											tmp18 = tmp19
										} else {
											tmp18 = v17
										}
										tmp15 = tmp18
									} // end let
									tmp14 = tmp15
								} else {
									tmp14 = v13
								}
								tmp11 = tmp14
							} // end let
							tmp12 := lang.Apply(tmp10, []any{tmp11})
							return tmp12
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var v10 any = lang.NewList(args[3:]...)
							_ = v10
							tmp11 := checkDerefVar(glojure_DOT_core_boolean)
							var tmp12 any
							{ // let
								// let binding "and__0__auto__"
								tmp13 := lang.Apply(v6, []any{v7, v8, v9})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									tmp16 := checkDerefVar(glojure_DOT_core_every_QMARK_)
									var tmp17 lang.FnFunc
									tmp17 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v18 := args[0]
										_ = v18
										var tmp19 any
										{ // let
											// let binding "and__0__auto__"
											tmp20 := lang.Apply(v3, []any{v18})
											var v21 any = tmp20
											_ = v21
											var tmp22 any
											if lang.IsTruthy(v21) {
												tmp23 := lang.Apply(v4, []any{v18})
												tmp22 = tmp23
											} else {
												tmp22 = v21
											}
											tmp19 = tmp22
										} // end let
										return tmp19
									})
									tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7443), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(7443), lang.NewKeyword("end-column"), int(65))
									tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp20 := lang.Apply(tmp16, []any{tmp19, v10})
									tmp15 = tmp20
								} else {
									tmp15 = v14
								}
								tmp12 = tmp15
							} // end let
							tmp13 := lang.Apply(tmp11, []any{tmp12})
							return tmp13
						}
					})
					v6 = tmp5
					_ = v6
				}
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7437), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7443), lang.NewKeyword("end-column"), int(75))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				{ // function ep3
					var v7 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v8 := args[0]
							_ = v8
							tmp9 := checkDerefVar(glojure_DOT_core_boolean)
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := lang.Apply(v3, []any{v8})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									var tmp14 any
									{ // let
										// let binding "and__0__auto__"
										tmp15 := lang.Apply(v4, []any{v8})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											tmp18 := lang.Apply(v5, []any{v8})
											tmp17 = tmp18
										} else {
											tmp17 = v16
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								} else {
									tmp13 = v12
								}
								tmp10 = tmp13
							} // end let
							tmp11 := lang.Apply(tmp9, []any{tmp10})
							return tmp11
						case 2:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							tmp10 := checkDerefVar(glojure_DOT_core_boolean)
							var tmp11 any
							{ // let
								// let binding "and__0__auto__"
								tmp12 := lang.Apply(v3, []any{v8})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									var tmp15 any
									{ // let
										// let binding "and__0__auto__"
										tmp16 := lang.Apply(v3, []any{v9})
										var v17 any = tmp16
										_ = v17
										var tmp18 any
										if lang.IsTruthy(v17) {
											var tmp19 any
											{ // let
												// let binding "and__0__auto__"
												tmp20 := lang.Apply(v4, []any{v8})
												var v21 any = tmp20
												_ = v21
												var tmp22 any
												if lang.IsTruthy(v21) {
													var tmp23 any
													{ // let
														// let binding "and__0__auto__"
														tmp24 := lang.Apply(v4, []any{v9})
														var v25 any = tmp24
														_ = v25
														var tmp26 any
														if lang.IsTruthy(v25) {
															var tmp27 any
															{ // let
																// let binding "and__0__auto__"
																tmp28 := lang.Apply(v5, []any{v8})
																var v29 any = tmp28
																_ = v29
																var tmp30 any
																if lang.IsTruthy(v29) {
																	tmp31 := lang.Apply(v5, []any{v9})
																	tmp30 = tmp31
																} else {
																	tmp30 = v29
																}
																tmp27 = tmp30
															} // end let
															tmp26 = tmp27
														} else {
															tmp26 = v25
														}
														tmp23 = tmp26
													} // end let
													tmp22 = tmp23
												} else {
													tmp22 = v21
												}
												tmp19 = tmp22
											} // end let
											tmp18 = tmp19
										} else {
											tmp18 = v17
										}
										tmp15 = tmp18
									} // end let
									tmp14 = tmp15
								} else {
									tmp14 = v13
								}
								tmp11 = tmp14
							} // end let
							tmp12 := lang.Apply(tmp10, []any{tmp11})
							return tmp12
						case 3:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							tmp11 := checkDerefVar(glojure_DOT_core_boolean)
							var tmp12 any
							{ // let
								// let binding "and__0__auto__"
								tmp13 := lang.Apply(v3, []any{v8})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									var tmp16 any
									{ // let
										// let binding "and__0__auto__"
										tmp17 := lang.Apply(v3, []any{v9})
										var v18 any = tmp17
										_ = v18
										var tmp19 any
										if lang.IsTruthy(v18) {
											var tmp20 any
											{ // let
												// let binding "and__0__auto__"
												tmp21 := lang.Apply(v3, []any{v10})
												var v22 any = tmp21
												_ = v22
												var tmp23 any
												if lang.IsTruthy(v22) {
													var tmp24 any
													{ // let
														// let binding "and__0__auto__"
														tmp25 := lang.Apply(v4, []any{v8})
														var v26 any = tmp25
														_ = v26
														var tmp27 any
														if lang.IsTruthy(v26) {
															var tmp28 any
															{ // let
																// let binding "and__0__auto__"
																tmp29 := lang.Apply(v4, []any{v9})
																var v30 any = tmp29
																_ = v30
																var tmp31 any
																if lang.IsTruthy(v30) {
																	var tmp32 any
																	{ // let
																		// let binding "and__0__auto__"
																		tmp33 := lang.Apply(v4, []any{v10})
																		var v34 any = tmp33
																		_ = v34
																		var tmp35 any
																		if lang.IsTruthy(v34) {
																			var tmp36 any
																			{ // let
																				// let binding "and__0__auto__"
																				tmp37 := lang.Apply(v5, []any{v8})
																				var v38 any = tmp37
																				_ = v38
																				var tmp39 any
																				if lang.IsTruthy(v38) {
																					var tmp40 any
																					{ // let
																						// let binding "and__0__auto__"
																						tmp41 := lang.Apply(v5, []any{v9})
																						var v42 any = tmp41
																						_ = v42
																						var tmp43 any
																						if lang.IsTruthy(v42) {
																							tmp44 := lang.Apply(v5, []any{v10})
																							tmp43 = tmp44
																						} else {
																							tmp43 = v42
																						}
																						tmp40 = tmp43
																					} // end let
																					tmp39 = tmp40
																				} else {
																					tmp39 = v38
																				}
																				tmp36 = tmp39
																			} // end let
																			tmp35 = tmp36
																		} else {
																			tmp35 = v34
																		}
																		tmp32 = tmp35
																	} // end let
																	tmp31 = tmp32
																} else {
																	tmp31 = v30
																}
																tmp28 = tmp31
															} // end let
															tmp27 = tmp28
														} else {
															tmp27 = v26
														}
														tmp24 = tmp27
													} // end let
													tmp23 = tmp24
												} else {
													tmp23 = v22
												}
												tmp20 = tmp23
											} // end let
											tmp19 = tmp20
										} else {
											tmp19 = v18
										}
										tmp16 = tmp19
									} // end let
									tmp15 = tmp16
								} else {
									tmp15 = v14
								}
								tmp12 = tmp15
							} // end let
							tmp13 := lang.Apply(tmp11, []any{tmp12})
							return tmp13
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							var v11 any = lang.NewList(args[3:]...)
							_ = v11
							tmp12 := checkDerefVar(glojure_DOT_core_boolean)
							var tmp13 any
							{ // let
								// let binding "and__0__auto__"
								tmp14 := lang.Apply(v7, []any{v8, v9, v10})
								var v15 any = tmp14
								_ = v15
								var tmp16 any
								if lang.IsTruthy(v15) {
									tmp17 := checkDerefVar(glojure_DOT_core_every_QMARK_)
									var tmp18 lang.FnFunc
									tmp18 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v19 := args[0]
										_ = v19
										var tmp20 any
										{ // let
											// let binding "and__0__auto__"
											tmp21 := lang.Apply(v3, []any{v19})
											var v22 any = tmp21
											_ = v22
											var tmp23 any
											if lang.IsTruthy(v22) {
												var tmp24 any
												{ // let
													// let binding "and__0__auto__"
													tmp25 := lang.Apply(v4, []any{v19})
													var v26 any = tmp25
													_ = v26
													var tmp27 any
													if lang.IsTruthy(v26) {
														tmp28 := lang.Apply(v5, []any{v19})
														tmp27 = tmp28
													} else {
														tmp27 = v26
													}
													tmp24 = tmp27
												} // end let
												tmp23 = tmp24
											} else {
												tmp23 = v22
											}
											tmp20 = tmp23
										} // end let
										return tmp20
									})
									tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7451), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(7451), lang.NewKeyword("end-column"), int(72))
									tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp21 := lang.Apply(tmp17, []any{tmp20, v11})
									tmp16 = tmp21
								} else {
									tmp16 = v15
								}
								tmp13 = tmp16
							} // end let
							tmp14 := lang.Apply(tmp12, []any{tmp13})
							return tmp14
						}
					})
					v7 = tmp6
					_ = v7
				}
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7445), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7451), lang.NewKeyword("end-column"), int(82))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ps"
					tmp8 := checkDerefVar(glojure_DOT_core_list_STAR_)
					tmp9 := lang.Apply(tmp8, []any{v3, v4, v5, v6})
					var v10 any = tmp9
					_ = v10
					var tmp11 lang.FnFunc
					{ // function epn
						var v12 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								return true
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := checkDerefVar(glojure_DOT_core_every_QMARK_)
								var tmp15 lang.FnFunc
								tmp15 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v16 := args[0]
									_ = v16
									tmp17 := lang.Apply(v16, []any{v13})
									return tmp17
								})
								tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7456), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(7456), lang.NewKeyword("end-column"), int(28))
								tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp18 := lang.Apply(tmp14, []any{tmp17, v10})
								return tmp18
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								tmp15 := checkDerefVar(glojure_DOT_core_every_QMARK_)
								var tmp16 lang.FnFunc
								tmp16 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v17 := args[0]
									_ = v17
									var tmp18 any
									{ // let
										// let binding "and__0__auto__"
										tmp19 := lang.Apply(v17, []any{v13})
										var v20 any = tmp19
										_ = v20
										var tmp21 any
										if lang.IsTruthy(v20) {
											tmp22 := lang.Apply(v17, []any{v14})
											tmp21 = tmp22
										} else {
											tmp21 = v20
										}
										tmp18 = tmp21
									} // end let
									return tmp18
								})
								tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7457), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(7457), lang.NewKeyword("end-column"), int(42))
								tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp19 := lang.Apply(tmp15, []any{tmp18, v10})
								return tmp19
							case 3:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								v15 := args[2]
								_ = v15
								tmp16 := checkDerefVar(glojure_DOT_core_every_QMARK_)
								var tmp17 lang.FnFunc
								tmp17 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v18 := args[0]
									_ = v18
									var tmp19 any
									{ // let
										// let binding "and__0__auto__"
										tmp20 := lang.Apply(v18, []any{v13})
										var v21 any = tmp20
										_ = v21
										var tmp22 any
										if lang.IsTruthy(v21) {
											var tmp23 any
											{ // let
												// let binding "and__0__auto__"
												tmp24 := lang.Apply(v18, []any{v14})
												var v25 any = tmp24
												_ = v25
												var tmp26 any
												if lang.IsTruthy(v25) {
													tmp27 := lang.Apply(v18, []any{v15})
													tmp26 = tmp27
												} else {
													tmp26 = v25
												}
												tmp23 = tmp26
											} // end let
											tmp22 = tmp23
										} else {
											tmp22 = v21
										}
										tmp19 = tmp22
									} // end let
									return tmp19
								})
								tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7458), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(7458), lang.NewKeyword("end-column"), int(50))
								tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp20 := lang.Apply(tmp16, []any{tmp19, v10})
								return tmp20
							default:
								if len(args) < 3 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								v15 := args[2]
								_ = v15
								var v16 any = lang.NewList(args[3:]...)
								_ = v16
								tmp17 := checkDerefVar(glojure_DOT_core_boolean)
								var tmp18 any
								{ // let
									// let binding "and__0__auto__"
									tmp19 := lang.Apply(v12, []any{v13, v14, v15})
									var v20 any = tmp19
									_ = v20
									var tmp21 any
									if lang.IsTruthy(v20) {
										tmp22 := checkDerefVar(glojure_DOT_core_every_QMARK_)
										var tmp23 lang.FnFunc
										tmp23 = lang.NewFnFunc(func(args ...any) any {
											if len(args) != 1 {
												panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
											}
											v24 := args[0]
											_ = v24
											tmp25 := checkDerefVar(glojure_DOT_core_every_QMARK_)
											tmp26 := lang.Apply(tmp25, []any{v24, v16})
											return tmp26
										})
										tmp24 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7460), lang.NewKeyword("column"), int(48), lang.NewKeyword("end-line"), int(7460), lang.NewKeyword("end-column"), int(63))
										tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp26 := lang.Apply(tmp22, []any{tmp25, v10})
										tmp21 = tmp26
									} else {
										tmp21 = v20
									}
									tmp18 = tmp21
								} // end let
								tmp19 := lang.Apply(tmp17, []any{tmp18})
								return tmp19
							}
						})
						v12 = tmp11
						_ = v12
					}
					tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7454), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7460), lang.NewKeyword("end-column"), int(71))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp7 = tmp13
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// every?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("every?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if (pred x) is logical true for every x in coll, else\n  false.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2664), lang.NewKeyword("end-line"), int(2664))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
		recur_loop_480:
			var tmp6 any
			tmp7 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
			tmp8 := checkDerefVar(glojure_DOT_core_seq)
			tmp9 := lang.Apply(tmp8, []any{v5})
			tmp10 := lang.Apply(tmp7, []any{tmp9})
			if lang.IsTruthy(tmp10) {
				tmp6 = true
			} else {
				var tmp11 any
				tmp12 := checkDerefVar(glojure_DOT_core_first)
				tmp13 := lang.Apply(tmp12, []any{v5})
				tmp14 := lang.Apply(v4, []any{tmp13})
				if lang.IsTruthy(tmp14) {
					var tmp15 any = v4
					tmp17 := checkDerefVar(glojure_DOT_core_next)
					tmp18 := lang.Apply(tmp17, []any{v5})
					var tmp16 any = tmp18
					v4 = tmp15
					v5 = tmp16
					goto recur_loop_480
				} else {
					var tmp19 any
					if lang.IsTruthy(lang.NewKeyword("else")) {
						tmp19 = false
					} else {
					}
					tmp11 = tmp19
				}
				tmp6 = tmp11
			}
			return tmp6
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-cause
	{
		tmp0 := lang.NewSymbol("ex-cause").WithMeta(lang.NewMap(lang.NewKeyword("tag"), nil, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ex"))), lang.NewKeyword("doc"), "Returns the cause of ex if ex is a Throwable.\n  Otherwise returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4828), lang.NewKeyword("end-line"), int(4828))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{lang.Throwable, v3})
			if lang.IsTruthy(tmp6) {
				tmp7, ok := lang.FieldOrMethod(v3, "getCause")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getCause")))
				}
				var tmp8 any
				switch reflect.TypeOf(tmp7).Kind() {
				case reflect.Func:
					tmp8 = lang.Apply(tmp7, nil)
				default:
					tmp8 = tmp7
				}
				tmp4 = tmp8
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-data
	{
		tmp0 := lang.NewSymbol("ex-data").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ex"))), lang.NewKeyword("doc"), "Returns exception data (a map) if ex is an IExceptionInfo.\n   Otherwise returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4812), lang.NewKeyword("end-line"), int(4812))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{nil, v3})
			if lang.IsTruthy(tmp6) {
				tmp7, ok := lang.FieldOrMethod(v3, "getData")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getData")))
				}
				var tmp8 any
				switch reflect.TypeOf(tmp7).Kind() {
				case reflect.Func:
					tmp8 = lang.Apply(tmp7, nil)
				default:
					tmp8 = tmp7
				}
				tmp4 = tmp8
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-info
	{
		tmp0 := lang.NewSymbol("ex-info").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("msg"), lang.NewSymbol("map")), lang.NewVector(lang.NewSymbol("msg"), lang.NewSymbol("map"), lang.NewSymbol("cause"))), lang.NewKeyword("doc"), "Create an instance of ExceptionInfo, a RuntimeException subclass\n   that carries a map of additional data.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4803), lang.NewKeyword("end-line"), int(4803))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_elide_top_frames)
				tmp6 := lang.Apply(nil, []any{v3, v4})
				tmp7 := lang.Apply(tmp5, []any{tmp6, "glojure.core$ex_info"})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_elide_top_frames)
				tmp7 := lang.Apply(nil, []any{v3, v4, v5})
				tmp8 := lang.Apply(tmp6, []any{tmp7, "glojure.core$ex_info"})
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-message
	{
		tmp0 := lang.NewSymbol("ex-message").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ex"))), lang.NewKeyword("doc"), "Returns the message attached to ex if ex is a Throwable.\n  Otherwise returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4820), lang.NewKeyword("end-line"), int(4820))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{lang.Throwable, v3})
			if lang.IsTruthy(tmp6) {
				tmp7, ok := lang.FieldOrMethod(v3, "getMessage")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMessage")))
				}
				var tmp8 any
				switch reflect.TypeOf(tmp7).Kind() {
				case reflect.Func:
					tmp8 = lang.Apply(tmp7, nil)
				default:
					tmp8 = tmp7
				}
				tmp4 = tmp8
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend
	{
		tmp0 := lang.NewSymbol("extend").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atype"), lang.NewSymbol("&"), lang.NewSymbol("proto+mmaps"))), lang.NewKeyword("doc"), "Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n    AProtocol\n     {:foo an-existing-fn\n      :bar (fn [a b] ...)\n      :baz (fn ([a]...) ([a b] ...)...)}\n    BProtocol \n      {...} \n    ...)\n \n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument. \n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders", lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(116), lang.NewKeyword("end-line"), int(116))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "seq_262"
					tmp6 := checkDerefVar(glojure_DOT_core_seq)
					tmp7 := checkDerefVar(glojure_DOT_core_partition)
					tmp8 := lang.Apply(tmp7, []any{int64(2), v4})
					tmp9 := lang.Apply(tmp6, []any{tmp8})
					var v10 any = tmp9
					_ = v10
					// let binding "chunk_263"
					var v11 any = nil
					_ = v11
					// let binding "count_264"
					var v12 any = int64(0)
					_ = v12
					// let binding "i_265"
					var v13 any = int64(0)
					_ = v13
					for {
						var tmp14 any
						tmp15 := checkDerefVar(glojure_DOT_core__LT_)
						tmp16 := lang.Apply(tmp15, []any{v13, v12})
						if lang.IsTruthy(tmp16) {
							var tmp17 any
							{ // let
								// let binding "vec__266"
								tmp18, _ := lang.FieldOrMethod(v11, "nth")
								if reflect.TypeOf(tmp18).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
								}
								tmp19 := lang.Apply(tmp18, []any{v13})
								var v20 any = tmp19
								_ = v20
								// let binding "proto"
								tmp21 := checkDerefVar(glojure_DOT_core_nth)
								tmp22 := lang.Apply(tmp21, []any{v20, int64(0), nil})
								var v23 any = tmp22
								_ = v23
								// let binding "mmap"
								tmp24 := checkDerefVar(glojure_DOT_core_nth)
								tmp25 := lang.Apply(tmp24, []any{v20, int64(1), nil})
								var v26 any = tmp25
								_ = v26
								var tmp27 any
								tmp28 := checkDerefVar(glojure_DOT_core_protocol_QMARK_)
								tmp29 := lang.Apply(tmp28, []any{v23})
								if lang.IsTruthy(tmp29) {
								} else {
									tmp30 := checkDerefVar(glojure_DOT_core_str)
									tmp31 := lang.Apply(tmp30, []any{v23, " is not a protocol"})
									tmp32 := lang.Apply(errors8.New, []any{tmp31})
									panic(tmp32)
								}
								_ = tmp27
								tmp33 := checkDerefVar(glojure_DOT_core_reduce1)
								var tmp34 lang.FnFunc
								tmp34 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 2 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v35 := args[0]
									_ = v35
									v36 := args[1]
									_ = v36
									var tmp37 any
									{ // let
										// let binding "vec__270"
										var v38 any = v36
										_ = v38
										// let binding "k"
										tmp39 := checkDerefVar(glojure_DOT_core_nth)
										tmp40 := lang.Apply(tmp39, []any{v38, int64(0), nil})
										var v41 any = tmp40
										_ = v41
										// let binding "v"
										tmp42 := checkDerefVar(glojure_DOT_core_nth)
										tmp43 := lang.Apply(tmp42, []any{v38, int64(1), nil})
										var v44 any = tmp43
										_ = v44
										tmp45 := checkDerefVar(glojure_DOT_core_get_in)
										tmp46 := checkDerefVar(glojure_DOT_core_deref)
										tmp47 := lang.Apply(tmp46, []any{v23})
										tmp48 := lang.NewVector(lang.NewKeyword("multis"), v41)
										tmp49 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(158), lang.NewKeyword("column"), int(33), lang.NewKeyword("end-line"), int(158), lang.NewKeyword("end-column"), int(43))
										tmp50, err := lang.WithMeta(tmp48, tmp49.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp51 := lang.Apply(tmp45, []any{tmp47, tmp50})
										var tmp52 lang.FnFunc
										tmp52 = lang.NewFnFunc(func(args ...any) any {
											switch len(args) {
											default:
												if len(args) < 1 {
													panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
												}
												v53 := args[0]
												_ = v53
												var v54 any = lang.NewList(args[1:]...)
												_ = v54
												tmp55 := checkDerefVar(glojure_DOT_core_apply)
												tmp56 := checkDerefVar(glojure_DOT_core_cons)
												tmp57 := lang.Apply(tmp56, []any{v53, v54})
												tmp58 := lang.Apply(tmp55, []any{v44, tmp57})
												return tmp58
											}
										})
										tmp53, _ := lang.FieldOrMethod(tmp51, "AddMethod")
										if reflect.TypeOf(tmp53).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddMethod is not a function")))
										}
										tmp54 := lang.Apply(tmp53, []any{v3, tmp52})
										tmp37 = tmp54
									} // end let
									return tmp37
								})
								tmp35 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(156), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(160), lang.NewKeyword("end-column"), int(45))
								tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp37 := lang.Apply(tmp33, []any{tmp36, nil, v26})
								_ = tmp37
								var tmp38 any = v10
								var tmp39 any = v11
								var tmp40 any = v12
								tmp42 := checkDerefVar(glojure_DOT_core_unchecked_inc)
								tmp43 := lang.Apply(tmp42, []any{v13})
								var tmp41 any = tmp43
								v10 = tmp38
								v11 = tmp39
								v12 = tmp40
								v13 = tmp41
								continue
							} // end let
							tmp14 = tmp17
						} else {
							var tmp18 any
							{ // let
								// let binding "temp__0__auto__"
								tmp19 := checkDerefVar(glojure_DOT_core_seq)
								tmp20 := lang.Apply(tmp19, []any{v10})
								var v21 any = tmp20
								_ = v21
								var tmp22 any
								if lang.IsTruthy(v21) {
									var tmp23 any
									{ // let
										// let binding "seq_262"
										var v24 any = v21
										_ = v24
										var tmp25 any
										tmp26 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
										tmp27 := lang.Apply(tmp26, []any{v24})
										if lang.IsTruthy(tmp27) {
											var tmp28 any
											{ // let
												// let binding "c__0__auto__"
												tmp29 := checkDerefVar(glojure_DOT_core_chunk_first)
												tmp30 := lang.Apply(tmp29, []any{v24})
												var v31 any = tmp30
												_ = v31
												tmp33 := checkDerefVar(glojure_DOT_core_chunk_rest)
												tmp34 := lang.Apply(tmp33, []any{v24})
												var tmp32 any = tmp34
												var tmp35 any = v31
												tmp37 := checkDerefVar(glojure_DOT_core_int)
												tmp38 := checkDerefVar(glojure_DOT_core_count)
												tmp39 := lang.Apply(tmp38, []any{v31})
												tmp40 := lang.Apply(tmp37, []any{tmp39})
												var tmp36 any = tmp40
												tmp42 := checkDerefVar(glojure_DOT_core_int)
												tmp43 := lang.Apply(tmp42, []any{int64(0)})
												var tmp41 any = tmp43
												v10 = tmp32
												v11 = tmp35
												v12 = tmp36
												v13 = tmp41
												continue
											} // end let
											tmp25 = tmp28
										} else {
											var tmp29 any
											{ // let
												// let binding "vec__273"
												tmp30 := checkDerefVar(glojure_DOT_core_first)
												tmp31 := lang.Apply(tmp30, []any{v24})
												var v32 any = tmp31
												_ = v32
												// let binding "proto"
												tmp33 := checkDerefVar(glojure_DOT_core_nth)
												tmp34 := lang.Apply(tmp33, []any{v32, int64(0), nil})
												var v35 any = tmp34
												_ = v35
												// let binding "mmap"
												tmp36 := checkDerefVar(glojure_DOT_core_nth)
												tmp37 := lang.Apply(tmp36, []any{v32, int64(1), nil})
												var v38 any = tmp37
												_ = v38
												var tmp39 any
												tmp40 := checkDerefVar(glojure_DOT_core_protocol_QMARK_)
												tmp41 := lang.Apply(tmp40, []any{v35})
												if lang.IsTruthy(tmp41) {
												} else {
													tmp42 := checkDerefVar(glojure_DOT_core_str)
													tmp43 := lang.Apply(tmp42, []any{v35, " is not a protocol"})
													tmp44 := lang.Apply(errors8.New, []any{tmp43})
													panic(tmp44)
												}
												_ = tmp39
												tmp45 := checkDerefVar(glojure_DOT_core_reduce1)
												var tmp46 lang.FnFunc
												tmp46 = lang.NewFnFunc(func(args ...any) any {
													if len(args) != 2 {
														panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
													}
													v47 := args[0]
													_ = v47
													v48 := args[1]
													_ = v48
													var tmp49 any
													{ // let
														// let binding "vec__277"
														var v50 any = v48
														_ = v50
														// let binding "k"
														tmp51 := checkDerefVar(glojure_DOT_core_nth)
														tmp52 := lang.Apply(tmp51, []any{v50, int64(0), nil})
														var v53 any = tmp52
														_ = v53
														// let binding "v"
														tmp54 := checkDerefVar(glojure_DOT_core_nth)
														tmp55 := lang.Apply(tmp54, []any{v50, int64(1), nil})
														var v56 any = tmp55
														_ = v56
														tmp57 := checkDerefVar(glojure_DOT_core_get_in)
														tmp58 := checkDerefVar(glojure_DOT_core_deref)
														tmp59 := lang.Apply(tmp58, []any{v35})
														tmp60 := lang.NewVector(lang.NewKeyword("multis"), v53)
														tmp61 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(158), lang.NewKeyword("column"), int(33), lang.NewKeyword("end-line"), int(158), lang.NewKeyword("end-column"), int(43))
														tmp62, err := lang.WithMeta(tmp60, tmp61.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp63 := lang.Apply(tmp57, []any{tmp59, tmp62})
														var tmp64 lang.FnFunc
														tmp64 = lang.NewFnFunc(func(args ...any) any {
															switch len(args) {
															default:
																if len(args) < 1 {
																	panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
																}
																v65 := args[0]
																_ = v65
																var v66 any = lang.NewList(args[1:]...)
																_ = v66
																tmp67 := checkDerefVar(glojure_DOT_core_apply)
																tmp68 := checkDerefVar(glojure_DOT_core_cons)
																tmp69 := lang.Apply(tmp68, []any{v65, v66})
																tmp70 := lang.Apply(tmp67, []any{v56, tmp69})
																return tmp70
															}
														})
														tmp65, _ := lang.FieldOrMethod(tmp63, "AddMethod")
														if reflect.TypeOf(tmp65).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddMethod is not a function")))
														}
														tmp66 := lang.Apply(tmp65, []any{v3, tmp64})
														tmp49 = tmp66
													} // end let
													return tmp49
												})
												tmp47 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(156), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(160), lang.NewKeyword("end-column"), int(45))
												tmp48, err := lang.WithMeta(tmp46, tmp47.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp49 := lang.Apply(tmp45, []any{tmp48, nil, v38})
												_ = tmp49
												tmp51 := checkDerefVar(glojure_DOT_core_next)
												tmp52 := lang.Apply(tmp51, []any{v24})
												var tmp50 any = tmp52
												var tmp53 any = nil
												var tmp54 any = int64(0)
												var tmp55 any = int64(0)
												v10 = tmp50
												v11 = tmp53
												v12 = tmp54
												v13 = tmp55
												continue
											} // end let
											tmp25 = tmp29
										}
										tmp23 = tmp25
									} // end let
									tmp22 = tmp23
								} else {
								}
								tmp18 = tmp22
							} // end let
							tmp14 = tmp18
						}
						tmp5 = tmp14
						break
					}
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend-protocol
	{
		tmp0 := lang.NewSymbol("extend-protocol").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("p"), lang.NewSymbol("&"), lang.NewSymbol("specs"))), lang.NewKeyword("doc"), "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types.\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))", lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(212), lang.NewKeyword("end-line"), int(212))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_emit_extend_protocol)
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend-type
	{
		tmp0 := lang.NewSymbol("extend-type").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("t"), lang.NewSymbol("&"), lang.NewSymbol("specs"))), lang.NewKeyword("doc"), "A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType \n    Countable\n      (cnt [c] ...)\n    Foo\n      (bar [x y] ...)\n      (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n   Countable\n     {:cnt (fn [c] ...)}\n   Foo\n     {:baz (fn ([x] ...) ([x y & zs] ...))\n      :bar (fn [x y] ...)})", lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(180), lang.NewKeyword("end-line"), int(180))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_emit_extend_type)
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// false?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("false?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is the value false, false otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(504), lang.NewKeyword("end-line"), int(504))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Identical, []any{v4, false})
			return tmp5
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ffirst
	{
		tmp0 := lang.NewSymbol("ffirst").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Same as (first (first x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(98), lang.NewKeyword("end-line"), int(102))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function ffirst
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_first)
				tmp6 := checkDerefVar(glojure_DOT_core_first)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(102), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(102), lang.NewKeyword("end-column"), int(50))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// file-seq
	{
		tmp0 := lang.NewSymbol("file-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("dir"))), lang.NewKeyword("doc"), "A tree seq on java.io.Files", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4972), lang.NewKeyword("end-line"), int(4972))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_tree_seq)
			var tmp5 lang.FnFunc
			tmp5 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v6 := args[0]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(v6, "isDirectory")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("isDirectory is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{})
				return tmp8
			})
			tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4978), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(4978), lang.NewKeyword("end-column"), int(47))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp8 lang.FnFunc
			tmp8 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v9 := args[0]
				_ = v9
				tmp10 := checkDerefVar(glojure_DOT_core_seq)
				tmp11, _ := lang.FieldOrMethod(v9, "listFiles")
				if reflect.TypeOf(tmp11).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("listFiles is not a function")))
				}
				tmp12 := lang.Apply(tmp11, []any{})
				tmp13 := lang.Apply(tmp10, []any{tmp12})
				return tmp13
			})
			tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4979), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(4979), lang.NewKeyword("end-column"), int(51))
			tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp11 := lang.Apply(tmp4, []any{tmp7, tmp10, v3})
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filter
	{
		tmp0 := lang.NewSymbol("filter").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred")), lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2785), lang.NewKeyword("end-line"), int(2785))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							tmp10 := lang.Apply(v3, []any{v8})
							if lang.IsTruthy(tmp10) {
								tmp11 := lang.Apply(v5, []any{v7, v8})
								tmp9 = tmp11
							} else {
								tmp9 = v7
							}
							return tmp9
						default:
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
					})
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2793), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(2799), lang.NewKeyword("end-column"), int(22))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2792), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2799), lang.NewKeyword("end-column"), int(23))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								tmp14 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
								tmp15 := lang.Apply(tmp14, []any{v12})
								if lang.IsTruthy(tmp15) {
									var tmp16 any
									{ // let
										// let binding "c"
										tmp17 := checkDerefVar(glojure_DOT_core_chunk_first)
										tmp18 := lang.Apply(tmp17, []any{v12})
										var v19 any = tmp18
										_ = v19
										// let binding "size"
										tmp20 := checkDerefVar(glojure_DOT_core_count)
										tmp21 := lang.Apply(tmp20, []any{v19})
										var v22 any = tmp21
										_ = v22
										// let binding "b"
										tmp23 := checkDerefVar(glojure_DOT_core_chunk_buffer)
										tmp24 := lang.Apply(tmp23, []any{v22})
										var v25 any = tmp24
										_ = v25
										var tmp26 any
										{ // let
											// let binding "n__0__auto__"
											tmp27 := lang.Apply(lang.LongCast, []any{v22})
											var v28 any = tmp27
											_ = v28
											var tmp29 any
											{ // let
												// let binding "i"
												var v30 any = int64(0)
												_ = v30
												for {
													var tmp31 any
													tmp32 := checkDerefVar(glojure_DOT_core__LT_)
													tmp33 := lang.Apply(tmp32, []any{v30, v28})
													if lang.IsTruthy(tmp33) {
														var tmp34 any
														{ // let
															// let binding "v"
															tmp35, _ := lang.FieldOrMethod(v19, "nth")
															if reflect.TypeOf(tmp35).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp36 := lang.Apply(tmp35, []any{v30})
															var v37 any = tmp36
															_ = v37
															var tmp38 any
															tmp39 := lang.Apply(v3, []any{v37})
															if lang.IsTruthy(tmp39) {
																tmp40 := checkDerefVar(glojure_DOT_core_chunk_append)
																tmp41 := lang.Apply(tmp40, []any{v25, v37})
																tmp38 = tmp41
															} else {
															}
															tmp34 = tmp38
														} // end let
														_ = tmp34
														tmp36 := checkDerefVar(glojure_DOT_core_unchecked_inc)
														tmp37 := lang.Apply(tmp36, []any{v30})
														var tmp35 any = tmp37
														v30 = tmp35
														continue
													} else {
													}
													tmp29 = tmp31
													break
												}
											} // end let
											tmp26 = tmp29
										} // end let
										_ = tmp26
										tmp27 := checkDerefVar(glojure_DOT_core_chunk_cons)
										tmp28 := checkDerefVar(glojure_DOT_core_chunk)
										tmp29 := lang.Apply(tmp28, []any{v25})
										tmp30 := checkDerefVar(glojure_DOT_core_filter)
										tmp31 := checkDerefVar(glojure_DOT_core_chunk_rest)
										tmp32 := lang.Apply(tmp31, []any{v12})
										tmp33 := lang.Apply(tmp30, []any{v3, tmp32})
										tmp34 := lang.Apply(tmp27, []any{tmp29, tmp33})
										tmp16 = tmp34
									} // end let
									tmp13 = tmp16
								} else {
									var tmp17 any
									{ // let
										// let binding "f"
										tmp18 := checkDerefVar(glojure_DOT_core_first)
										tmp19 := lang.Apply(tmp18, []any{v12})
										var v20 any = tmp19
										_ = v20
										// let binding "r"
										tmp21 := checkDerefVar(glojure_DOT_core_rest)
										tmp22 := lang.Apply(tmp21, []any{v12})
										var v23 any = tmp22
										_ = v23
										var tmp24 any
										tmp25 := lang.Apply(v3, []any{v20})
										if lang.IsTruthy(tmp25) {
											tmp26 := checkDerefVar(glojure_DOT_core_cons)
											tmp27 := checkDerefVar(glojure_DOT_core_filter)
											tmp28 := lang.Apply(tmp27, []any{v3, v23})
											tmp29 := lang.Apply(tmp26, []any{v20, tmp28})
											tmp24 = tmp29
										} else {
											tmp30 := checkDerefVar(glojure_DOT_core_filter)
											tmp31 := lang.Apply(tmp30, []any{v3, v23})
											tmp24 = tmp31
										}
										tmp17 = tmp24
									} // end let
									tmp13 = tmp17
								}
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filter-key
	{
		tmp0 := lang.NewSymbol("filter-key").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("keyfn"), lang.NewSymbol("pred"), lang.NewSymbol("amap"))), lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4115), lang.NewKeyword("end-line"), int(4117), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "ret"
				tmp7 := lang.NewMap()
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4118), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(4118), lang.NewKeyword("end-column"), int(17))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v10 any = tmp9
				_ = v10
				// let binding "es"
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := lang.Apply(tmp11, []any{v5})
				var v13 any = tmp12
				_ = v13
				for {
					var tmp14 any
					if lang.IsTruthy(v13) {
						var tmp15 any
						tmp16 := checkDerefVar(glojure_DOT_core_first)
						tmp17 := lang.Apply(tmp16, []any{v13})
						tmp18 := lang.Apply(v3, []any{tmp17})
						tmp19 := lang.Apply(v4, []any{tmp18})
						if lang.IsTruthy(tmp19) {
							tmp21 := checkDerefVar(glojure_DOT_core_assoc)
							tmp22 := checkDerefVar(glojure_DOT_core_key)
							tmp23 := checkDerefVar(glojure_DOT_core_first)
							tmp24 := lang.Apply(tmp23, []any{v13})
							tmp25 := lang.Apply(tmp22, []any{tmp24})
							tmp26 := checkDerefVar(glojure_DOT_core_val)
							tmp27 := checkDerefVar(glojure_DOT_core_first)
							tmp28 := lang.Apply(tmp27, []any{v13})
							tmp29 := lang.Apply(tmp26, []any{tmp28})
							tmp30 := lang.Apply(tmp21, []any{v10, tmp25, tmp29})
							var tmp20 any = tmp30
							tmp32 := checkDerefVar(glojure_DOT_core_next)
							tmp33 := lang.Apply(tmp32, []any{v13})
							var tmp31 any = tmp33
							v10 = tmp20
							v13 = tmp31
							continue
						} else {
							var tmp34 any = v10
							tmp36 := checkDerefVar(glojure_DOT_core_next)
							tmp37 := lang.Apply(tmp36, []any{v13})
							var tmp35 any = tmp37
							v10 = tmp34
							v13 = tmp35
							continue
						}
						tmp14 = tmp15
					} else {
						tmp14 = v10
					}
					tmp6 = tmp14
					break
				}
			} // end let
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filterv
	{
		tmp0 := lang.NewSymbol("filterv").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6961), lang.NewKeyword("end-line"), int(6961))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
			tmp6 := checkDerefVar(glojure_DOT_core_reduce)
			var tmp7 lang.FnFunc
			tmp7 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v8 := args[0]
				_ = v8
				v9 := args[1]
				_ = v9
				var tmp10 any
				tmp11 := lang.Apply(v3, []any{v9})
				if lang.IsTruthy(tmp11) {
					tmp12 := checkDerefVar(glojure_DOT_core_conj_BANG_)
					tmp13 := lang.Apply(tmp12, []any{v8, v9})
					tmp10 = tmp13
				} else {
					tmp10 = v8
				}
				return tmp10
			})
			tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6967), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(6967), lang.NewKeyword("end-column"), int(52))
			tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp10 := checkDerefVar(glojure_DOT_core_transient)
			tmp11 := lang.NewVector()
			tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6968), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(6968), lang.NewKeyword("end-column"), int(27))
			tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp14 := lang.Apply(tmp10, []any{tmp13})
			tmp15 := lang.Apply(tmp6, []any{tmp9, tmp14, v4})
			tmp16 := lang.Apply(tmp5, []any{tmp15})
			return tmp16
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find
	{
		tmp0 := lang.NewSymbol("find").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"))), lang.NewKeyword("doc"), "Returns the map entry for key, or nil if key not present.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1530), lang.NewKeyword("end-line"), int(1530))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime7.RT, "Find")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Find is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-keyword
	{
		tmp1 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp0 := lang.NewSymbol("find-keyword").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name")), lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("name"))), lang.NewKeyword("doc"), "Returns a Keyword with the given namespace and name if one already\n  exists.  This function will not intern a new keyword. If the keyword\n  has not already been interned, it will return nil.  Do not use :\n  in the keyword strings, it will be added automatically.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(618), lang.NewKeyword("end-line"), int(618))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp5 = v4
				} else {
					var tmp8 any
					tmp9 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v4})
					if lang.IsTruthy(tmp10) {
						tmp11 := lang.Apply(nil, []any{v4})
						tmp8 = tmp11
					} else {
						var tmp12 any
						tmp13 := checkDerefVar(glojure_DOT_core_string_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v4})
						if lang.IsTruthy(tmp14) {
							tmp15 := lang.Apply(nil, []any{v4})
							tmp12 = tmp15
						} else {
						}
						tmp8 = tmp12
					}
					tmp5 = tmp8
				}
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(nil, []any{v4, v5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp4 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-ns
	{
		tmp0 := lang.NewSymbol("find-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Returns the namespace named by the symbol or nil if it doesn't exist.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4125), lang.NewKeyword("end-line"), int(4125))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.FindNamespace, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-var
	{
		tmp0 := lang.NewSymbol("find-var").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Returns the global var named by the namespace-qualified symbol, or\n  nil if no var with that name.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2013), lang.NewKeyword("end-line"), int(2013))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime7.RT, "FindVar")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("FindVar is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// first
	{
		tmp0 := lang.NewSymbol("first").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns the first item in the collection. Calls seq on its\n    argument. If coll is nil, returns nil.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(47), lang.NewKeyword("end-line"), int(52))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function first
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(lang.First, []any{v4})
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(52), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(52), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fits-table?
	{
		tmp0 := lang.NewSymbol("fits-table?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ints"))), lang.NewKeyword("doc"), "Returns true if the collection of ints can fit within the\n  max-table-switch-size, false otherwise.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6625), lang.NewKeyword("end-line"), int(6625), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core__LT_)
			tmp5 := checkDerefVar(glojure_DOT_core__)
			tmp6 := checkDerefVar(glojure_DOT_core_apply)
			tmp7 := checkDerefVar(glojure_DOT_core_max)
			tmp8 := checkDerefVar(glojure_DOT_core_seq)
			tmp9 := lang.Apply(tmp8, []any{v3})
			tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9})
			tmp11 := checkDerefVar(glojure_DOT_core_apply)
			tmp12 := checkDerefVar(glojure_DOT_core_min)
			tmp13 := checkDerefVar(glojure_DOT_core_seq)
			tmp14 := lang.Apply(tmp13, []any{v3})
			tmp15 := lang.Apply(tmp11, []any{tmp12, tmp14})
			tmp16 := lang.Apply(tmp5, []any{tmp10, tmp15})
			tmp17 := checkDerefVar(glojure_DOT_core_max_switch_table_size)
			tmp18 := lang.Apply(tmp4, []any{tmp16, tmp17})
			return tmp18
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// flatten
	{
		tmp0 := lang.NewSymbol("flatten").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat lazy sequence.\n  (flatten nil) returns an empty sequence.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7118), lang.NewKeyword("end-line"), int(7118))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_filter)
			tmp5 := checkDerefVar(glojure_DOT_core_complement)
			tmp6 := checkDerefVar(glojure_DOT_core_sequential_QMARK_)
			tmp7 := lang.Apply(tmp5, []any{tmp6})
			tmp8 := checkDerefVar(glojure_DOT_core_rest)
			tmp9 := checkDerefVar(glojure_DOT_core_tree_seq)
			tmp10 := checkDerefVar(glojure_DOT_core_sequential_QMARK_)
			tmp11 := checkDerefVar(glojure_DOT_core_seq)
			tmp12 := lang.Apply(tmp9, []any{tmp10, tmp11, v3})
			tmp13 := lang.Apply(tmp8, []any{tmp12})
			tmp14 := lang.Apply(tmp4, []any{tmp7, tmp13})
			return tmp14
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float
	{
		var tmp1 lang.FnFunc
		{ // function float__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = lang.NewSymbol("uncheckedFloatCast")
				} else {
					tmp14 = lang.NewSymbol("floatCast")
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("float").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to float", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3487), lang.NewKeyword("end-line"), int(3487))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.FloatCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float-array
	{
		var tmp1 lang.FnFunc
		{ // function float-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(glojure_DOT_core_seq)
					tmp5 := checkDerefVar(glojure_DOT_core_concat)
					tmp6 := checkDerefVar(glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
					tmp8 := checkDerefVar(glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/FloatArray")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.core/args")})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("float-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of floats", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5301), lang.NewKeyword("end-line"), int(5301))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "FloatArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("FloatArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "FloatArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("FloatArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float?
	{
		tmp0 := lang.NewSymbol("float?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is a floating point number", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3605), lang.NewKeyword("end-line"), int(3605))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{lang.Builtins["float64"], v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp8 = v7
				} else {
					tmp9 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{lang.Builtins["float32"], v3})
					tmp8 = tmp10
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// floats
	{
		var tmp1 lang.FnFunc
		{ // function floats
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/Floats")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("floats").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to float[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5392), lang.NewKeyword("end-line"), int(5392))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Floats")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Floats is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// flush
	{
		tmp0 := lang.NewSymbol("flush").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Flushes the output stream that is the current value of\n  *out*", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3706), lang.NewKeyword("end-line"), int(3706))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := checkDerefVar(glojure_DOT_core__STAR_out_STAR_)
			tmp4, _ := lang.FieldOrMethod(tmp3, "Sync")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Sync is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			_ = tmp5
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fn
	{
		tmp0 := lang.NewSymbol("fn").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("sigs"))), lang.NewKeyword("doc"), "params => positional-params*, or positional-params* & rest-param\n  positional-param => binding-form\n  rest-param => binding-form\n  binding-form => name, or destructuring-form\n\n  Defines a function.\n\n  See https://glojure.org/reference/special_forms#fn for more information", lang.NewKeyword("forms"), lang.NewVector(lang.NewList(lang.NewSymbol("fn"), lang.NewSymbol("name?"), lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("exprs*")), lang.NewList(lang.NewSymbol("fn"), lang.NewSymbol("name?"), lang.NewList(lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("exprs*")), lang.NewSymbol("+"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4533), lang.NewKeyword("end-line"), int(4533), lang.NewKeyword("special-form"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "name"
					var tmp7 any
					tmp8 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
					tmp9 := checkDerefVar(glojure_DOT_core_first)
					tmp10 := lang.Apply(tmp9, []any{v5})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(glojure_DOT_core_first)
						tmp13 := lang.Apply(tmp12, []any{v5})
						tmp7 = tmp13
					} else {
					}
					var v14 any = tmp7
					_ = v14
					// let binding "sigs"
					var tmp15 any
					if lang.IsTruthy(v14) {
						tmp16 := checkDerefVar(glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v5})
						tmp15 = tmp17
					} else {
						tmp15 = v5
					}
					var v18 any = tmp15
					_ = v18
					// let binding "sigs"
					var tmp19 any
					tmp20 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
					tmp21 := checkDerefVar(glojure_DOT_core_first)
					tmp22 := lang.Apply(tmp21, []any{v18})
					tmp23 := lang.Apply(tmp20, []any{tmp22})
					if lang.IsTruthy(tmp23) {
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v18})
						tmp19 = tmp25
					} else {
						var tmp26 any
						tmp27 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
						tmp28 := checkDerefVar(glojure_DOT_core_first)
						tmp29 := lang.Apply(tmp28, []any{v18})
						tmp30 := lang.Apply(tmp27, []any{tmp29})
						if lang.IsTruthy(tmp30) {
							tmp26 = v18
						} else {
							var tmp31 any
							tmp32 := checkDerefVar(glojure_DOT_core_seq)
							tmp33 := lang.Apply(tmp32, []any{v18})
							if lang.IsTruthy(tmp33) {
								tmp34 := checkDerefVar(glojure_DOT_core_str)
								tmp35 := checkDerefVar(glojure_DOT_core_first)
								tmp36 := lang.Apply(tmp35, []any{v18})
								tmp37 := lang.Apply(tmp34, []any{"Parameter declaration ", tmp36, " should be a vector"})
								tmp31 = tmp37
							} else {
								tmp38 := checkDerefVar(glojure_DOT_core_str)
								tmp39 := lang.Apply(tmp38, []any{"Parameter declaration missing"})
								tmp31 = tmp39
							}
							tmp40 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
							panic(tmp40)
						}
						tmp19 = tmp26
					}
					var v41 any = tmp19
					_ = v41
					// let binding "psig"
					var tmp42 lang.FnFunc
					tmp42 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v43 := args[0]
						_ = v43
						var tmp44 any
						tmp45 := checkDerefVar(glojure_DOT_core_not)
						tmp46 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
						tmp47 := lang.Apply(tmp46, []any{v43})
						tmp48 := lang.Apply(tmp45, []any{tmp47})
						if lang.IsTruthy(tmp48) {
							tmp49 := checkDerefVar(glojure_DOT_core_str)
							tmp50 := lang.Apply(tmp49, []any{"Invalid signature ", v43, " should be a list"})
							tmp51 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp50})
							panic(tmp51)
						} else {
						}
						_ = tmp44
						var tmp52 any
						{ // let
							// let binding "vec__13"
							var v53 any = v43
							_ = v53
							// let binding "seq__14"
							tmp54 := checkDerefVar(glojure_DOT_core_seq)
							tmp55 := lang.Apply(tmp54, []any{v53})
							var v56 any = tmp55
							_ = v56
							// let binding "first__15"
							tmp57 := checkDerefVar(glojure_DOT_core_first)
							tmp58 := lang.Apply(tmp57, []any{v56})
							var v59 any = tmp58
							_ = v59
							// let binding "seq__14"
							tmp60 := checkDerefVar(glojure_DOT_core_next)
							tmp61 := lang.Apply(tmp60, []any{v56})
							var v62 any = tmp61
							_ = v62
							// let binding "params"
							var v63 any = v59
							_ = v63
							// let binding "body"
							var v64 any = v62
							_ = v64
							// let binding "_"
							var tmp65 any
							tmp66 := checkDerefVar(glojure_DOT_core_not)
							tmp67 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
							tmp68 := lang.Apply(tmp67, []any{v63})
							tmp69 := lang.Apply(tmp66, []any{tmp68})
							if lang.IsTruthy(tmp69) {
								var tmp70 any
								tmp71 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
								tmp72 := checkDerefVar(glojure_DOT_core_first)
								tmp73 := lang.Apply(tmp72, []any{v41})
								tmp74 := lang.Apply(tmp71, []any{tmp73})
								if lang.IsTruthy(tmp74) {
									tmp75 := checkDerefVar(glojure_DOT_core_str)
									tmp76 := lang.Apply(tmp75, []any{"Parameter declaration ", v63, " should be a vector"})
									tmp70 = tmp76
								} else {
									tmp77 := checkDerefVar(glojure_DOT_core_str)
									tmp78 := lang.Apply(tmp77, []any{"Invalid signature ", v43, " should be a list"})
									tmp70 = tmp78
								}
								tmp79 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp70})
								panic(tmp79)
							} else {
							}
							var v80 any = tmp65
							_ = v80
							// let binding "conds"
							var tmp81 any
							var tmp82 any
							{ // let
								// let binding "and__0__auto__"
								tmp83 := checkDerefVar(glojure_DOT_core_next)
								tmp84 := lang.Apply(tmp83, []any{v64})
								var v85 any = tmp84
								_ = v85
								var tmp86 any
								if lang.IsTruthy(v85) {
									tmp87 := checkDerefVar(glojure_DOT_core_map_QMARK_)
									tmp88 := checkDerefVar(glojure_DOT_core_first)
									tmp89 := lang.Apply(tmp88, []any{v64})
									tmp90 := lang.Apply(tmp87, []any{tmp89})
									tmp86 = tmp90
								} else {
									tmp86 = v85
								}
								tmp82 = tmp86
							} // end let
							if lang.IsTruthy(tmp82) {
								tmp83 := checkDerefVar(glojure_DOT_core_first)
								tmp84 := lang.Apply(tmp83, []any{v64})
								tmp81 = tmp84
							} else {
							}
							var v85 any = tmp81
							_ = v85
							// let binding "body"
							var tmp86 any
							if lang.IsTruthy(v85) {
								tmp87 := checkDerefVar(glojure_DOT_core_next)
								tmp88 := lang.Apply(tmp87, []any{v64})
								tmp86 = tmp88
							} else {
								tmp86 = v64
							}
							var v89 any = tmp86
							_ = v89
							// let binding "conds"
							var tmp90 any
							{ // let
								// let binding "or__0__auto__"
								var v91 any = v85
								_ = v91
								var tmp92 any
								if lang.IsTruthy(v91) {
									tmp92 = v91
								} else {
									tmp93 := checkDerefVar(glojure_DOT_core_meta)
									tmp94 := lang.Apply(tmp93, []any{v63})
									tmp92 = tmp94
								}
								tmp90 = tmp92
							} // end let
							var v91 any = tmp90
							_ = v91
							// let binding "pre"
							tmp92 := lang.Apply(lang.NewKeyword("pre"), []any{v91})
							var v93 any = tmp92
							_ = v93
							// let binding "post"
							tmp94 := lang.Apply(lang.NewKeyword("post"), []any{v91})
							var v95 any = tmp94
							_ = v95
							// let binding "body"
							var tmp96 any
							if lang.IsTruthy(v95) {
								tmp97 := checkDerefVar(glojure_DOT_core_seq)
								tmp98 := checkDerefVar(glojure_DOT_core_concat)
								tmp99 := checkDerefVar(glojure_DOT_core_list)
								tmp100 := checkDerefVar(glojure_DOT_core_seq)
								tmp101 := checkDerefVar(glojure_DOT_core_concat)
								tmp102 := checkDerefVar(glojure_DOT_core_list)
								tmp103 := lang.Apply(tmp102, []any{lang.NewSymbol("glojure.core/let")})
								tmp104 := checkDerefVar(glojure_DOT_core_list)
								tmp105 := checkDerefVar(glojure_DOT_core_apply)
								tmp106 := checkDerefVar(glojure_DOT_core_vector)
								tmp107 := checkDerefVar(glojure_DOT_core_seq)
								tmp108 := checkDerefVar(glojure_DOT_core_concat)
								tmp109 := checkDerefVar(glojure_DOT_core_list)
								tmp110 := lang.Apply(tmp109, []any{lang.NewSymbol("%")})
								tmp111 := checkDerefVar(glojure_DOT_core_list)
								var tmp112 any
								tmp113 := checkDerefVar(glojure_DOT_core__LT_)
								tmp114 := checkDerefVar(glojure_DOT_core_count)
								tmp115 := lang.Apply(tmp114, []any{v89})
								tmp116 := lang.Apply(tmp113, []any{int64(1), tmp115})
								if lang.IsTruthy(tmp116) {
									tmp117 := checkDerefVar(glojure_DOT_core_seq)
									tmp118 := checkDerefVar(glojure_DOT_core_concat)
									tmp119 := checkDerefVar(glojure_DOT_core_list)
									tmp120 := lang.Apply(tmp119, []any{lang.NewSymbol("do")})
									tmp121 := lang.Apply(tmp118, []any{tmp120, v89})
									tmp122 := lang.Apply(tmp117, []any{tmp121})
									tmp112 = tmp122
								} else {
									tmp123 := checkDerefVar(glojure_DOT_core_first)
									tmp124 := lang.Apply(tmp123, []any{v89})
									tmp112 = tmp124
								}
								tmp125 := lang.Apply(tmp111, []any{tmp112})
								tmp126 := lang.Apply(tmp108, []any{tmp110, tmp125})
								tmp127 := lang.Apply(tmp107, []any{tmp126})
								tmp128 := lang.Apply(tmp105, []any{tmp106, tmp127})
								tmp129 := lang.Apply(tmp104, []any{tmp128})
								tmp130 := checkDerefVar(glojure_DOT_core_map)
								var tmp131 lang.FnFunc
								tmp131 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v132 := args[0]
									_ = v132
									tmp133 := checkDerefVar(glojure_DOT_core_seq)
									tmp134 := checkDerefVar(glojure_DOT_core_concat)
									tmp135 := checkDerefVar(glojure_DOT_core_list)
									tmp136 := lang.Apply(tmp135, []any{lang.NewSymbol("glojure.core/assert")})
									tmp137 := checkDerefVar(glojure_DOT_core_list)
									tmp138 := lang.Apply(tmp137, []any{v132})
									tmp139 := lang.Apply(tmp134, []any{tmp136, tmp138})
									tmp140 := lang.Apply(tmp133, []any{tmp139})
									return tmp140
								})
								tmp132 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4582), lang.NewKeyword("column"), int(41), lang.NewKeyword("end-line"), int(4582), lang.NewKeyword("end-column"), int(62))
								tmp133, err := lang.WithMeta(tmp131, tmp132.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp134 := lang.Apply(tmp130, []any{tmp133, v95})
								tmp135 := checkDerefVar(glojure_DOT_core_list)
								tmp136 := lang.Apply(tmp135, []any{lang.NewSymbol("%")})
								tmp137 := lang.Apply(tmp101, []any{tmp103, tmp129, tmp134, tmp136})
								tmp138 := lang.Apply(tmp100, []any{tmp137})
								tmp139 := lang.Apply(tmp99, []any{tmp138})
								tmp140 := lang.Apply(tmp98, []any{tmp139})
								tmp141 := lang.Apply(tmp97, []any{tmp140})
								tmp96 = tmp141
							} else {
								tmp96 = v89
							}
							var v142 any = tmp96
							_ = v142
							// let binding "body"
							var tmp143 any
							if lang.IsTruthy(v93) {
								tmp144 := checkDerefVar(glojure_DOT_core_concat)
								tmp145 := checkDerefVar(glojure_DOT_core_map)
								var tmp146 lang.FnFunc
								tmp146 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v147 := args[0]
									_ = v147
									tmp148 := checkDerefVar(glojure_DOT_core_seq)
									tmp149 := checkDerefVar(glojure_DOT_core_concat)
									tmp150 := checkDerefVar(glojure_DOT_core_list)
									tmp151 := lang.Apply(tmp150, []any{lang.NewSymbol("glojure.core/assert")})
									tmp152 := checkDerefVar(glojure_DOT_core_list)
									tmp153 := lang.Apply(tmp152, []any{v147})
									tmp154 := lang.Apply(tmp149, []any{tmp151, tmp153})
									tmp155 := lang.Apply(tmp148, []any{tmp154})
									return tmp155
								})
								tmp147 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4586), lang.NewKeyword("column"), int(44), lang.NewKeyword("end-line"), int(4586), lang.NewKeyword("end-column"), int(65))
								tmp148, err := lang.WithMeta(tmp146, tmp147.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp149 := lang.Apply(tmp145, []any{tmp148, v93})
								tmp150 := lang.Apply(tmp144, []any{tmp149, v142})
								tmp143 = tmp150
							} else {
								tmp143 = v142
							}
							var v151 any = tmp143
							_ = v151
							tmp152 := checkDerefVar(glojure_DOT_core_maybe_destructured)
							tmp153 := lang.Apply(tmp152, []any{v63, v151})
							tmp52 = tmp153
						} // end let
						return tmp52
					})
					tmp43 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4558), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(4589), lang.NewKeyword("end-column"), int(53))
					tmp44, err := lang.WithMeta(tmp42, tmp43.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v45 any = tmp44
					_ = v45
					// let binding "new-sigs"
					tmp46 := checkDerefVar(glojure_DOT_core_map)
					tmp47 := lang.Apply(tmp46, []any{v45, v41})
					var v48 any = tmp47
					_ = v48
					tmp49 := checkDerefVar(glojure_DOT_core_with_meta)
					var tmp50 any
					if lang.IsTruthy(v14) {
						tmp51 := checkDerefVar(glojure_DOT_core_list_STAR_)
						tmp52 := lang.Apply(tmp51, []any{lang.NewSymbol("fn*"), v14, v48})
						tmp50 = tmp52
					} else {
						tmp53 := checkDerefVar(glojure_DOT_core_cons)
						tmp54 := lang.Apply(tmp53, []any{lang.NewSymbol("fn*"), v48})
						tmp50 = tmp54
					}
					tmp55 := checkDerefVar(glojure_DOT_core_meta)
					tmp56 := lang.Apply(tmp55, []any{v3})
					tmp57 := lang.Apply(tmp49, []any{tmp50, tmp56})
					tmp6 = tmp57
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fn?
	{
		tmp0 := lang.NewSymbol("fn?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x implements Fn, i.e. is an object created via fn.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6216), lang.NewKeyword("end-line"), int(6216))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*runtime7.Fn)(nil))
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fnext
	{
		tmp0 := lang.NewSymbol("fnext").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Same as (first (next x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(112), lang.NewKeyword("end-line"), int(116))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function fnext
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_first)
				tmp6 := checkDerefVar(glojure_DOT_core_next)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(116), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(116), lang.NewKeyword("end-column"), int(47))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fnil
	{
		tmp0 := lang.NewSymbol("fnil").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("z"))), lang.NewKeyword("doc"), "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6558), lang.NewKeyword("end-line"), int(6558))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 1:
						v6 := args[0]
						_ = v6
						var tmp7 any
						tmp8 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp9 := lang.Apply(tmp8, []any{v6})
						if lang.IsTruthy(tmp9) {
							tmp7 = v4
						} else {
							tmp7 = v6
						}
						tmp10 := lang.Apply(v3, []any{tmp7})
						return tmp10
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						var tmp8 any
						tmp9 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp10 := lang.Apply(tmp9, []any{v6})
						if lang.IsTruthy(tmp10) {
							tmp8 = v4
						} else {
							tmp8 = v6
						}
						tmp11 := lang.Apply(v3, []any{tmp8, v7})
						return tmp11
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var tmp9 any
						tmp10 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v6})
						if lang.IsTruthy(tmp11) {
							tmp9 = v4
						} else {
							tmp9 = v6
						}
						tmp12 := lang.Apply(v3, []any{tmp9, v7, v8})
						return tmp12
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := checkDerefVar(glojure_DOT_core_apply)
						var tmp11 any
						tmp12 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v6})
						if lang.IsTruthy(tmp13) {
							tmp11 = v4
						} else {
							tmp11 = v6
						}
						tmp14 := lang.Apply(tmp10, []any{v3, tmp11, v7, v8, v9})
						return tmp14
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6567), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(6571), lang.NewKeyword("end-column"), int(55))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						var tmp9 any
						tmp10 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v7})
						if lang.IsTruthy(tmp11) {
							tmp9 = v4
						} else {
							tmp9 = v7
						}
						var tmp12 any
						tmp13 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v8})
						if lang.IsTruthy(tmp14) {
							tmp12 = v5
						} else {
							tmp12 = v8
						}
						tmp15 := lang.Apply(v3, []any{tmp9, tmp12})
						return tmp15
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var tmp10 any
						tmp11 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v7})
						if lang.IsTruthy(tmp12) {
							tmp10 = v4
						} else {
							tmp10 = v7
						}
						var tmp13 any
						tmp14 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp15 := lang.Apply(tmp14, []any{v8})
						if lang.IsTruthy(tmp15) {
							tmp13 = v5
						} else {
							tmp13 = v8
						}
						tmp16 := lang.Apply(v3, []any{tmp10, tmp13, v9})
						return tmp16
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := checkDerefVar(glojure_DOT_core_apply)
						var tmp12 any
						tmp13 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v7})
						if lang.IsTruthy(tmp14) {
							tmp12 = v4
						} else {
							tmp12 = v7
						}
						var tmp15 any
						tmp16 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp17 := lang.Apply(tmp16, []any{v8})
						if lang.IsTruthy(tmp17) {
							tmp15 = v5
						} else {
							tmp15 = v8
						}
						tmp18 := lang.Apply(tmp11, []any{v3, tmp12, tmp15, v9, v10})
						return tmp18
					}
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6573), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(6576), lang.NewKeyword("end-column"), int(71))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 2:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						var tmp10 any
						tmp11 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v8})
						if lang.IsTruthy(tmp12) {
							tmp10 = v4
						} else {
							tmp10 = v8
						}
						var tmp13 any
						tmp14 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp15 := lang.Apply(tmp14, []any{v9})
						if lang.IsTruthy(tmp15) {
							tmp13 = v5
						} else {
							tmp13 = v9
						}
						tmp16 := lang.Apply(v3, []any{tmp10, tmp13})
						return tmp16
					case 3:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var tmp11 any
						tmp12 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v8})
						if lang.IsTruthy(tmp13) {
							tmp11 = v4
						} else {
							tmp11 = v8
						}
						var tmp14 any
						tmp15 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp16 := lang.Apply(tmp15, []any{v9})
						if lang.IsTruthy(tmp16) {
							tmp14 = v5
						} else {
							tmp14 = v9
						}
						var tmp17 any
						tmp18 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v10})
						if lang.IsTruthy(tmp19) {
							tmp17 = v6
						} else {
							tmp17 = v10
						}
						tmp20 := lang.Apply(v3, []any{tmp11, tmp14, tmp17})
						return tmp20
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var v11 any = lang.NewList(args[3:]...)
						_ = v11
						tmp12 := checkDerefVar(glojure_DOT_core_apply)
						var tmp13 any
						tmp14 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp15 := lang.Apply(tmp14, []any{v8})
						if lang.IsTruthy(tmp15) {
							tmp13 = v4
						} else {
							tmp13 = v8
						}
						var tmp16 any
						tmp17 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp18 := lang.Apply(tmp17, []any{v9})
						if lang.IsTruthy(tmp18) {
							tmp16 = v5
						} else {
							tmp16 = v9
						}
						var tmp19 any
						tmp20 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
						tmp21 := lang.Apply(tmp20, []any{v10})
						if lang.IsTruthy(tmp21) {
							tmp19 = v6
						} else {
							tmp19 = v10
						}
						tmp22 := lang.Apply(tmp12, []any{v3, tmp13, tmp16, tmp19, v11})
						return tmp22
					}
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6578), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(6581), lang.NewKeyword("end-column"), int(87))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp9
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// for
	{
		tmp0 := lang.NewSymbol("for").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("seq-exprs"), lang.NewSymbol("body-expr"))), lang.NewKeyword("doc"), "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4646), lang.NewKeyword("end-line"), int(4646))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			var tmp7 any
			tmp8 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
			tmp9 := lang.Apply(tmp8, []any{v5})
			if lang.IsTruthy(tmp9) {
			} else {
				tmp10 := checkDerefVar(glojure_DOT_core_str)
				tmp11 := checkDerefVar(glojure_DOT_core_first)
				tmp12 := lang.Apply(tmp11, []any{v3})
				tmp13 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
				tmp14 := checkDerefVar(glojure_DOT_core_meta)
				tmp15 := lang.Apply(tmp14, []any{v3})
				tmp16 := lang.Apply(lang.NewKeyword("line"), []any{tmp15})
				tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
				tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
				panic(tmp18)
			}
			_ = tmp7
			var tmp19 any
			tmp20 := checkDerefVar(glojure_DOT_core_even_QMARK_)
			tmp21 := checkDerefVar(glojure_DOT_core_count)
			tmp22 := lang.Apply(tmp21, []any{v5})
			tmp23 := lang.Apply(tmp20, []any{tmp22})
			if lang.IsTruthy(tmp23) {
			} else {
				tmp24 := checkDerefVar(glojure_DOT_core_str)
				tmp25 := checkDerefVar(glojure_DOT_core_first)
				tmp26 := lang.Apply(tmp25, []any{v3})
				tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
				tmp28 := checkDerefVar(glojure_DOT_core_meta)
				tmp29 := lang.Apply(tmp28, []any{v3})
				tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
				tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
				tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
				panic(tmp32)
			}
			_ = tmp19
			var tmp33 any
			{ // let
				// let binding "to-groups"
				var tmp34 lang.FnFunc
				tmp34 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v35 := args[0]
					_ = v35
					tmp36 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp37 lang.FnFunc
					tmp37 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v38 := args[0]
						_ = v38
						v39 := args[1]
						_ = v39
						var tmp40 any
						{ // let
							// let binding "vec__24"
							var v41 any = v39
							_ = v41
							// let binding "k"
							tmp42 := checkDerefVar(glojure_DOT_core_nth)
							tmp43 := lang.Apply(tmp42, []any{v41, int64(0), nil})
							var v44 any = tmp43
							_ = v44
							// let binding "v"
							tmp45 := checkDerefVar(glojure_DOT_core_nth)
							tmp46 := lang.Apply(tmp45, []any{v41, int64(1), nil})
							var v47 any = tmp46
							_ = v47
							var tmp48 any
							tmp49 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
							tmp50 := lang.Apply(tmp49, []any{v44})
							if lang.IsTruthy(tmp50) {
								tmp51 := checkDerefVar(glojure_DOT_core_conj)
								tmp52 := checkDerefVar(glojure_DOT_core_pop)
								tmp53 := lang.Apply(tmp52, []any{v38})
								tmp54 := checkDerefVar(glojure_DOT_core_conj)
								tmp55 := checkDerefVar(glojure_DOT_core_peek)
								tmp56 := lang.Apply(tmp55, []any{v38})
								tmp57 := lang.NewVector(v44, v47)
								tmp58 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4664), lang.NewKeyword("column"), int(72), lang.NewKeyword("end-line"), int(4664), lang.NewKeyword("end-column"), int(76))
								tmp59, err := lang.WithMeta(tmp57, tmp58.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp60 := lang.Apply(tmp54, []any{tmp56, tmp59})
								tmp61 := lang.Apply(tmp51, []any{tmp53, tmp60})
								tmp48 = tmp61
							} else {
								tmp62 := checkDerefVar(glojure_DOT_core_conj)
								tmp63 := lang.NewVector(v44, v47)
								tmp64 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4665), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(4665), lang.NewKeyword("end-column"), int(50))
								tmp65, err := lang.WithMeta(tmp63, tmp64.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp66 := lang.Apply(tmp62, []any{v38, tmp65})
								tmp48 = tmp66
							}
							tmp40 = tmp48
						} // end let
						return tmp40
					})
					tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4662), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(4665), lang.NewKeyword("end-column"), int(53))
					tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp40 := lang.NewVector()
					tmp41 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4666), lang.NewKeyword("column"), int(29), lang.NewKeyword("end-line"), int(4666), lang.NewKeyword("end-column"), int(30))
					tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp43 := checkDerefVar(glojure_DOT_core_partition)
					tmp44 := lang.Apply(tmp43, []any{int64(2), v35})
					tmp45 := lang.Apply(tmp36, []any{tmp39, tmp42, tmp44})
					return tmp45
				})
				tmp35 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4661), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(4666), lang.NewKeyword("end-column"), int(56))
				tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v37 any = tmp36
				_ = v37
				// let binding "err"
				var tmp38 lang.FnFunc
				tmp38 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						if len(args) < 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var v39 any = lang.NewList(args[0:]...)
						_ = v39
						tmp40 := checkDerefVar(glojure_DOT_core_apply)
						tmp41 := checkDerefVar(glojure_DOT_core_str)
						tmp42 := lang.Apply(tmp40, []any{tmp41, v39})
						tmp43 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp42})
						panic(tmp43)
					}
				})
				tmp39 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4667), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(4667), lang.NewKeyword("end-column"), int(125))
				tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v41 any = tmp40
				_ = v41
				// let binding "emit-bind"
				var tmp42 lang.FnFunc
				{ // function emit-bind
					var v43 lang.FnFunc
					tmp42 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v44 := args[0]
						_ = v44
						var tmp45 any
						{ // let
							// let binding "vec__28"
							var v46 any = v44
							_ = v46
							// let binding "seq__29"
							tmp47 := checkDerefVar(glojure_DOT_core_seq)
							tmp48 := lang.Apply(tmp47, []any{v46})
							var v49 any = tmp48
							_ = v49
							// let binding "first__30"
							tmp50 := checkDerefVar(glojure_DOT_core_first)
							tmp51 := lang.Apply(tmp50, []any{v49})
							var v52 any = tmp51
							_ = v52
							// let binding "seq__29"
							tmp53 := checkDerefVar(glojure_DOT_core_next)
							tmp54 := lang.Apply(tmp53, []any{v49})
							var v55 any = tmp54
							_ = v55
							// let binding "vec__31"
							var v56 any = v52
							_ = v56
							// let binding "seq__32"
							tmp57 := checkDerefVar(glojure_DOT_core_seq)
							tmp58 := lang.Apply(tmp57, []any{v56})
							var v59 any = tmp58
							_ = v59
							// let binding "first__33"
							tmp60 := checkDerefVar(glojure_DOT_core_first)
							tmp61 := lang.Apply(tmp60, []any{v59})
							var v62 any = tmp61
							_ = v62
							// let binding "seq__32"
							tmp63 := checkDerefVar(glojure_DOT_core_next)
							tmp64 := lang.Apply(tmp63, []any{v59})
							var v65 any = tmp64
							_ = v65
							// let binding "bind"
							var v66 any = v62
							_ = v66
							// let binding "first__33"
							tmp67 := checkDerefVar(glojure_DOT_core_first)
							tmp68 := lang.Apply(tmp67, []any{v65})
							var v69 any = tmp68
							_ = v69
							// let binding "seq__32"
							tmp70 := checkDerefVar(glojure_DOT_core_next)
							tmp71 := lang.Apply(tmp70, []any{v65})
							var v72 any = tmp71
							_ = v72
							// let binding "expr"
							var v73 any = v69
							_ = v73
							// let binding "mod-pairs"
							var v74 any = v72
							_ = v74
							// let binding "vec__34"
							var v75 any = v55
							_ = v75
							// let binding "vec__37"
							tmp76 := checkDerefVar(glojure_DOT_core_nth)
							tmp77 := lang.Apply(tmp76, []any{v75, int64(0), nil})
							var v78 any = tmp77
							_ = v78
							// let binding "_"
							tmp79 := checkDerefVar(glojure_DOT_core_nth)
							tmp80 := lang.Apply(tmp79, []any{v78, int64(0), nil})
							var v81 any = tmp80
							_ = v81
							// let binding "next-expr"
							tmp82 := checkDerefVar(glojure_DOT_core_nth)
							tmp83 := lang.Apply(tmp82, []any{v78, int64(1), nil})
							var v84 any = tmp83
							_ = v84
							// let binding "next-groups"
							var v85 any = v75
							_ = v85
							var tmp86 any
							{ // let
								// let binding "giter"
								tmp87 := checkDerefVar(glojure_DOT_core_gensym)
								tmp88 := lang.Apply(tmp87, []any{"iter__"})
								var v89 any = tmp88
								_ = v89
								// let binding "gxs"
								tmp90 := checkDerefVar(glojure_DOT_core_gensym)
								tmp91 := lang.Apply(tmp90, []any{"s__"})
								var v92 any = tmp91
								_ = v92
								// let binding "do-mod"
								var tmp93 lang.FnFunc
								{ // function do-mod
									var v94 lang.FnFunc
									tmp93 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v95 := args[0]
										_ = v95
										var tmp96 any
										{ // let
											// let binding "vec__41"
											var v97 any = v95
											_ = v97
											// let binding "seq__42"
											tmp98 := checkDerefVar(glojure_DOT_core_seq)
											tmp99 := lang.Apply(tmp98, []any{v97})
											var v100 any = tmp99
											_ = v100
											// let binding "first__43"
											tmp101 := checkDerefVar(glojure_DOT_core_first)
											tmp102 := lang.Apply(tmp101, []any{v100})
											var v103 any = tmp102
											_ = v103
											// let binding "seq__42"
											tmp104 := checkDerefVar(glojure_DOT_core_next)
											tmp105 := lang.Apply(tmp104, []any{v100})
											var v106 any = tmp105
											_ = v106
											// let binding "vec__44"
											var v107 any = v103
											_ = v107
											// let binding "k"
											tmp108 := checkDerefVar(glojure_DOT_core_nth)
											tmp109 := lang.Apply(tmp108, []any{v107, int64(0), nil})
											var v110 any = tmp109
											_ = v110
											// let binding "v"
											tmp111 := checkDerefVar(glojure_DOT_core_nth)
											tmp112 := lang.Apply(tmp111, []any{v107, int64(1), nil})
											var v113 any = tmp112
											_ = v113
											// let binding "pair"
											var v114 any = v107
											_ = v114
											// let binding "etc"
											var v115 any = v106
											_ = v115
											var tmp116 any
											tmp117 := checkDerefVar(glojure_DOT_core__EQ_)
											tmp118 := lang.Apply(tmp117, []any{v110, lang.NewKeyword("let")})
											if lang.IsTruthy(tmp118) {
												tmp119 := checkDerefVar(glojure_DOT_core_seq)
												tmp120 := checkDerefVar(glojure_DOT_core_concat)
												tmp121 := checkDerefVar(glojure_DOT_core_list)
												tmp122 := lang.Apply(tmp121, []any{lang.NewSymbol("glojure.core/let")})
												tmp123 := checkDerefVar(glojure_DOT_core_list)
												tmp124 := lang.Apply(tmp123, []any{v113})
												tmp125 := checkDerefVar(glojure_DOT_core_list)
												tmp126 := lang.Apply(v94, []any{v115})
												tmp127 := lang.Apply(tmp125, []any{tmp126})
												tmp128 := lang.Apply(tmp120, []any{tmp122, tmp124, tmp127})
												tmp129 := lang.Apply(tmp119, []any{tmp128})
												tmp116 = tmp129
											} else {
												var tmp130 any
												tmp131 := checkDerefVar(glojure_DOT_core__EQ_)
												tmp132 := lang.Apply(tmp131, []any{v110, lang.NewKeyword("while")})
												if lang.IsTruthy(tmp132) {
													tmp133 := checkDerefVar(glojure_DOT_core_seq)
													tmp134 := checkDerefVar(glojure_DOT_core_concat)
													tmp135 := checkDerefVar(glojure_DOT_core_list)
													tmp136 := lang.Apply(tmp135, []any{lang.NewSymbol("glojure.core/when")})
													tmp137 := checkDerefVar(glojure_DOT_core_list)
													tmp138 := lang.Apply(tmp137, []any{v113})
													tmp139 := checkDerefVar(glojure_DOT_core_list)
													tmp140 := lang.Apply(v94, []any{v115})
													tmp141 := lang.Apply(tmp139, []any{tmp140})
													tmp142 := lang.Apply(tmp134, []any{tmp136, tmp138, tmp141})
													tmp143 := lang.Apply(tmp133, []any{tmp142})
													tmp130 = tmp143
												} else {
													var tmp144 any
													tmp145 := checkDerefVar(glojure_DOT_core__EQ_)
													tmp146 := lang.Apply(tmp145, []any{v110, lang.NewKeyword("when")})
													if lang.IsTruthy(tmp146) {
														tmp147 := checkDerefVar(glojure_DOT_core_seq)
														tmp148 := checkDerefVar(glojure_DOT_core_concat)
														tmp149 := checkDerefVar(glojure_DOT_core_list)
														tmp150 := lang.Apply(tmp149, []any{lang.NewSymbol("if")})
														tmp151 := checkDerefVar(glojure_DOT_core_list)
														tmp152 := lang.Apply(tmp151, []any{v113})
														tmp153 := checkDerefVar(glojure_DOT_core_list)
														tmp154 := lang.Apply(v94, []any{v115})
														tmp155 := lang.Apply(tmp153, []any{tmp154})
														tmp156 := checkDerefVar(glojure_DOT_core_list)
														tmp157 := checkDerefVar(glojure_DOT_core_seq)
														tmp158 := checkDerefVar(glojure_DOT_core_concat)
														tmp159 := checkDerefVar(glojure_DOT_core_list)
														tmp160 := lang.Apply(tmp159, []any{lang.NewSymbol("recur")})
														tmp161 := checkDerefVar(glojure_DOT_core_list)
														tmp162 := checkDerefVar(glojure_DOT_core_seq)
														tmp163 := checkDerefVar(glojure_DOT_core_concat)
														tmp164 := checkDerefVar(glojure_DOT_core_list)
														tmp165 := lang.Apply(tmp164, []any{lang.NewSymbol("glojure.core/rest")})
														tmp166 := checkDerefVar(glojure_DOT_core_list)
														tmp167 := lang.Apply(tmp166, []any{v92})
														tmp168 := lang.Apply(tmp163, []any{tmp165, tmp167})
														tmp169 := lang.Apply(tmp162, []any{tmp168})
														tmp170 := lang.Apply(tmp161, []any{tmp169})
														tmp171 := lang.Apply(tmp158, []any{tmp160, tmp170})
														tmp172 := lang.Apply(tmp157, []any{tmp171})
														tmp173 := lang.Apply(tmp156, []any{tmp172})
														tmp174 := lang.Apply(tmp148, []any{tmp150, tmp152, tmp155, tmp173})
														tmp175 := lang.Apply(tmp147, []any{tmp174})
														tmp144 = tmp175
													} else {
														var tmp176 any
														tmp177 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
														tmp178 := lang.Apply(tmp177, []any{v110})
														if lang.IsTruthy(tmp178) {
															tmp179 := lang.Apply(v41, []any{"Invalid 'for' keyword ", v110})
															tmp176 = tmp179
														} else {
															var tmp180 any
															if lang.IsTruthy(v85) {
																tmp181 := checkDerefVar(glojure_DOT_core_seq)
																tmp182 := checkDerefVar(glojure_DOT_core_concat)
																tmp183 := checkDerefVar(glojure_DOT_core_list)
																tmp184 := lang.Apply(tmp183, []any{lang.NewSymbol("glojure.core/let")})
																tmp185 := checkDerefVar(glojure_DOT_core_list)
																tmp186 := checkDerefVar(glojure_DOT_core_apply)
																tmp187 := checkDerefVar(glojure_DOT_core_vector)
																tmp188 := checkDerefVar(glojure_DOT_core_seq)
																tmp189 := checkDerefVar(glojure_DOT_core_concat)
																tmp190 := checkDerefVar(glojure_DOT_core_list)
																tmp191 := lang.Apply(tmp190, []any{lang.NewSymbol("iterys__0__auto__")})
																tmp192 := checkDerefVar(glojure_DOT_core_list)
																tmp193 := lang.Apply(v43, []any{v85})
																tmp194 := lang.Apply(tmp192, []any{tmp193})
																tmp195 := checkDerefVar(glojure_DOT_core_list)
																tmp196 := lang.Apply(tmp195, []any{lang.NewSymbol("fs__1__auto__")})
																tmp197 := checkDerefVar(glojure_DOT_core_list)
																tmp198 := checkDerefVar(glojure_DOT_core_seq)
																tmp199 := checkDerefVar(glojure_DOT_core_concat)
																tmp200 := checkDerefVar(glojure_DOT_core_list)
																tmp201 := lang.Apply(tmp200, []any{lang.NewSymbol("glojure.core/seq")})
																tmp202 := checkDerefVar(glojure_DOT_core_list)
																tmp203 := checkDerefVar(glojure_DOT_core_seq)
																tmp204 := checkDerefVar(glojure_DOT_core_concat)
																tmp205 := checkDerefVar(glojure_DOT_core_list)
																tmp206 := lang.Apply(tmp205, []any{lang.NewSymbol("iterys__0__auto__")})
																tmp207 := checkDerefVar(glojure_DOT_core_list)
																tmp208 := lang.Apply(tmp207, []any{v84})
																tmp209 := lang.Apply(tmp204, []any{tmp206, tmp208})
																tmp210 := lang.Apply(tmp203, []any{tmp209})
																tmp211 := lang.Apply(tmp202, []any{tmp210})
																tmp212 := lang.Apply(tmp199, []any{tmp201, tmp211})
																tmp213 := lang.Apply(tmp198, []any{tmp212})
																tmp214 := lang.Apply(tmp197, []any{tmp213})
																tmp215 := lang.Apply(tmp189, []any{tmp191, tmp194, tmp196, tmp214})
																tmp216 := lang.Apply(tmp188, []any{tmp215})
																tmp217 := lang.Apply(tmp186, []any{tmp187, tmp216})
																tmp218 := lang.Apply(tmp185, []any{tmp217})
																tmp219 := checkDerefVar(glojure_DOT_core_list)
																tmp220 := checkDerefVar(glojure_DOT_core_seq)
																tmp221 := checkDerefVar(glojure_DOT_core_concat)
																tmp222 := checkDerefVar(glojure_DOT_core_list)
																tmp223 := lang.Apply(tmp222, []any{lang.NewSymbol("if")})
																tmp224 := checkDerefVar(glojure_DOT_core_list)
																tmp225 := lang.Apply(tmp224, []any{lang.NewSymbol("fs__1__auto__")})
																tmp226 := checkDerefVar(glojure_DOT_core_list)
																tmp227 := checkDerefVar(glojure_DOT_core_seq)
																tmp228 := checkDerefVar(glojure_DOT_core_concat)
																tmp229 := checkDerefVar(glojure_DOT_core_list)
																tmp230 := lang.Apply(tmp229, []any{lang.NewSymbol("glojure.core/concat")})
																tmp231 := checkDerefVar(glojure_DOT_core_list)
																tmp232 := lang.Apply(tmp231, []any{lang.NewSymbol("fs__1__auto__")})
																tmp233 := checkDerefVar(glojure_DOT_core_list)
																tmp234 := checkDerefVar(glojure_DOT_core_seq)
																tmp235 := checkDerefVar(glojure_DOT_core_concat)
																tmp236 := checkDerefVar(glojure_DOT_core_list)
																tmp237 := lang.Apply(tmp236, []any{v89})
																tmp238 := checkDerefVar(glojure_DOT_core_list)
																tmp239 := checkDerefVar(glojure_DOT_core_seq)
																tmp240 := checkDerefVar(glojure_DOT_core_concat)
																tmp241 := checkDerefVar(glojure_DOT_core_list)
																tmp242 := lang.Apply(tmp241, []any{lang.NewSymbol("glojure.core/rest")})
																tmp243 := checkDerefVar(glojure_DOT_core_list)
																tmp244 := lang.Apply(tmp243, []any{v92})
																tmp245 := lang.Apply(tmp240, []any{tmp242, tmp244})
																tmp246 := lang.Apply(tmp239, []any{tmp245})
																tmp247 := lang.Apply(tmp238, []any{tmp246})
																tmp248 := lang.Apply(tmp235, []any{tmp237, tmp247})
																tmp249 := lang.Apply(tmp234, []any{tmp248})
																tmp250 := lang.Apply(tmp233, []any{tmp249})
																tmp251 := lang.Apply(tmp228, []any{tmp230, tmp232, tmp250})
																tmp252 := lang.Apply(tmp227, []any{tmp251})
																tmp253 := lang.Apply(tmp226, []any{tmp252})
																tmp254 := checkDerefVar(glojure_DOT_core_list)
																tmp255 := checkDerefVar(glojure_DOT_core_seq)
																tmp256 := checkDerefVar(glojure_DOT_core_concat)
																tmp257 := checkDerefVar(glojure_DOT_core_list)
																tmp258 := lang.Apply(tmp257, []any{lang.NewSymbol("recur")})
																tmp259 := checkDerefVar(glojure_DOT_core_list)
																tmp260 := checkDerefVar(glojure_DOT_core_seq)
																tmp261 := checkDerefVar(glojure_DOT_core_concat)
																tmp262 := checkDerefVar(glojure_DOT_core_list)
																tmp263 := lang.Apply(tmp262, []any{lang.NewSymbol("glojure.core/rest")})
																tmp264 := checkDerefVar(glojure_DOT_core_list)
																tmp265 := lang.Apply(tmp264, []any{v92})
																tmp266 := lang.Apply(tmp261, []any{tmp263, tmp265})
																tmp267 := lang.Apply(tmp260, []any{tmp266})
																tmp268 := lang.Apply(tmp259, []any{tmp267})
																tmp269 := lang.Apply(tmp256, []any{tmp258, tmp268})
																tmp270 := lang.Apply(tmp255, []any{tmp269})
																tmp271 := lang.Apply(tmp254, []any{tmp270})
																tmp272 := lang.Apply(tmp221, []any{tmp223, tmp225, tmp253, tmp271})
																tmp273 := lang.Apply(tmp220, []any{tmp272})
																tmp274 := lang.Apply(tmp219, []any{tmp273})
																tmp275 := lang.Apply(tmp182, []any{tmp184, tmp218, tmp274})
																tmp276 := lang.Apply(tmp181, []any{tmp275})
																tmp180 = tmp276
															} else {
																var tmp277 any
																if lang.IsTruthy(lang.NewKeyword("else")) {
																	tmp278 := checkDerefVar(glojure_DOT_core_seq)
																	tmp279 := checkDerefVar(glojure_DOT_core_concat)
																	tmp280 := checkDerefVar(glojure_DOT_core_list)
																	tmp281 := lang.Apply(tmp280, []any{lang.NewSymbol("glojure.core/cons")})
																	tmp282 := checkDerefVar(glojure_DOT_core_list)
																	tmp283 := lang.Apply(tmp282, []any{v6})
																	tmp284 := checkDerefVar(glojure_DOT_core_list)
																	tmp285 := checkDerefVar(glojure_DOT_core_seq)
																	tmp286 := checkDerefVar(glojure_DOT_core_concat)
																	tmp287 := checkDerefVar(glojure_DOT_core_list)
																	tmp288 := lang.Apply(tmp287, []any{v89})
																	tmp289 := checkDerefVar(glojure_DOT_core_list)
																	tmp290 := checkDerefVar(glojure_DOT_core_seq)
																	tmp291 := checkDerefVar(glojure_DOT_core_concat)
																	tmp292 := checkDerefVar(glojure_DOT_core_list)
																	tmp293 := lang.Apply(tmp292, []any{lang.NewSymbol("glojure.core/rest")})
																	tmp294 := checkDerefVar(glojure_DOT_core_list)
																	tmp295 := lang.Apply(tmp294, []any{v92})
																	tmp296 := lang.Apply(tmp291, []any{tmp293, tmp295})
																	tmp297 := lang.Apply(tmp290, []any{tmp296})
																	tmp298 := lang.Apply(tmp289, []any{tmp297})
																	tmp299 := lang.Apply(tmp286, []any{tmp288, tmp298})
																	tmp300 := lang.Apply(tmp285, []any{tmp299})
																	tmp301 := lang.Apply(tmp284, []any{tmp300})
																	tmp302 := lang.Apply(tmp279, []any{tmp281, tmp283, tmp301})
																	tmp303 := lang.Apply(tmp278, []any{tmp302})
																	tmp277 = tmp303
																} else {
																}
																tmp180 = tmp277
															}
															tmp176 = tmp180
														}
														tmp144 = tmp176
													}
													tmp130 = tmp144
												}
												tmp116 = tmp130
											}
											tmp96 = tmp116
										} // end let
										return tmp96
									})
									v94 = tmp93
									_ = v94
								}
								tmp94 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4672), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(4687), lang.NewKeyword("end-column"), int(73))
								tmp95, err := lang.WithMeta(tmp93, tmp94.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								var v96 any = tmp95
								_ = v96
								var tmp97 any
								if lang.IsTruthy(v85) {
									tmp98 := checkDerefVar(glojure_DOT_core_seq)
									tmp99 := checkDerefVar(glojure_DOT_core_concat)
									tmp100 := checkDerefVar(glojure_DOT_core_list)
									tmp101 := lang.Apply(tmp100, []any{lang.NewSymbol("glojure.core/fn")})
									tmp102 := checkDerefVar(glojure_DOT_core_list)
									tmp103 := lang.Apply(tmp102, []any{v89})
									tmp104 := checkDerefVar(glojure_DOT_core_list)
									tmp105 := checkDerefVar(glojure_DOT_core_apply)
									tmp106 := checkDerefVar(glojure_DOT_core_vector)
									tmp107 := checkDerefVar(glojure_DOT_core_seq)
									tmp108 := checkDerefVar(glojure_DOT_core_concat)
									tmp109 := checkDerefVar(glojure_DOT_core_list)
									tmp110 := lang.Apply(tmp109, []any{v92})
									tmp111 := lang.Apply(tmp108, []any{tmp110})
									tmp112 := lang.Apply(tmp107, []any{tmp111})
									tmp113 := lang.Apply(tmp105, []any{tmp106, tmp112})
									tmp114 := lang.Apply(tmp104, []any{tmp113})
									tmp115 := checkDerefVar(glojure_DOT_core_list)
									tmp116 := checkDerefVar(glojure_DOT_core_seq)
									tmp117 := checkDerefVar(glojure_DOT_core_concat)
									tmp118 := checkDerefVar(glojure_DOT_core_list)
									tmp119 := lang.Apply(tmp118, []any{lang.NewSymbol("glojure.core/lazy-seq")})
									tmp120 := checkDerefVar(glojure_DOT_core_list)
									tmp121 := checkDerefVar(glojure_DOT_core_seq)
									tmp122 := checkDerefVar(glojure_DOT_core_concat)
									tmp123 := checkDerefVar(glojure_DOT_core_list)
									tmp124 := lang.Apply(tmp123, []any{lang.NewSymbol("glojure.core/loop")})
									tmp125 := checkDerefVar(glojure_DOT_core_list)
									tmp126 := checkDerefVar(glojure_DOT_core_apply)
									tmp127 := checkDerefVar(glojure_DOT_core_vector)
									tmp128 := checkDerefVar(glojure_DOT_core_seq)
									tmp129 := checkDerefVar(glojure_DOT_core_concat)
									tmp130 := checkDerefVar(glojure_DOT_core_list)
									tmp131 := lang.Apply(tmp130, []any{v92})
									tmp132 := checkDerefVar(glojure_DOT_core_list)
									tmp133 := lang.Apply(tmp132, []any{v92})
									tmp134 := lang.Apply(tmp129, []any{tmp131, tmp133})
									tmp135 := lang.Apply(tmp128, []any{tmp134})
									tmp136 := lang.Apply(tmp126, []any{tmp127, tmp135})
									tmp137 := lang.Apply(tmp125, []any{tmp136})
									tmp138 := checkDerefVar(glojure_DOT_core_list)
									tmp139 := checkDerefVar(glojure_DOT_core_seq)
									tmp140 := checkDerefVar(glojure_DOT_core_concat)
									tmp141 := checkDerefVar(glojure_DOT_core_list)
									tmp142 := lang.Apply(tmp141, []any{lang.NewSymbol("glojure.core/when-first")})
									tmp143 := checkDerefVar(glojure_DOT_core_list)
									tmp144 := checkDerefVar(glojure_DOT_core_apply)
									tmp145 := checkDerefVar(glojure_DOT_core_vector)
									tmp146 := checkDerefVar(glojure_DOT_core_seq)
									tmp147 := checkDerefVar(glojure_DOT_core_concat)
									tmp148 := checkDerefVar(glojure_DOT_core_list)
									tmp149 := lang.Apply(tmp148, []any{v66})
									tmp150 := checkDerefVar(glojure_DOT_core_list)
									tmp151 := lang.Apply(tmp150, []any{v92})
									tmp152 := lang.Apply(tmp147, []any{tmp149, tmp151})
									tmp153 := lang.Apply(tmp146, []any{tmp152})
									tmp154 := lang.Apply(tmp144, []any{tmp145, tmp153})
									tmp155 := lang.Apply(tmp143, []any{tmp154})
									tmp156 := checkDerefVar(glojure_DOT_core_list)
									tmp157 := lang.Apply(v96, []any{v74})
									tmp158 := lang.Apply(tmp156, []any{tmp157})
									tmp159 := lang.Apply(tmp140, []any{tmp142, tmp155, tmp158})
									tmp160 := lang.Apply(tmp139, []any{tmp159})
									tmp161 := lang.Apply(tmp138, []any{tmp160})
									tmp162 := lang.Apply(tmp122, []any{tmp124, tmp137, tmp161})
									tmp163 := lang.Apply(tmp121, []any{tmp162})
									tmp164 := lang.Apply(tmp120, []any{tmp163})
									tmp165 := lang.Apply(tmp117, []any{tmp119, tmp164})
									tmp166 := lang.Apply(tmp116, []any{tmp165})
									tmp167 := lang.Apply(tmp115, []any{tmp166})
									tmp168 := lang.Apply(tmp99, []any{tmp101, tmp103, tmp114, tmp167})
									tmp169 := lang.Apply(tmp98, []any{tmp168})
									tmp97 = tmp169
								} else {
									var tmp170 any
									{ // let
										// let binding "gi"
										tmp171 := checkDerefVar(glojure_DOT_core_gensym)
										tmp172 := lang.Apply(tmp171, []any{"i__"})
										var v173 any = tmp172
										_ = v173
										// let binding "gb"
										tmp174 := checkDerefVar(glojure_DOT_core_gensym)
										tmp175 := lang.Apply(tmp174, []any{"b__"})
										var v176 any = tmp175
										_ = v176
										// let binding "do-cmod"
										var tmp177 lang.FnFunc
										{ // function do-cmod
											var v178 lang.FnFunc
											tmp177 = lang.NewFnFunc(func(args ...any) any {
												if len(args) != 1 {
													panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
												}
												v179 := args[0]
												_ = v179
												var tmp180 any
												{ // let
													// let binding "vec__48"
													var v181 any = v179
													_ = v181
													// let binding "seq__49"
													tmp182 := checkDerefVar(glojure_DOT_core_seq)
													tmp183 := lang.Apply(tmp182, []any{v181})
													var v184 any = tmp183
													_ = v184
													// let binding "first__50"
													tmp185 := checkDerefVar(glojure_DOT_core_first)
													tmp186 := lang.Apply(tmp185, []any{v184})
													var v187 any = tmp186
													_ = v187
													// let binding "seq__49"
													tmp188 := checkDerefVar(glojure_DOT_core_next)
													tmp189 := lang.Apply(tmp188, []any{v184})
													var v190 any = tmp189
													_ = v190
													// let binding "vec__51"
													var v191 any = v187
													_ = v191
													// let binding "k"
													tmp192 := checkDerefVar(glojure_DOT_core_nth)
													tmp193 := lang.Apply(tmp192, []any{v191, int64(0), nil})
													var v194 any = tmp193
													_ = v194
													// let binding "v"
													tmp195 := checkDerefVar(glojure_DOT_core_nth)
													tmp196 := lang.Apply(tmp195, []any{v191, int64(1), nil})
													var v197 any = tmp196
													_ = v197
													// let binding "pair"
													var v198 any = v191
													_ = v198
													// let binding "etc"
													var v199 any = v190
													_ = v199
													var tmp200 any
													tmp201 := checkDerefVar(glojure_DOT_core__EQ_)
													tmp202 := lang.Apply(tmp201, []any{v194, lang.NewKeyword("let")})
													if lang.IsTruthy(tmp202) {
														tmp203 := checkDerefVar(glojure_DOT_core_seq)
														tmp204 := checkDerefVar(glojure_DOT_core_concat)
														tmp205 := checkDerefVar(glojure_DOT_core_list)
														tmp206 := lang.Apply(tmp205, []any{lang.NewSymbol("glojure.core/let")})
														tmp207 := checkDerefVar(glojure_DOT_core_list)
														tmp208 := lang.Apply(tmp207, []any{v197})
														tmp209 := checkDerefVar(glojure_DOT_core_list)
														tmp210 := lang.Apply(v178, []any{v199})
														tmp211 := lang.Apply(tmp209, []any{tmp210})
														tmp212 := lang.Apply(tmp204, []any{tmp206, tmp208, tmp211})
														tmp213 := lang.Apply(tmp203, []any{tmp212})
														tmp200 = tmp213
													} else {
														var tmp214 any
														tmp215 := checkDerefVar(glojure_DOT_core__EQ_)
														tmp216 := lang.Apply(tmp215, []any{v194, lang.NewKeyword("while")})
														if lang.IsTruthy(tmp216) {
															tmp217 := checkDerefVar(glojure_DOT_core_seq)
															tmp218 := checkDerefVar(glojure_DOT_core_concat)
															tmp219 := checkDerefVar(glojure_DOT_core_list)
															tmp220 := lang.Apply(tmp219, []any{lang.NewSymbol("glojure.core/when")})
															tmp221 := checkDerefVar(glojure_DOT_core_list)
															tmp222 := lang.Apply(tmp221, []any{v197})
															tmp223 := checkDerefVar(glojure_DOT_core_list)
															tmp224 := lang.Apply(v178, []any{v199})
															tmp225 := lang.Apply(tmp223, []any{tmp224})
															tmp226 := lang.Apply(tmp218, []any{tmp220, tmp222, tmp225})
															tmp227 := lang.Apply(tmp217, []any{tmp226})
															tmp214 = tmp227
														} else {
															var tmp228 any
															tmp229 := checkDerefVar(glojure_DOT_core__EQ_)
															tmp230 := lang.Apply(tmp229, []any{v194, lang.NewKeyword("when")})
															if lang.IsTruthy(tmp230) {
																tmp231 := checkDerefVar(glojure_DOT_core_seq)
																tmp232 := checkDerefVar(glojure_DOT_core_concat)
																tmp233 := checkDerefVar(glojure_DOT_core_list)
																tmp234 := lang.Apply(tmp233, []any{lang.NewSymbol("if")})
																tmp235 := checkDerefVar(glojure_DOT_core_list)
																tmp236 := lang.Apply(tmp235, []any{v197})
																tmp237 := checkDerefVar(glojure_DOT_core_list)
																tmp238 := lang.Apply(v178, []any{v199})
																tmp239 := lang.Apply(tmp237, []any{tmp238})
																tmp240 := checkDerefVar(glojure_DOT_core_list)
																tmp241 := checkDerefVar(glojure_DOT_core_seq)
																tmp242 := checkDerefVar(glojure_DOT_core_concat)
																tmp243 := checkDerefVar(glojure_DOT_core_list)
																tmp244 := lang.Apply(tmp243, []any{lang.NewSymbol("recur")})
																tmp245 := checkDerefVar(glojure_DOT_core_list)
																tmp246 := checkDerefVar(glojure_DOT_core_seq)
																tmp247 := checkDerefVar(glojure_DOT_core_concat)
																tmp248 := checkDerefVar(glojure_DOT_core_list)
																tmp249 := lang.Apply(tmp248, []any{lang.NewSymbol("glojure.core/unchecked-inc")})
																tmp250 := checkDerefVar(glojure_DOT_core_list)
																tmp251 := lang.Apply(tmp250, []any{v173})
																tmp252 := lang.Apply(tmp247, []any{tmp249, tmp251})
																tmp253 := lang.Apply(tmp246, []any{tmp252})
																tmp254 := lang.Apply(tmp245, []any{tmp253})
																tmp255 := lang.Apply(tmp242, []any{tmp244, tmp254})
																tmp256 := lang.Apply(tmp241, []any{tmp255})
																tmp257 := lang.Apply(tmp240, []any{tmp256})
																tmp258 := lang.Apply(tmp232, []any{tmp234, tmp236, tmp239, tmp257})
																tmp259 := lang.Apply(tmp231, []any{tmp258})
																tmp228 = tmp259
															} else {
																var tmp260 any
																tmp261 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
																tmp262 := lang.Apply(tmp261, []any{v194})
																if lang.IsTruthy(tmp262) {
																	tmp263 := lang.Apply(v41, []any{"Invalid 'for' keyword ", v194})
																	tmp260 = tmp263
																} else {
																	var tmp264 any
																	if lang.IsTruthy(lang.NewKeyword("else")) {
																		tmp265 := checkDerefVar(glojure_DOT_core_seq)
																		tmp266 := checkDerefVar(glojure_DOT_core_concat)
																		tmp267 := checkDerefVar(glojure_DOT_core_list)
																		tmp268 := lang.Apply(tmp267, []any{lang.NewSymbol("do")})
																		tmp269 := checkDerefVar(glojure_DOT_core_list)
																		tmp270 := checkDerefVar(glojure_DOT_core_seq)
																		tmp271 := checkDerefVar(glojure_DOT_core_concat)
																		tmp272 := checkDerefVar(glojure_DOT_core_list)
																		tmp273 := lang.Apply(tmp272, []any{lang.NewSymbol("glojure.core/chunk-append")})
																		tmp274 := checkDerefVar(glojure_DOT_core_list)
																		tmp275 := lang.Apply(tmp274, []any{v176})
																		tmp276 := checkDerefVar(glojure_DOT_core_list)
																		tmp277 := lang.Apply(tmp276, []any{v6})
																		tmp278 := lang.Apply(tmp271, []any{tmp273, tmp275, tmp277})
																		tmp279 := lang.Apply(tmp270, []any{tmp278})
																		tmp280 := lang.Apply(tmp269, []any{tmp279})
																		tmp281 := checkDerefVar(glojure_DOT_core_list)
																		tmp282 := checkDerefVar(glojure_DOT_core_seq)
																		tmp283 := checkDerefVar(glojure_DOT_core_concat)
																		tmp284 := checkDerefVar(glojure_DOT_core_list)
																		tmp285 := lang.Apply(tmp284, []any{lang.NewSymbol("recur")})
																		tmp286 := checkDerefVar(glojure_DOT_core_list)
																		tmp287 := checkDerefVar(glojure_DOT_core_seq)
																		tmp288 := checkDerefVar(glojure_DOT_core_concat)
																		tmp289 := checkDerefVar(glojure_DOT_core_list)
																		tmp290 := lang.Apply(tmp289, []any{lang.NewSymbol("glojure.core/unchecked-inc")})
																		tmp291 := checkDerefVar(glojure_DOT_core_list)
																		tmp292 := lang.Apply(tmp291, []any{v173})
																		tmp293 := lang.Apply(tmp288, []any{tmp290, tmp292})
																		tmp294 := lang.Apply(tmp287, []any{tmp293})
																		tmp295 := lang.Apply(tmp286, []any{tmp294})
																		tmp296 := lang.Apply(tmp283, []any{tmp285, tmp295})
																		tmp297 := lang.Apply(tmp282, []any{tmp296})
																		tmp298 := lang.Apply(tmp281, []any{tmp297})
																		tmp299 := lang.Apply(tmp266, []any{tmp268, tmp280, tmp298})
																		tmp300 := lang.Apply(tmp265, []any{tmp299})
																		tmp264 = tmp300
																	} else {
																	}
																	tmp260 = tmp264
																}
																tmp228 = tmp260
															}
															tmp214 = tmp228
														}
														tmp200 = tmp214
													}
													tmp180 = tmp200
												} // end let
												return tmp180
											})
											v178 = tmp177
											_ = v178
										}
										tmp178 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4698), lang.NewKeyword("column"), int(39), lang.NewKeyword("end-line"), int(4710), lang.NewKeyword("end-column"), int(79))
										tmp179, err := lang.WithMeta(tmp177, tmp178.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										var v180 any = tmp179
										_ = v180
										tmp181 := checkDerefVar(glojure_DOT_core_seq)
										tmp182 := checkDerefVar(glojure_DOT_core_concat)
										tmp183 := checkDerefVar(glojure_DOT_core_list)
										tmp184 := lang.Apply(tmp183, []any{lang.NewSymbol("glojure.core/fn")})
										tmp185 := checkDerefVar(glojure_DOT_core_list)
										tmp186 := lang.Apply(tmp185, []any{v89})
										tmp187 := checkDerefVar(glojure_DOT_core_list)
										tmp188 := checkDerefVar(glojure_DOT_core_apply)
										tmp189 := checkDerefVar(glojure_DOT_core_vector)
										tmp190 := checkDerefVar(glojure_DOT_core_seq)
										tmp191 := checkDerefVar(glojure_DOT_core_concat)
										tmp192 := checkDerefVar(glojure_DOT_core_list)
										tmp193 := lang.Apply(tmp192, []any{v92})
										tmp194 := lang.Apply(tmp191, []any{tmp193})
										tmp195 := lang.Apply(tmp190, []any{tmp194})
										tmp196 := lang.Apply(tmp188, []any{tmp189, tmp195})
										tmp197 := lang.Apply(tmp187, []any{tmp196})
										tmp198 := checkDerefVar(glojure_DOT_core_list)
										tmp199 := checkDerefVar(glojure_DOT_core_seq)
										tmp200 := checkDerefVar(glojure_DOT_core_concat)
										tmp201 := checkDerefVar(glojure_DOT_core_list)
										tmp202 := lang.Apply(tmp201, []any{lang.NewSymbol("glojure.core/lazy-seq")})
										tmp203 := checkDerefVar(glojure_DOT_core_list)
										tmp204 := checkDerefVar(glojure_DOT_core_seq)
										tmp205 := checkDerefVar(glojure_DOT_core_concat)
										tmp206 := checkDerefVar(glojure_DOT_core_list)
										tmp207 := lang.Apply(tmp206, []any{lang.NewSymbol("glojure.core/loop")})
										tmp208 := checkDerefVar(glojure_DOT_core_list)
										tmp209 := checkDerefVar(glojure_DOT_core_apply)
										tmp210 := checkDerefVar(glojure_DOT_core_vector)
										tmp211 := checkDerefVar(glojure_DOT_core_seq)
										tmp212 := checkDerefVar(glojure_DOT_core_concat)
										tmp213 := checkDerefVar(glojure_DOT_core_list)
										tmp214 := lang.Apply(tmp213, []any{v92})
										tmp215 := checkDerefVar(glojure_DOT_core_list)
										tmp216 := lang.Apply(tmp215, []any{v92})
										tmp217 := lang.Apply(tmp212, []any{tmp214, tmp216})
										tmp218 := lang.Apply(tmp211, []any{tmp217})
										tmp219 := lang.Apply(tmp209, []any{tmp210, tmp218})
										tmp220 := lang.Apply(tmp208, []any{tmp219})
										tmp221 := checkDerefVar(glojure_DOT_core_list)
										tmp222 := checkDerefVar(glojure_DOT_core_seq)
										tmp223 := checkDerefVar(glojure_DOT_core_concat)
										tmp224 := checkDerefVar(glojure_DOT_core_list)
										tmp225 := lang.Apply(tmp224, []any{lang.NewSymbol("glojure.core/when-let")})
										tmp226 := checkDerefVar(glojure_DOT_core_list)
										tmp227 := checkDerefVar(glojure_DOT_core_apply)
										tmp228 := checkDerefVar(glojure_DOT_core_vector)
										tmp229 := checkDerefVar(glojure_DOT_core_seq)
										tmp230 := checkDerefVar(glojure_DOT_core_concat)
										tmp231 := checkDerefVar(glojure_DOT_core_list)
										tmp232 := lang.Apply(tmp231, []any{v92})
										tmp233 := checkDerefVar(glojure_DOT_core_list)
										tmp234 := checkDerefVar(glojure_DOT_core_seq)
										tmp235 := checkDerefVar(glojure_DOT_core_concat)
										tmp236 := checkDerefVar(glojure_DOT_core_list)
										tmp237 := lang.Apply(tmp236, []any{lang.NewSymbol("glojure.core/seq")})
										tmp238 := checkDerefVar(glojure_DOT_core_list)
										tmp239 := lang.Apply(tmp238, []any{v92})
										tmp240 := lang.Apply(tmp235, []any{tmp237, tmp239})
										tmp241 := lang.Apply(tmp234, []any{tmp240})
										tmp242 := lang.Apply(tmp233, []any{tmp241})
										tmp243 := lang.Apply(tmp230, []any{tmp232, tmp242})
										tmp244 := lang.Apply(tmp229, []any{tmp243})
										tmp245 := lang.Apply(tmp227, []any{tmp228, tmp244})
										tmp246 := lang.Apply(tmp226, []any{tmp245})
										tmp247 := checkDerefVar(glojure_DOT_core_list)
										tmp248 := checkDerefVar(glojure_DOT_core_seq)
										tmp249 := checkDerefVar(glojure_DOT_core_concat)
										tmp250 := checkDerefVar(glojure_DOT_core_list)
										tmp251 := lang.Apply(tmp250, []any{lang.NewSymbol("if")})
										tmp252 := checkDerefVar(glojure_DOT_core_list)
										tmp253 := checkDerefVar(glojure_DOT_core_seq)
										tmp254 := checkDerefVar(glojure_DOT_core_concat)
										tmp255 := checkDerefVar(glojure_DOT_core_list)
										tmp256 := lang.Apply(tmp255, []any{lang.NewSymbol("glojure.core/chunked-seq?")})
										tmp257 := checkDerefVar(glojure_DOT_core_list)
										tmp258 := lang.Apply(tmp257, []any{v92})
										tmp259 := lang.Apply(tmp254, []any{tmp256, tmp258})
										tmp260 := lang.Apply(tmp253, []any{tmp259})
										tmp261 := lang.Apply(tmp252, []any{tmp260})
										tmp262 := checkDerefVar(glojure_DOT_core_list)
										tmp263 := checkDerefVar(glojure_DOT_core_seq)
										tmp264 := checkDerefVar(glojure_DOT_core_concat)
										tmp265 := checkDerefVar(glojure_DOT_core_list)
										tmp266 := lang.Apply(tmp265, []any{lang.NewSymbol("glojure.core/let")})
										tmp267 := checkDerefVar(glojure_DOT_core_list)
										tmp268 := checkDerefVar(glojure_DOT_core_apply)
										tmp269 := checkDerefVar(glojure_DOT_core_vector)
										tmp270 := checkDerefVar(glojure_DOT_core_seq)
										tmp271 := checkDerefVar(glojure_DOT_core_concat)
										tmp272 := checkDerefVar(glojure_DOT_core_list)
										tmp273 := lang.Apply(tmp272, []any{lang.NewSymbol("c__0__auto__")})
										tmp274 := checkDerefVar(glojure_DOT_core_list)
										tmp275 := checkDerefVar(glojure_DOT_core_seq)
										tmp276 := checkDerefVar(glojure_DOT_core_concat)
										tmp277 := checkDerefVar(glojure_DOT_core_list)
										tmp278 := lang.Apply(tmp277, []any{lang.NewSymbol("glojure.core/chunk-first")})
										tmp279 := checkDerefVar(glojure_DOT_core_list)
										tmp280 := lang.Apply(tmp279, []any{v92})
										tmp281 := lang.Apply(tmp276, []any{tmp278, tmp280})
										tmp282 := lang.Apply(tmp275, []any{tmp281})
										tmp283 := lang.Apply(tmp274, []any{tmp282})
										tmp284 := checkDerefVar(glojure_DOT_core_list)
										tmp285 := lang.Apply(tmp284, []any{lang.NewSymbol("size__1__auto__")})
										tmp286 := checkDerefVar(glojure_DOT_core_list)
										tmp287 := checkDerefVar(glojure_DOT_core_seq)
										tmp288 := checkDerefVar(glojure_DOT_core_concat)
										tmp289 := checkDerefVar(glojure_DOT_core_list)
										tmp290 := lang.Apply(tmp289, []any{lang.NewSymbol("glojure.core/int")})
										tmp291 := checkDerefVar(glojure_DOT_core_list)
										tmp292 := checkDerefVar(glojure_DOT_core_seq)
										tmp293 := checkDerefVar(glojure_DOT_core_concat)
										tmp294 := checkDerefVar(glojure_DOT_core_list)
										tmp295 := lang.Apply(tmp294, []any{lang.NewSymbol("glojure.core/count")})
										tmp296 := checkDerefVar(glojure_DOT_core_list)
										tmp297 := lang.Apply(tmp296, []any{lang.NewSymbol("c__0__auto__")})
										tmp298 := lang.Apply(tmp293, []any{tmp295, tmp297})
										tmp299 := lang.Apply(tmp292, []any{tmp298})
										tmp300 := lang.Apply(tmp291, []any{tmp299})
										tmp301 := lang.Apply(tmp288, []any{tmp290, tmp300})
										tmp302 := lang.Apply(tmp287, []any{tmp301})
										tmp303 := lang.Apply(tmp286, []any{tmp302})
										tmp304 := checkDerefVar(glojure_DOT_core_list)
										tmp305 := lang.Apply(tmp304, []any{v176})
										tmp306 := checkDerefVar(glojure_DOT_core_list)
										tmp307 := checkDerefVar(glojure_DOT_core_seq)
										tmp308 := checkDerefVar(glojure_DOT_core_concat)
										tmp309 := checkDerefVar(glojure_DOT_core_list)
										tmp310 := lang.Apply(tmp309, []any{lang.NewSymbol("glojure.core/chunk-buffer")})
										tmp311 := checkDerefVar(glojure_DOT_core_list)
										tmp312 := lang.Apply(tmp311, []any{lang.NewSymbol("size__1__auto__")})
										tmp313 := lang.Apply(tmp308, []any{tmp310, tmp312})
										tmp314 := lang.Apply(tmp307, []any{tmp313})
										tmp315 := lang.Apply(tmp306, []any{tmp314})
										tmp316 := lang.Apply(tmp271, []any{tmp273, tmp283, tmp285, tmp303, tmp305, tmp315})
										tmp317 := lang.Apply(tmp270, []any{tmp316})
										tmp318 := lang.Apply(tmp268, []any{tmp269, tmp317})
										tmp319 := lang.Apply(tmp267, []any{tmp318})
										tmp320 := checkDerefVar(glojure_DOT_core_list)
										tmp321 := checkDerefVar(glojure_DOT_core_seq)
										tmp322 := checkDerefVar(glojure_DOT_core_concat)
										tmp323 := checkDerefVar(glojure_DOT_core_list)
										tmp324 := lang.Apply(tmp323, []any{lang.NewSymbol("if")})
										tmp325 := checkDerefVar(glojure_DOT_core_list)
										tmp326 := checkDerefVar(glojure_DOT_core_seq)
										tmp327 := checkDerefVar(glojure_DOT_core_concat)
										tmp328 := checkDerefVar(glojure_DOT_core_list)
										tmp329 := lang.Apply(tmp328, []any{lang.NewSymbol("glojure.core/loop")})
										tmp330 := checkDerefVar(glojure_DOT_core_list)
										tmp331 := checkDerefVar(glojure_DOT_core_apply)
										tmp332 := checkDerefVar(glojure_DOT_core_vector)
										tmp333 := checkDerefVar(glojure_DOT_core_seq)
										tmp334 := checkDerefVar(glojure_DOT_core_concat)
										tmp335 := checkDerefVar(glojure_DOT_core_list)
										tmp336 := lang.Apply(tmp335, []any{v173})
										tmp337 := checkDerefVar(glojure_DOT_core_list)
										tmp338 := checkDerefVar(glojure_DOT_core_seq)
										tmp339 := checkDerefVar(glojure_DOT_core_concat)
										tmp340 := checkDerefVar(glojure_DOT_core_list)
										tmp341 := lang.Apply(tmp340, []any{lang.NewSymbol("glojure.core/int")})
										tmp342 := checkDerefVar(glojure_DOT_core_list)
										tmp343 := lang.Apply(tmp342, []any{int64(0)})
										tmp344 := lang.Apply(tmp339, []any{tmp341, tmp343})
										tmp345 := lang.Apply(tmp338, []any{tmp344})
										tmp346 := lang.Apply(tmp337, []any{tmp345})
										tmp347 := lang.Apply(tmp334, []any{tmp336, tmp346})
										tmp348 := lang.Apply(tmp333, []any{tmp347})
										tmp349 := lang.Apply(tmp331, []any{tmp332, tmp348})
										tmp350 := lang.Apply(tmp330, []any{tmp349})
										tmp351 := checkDerefVar(glojure_DOT_core_list)
										tmp352 := checkDerefVar(glojure_DOT_core_seq)
										tmp353 := checkDerefVar(glojure_DOT_core_concat)
										tmp354 := checkDerefVar(glojure_DOT_core_list)
										tmp355 := lang.Apply(tmp354, []any{lang.NewSymbol("if")})
										tmp356 := checkDerefVar(glojure_DOT_core_list)
										tmp357 := checkDerefVar(glojure_DOT_core_seq)
										tmp358 := checkDerefVar(glojure_DOT_core_concat)
										tmp359 := checkDerefVar(glojure_DOT_core_list)
										tmp360 := lang.Apply(tmp359, []any{lang.NewSymbol("glojure.core/<")})
										tmp361 := checkDerefVar(glojure_DOT_core_list)
										tmp362 := lang.Apply(tmp361, []any{v173})
										tmp363 := checkDerefVar(glojure_DOT_core_list)
										tmp364 := lang.Apply(tmp363, []any{lang.NewSymbol("size__1__auto__")})
										tmp365 := lang.Apply(tmp358, []any{tmp360, tmp362, tmp364})
										tmp366 := lang.Apply(tmp357, []any{tmp365})
										tmp367 := lang.Apply(tmp356, []any{tmp366})
										tmp368 := checkDerefVar(glojure_DOT_core_list)
										tmp369 := checkDerefVar(glojure_DOT_core_seq)
										tmp370 := checkDerefVar(glojure_DOT_core_concat)
										tmp371 := checkDerefVar(glojure_DOT_core_list)
										tmp372 := lang.Apply(tmp371, []any{lang.NewSymbol("glojure.core/let")})
										tmp373 := checkDerefVar(glojure_DOT_core_list)
										tmp374 := checkDerefVar(glojure_DOT_core_apply)
										tmp375 := checkDerefVar(glojure_DOT_core_vector)
										tmp376 := checkDerefVar(glojure_DOT_core_seq)
										tmp377 := checkDerefVar(glojure_DOT_core_concat)
										tmp378 := checkDerefVar(glojure_DOT_core_list)
										tmp379 := lang.Apply(tmp378, []any{v66})
										tmp380 := checkDerefVar(glojure_DOT_core_list)
										tmp381 := checkDerefVar(glojure_DOT_core_seq)
										tmp382 := checkDerefVar(glojure_DOT_core_concat)
										tmp383 := checkDerefVar(glojure_DOT_core_list)
										tmp384 := lang.Apply(tmp383, []any{lang.NewSymbol(".nth")})
										tmp385 := checkDerefVar(glojure_DOT_core_list)
										tmp386 := lang.Apply(tmp385, []any{lang.NewSymbol("c__0__auto__")})
										tmp387 := checkDerefVar(glojure_DOT_core_list)
										tmp388 := lang.Apply(tmp387, []any{v173})
										tmp389 := lang.Apply(tmp382, []any{tmp384, tmp386, tmp388})
										tmp390 := lang.Apply(tmp381, []any{tmp389})
										tmp391 := lang.Apply(tmp380, []any{tmp390})
										tmp392 := lang.Apply(tmp377, []any{tmp379, tmp391})
										tmp393 := lang.Apply(tmp376, []any{tmp392})
										tmp394 := lang.Apply(tmp374, []any{tmp375, tmp393})
										tmp395 := lang.Apply(tmp373, []any{tmp394})
										tmp396 := checkDerefVar(glojure_DOT_core_list)
										tmp397 := lang.Apply(v180, []any{v74})
										tmp398 := lang.Apply(tmp396, []any{tmp397})
										tmp399 := lang.Apply(tmp370, []any{tmp372, tmp395, tmp398})
										tmp400 := lang.Apply(tmp369, []any{tmp399})
										tmp401 := lang.Apply(tmp368, []any{tmp400})
										tmp402 := checkDerefVar(glojure_DOT_core_list)
										tmp403 := lang.Apply(tmp402, []any{true})
										tmp404 := lang.Apply(tmp353, []any{tmp355, tmp367, tmp401, tmp403})
										tmp405 := lang.Apply(tmp352, []any{tmp404})
										tmp406 := lang.Apply(tmp351, []any{tmp405})
										tmp407 := lang.Apply(tmp327, []any{tmp329, tmp350, tmp406})
										tmp408 := lang.Apply(tmp326, []any{tmp407})
										tmp409 := lang.Apply(tmp325, []any{tmp408})
										tmp410 := checkDerefVar(glojure_DOT_core_list)
										tmp411 := checkDerefVar(glojure_DOT_core_seq)
										tmp412 := checkDerefVar(glojure_DOT_core_concat)
										tmp413 := checkDerefVar(glojure_DOT_core_list)
										tmp414 := lang.Apply(tmp413, []any{lang.NewSymbol("glojure.core/chunk-cons")})
										tmp415 := checkDerefVar(glojure_DOT_core_list)
										tmp416 := checkDerefVar(glojure_DOT_core_seq)
										tmp417 := checkDerefVar(glojure_DOT_core_concat)
										tmp418 := checkDerefVar(glojure_DOT_core_list)
										tmp419 := lang.Apply(tmp418, []any{lang.NewSymbol("glojure.core/chunk")})
										tmp420 := checkDerefVar(glojure_DOT_core_list)
										tmp421 := lang.Apply(tmp420, []any{v176})
										tmp422 := lang.Apply(tmp417, []any{tmp419, tmp421})
										tmp423 := lang.Apply(tmp416, []any{tmp422})
										tmp424 := lang.Apply(tmp415, []any{tmp423})
										tmp425 := checkDerefVar(glojure_DOT_core_list)
										tmp426 := checkDerefVar(glojure_DOT_core_seq)
										tmp427 := checkDerefVar(glojure_DOT_core_concat)
										tmp428 := checkDerefVar(glojure_DOT_core_list)
										tmp429 := lang.Apply(tmp428, []any{v89})
										tmp430 := checkDerefVar(glojure_DOT_core_list)
										tmp431 := checkDerefVar(glojure_DOT_core_seq)
										tmp432 := checkDerefVar(glojure_DOT_core_concat)
										tmp433 := checkDerefVar(glojure_DOT_core_list)
										tmp434 := lang.Apply(tmp433, []any{lang.NewSymbol("glojure.core/chunk-rest")})
										tmp435 := checkDerefVar(glojure_DOT_core_list)
										tmp436 := lang.Apply(tmp435, []any{v92})
										tmp437 := lang.Apply(tmp432, []any{tmp434, tmp436})
										tmp438 := lang.Apply(tmp431, []any{tmp437})
										tmp439 := lang.Apply(tmp430, []any{tmp438})
										tmp440 := lang.Apply(tmp427, []any{tmp429, tmp439})
										tmp441 := lang.Apply(tmp426, []any{tmp440})
										tmp442 := lang.Apply(tmp425, []any{tmp441})
										tmp443 := lang.Apply(tmp412, []any{tmp414, tmp424, tmp442})
										tmp444 := lang.Apply(tmp411, []any{tmp443})
										tmp445 := lang.Apply(tmp410, []any{tmp444})
										tmp446 := checkDerefVar(glojure_DOT_core_list)
										tmp447 := checkDerefVar(glojure_DOT_core_seq)
										tmp448 := checkDerefVar(glojure_DOT_core_concat)
										tmp449 := checkDerefVar(glojure_DOT_core_list)
										tmp450 := lang.Apply(tmp449, []any{lang.NewSymbol("glojure.core/chunk-cons")})
										tmp451 := checkDerefVar(glojure_DOT_core_list)
										tmp452 := checkDerefVar(glojure_DOT_core_seq)
										tmp453 := checkDerefVar(glojure_DOT_core_concat)
										tmp454 := checkDerefVar(glojure_DOT_core_list)
										tmp455 := lang.Apply(tmp454, []any{lang.NewSymbol("glojure.core/chunk")})
										tmp456 := checkDerefVar(glojure_DOT_core_list)
										tmp457 := lang.Apply(tmp456, []any{v176})
										tmp458 := lang.Apply(tmp453, []any{tmp455, tmp457})
										tmp459 := lang.Apply(tmp452, []any{tmp458})
										tmp460 := lang.Apply(tmp451, []any{tmp459})
										tmp461 := checkDerefVar(glojure_DOT_core_list)
										tmp462 := lang.Apply(tmp461, []any{nil})
										tmp463 := lang.Apply(tmp448, []any{tmp450, tmp460, tmp462})
										tmp464 := lang.Apply(tmp447, []any{tmp463})
										tmp465 := lang.Apply(tmp446, []any{tmp464})
										tmp466 := lang.Apply(tmp322, []any{tmp324, tmp409, tmp445, tmp465})
										tmp467 := lang.Apply(tmp321, []any{tmp466})
										tmp468 := lang.Apply(tmp320, []any{tmp467})
										tmp469 := lang.Apply(tmp264, []any{tmp266, tmp319, tmp468})
										tmp470 := lang.Apply(tmp263, []any{tmp469})
										tmp471 := lang.Apply(tmp262, []any{tmp470})
										tmp472 := checkDerefVar(glojure_DOT_core_list)
										tmp473 := checkDerefVar(glojure_DOT_core_seq)
										tmp474 := checkDerefVar(glojure_DOT_core_concat)
										tmp475 := checkDerefVar(glojure_DOT_core_list)
										tmp476 := lang.Apply(tmp475, []any{lang.NewSymbol("glojure.core/let")})
										tmp477 := checkDerefVar(glojure_DOT_core_list)
										tmp478 := checkDerefVar(glojure_DOT_core_apply)
										tmp479 := checkDerefVar(glojure_DOT_core_vector)
										tmp480 := checkDerefVar(glojure_DOT_core_seq)
										tmp481 := checkDerefVar(glojure_DOT_core_concat)
										tmp482 := checkDerefVar(glojure_DOT_core_list)
										tmp483 := lang.Apply(tmp482, []any{v66})
										tmp484 := checkDerefVar(glojure_DOT_core_list)
										tmp485 := checkDerefVar(glojure_DOT_core_seq)
										tmp486 := checkDerefVar(glojure_DOT_core_concat)
										tmp487 := checkDerefVar(glojure_DOT_core_list)
										tmp488 := lang.Apply(tmp487, []any{lang.NewSymbol("glojure.core/first")})
										tmp489 := checkDerefVar(glojure_DOT_core_list)
										tmp490 := lang.Apply(tmp489, []any{v92})
										tmp491 := lang.Apply(tmp486, []any{tmp488, tmp490})
										tmp492 := lang.Apply(tmp485, []any{tmp491})
										tmp493 := lang.Apply(tmp484, []any{tmp492})
										tmp494 := lang.Apply(tmp481, []any{tmp483, tmp493})
										tmp495 := lang.Apply(tmp480, []any{tmp494})
										tmp496 := lang.Apply(tmp478, []any{tmp479, tmp495})
										tmp497 := lang.Apply(tmp477, []any{tmp496})
										tmp498 := checkDerefVar(glojure_DOT_core_list)
										tmp499 := lang.Apply(v96, []any{v74})
										tmp500 := lang.Apply(tmp498, []any{tmp499})
										tmp501 := lang.Apply(tmp474, []any{tmp476, tmp497, tmp500})
										tmp502 := lang.Apply(tmp473, []any{tmp501})
										tmp503 := lang.Apply(tmp472, []any{tmp502})
										tmp504 := lang.Apply(tmp249, []any{tmp251, tmp261, tmp471, tmp503})
										tmp505 := lang.Apply(tmp248, []any{tmp504})
										tmp506 := lang.Apply(tmp247, []any{tmp505})
										tmp507 := lang.Apply(tmp223, []any{tmp225, tmp246, tmp506})
										tmp508 := lang.Apply(tmp222, []any{tmp507})
										tmp509 := lang.Apply(tmp221, []any{tmp508})
										tmp510 := lang.Apply(tmp205, []any{tmp207, tmp220, tmp509})
										tmp511 := lang.Apply(tmp204, []any{tmp510})
										tmp512 := lang.Apply(tmp203, []any{tmp511})
										tmp513 := lang.Apply(tmp200, []any{tmp202, tmp512})
										tmp514 := lang.Apply(tmp199, []any{tmp513})
										tmp515 := lang.Apply(tmp198, []any{tmp514})
										tmp516 := lang.Apply(tmp182, []any{tmp184, tmp186, tmp197, tmp515})
										tmp517 := lang.Apply(tmp181, []any{tmp516})
										tmp170 = tmp517
									} // end let
									tmp97 = tmp170
								}
								tmp86 = tmp97
							} // end let
							tmp45 = tmp86
						} // end let
						return tmp45
					})
					v43 = tmp42
					_ = v43
				}
				tmp43 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4668), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(4729), lang.NewKeyword("end-column"), int(68))
				tmp44, err := lang.WithMeta(tmp42, tmp43.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v45 any = tmp44
				_ = v45
				tmp46 := checkDerefVar(glojure_DOT_core_seq)
				tmp47 := checkDerefVar(glojure_DOT_core_concat)
				tmp48 := checkDerefVar(glojure_DOT_core_list)
				tmp49 := lang.Apply(tmp48, []any{lang.NewSymbol("glojure.core/let")})
				tmp50 := checkDerefVar(glojure_DOT_core_list)
				tmp51 := checkDerefVar(glojure_DOT_core_apply)
				tmp52 := checkDerefVar(glojure_DOT_core_vector)
				tmp53 := checkDerefVar(glojure_DOT_core_seq)
				tmp54 := checkDerefVar(glojure_DOT_core_concat)
				tmp55 := checkDerefVar(glojure_DOT_core_list)
				tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("iter__0__auto__")})
				tmp57 := checkDerefVar(glojure_DOT_core_list)
				tmp58 := lang.Apply(v37, []any{v5})
				tmp59 := lang.Apply(v45, []any{tmp58})
				tmp60 := lang.Apply(tmp57, []any{tmp59})
				tmp61 := lang.Apply(tmp54, []any{tmp56, tmp60})
				tmp62 := lang.Apply(tmp53, []any{tmp61})
				tmp63 := lang.Apply(tmp51, []any{tmp52, tmp62})
				tmp64 := lang.Apply(tmp50, []any{tmp63})
				tmp65 := checkDerefVar(glojure_DOT_core_list)
				tmp66 := checkDerefVar(glojure_DOT_core_seq)
				tmp67 := checkDerefVar(glojure_DOT_core_concat)
				tmp68 := checkDerefVar(glojure_DOT_core_list)
				tmp69 := lang.Apply(tmp68, []any{lang.NewSymbol("iter__0__auto__")})
				tmp70 := checkDerefVar(glojure_DOT_core_list)
				tmp71 := checkDerefVar(glojure_DOT_core_second)
				tmp72 := lang.Apply(tmp71, []any{v5})
				tmp73 := lang.Apply(tmp70, []any{tmp72})
				tmp74 := lang.Apply(tmp67, []any{tmp69, tmp73})
				tmp75 := lang.Apply(tmp66, []any{tmp74})
				tmp76 := lang.Apply(tmp65, []any{tmp75})
				tmp77 := lang.Apply(tmp47, []any{tmp49, tmp64, tmp76})
				tmp78 := lang.Apply(tmp46, []any{tmp77})
				tmp33 = tmp78
			} // end let
			return tmp33
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// force
	{
		tmp0 := lang.NewSymbol("force").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(754), lang.NewKeyword("end-line"), int(754))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(nil, "force")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("force is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// format
	{
		tmp0 := lang.NewSymbol("format").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("fmt"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Formats a string using java.lang.String.format, see java.util.Formatter for format\n  string syntax", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5717), lang.NewKeyword("end-line"), int(5717))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_apply)
				tmp6 := lang.Apply(tmp5, []any{fmt.Sprintf, v3, v4})
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// frequencies
	{
		tmp0 := lang.NewSymbol("frequencies").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a map from distinct items in coll to the number of times\n  they appear.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7185), lang.NewKeyword("end-line"), int(7185))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
			tmp5 := checkDerefVar(glojure_DOT_core_reduce)
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v7 := args[0]
				_ = v7
				v8 := args[1]
				_ = v8
				tmp9 := checkDerefVar(glojure_DOT_core_assoc_BANG_)
				tmp10 := checkDerefVar(glojure_DOT_core_inc)
				tmp11 := checkDerefVar(glojure_DOT_core_get)
				tmp12 := lang.Apply(tmp11, []any{v7, v8, int64(0)})
				tmp13 := lang.Apply(tmp10, []any{tmp12})
				tmp14 := lang.Apply(tmp9, []any{v7, v8, tmp13})
				return tmp14
			})
			tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7192), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(7193), lang.NewKeyword("end-column"), int(54))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := checkDerefVar(glojure_DOT_core_transient)
			tmp10 := lang.NewMap()
			tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7194), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(7194), lang.NewKeyword("end-column"), int(24))
			tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp13 := lang.Apply(tmp9, []any{tmp12})
			tmp14 := lang.Apply(tmp5, []any{tmp8, tmp13, v3})
			tmp15 := lang.Apply(tmp4, []any{tmp14})
			return tmp15
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future
	{
		tmp0 := lang.NewSymbol("future").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Takes a body of expressions and yields a future object that will\n  invoke the body in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant of\n  deref with timeout is used. See also - realized?.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7009), lang.NewKeyword("end-line"), int(7009))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_concat)
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("glojure.core/future-call")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("fn*")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := checkDerefVar(glojure_DOT_core_apply)
				tmp17 := checkDerefVar(glojure_DOT_core_vector)
				tmp18 := checkDerefVar(glojure_DOT_core_seq)
				tmp19 := checkDerefVar(glojure_DOT_core_concat)
				tmp20 := lang.Apply(tmp19, nil)
				tmp21 := lang.Apply(tmp18, []any{tmp20})
				tmp22 := lang.Apply(tmp16, []any{tmp17, tmp21})
				tmp23 := lang.Apply(tmp15, []any{tmp22})
				tmp24 := lang.Apply(tmp12, []any{tmp14, tmp23, v5})
				tmp25 := lang.Apply(tmp11, []any{tmp24})
				tmp26 := lang.Apply(tmp10, []any{tmp25})
				tmp27 := lang.Apply(tmp7, []any{tmp9, tmp26})
				tmp28 := lang.Apply(tmp6, []any{tmp27})
				return tmp28
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-call
	{
		tmp0 := lang.NewSymbol("future-call").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Takes a function of no args and yields a future object that will\n  invoke the function in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant\n  of deref with timeout is used. See also - realized?.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7003), lang.NewKeyword("end-line"), int(7003))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "f"
				tmp5 := checkDerefVar(glojure_DOT_core_binding_conveyor_fn)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				// let binding "fut"
				tmp8 := lang.Apply(lang.AgentSubmit, []any{v7})
				var v9 any = tmp8
				_ = v9
				tmp4 = v9
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-cancel
	{
		tmp0 := lang.NewSymbol("future-cancel").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Cancels the future, if possible.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7019), lang.NewKeyword("end-line"), int(7019))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "cancel")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("cancel is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{true})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-cancelled?
	{
		tmp0 := lang.NewSymbol("future-cancelled?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Returns true if future f is cancelled", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7025), lang.NewKeyword("end-line"), int(7025))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "isCancelled")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isCancelled")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-done?
	{
		tmp0 := lang.NewSymbol("future-done?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Returns true if future f is done", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6538), lang.NewKeyword("end-line"), int(6538))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "isDone")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isDone")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future?
	{
		tmp0 := lang.NewSymbol("future?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is a future", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6532), lang.NewKeyword("end-line"), int(6532))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// gen-class
	{
		tmp0 := lang.NewSymbol("gen-class").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// gensym
	{
		tmp0 := lang.NewSymbol("gensym").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("prefix-string"))), lang.NewKeyword("doc"), "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(599), lang.NewKeyword("end-line"), int(599))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(glojure_DOT_core_gensym)
				tmp4 := lang.Apply(tmp3, []any{"G__"})
				return tmp4
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_str)
				tmp5 := checkDerefVar(glojure_DOT_core_str)
				tmp6, _ := lang.FieldOrMethod(runtime7.RT, "NextID")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("NextID is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				tmp9 := lang.Apply(tmp4, []any{v3, tmp8})
				tmp10 := lang.Apply(lang.NewSymbol, []any{tmp9})
				return tmp10
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get
	{
		var tmp1 lang.FnFunc
		{ // function get__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					var v5 any = lang.NewList(args[2:]...)
					_ = v5
					tmp6 := checkDerefVar(glojure_DOT_core_seq)
					tmp7 := checkDerefVar(glojure_DOT_core_concat)
					tmp8 := checkDerefVar(glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol(".")})
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/Get")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v4})
					tmp21 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp20, v5})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp12, []any{tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp23})
					tmp25 := lang.Apply(tmp6, []any{tmp24})
					return tmp25
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("get").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"), lang.NewSymbol("not-found"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the value mapped to key, not-found or nil if key not present\n  in associative collection, set, string, array, or ILookup instance.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2), int64(3)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1489), lang.NewKeyword("end-line"), int(1489))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.Get, []any{v4, v5})
				return tmp6
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(lang.GetDefault, []any{v4, v5, v6})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-in
	{
		tmp0 := lang.NewSymbol("get-in").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("ks")), lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("ks"), lang.NewSymbol("not-found"))), lang.NewKeyword("doc"), "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key\n  is not present, or the not-found value if supplied.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6128), lang.NewKeyword("end-line"), int(6128))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp6 := checkDerefVar(glojure_DOT_core_get)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3, v4})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "sentinel"
					tmp7 := lang.Apply(reflect.StructOf, []any{nil})
					tmp8 := lang.Apply(reflect.New, []any{tmp7})
					tmp9, ok := lang.FieldOrMethod(tmp8, "Interface")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp8, "Interface")))
					}
					var tmp10 any
					switch reflect.TypeOf(tmp9).Kind() {
					case reflect.Func:
						tmp10 = lang.Apply(tmp9, nil)
					default:
						tmp10 = tmp9
					}
					var v11 any = tmp10
					_ = v11
					// let binding "m"
					var v12 any = v3
					_ = v12
					// let binding "ks"
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := lang.Apply(tmp13, []any{v4})
					var v15 any = tmp14
					_ = v15
					for {
						var tmp16 any
						if lang.IsTruthy(v15) {
							var tmp17 any
							{ // let
								// let binding "m"
								tmp18 := checkDerefVar(glojure_DOT_core_get)
								tmp19 := checkDerefVar(glojure_DOT_core_first)
								tmp20 := lang.Apply(tmp19, []any{v15})
								tmp21 := lang.Apply(tmp18, []any{v12, tmp20, v11})
								var v22 any = tmp21
								_ = v22
								var tmp23 any
								tmp24 := checkDerefVar(glojure_DOT_core_identical_QMARK_)
								tmp25 := lang.Apply(tmp24, []any{v11, v22})
								if lang.IsTruthy(tmp25) {
									tmp23 = v5
								} else {
									var tmp26 any = v11
									var tmp27 any = v22
									tmp29 := checkDerefVar(glojure_DOT_core_next)
									tmp30 := lang.Apply(tmp29, []any{v15})
									var tmp28 any = tmp30
									v11 = tmp26
									v12 = tmp27
									v15 = tmp28
									continue
								}
								tmp17 = tmp23
							} // end let
							tmp16 = tmp17
						} else {
							tmp16 = v12
						}
						tmp6 = tmp16
						break
					}
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-method
	{
		tmp0 := lang.NewSymbol("get-method").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"), lang.NewSymbol("dispatch-val"))), lang.NewKeyword("doc"), "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1815), lang.NewKeyword("end-line"), int(1815))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "getMethod")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("getMethod is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-thread-bindings
	{
		tmp0 := lang.NewSymbol("get-thread-bindings").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Get a map with the Var/value pairs which is currently in effect for the\n  current thread.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1937), lang.NewKeyword("end-line"), int(1937))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(nil, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-validator
	{
		tmp0 := lang.NewSymbol("get-validator").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("iref"))), lang.NewKeyword("doc"), "Gets the validator-fn for a var/ref/agent/atom.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2392), lang.NewKeyword("end-line"), int(2392))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "getValidator")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("getValidator is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// global-hierarchy
	{
		tmp0 := lang.NewSymbol("global-hierarchy").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5513), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(5514), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.NewMap(lang.NewKeyword("parents"), lang.NewMap(), lang.NewKeyword("descendants"), lang.NewMap(), lang.NewKeyword("ancestors"), lang.NewMap()), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// group-by
	{
		tmp0 := lang.NewSymbol("group-by").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7128), lang.NewKeyword("end-line"), int(7128))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
			tmp6 := checkDerefVar(glojure_DOT_core_reduce)
			var tmp7 lang.FnFunc
			tmp7 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v8 := args[0]
				_ = v8
				v9 := args[1]
				_ = v9
				var tmp10 any
				{ // let
					// let binding "k"
					tmp11 := lang.Apply(v3, []any{v9})
					var v12 any = tmp11
					_ = v12
					tmp13 := checkDerefVar(glojure_DOT_core_assoc_BANG_)
					tmp14 := checkDerefVar(glojure_DOT_core_conj)
					tmp15 := checkDerefVar(glojure_DOT_core_get)
					tmp16 := lang.NewVector()
					tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7139), lang.NewKeyword("column"), int(40), lang.NewKeyword("end-line"), int(7139), lang.NewKeyword("end-column"), int(41))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp19 := lang.Apply(tmp15, []any{v8, v12, tmp18})
					tmp20 := lang.Apply(tmp14, []any{tmp19, v9})
					tmp21 := lang.Apply(tmp13, []any{v8, v12, tmp20})
					tmp10 = tmp21
				} // end let
				return tmp10
			})
			tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7137), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(7139), lang.NewKeyword("end-column"), int(48))
			tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp10 := checkDerefVar(glojure_DOT_core_transient)
			tmp11 := lang.NewMap()
			tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7140), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(7140), lang.NewKeyword("end-column"), int(17))
			tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp14 := lang.Apply(tmp10, []any{tmp13})
			tmp15 := lang.Apply(tmp6, []any{tmp9, tmp14, v4})
			tmp16 := lang.Apply(tmp5, []any{tmp15})
			return tmp16
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// halt-when
	{
		tmp0 := lang.NewSymbol("halt-when").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred")), lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("retf"))), lang.NewKeyword("doc"), "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7657), lang.NewKeyword("end-line"), int(7657))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_halt_when)
				tmp5 := lang.Apply(tmp4, []any{v3, nil})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v6 := args[0]
					_ = v6
					var tmp7 lang.FnFunc
					tmp7 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp8 := lang.Apply(v6, nil)
							return tmp8
						case 1:
							v8 := args[0]
							_ = v8
							var tmp9 any
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := checkDerefVar(glojure_DOT_core_map_QMARK_)
								tmp12 := lang.Apply(tmp11, []any{v8})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp15 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
									tmp16 := lang.Apply(tmp15, []any{v8, lang.NewKeyword("glojure.core/halt")})
									tmp14 = tmp16
								} else {
									tmp14 = v13
								}
								tmp10 = tmp14
							} // end let
							if lang.IsTruthy(tmp10) {
								tmp11 := lang.Apply(lang.NewKeyword("glojure.core/halt"), []any{v8})
								tmp9 = tmp11
							} else {
								tmp12 := lang.Apply(v6, []any{v8})
								tmp9 = tmp12
							}
							return tmp9
						case 2:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							var tmp10 any
							tmp11 := lang.Apply(v3, []any{v9})
							if lang.IsTruthy(tmp11) {
								tmp12 := checkDerefVar(glojure_DOT_core_reduced)
								var tmp13 any
								if lang.IsTruthy(v4) {
									tmp14 := lang.Apply(v6, []any{v8})
									tmp15 := lang.Apply(v4, []any{tmp14, v9})
									tmp13 = tmp15
								} else {
									tmp13 = v9
								}
								tmp16 := lang.NewMap(lang.NewKeyword("glojure.core/halt"), tmp13)
								tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7678), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(7678), lang.NewKeyword("end-column"), int(72))
								tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp19 := lang.Apply(tmp12, []any{tmp18})
								tmp10 = tmp19
							} else {
								tmp20 := lang.Apply(v6, []any{v8, v9})
								tmp10 = tmp20
							}
							return tmp10
						default:
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
					})
					tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7670), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7679), lang.NewKeyword("end-column"), int(34))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp9
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7669), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7679), lang.NewKeyword("end-column"), int(35))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash
	{
		tmp0 := lang.NewSymbol("hash").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns the hash code of its argument. Note this is the hash code\n  consistent with =, and thus is different than .hashCode for Integer,\n  Short, Byte and Clojure collections.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5189), lang.NewKeyword("end-line"), int(5189))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.HashEq, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-map
	{
		tmp0 := lang.NewSymbol("hash-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keyvals"))), lang.NewKeyword("doc"), "keyval => key val\n  Returns a new hash map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(378), lang.NewKeyword("end-line"), int(378))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.NewMap()
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(384), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(384), lang.NewKeyword("end-column"), int(8))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentHashMap, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-ordered-coll
	{
		tmp0 := lang.NewSymbol("hash-ordered-coll").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://glojure.org/data_structures#hash for full algorithms.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5210), lang.NewKeyword("end-line"), int(5210))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-set
	{
		tmp0 := lang.NewSymbol("hash-set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keys"))), lang.NewKeyword("doc"), "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(388), lang.NewKeyword("end-line"), int(388))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(393), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(393), lang.NewKeyword("end-column"), int(9))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(nil, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-unordered-coll
	{
		tmp0 := lang.NewSymbol("hash-unordered-coll").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://glojure.org/data_structures#hash for full algorithms.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5219), lang.NewKeyword("end-line"), int(5219))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ident?
	{
		tmp0 := lang.NewSymbol("ident?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a symbol or keyword", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1608), lang.NewKeyword("end-line"), int(1608))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp8 = v7
				} else {
					tmp9 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp8 = tmp10
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// identical?
	{
		var tmp1 lang.FnFunc
		{ // function identical?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.lang.Util")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("glojure.core/identical")})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp5, []any{tmp17})
				return tmp18
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("identical?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Tests if 2 arguments are the same object", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(768), lang.NewKeyword("end-line"), int(768))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := lang.Apply(lang.Identical, []any{v4, v5})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// identity
	{
		tmp0 := lang.NewSymbol("identity").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns its argument.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1446), lang.NewKeyword("end-line"), int(1446))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			return v3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-let
	{
		tmp0 := lang.NewSymbol("if-let").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("then")), lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("then"), lang.NewSymbol("else"), lang.NewSymbol("&"), lang.NewSymbol("oldform"))), lang.NewKeyword("doc"), "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1839), lang.NewKeyword("end-line"), int(1839))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/if-let")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v6})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{nil})
				tmp17 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp7, []any{tmp17})
				return tmp18
			default:
				if len(args) < 5 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var v8 any = lang.NewList(args[5:]...)
				_ = v8
				var tmp9 any
				tmp10 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := checkDerefVar(glojure_DOT_core_str)
					tmp13 := checkDerefVar(glojure_DOT_core_first)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp15 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp16 := checkDerefVar(glojure_DOT_core_meta)
					tmp17 := lang.Apply(tmp16, []any{v3})
					tmp18 := lang.Apply(lang.NewKeyword("line"), []any{tmp17})
					tmp19 := lang.Apply(tmp12, []any{tmp14, " requires ", "a vector for its binding", " in ", tmp15, ":", tmp18})
					tmp20 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp19})
					panic(tmp20)
				}
				_ = tmp9
				var tmp21 any
				tmp22 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
				tmp23 := lang.Apply(tmp22, []any{v8})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "1 or 2 forms after binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp21
				var tmp33 any
				tmp34 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp35 := checkDerefVar(glojure_DOT_core_count)
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp34, []any{int64(2), tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := checkDerefVar(glojure_DOT_core_str)
					tmp39 := checkDerefVar(glojure_DOT_core_first)
					tmp40 := lang.Apply(tmp39, []any{v3})
					tmp41 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp42 := checkDerefVar(glojure_DOT_core_meta)
					tmp43 := lang.Apply(tmp42, []any{v3})
					tmp44 := lang.Apply(lang.NewKeyword("line"), []any{tmp43})
					tmp45 := lang.Apply(tmp38, []any{tmp40, " requires ", "exactly 2 forms in binding vector", " in ", tmp41, ":", tmp44})
					tmp46 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp45})
					panic(tmp46)
				}
				_ = tmp33
				var tmp47 any
				{ // let
					// let binding "form"
					tmp48 := lang.Apply(v5, []any{int64(0)})
					var v49 any = tmp48
					_ = v49
					// let binding "tst"
					tmp50 := lang.Apply(v5, []any{int64(1)})
					var v51 any = tmp50
					_ = v51
					tmp52 := checkDerefVar(glojure_DOT_core_seq)
					tmp53 := checkDerefVar(glojure_DOT_core_concat)
					tmp54 := checkDerefVar(glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{lang.NewSymbol("glojure.core/let")})
					tmp56 := checkDerefVar(glojure_DOT_core_list)
					tmp57 := checkDerefVar(glojure_DOT_core_apply)
					tmp58 := checkDerefVar(glojure_DOT_core_vector)
					tmp59 := checkDerefVar(glojure_DOT_core_seq)
					tmp60 := checkDerefVar(glojure_DOT_core_concat)
					tmp61 := checkDerefVar(glojure_DOT_core_list)
					tmp62 := lang.Apply(tmp61, []any{lang.NewSymbol("temp__0__auto__")})
					tmp63 := checkDerefVar(glojure_DOT_core_list)
					tmp64 := lang.Apply(tmp63, []any{v51})
					tmp65 := lang.Apply(tmp60, []any{tmp62, tmp64})
					tmp66 := lang.Apply(tmp59, []any{tmp65})
					tmp67 := lang.Apply(tmp57, []any{tmp58, tmp66})
					tmp68 := lang.Apply(tmp56, []any{tmp67})
					tmp69 := checkDerefVar(glojure_DOT_core_list)
					tmp70 := checkDerefVar(glojure_DOT_core_seq)
					tmp71 := checkDerefVar(glojure_DOT_core_concat)
					tmp72 := checkDerefVar(glojure_DOT_core_list)
					tmp73 := lang.Apply(tmp72, []any{lang.NewSymbol("if")})
					tmp74 := checkDerefVar(glojure_DOT_core_list)
					tmp75 := lang.Apply(tmp74, []any{lang.NewSymbol("temp__0__auto__")})
					tmp76 := checkDerefVar(glojure_DOT_core_list)
					tmp77 := checkDerefVar(glojure_DOT_core_seq)
					tmp78 := checkDerefVar(glojure_DOT_core_concat)
					tmp79 := checkDerefVar(glojure_DOT_core_list)
					tmp80 := lang.Apply(tmp79, []any{lang.NewSymbol("glojure.core/let")})
					tmp81 := checkDerefVar(glojure_DOT_core_list)
					tmp82 := checkDerefVar(glojure_DOT_core_apply)
					tmp83 := checkDerefVar(glojure_DOT_core_vector)
					tmp84 := checkDerefVar(glojure_DOT_core_seq)
					tmp85 := checkDerefVar(glojure_DOT_core_concat)
					tmp86 := checkDerefVar(glojure_DOT_core_list)
					tmp87 := lang.Apply(tmp86, []any{v49})
					tmp88 := checkDerefVar(glojure_DOT_core_list)
					tmp89 := lang.Apply(tmp88, []any{lang.NewSymbol("temp__0__auto__")})
					tmp90 := lang.Apply(tmp85, []any{tmp87, tmp89})
					tmp91 := lang.Apply(tmp84, []any{tmp90})
					tmp92 := lang.Apply(tmp82, []any{tmp83, tmp91})
					tmp93 := lang.Apply(tmp81, []any{tmp92})
					tmp94 := checkDerefVar(glojure_DOT_core_list)
					tmp95 := lang.Apply(tmp94, []any{v6})
					tmp96 := lang.Apply(tmp78, []any{tmp80, tmp93, tmp95})
					tmp97 := lang.Apply(tmp77, []any{tmp96})
					tmp98 := lang.Apply(tmp76, []any{tmp97})
					tmp99 := checkDerefVar(glojure_DOT_core_list)
					tmp100 := lang.Apply(tmp99, []any{v7})
					tmp101 := lang.Apply(tmp71, []any{tmp73, tmp75, tmp98, tmp100})
					tmp102 := lang.Apply(tmp70, []any{tmp101})
					tmp103 := lang.Apply(tmp69, []any{tmp102})
					tmp104 := lang.Apply(tmp53, []any{tmp55, tmp68, tmp103})
					tmp105 := lang.Apply(tmp52, []any{tmp104})
					tmp47 = tmp105
				} // end let
				return tmp47
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-not
	{
		tmp0 := lang.NewSymbol("if-not").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("test"), lang.NewSymbol("then")), lang.NewVector(lang.NewSymbol("test"), lang.NewSymbol("then"), lang.NewSymbol("else"))), lang.NewKeyword("doc"), "Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(760), lang.NewKeyword("end-line"), int(760))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/if-not")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v6})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{nil})
				tmp17 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp7, []any{tmp17})
				return tmp18
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_seq)
				tmp9 := checkDerefVar(glojure_DOT_core_concat)
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("if")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := checkDerefVar(glojure_DOT_core_seq)
				tmp14 := checkDerefVar(glojure_DOT_core_concat)
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/not")})
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v5})
				tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp13, []any{tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := checkDerefVar(glojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{v6})
				tmp24 := checkDerefVar(glojure_DOT_core_list)
				tmp25 := lang.Apply(tmp24, []any{v7})
				tmp26 := lang.Apply(tmp9, []any{tmp11, tmp21, tmp23, tmp25})
				tmp27 := lang.Apply(tmp8, []any{tmp26})
				return tmp27
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-some
	{
		tmp0 := lang.NewSymbol("if-some").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("then")), lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("then"), lang.NewSymbol("else"), lang.NewSymbol("&"), lang.NewSymbol("oldform"))), lang.NewKeyword("doc"), "bindings => binding-form test\n\n   If test is not nil, evaluates then with binding-form bound to the\n   value of test, if not, yields else", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1874), lang.NewKeyword("end-line"), int(1874))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/if-some")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v6})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{nil})
				tmp17 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp7, []any{tmp17})
				return tmp18
			default:
				if len(args) < 5 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var v8 any = lang.NewList(args[5:]...)
				_ = v8
				var tmp9 any
				tmp10 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := checkDerefVar(glojure_DOT_core_str)
					tmp13 := checkDerefVar(glojure_DOT_core_first)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp15 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp16 := checkDerefVar(glojure_DOT_core_meta)
					tmp17 := lang.Apply(tmp16, []any{v3})
					tmp18 := lang.Apply(lang.NewKeyword("line"), []any{tmp17})
					tmp19 := lang.Apply(tmp12, []any{tmp14, " requires ", "a vector for its binding", " in ", tmp15, ":", tmp18})
					tmp20 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp19})
					panic(tmp20)
				}
				_ = tmp9
				var tmp21 any
				tmp22 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
				tmp23 := lang.Apply(tmp22, []any{v8})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "1 or 2 forms after binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp21
				var tmp33 any
				tmp34 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp35 := checkDerefVar(glojure_DOT_core_count)
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp34, []any{int64(2), tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := checkDerefVar(glojure_DOT_core_str)
					tmp39 := checkDerefVar(glojure_DOT_core_first)
					tmp40 := lang.Apply(tmp39, []any{v3})
					tmp41 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp42 := checkDerefVar(glojure_DOT_core_meta)
					tmp43 := lang.Apply(tmp42, []any{v3})
					tmp44 := lang.Apply(lang.NewKeyword("line"), []any{tmp43})
					tmp45 := lang.Apply(tmp38, []any{tmp40, " requires ", "exactly 2 forms in binding vector", " in ", tmp41, ":", tmp44})
					tmp46 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp45})
					panic(tmp46)
				}
				_ = tmp33
				var tmp47 any
				{ // let
					// let binding "form"
					tmp48 := lang.Apply(v5, []any{int64(0)})
					var v49 any = tmp48
					_ = v49
					// let binding "tst"
					tmp50 := lang.Apply(v5, []any{int64(1)})
					var v51 any = tmp50
					_ = v51
					tmp52 := checkDerefVar(glojure_DOT_core_seq)
					tmp53 := checkDerefVar(glojure_DOT_core_concat)
					tmp54 := checkDerefVar(glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{lang.NewSymbol("glojure.core/let")})
					tmp56 := checkDerefVar(glojure_DOT_core_list)
					tmp57 := checkDerefVar(glojure_DOT_core_apply)
					tmp58 := checkDerefVar(glojure_DOT_core_vector)
					tmp59 := checkDerefVar(glojure_DOT_core_seq)
					tmp60 := checkDerefVar(glojure_DOT_core_concat)
					tmp61 := checkDerefVar(glojure_DOT_core_list)
					tmp62 := lang.Apply(tmp61, []any{lang.NewSymbol("temp__0__auto__")})
					tmp63 := checkDerefVar(glojure_DOT_core_list)
					tmp64 := lang.Apply(tmp63, []any{v51})
					tmp65 := lang.Apply(tmp60, []any{tmp62, tmp64})
					tmp66 := lang.Apply(tmp59, []any{tmp65})
					tmp67 := lang.Apply(tmp57, []any{tmp58, tmp66})
					tmp68 := lang.Apply(tmp56, []any{tmp67})
					tmp69 := checkDerefVar(glojure_DOT_core_list)
					tmp70 := checkDerefVar(glojure_DOT_core_seq)
					tmp71 := checkDerefVar(glojure_DOT_core_concat)
					tmp72 := checkDerefVar(glojure_DOT_core_list)
					tmp73 := lang.Apply(tmp72, []any{lang.NewSymbol("if")})
					tmp74 := checkDerefVar(glojure_DOT_core_list)
					tmp75 := checkDerefVar(glojure_DOT_core_seq)
					tmp76 := checkDerefVar(glojure_DOT_core_concat)
					tmp77 := checkDerefVar(glojure_DOT_core_list)
					tmp78 := lang.Apply(tmp77, []any{lang.NewSymbol("glojure.core/nil?")})
					tmp79 := checkDerefVar(glojure_DOT_core_list)
					tmp80 := lang.Apply(tmp79, []any{lang.NewSymbol("temp__0__auto__")})
					tmp81 := lang.Apply(tmp76, []any{tmp78, tmp80})
					tmp82 := lang.Apply(tmp75, []any{tmp81})
					tmp83 := lang.Apply(tmp74, []any{tmp82})
					tmp84 := checkDerefVar(glojure_DOT_core_list)
					tmp85 := lang.Apply(tmp84, []any{v7})
					tmp86 := checkDerefVar(glojure_DOT_core_list)
					tmp87 := checkDerefVar(glojure_DOT_core_seq)
					tmp88 := checkDerefVar(glojure_DOT_core_concat)
					tmp89 := checkDerefVar(glojure_DOT_core_list)
					tmp90 := lang.Apply(tmp89, []any{lang.NewSymbol("glojure.core/let")})
					tmp91 := checkDerefVar(glojure_DOT_core_list)
					tmp92 := checkDerefVar(glojure_DOT_core_apply)
					tmp93 := checkDerefVar(glojure_DOT_core_vector)
					tmp94 := checkDerefVar(glojure_DOT_core_seq)
					tmp95 := checkDerefVar(glojure_DOT_core_concat)
					tmp96 := checkDerefVar(glojure_DOT_core_list)
					tmp97 := lang.Apply(tmp96, []any{v49})
					tmp98 := checkDerefVar(glojure_DOT_core_list)
					tmp99 := lang.Apply(tmp98, []any{lang.NewSymbol("temp__0__auto__")})
					tmp100 := lang.Apply(tmp95, []any{tmp97, tmp99})
					tmp101 := lang.Apply(tmp94, []any{tmp100})
					tmp102 := lang.Apply(tmp92, []any{tmp93, tmp101})
					tmp103 := lang.Apply(tmp91, []any{tmp102})
					tmp104 := checkDerefVar(glojure_DOT_core_list)
					tmp105 := lang.Apply(tmp104, []any{v6})
					tmp106 := lang.Apply(tmp88, []any{tmp90, tmp103, tmp105})
					tmp107 := lang.Apply(tmp87, []any{tmp106})
					tmp108 := lang.Apply(tmp86, []any{tmp107})
					tmp109 := lang.Apply(tmp71, []any{tmp73, tmp83, tmp85, tmp108})
					tmp110 := lang.Apply(tmp70, []any{tmp109})
					tmp111 := lang.Apply(tmp69, []any{tmp110})
					tmp112 := lang.Apply(tmp53, []any{tmp55, tmp68, tmp111})
					tmp113 := lang.Apply(tmp52, []any{tmp112})
					tmp47 = tmp113
				} // end let
				return tmp47
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ifn?
	{
		tmp0 := lang.NewSymbol("ifn?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6209), lang.NewKeyword("end-line"), int(6209))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// import
	{
		tmp0 := lang.NewSymbol("import").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("import-symbols-or-lists"))), lang.NewKeyword("doc"), "import-list => (package-symbol class-name-symbols*)\n\n  For each name in class-name-symbols, adds a mapping from name to the\n  class named by package.name to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3426), lang.NewKeyword("end-line"), int(3426))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "specs"
					tmp7 := checkDerefVar(glojure_DOT_core_map)
					var tmp8 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v9 := args[0]
						_ = v9
						var tmp10 any
						var tmp11 any
						{ // let
							// let binding "and__0__auto__"
							tmp12 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
							tmp13 := lang.Apply(tmp12, []any{v9})
							var v14 any = tmp13
							_ = v14
							var tmp15 any
							if lang.IsTruthy(v14) {
								tmp16 := checkDerefVar(glojure_DOT_core__EQ_)
								tmp17 := checkDerefVar(glojure_DOT_core_first)
								tmp18 := lang.Apply(tmp17, []any{v9})
								tmp19 := lang.Apply(tmp16, []any{lang.NewSymbol("quote"), tmp18})
								tmp15 = tmp19
							} else {
								tmp15 = v14
							}
							tmp11 = tmp15
						} // end let
						if lang.IsTruthy(tmp11) {
							tmp12 := checkDerefVar(glojure_DOT_core_second)
							tmp13 := lang.Apply(tmp12, []any{v9})
							tmp10 = tmp13
						} else {
							tmp10 = v9
						}
						return tmp10
					})
					tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3434), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(3434), lang.NewKeyword("end-column"), int(73))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp11 := lang.Apply(tmp7, []any{tmp10, v5})
					var v12 any = tmp11
					_ = v12
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("do")})
					tmp17 := checkDerefVar(glojure_DOT_core_map)
					var tmp18 lang.FnFunc
					tmp18 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v19 := args[0]
						_ = v19
						tmp20 := checkDerefVar(glojure_DOT_core_list)
						tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Import"), v19})
						return tmp21
					})
					tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3436), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(3436), lang.NewKeyword("end-column"), int(73))
					tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp21 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp22 lang.FnFunc
					tmp22 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v23 := args[0]
						_ = v23
						v24 := args[1]
						_ = v24
						var tmp25 any
						tmp26 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
						tmp27 := lang.Apply(tmp26, []any{v24})
						if lang.IsTruthy(tmp27) {
							tmp28 := checkDerefVar(glojure_DOT_core_conj)
							tmp29 := checkDerefVar(glojure_DOT_core_name)
							tmp30 := lang.Apply(tmp29, []any{v24})
							tmp31 := lang.Apply(tmp28, []any{v23, tmp30})
							tmp25 = tmp31
						} else {
							var tmp32 any
							{ // let
								// let binding "p"
								tmp33 := checkDerefVar(glojure_DOT_core_first)
								tmp34 := lang.Apply(tmp33, []any{v24})
								var v35 any = tmp34
								_ = v35
								// let binding "cs"
								tmp36 := checkDerefVar(glojure_DOT_core_rest)
								tmp37 := lang.Apply(tmp36, []any{v24})
								var v38 any = tmp37
								_ = v38
								tmp39 := checkDerefVar(glojure_DOT_core_into1)
								tmp40 := checkDerefVar(glojure_DOT_core_map)
								var tmp41 lang.FnFunc
								tmp41 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v42 := args[0]
									_ = v42
									tmp43 := checkDerefVar(glojure_DOT_core_str)
									tmp44 := lang.Apply(tmp43, []any{v35, ".", v42})
									return tmp44
								})
								tmp42 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3441), lang.NewKeyword("column"), int(45), lang.NewKeyword("end-line"), int(3441), lang.NewKeyword("end-column"), int(58))
								tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp44 := lang.Apply(tmp40, []any{tmp43, v38})
								tmp45 := lang.Apply(tmp39, []any{v23, tmp44})
								tmp32 = tmp45
							} // end let
							tmp25 = tmp32
						}
						return tmp25
					})
					tmp23 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3437), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(3441), lang.NewKeyword("end-column"), int(66))
					tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp25 := lang.NewVector()
					tmp26 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3442), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(3442), lang.NewKeyword("end-column"), int(26))
					tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp28 := lang.Apply(tmp21, []any{tmp24, tmp27, v12})
					tmp29 := lang.Apply(tmp17, []any{tmp20, tmp28})
					tmp30 := lang.Apply(tmp14, []any{tmp16, tmp29})
					tmp31 := lang.Apply(tmp13, []any{tmp30})
					tmp6 = tmp31
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inc
	{
		var tmp1 lang.FnFunc
		{ // function inc__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = lang.NewSymbol("unchecked_inc")
				} else {
					tmp14 = lang.NewSymbol("inc")
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("inc").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one greater than num. Does not auto-promote\n  longs, will throw on overflow. See also: inc'", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(915), lang.NewKeyword("end-line"), int(915))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Inc")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Inc is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inc'
	{
		var tmp1 lang.FnFunc
		{ // function inc'__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/IncP")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("inc'").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one greater than num. Supports arbitrary precision.\n  See also: inc", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(908), lang.NewKeyword("end-line"), int(908))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IncP")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IncP is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// indexed?
	{
		tmp0 := lang.NewSymbol("indexed?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return true if coll implements Indexed, indicating efficient lookup by index", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6263), lang.NewKeyword("end-line"), int(6263))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// infinite?
	{
		var tmp1 lang.FnFunc
		{ // function infinite?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol("Double/isInfinite")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("infinite?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if num is negative or positive infinity, else false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7977), lang.NewKeyword("end-line"), int(7977))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inst-ms
	{
		tmp0 := lang.NewSymbol("inst-ms").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("inst"))), lang.NewKeyword("doc"), "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6831), lang.NewKeyword("end-line"), int(6831))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inst?
	{
		tmp0 := lang.NewSymbol("inst?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x satisfies Inst", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6837), lang.NewKeyword("end-line"), int(6837))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// instance?
	{
		tmp0 := lang.NewSymbol("instance?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("c"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Evaluates x and tests if it is an instance of the type\n    t. Returns true or false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(139), lang.NewKeyword("end-line"), int(143))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function instance?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.HasType, []any{v4, v5})
				return tmp6
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(143), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(143), lang.NewKeyword("end-column"), int(85))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int
	{
		var tmp1 lang.FnFunc
		{ // function int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = lang.NewSymbol("uncheckedIntCast")
				} else {
					tmp14 = lang.NewSymbol("intCast")
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to int", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(875), lang.NewKeyword("end-line"), int(875))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime7.RT, "IntCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IntCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int-array
	{
		var tmp1 lang.FnFunc
		{ // function int-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(glojure_DOT_core_seq)
					tmp5 := checkDerefVar(glojure_DOT_core_concat)
					tmp6 := checkDerefVar(glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
					tmp8 := checkDerefVar(glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/IntArray")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.core/args")})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("int-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of ints", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5356), lang.NewKeyword("end-line"), int(5356))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IntArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("IntArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "IntArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("IntArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int?
	{
		tmp0 := lang.NewSymbol("int?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a fixed precision integer", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1395), lang.NewKeyword("end-line"), int(1395))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{lang.Builtins["int64"], v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp8 = v7
				} else {
					var tmp9 any
					{ // let
						// let binding "or__0__auto__"
						tmp10 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{nil, v3})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							tmp13 = v12
						} else {
							var tmp14 any
							{ // let
								// let binding "or__0__auto__"
								tmp15 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
								tmp16 := lang.Apply(tmp15, []any{nil, v3})
								var v17 any = tmp16
								_ = v17
								var tmp18 any
								if lang.IsTruthy(v17) {
									tmp18 = v17
								} else {
									tmp19 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
									tmp20 := lang.Apply(tmp19, []any{nil, v3})
									tmp18 = tmp20
								}
								tmp14 = tmp18
							} // end let
							tmp13 = tmp14
						}
						tmp9 = tmp13
					} // end let
					tmp8 = tmp9
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// integer?
	{
		tmp0 := lang.NewSymbol("integer?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is an integer", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1379), lang.NewKeyword("end-line"), int(1379))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.IsInteger, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// interleave
	{
		tmp0 := lang.NewSymbol("interleave").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("c1")), lang.NewVector(lang.NewSymbol("c1"), lang.NewSymbol("c2")), lang.NewVector(lang.NewSymbol("c1"), lang.NewSymbol("c2"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Returns a lazy seq of the first item in each coll, then the second etc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4308), lang.NewKeyword("end-line"), int(4308))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return lang.NewList()
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					return v3
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "s1"
						tmp7 := checkDerefVar(glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v3})
						var v9 any = tmp8
						_ = v9
						// let binding "s2"
						tmp10 := checkDerefVar(glojure_DOT_core_seq)
						tmp11 := lang.Apply(tmp10, []any{v4})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						var tmp14 any
						{ // let
							// let binding "and__0__auto__"
							var v15 any = v9
							_ = v15
							var tmp16 any
							if lang.IsTruthy(v15) {
								tmp16 = v12
							} else {
								tmp16 = v15
							}
							tmp14 = tmp16
						} // end let
						if lang.IsTruthy(tmp14) {
							tmp15 := checkDerefVar(glojure_DOT_core_cons)
							tmp16 := checkDerefVar(glojure_DOT_core_first)
							tmp17 := lang.Apply(tmp16, []any{v9})
							tmp18 := checkDerefVar(glojure_DOT_core_cons)
							tmp19 := checkDerefVar(glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v12})
							tmp21 := checkDerefVar(glojure_DOT_core_interleave)
							tmp22 := checkDerefVar(glojure_DOT_core_rest)
							tmp23 := lang.Apply(tmp22, []any{v9})
							tmp24 := checkDerefVar(glojure_DOT_core_rest)
							tmp25 := lang.Apply(tmp24, []any{v12})
							tmp26 := lang.Apply(tmp21, []any{tmp23, tmp25})
							tmp27 := lang.Apply(tmp18, []any{tmp20, tmp26})
							tmp28 := lang.Apply(tmp15, []any{tmp17, tmp27})
							tmp13 = tmp28
						} else {
						}
						tmp6 = tmp13
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "ss"
						tmp8 := checkDerefVar(glojure_DOT_core_map)
						tmp9 := checkDerefVar(glojure_DOT_core_seq)
						tmp10 := checkDerefVar(glojure_DOT_core_conj)
						tmp11 := lang.Apply(tmp10, []any{v5, v4, v3})
						tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						tmp15 := checkDerefVar(glojure_DOT_core_every_QMARK_)
						tmp16 := checkDerefVar(glojure_DOT_core_identity)
						tmp17 := lang.Apply(tmp15, []any{tmp16, v13})
						if lang.IsTruthy(tmp17) {
							tmp18 := checkDerefVar(glojure_DOT_core_concat)
							tmp19 := checkDerefVar(glojure_DOT_core_map)
							tmp20 := checkDerefVar(glojure_DOT_core_first)
							tmp21 := lang.Apply(tmp19, []any{tmp20, v13})
							tmp22 := checkDerefVar(glojure_DOT_core_apply)
							tmp23 := checkDerefVar(glojure_DOT_core_interleave)
							tmp24 := checkDerefVar(glojure_DOT_core_map)
							tmp25 := checkDerefVar(glojure_DOT_core_rest)
							tmp26 := lang.Apply(tmp24, []any{tmp25, v13})
							tmp27 := lang.Apply(tmp22, []any{tmp23, tmp26})
							tmp28 := lang.Apply(tmp18, []any{tmp21, tmp27})
							tmp14 = tmp28
						} else {
						}
						tmp7 = tmp14
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// intern
	{
		tmp0 := lang.NewSymbol("intern").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("name")), lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("name"), lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Finds or creates a var named by the symbol name in the namespace\n  ns (which can be a symbol or a namespace), setting its root binding\n  to val if supplied. The namespace must exist. The var will adopt any\n  metadata from the name symbol.  Returns the var.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6311), lang.NewKeyword("end-line"), int(6311))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "v"
					tmp6 := checkDerefVar(glojure_DOT_core_the_ns)
					tmp7 := lang.Apply(tmp6, []any{v3})
					tmp8 := lang.Apply(nil, []any{tmp7, v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core_meta)
					tmp12 := lang.Apply(tmp11, []any{v4})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(glojure_DOT_core_meta)
						tmp14 := lang.Apply(tmp13, []any{v4})
						tmp15, _ := lang.FieldOrMethod(v9, "setMeta")
						if reflect.TypeOf(tmp15).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMeta is not a function")))
						}
						tmp16 := lang.Apply(tmp15, []any{tmp14})
						tmp10 = tmp16
					} else {
					}
					_ = tmp10
					tmp5 = v9
				} // end let
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "v"
					tmp7 := checkDerefVar(glojure_DOT_core_the_ns)
					tmp8 := lang.Apply(tmp7, []any{v3})
					tmp9 := lang.Apply(nil, []any{tmp8, v4, v5})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					tmp12 := checkDerefVar(glojure_DOT_core_meta)
					tmp13 := lang.Apply(tmp12, []any{v4})
					if lang.IsTruthy(tmp13) {
						tmp14 := checkDerefVar(glojure_DOT_core_meta)
						tmp15 := lang.Apply(tmp14, []any{v4})
						tmp16, _ := lang.FieldOrMethod(v10, "setMeta")
						if reflect.TypeOf(tmp16).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMeta is not a function")))
						}
						tmp17 := lang.Apply(tmp16, []any{tmp15})
						tmp11 = tmp17
					} else {
					}
					_ = tmp11
					tmp6 = v10
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// interpose
	{
		tmp0 := lang.NewSymbol("interpose").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sep")), lang.NewVector(lang.NewSymbol("sep"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5230), lang.NewKeyword("end-line"), int(5230))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "started"
						tmp7 := checkDerefVar(glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{false})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								tmp14 := checkDerefVar(glojure_DOT_core_deref)
								tmp15 := lang.Apply(tmp14, []any{v9})
								if lang.IsTruthy(tmp15) {
									var tmp16 any
									{ // let
										// let binding "sepr"
										tmp17 := lang.Apply(v5, []any{v11, v3})
										var v18 any = tmp17
										_ = v18
										var tmp19 any
										tmp20 := checkDerefVar(glojure_DOT_core_reduced_QMARK_)
										tmp21 := lang.Apply(tmp20, []any{v18})
										if lang.IsTruthy(tmp21) {
											tmp19 = v18
										} else {
											tmp22 := lang.Apply(v5, []any{v18, v12})
											tmp19 = tmp22
										}
										tmp16 = tmp19
									} // end let
									tmp13 = tmp16
								} else {
									tmp17 := checkDerefVar(glojure_DOT_core_vreset_BANG_)
									tmp18 := lang.Apply(tmp17, []any{v9, true})
									_ = tmp18
									tmp19 := lang.Apply(v5, []any{v11, v12})
									tmp13 = tmp19
								}
								return tmp13
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5238), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(5249), lang.NewKeyword("end-column"), int(35))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5236), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(5249), lang.NewKeyword("end-column"), int(37))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_drop)
				tmp6 := checkDerefVar(glojure_DOT_core_interleave)
				tmp7 := checkDerefVar(glojure_DOT_core_repeat)
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp9 := lang.Apply(tmp6, []any{tmp8, v4})
				tmp10 := lang.Apply(tmp5, []any{int64(1), tmp9})
				return tmp10
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into
	{
		tmp0 := lang.NewSymbol("into").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("to")), lang.NewVector(lang.NewSymbol("to"), lang.NewSymbol("from")), lang.NewVector(lang.NewSymbol("to"), lang.NewSymbol("xform"), lang.NewSymbol("from"))), lang.NewKeyword("doc"), "Returns a new coll consisting of to with all of the items of\n  from conjoined. A transducer may be supplied.\n  (into x) returns x. (into) returns [].", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6922), lang.NewKeyword("end-line"), int(6922))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.NewVector()
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6928), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(6928), lang.NewKeyword("end-column"), int(8))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(glojure_DOT_core_with_meta)
					tmp10 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
					tmp11 := checkDerefVar(glojure_DOT_core_reduce)
					tmp12 := checkDerefVar(glojure_DOT_core_conj_BANG_)
					tmp13 := checkDerefVar(glojure_DOT_core_transient)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp15 := lang.Apply(tmp11, []any{tmp12, tmp14, v4})
					tmp16 := lang.Apply(tmp10, []any{tmp15})
					tmp17 := checkDerefVar(glojure_DOT_core_meta)
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.Apply(tmp9, []any{tmp16, tmp18})
					tmp5 = tmp19
				} else {
					tmp20 := checkDerefVar(glojure_DOT_core_reduce)
					tmp21 := checkDerefVar(glojure_DOT_core_conj)
					tmp22 := lang.Apply(tmp20, []any{tmp21, v3, v4})
					tmp5 = tmp22
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp8 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					{ // let
						// let binding "tm"
						tmp11 := checkDerefVar(glojure_DOT_core_meta)
						tmp12 := lang.Apply(tmp11, []any{v3})
						var v13 any = tmp12
						_ = v13
						// let binding "rf"
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 1:
								v15 := args[0]
								_ = v15
								tmp16 := checkDerefVar(glojure_DOT_core_with_meta)
								tmp17 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
								tmp18 := lang.Apply(tmp17, []any{v15})
								tmp19 := lang.Apply(tmp16, []any{tmp18, v13})
								return tmp19
							case 2:
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								tmp17 := checkDerefVar(glojure_DOT_core_conj_BANG_)
								tmp18 := lang.Apply(tmp17, []any{v15, v16})
								return tmp18
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6937), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(6939), lang.NewKeyword("end-column"), int(44))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v17 any = tmp16
						_ = v17
						tmp18 := checkDerefVar(glojure_DOT_core_transduce)
						tmp19 := checkDerefVar(glojure_DOT_core_transient)
						tmp20 := lang.Apply(tmp19, []any{v3})
						tmp21 := lang.Apply(tmp18, []any{v4, v17, tmp20, v5})
						tmp10 = tmp21
					} // end let
					tmp6 = tmp10
				} else {
					tmp11 := checkDerefVar(glojure_DOT_core_transduce)
					tmp12 := checkDerefVar(glojure_DOT_core_conj)
					tmp13 := lang.Apply(tmp11, []any{v4, tmp12, v3, v5})
					tmp6 = tmp13
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into-array
	{
		tmp0 := lang.NewSymbol("into-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("aseq")), lang.NewVector(lang.NewSymbol("type"), lang.NewSymbol("aseq"))), lang.NewKeyword("doc"), "Returns an array with components set to the values in aseq. The array's\n  component type is type if provided, or the type of the first value in\n  aseq if present, or Object. All values in aseq must be compatible with\n  the component type. Class objects for the primitive types can be obtained\n  using, e.g., Integer/TYPE.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3444), lang.NewKeyword("end-line"), int(3444))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := lang.Apply(tmp4, []any{v3})
				tmp6 := lang.Apply(nil, []any{tmp5})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7 := lang.Apply(nil, []any{v3, tmp6})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into1
	{
		tmp0 := lang.NewSymbol("into1").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("to"), lang.NewSymbol("from"))), lang.NewKeyword("doc"), "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3416), lang.NewKeyword("end-line"), int(3416), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			if lang.IsTruthy(tmp8) {
				tmp9 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
				tmp10 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp11 := checkDerefVar(glojure_DOT_core_conj_BANG_)
				tmp12 := checkDerefVar(glojure_DOT_core_transient)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp10, []any{tmp11, tmp13, v4})
				tmp15 := lang.Apply(tmp9, []any{tmp14})
				tmp5 = tmp15
			} else {
				tmp16 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp17 := checkDerefVar(glojure_DOT_core_conj)
				tmp18 := lang.Apply(tmp16, []any{tmp17, v3, v4})
				tmp5 = tmp18
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ints
	{
		var tmp1 lang.FnFunc
		{ // function ints
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/Ints")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("ints").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to int[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5397), lang.NewKeyword("end-line"), int(5397))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Ints")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Ints is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// io!
	{
		tmp0 := lang.NewSymbol("io!").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "If an io! block occurs in a transaction, throws an\n  IllegalStateException, else runs body in an implicit do. If the\n  first expression in body is a literal string, will use that as the\n  exception message.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(2504), lang.NewKeyword("end-line"), int(2504))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "message"
					var tmp7 any
					tmp8 := checkDerefVar(glojure_DOT_core_string_QMARK_)
					tmp9 := checkDerefVar(glojure_DOT_core_first)
					tmp10 := lang.Apply(tmp9, []any{v5})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(glojure_DOT_core_first)
						tmp13 := lang.Apply(tmp12, []any{v5})
						tmp7 = tmp13
					} else {
					}
					var v14 any = tmp7
					_ = v14
					// let binding "body"
					var tmp15 any
					if lang.IsTruthy(v14) {
						tmp16 := checkDerefVar(glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v5})
						tmp15 = tmp17
					} else {
						tmp15 = v5
					}
					var v18 any = tmp15
					_ = v18
					tmp19 := checkDerefVar(glojure_DOT_core_seq)
					tmp20 := checkDerefVar(glojure_DOT_core_concat)
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("if")})
					tmp23 := checkDerefVar(glojure_DOT_core_list)
					tmp24 := checkDerefVar(glojure_DOT_core_seq)
					tmp25 := checkDerefVar(glojure_DOT_core_concat)
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{lang.NewSymbol("glojure.lang.LockingTransaction/isRunning")})
					tmp28 := lang.Apply(tmp25, []any{tmp27})
					tmp29 := lang.Apply(tmp24, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp29})
					tmp31 := checkDerefVar(glojure_DOT_core_list)
					tmp32 := checkDerefVar(glojure_DOT_core_seq)
					tmp33 := checkDerefVar(glojure_DOT_core_concat)
					tmp34 := checkDerefVar(glojure_DOT_core_list)
					tmp35 := lang.Apply(tmp34, []any{lang.NewSymbol("throw")})
					tmp36 := checkDerefVar(glojure_DOT_core_list)
					tmp37 := checkDerefVar(glojure_DOT_core_seq)
					tmp38 := checkDerefVar(glojure_DOT_core_concat)
					tmp39 := checkDerefVar(glojure_DOT_core_list)
					tmp40 := lang.Apply(tmp39, []any{lang.NewSymbol("new")})
					tmp41 := checkDerefVar(glojure_DOT_core_list)
					tmp42 := lang.Apply(tmp41, []any{lang.NewSymbol("glojure.core/IllegalStateException")})
					tmp43 := checkDerefVar(glojure_DOT_core_list)
					var tmp44 any
					{ // let
						// let binding "or__0__auto__"
						var v45 any = v14
						_ = v45
						var tmp46 any
						if lang.IsTruthy(v45) {
							tmp46 = v45
						} else {
							tmp46 = "I/O in transaction"
						}
						tmp44 = tmp46
					} // end let
					tmp45 := lang.Apply(tmp43, []any{tmp44})
					tmp46 := lang.Apply(tmp38, []any{tmp40, tmp42, tmp45})
					tmp47 := lang.Apply(tmp37, []any{tmp46})
					tmp48 := lang.Apply(tmp36, []any{tmp47})
					tmp49 := lang.Apply(tmp33, []any{tmp35, tmp48})
					tmp50 := lang.Apply(tmp32, []any{tmp49})
					tmp51 := lang.Apply(tmp31, []any{tmp50})
					tmp52 := checkDerefVar(glojure_DOT_core_list)
					tmp53 := checkDerefVar(glojure_DOT_core_seq)
					tmp54 := checkDerefVar(glojure_DOT_core_concat)
					tmp55 := checkDerefVar(glojure_DOT_core_list)
					tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("do")})
					tmp57 := lang.Apply(tmp54, []any{tmp56, v18})
					tmp58 := lang.Apply(tmp53, []any{tmp57})
					tmp59 := lang.Apply(tmp52, []any{tmp58})
					tmp60 := lang.Apply(tmp20, []any{tmp22, tmp30, tmp51, tmp59})
					tmp61 := lang.Apply(tmp19, []any{tmp60})
					tmp6 = tmp61
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// isa?
	{
		tmp0 := lang.NewSymbol("isa?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("child"), lang.NewSymbol("parent")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("child"), lang.NewSymbol("parent"))), lang.NewKeyword("doc"), "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a Java type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5543), lang.NewKeyword("end-line"), int(5543))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_isa_QMARK_)
				tmp6 := checkDerefVar(glojure_DOT_core_global_hierarchy)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3, v4})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "or__0__auto__"
					tmp7 := checkDerefVar(glojure_DOT_core__EQ_)
					tmp8 := lang.Apply(tmp7, []any{v4, v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp10 = v9
					} else {
						var tmp11 any
						{ // let
							// let binding "or__0__auto__"
							var tmp12 any
							{ // let
								// let binding "and__0__auto__"
								tmp13 := checkDerefVar(glojure_DOT_core_class_QMARK_)
								tmp14 := lang.Apply(tmp13, []any{v5})
								var v15 any = tmp14
								_ = v15
								var tmp16 any
								if lang.IsTruthy(v15) {
									var tmp17 any
									{ // let
										// let binding "and__0__auto__"
										tmp18 := checkDerefVar(glojure_DOT_core_class_QMARK_)
										tmp19 := lang.Apply(tmp18, []any{v4})
										var v20 any = tmp19
										_ = v20
										var tmp21 any
										if lang.IsTruthy(v20) {
											tmp22, _ := lang.FieldOrMethod(v4, "AssignableTo")
											if reflect.TypeOf(tmp22).Kind() != reflect.Func {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("AssignableTo is not a function")))
											}
											tmp23 := lang.Apply(tmp22, []any{v5})
											tmp21 = tmp23
										} else {
											tmp21 = v20
										}
										tmp17 = tmp21
									} // end let
									tmp16 = tmp17
								} else {
									tmp16 = v15
								}
								tmp12 = tmp16
							} // end let
							var v13 any = tmp12
							_ = v13
							var tmp14 any
							if lang.IsTruthy(v13) {
								tmp14 = v13
							} else {
								var tmp15 any
								{ // let
									// let binding "or__0__auto__"
									tmp16 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
									tmp17 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
									tmp18 := lang.Apply(tmp17, []any{v4})
									tmp19 := lang.Apply(tmp16, []any{tmp18, v5})
									var v20 any = tmp19
									_ = v20
									var tmp21 any
									if lang.IsTruthy(v20) {
										tmp21 = v20
									} else {
										var tmp22 any
										{ // let
											// let binding "or__0__auto__"
											var tmp23 any
											{ // let
												// let binding "and__0__auto__"
												tmp24 := checkDerefVar(glojure_DOT_core_class_QMARK_)
												tmp25 := lang.Apply(tmp24, []any{v4})
												var v26 any = tmp25
												_ = v26
												var tmp27 any
												if lang.IsTruthy(v26) {
													tmp28 := checkDerefVar(glojure_DOT_core_some)
													var tmp29 lang.FnFunc
													tmp29 = lang.NewFnFunc(func(args ...any) any {
														if len(args) != 1 {
															panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
														}
														v30 := args[0]
														_ = v30
														tmp31 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
														tmp32 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
														tmp33 := lang.Apply(tmp32, []any{v30})
														tmp34 := lang.Apply(tmp31, []any{tmp33, v5})
														return tmp34
													})
													tmp30 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5556), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(5556), lang.NewKeyword("end-column"), int(71))
													tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
													if err != nil {
														panic(err)
													}
													tmp32 := checkDerefVar(glojure_DOT_core_supers)
													tmp33 := lang.Apply(tmp32, []any{v4})
													tmp34 := lang.Apply(tmp28, []any{tmp31, tmp33})
													tmp27 = tmp34
												} else {
													tmp27 = v26
												}
												tmp23 = tmp27
											} // end let
											var v24 any = tmp23
											_ = v24
											var tmp25 any
											if lang.IsTruthy(v24) {
												tmp25 = v24
											} else {
												var tmp26 any
												{ // let
													// let binding "and__0__auto__"
													tmp27 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
													tmp28 := lang.Apply(tmp27, []any{v5})
													var v29 any = tmp28
													_ = v29
													var tmp30 any
													if lang.IsTruthy(v29) {
														var tmp31 any
														{ // let
															// let binding "and__0__auto__"
															tmp32 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
															tmp33 := lang.Apply(tmp32, []any{v4})
															var v34 any = tmp33
															_ = v34
															var tmp35 any
															if lang.IsTruthy(v34) {
																var tmp36 any
																{ // let
																	// let binding "and__0__auto__"
																	tmp37 := checkDerefVar(glojure_DOT_core__EQ_)
																	tmp38 := checkDerefVar(glojure_DOT_core_count)
																	tmp39 := lang.Apply(tmp38, []any{v5})
																	tmp40 := checkDerefVar(glojure_DOT_core_count)
																	tmp41 := lang.Apply(tmp40, []any{v4})
																	tmp42 := lang.Apply(tmp37, []any{tmp39, tmp41})
																	var v43 any = tmp42
																	_ = v43
																	var tmp44 any
																	if lang.IsTruthy(v43) {
																		var tmp45 any
																		{ // let
																			// let binding "ret"
																			var v46 any = true
																			_ = v46
																			// let binding "i"
																			var v47 any = int64(0)
																			_ = v47
																			for {
																				var tmp48 any
																				var tmp49 any
																				{ // let
																					// let binding "or__0__auto__"
																					tmp50 := checkDerefVar(glojure_DOT_core_not)
																					tmp51 := lang.Apply(tmp50, []any{v46})
																					var v52 any = tmp51
																					_ = v52
																					var tmp53 any
																					if lang.IsTruthy(v52) {
																						tmp53 = v52
																					} else {
																						tmp54 := checkDerefVar(glojure_DOT_core__EQ_)
																						tmp55 := checkDerefVar(glojure_DOT_core_count)
																						tmp56 := lang.Apply(tmp55, []any{v5})
																						tmp57 := lang.Apply(tmp54, []any{v47, tmp56})
																						tmp53 = tmp57
																					}
																					tmp49 = tmp53
																				} // end let
																				if lang.IsTruthy(tmp49) {
																					tmp48 = v46
																				} else {
																					tmp51 := checkDerefVar(glojure_DOT_core_isa_QMARK_)
																					tmp52 := lang.Apply(v4, []any{v47})
																					tmp53 := lang.Apply(v5, []any{v47})
																					tmp54 := lang.Apply(tmp51, []any{v3, tmp52, tmp53})
																					var tmp50 any = tmp54
																					tmp56 := checkDerefVar(glojure_DOT_core_inc)
																					tmp57 := lang.Apply(tmp56, []any{v47})
																					var tmp55 any = tmp57
																					v46 = tmp50
																					v47 = tmp55
																					continue
																				}
																				tmp45 = tmp48
																				break
																			}
																		} // end let
																		tmp44 = tmp45
																	} else {
																		tmp44 = v43
																	}
																	tmp36 = tmp44
																} // end let
																tmp35 = tmp36
															} else {
																tmp35 = v34
															}
															tmp31 = tmp35
														} // end let
														tmp30 = tmp31
													} else {
														tmp30 = v29
													}
													tmp26 = tmp30
												} // end let
												tmp25 = tmp26
											}
											tmp22 = tmp25
										} // end let
										tmp21 = tmp22
									}
									tmp15 = tmp21
								} // end let
								tmp14 = tmp15
							}
							tmp11 = tmp14
						} // end let
						tmp10 = tmp11
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iterate
	{
		tmp0 := lang.NewSymbol("iterate").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns a lazy (infinite!) sequence of x, (f x), (f (f x)) etc.\n  f must be free of side-effects", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3011), lang.NewKeyword("end-line"), int(3011))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iteration
	{
		tmp0 := lang.NewSymbol("iteration").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("step"), lang.NewSymbol("&"), lang.NewMap(lang.NewKeyword("keys"), lang.NewVector(lang.NewSymbol("somef"), lang.NewSymbol("vf"), lang.NewSymbol("kf"), lang.NewSymbol("initk")), lang.NewKeyword("or"), lang.NewMap(lang.NewSymbol("vf"), lang.NewSymbol("identity"), lang.NewSymbol("kf"), lang.NewSymbol("identity"), lang.NewSymbol("somef"), lang.NewSymbol("some?"), lang.NewSymbol("initk"), nil)))), lang.NewKeyword("doc"), "Creates a seqable/reducible via repeated calls to step,\n  a function of some (continuation token) 'k'. The first call to step\n  will be passed initk, returning 'ret'. Iff (somef ret) is true,\n  (vf ret) will be included in the iteration, else iteration will\n  terminate and vf/kf will not be called. If (kf ret) is non-nil it\n  will be passed to the next step call, else iteration will terminate.\n\n  This can be used e.g. to consume APIs that return paginated or batched data.\n\n   step - (possibly impure) fn of 'k' -> 'ret'\n\n   :somef - fn of 'ret' -> logical true/false, default 'some?'\n   :vf - fn of 'ret' -> 'v', a value produced by the iteration, default 'identity'\n   :kf - fn of 'ret' -> 'next-k' or nil (signaling 'do not continue'), default 'identity'\n   :initk - the first value passed to step, default 'nil'\n\n  It is presumed that step with non-initk is unreproducible/non-idempotent.\n  If step with initk is unreproducible it is on the consumer to not consume twice.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7716), lang.NewKeyword("end-line"), int(7716))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "map__357"
					var v6 any = v4
					_ = v6
					// let binding "map__357"
					var tmp7 any
					tmp8 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v6})
					if lang.IsTruthy(tmp9) {
						var tmp10 any
						tmp11 := checkDerefVar(glojure_DOT_core_next)
						tmp12 := lang.Apply(tmp11, []any{v6})
						if lang.IsTruthy(tmp12) {
							tmp13 := checkDerefVar(glojure_DOT_core_to_array)
							tmp14 := lang.Apply(tmp13, []any{v6})
							tmp15 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp14})
							tmp10 = tmp15
						} else {
							var tmp16 any
							tmp17 := checkDerefVar(glojure_DOT_core_seq)
							tmp18 := lang.Apply(tmp17, []any{v6})
							if lang.IsTruthy(tmp18) {
								tmp19 := checkDerefVar(glojure_DOT_core_first)
								tmp20 := lang.Apply(tmp19, []any{v6})
								tmp16 = tmp20
							} else {
							}
							tmp10 = tmp16
						}
						tmp7 = tmp10
					} else {
						tmp7 = v6
					}
					var v21 any = tmp7
					_ = v21
					// let binding "somef"
					tmp22 := checkDerefVar(glojure_DOT_core_get)
					tmp23 := checkDerefVar(glojure_DOT_core_some_QMARK_)
					tmp24 := lang.Apply(tmp22, []any{v21, lang.NewKeyword("somef"), tmp23})
					var v25 any = tmp24
					_ = v25
					// let binding "vf"
					tmp26 := checkDerefVar(glojure_DOT_core_get)
					tmp27 := checkDerefVar(glojure_DOT_core_identity)
					tmp28 := lang.Apply(tmp26, []any{v21, lang.NewKeyword("vf"), tmp27})
					var v29 any = tmp28
					_ = v29
					// let binding "kf"
					tmp30 := checkDerefVar(glojure_DOT_core_get)
					tmp31 := checkDerefVar(glojure_DOT_core_identity)
					tmp32 := lang.Apply(tmp30, []any{v21, lang.NewKeyword("kf"), tmp31})
					var v33 any = tmp32
					_ = v33
					// let binding "initk"
					tmp34 := checkDerefVar(glojure_DOT_core_get)
					tmp35 := lang.Apply(tmp34, []any{v21, lang.NewKeyword("initk"), nil})
					var v36 any = tmp35
					_ = v36
					tmp37 := checkDerefVar(glojure_DOT_core_seq)
					tmp38 := lang.NewVector(nil)
					tmp39 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7743), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(7743), lang.NewKeyword("end-column"), int(11))
					tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp41 lang.FnFunc
					{ // function next
						var v42 lang.FnFunc
						tmp41 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v43 := args[0]
							_ = v43
							var tmp44 any
							tmp45 := lang.Apply(v25, []any{v43})
							if lang.IsTruthy(tmp45) {
								tmp46 := checkDerefVar(glojure_DOT_core_cons)
								tmp47 := lang.Apply(v29, []any{v43})
								var tmp48 any
								{ // let
									// let binding "temp__0__auto__"
									tmp49 := lang.Apply(v33, []any{v43})
									var v50 any = tmp49
									_ = v50
									var tmp51 any
									tmp52 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
									tmp53 := lang.Apply(tmp52, []any{v50})
									if lang.IsTruthy(tmp53) {
									} else {
										var tmp54 any
										{ // let
											// let binding "k"
											var v55 any = v50
											_ = v55
											var tmp56 lang.FnFunc
											tmp56 = lang.NewFnFunc(func(args ...any) any {
												if len(args) != 0 {
													panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
												}
												tmp57 := lang.Apply(v3, []any{v55})
												tmp58 := lang.Apply(v42, []any{tmp57})
												return tmp58
											})
											tmp57 := lang.Apply(lang.NewLazySeq, []any{tmp56})
											tmp54 = tmp57
										} // end let
										tmp51 = tmp54
									}
									tmp48 = tmp51
								} // end let
								tmp49 := lang.Apply(tmp46, []any{tmp47, tmp48})
								tmp44 = tmp49
							} else {
							}
							return tmp44
						})
						v42 = tmp41
						_ = v42
					}
					tmp42 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7744), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(7748), lang.NewKeyword("end-column"), int(51))
					tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp44 := lang.Apply(v3, []any{v36})
					tmp45 := lang.Apply(tmp43, []any{tmp44})
					tmp46 := lang.Apply(tmp37, []any{tmp40, tmp45})
					tmp47 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
					tmp48 := checkDerefVar(glojure_DOT_core_reduce)
					tmp49 := lang.NewVector(nil, nil, nil)
					tmp50 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7751), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(7751), lang.NewKeyword("end-column"), int(22))
					tmp51, err := lang.WithMeta(tmp49, tmp50.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp52 any
					{ // let
						// let binding "acc"
						var v53 any = nil
						_ = v53
						// let binding "ret"
						tmp54 := lang.Apply(v3, []any{v36})
						var v55 any = tmp54
						_ = v55
						for {
							var tmp56 any
							tmp57 := lang.Apply(v25, []any{v55})
							if lang.IsTruthy(tmp57) {
								var tmp58 any
								{ // let
									// let binding "acc"
									tmp59 := lang.Apply(v29, []any{v55})
									tmp60 := lang.Apply(nil, []any{v53, tmp59})
									var v61 any = tmp60
									_ = v61
									var tmp62 any
									tmp63 := checkDerefVar(glojure_DOT_core_reduced_QMARK_)
									tmp64 := lang.Apply(tmp63, []any{v61})
									if lang.IsTruthy(tmp64) {
										tmp65 := checkDerefVar(glojure_DOT_core_deref)
										tmp66 := lang.Apply(tmp65, []any{v61})
										tmp62 = tmp66
									} else {
										var tmp67 any
										{ // let
											// let binding "temp__0__auto__"
											tmp68 := lang.Apply(v33, []any{v55})
											var v69 any = tmp68
											_ = v69
											var tmp70 any
											tmp71 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
											tmp72 := lang.Apply(tmp71, []any{v69})
											if lang.IsTruthy(tmp72) {
												tmp70 = v61
											} else {
												var tmp73 any
												{ // let
													// let binding "k"
													var v74 any = v69
													_ = v74
													var tmp75 any = v61
													tmp77 := lang.Apply(v3, []any{v74})
													var tmp76 any = tmp77
													v53 = tmp75
													v55 = tmp76
													continue
												} // end let
												tmp70 = tmp73
											}
											tmp67 = tmp70
										} // end let
										tmp62 = tmp67
									}
									tmp58 = tmp62
								} // end let
								tmp56 = tmp58
							} else {
								tmp56 = v53
							}
							tmp52 = tmp56
							break
						}
					} // end let
					tmp53 := lang.Apply(tmp48, []any{tmp51, tmp52})
					tmp54 := lang.Apply(nil, []any{nil, tmp46, tmp47, tmp53})
					tmp5 = tmp54
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iterator-seq
	{
		tmp0 := lang.NewSymbol("iterator-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("iter"))), lang.NewKeyword("doc"), "Returns a seq on a java.util.Iterator. Note that most collections\n  providing iterators implement Iterable and thus support seq directly.\n  Seqs cache values, thus iterator-seq should not be used on any\n  iterator that repeatedly returns the same mutable object.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5700), lang.NewKeyword("end-line"), int(5700))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// juxt
	{
		tmp0 := lang.NewSymbol("juxt").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("g")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("g"), lang.NewSymbol("h")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("g"), lang.NewSymbol("h"), lang.NewSymbol("&"), lang.NewSymbol("fs"))), lang.NewKeyword("doc"), "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2568), lang.NewKeyword("end-line"), int(2568))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp5 := lang.Apply(v3, nil)
						tmp6 := lang.NewVector(tmp5)
						tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2578), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(2578), lang.NewKeyword("end-column"), int(16))
						tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp8
					case 1:
						v5 := args[0]
						_ = v5
						tmp6 := lang.Apply(v3, []any{v5})
						tmp7 := lang.NewVector(tmp6)
						tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2579), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(2579), lang.NewKeyword("end-column"), int(19))
						tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp9
					case 2:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						tmp7 := lang.Apply(v3, []any{v5, v6})
						tmp8 := lang.NewVector(tmp7)
						tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2580), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(2580), lang.NewKeyword("end-column"), int(23))
						tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp10
					case 3:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v5, v6, v7})
						tmp9 := lang.NewVector(tmp8)
						tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2581), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(2581), lang.NewKeyword("end-column"), int(27))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp11
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						var v8 any = lang.NewList(args[3:]...)
						_ = v8
						tmp9 := checkDerefVar(glojure_DOT_core_apply)
						tmp10 := lang.Apply(tmp9, []any{v3, v5, v6, v7, v8})
						tmp11 := lang.NewVector(tmp10)
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2582), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(2582), lang.NewKeyword("end-column"), int(45))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp13
					}
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2577), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2582), lang.NewKeyword("end-column"), int(47))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v3, nil)
						tmp7 := lang.Apply(v4, nil)
						tmp8 := lang.NewVector(tmp6, tmp7)
						tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2585), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(2585), lang.NewKeyword("end-column"), int(20))
						tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp10
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v3, []any{v6})
						tmp8 := lang.Apply(v4, []any{v6})
						tmp9 := lang.NewVector(tmp7, tmp8)
						tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2586), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(2586), lang.NewKeyword("end-column"), int(25))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp11
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v6, v7})
						tmp9 := lang.Apply(v4, []any{v6, v7})
						tmp10 := lang.NewVector(tmp8, tmp9)
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2587), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(2587), lang.NewKeyword("end-column"), int(31))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp12
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v6, v7, v8})
						tmp10 := lang.Apply(v4, []any{v6, v7, v8})
						tmp11 := lang.NewVector(tmp9, tmp10)
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2588), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(2588), lang.NewKeyword("end-column"), int(37))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp13
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := checkDerefVar(glojure_DOT_core_apply)
						tmp11 := lang.Apply(tmp10, []any{v3, v6, v7, v8, v9})
						tmp12 := checkDerefVar(glojure_DOT_core_apply)
						tmp13 := lang.Apply(tmp12, []any{v4, v6, v7, v8, v9})
						tmp14 := lang.NewVector(tmp11, tmp13)
						tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2589), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(2589), lang.NewKeyword("end-column"), int(66))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp16
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2584), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2589), lang.NewKeyword("end-column"), int(68))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp7 := lang.Apply(v3, nil)
						tmp8 := lang.Apply(v4, nil)
						tmp9 := lang.Apply(v5, nil)
						tmp10 := lang.NewVector(tmp7, tmp8, tmp9)
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2592), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(2592), lang.NewKeyword("end-column"), int(24))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp12
					case 1:
						v7 := args[0]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v7})
						tmp9 := lang.Apply(v4, []any{v7})
						tmp10 := lang.Apply(v5, []any{v7})
						tmp11 := lang.NewVector(tmp8, tmp9, tmp10)
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2593), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(2593), lang.NewKeyword("end-column"), int(31))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp13
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v7, v8})
						tmp10 := lang.Apply(v4, []any{v7, v8})
						tmp11 := lang.Apply(v5, []any{v7, v8})
						tmp12 := lang.NewVector(tmp9, tmp10, tmp11)
						tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2594), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(2594), lang.NewKeyword("end-column"), int(39))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp14
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						tmp10 := lang.Apply(v3, []any{v7, v8, v9})
						tmp11 := lang.Apply(v4, []any{v7, v8, v9})
						tmp12 := lang.Apply(v5, []any{v7, v8, v9})
						tmp13 := lang.NewVector(tmp10, tmp11, tmp12)
						tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2595), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(2595), lang.NewKeyword("end-column"), int(47))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp15
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := checkDerefVar(glojure_DOT_core_apply)
						tmp12 := lang.Apply(tmp11, []any{v3, v7, v8, v9, v10})
						tmp13 := checkDerefVar(glojure_DOT_core_apply)
						tmp14 := lang.Apply(tmp13, []any{v4, v7, v8, v9, v10})
						tmp15 := checkDerefVar(glojure_DOT_core_apply)
						tmp16 := lang.Apply(tmp15, []any{v5, v7, v8, v9, v10})
						tmp17 := lang.NewVector(tmp12, tmp14, tmp16)
						tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2596), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(2596), lang.NewKeyword("end-column"), int(87))
						tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp19
					}
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2591), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2596), lang.NewKeyword("end-column"), int(89))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "fs"
					tmp8 := checkDerefVar(glojure_DOT_core_list_STAR_)
					tmp9 := lang.Apply(tmp8, []any{v3, v4, v5, v6})
					var v10 any = tmp9
					_ = v10
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp12 := checkDerefVar(glojure_DOT_core_reduce1)
							var tmp13 lang.FnFunc
							tmp13 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v14 := args[0]
								_ = v14
								v15 := args[1]
								_ = v15
								tmp16 := checkDerefVar(glojure_DOT_core_conj)
								tmp17 := lang.Apply(v15, nil)
								tmp18 := lang.Apply(tmp16, []any{v14, tmp17})
								return tmp18
							})
							tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2600), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(2600), lang.NewKeyword("end-column"), int(37))
							tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 := lang.NewVector()
							tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2600), lang.NewKeyword("column"), int(39), lang.NewKeyword("end-line"), int(2600), lang.NewKeyword("end-column"), int(40))
							tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp19 := lang.Apply(tmp12, []any{tmp15, tmp18, v10})
							return tmp19
						case 1:
							v12 := args[0]
							_ = v12
							tmp13 := checkDerefVar(glojure_DOT_core_reduce1)
							var tmp14 lang.FnFunc
							tmp14 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								tmp17 := checkDerefVar(glojure_DOT_core_conj)
								tmp18 := lang.Apply(v16, []any{v12})
								tmp19 := lang.Apply(tmp17, []any{v15, tmp18})
								return tmp19
							})
							tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2601), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(2601), lang.NewKeyword("end-column"), int(40))
							tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 := lang.NewVector()
							tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2601), lang.NewKeyword("column"), int(42), lang.NewKeyword("end-line"), int(2601), lang.NewKeyword("end-column"), int(43))
							tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp20 := lang.Apply(tmp13, []any{tmp16, tmp19, v10})
							return tmp20
						case 2:
							v12 := args[0]
							_ = v12
							v13 := args[1]
							_ = v13
							tmp14 := checkDerefVar(glojure_DOT_core_reduce1)
							var tmp15 lang.FnFunc
							tmp15 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v16 := args[0]
								_ = v16
								v17 := args[1]
								_ = v17
								tmp18 := checkDerefVar(glojure_DOT_core_conj)
								tmp19 := lang.Apply(v17, []any{v12, v13})
								tmp20 := lang.Apply(tmp18, []any{v16, tmp19})
								return tmp20
							})
							tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2602), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(2602), lang.NewKeyword("end-column"), int(44))
							tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp18 := lang.NewVector()
							tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2602), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(2602), lang.NewKeyword("end-column"), int(47))
							tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp21 := lang.Apply(tmp14, []any{tmp17, tmp20, v10})
							return tmp21
						case 3:
							v12 := args[0]
							_ = v12
							v13 := args[1]
							_ = v13
							v14 := args[2]
							_ = v14
							tmp15 := checkDerefVar(glojure_DOT_core_reduce1)
							var tmp16 lang.FnFunc
							tmp16 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v17 := args[0]
								_ = v17
								v18 := args[1]
								_ = v18
								tmp19 := checkDerefVar(glojure_DOT_core_conj)
								tmp20 := lang.Apply(v18, []any{v12, v13, v14})
								tmp21 := lang.Apply(tmp19, []any{v17, tmp20})
								return tmp21
							})
							tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2603), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(2603), lang.NewKeyword("end-column"), int(48))
							tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp19 := lang.NewVector()
							tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2603), lang.NewKeyword("column"), int(50), lang.NewKeyword("end-line"), int(2603), lang.NewKeyword("end-column"), int(51))
							tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp22 := lang.Apply(tmp15, []any{tmp18, tmp21, v10})
							return tmp22
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v12 := args[0]
							_ = v12
							v13 := args[1]
							_ = v13
							v14 := args[2]
							_ = v14
							var v15 any = lang.NewList(args[3:]...)
							_ = v15
							tmp16 := checkDerefVar(glojure_DOT_core_reduce1)
							var tmp17 lang.FnFunc
							tmp17 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v18 := args[0]
								_ = v18
								v19 := args[1]
								_ = v19
								tmp20 := checkDerefVar(glojure_DOT_core_conj)
								tmp21 := checkDerefVar(glojure_DOT_core_apply)
								tmp22 := lang.Apply(tmp21, []any{v19, v12, v13, v14, v15})
								tmp23 := lang.Apply(tmp20, []any{v18, tmp22})
								return tmp23
							})
							tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2604), lang.NewKeyword("column"), int(35), lang.NewKeyword("end-line"), int(2604), lang.NewKeyword("end-column"), int(66))
							tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp20 := lang.NewVector()
							tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2604), lang.NewKeyword("column"), int(68), lang.NewKeyword("end-line"), int(2604), lang.NewKeyword("end-column"), int(69))
							tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp23 := lang.Apply(tmp16, []any{tmp19, tmp22, v10})
							return tmp23
						}
					})
					tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2599), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(2604), lang.NewKeyword("end-column"), int(75))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp7 = tmp13
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keep
	{
		tmp0 := lang.NewSymbol("keep").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7339), lang.NewKeyword("end-line"), int(7339))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "v"
								tmp10 := lang.Apply(v3, []any{v8})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								tmp13 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
								tmp14 := lang.Apply(tmp13, []any{v11})
								if lang.IsTruthy(tmp14) {
									tmp12 = v7
								} else {
									tmp15 := lang.Apply(v5, []any{v7, v11})
									tmp12 = tmp15
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						default:
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
					})
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7347), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7354), lang.NewKeyword("end-column"), int(31))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7346), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(7354), lang.NewKeyword("end-column"), int(32))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								tmp14 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
								tmp15 := lang.Apply(tmp14, []any{v12})
								if lang.IsTruthy(tmp15) {
									var tmp16 any
									{ // let
										// let binding "c"
										tmp17 := checkDerefVar(glojure_DOT_core_chunk_first)
										tmp18 := lang.Apply(tmp17, []any{v12})
										var v19 any = tmp18
										_ = v19
										// let binding "size"
										tmp20 := checkDerefVar(glojure_DOT_core_count)
										tmp21 := lang.Apply(tmp20, []any{v19})
										var v22 any = tmp21
										_ = v22
										// let binding "b"
										tmp23 := checkDerefVar(glojure_DOT_core_chunk_buffer)
										tmp24 := lang.Apply(tmp23, []any{v22})
										var v25 any = tmp24
										_ = v25
										var tmp26 any
										{ // let
											// let binding "n__0__auto__"
											tmp27 := checkDerefVar(glojure_DOT_core_long)
											tmp28 := lang.Apply(tmp27, []any{v22})
											var v29 any = tmp28
											_ = v29
											var tmp30 any
											{ // let
												// let binding "i"
												var v31 any = int64(0)
												_ = v31
												for {
													var tmp32 any
													tmp33 := checkDerefVar(glojure_DOT_core__LT_)
													tmp34 := lang.Apply(tmp33, []any{v31, v29})
													if lang.IsTruthy(tmp34) {
														var tmp35 any
														{ // let
															// let binding "x"
															tmp36, _ := lang.FieldOrMethod(v19, "nth")
															if reflect.TypeOf(tmp36).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp37 := lang.Apply(tmp36, []any{v31})
															tmp38 := lang.Apply(v3, []any{tmp37})
															var v39 any = tmp38
															_ = v39
															var tmp40 any
															tmp41 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
															tmp42 := lang.Apply(tmp41, []any{v39})
															if lang.IsTruthy(tmp42) {
															} else {
																tmp43 := checkDerefVar(glojure_DOT_core_chunk_append)
																tmp44 := lang.Apply(tmp43, []any{v25, v39})
																tmp40 = tmp44
															}
															tmp35 = tmp40
														} // end let
														_ = tmp35
														tmp37 := checkDerefVar(glojure_DOT_core_unchecked_inc)
														tmp38 := lang.Apply(tmp37, []any{v31})
														var tmp36 any = tmp38
														v31 = tmp36
														continue
													} else {
													}
													tmp30 = tmp32
													break
												}
											} // end let
											tmp26 = tmp30
										} // end let
										_ = tmp26
										tmp27 := checkDerefVar(glojure_DOT_core_chunk_cons)
										tmp28 := checkDerefVar(glojure_DOT_core_chunk)
										tmp29 := lang.Apply(tmp28, []any{v25})
										tmp30 := checkDerefVar(glojure_DOT_core_keep)
										tmp31 := checkDerefVar(glojure_DOT_core_chunk_rest)
										tmp32 := lang.Apply(tmp31, []any{v12})
										tmp33 := lang.Apply(tmp30, []any{v3, tmp32})
										tmp34 := lang.Apply(tmp27, []any{tmp29, tmp33})
										tmp16 = tmp34
									} // end let
									tmp13 = tmp16
								} else {
									var tmp17 any
									{ // let
										// let binding "x"
										tmp18 := checkDerefVar(glojure_DOT_core_first)
										tmp19 := lang.Apply(tmp18, []any{v12})
										tmp20 := lang.Apply(v3, []any{tmp19})
										var v21 any = tmp20
										_ = v21
										var tmp22 any
										tmp23 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
										tmp24 := lang.Apply(tmp23, []any{v21})
										if lang.IsTruthy(tmp24) {
											tmp25 := checkDerefVar(glojure_DOT_core_keep)
											tmp26 := checkDerefVar(glojure_DOT_core_rest)
											tmp27 := lang.Apply(tmp26, []any{v12})
											tmp28 := lang.Apply(tmp25, []any{v3, tmp27})
											tmp22 = tmp28
										} else {
											tmp29 := checkDerefVar(glojure_DOT_core_cons)
											tmp30 := checkDerefVar(glojure_DOT_core_keep)
											tmp31 := checkDerefVar(glojure_DOT_core_rest)
											tmp32 := lang.Apply(tmp31, []any{v12})
											tmp33 := lang.Apply(tmp30, []any{v3, tmp32})
											tmp34 := lang.Apply(tmp29, []any{v21, tmp33})
											tmp22 = tmp34
										}
										tmp17 = tmp22
									} // end let
									tmp13 = tmp17
								}
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keep-indexed
	{
		tmp0 := lang.NewSymbol("keep-indexed").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7372), lang.NewKeyword("end-line"), int(7372))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "iv"
						tmp7 := checkDerefVar(glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{int64(-1)})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "i"
									tmp14 := checkDerefVar(glojure_DOT_core_inc)
									tmp15, ok := lang.FieldOrMethod(v9, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Deref")))
									}
									var tmp16 any
									switch reflect.TypeOf(tmp15).Kind() {
									case reflect.Func:
										tmp16 = lang.Apply(tmp15, nil)
									default:
										tmp16 = tmp15
									}
									tmp17 := lang.Apply(tmp14, []any{tmp16})
									tmp18, _ := lang.FieldOrMethod(v9, "reset")
									if reflect.TypeOf(tmp18).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp19 := lang.Apply(tmp18, []any{tmp17})
									var v20 any = tmp19
									_ = v20
									// let binding "v"
									tmp21 := lang.Apply(v3, []any{v20, v12})
									var v22 any = tmp21
									_ = v22
									var tmp23 any
									tmp24 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
									tmp25 := lang.Apply(tmp24, []any{v22})
									if lang.IsTruthy(tmp25) {
										tmp23 = v11
									} else {
										tmp26 := lang.Apply(v5, []any{v11, v22})
										tmp23 = tmp26
									}
									tmp13 = tmp23
								} // end let
								return tmp13
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7382), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7390), lang.NewKeyword("end-column"), int(33))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7380), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(7390), lang.NewKeyword("end-column"), int(35))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return nil
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// key
	{
		tmp0 := lang.NewSymbol("key").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("e"))), lang.NewKeyword("doc"), "Returns the key of the map entry.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1563), lang.NewKeyword("end-line"), int(1563))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "GetKey")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("GetKey is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keys
	{
		tmp0 := lang.NewSymbol("keys").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"))), lang.NewKeyword("doc"), "Returns a sequence of the map's keys, in the same order as (seq map).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1551), lang.NewKeyword("end-line"), int(1551))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.Keys, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keyword
	{
		tmp1 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp0 := lang.NewSymbol("keyword").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name")), lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("name"))), lang.NewKeyword("doc"), "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(609), lang.NewKeyword("end-line"), int(609))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp5 = v4
				} else {
					var tmp8 any
					tmp9 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v4})
					if lang.IsTruthy(tmp10) {
						tmp11 := lang.Apply(lang.InternKeywordSymbol, []any{v4})
						tmp8 = tmp11
					} else {
						var tmp12 any
						tmp13 := checkDerefVar(glojure_DOT_core_string_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v4})
						if lang.IsTruthy(tmp14) {
							tmp15 := lang.Apply(lang.InternKeywordString, []any{v4})
							tmp12 = tmp15
						} else {
						}
						tmp8 = tmp12
					}
					tmp5 = tmp8
				}
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.InternKeyword, []any{v4, v5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp4 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keyword?
	{
		tmp0 := lang.NewSymbol("keyword?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a Keyword", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(563), lang.NewKeyword("end-line"), int(563))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// last
	{
		tmp0 := lang.NewSymbol("last").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return the last item in coll, in linear time", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(262), lang.NewKeyword("end-line"), int(266))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function last
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
			recur_loop_32:
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_next)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp9 := checkDerefVar(glojure_DOT_core_next)
					tmp10 := lang.Apply(tmp9, []any{v4})
					var tmp8 any = tmp10
					v4 = tmp8
					goto recur_loop_32
				} else {
					tmp11 := checkDerefVar(glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v4})
					tmp5 = tmp12
				}
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(266), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(269), lang.NewKeyword("end-column"), int(21))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lazy-cat
	{
		tmp0 := lang.NewSymbol("lazy-cat").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4636), lang.NewKeyword("end-line"), int(4636))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_concat)
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("glojure.core/concat")})
				tmp10 := checkDerefVar(glojure_DOT_core_map)
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v12 := args[0]
					_ = v12
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/lazy-seq"), v12})
					return tmp14
				})
				tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4644), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(4644), lang.NewKeyword("end-column"), int(37))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.Apply(tmp10, []any{tmp13, v5})
				tmp15 := lang.Apply(tmp7, []any{tmp9, tmp14})
				tmp16 := lang.Apply(tmp6, []any{tmp15})
				return tmp16
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lazy-seq
	{
		tmp0 := lang.NewSymbol("lazy-seq").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Takes a body of expressions that returns an ISeq or nil, and yields\n  a Seqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls. See also - realized?", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(676), lang.NewKeyword("end-line"), int(676))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := checkDerefVar(glojure_DOT_core_list_STAR_)
				tmp8 := lang.NewVector()
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(683), lang.NewKeyword("column"), int(101), lang.NewKeyword("end-line"), int(683), lang.NewKeyword("end-column"), int(102))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := lang.Apply(tmp7, []any{lang.NewSymbol("fn*"), tmp10, v5})
				tmp12 := lang.Apply(tmp6, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewLazySeq"), tmp11})
				return tmp12
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// let
	{
		tmp0 := lang.NewSymbol("let").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "binding => binding-form init-expr\n  binding-form => name, or destructuring-form\n  destructuring-form => map-destructure-form, or seq-destructure-form\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\n\n  See https://glojure.org/reference/special_forms#binding-forms for\n  more information about destructuring.", lang.NewKeyword("forms"), lang.NewVector(lang.NewList(lang.NewSymbol("let"), lang.NewVector(lang.NewSymbol("bindings*")), lang.NewSymbol("exprs*"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4496), lang.NewKeyword("end-line"), int(4496), lang.NewKeyword("special-form"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(glojure_DOT_core_str)
					tmp11 := checkDerefVar(glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(lang.NewKeyword("line"), []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				tmp33 := checkDerefVar(glojure_DOT_core_seq)
				tmp34 := checkDerefVar(glojure_DOT_core_concat)
				tmp35 := checkDerefVar(glojure_DOT_core_list)
				tmp36 := lang.Apply(tmp35, []any{lang.NewSymbol("let*")})
				tmp37 := checkDerefVar(glojure_DOT_core_list)
				tmp38 := checkDerefVar(glojure_DOT_core_destructure)
				tmp39 := lang.Apply(tmp38, []any{v5})
				tmp40 := lang.Apply(tmp37, []any{tmp39})
				tmp41 := lang.Apply(tmp34, []any{tmp36, tmp40, v6})
				tmp42 := lang.Apply(tmp33, []any{tmp41})
				return tmp42
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// letfn
	{
		tmp0 := lang.NewSymbol("letfn").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("fnspecs"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body.", lang.NewKeyword("forms"), lang.NewVector(lang.NewList(lang.NewSymbol("letfn"), lang.NewVector(lang.NewSymbol("fnspecs*")), lang.NewSymbol("exprs*"))), lang.NewKeyword("url"), nil, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(6545), lang.NewKeyword("end-line"), int(6545), lang.NewKeyword("special-form"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("letfn*")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_vec)
				tmp13 := checkDerefVar(glojure_DOT_core_interleave)
				tmp14 := checkDerefVar(glojure_DOT_core_map)
				tmp15 := checkDerefVar(glojure_DOT_core_first)
				tmp16 := lang.Apply(tmp14, []any{tmp15, v5})
				tmp17 := checkDerefVar(glojure_DOT_core_map)
				var tmp18 lang.FnFunc
				tmp18 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v19 := args[0]
					_ = v19
					tmp20 := checkDerefVar(glojure_DOT_core_cons)
					tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/fn"), v19})
					return tmp21
				})
				tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6555), lang.NewKeyword("column"), int(35), lang.NewKeyword("end-line"), int(6555), lang.NewKeyword("end-column"), int(47))
				tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp21 := lang.Apply(tmp17, []any{tmp20, v5})
				tmp22 := lang.Apply(tmp13, []any{tmp16, tmp21})
				tmp23 := lang.Apply(tmp12, []any{tmp22})
				tmp24 := lang.Apply(tmp11, []any{tmp23})
				tmp25 := lang.Apply(tmp8, []any{tmp10, tmp24, v6})
				tmp26 := lang.Apply(tmp7, []any{tmp25})
				return tmp26
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// libspec?
	{
		tmp0 := lang.NewSymbol("libspec?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is a libspec", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5848), lang.NewKeyword("end-line"), int(5848), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp8 = v7
				} else {
					var tmp9 any
					{ // let
						// let binding "and__0__auto__"
						tmp10 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v3})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							var tmp14 any
							{ // let
								// let binding "or__0__auto__"
								tmp15 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
								tmp16 := checkDerefVar(glojure_DOT_core_second)
								tmp17 := lang.Apply(tmp16, []any{v3})
								tmp18 := lang.Apply(tmp15, []any{tmp17})
								var v19 any = tmp18
								_ = v19
								var tmp20 any
								if lang.IsTruthy(v19) {
									tmp20 = v19
								} else {
									tmp21 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
									tmp22 := checkDerefVar(glojure_DOT_core_second)
									tmp23 := lang.Apply(tmp22, []any{v3})
									tmp24 := lang.Apply(tmp21, []any{tmp23})
									tmp20 = tmp24
								}
								tmp14 = tmp20
							} // end let
							tmp13 = tmp14
						} else {
							tmp13 = v12
						}
						tmp9 = tmp13
					} // end let
					tmp8 = tmp9
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lift-ns
	{
		tmp0 := lang.NewSymbol("lift-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"))), lang.NewKeyword("doc"), "Returns [lifted-ns lifted-kvs] or nil if m can't be lifted.", lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(261), lang.NewKeyword("end-line"), int(261), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core__STAR_print_namespace_maps_STAR_)
			if lang.IsTruthy(tmp5) {
				var tmp6 any
				{ // let
					// let binding "ns"
					var v7 any = nil
					_ = v7
					// let binding "G__221"
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := lang.Apply(tmp8, []any{v3})
					var v10 any = tmp9
					_ = v10
					// let binding "vec__222"
					var v11 any = v10
					_ = v11
					// let binding "seq__223"
					tmp12 := checkDerefVar(glojure_DOT_core_seq)
					tmp13 := lang.Apply(tmp12, []any{v11})
					var v14 any = tmp13
					_ = v14
					// let binding "first__224"
					tmp15 := checkDerefVar(glojure_DOT_core_first)
					tmp16 := lang.Apply(tmp15, []any{v14})
					var v17 any = tmp16
					_ = v17
					// let binding "seq__223"
					tmp18 := checkDerefVar(glojure_DOT_core_next)
					tmp19 := lang.Apply(tmp18, []any{v14})
					var v20 any = tmp19
					_ = v20
					// let binding "vec__225"
					var v21 any = v17
					_ = v21
					// let binding "k"
					tmp22 := checkDerefVar(glojure_DOT_core_nth)
					tmp23 := lang.Apply(tmp22, []any{v21, int64(0), nil})
					var v24 any = tmp23
					_ = v24
					// let binding "v"
					tmp25 := checkDerefVar(glojure_DOT_core_nth)
					tmp26 := lang.Apply(tmp25, []any{v21, int64(1), nil})
					var v27 any = tmp26
					_ = v27
					// let binding "entry"
					var v28 any = v21
					_ = v28
					// let binding "entries"
					var v29 any = v20
					_ = v29
					// let binding "kvs"
					tmp30 := lang.NewVector()
					tmp31 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(267), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(267), lang.NewKeyword("end-column"), int(17))
					tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v33 any = tmp32
					_ = v33
					var tmp34 any
					{ // let
						// let binding "ns"
						var v35 any = v7
						_ = v35
						// let binding "G__221"
						var v36 any = v10
						_ = v36
						// let binding "kvs"
						var v37 any = v33
						_ = v37
						for {
							var tmp38 any
							{ // let
								// let binding "ns"
								var v39 any = v35
								_ = v39
								// let binding "vec__228"
								var v40 any = v36
								_ = v40
								// let binding "seq__229"
								tmp41 := checkDerefVar(glojure_DOT_core_seq)
								tmp42 := lang.Apply(tmp41, []any{v40})
								var v43 any = tmp42
								_ = v43
								// let binding "first__230"
								tmp44 := checkDerefVar(glojure_DOT_core_first)
								tmp45 := lang.Apply(tmp44, []any{v43})
								var v46 any = tmp45
								_ = v46
								// let binding "seq__229"
								tmp47 := checkDerefVar(glojure_DOT_core_next)
								tmp48 := lang.Apply(tmp47, []any{v43})
								var v49 any = tmp48
								_ = v49
								// let binding "vec__231"
								var v50 any = v46
								_ = v50
								// let binding "k"
								tmp51 := checkDerefVar(glojure_DOT_core_nth)
								tmp52 := lang.Apply(tmp51, []any{v50, int64(0), nil})
								var v53 any = tmp52
								_ = v53
								// let binding "v"
								tmp54 := checkDerefVar(glojure_DOT_core_nth)
								tmp55 := lang.Apply(tmp54, []any{v50, int64(1), nil})
								var v56 any = tmp55
								_ = v56
								// let binding "entry"
								var v57 any = v50
								_ = v57
								// let binding "entries"
								var v58 any = v49
								_ = v58
								// let binding "kvs"
								var v59 any = v37
								_ = v59
								var tmp60 any
								if lang.IsTruthy(v57) {
									var tmp61 any
									tmp62 := checkDerefVar(glojure_DOT_core_qualified_ident_QMARK_)
									tmp63 := lang.Apply(tmp62, []any{v53})
									if lang.IsTruthy(tmp63) {
										var tmp64 any
										if lang.IsTruthy(v39) {
											var tmp65 any
											tmp66 := checkDerefVar(glojure_DOT_core__EQ_)
											tmp67 := checkDerefVar(glojure_DOT_core_namespace)
											tmp68 := lang.Apply(tmp67, []any{v53})
											tmp69 := lang.Apply(tmp66, []any{v39, tmp68})
											if lang.IsTruthy(tmp69) {
												var tmp70 any = v39
												var tmp71 any = v58
												tmp73 := checkDerefVar(glojure_DOT_core_conj)
												tmp74 := checkDerefVar(glojure_DOT_core_strip_ns)
												tmp75 := lang.Apply(tmp74, []any{v53})
												tmp76 := lang.NewVector(tmp75, v56)
												tmp77 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(272), lang.NewKeyword("column"), int(43), lang.NewKeyword("end-line"), int(272), lang.NewKeyword("end-column"), int(58))
												tmp78, err := lang.WithMeta(tmp76, tmp77.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp79 := lang.Apply(tmp73, []any{v59, tmp78})
												var tmp72 any = tmp79
												v35 = tmp70
												v36 = tmp71
												v37 = tmp72
												continue
											} else {
											}
											tmp64 = tmp65
										} else {
											var tmp80 any
											{ // let
												// let binding "temp__0__auto__"
												tmp81 := checkDerefVar(glojure_DOT_core_namespace)
												tmp82 := lang.Apply(tmp81, []any{v53})
												var v83 any = tmp82
												_ = v83
												var tmp84 any
												if lang.IsTruthy(v83) {
													var tmp85 any
													{ // let
														// let binding "new-ns"
														var v86 any = v83
														_ = v86
														var tmp87 any = v86
														var tmp88 any = v58
														tmp90 := checkDerefVar(glojure_DOT_core_conj)
														tmp91 := checkDerefVar(glojure_DOT_core_strip_ns)
														tmp92 := lang.Apply(tmp91, []any{v53})
														tmp93 := lang.NewVector(tmp92, v56)
														tmp94 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(274), lang.NewKeyword("column"), int(47), lang.NewKeyword("end-line"), int(274), lang.NewKeyword("end-column"), int(62))
														tmp95, err := lang.WithMeta(tmp93, tmp94.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp96 := lang.Apply(tmp90, []any{v59, tmp95})
														var tmp89 any = tmp96
														v35 = tmp87
														v36 = tmp88
														v37 = tmp89
														continue
													} // end let
													tmp84 = tmp85
												} else {
												}
												tmp80 = tmp84
											} // end let
											tmp64 = tmp80
										}
										tmp61 = tmp64
									} else {
									}
									tmp60 = tmp61
								} else {
									tmp81 := lang.NewVector(v39, v59)
									tmp82 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(275), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(275), lang.NewKeyword("end-column"), int(16))
									tmp83, err := lang.WithMeta(tmp81, tmp82.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp60 = tmp83
								}
								tmp38 = tmp60
							} // end let
							tmp34 = tmp38
							break
						}
					} // end let
					tmp6 = tmp34
				} // end let
				tmp4 = tmp6
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// line-seq
	{
		tmp0 := lang.NewSymbol("line-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rdr"))), lang.NewKeyword("doc"), "Returns the lines of text from rdr as a lazy sequence of strings.\n  rdr must implement java.io.BufferedReader.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3068), lang.NewKeyword("end-line"), int(3068))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5, ok := lang.FieldOrMethod(v3, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "readLine")))
				}
				var tmp6 any
				switch reflect.TypeOf(tmp5).Kind() {
				case reflect.Func:
					tmp6 = lang.Apply(tmp5, nil)
				default:
					tmp6 = tmp5
				}
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "line"
						var v10 any = v7
						_ = v10
						tmp11 := checkDerefVar(glojure_DOT_core_cons)
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							tmp13 := checkDerefVar(glojure_DOT_core_line_seq)
							tmp14 := lang.Apply(tmp13, []any{v3})
							return tmp14
						})
						tmp13 := lang.Apply(lang.NewLazySeq, []any{tmp12})
						tmp14 := lang.Apply(tmp11, []any{v10, tmp13})
						tmp9 = tmp14
					} // end let
					tmp8 = tmp9
				} else {
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list
	{
		tmp0 := lang.NewSymbol("list").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("items"))), lang.NewKeyword("doc"), "Creates a new list containing the items.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(15), lang.NewKeyword("end-line"), int(18))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.NewList, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list*
	{
		tmp0 := lang.NewSymbol("list*").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Creates a new seq containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(641), lang.NewKeyword("end-line"), int(641))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_cons)
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_cons)
				tmp7 := checkDerefVar(glojure_DOT_core_cons)
				tmp8 := lang.Apply(tmp7, []any{v4, v5})
				tmp9 := lang.Apply(tmp6, []any{v3, tmp8})
				return tmp9
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_cons)
				tmp8 := checkDerefVar(glojure_DOT_core_cons)
				tmp9 := checkDerefVar(glojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v5, v6})
				tmp11 := lang.Apply(tmp8, []any{v4, tmp10})
				tmp12 := lang.Apply(tmp7, []any{v3, tmp11})
				return tmp12
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_cons)
				tmp9 := checkDerefVar(glojure_DOT_core_cons)
				tmp10 := checkDerefVar(glojure_DOT_core_cons)
				tmp11 := checkDerefVar(glojure_DOT_core_cons)
				tmp12 := checkDerefVar(glojure_DOT_core_spread)
				tmp13 := lang.Apply(tmp12, []any{v7})
				tmp14 := lang.Apply(tmp11, []any{v6, tmp13})
				tmp15 := lang.Apply(tmp10, []any{v5, tmp14})
				tmp16 := lang.Apply(tmp9, []any{v4, tmp15})
				tmp17 := lang.Apply(tmp8, []any{v3, tmp16})
				return tmp17
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list?
	{
		tmp0 := lang.NewSymbol("list?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x implements IPersistentList", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6198), lang.NewKeyword("end-line"), int(6198))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.IPersistentList)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load
	{
		tmp0 := lang.NewSymbol("load").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("paths"))), lang.NewKeyword("doc"), "Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("redef"), true, lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6095), lang.NewKeyword("end-line"), int(6095))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "seq_133"
					tmp5 := checkDerefVar(glojure_DOT_core_seq)
					tmp6 := lang.Apply(tmp5, []any{v3})
					var v7 any = tmp6
					_ = v7
					// let binding "chunk_134"
					var v8 any = nil
					_ = v8
					// let binding "count_135"
					var v9 any = int64(0)
					_ = v9
					// let binding "i_136"
					var v10 any = int64(0)
					_ = v10
					for {
						var tmp11 any
						tmp12 := checkDerefVar(glojure_DOT_core__LT_)
						tmp13 := lang.Apply(tmp12, []any{v10, v9})
						if lang.IsTruthy(tmp13) {
							var tmp14 any
							{ // let
								// let binding "path"
								tmp15, _ := lang.FieldOrMethod(v8, "nth")
								if reflect.TypeOf(tmp15).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
								}
								tmp16 := lang.Apply(tmp15, []any{v10})
								var v17 any = tmp16
								_ = v17
								var tmp18 any
								{ // let
									// let binding "path"
									var tmp19 any
									tmp20 := lang.Apply(strings11.HasPrefix, []any{v17, "/"})
									if lang.IsTruthy(tmp20) {
										tmp19 = v17
									} else {
										tmp21 := checkDerefVar(glojure_DOT_core_str)
										tmp22 := checkDerefVar(glojure_DOT_core_root_directory)
										tmp23 := checkDerefVar(glojure_DOT_core_ns_name)
										tmp24 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
										tmp25 := lang.Apply(tmp23, []any{tmp24})
										tmp26 := lang.Apply(tmp22, []any{tmp25})
										tmp27 := lang.Apply(tmp21, []any{tmp26, lang.NewChar(47), v17})
										tmp19 = tmp27
									}
									var v28 any = tmp19
									_ = v28
									var tmp29 any
									tmp30 := checkDerefVar(glojure_DOT_core__STAR_loading_verbosely_STAR_)
									if lang.IsTruthy(tmp30) {
										tmp31 := checkDerefVar(glojure_DOT_core_printf)
										tmp32 := lang.Apply(tmp31, []any{"(glojure.core/load \"%s\")\n", v28})
										_ = tmp32
										tmp33 := checkDerefVar(glojure_DOT_core_flush)
										tmp34 := lang.Apply(tmp33, nil)
										tmp29 = tmp34
									} else {
									}
									_ = tmp29
									tmp35 := checkDerefVar(glojure_DOT_core_check_cyclic_dependency)
									tmp36 := lang.Apply(tmp35, []any{v28})
									_ = tmp36
									var tmp37 any
									tmp38 := checkDerefVar(glojure_DOT_core__EQ_)
									tmp39 := checkDerefVar(glojure_DOT_core_first)
									tmp40 := checkDerefVar(glojure_DOT_core__STAR_pending_paths_STAR_)
									tmp41 := lang.Apply(tmp39, []any{tmp40})
									tmp42 := lang.Apply(tmp38, []any{v28, tmp41})
									if lang.IsTruthy(tmp42) {
									} else {
										var tmp43 any
										{ // let
											tmp44 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
											tmp45 := checkDerefVar(glojure_DOT_core_hash_map)
											tmp46 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*pending-paths*"))
											tmp47 := checkDerefVar(glojure_DOT_core_conj)
											tmp48 := checkDerefVar(glojure_DOT_core__STAR_pending_paths_STAR_)
											tmp49 := lang.Apply(tmp47, []any{tmp48, v28})
											tmp50 := lang.Apply(tmp45, []any{tmp46, tmp49})
											tmp51 := lang.Apply(tmp44, []any{tmp50})
											_ = tmp51
											var tmp52 any
											func() {
												defer func() {
													tmp53 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
													tmp54 := lang.Apply(tmp53, nil)
													_ = tmp54
												}()
												tmp55 := lang.Apply(strings11.TrimPrefix, []any{v28, "/"})
												tmp56, _ := lang.FieldOrMethod(runtime7.RT, "Load")
												if reflect.TypeOf(tmp56).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("Load is not a function")))
												}
												tmp57 := lang.Apply(tmp56, []any{tmp55})
												tmp52 = tmp57
											}()
											tmp43 = tmp52
										} // end let
										tmp37 = tmp43
									}
									tmp18 = tmp37
								} // end let
								_ = tmp18
								var tmp19 any = v7
								var tmp20 any = v8
								var tmp21 any = v9
								tmp23 := checkDerefVar(glojure_DOT_core_unchecked_inc)
								tmp24 := lang.Apply(tmp23, []any{v10})
								var tmp22 any = tmp24
								v7 = tmp19
								v8 = tmp20
								v9 = tmp21
								v10 = tmp22
								continue
							} // end let
							tmp11 = tmp14
						} else {
							var tmp15 any
							{ // let
								// let binding "temp__0__auto__"
								tmp16 := checkDerefVar(glojure_DOT_core_seq)
								tmp17 := lang.Apply(tmp16, []any{v7})
								var v18 any = tmp17
								_ = v18
								var tmp19 any
								if lang.IsTruthy(v18) {
									var tmp20 any
									{ // let
										// let binding "seq_133"
										var v21 any = v18
										_ = v21
										var tmp22 any
										tmp23 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
										tmp24 := lang.Apply(tmp23, []any{v21})
										if lang.IsTruthy(tmp24) {
											var tmp25 any
											{ // let
												// let binding "c__0__auto__"
												tmp26 := checkDerefVar(glojure_DOT_core_chunk_first)
												tmp27 := lang.Apply(tmp26, []any{v21})
												var v28 any = tmp27
												_ = v28
												tmp30 := checkDerefVar(glojure_DOT_core_chunk_rest)
												tmp31 := lang.Apply(tmp30, []any{v21})
												var tmp29 any = tmp31
												var tmp32 any = v28
												tmp34 := checkDerefVar(glojure_DOT_core_int)
												tmp35 := checkDerefVar(glojure_DOT_core_count)
												tmp36 := lang.Apply(tmp35, []any{v28})
												tmp37 := lang.Apply(tmp34, []any{tmp36})
												var tmp33 any = tmp37
												tmp39 := checkDerefVar(glojure_DOT_core_int)
												tmp40 := lang.Apply(tmp39, []any{int64(0)})
												var tmp38 any = tmp40
												v7 = tmp29
												v8 = tmp32
												v9 = tmp33
												v10 = tmp38
												continue
											} // end let
											tmp22 = tmp25
										} else {
											var tmp26 any
											{ // let
												// let binding "path"
												tmp27 := checkDerefVar(glojure_DOT_core_first)
												tmp28 := lang.Apply(tmp27, []any{v21})
												var v29 any = tmp28
												_ = v29
												var tmp30 any
												{ // let
													// let binding "path"
													var tmp31 any
													tmp32 := lang.Apply(strings11.HasPrefix, []any{v29, "/"})
													if lang.IsTruthy(tmp32) {
														tmp31 = v29
													} else {
														tmp33 := checkDerefVar(glojure_DOT_core_str)
														tmp34 := checkDerefVar(glojure_DOT_core_root_directory)
														tmp35 := checkDerefVar(glojure_DOT_core_ns_name)
														tmp36 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
														tmp37 := lang.Apply(tmp35, []any{tmp36})
														tmp38 := lang.Apply(tmp34, []any{tmp37})
														tmp39 := lang.Apply(tmp33, []any{tmp38, lang.NewChar(47), v29})
														tmp31 = tmp39
													}
													var v40 any = tmp31
													_ = v40
													var tmp41 any
													tmp42 := checkDerefVar(glojure_DOT_core__STAR_loading_verbosely_STAR_)
													if lang.IsTruthy(tmp42) {
														tmp43 := checkDerefVar(glojure_DOT_core_printf)
														tmp44 := lang.Apply(tmp43, []any{"(glojure.core/load \"%s\")\n", v40})
														_ = tmp44
														tmp45 := checkDerefVar(glojure_DOT_core_flush)
														tmp46 := lang.Apply(tmp45, nil)
														tmp41 = tmp46
													} else {
													}
													_ = tmp41
													tmp47 := checkDerefVar(glojure_DOT_core_check_cyclic_dependency)
													tmp48 := lang.Apply(tmp47, []any{v40})
													_ = tmp48
													var tmp49 any
													tmp50 := checkDerefVar(glojure_DOT_core__EQ_)
													tmp51 := checkDerefVar(glojure_DOT_core_first)
													tmp52 := checkDerefVar(glojure_DOT_core__STAR_pending_paths_STAR_)
													tmp53 := lang.Apply(tmp51, []any{tmp52})
													tmp54 := lang.Apply(tmp50, []any{v40, tmp53})
													if lang.IsTruthy(tmp54) {
													} else {
														var tmp55 any
														{ // let
															tmp56 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
															tmp57 := checkDerefVar(glojure_DOT_core_hash_map)
															tmp58 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*pending-paths*"))
															tmp59 := checkDerefVar(glojure_DOT_core_conj)
															tmp60 := checkDerefVar(glojure_DOT_core__STAR_pending_paths_STAR_)
															tmp61 := lang.Apply(tmp59, []any{tmp60, v40})
															tmp62 := lang.Apply(tmp57, []any{tmp58, tmp61})
															tmp63 := lang.Apply(tmp56, []any{tmp62})
															_ = tmp63
															var tmp64 any
															func() {
																defer func() {
																	tmp65 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
																	tmp66 := lang.Apply(tmp65, nil)
																	_ = tmp66
																}()
																tmp67 := lang.Apply(strings11.TrimPrefix, []any{v40, "/"})
																tmp68, _ := lang.FieldOrMethod(runtime7.RT, "Load")
																if reflect.TypeOf(tmp68).Kind() != reflect.Func {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("Load is not a function")))
																}
																tmp69 := lang.Apply(tmp68, []any{tmp67})
																tmp64 = tmp69
															}()
															tmp55 = tmp64
														} // end let
														tmp49 = tmp55
													}
													tmp30 = tmp49
												} // end let
												_ = tmp30
												tmp32 := checkDerefVar(glojure_DOT_core_next)
												tmp33 := lang.Apply(tmp32, []any{v21})
												var tmp31 any = tmp33
												var tmp34 any = nil
												var tmp35 any = int64(0)
												var tmp36 any = int64(0)
												v7 = tmp31
												v8 = tmp34
												v9 = tmp35
												v10 = tmp36
												continue
											} // end let
											tmp22 = tmp26
										}
										tmp20 = tmp22
									} // end let
									tmp19 = tmp20
								} else {
								}
								tmp15 = tmp19
							} // end let
							tmp11 = tmp15
						}
						tmp4 = tmp11
						break
					}
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-all
	{
		tmp0 := lang.NewSymbol("load-all").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("lib"), lang.NewSymbol("need-ns"), lang.NewSymbol("require"))), lang.NewKeyword("doc"), "Loads a lib given its name and forces a load of any libs it directly or\n  indirectly loads. If need-ns, ensures that the associated namespace\n  exists after loading. If require, records the load so any duplicate loads\n  can be skipped.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5892), lang.NewKeyword("end-line"), int(5892), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				tmp7 := checkDerefVar(glojure_DOT_core_commute)
				tmp8 := checkDerefVar(glojure_DOT_core__STAR_loaded_libs_STAR_)
				var tmp9 lang.FnFunc
				tmp9 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v10 := args[0]
					_ = v10
					v11 := args[1]
					_ = v11
					tmp12 := checkDerefVar(glojure_DOT_core_reduce1)
					tmp13 := checkDerefVar(glojure_DOT_core_conj)
					tmp14 := lang.Apply(tmp12, []any{tmp13, v10, v11})
					return tmp14
				})
				tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5899), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(5899), lang.NewKeyword("end-column"), int(47))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp12 any
				{ // let
					tmp13 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
					tmp14 := checkDerefVar(glojure_DOT_core_hash_map)
					tmp15 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*loaded-libs*"))
					tmp16 := checkDerefVar(glojure_DOT_core_ref)
					tmp17 := checkDerefVar(glojure_DOT_core_sorted_set)
					tmp18 := lang.Apply(tmp17, nil)
					tmp19 := lang.Apply(tmp16, []any{tmp18})
					tmp20 := lang.Apply(tmp14, []any{tmp15, tmp19})
					tmp21 := lang.Apply(tmp13, []any{tmp20})
					_ = tmp21
					var tmp22 any
					func() {
						defer func() {
							tmp23 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
							tmp24 := lang.Apply(tmp23, nil)
							_ = tmp24
						}()
						tmp25 := checkDerefVar(glojure_DOT_core_load_one)
						tmp26 := lang.Apply(tmp25, []any{v3, v4, v5})
						_ = tmp26
						tmp27 := checkDerefVar(glojure_DOT_core_deref)
						tmp28 := checkDerefVar(glojure_DOT_core__STAR_loaded_libs_STAR_)
						tmp29 := lang.Apply(tmp27, []any{tmp28})
						tmp22 = tmp29
					}()
					tmp12 = tmp22
				} // end let
				tmp13 := lang.Apply(tmp7, []any{tmp8, tmp11, tmp12})
				return tmp13
			})
			tmp7, _ := lang.FieldOrMethod(lang.LockingTransaction, "RunInTransaction")
			if reflect.TypeOf(tmp7).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("RunInTransaction is not a function")))
			}
			tmp8 := lang.Apply(tmp7, []any{tmp6})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-data-reader-file
	{
		tmp0 := lang.NewSymbol("load-data-reader-file").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7836), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7836), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("mappings"), lang.NewSymbol("url"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "rdr"
				tmp6, ok := lang.FieldOrMethod(v4, "openStream")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "openStream")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				tmp8 := lang.Apply(nil, []any{tmp7, "UTF-8"})
				tmp9 := lang.Apply(nil, []any{tmp8})
				var v10 any = tmp9
				_ = v10
				var tmp11 any
				func() {
					defer func() {
						tmp12, ok := lang.FieldOrMethod(v10, "close")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "close")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						_ = tmp13
					}()
					var tmp14 any
					{ // let
						tmp15 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
						tmp16 := checkDerefVar(glojure_DOT_core_hash_map)
						tmp17 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*file*"))
						tmp18, ok := lang.FieldOrMethod(v4, "getFile")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getFile")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						tmp20 := lang.Apply(tmp16, []any{tmp17, tmp19})
						tmp21 := lang.Apply(tmp15, []any{tmp20})
						_ = tmp21
						var tmp22 any
						func() {
							defer func() {
								tmp23 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
								tmp24 := lang.Apply(tmp23, nil)
								_ = tmp24
							}()
							var tmp25 any
							{ // let
								// let binding "read-opts"
								var tmp26 any
								tmp27, ok := lang.FieldOrMethod(v4, "getPath")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getPath")))
								}
								var tmp28 any
								switch reflect.TypeOf(tmp27).Kind() {
								case reflect.Func:
									tmp28 = lang.Apply(tmp27, nil)
								default:
									tmp28 = tmp27
								}
								tmp29, _ := lang.FieldOrMethod(tmp28, "endsWith")
								if reflect.TypeOf(tmp29).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("endsWith is not a function")))
								}
								tmp30 := lang.Apply(tmp29, []any{"cljc"})
								if lang.IsTruthy(tmp30) {
									tmp31 := lang.NewMap(lang.NewKeyword("eof"), nil, lang.NewKeyword("read-cond"), lang.NewKeyword("allow"))
									tmp32 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7842), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(7842), lang.NewKeyword("end-column"), int(52))
									tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp26 = tmp33
								} else {
									tmp34 := lang.NewMap(lang.NewKeyword("eof"), nil)
									tmp35 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7843), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(7843), lang.NewKeyword("end-column"), int(34))
									tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp26 = tmp36
								}
								var v37 any = tmp26
								_ = v37
								// let binding "new-mappings"
								tmp38 := checkDerefVar(glojure_DOT_core_read)
								tmp39 := lang.Apply(tmp38, []any{v37, v10})
								var v40 any = tmp39
								_ = v40
								var tmp41 any
								tmp42 := checkDerefVar(glojure_DOT_core_not)
								tmp43 := checkDerefVar(glojure_DOT_core_map_QMARK_)
								tmp44 := lang.Apply(tmp43, []any{v40})
								tmp45 := lang.Apply(tmp42, []any{tmp44})
								if lang.IsTruthy(tmp45) {
									tmp46 := checkDerefVar(glojure_DOT_core_ex_info)
									tmp47 := checkDerefVar(glojure_DOT_core_str)
									tmp48 := lang.Apply(tmp47, []any{"Not a valid data-reader map"})
									tmp49 := lang.NewMap(lang.NewKeyword("url"), v4)
									tmp50 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7847), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(7847), lang.NewKeyword("end-column"), int(36))
									tmp51, err := lang.WithMeta(tmp49, tmp50.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp52 := lang.Apply(tmp46, []any{tmp48, tmp51})
									panic(tmp52)
								} else {
								}
								_ = tmp41
								tmp53 := checkDerefVar(glojure_DOT_core_reduce)
								var tmp54 lang.FnFunc
								tmp54 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 2 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v55 := args[0]
									_ = v55
									v56 := args[1]
									_ = v56
									var tmp57 any
									{ // let
										// let binding "vec__359"
										var v58 any = v56
										_ = v58
										// let binding "k"
										tmp59 := checkDerefVar(glojure_DOT_core_nth)
										tmp60 := lang.Apply(tmp59, []any{v58, int64(0), nil})
										var v61 any = tmp60
										_ = v61
										// let binding "v"
										tmp62 := checkDerefVar(glojure_DOT_core_nth)
										tmp63 := lang.Apply(tmp62, []any{v58, int64(1), nil})
										var v64 any = tmp63
										_ = v64
										var tmp65 any
										tmp66 := checkDerefVar(glojure_DOT_core_not)
										tmp67 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
										tmp68 := lang.Apply(tmp67, []any{v61})
										tmp69 := lang.Apply(tmp66, []any{tmp68})
										if lang.IsTruthy(tmp69) {
											tmp70 := checkDerefVar(glojure_DOT_core_ex_info)
											tmp71 := checkDerefVar(glojure_DOT_core_str)
											tmp72 := lang.Apply(tmp71, []any{"Invalid form in data-reader file"})
											tmp73 := lang.NewMap(lang.NewKeyword("url"), v4, lang.NewKeyword("form"), v61)
											tmp74 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7852), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(7853), lang.NewKeyword("end-column"), int(38))
											tmp75, err := lang.WithMeta(tmp73, tmp74.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp76 := lang.Apply(tmp70, []any{tmp72, tmp75})
											panic(tmp76)
										} else {
										}
										_ = tmp65
										var tmp77 any
										{ // let
											// let binding "v-var"
											tmp78 := checkDerefVar(glojure_DOT_core_data_reader_var)
											tmp79 := lang.Apply(tmp78, []any{v64})
											var v80 any = tmp79
											_ = v80
											var tmp81 any
											var tmp82 any
											{ // let
												// let binding "and__0__auto__"
												tmp83 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
												tmp84 := lang.Apply(tmp83, []any{v3, v61})
												var v85 any = tmp84
												_ = v85
												var tmp86 any
												if lang.IsTruthy(v85) {
													tmp87 := checkDerefVar(glojure_DOT_core_not_EQ_)
													tmp88 := lang.Apply(v3, []any{v61})
													tmp89 := lang.Apply(tmp87, []any{tmp88, v80})
													tmp86 = tmp89
												} else {
													tmp86 = v85
												}
												tmp82 = tmp86
											} // end let
											if lang.IsTruthy(tmp82) {
												tmp83 := checkDerefVar(glojure_DOT_core_ex_info)
												tmp84 := lang.NewMap(lang.NewKeyword("url"), v4, lang.NewKeyword("conflict"), v61, lang.NewKeyword("mappings"), v55)
												tmp85 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7858), lang.NewKeyword("column"), int(32), lang.NewKeyword("end-line"), int(7860), lang.NewKeyword("end-column"), int(44))
												tmp86, err := lang.WithMeta(tmp84, tmp85.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp87 := lang.Apply(tmp83, []any{"Conflicting data-reader mapping", tmp86})
												panic(tmp87)
											} else {
											}
											_ = tmp81
											tmp88 := checkDerefVar(glojure_DOT_core_assoc)
											tmp89 := lang.Apply(tmp88, []any{v55, v61, v80})
											tmp77 = tmp89
										} // end let
										tmp57 = tmp77
									} // end let
									return tmp57
								})
								tmp55 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7849), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(7861), lang.NewKeyword("end-column"), int(32))
								tmp56, err := lang.WithMeta(tmp54, tmp55.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp57 := lang.Apply(tmp53, []any{tmp56, v3, v40})
								tmp25 = tmp57
							} // end let
							tmp22 = tmp25
						}()
						tmp14 = tmp22
					} // end let
					tmp11 = tmp14
				}()
				tmp5 = tmp11
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-data-readers
	{
		tmp0 := lang.NewSymbol("load-data-readers").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7865), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7865), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := checkDerefVar(glojure_DOT_core_alter_var_root)
			tmp4 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*data-readers*"))
			var tmp5 lang.FnFunc
			tmp5 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v6 := args[0]
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_reduce)
				tmp8 := checkDerefVar(glojure_DOT_core_load_data_reader_file)
				tmp9 := checkDerefVar(glojure_DOT_core_data_reader_urls)
				tmp10 := lang.Apply(tmp9, nil)
				tmp11 := lang.Apply(tmp7, []any{tmp8, v6, tmp10})
				return tmp11
			})
			tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7867), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(7869), lang.NewKeyword("end-column"), int(57))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp8 := lang.Apply(tmp3, []any{tmp4, tmp7})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-file
	{
		tmp0 := lang.NewSymbol("load-file").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-lib
	{
		tmp0 := lang.NewSymbol("load-lib").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("prefix"), lang.NewSymbol("lib"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Loads a lib with options", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5904), lang.NewKeyword("end-line"), int(5904), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_throw_if)
				var tmp7 any
				{ // let
					// let binding "and__0__auto__"
					var v8 any = v3
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp10 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
						tmp11 := checkDerefVar(glojure_DOT_core_name)
						tmp12 := lang.Apply(tmp11, []any{v4})
						tmp13 := checkDerefVar(glojure_DOT_core_int)
						tmp14 := lang.Apply(tmp13, []any{lang.NewChar(46)})
						tmp15 := lang.Apply(strings11.Index, []any{tmp12, tmp14})
						tmp16 := lang.Apply(tmp10, []any{tmp15})
						tmp9 = tmp16
					} else {
						tmp9 = v8
					}
					tmp7 = tmp9
				} // end let
				tmp8 := checkDerefVar(glojure_DOT_core_name)
				tmp9 := lang.Apply(tmp8, []any{v4})
				tmp10 := lang.Apply(tmp6, []any{tmp7, "Found lib name '%s' containing period with prefix '%s'.  lib names inside prefix lists must not contain periods", tmp9, v3})
				_ = tmp10
				var tmp11 any
				{ // let
					// let binding "lib"
					var tmp12 any
					if lang.IsTruthy(v3) {
						tmp13 := checkDerefVar(glojure_DOT_core_symbol)
						tmp14 := checkDerefVar(glojure_DOT_core_str)
						tmp15 := lang.Apply(tmp14, []any{v3, lang.NewChar(46), v4})
						tmp16 := lang.Apply(tmp13, []any{tmp15})
						tmp12 = tmp16
					} else {
						tmp12 = v4
					}
					var v17 any = tmp12
					_ = v17
					// let binding "opts"
					tmp18 := checkDerefVar(glojure_DOT_core_apply)
					tmp19 := checkDerefVar(glojure_DOT_core_hash_map)
					tmp20 := lang.Apply(tmp18, []any{tmp19, v5})
					var v21 any = tmp20
					_ = v21
					// let binding "map__110"
					var v22 any = v21
					_ = v22
					// let binding "map__110"
					var tmp23 any
					tmp24 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
					tmp25 := lang.Apply(tmp24, []any{v22})
					if lang.IsTruthy(tmp25) {
						var tmp26 any
						tmp27 := checkDerefVar(glojure_DOT_core_next)
						tmp28 := lang.Apply(tmp27, []any{v22})
						if lang.IsTruthy(tmp28) {
							tmp29 := checkDerefVar(glojure_DOT_core_to_array)
							tmp30 := lang.Apply(tmp29, []any{v22})
							tmp31 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp30})
							tmp26 = tmp31
						} else {
							var tmp32 any
							tmp33 := checkDerefVar(glojure_DOT_core_seq)
							tmp34 := lang.Apply(tmp33, []any{v22})
							if lang.IsTruthy(tmp34) {
								tmp35 := checkDerefVar(glojure_DOT_core_first)
								tmp36 := lang.Apply(tmp35, []any{v22})
								tmp32 = tmp36
							} else {
							}
							tmp26 = tmp32
						}
						tmp23 = tmp26
					} else {
						tmp23 = v22
					}
					var v37 any = tmp23
					_ = v37
					// let binding "as"
					tmp38 := checkDerefVar(glojure_DOT_core_get)
					tmp39 := lang.Apply(tmp38, []any{v37, lang.NewKeyword("as")})
					var v40 any = tmp39
					_ = v40
					// let binding "reload"
					tmp41 := checkDerefVar(glojure_DOT_core_get)
					tmp42 := lang.Apply(tmp41, []any{v37, lang.NewKeyword("reload")})
					var v43 any = tmp42
					_ = v43
					// let binding "reload-all"
					tmp44 := checkDerefVar(glojure_DOT_core_get)
					tmp45 := lang.Apply(tmp44, []any{v37, lang.NewKeyword("reload-all")})
					var v46 any = tmp45
					_ = v46
					// let binding "require"
					tmp47 := checkDerefVar(glojure_DOT_core_get)
					tmp48 := lang.Apply(tmp47, []any{v37, lang.NewKeyword("require")})
					var v49 any = tmp48
					_ = v49
					// let binding "use"
					tmp50 := checkDerefVar(glojure_DOT_core_get)
					tmp51 := lang.Apply(tmp50, []any{v37, lang.NewKeyword("use")})
					var v52 any = tmp51
					_ = v52
					// let binding "verbose"
					tmp53 := checkDerefVar(glojure_DOT_core_get)
					tmp54 := lang.Apply(tmp53, []any{v37, lang.NewKeyword("verbose")})
					var v55 any = tmp54
					_ = v55
					// let binding "as-alias"
					tmp56 := checkDerefVar(glojure_DOT_core_get)
					tmp57 := lang.Apply(tmp56, []any{v37, lang.NewKeyword("as-alias")})
					var v58 any = tmp57
					_ = v58
					// let binding "loaded"
					tmp59 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
					tmp60 := checkDerefVar(glojure_DOT_core_deref)
					tmp61 := checkDerefVar(glojure_DOT_core__STAR_loaded_libs_STAR_)
					tmp62 := lang.Apply(tmp60, []any{tmp61})
					tmp63 := lang.Apply(tmp59, []any{tmp62, v17})
					var v64 any = tmp63
					_ = v64
					// let binding "need-ns"
					var tmp65 any
					{ // let
						// let binding "or__0__auto__"
						var v66 any = v40
						_ = v66
						var tmp67 any
						if lang.IsTruthy(v66) {
							tmp67 = v66
						} else {
							tmp67 = v52
						}
						tmp65 = tmp67
					} // end let
					var v66 any = tmp65
					_ = v66
					// let binding "load"
					var tmp67 any
					if lang.IsTruthy(v46) {
						tmp68 := checkDerefVar(glojure_DOT_core_load_all)
						tmp67 = tmp68
					} else {
						var tmp69 any
						if lang.IsTruthy(v43) {
							tmp70 := checkDerefVar(glojure_DOT_core_load_one)
							tmp69 = tmp70
						} else {
							var tmp71 any
							tmp72 := checkDerefVar(glojure_DOT_core_not)
							tmp73 := lang.Apply(tmp72, []any{v64})
							if lang.IsTruthy(tmp73) {
								var tmp74 any
								if lang.IsTruthy(v66) {
									tmp75 := checkDerefVar(glojure_DOT_core_load_one)
									tmp74 = tmp75
								} else {
									var tmp76 any
									if lang.IsTruthy(v58) {
										var tmp77 lang.FnFunc
										tmp77 = lang.NewFnFunc(func(args ...any) any {
											if len(args) != 3 {
												panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
											}
											v78 := args[0]
											_ = v78
											v79 := args[1]
											_ = v79
											v80 := args[2]
											_ = v80
											tmp81 := checkDerefVar(glojure_DOT_core_create_ns)
											tmp82 := lang.Apply(tmp81, []any{v78})
											return tmp82
										})
										tmp78 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5918), lang.NewKeyword("column"), int(48), lang.NewKeyword("end-line"), int(5918), lang.NewKeyword("end-column"), int(88))
										tmp79, err := lang.WithMeta(tmp77, tmp78.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp76 = tmp79
									} else {
										var tmp80 any
										if lang.IsTruthy(lang.NewKeyword("else")) {
											tmp81 := checkDerefVar(glojure_DOT_core_load_one)
											tmp80 = tmp81
										} else {
										}
										tmp76 = tmp80
									}
									tmp74 = tmp76
								}
								tmp71 = tmp74
							} else {
							}
							tmp69 = tmp71
						}
						tmp67 = tmp69
					}
					var v82 any = tmp67
					_ = v82
					// let binding "filter-opts"
					tmp83 := checkDerefVar(glojure_DOT_core_select_keys)
					tmp84 := lang.Apply(tmp83, []any{v21, lang.NewList(lang.NewKeyword("exclude"), lang.NewKeyword("only"), lang.NewKeyword("rename"), lang.NewKeyword("refer"))})
					var v85 any = tmp84
					_ = v85
					// let binding "undefined-on-entry"
					tmp86 := checkDerefVar(glojure_DOT_core_not)
					tmp87 := checkDerefVar(glojure_DOT_core_find_ns)
					tmp88 := lang.Apply(tmp87, []any{v17})
					tmp89 := lang.Apply(tmp86, []any{tmp88})
					var v90 any = tmp89
					_ = v90
					var tmp91 any
					{ // let
						tmp92 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
						tmp93 := checkDerefVar(glojure_DOT_core_hash_map)
						tmp94 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*loading-verbosely*"))
						var tmp95 any
						{ // let
							// let binding "or__0__auto__"
							tmp96 := checkDerefVar(glojure_DOT_core__STAR_loading_verbosely_STAR_)
							var v97 any = tmp96
							_ = v97
							var tmp98 any
							if lang.IsTruthy(v97) {
								tmp98 = v97
							} else {
								tmp98 = v55
							}
							tmp95 = tmp98
						} // end let
						tmp96 := lang.Apply(tmp93, []any{tmp94, tmp95})
						tmp97 := lang.Apply(tmp92, []any{tmp96})
						_ = tmp97
						var tmp98 any
						func() {
							defer func() {
								tmp99 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
								tmp100 := lang.Apply(tmp99, nil)
								_ = tmp100
							}()
							var tmp101 any
							if lang.IsTruthy(v82) {
								var tmp102 any
								func() {
									defer func() {
										if r := recover(); r != nil {
											if lang.CatchMatches(r, lang.Builtins["any"]) {
												v103 := r
												_ = v103
												var tmp104 any
												if lang.IsTruthy(v90) {
													tmp105 := checkDerefVar(glojure_DOT_core_remove_ns)
													tmp106 := lang.Apply(tmp105, []any{v17})
													tmp104 = tmp106
												} else {
												}
												_ = tmp104
												panic(v103)
											} else {
												panic(r)
											}
										}
									}()
									tmp103 := lang.Apply(v82, []any{v17, v66, v49})
									tmp102 = tmp103
								}()
								tmp101 = tmp102
							} else {
								tmp104 := checkDerefVar(glojure_DOT_core_throw_if)
								var tmp105 any
								{ // let
									// let binding "and__0__auto__"
									var v106 any = v66
									_ = v106
									var tmp107 any
									if lang.IsTruthy(v106) {
										tmp108 := checkDerefVar(glojure_DOT_core_not)
										tmp109 := checkDerefVar(glojure_DOT_core_find_ns)
										tmp110 := lang.Apply(tmp109, []any{v17})
										tmp111 := lang.Apply(tmp108, []any{tmp110})
										tmp107 = tmp111
									} else {
										tmp107 = v106
									}
									tmp105 = tmp107
								} // end let
								tmp106 := lang.Apply(tmp104, []any{tmp105, "namespace '%s' not found", v17})
								tmp101 = tmp106
							}
							_ = tmp101
							var tmp107 any
							var tmp108 any
							{ // let
								// let binding "and__0__auto__"
								var v109 any = v66
								_ = v109
								var tmp110 any
								if lang.IsTruthy(v109) {
									tmp111 := checkDerefVar(glojure_DOT_core__STAR_loading_verbosely_STAR_)
									tmp110 = tmp111
								} else {
									tmp110 = v109
								}
								tmp108 = tmp110
							} // end let
							if lang.IsTruthy(tmp108) {
								tmp109 := checkDerefVar(glojure_DOT_core_printf)
								tmp110 := checkDerefVar(glojure_DOT_core_ns_name)
								tmp111 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
								tmp112 := lang.Apply(tmp110, []any{tmp111})
								tmp113 := lang.Apply(tmp109, []any{"(glojure.core/in-ns '%s)\n", tmp112})
								tmp107 = tmp113
							} else {
							}
							_ = tmp107
							var tmp114 any
							if lang.IsTruthy(v40) {
								var tmp115 any
								tmp116 := checkDerefVar(glojure_DOT_core__STAR_loading_verbosely_STAR_)
								if lang.IsTruthy(tmp116) {
									tmp117 := checkDerefVar(glojure_DOT_core_printf)
									tmp118 := lang.Apply(tmp117, []any{"(glojure.core/alias '%s '%s)\n", v40, v17})
									tmp115 = tmp118
								} else {
								}
								_ = tmp115
								tmp119 := checkDerefVar(glojure_DOT_core_alias)
								tmp120 := lang.Apply(tmp119, []any{v40, v17})
								tmp114 = tmp120
							} else {
							}
							_ = tmp114
							var tmp121 any
							if lang.IsTruthy(v58) {
								var tmp122 any
								tmp123 := checkDerefVar(glojure_DOT_core__STAR_loading_verbosely_STAR_)
								if lang.IsTruthy(tmp123) {
									tmp124 := checkDerefVar(glojure_DOT_core_printf)
									tmp125 := lang.Apply(tmp124, []any{"(glojure.core/alias '%s '%s)\n", v58, v17})
									tmp122 = tmp125
								} else {
								}
								_ = tmp122
								tmp126 := checkDerefVar(glojure_DOT_core_alias)
								tmp127 := lang.Apply(tmp126, []any{v58, v17})
								tmp121 = tmp127
							} else {
							}
							_ = tmp121
							var tmp128 any
							var tmp129 any
							{ // let
								// let binding "or__0__auto__"
								var v130 any = v52
								_ = v130
								var tmp131 any
								if lang.IsTruthy(v130) {
									tmp131 = v130
								} else {
									tmp132 := lang.Apply(lang.NewKeyword("refer"), []any{v85})
									tmp131 = tmp132
								}
								tmp129 = tmp131
							} // end let
							if lang.IsTruthy(tmp129) {
								var tmp130 any
								tmp131 := checkDerefVar(glojure_DOT_core__STAR_loading_verbosely_STAR_)
								if lang.IsTruthy(tmp131) {
									tmp132 := checkDerefVar(glojure_DOT_core_printf)
									tmp133 := lang.Apply(tmp132, []any{"(glojure.core/refer '%s", v17})
									_ = tmp133
									var tmp134 any
									{ // let
										// let binding "seq_111"
										tmp135 := checkDerefVar(glojure_DOT_core_seq)
										tmp136 := lang.Apply(tmp135, []any{v85})
										var v137 any = tmp136
										_ = v137
										// let binding "chunk_112"
										var v138 any = nil
										_ = v138
										// let binding "count_113"
										var v139 any = int64(0)
										_ = v139
										// let binding "i_114"
										var v140 any = int64(0)
										_ = v140
										for {
											var tmp141 any
											tmp142 := checkDerefVar(glojure_DOT_core__LT_)
											tmp143 := lang.Apply(tmp142, []any{v140, v139})
											if lang.IsTruthy(tmp143) {
												var tmp144 any
												{ // let
													// let binding "opt"
													tmp145, _ := lang.FieldOrMethod(v138, "nth")
													if reflect.TypeOf(tmp145).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
													}
													tmp146 := lang.Apply(tmp145, []any{v140})
													var v147 any = tmp146
													_ = v147
													tmp148 := checkDerefVar(glojure_DOT_core_printf)
													tmp149 := checkDerefVar(glojure_DOT_core_key)
													tmp150 := lang.Apply(tmp149, []any{v147})
													tmp151 := checkDerefVar(glojure_DOT_core_print_str)
													tmp152 := checkDerefVar(glojure_DOT_core_val)
													tmp153 := lang.Apply(tmp152, []any{v147})
													tmp154 := lang.Apply(tmp151, []any{tmp153})
													tmp155 := lang.Apply(tmp148, []any{" %s '%s", tmp150, tmp154})
													_ = tmp155
													var tmp156 any = v137
													var tmp157 any = v138
													var tmp158 any = v139
													tmp160 := checkDerefVar(glojure_DOT_core_unchecked_inc)
													tmp161 := lang.Apply(tmp160, []any{v140})
													var tmp159 any = tmp161
													v137 = tmp156
													v138 = tmp157
													v139 = tmp158
													v140 = tmp159
													continue
												} // end let
												tmp141 = tmp144
											} else {
												var tmp145 any
												{ // let
													// let binding "temp__0__auto__"
													tmp146 := checkDerefVar(glojure_DOT_core_seq)
													tmp147 := lang.Apply(tmp146, []any{v137})
													var v148 any = tmp147
													_ = v148
													var tmp149 any
													if lang.IsTruthy(v148) {
														var tmp150 any
														{ // let
															// let binding "seq_111"
															var v151 any = v148
															_ = v151
															var tmp152 any
															tmp153 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
															tmp154 := lang.Apply(tmp153, []any{v151})
															if lang.IsTruthy(tmp154) {
																var tmp155 any
																{ // let
																	// let binding "c__0__auto__"
																	tmp156 := checkDerefVar(glojure_DOT_core_chunk_first)
																	tmp157 := lang.Apply(tmp156, []any{v151})
																	var v158 any = tmp157
																	_ = v158
																	tmp160 := checkDerefVar(glojure_DOT_core_chunk_rest)
																	tmp161 := lang.Apply(tmp160, []any{v151})
																	var tmp159 any = tmp161
																	var tmp162 any = v158
																	tmp164 := checkDerefVar(glojure_DOT_core_int)
																	tmp165 := checkDerefVar(glojure_DOT_core_count)
																	tmp166 := lang.Apply(tmp165, []any{v158})
																	tmp167 := lang.Apply(tmp164, []any{tmp166})
																	var tmp163 any = tmp167
																	tmp169 := checkDerefVar(glojure_DOT_core_int)
																	tmp170 := lang.Apply(tmp169, []any{int64(0)})
																	var tmp168 any = tmp170
																	v137 = tmp159
																	v138 = tmp162
																	v139 = tmp163
																	v140 = tmp168
																	continue
																} // end let
																tmp152 = tmp155
															} else {
																var tmp156 any
																{ // let
																	// let binding "opt"
																	tmp157 := checkDerefVar(glojure_DOT_core_first)
																	tmp158 := lang.Apply(tmp157, []any{v151})
																	var v159 any = tmp158
																	_ = v159
																	tmp160 := checkDerefVar(glojure_DOT_core_printf)
																	tmp161 := checkDerefVar(glojure_DOT_core_key)
																	tmp162 := lang.Apply(tmp161, []any{v159})
																	tmp163 := checkDerefVar(glojure_DOT_core_print_str)
																	tmp164 := checkDerefVar(glojure_DOT_core_val)
																	tmp165 := lang.Apply(tmp164, []any{v159})
																	tmp166 := lang.Apply(tmp163, []any{tmp165})
																	tmp167 := lang.Apply(tmp160, []any{" %s '%s", tmp162, tmp166})
																	_ = tmp167
																	tmp169 := checkDerefVar(glojure_DOT_core_next)
																	tmp170 := lang.Apply(tmp169, []any{v151})
																	var tmp168 any = tmp170
																	var tmp171 any = nil
																	var tmp172 any = int64(0)
																	var tmp173 any = int64(0)
																	v137 = tmp168
																	v138 = tmp171
																	v139 = tmp172
																	v140 = tmp173
																	continue
																} // end let
																tmp152 = tmp156
															}
															tmp150 = tmp152
														} // end let
														tmp149 = tmp150
													} else {
													}
													tmp145 = tmp149
												} // end let
												tmp141 = tmp145
											}
											tmp134 = tmp141
											break
										}
									} // end let
									_ = tmp134
									tmp135 := checkDerefVar(glojure_DOT_core_printf)
									tmp136 := lang.Apply(tmp135, []any{")\n"})
									tmp130 = tmp136
								} else {
								}
								_ = tmp130
								tmp137 := checkDerefVar(glojure_DOT_core_apply)
								tmp138 := checkDerefVar(glojure_DOT_core_refer)
								tmp139 := checkDerefVar(glojure_DOT_core_mapcat)
								tmp140 := checkDerefVar(glojure_DOT_core_seq)
								tmp141 := lang.Apply(tmp139, []any{tmp140, v85})
								tmp142 := lang.Apply(tmp137, []any{tmp138, v17, tmp141})
								tmp128 = tmp142
							} else {
							}
							tmp98 = tmp128
						}()
						tmp91 = tmp98
					} // end let
					tmp11 = tmp91
				} // end let
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-libs
	{
		tmp0 := lang.NewSymbol("load-libs").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Loads libs, interpreting libspecs, prefix lists, and flags for\n  forwarding to load-lib", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5951), lang.NewKeyword("end-line"), int(5951), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "flags"
					tmp5 := checkDerefVar(glojure_DOT_core_filter)
					tmp6 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
					tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
					var v8 any = tmp7
					_ = v8
					// let binding "opts"
					tmp9 := checkDerefVar(glojure_DOT_core_interleave)
					tmp10 := checkDerefVar(glojure_DOT_core_repeat)
					tmp11 := lang.Apply(tmp10, []any{true})
					tmp12 := lang.Apply(tmp9, []any{v8, tmp11})
					var v13 any = tmp12
					_ = v13
					// let binding "args"
					tmp14 := checkDerefVar(glojure_DOT_core_filter)
					tmp15 := checkDerefVar(glojure_DOT_core_complement)
					tmp16 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
					tmp17 := lang.Apply(tmp15, []any{tmp16})
					tmp18 := lang.Apply(tmp14, []any{tmp17, v3})
					var v19 any = tmp18
					_ = v19
					var tmp20 any
					{ // let
						// let binding "supported"
						tmp21 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{lang.NewKeyword("as"), lang.NewKeyword("reload"), lang.NewKeyword("reload-all"), lang.NewKeyword("require"), lang.NewKeyword("use"), lang.NewKeyword("verbose"), lang.NewKeyword("refer"), lang.NewKeyword("as-alias")}))
						tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5959), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(5959), lang.NewKeyword("end-column"), int(86))
						tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v24 any = tmp23
						_ = v24
						// let binding "unsupported"
						tmp25 := checkDerefVar(glojure_DOT_core_seq)
						tmp26 := checkDerefVar(glojure_DOT_core_remove)
						tmp27 := lang.Apply(tmp26, []any{v24, v8})
						tmp28 := lang.Apply(tmp25, []any{tmp27})
						var v29 any = tmp28
						_ = v29
						tmp30 := checkDerefVar(glojure_DOT_core_throw_if)
						tmp31 := checkDerefVar(glojure_DOT_core_apply)
						tmp32 := checkDerefVar(glojure_DOT_core_str)
						tmp33 := checkDerefVar(glojure_DOT_core_interpose)
						tmp34 := lang.Apply(tmp33, []any{lang.NewChar(44), v29})
						tmp35 := lang.Apply(tmp31, []any{tmp32, "Unsupported option(s) supplied: ", tmp34})
						tmp36 := lang.Apply(tmp30, []any{v29, tmp35})
						tmp20 = tmp36
					} // end let
					_ = tmp20
					tmp21 := checkDerefVar(glojure_DOT_core_throw_if)
					tmp22 := checkDerefVar(glojure_DOT_core_not)
					tmp23 := checkDerefVar(glojure_DOT_core_seq)
					tmp24 := lang.Apply(tmp23, []any{v19})
					tmp25 := lang.Apply(tmp22, []any{tmp24})
					tmp26 := lang.Apply(tmp21, []any{tmp25, "Nothing specified to load"})
					_ = tmp26
					var tmp27 any
					{ // let
						// let binding "seq_115"
						tmp28 := checkDerefVar(glojure_DOT_core_seq)
						tmp29 := lang.Apply(tmp28, []any{v19})
						var v30 any = tmp29
						_ = v30
						// let binding "chunk_116"
						var v31 any = nil
						_ = v31
						// let binding "count_117"
						var v32 any = int64(0)
						_ = v32
						// let binding "i_118"
						var v33 any = int64(0)
						_ = v33
						for {
							var tmp34 any
							tmp35 := checkDerefVar(glojure_DOT_core__LT_)
							tmp36 := lang.Apply(tmp35, []any{v33, v32})
							if lang.IsTruthy(tmp36) {
								var tmp37 any
								{ // let
									// let binding "arg"
									tmp38, _ := lang.FieldOrMethod(v31, "nth")
									if reflect.TypeOf(tmp38).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp39 := lang.Apply(tmp38, []any{v33})
									var v40 any = tmp39
									_ = v40
									var tmp41 any
									tmp42 := checkDerefVar(glojure_DOT_core_libspec_QMARK_)
									tmp43 := lang.Apply(tmp42, []any{v40})
									if lang.IsTruthy(tmp43) {
										tmp44 := checkDerefVar(glojure_DOT_core_apply)
										tmp45 := checkDerefVar(glojure_DOT_core_load_lib)
										tmp46 := checkDerefVar(glojure_DOT_core_prependss)
										tmp47 := lang.Apply(tmp46, []any{v40, v13})
										tmp48 := lang.Apply(tmp44, []any{tmp45, nil, tmp47})
										tmp41 = tmp48
									} else {
										var tmp49 any
										{ // let
											// let binding "vec__119"
											var v50 any = v40
											_ = v50
											// let binding "seq__120"
											tmp51 := checkDerefVar(glojure_DOT_core_seq)
											tmp52 := lang.Apply(tmp51, []any{v50})
											var v53 any = tmp52
											_ = v53
											// let binding "first__121"
											tmp54 := checkDerefVar(glojure_DOT_core_first)
											tmp55 := lang.Apply(tmp54, []any{v53})
											var v56 any = tmp55
											_ = v56
											// let binding "seq__120"
											tmp57 := checkDerefVar(glojure_DOT_core_next)
											tmp58 := lang.Apply(tmp57, []any{v53})
											var v59 any = tmp58
											_ = v59
											// let binding "prefix"
											var v60 any = v56
											_ = v60
											// let binding "args"
											var v61 any = v59
											_ = v61
											tmp62 := checkDerefVar(glojure_DOT_core_throw_if)
											tmp63 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
											tmp64 := lang.Apply(tmp63, []any{v60})
											tmp65 := lang.Apply(tmp62, []any{tmp64, "prefix cannot be nil"})
											_ = tmp65
											var tmp66 any
											{ // let
												// let binding "seq_122"
												tmp67 := checkDerefVar(glojure_DOT_core_seq)
												tmp68 := lang.Apply(tmp67, []any{v61})
												var v69 any = tmp68
												_ = v69
												// let binding "chunk_123"
												var v70 any = nil
												_ = v70
												// let binding "count_124"
												var v71 any = int64(0)
												_ = v71
												// let binding "i_125"
												var v72 any = int64(0)
												_ = v72
												for {
													var tmp73 any
													tmp74 := checkDerefVar(glojure_DOT_core__LT_)
													tmp75 := lang.Apply(tmp74, []any{v72, v71})
													if lang.IsTruthy(tmp75) {
														var tmp76 any
														{ // let
															// let binding "arg"
															tmp77, _ := lang.FieldOrMethod(v70, "nth")
															if reflect.TypeOf(tmp77).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp78 := lang.Apply(tmp77, []any{v72})
															var v79 any = tmp78
															_ = v79
															tmp80 := checkDerefVar(glojure_DOT_core_apply)
															tmp81 := checkDerefVar(glojure_DOT_core_load_lib)
															tmp82 := checkDerefVar(glojure_DOT_core_prependss)
															tmp83 := lang.Apply(tmp82, []any{v79, v13})
															tmp84 := lang.Apply(tmp80, []any{tmp81, v60, tmp83})
															_ = tmp84
															var tmp85 any = v69
															var tmp86 any = v70
															var tmp87 any = v71
															tmp89 := checkDerefVar(glojure_DOT_core_unchecked_inc)
															tmp90 := lang.Apply(tmp89, []any{v72})
															var tmp88 any = tmp90
															v69 = tmp85
															v70 = tmp86
															v71 = tmp87
															v72 = tmp88
															continue
														} // end let
														tmp73 = tmp76
													} else {
														var tmp77 any
														{ // let
															// let binding "temp__0__auto__"
															tmp78 := checkDerefVar(glojure_DOT_core_seq)
															tmp79 := lang.Apply(tmp78, []any{v69})
															var v80 any = tmp79
															_ = v80
															var tmp81 any
															if lang.IsTruthy(v80) {
																var tmp82 any
																{ // let
																	// let binding "seq_122"
																	var v83 any = v80
																	_ = v83
																	var tmp84 any
																	tmp85 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
																	tmp86 := lang.Apply(tmp85, []any{v83})
																	if lang.IsTruthy(tmp86) {
																		var tmp87 any
																		{ // let
																			// let binding "c__0__auto__"
																			tmp88 := checkDerefVar(glojure_DOT_core_chunk_first)
																			tmp89 := lang.Apply(tmp88, []any{v83})
																			var v90 any = tmp89
																			_ = v90
																			tmp92 := checkDerefVar(glojure_DOT_core_chunk_rest)
																			tmp93 := lang.Apply(tmp92, []any{v83})
																			var tmp91 any = tmp93
																			var tmp94 any = v90
																			tmp96 := checkDerefVar(glojure_DOT_core_int)
																			tmp97 := checkDerefVar(glojure_DOT_core_count)
																			tmp98 := lang.Apply(tmp97, []any{v90})
																			tmp99 := lang.Apply(tmp96, []any{tmp98})
																			var tmp95 any = tmp99
																			tmp101 := checkDerefVar(glojure_DOT_core_int)
																			tmp102 := lang.Apply(tmp101, []any{int64(0)})
																			var tmp100 any = tmp102
																			v69 = tmp91
																			v70 = tmp94
																			v71 = tmp95
																			v72 = tmp100
																			continue
																		} // end let
																		tmp84 = tmp87
																	} else {
																		var tmp88 any
																		{ // let
																			// let binding "arg"
																			tmp89 := checkDerefVar(glojure_DOT_core_first)
																			tmp90 := lang.Apply(tmp89, []any{v83})
																			var v91 any = tmp90
																			_ = v91
																			tmp92 := checkDerefVar(glojure_DOT_core_apply)
																			tmp93 := checkDerefVar(glojure_DOT_core_load_lib)
																			tmp94 := checkDerefVar(glojure_DOT_core_prependss)
																			tmp95 := lang.Apply(tmp94, []any{v91, v13})
																			tmp96 := lang.Apply(tmp92, []any{tmp93, v60, tmp95})
																			_ = tmp96
																			tmp98 := checkDerefVar(glojure_DOT_core_next)
																			tmp99 := lang.Apply(tmp98, []any{v83})
																			var tmp97 any = tmp99
																			var tmp100 any = nil
																			var tmp101 any = int64(0)
																			var tmp102 any = int64(0)
																			v69 = tmp97
																			v70 = tmp100
																			v71 = tmp101
																			v72 = tmp102
																			continue
																		} // end let
																		tmp84 = tmp88
																	}
																	tmp82 = tmp84
																} // end let
																tmp81 = tmp82
															} else {
															}
															tmp77 = tmp81
														} // end let
														tmp73 = tmp77
													}
													tmp66 = tmp73
													break
												}
											} // end let
											tmp49 = tmp66
										} // end let
										tmp41 = tmp49
									}
									_ = tmp41
									var tmp50 any = v30
									var tmp51 any = v31
									var tmp52 any = v32
									tmp54 := checkDerefVar(glojure_DOT_core_unchecked_inc)
									tmp55 := lang.Apply(tmp54, []any{v33})
									var tmp53 any = tmp55
									v30 = tmp50
									v31 = tmp51
									v32 = tmp52
									v33 = tmp53
									continue
								} // end let
								tmp34 = tmp37
							} else {
								var tmp38 any
								{ // let
									// let binding "temp__0__auto__"
									tmp39 := checkDerefVar(glojure_DOT_core_seq)
									tmp40 := lang.Apply(tmp39, []any{v30})
									var v41 any = tmp40
									_ = v41
									var tmp42 any
									if lang.IsTruthy(v41) {
										var tmp43 any
										{ // let
											// let binding "seq_115"
											var v44 any = v41
											_ = v44
											var tmp45 any
											tmp46 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
											tmp47 := lang.Apply(tmp46, []any{v44})
											if lang.IsTruthy(tmp47) {
												var tmp48 any
												{ // let
													// let binding "c__0__auto__"
													tmp49 := checkDerefVar(glojure_DOT_core_chunk_first)
													tmp50 := lang.Apply(tmp49, []any{v44})
													var v51 any = tmp50
													_ = v51
													tmp53 := checkDerefVar(glojure_DOT_core_chunk_rest)
													tmp54 := lang.Apply(tmp53, []any{v44})
													var tmp52 any = tmp54
													var tmp55 any = v51
													tmp57 := checkDerefVar(glojure_DOT_core_int)
													tmp58 := checkDerefVar(glojure_DOT_core_count)
													tmp59 := lang.Apply(tmp58, []any{v51})
													tmp60 := lang.Apply(tmp57, []any{tmp59})
													var tmp56 any = tmp60
													tmp62 := checkDerefVar(glojure_DOT_core_int)
													tmp63 := lang.Apply(tmp62, []any{int64(0)})
													var tmp61 any = tmp63
													v30 = tmp52
													v31 = tmp55
													v32 = tmp56
													v33 = tmp61
													continue
												} // end let
												tmp45 = tmp48
											} else {
												var tmp49 any
												{ // let
													// let binding "arg"
													tmp50 := checkDerefVar(glojure_DOT_core_first)
													tmp51 := lang.Apply(tmp50, []any{v44})
													var v52 any = tmp51
													_ = v52
													var tmp53 any
													tmp54 := checkDerefVar(glojure_DOT_core_libspec_QMARK_)
													tmp55 := lang.Apply(tmp54, []any{v52})
													if lang.IsTruthy(tmp55) {
														tmp56 := checkDerefVar(glojure_DOT_core_apply)
														tmp57 := checkDerefVar(glojure_DOT_core_load_lib)
														tmp58 := checkDerefVar(glojure_DOT_core_prependss)
														tmp59 := lang.Apply(tmp58, []any{v52, v13})
														tmp60 := lang.Apply(tmp56, []any{tmp57, nil, tmp59})
														tmp53 = tmp60
													} else {
														var tmp61 any
														{ // let
															// let binding "vec__126"
															var v62 any = v52
															_ = v62
															// let binding "seq__127"
															tmp63 := checkDerefVar(glojure_DOT_core_seq)
															tmp64 := lang.Apply(tmp63, []any{v62})
															var v65 any = tmp64
															_ = v65
															// let binding "first__128"
															tmp66 := checkDerefVar(glojure_DOT_core_first)
															tmp67 := lang.Apply(tmp66, []any{v65})
															var v68 any = tmp67
															_ = v68
															// let binding "seq__127"
															tmp69 := checkDerefVar(glojure_DOT_core_next)
															tmp70 := lang.Apply(tmp69, []any{v65})
															var v71 any = tmp70
															_ = v71
															// let binding "prefix"
															var v72 any = v68
															_ = v72
															// let binding "args"
															var v73 any = v71
															_ = v73
															tmp74 := checkDerefVar(glojure_DOT_core_throw_if)
															tmp75 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
															tmp76 := lang.Apply(tmp75, []any{v72})
															tmp77 := lang.Apply(tmp74, []any{tmp76, "prefix cannot be nil"})
															_ = tmp77
															var tmp78 any
															{ // let
																// let binding "seq_129"
																tmp79 := checkDerefVar(glojure_DOT_core_seq)
																tmp80 := lang.Apply(tmp79, []any{v73})
																var v81 any = tmp80
																_ = v81
																// let binding "chunk_130"
																var v82 any = nil
																_ = v82
																// let binding "count_131"
																var v83 any = int64(0)
																_ = v83
																// let binding "i_132"
																var v84 any = int64(0)
																_ = v84
																for {
																	var tmp85 any
																	tmp86 := checkDerefVar(glojure_DOT_core__LT_)
																	tmp87 := lang.Apply(tmp86, []any{v84, v83})
																	if lang.IsTruthy(tmp87) {
																		var tmp88 any
																		{ // let
																			// let binding "arg"
																			tmp89, _ := lang.FieldOrMethod(v82, "nth")
																			if reflect.TypeOf(tmp89).Kind() != reflect.Func {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
																			}
																			tmp90 := lang.Apply(tmp89, []any{v84})
																			var v91 any = tmp90
																			_ = v91
																			tmp92 := checkDerefVar(glojure_DOT_core_apply)
																			tmp93 := checkDerefVar(glojure_DOT_core_load_lib)
																			tmp94 := checkDerefVar(glojure_DOT_core_prependss)
																			tmp95 := lang.Apply(tmp94, []any{v91, v13})
																			tmp96 := lang.Apply(tmp92, []any{tmp93, v72, tmp95})
																			_ = tmp96
																			var tmp97 any = v81
																			var tmp98 any = v82
																			var tmp99 any = v83
																			tmp101 := checkDerefVar(glojure_DOT_core_unchecked_inc)
																			tmp102 := lang.Apply(tmp101, []any{v84})
																			var tmp100 any = tmp102
																			v81 = tmp97
																			v82 = tmp98
																			v83 = tmp99
																			v84 = tmp100
																			continue
																		} // end let
																		tmp85 = tmp88
																	} else {
																		var tmp89 any
																		{ // let
																			// let binding "temp__0__auto__"
																			tmp90 := checkDerefVar(glojure_DOT_core_seq)
																			tmp91 := lang.Apply(tmp90, []any{v81})
																			var v92 any = tmp91
																			_ = v92
																			var tmp93 any
																			if lang.IsTruthy(v92) {
																				var tmp94 any
																				{ // let
																					// let binding "seq_129"
																					var v95 any = v92
																					_ = v95
																					var tmp96 any
																					tmp97 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
																					tmp98 := lang.Apply(tmp97, []any{v95})
																					if lang.IsTruthy(tmp98) {
																						var tmp99 any
																						{ // let
																							// let binding "c__0__auto__"
																							tmp100 := checkDerefVar(glojure_DOT_core_chunk_first)
																							tmp101 := lang.Apply(tmp100, []any{v95})
																							var v102 any = tmp101
																							_ = v102
																							tmp104 := checkDerefVar(glojure_DOT_core_chunk_rest)
																							tmp105 := lang.Apply(tmp104, []any{v95})
																							var tmp103 any = tmp105
																							var tmp106 any = v102
																							tmp108 := checkDerefVar(glojure_DOT_core_int)
																							tmp109 := checkDerefVar(glojure_DOT_core_count)
																							tmp110 := lang.Apply(tmp109, []any{v102})
																							tmp111 := lang.Apply(tmp108, []any{tmp110})
																							var tmp107 any = tmp111
																							tmp113 := checkDerefVar(glojure_DOT_core_int)
																							tmp114 := lang.Apply(tmp113, []any{int64(0)})
																							var tmp112 any = tmp114
																							v81 = tmp103
																							v82 = tmp106
																							v83 = tmp107
																							v84 = tmp112
																							continue
																						} // end let
																						tmp96 = tmp99
																					} else {
																						var tmp100 any
																						{ // let
																							// let binding "arg"
																							tmp101 := checkDerefVar(glojure_DOT_core_first)
																							tmp102 := lang.Apply(tmp101, []any{v95})
																							var v103 any = tmp102
																							_ = v103
																							tmp104 := checkDerefVar(glojure_DOT_core_apply)
																							tmp105 := checkDerefVar(glojure_DOT_core_load_lib)
																							tmp106 := checkDerefVar(glojure_DOT_core_prependss)
																							tmp107 := lang.Apply(tmp106, []any{v103, v13})
																							tmp108 := lang.Apply(tmp104, []any{tmp105, v72, tmp107})
																							_ = tmp108
																							tmp110 := checkDerefVar(glojure_DOT_core_next)
																							tmp111 := lang.Apply(tmp110, []any{v95})
																							var tmp109 any = tmp111
																							var tmp112 any = nil
																							var tmp113 any = int64(0)
																							var tmp114 any = int64(0)
																							v81 = tmp109
																							v82 = tmp112
																							v83 = tmp113
																							v84 = tmp114
																							continue
																						} // end let
																						tmp96 = tmp100
																					}
																					tmp94 = tmp96
																				} // end let
																				tmp93 = tmp94
																			} else {
																			}
																			tmp89 = tmp93
																		} // end let
																		tmp85 = tmp89
																	}
																	tmp78 = tmp85
																	break
																}
															} // end let
															tmp61 = tmp78
														} // end let
														tmp53 = tmp61
													}
													_ = tmp53
													tmp63 := checkDerefVar(glojure_DOT_core_next)
													tmp64 := lang.Apply(tmp63, []any{v44})
													var tmp62 any = tmp64
													var tmp65 any = nil
													var tmp66 any = int64(0)
													var tmp67 any = int64(0)
													v30 = tmp62
													v31 = tmp65
													v32 = tmp66
													v33 = tmp67
													continue
												} // end let
												tmp45 = tmp49
											}
											tmp43 = tmp45
										} // end let
										tmp42 = tmp43
									} else {
									}
									tmp38 = tmp42
								} // end let
								tmp34 = tmp38
							}
							tmp27 = tmp34
							break
						}
					} // end let
					tmp4 = tmp27
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-one
	{
		tmp0 := lang.NewSymbol("load-one").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("lib"), lang.NewSymbol("need-ns"), lang.NewSymbol("require"))), lang.NewKeyword("doc"), "Loads a lib given its name. If need-ns, ensures that the associated\n  namespace exists after loading. If require, records the load so any\n  duplicate loads can be skipped.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5879), lang.NewKeyword("end-line"), int(5879), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := checkDerefVar(glojure_DOT_core_load)
			tmp7 := checkDerefVar(glojure_DOT_core_root_resource)
			tmp8 := lang.Apply(tmp7, []any{v3})
			tmp9 := lang.Apply(tmp6, []any{tmp8})
			_ = tmp9
			tmp10 := checkDerefVar(glojure_DOT_core_throw_if)
			var tmp11 any
			{ // let
				// let binding "and__0__auto__"
				var v12 any = v4
				_ = v12
				var tmp13 any
				if lang.IsTruthy(v12) {
					tmp14 := checkDerefVar(glojure_DOT_core_not)
					tmp15 := checkDerefVar(glojure_DOT_core_find_ns)
					tmp16 := lang.Apply(tmp15, []any{v3})
					tmp17 := lang.Apply(tmp14, []any{tmp16})
					tmp13 = tmp17
				} else {
					tmp13 = v12
				}
				tmp11 = tmp13
			} // end let
			tmp12 := checkDerefVar(glojure_DOT_core_root_resource)
			tmp13 := lang.Apply(tmp12, []any{v3})
			tmp14 := lang.Apply(tmp10, []any{tmp11, "namespace '%s' not found after loading '%s'", v3, tmp13})
			_ = tmp14
			var tmp15 any
			if lang.IsTruthy(v5) {
				var tmp16 lang.FnFunc
				tmp16 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					tmp17 := checkDerefVar(glojure_DOT_core_commute)
					tmp18 := checkDerefVar(glojure_DOT_core__STAR_loaded_libs_STAR_)
					tmp19 := checkDerefVar(glojure_DOT_core_conj)
					tmp20 := lang.Apply(tmp17, []any{tmp18, tmp19, v3})
					return tmp20
				})
				tmp17, _ := lang.FieldOrMethod(lang.LockingTransaction, "RunInTransaction")
				if reflect.TypeOf(tmp17).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("RunInTransaction is not a function")))
				}
				tmp18 := lang.Apply(tmp17, []any{tmp16})
				tmp15 = tmp18
			} else {
			}
			return tmp15
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-reader
	{
		tmp0 := lang.NewSymbol("load-reader").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rdr"))), lang.NewKeyword("doc"), "Sequentially read and evaluate the set of forms contained in the\n  stream/file", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4081), lang.NewKeyword("end-line"), int(4081))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime7.Compiler, "load")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("load is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-string
	{
		tmp0 := lang.NewSymbol("load-string").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Sequentially read and evaluate the set of forms contained in the\n  string", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4088), lang.NewKeyword("end-line"), int(4088))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "rdr"
				tmp5 := lang.Apply(nil, []any{v3})
				tmp6 := lang.Apply(nil, []any{tmp5})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_load_reader)
				tmp9 := lang.Apply(tmp8, []any{v7})
				tmp4 = tmp9
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// loaded-libs
	{
		tmp0 := lang.NewSymbol("loaded-libs").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Returns a sorted set of symbols naming the currently loaded libs", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6090), lang.NewKeyword("end-line"), int(6090))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := checkDerefVar(glojure_DOT_core_deref)
			tmp4 := checkDerefVar(glojure_DOT_core__STAR_loaded_libs_STAR_)
			tmp5 := lang.Apply(tmp3, []any{tmp4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// locking
	{
		tmp0 := lang.NewSymbol("locking").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Executes exprs in an implicit do, while holding the monitor of x.\n  Will release the monitor of x in all circumstances.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1643), lang.NewKeyword("end-line"), int(1643))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/let")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_apply)
				tmp13 := checkDerefVar(glojure_DOT_core_vector)
				tmp14 := checkDerefVar(glojure_DOT_core_seq)
				tmp15 := checkDerefVar(glojure_DOT_core_concat)
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("lockee__0__auto__")})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v5})
				tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
				tmp21 := lang.Apply(tmp14, []any{tmp20})
				tmp22 := lang.Apply(tmp12, []any{tmp13, tmp21})
				tmp23 := lang.Apply(tmp11, []any{tmp22})
				tmp24 := checkDerefVar(glojure_DOT_core_list)
				tmp25 := checkDerefVar(glojure_DOT_core_seq)
				tmp26 := checkDerefVar(glojure_DOT_core_concat)
				tmp27 := checkDerefVar(glojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("try")})
				tmp29 := checkDerefVar(glojure_DOT_core_list)
				tmp30 := checkDerefVar(glojure_DOT_core_seq)
				tmp31 := checkDerefVar(glojure_DOT_core_concat)
				tmp32 := checkDerefVar(glojure_DOT_core_list)
				tmp33 := lang.Apply(tmp32, []any{lang.NewSymbol("glojure.core/let")})
				tmp34 := checkDerefVar(glojure_DOT_core_list)
				tmp35 := checkDerefVar(glojure_DOT_core_apply)
				tmp36 := checkDerefVar(glojure_DOT_core_vector)
				tmp37 := checkDerefVar(glojure_DOT_core_seq)
				tmp38 := checkDerefVar(glojure_DOT_core_concat)
				tmp39 := checkDerefVar(glojure_DOT_core_list)
				tmp40 := lang.Apply(tmp39, []any{lang.NewSymbol("locklocal__1__auto__")})
				tmp41 := checkDerefVar(glojure_DOT_core_list)
				tmp42 := lang.Apply(tmp41, []any{lang.NewSymbol("lockee__0__auto__")})
				tmp43 := lang.Apply(tmp38, []any{tmp40, tmp42})
				tmp44 := lang.Apply(tmp37, []any{tmp43})
				tmp45 := lang.Apply(tmp35, []any{tmp36, tmp44})
				tmp46 := lang.Apply(tmp34, []any{tmp45})
				tmp47 := checkDerefVar(glojure_DOT_core_list)
				tmp48 := checkDerefVar(glojure_DOT_core_seq)
				tmp49 := checkDerefVar(glojure_DOT_core_concat)
				tmp50 := checkDerefVar(glojure_DOT_core_list)
				tmp51 := lang.Apply(tmp50, []any{lang.NewSymbol("monitor-enter")})
				tmp52 := checkDerefVar(glojure_DOT_core_list)
				tmp53 := lang.Apply(tmp52, []any{lang.NewSymbol("locklocal__1__auto__")})
				tmp54 := lang.Apply(tmp49, []any{tmp51, tmp53})
				tmp55 := lang.Apply(tmp48, []any{tmp54})
				tmp56 := lang.Apply(tmp47, []any{tmp55})
				tmp57 := checkDerefVar(glojure_DOT_core_list)
				tmp58 := checkDerefVar(glojure_DOT_core_seq)
				tmp59 := checkDerefVar(glojure_DOT_core_concat)
				tmp60 := checkDerefVar(glojure_DOT_core_list)
				tmp61 := lang.Apply(tmp60, []any{lang.NewSymbol("try")})
				tmp62 := checkDerefVar(glojure_DOT_core_list)
				tmp63 := checkDerefVar(glojure_DOT_core_seq)
				tmp64 := checkDerefVar(glojure_DOT_core_concat)
				tmp65 := checkDerefVar(glojure_DOT_core_list)
				tmp66 := lang.Apply(tmp65, []any{lang.NewSymbol("finally")})
				tmp67 := checkDerefVar(glojure_DOT_core_list)
				tmp68 := checkDerefVar(glojure_DOT_core_seq)
				tmp69 := checkDerefVar(glojure_DOT_core_concat)
				tmp70 := checkDerefVar(glojure_DOT_core_list)
				tmp71 := lang.Apply(tmp70, []any{lang.NewSymbol("monitor-exit")})
				tmp72 := checkDerefVar(glojure_DOT_core_list)
				tmp73 := lang.Apply(tmp72, []any{lang.NewSymbol("locklocal__1__auto__")})
				tmp74 := lang.Apply(tmp69, []any{tmp71, tmp73})
				tmp75 := lang.Apply(tmp68, []any{tmp74})
				tmp76 := lang.Apply(tmp67, []any{tmp75})
				tmp77 := lang.Apply(tmp64, []any{tmp66, tmp76})
				tmp78 := lang.Apply(tmp63, []any{tmp77})
				tmp79 := lang.Apply(tmp62, []any{tmp78})
				tmp80 := lang.Apply(tmp59, []any{tmp61, v6, tmp79})
				tmp81 := lang.Apply(tmp58, []any{tmp80})
				tmp82 := lang.Apply(tmp57, []any{tmp81})
				tmp83 := lang.Apply(tmp31, []any{tmp33, tmp46, tmp56, tmp82})
				tmp84 := lang.Apply(tmp30, []any{tmp83})
				tmp85 := lang.Apply(tmp29, []any{tmp84})
				tmp86 := lang.Apply(tmp26, []any{tmp28, tmp85})
				tmp87 := lang.Apply(tmp25, []any{tmp86})
				tmp88 := lang.Apply(tmp24, []any{tmp87})
				tmp89 := lang.Apply(tmp8, []any{tmp10, tmp23, tmp88})
				tmp90 := lang.Apply(tmp7, []any{tmp89})
				return tmp90
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// long
	{
		var tmp1 lang.FnFunc
		{ // function long__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/LongCast")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("long").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to long", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3481), lang.NewKeyword("end-line"), int(3481))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.LongCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// long-array
	{
		var tmp1 lang.FnFunc
		{ // function long-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(glojure_DOT_core_seq)
					tmp5 := checkDerefVar(glojure_DOT_core_concat)
					tmp6 := checkDerefVar(glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
					tmp8 := checkDerefVar(glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/LongArray")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.core/args")})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("long-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of longs", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5364), lang.NewKeyword("end-line"), int(5364))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "LongArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("LongArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "LongArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("LongArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// longs
	{
		var tmp1 lang.FnFunc
		{ // function longs
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/Longs")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("longs").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to long[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5407), lang.NewKeyword("end-line"), int(5407))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Longs")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Longs is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// loop
	{
		tmp0 := lang.NewSymbol("loop").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", lang.NewKeyword("forms"), lang.NewVector(lang.NewList(lang.NewSymbol("loop"), lang.NewVector(lang.NewSymbol("bindings*")), lang.NewSymbol("exprs*"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4597), lang.NewKeyword("end-line"), int(4597), lang.NewKeyword("special-form"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(glojure_DOT_core_str)
					tmp11 := checkDerefVar(glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(lang.NewKeyword("line"), []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "db"
					tmp34 := checkDerefVar(glojure_DOT_core_destructure)
					tmp35 := lang.Apply(tmp34, []any{v5})
					var v36 any = tmp35
					_ = v36
					var tmp37 any
					tmp38 := checkDerefVar(glojure_DOT_core__EQ_)
					tmp39 := lang.Apply(tmp38, []any{v36, v5})
					if lang.IsTruthy(tmp39) {
						tmp40 := checkDerefVar(glojure_DOT_core_seq)
						tmp41 := checkDerefVar(glojure_DOT_core_concat)
						tmp42 := checkDerefVar(glojure_DOT_core_list)
						tmp43 := lang.Apply(tmp42, []any{lang.NewSymbol("loop*")})
						tmp44 := checkDerefVar(glojure_DOT_core_list)
						tmp45 := lang.Apply(tmp44, []any{v5})
						tmp46 := lang.Apply(tmp41, []any{tmp43, tmp45, v6})
						tmp47 := lang.Apply(tmp40, []any{tmp46})
						tmp37 = tmp47
					} else {
						var tmp48 any
						{ // let
							// let binding "vs"
							tmp49 := checkDerefVar(glojure_DOT_core_take_nth)
							tmp50 := checkDerefVar(glojure_DOT_core_drop)
							tmp51 := lang.Apply(tmp50, []any{int64(1), v5})
							tmp52 := lang.Apply(tmp49, []any{int64(2), tmp51})
							var v53 any = tmp52
							_ = v53
							// let binding "bs"
							tmp54 := checkDerefVar(glojure_DOT_core_take_nth)
							tmp55 := lang.Apply(tmp54, []any{int64(2), v5})
							var v56 any = tmp55
							_ = v56
							// let binding "gs"
							tmp57 := checkDerefVar(glojure_DOT_core_map)
							var tmp58 lang.FnFunc
							tmp58 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v59 := args[0]
								_ = v59
								var tmp60 any
								tmp61 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
								tmp62 := lang.Apply(tmp61, []any{v59})
								if lang.IsTruthy(tmp62) {
									tmp60 = v59
								} else {
									tmp63 := checkDerefVar(glojure_DOT_core_gensym)
									tmp64 := lang.Apply(tmp63, nil)
									tmp60 = tmp64
								}
								return tmp60
							})
							tmp59 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4611), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(4611), lang.NewKeyword("end-column"), int(58))
							tmp60, err := lang.WithMeta(tmp58, tmp59.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp61 := lang.Apply(tmp57, []any{tmp60, v56})
							var v62 any = tmp61
							_ = v62
							// let binding "bfs"
							tmp63 := checkDerefVar(glojure_DOT_core_reduce1)
							var tmp64 lang.FnFunc
							tmp64 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v65 := args[0]
								_ = v65
								v66 := args[1]
								_ = v66
								var tmp67 any
								{ // let
									// let binding "vec__17"
									var v68 any = v66
									_ = v68
									// let binding "b"
									tmp69 := checkDerefVar(glojure_DOT_core_nth)
									tmp70 := lang.Apply(tmp69, []any{v68, int64(0), nil})
									var v71 any = tmp70
									_ = v71
									// let binding "v"
									tmp72 := checkDerefVar(glojure_DOT_core_nth)
									tmp73 := lang.Apply(tmp72, []any{v68, int64(1), nil})
									var v74 any = tmp73
									_ = v74
									// let binding "g"
									tmp75 := checkDerefVar(glojure_DOT_core_nth)
									tmp76 := lang.Apply(tmp75, []any{v68, int64(2), nil})
									var v77 any = tmp76
									_ = v77
									var tmp78 any
									tmp79 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
									tmp80 := lang.Apply(tmp79, []any{v71})
									if lang.IsTruthy(tmp80) {
										tmp81 := checkDerefVar(glojure_DOT_core_conj)
										tmp82 := lang.Apply(tmp81, []any{v65, v77, v74})
										tmp78 = tmp82
									} else {
										tmp83 := checkDerefVar(glojure_DOT_core_conj)
										tmp84 := lang.Apply(tmp83, []any{v65, v77, v74, v71, v77})
										tmp78 = tmp84
									}
									tmp67 = tmp78
								} // end let
								return tmp67
							})
							tmp65 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4612), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(4615), lang.NewKeyword("end-column"), int(50))
							tmp66, err := lang.WithMeta(tmp64, tmp65.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp67 := lang.NewVector()
							tmp68 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4616), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(4616), lang.NewKeyword("end-column"), int(28))
							tmp69, err := lang.WithMeta(tmp67, tmp68.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp70 := checkDerefVar(glojure_DOT_core_map)
							tmp71 := checkDerefVar(glojure_DOT_core_vector)
							tmp72 := lang.Apply(tmp70, []any{tmp71, v56, v53, v62})
							tmp73 := lang.Apply(tmp63, []any{tmp66, tmp69, tmp72})
							var v74 any = tmp73
							_ = v74
							tmp75 := checkDerefVar(glojure_DOT_core_seq)
							tmp76 := checkDerefVar(glojure_DOT_core_concat)
							tmp77 := checkDerefVar(glojure_DOT_core_list)
							tmp78 := lang.Apply(tmp77, []any{lang.NewSymbol("glojure.core/let")})
							tmp79 := checkDerefVar(glojure_DOT_core_list)
							tmp80 := lang.Apply(tmp79, []any{v74})
							tmp81 := checkDerefVar(glojure_DOT_core_list)
							tmp82 := checkDerefVar(glojure_DOT_core_seq)
							tmp83 := checkDerefVar(glojure_DOT_core_concat)
							tmp84 := checkDerefVar(glojure_DOT_core_list)
							tmp85 := lang.Apply(tmp84, []any{lang.NewSymbol("loop*")})
							tmp86 := checkDerefVar(glojure_DOT_core_list)
							tmp87 := checkDerefVar(glojure_DOT_core_vec)
							tmp88 := checkDerefVar(glojure_DOT_core_interleave)
							tmp89 := lang.Apply(tmp88, []any{v62, v62})
							tmp90 := lang.Apply(tmp87, []any{tmp89})
							tmp91 := lang.Apply(tmp86, []any{tmp90})
							tmp92 := checkDerefVar(glojure_DOT_core_list)
							tmp93 := checkDerefVar(glojure_DOT_core_seq)
							tmp94 := checkDerefVar(glojure_DOT_core_concat)
							tmp95 := checkDerefVar(glojure_DOT_core_list)
							tmp96 := lang.Apply(tmp95, []any{lang.NewSymbol("glojure.core/let")})
							tmp97 := checkDerefVar(glojure_DOT_core_list)
							tmp98 := checkDerefVar(glojure_DOT_core_vec)
							tmp99 := checkDerefVar(glojure_DOT_core_interleave)
							tmp100 := lang.Apply(tmp99, []any{v56, v62})
							tmp101 := lang.Apply(tmp98, []any{tmp100})
							tmp102 := lang.Apply(tmp97, []any{tmp101})
							tmp103 := lang.Apply(tmp94, []any{tmp96, tmp102, v6})
							tmp104 := lang.Apply(tmp93, []any{tmp103})
							tmp105 := lang.Apply(tmp92, []any{tmp104})
							tmp106 := lang.Apply(tmp83, []any{tmp85, tmp91, tmp105})
							tmp107 := lang.Apply(tmp82, []any{tmp106})
							tmp108 := lang.Apply(tmp81, []any{tmp107})
							tmp109 := lang.Apply(tmp76, []any{tmp78, tmp80, tmp108})
							tmp110 := lang.Apply(tmp75, []any{tmp109})
							tmp48 = tmp110
						} // end let
						tmp37 = tmp48
					}
					tmp33 = tmp37
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// macroexpand
	{
		tmp0 := lang.NewSymbol("macroexpand").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("form"))), lang.NewKeyword("doc"), "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4025), lang.NewKeyword("end-line"), int(4025))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ex"
				tmp5 := checkDerefVar(glojure_DOT_core_macroexpand_1)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(glojure_DOT_core_identical_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v7, v3})
				if lang.IsTruthy(tmp10) {
					tmp8 = v3
				} else {
					tmp11 := checkDerefVar(glojure_DOT_core_macroexpand)
					tmp12 := lang.Apply(tmp11, []any{v7})
					tmp8 = tmp12
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// macroexpand-1
	{
		tmp0 := lang.NewSymbol("macroexpand-1").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("form"))), lang.NewKeyword("doc"), "If form represents a macro form, returns its expansion,\n  else returns form.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4017), lang.NewKeyword("end-line"), int(4017))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime7.Compiler, "macroexpand1")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("macroexpand1 is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-array
	{
		tmp0 := lang.NewSymbol("make-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("type"), lang.NewSymbol("len")), lang.NewVector(lang.NewSymbol("type"), lang.NewSymbol("dim"), lang.NewSymbol("&"), lang.NewSymbol("more-dims"))), lang.NewKeyword("doc"), "Creates and returns an array of instances of the specified class of\n  the specified dimension(s).  Note that a class object is required.\n  Class objects can be obtained by using their imported or\n  fully-qualified name.  Class objects for the primitive types can be\n  obtained using, e.g., Integer/TYPE.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3985), lang.NewKeyword("end-line"), int(3985))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_int)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7, _ := lang.FieldOrMethod(nil, "newInstance")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("newInstance is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v3, tmp6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "dims"
					tmp7 := checkDerefVar(glojure_DOT_core_cons)
					tmp8 := lang.Apply(tmp7, []any{v4, v5})
					var v9 any = tmp8
					_ = v9
					// let binding "dimarray"
					tmp10 := checkDerefVar(glojure_DOT_core_make_array)
					tmp11, ok := lang.FieldOrMethod(nil, "TYPE")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "TYPE")))
					}
					var tmp12 any
					switch reflect.TypeOf(tmp11).Kind() {
					case reflect.Func:
						tmp12 = lang.Apply(tmp11, nil)
					default:
						tmp12 = tmp11
					}
					tmp13 := checkDerefVar(glojure_DOT_core_count)
					tmp14 := lang.Apply(tmp13, []any{v9})
					tmp15 := lang.Apply(tmp10, []any{tmp12, tmp14})
					var v16 any = tmp15
					_ = v16
					var tmp17 any
					{ // let
						// let binding "n__0__auto__"
						tmp18 := checkDerefVar(glojure_DOT_core_long)
						tmp19 := checkDerefVar(glojure_DOT_core_alength)
						tmp20 := lang.Apply(tmp19, []any{v16})
						tmp21 := lang.Apply(tmp18, []any{tmp20})
						var v22 any = tmp21
						_ = v22
						var tmp23 any
						{ // let
							// let binding "i"
							var v24 any = int64(0)
							_ = v24
							for {
								var tmp25 any
								tmp26 := checkDerefVar(glojure_DOT_core__LT_)
								tmp27 := lang.Apply(tmp26, []any{v24, v22})
								if lang.IsTruthy(tmp27) {
									tmp28 := checkDerefVar(glojure_DOT_core_aset_int)
									tmp29 := checkDerefVar(glojure_DOT_core_nth)
									tmp30 := lang.Apply(tmp29, []any{v9, v24})
									tmp31 := lang.Apply(tmp28, []any{v16, v24, tmp30})
									_ = tmp31
									tmp33 := checkDerefVar(glojure_DOT_core_unchecked_inc)
									tmp34 := lang.Apply(tmp33, []any{v24})
									var tmp32 any = tmp34
									v24 = tmp32
									continue
								} else {
								}
								tmp23 = tmp25
								break
							}
						} // end let
						tmp17 = tmp23
					} // end let
					_ = tmp17
					tmp18, _ := lang.FieldOrMethod(nil, "newInstance")
					if reflect.TypeOf(tmp18).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("newInstance is not a function")))
					}
					tmp19 := lang.Apply(tmp18, []any{v3, v16})
					tmp6 = tmp19
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-hierarchy
	{
		tmp0 := lang.NewSymbol("make-hierarchy").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Creates a hierarchy object for use with derive, isa? etc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5507), lang.NewKeyword("end-line"), int(5507))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.NewMap()
			tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5511), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(5511), lang.NewKeyword("end-column"), int(17))
			tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp6 := lang.NewMap()
			tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5511), lang.NewKeyword("column"), int(32), lang.NewKeyword("end-line"), int(5511), lang.NewKeyword("end-column"), int(33))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := lang.NewMap()
			tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5511), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(5511), lang.NewKeyword("end-column"), int(47))
			tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp12 := lang.NewMap(lang.NewKeyword("parents"), tmp5, lang.NewKeyword("descendants"), tmp8, lang.NewKeyword("ancestors"), tmp11)
			tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5511), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(5511), lang.NewKeyword("end-column"), int(48))
			tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp14
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map
	{
		tmp0 := lang.NewSymbol("map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2"), lang.NewSymbol("c3")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2"), lang.NewSymbol("c3"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2719), lang.NewKeyword("end-line"), int(2719))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							tmp9 := lang.Apply(v3, []any{v8})
							tmp10 := lang.Apply(v5, []any{v7, tmp9})
							return tmp10
						default:
							if len(args) < 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var v9 any = lang.NewList(args[2:]...)
							_ = v9
							tmp10 := checkDerefVar(glojure_DOT_core_apply)
							tmp11 := lang.Apply(tmp10, []any{v3, v8, v9})
							tmp12 := lang.Apply(v5, []any{v7, tmp11})
							return tmp12
						}
					})
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2730), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(2736), lang.NewKeyword("end-column"), int(47))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2729), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2736), lang.NewKeyword("end-column"), int(48))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								tmp14 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
								tmp15 := lang.Apply(tmp14, []any{v12})
								if lang.IsTruthy(tmp15) {
									var tmp16 any
									{ // let
										// let binding "c"
										tmp17 := checkDerefVar(glojure_DOT_core_chunk_first)
										tmp18 := lang.Apply(tmp17, []any{v12})
										var v19 any = tmp18
										_ = v19
										// let binding "size"
										tmp20 := checkDerefVar(glojure_DOT_core_int)
										tmp21 := checkDerefVar(glojure_DOT_core_count)
										tmp22 := lang.Apply(tmp21, []any{v19})
										tmp23 := lang.Apply(tmp20, []any{tmp22})
										var v24 any = tmp23
										_ = v24
										// let binding "b"
										tmp25 := checkDerefVar(glojure_DOT_core_chunk_buffer)
										tmp26 := lang.Apply(tmp25, []any{v24})
										var v27 any = tmp26
										_ = v27
										var tmp28 any
										{ // let
											// let binding "n__0__auto__"
											tmp29 := lang.Apply(lang.LongCast, []any{v24})
											var v30 any = tmp29
											_ = v30
											var tmp31 any
											{ // let
												// let binding "i"
												var v32 any = int64(0)
												_ = v32
												for {
													var tmp33 any
													tmp34 := checkDerefVar(glojure_DOT_core__LT_)
													tmp35 := lang.Apply(tmp34, []any{v32, v30})
													if lang.IsTruthy(tmp35) {
														tmp36 := checkDerefVar(glojure_DOT_core_chunk_append)
														tmp37, _ := lang.FieldOrMethod(v19, "nth")
														if reflect.TypeOf(tmp37).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
														}
														tmp38 := lang.Apply(tmp37, []any{v32})
														tmp39 := lang.Apply(v3, []any{tmp38})
														tmp40 := lang.Apply(tmp36, []any{v27, tmp39})
														_ = tmp40
														tmp42 := checkDerefVar(glojure_DOT_core_unchecked_inc)
														tmp43 := lang.Apply(tmp42, []any{v32})
														var tmp41 any = tmp43
														v32 = tmp41
														continue
													} else {
													}
													tmp31 = tmp33
													break
												}
											} // end let
											tmp28 = tmp31
										} // end let
										_ = tmp28
										tmp29 := checkDerefVar(glojure_DOT_core_chunk_cons)
										tmp30 := checkDerefVar(glojure_DOT_core_chunk)
										tmp31 := lang.Apply(tmp30, []any{v27})
										tmp32 := checkDerefVar(glojure_DOT_core_map)
										tmp33 := checkDerefVar(glojure_DOT_core_chunk_rest)
										tmp34 := lang.Apply(tmp33, []any{v12})
										tmp35 := lang.Apply(tmp32, []any{v3, tmp34})
										tmp36 := lang.Apply(tmp29, []any{tmp31, tmp35})
										tmp16 = tmp36
									} // end let
									tmp13 = tmp16
								} else {
									tmp17 := checkDerefVar(glojure_DOT_core_cons)
									tmp18 := checkDerefVar(glojure_DOT_core_first)
									tmp19 := lang.Apply(tmp18, []any{v12})
									tmp20 := lang.Apply(v3, []any{tmp19})
									tmp21 := checkDerefVar(glojure_DOT_core_map)
									tmp22 := checkDerefVar(glojure_DOT_core_rest)
									tmp23 := lang.Apply(tmp22, []any{v12})
									tmp24 := lang.Apply(tmp21, []any{v3, tmp23})
									tmp25 := lang.Apply(tmp17, []any{tmp20, tmp24})
									tmp13 = tmp25
								}
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "s1"
						tmp8 := checkDerefVar(glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v4})
						var v10 any = tmp9
						_ = v10
						// let binding "s2"
						tmp11 := checkDerefVar(glojure_DOT_core_seq)
						tmp12 := lang.Apply(tmp11, []any{v5})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						var tmp15 any
						{ // let
							// let binding "and__0__auto__"
							var v16 any = v10
							_ = v16
							var tmp17 any
							if lang.IsTruthy(v16) {
								tmp17 = v13
							} else {
								tmp17 = v16
							}
							tmp15 = tmp17
						} // end let
						if lang.IsTruthy(tmp15) {
							tmp16 := checkDerefVar(glojure_DOT_core_cons)
							tmp17 := checkDerefVar(glojure_DOT_core_first)
							tmp18 := lang.Apply(tmp17, []any{v10})
							tmp19 := checkDerefVar(glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v13})
							tmp21 := lang.Apply(v3, []any{tmp18, tmp20})
							tmp22 := checkDerefVar(glojure_DOT_core_map)
							tmp23 := checkDerefVar(glojure_DOT_core_rest)
							tmp24 := lang.Apply(tmp23, []any{v10})
							tmp25 := checkDerefVar(glojure_DOT_core_rest)
							tmp26 := lang.Apply(tmp25, []any{v13})
							tmp27 := lang.Apply(tmp22, []any{v3, tmp24, tmp26})
							tmp28 := lang.Apply(tmp16, []any{tmp21, tmp27})
							tmp14 = tmp28
						} else {
						}
						tmp7 = tmp14
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp8 any
					{ // let
						// let binding "s1"
						tmp9 := checkDerefVar(glojure_DOT_core_seq)
						tmp10 := lang.Apply(tmp9, []any{v4})
						var v11 any = tmp10
						_ = v11
						// let binding "s2"
						tmp12 := checkDerefVar(glojure_DOT_core_seq)
						tmp13 := lang.Apply(tmp12, []any{v5})
						var v14 any = tmp13
						_ = v14
						// let binding "s3"
						tmp15 := checkDerefVar(glojure_DOT_core_seq)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var v17 any = tmp16
						_ = v17
						var tmp18 any
						var tmp19 any
						{ // let
							// let binding "and__0__auto__"
							var v20 any = v11
							_ = v20
							var tmp21 any
							if lang.IsTruthy(v20) {
								var tmp22 any
								{ // let
									// let binding "and__0__auto__"
									var v23 any = v14
									_ = v23
									var tmp24 any
									if lang.IsTruthy(v23) {
										tmp24 = v17
									} else {
										tmp24 = v23
									}
									tmp22 = tmp24
								} // end let
								tmp21 = tmp22
							} else {
								tmp21 = v20
							}
							tmp19 = tmp21
						} // end let
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(glojure_DOT_core_cons)
							tmp21 := checkDerefVar(glojure_DOT_core_first)
							tmp22 := lang.Apply(tmp21, []any{v11})
							tmp23 := checkDerefVar(glojure_DOT_core_first)
							tmp24 := lang.Apply(tmp23, []any{v14})
							tmp25 := checkDerefVar(glojure_DOT_core_first)
							tmp26 := lang.Apply(tmp25, []any{v17})
							tmp27 := lang.Apply(v3, []any{tmp22, tmp24, tmp26})
							tmp28 := checkDerefVar(glojure_DOT_core_map)
							tmp29 := checkDerefVar(glojure_DOT_core_rest)
							tmp30 := lang.Apply(tmp29, []any{v11})
							tmp31 := checkDerefVar(glojure_DOT_core_rest)
							tmp32 := lang.Apply(tmp31, []any{v14})
							tmp33 := checkDerefVar(glojure_DOT_core_rest)
							tmp34 := lang.Apply(tmp33, []any{v17})
							tmp35 := lang.Apply(tmp28, []any{v3, tmp30, tmp32, tmp34})
							tmp36 := lang.Apply(tmp20, []any{tmp27, tmp35})
							tmp18 = tmp36
						} else {
						}
						tmp8 = tmp18
					} // end let
					return tmp8
				})
				tmp8 := lang.Apply(lang.NewLazySeq, []any{tmp7})
				return tmp8
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 any
				{ // let
					// let binding "step"
					var tmp9 lang.FnFunc
					{ // function step
						var v10 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v11 := args[0]
							_ = v11
							var tmp12 lang.FnFunc
							tmp12 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								var tmp13 any
								{ // let
									// let binding "ss"
									tmp14 := checkDerefVar(glojure_DOT_core_map)
									tmp15 := checkDerefVar(glojure_DOT_core_seq)
									tmp16 := lang.Apply(tmp14, []any{tmp15, v11})
									var v17 any = tmp16
									_ = v17
									var tmp18 any
									tmp19 := checkDerefVar(glojure_DOT_core_every_QMARK_)
									tmp20 := checkDerefVar(glojure_DOT_core_identity)
									tmp21 := lang.Apply(tmp19, []any{tmp20, v17})
									if lang.IsTruthy(tmp21) {
										tmp22 := checkDerefVar(glojure_DOT_core_cons)
										tmp23 := checkDerefVar(glojure_DOT_core_map)
										tmp24 := checkDerefVar(glojure_DOT_core_first)
										tmp25 := lang.Apply(tmp23, []any{tmp24, v17})
										tmp26 := checkDerefVar(glojure_DOT_core_map)
										tmp27 := checkDerefVar(glojure_DOT_core_rest)
										tmp28 := lang.Apply(tmp26, []any{tmp27, v17})
										tmp29 := lang.Apply(v10, []any{tmp28})
										tmp30 := lang.Apply(tmp22, []any{tmp25, tmp29})
										tmp18 = tmp30
									} else {
									}
									tmp13 = tmp18
								} // end let
								return tmp13
							})
							tmp13 := lang.Apply(lang.NewLazySeq, []any{tmp12})
							return tmp13
						})
						v10 = tmp9
						_ = v10
					}
					tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2761), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(2765), lang.NewKeyword("end-column"), int(68))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v12 any = tmp11
					_ = v12
					tmp13 := checkDerefVar(glojure_DOT_core_map)
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						tmp16 := checkDerefVar(glojure_DOT_core_apply)
						tmp17 := lang.Apply(tmp16, []any{v3, v15})
						return tmp17
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2766), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(2766), lang.NewKeyword("end-column"), int(22))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := checkDerefVar(glojure_DOT_core_conj)
					tmp18 := lang.Apply(tmp17, []any{v7, v6, v5, v4})
					tmp19 := lang.Apply(v12, []any{tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp16, tmp19})
					tmp8 = tmp20
				} // end let
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map-entry?
	{
		tmp0 := lang.NewSymbol("map-entry?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a map entry", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.8", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1473), lang.NewKeyword("end-line"), int(1473))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.MapEntry)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map-indexed
	{
		tmp0 := lang.NewSymbol("map-indexed").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7309), lang.NewKeyword("end-line"), int(7309))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "i"
						tmp7 := checkDerefVar(glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{int64(-1)})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								tmp13 := checkDerefVar(glojure_DOT_core_inc)
								tmp14, ok := lang.FieldOrMethod(v9, "Deref")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Deref")))
								}
								var tmp15 any
								switch reflect.TypeOf(tmp14).Kind() {
								case reflect.Func:
									tmp15 = lang.Apply(tmp14, nil)
								default:
									tmp15 = tmp14
								}
								tmp16 := lang.Apply(tmp13, []any{tmp15})
								tmp17, _ := lang.FieldOrMethod(v9, "reset")
								if reflect.TypeOf(tmp17).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
								}
								tmp18 := lang.Apply(tmp17, []any{tmp16})
								tmp19 := lang.Apply(v3, []any{tmp18, v12})
								tmp20 := lang.Apply(v5, []any{v11, tmp19})
								return tmp20
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7320), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7324), lang.NewKeyword("end-column"), int(48))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7318), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(7324), lang.NewKeyword("end-column"), int(50))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return nil
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map?
	{
		tmp0 := lang.NewSymbol("map?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x implements IPersistentMap", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(167), lang.NewKeyword("end-line"), int(171))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function map?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v4})
				return tmp7
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(171), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(171), lang.NewKeyword("end-column"), int(97))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mapcat
	{
		tmp0 := lang.NewSymbol("mapcat").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2775), lang.NewKeyword("end-line"), int(2775))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_comp)
				tmp5 := checkDerefVar(glojure_DOT_core_map)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := checkDerefVar(glojure_DOT_core_cat)
				tmp8 := lang.Apply(tmp4, []any{tmp6, tmp7})
				return tmp8
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_apply)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_map)
				tmp9 := lang.Apply(tmp7, []any{tmp8, v3, v4})
				tmp10 := lang.Apply(tmp5, []any{tmp6, tmp9})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mapv
	{
		tmp0 := lang.NewSymbol("mapv").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2"), lang.NewSymbol("c3")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2"), lang.NewSymbol("c3"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6943), lang.NewKeyword("end-line"), int(6943))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
				tmp6 := checkDerefVar(glojure_DOT_core_reduce)
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v8 := args[0]
					_ = v8
					v9 := args[1]
					_ = v9
					tmp10 := checkDerefVar(glojure_DOT_core_conj_BANG_)
					tmp11 := lang.Apply(v3, []any{v9})
					tmp12 := lang.Apply(tmp10, []any{v8, tmp11})
					return tmp12
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6952), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(6952), lang.NewKeyword("end-column"), int(43))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := checkDerefVar(glojure_DOT_core_transient)
				tmp11 := lang.NewVector()
				tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6952), lang.NewKeyword("column"), int(56), lang.NewKeyword("end-line"), int(6952), lang.NewKeyword("end-column"), int(57))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.Apply(tmp10, []any{tmp13})
				tmp15 := lang.Apply(tmp6, []any{tmp9, tmp14, v4})
				tmp16 := lang.Apply(tmp5, []any{tmp15})
				return tmp16
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_into)
				tmp7 := lang.NewVector()
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6955), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(6955), lang.NewKeyword("end-column"), int(13))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := checkDerefVar(glojure_DOT_core_map)
				tmp11 := lang.Apply(tmp10, []any{v3, v4, v5})
				tmp12 := lang.Apply(tmp6, []any{tmp9, tmp11})
				return tmp12
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_into)
				tmp8 := lang.NewVector()
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6957), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(6957), lang.NewKeyword("end-column"), int(13))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := checkDerefVar(glojure_DOT_core_map)
				tmp12 := lang.Apply(tmp11, []any{v3, v4, v5, v6})
				tmp13 := lang.Apply(tmp7, []any{tmp10, tmp12})
				return tmp13
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_into)
				tmp9 := lang.NewVector()
				tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6959), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(6959), lang.NewKeyword("end-column"), int(13))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := checkDerefVar(glojure_DOT_core_apply)
				tmp13 := checkDerefVar(glojure_DOT_core_map)
				tmp14 := lang.Apply(tmp12, []any{tmp13, v3, v4, v5, v6, v7})
				tmp15 := lang.Apply(tmp8, []any{tmp11, tmp14})
				return tmp15
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed33
					} else {
						tmp4 = closed33
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed33
					} else {
						tmp5 = closed33
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed33
					} else {
						tmp6 = closed33
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("max").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the greatest of the nums.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1108), lang.NewKeyword("end-line"), int(1108))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				return v5
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Max")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Max is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core_max)
				tmp10 := checkDerefVar(glojure_DOT_core_max)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-key
	{
		tmp0 := lang.NewSymbol("max-key").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5013), lang.NewKeyword("end-line"), int(5013))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return v4
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(glojure_DOT_core__GT_)
				tmp8 := lang.Apply(v3, []any{v4})
				tmp9 := lang.Apply(v3, []any{v5})
				tmp10 := lang.Apply(tmp7, []any{tmp8, tmp9})
				if lang.IsTruthy(tmp10) {
					tmp6 = v4
				} else {
					tmp6 = v5
				}
				return tmp6
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "kx"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ky"
					tmp10 := lang.Apply(v3, []any{v5})
					var v11 any = tmp10
					_ = v11
					// let binding "vec__55"
					var tmp12 any
					tmp13 := checkDerefVar(glojure_DOT_core__GT_)
					tmp14 := lang.Apply(tmp13, []any{v9, v11})
					if lang.IsTruthy(tmp14) {
						tmp15 := lang.NewVector(v4, v9)
						tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5023), lang.NewKeyword("column"), int(31), lang.NewKeyword("end-line"), int(5023), lang.NewKeyword("end-column"), int(36))
						tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp17
					} else {
						tmp18 := lang.NewVector(v5, v11)
						tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5023), lang.NewKeyword("column"), int(38), lang.NewKeyword("end-line"), int(5023), lang.NewKeyword("end-column"), int(43))
						tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp20
					}
					var v21 any = tmp12
					_ = v21
					// let binding "v"
					tmp22 := checkDerefVar(glojure_DOT_core_nth)
					tmp23 := lang.Apply(tmp22, []any{v21, int64(0), nil})
					var v24 any = tmp23
					_ = v24
					// let binding "kv"
					tmp25 := checkDerefVar(glojure_DOT_core_nth)
					tmp26 := lang.Apply(tmp25, []any{v21, int64(1), nil})
					var v27 any = tmp26
					_ = v27
					var tmp28 any
					{ // let
						// let binding "v"
						var v29 any = v24
						_ = v29
						// let binding "kv"
						var v30 any = v27
						_ = v30
						// let binding "more"
						var v31 any = v6
						_ = v31
						for {
							var tmp32 any
							if lang.IsTruthy(v31) {
								var tmp33 any
								{ // let
									// let binding "w"
									tmp34 := checkDerefVar(glojure_DOT_core_first)
									tmp35 := lang.Apply(tmp34, []any{v31})
									var v36 any = tmp35
									_ = v36
									// let binding "kw"
									tmp37 := lang.Apply(v3, []any{v36})
									var v38 any = tmp37
									_ = v38
									var tmp39 any
									tmp40 := checkDerefVar(glojure_DOT_core__GT__EQ_)
									tmp41 := lang.Apply(tmp40, []any{v38, v30})
									if lang.IsTruthy(tmp41) {
										var tmp42 any = v36
										var tmp43 any = v38
										tmp45 := checkDerefVar(glojure_DOT_core_next)
										tmp46 := lang.Apply(tmp45, []any{v31})
										var tmp44 any = tmp46
										v29 = tmp42
										v30 = tmp43
										v31 = tmp44
										continue
									} else {
										var tmp47 any = v29
										var tmp48 any = v30
										tmp50 := checkDerefVar(glojure_DOT_core_next)
										tmp51 := lang.Apply(tmp50, []any{v31})
										var tmp49 any = tmp51
										v29 = tmp47
										v30 = tmp48
										v31 = tmp49
										continue
									}
									tmp33 = tmp39
								} // end let
								tmp32 = tmp33
							} else {
								tmp32 = v29
							}
							tmp28 = tmp32
							break
						}
					} // end let
					tmp7 = tmp28
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-mask-bits
	{
		tmp0 := lang.NewSymbol("max-mask-bits").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6601), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(6601), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, int64(13), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-switch-table-size
	{
		tmp0 := lang.NewSymbol("max-switch-table-size").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6602), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(6602), lang.NewKeyword("end-column"), int(36), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, int64(8192), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// maybe-destructured
	{
		tmp0 := lang.NewSymbol("maybe-destructured").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4514), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(4515), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("params"), lang.NewSymbol("body"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_every_QMARK_)
			tmp7 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			if lang.IsTruthy(tmp8) {
				tmp9 := checkDerefVar(glojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp5 = tmp10
			} else {
				var tmp11 any
				{ // let
					// let binding "params"
					var v12 any = v3
					_ = v12
					// let binding "new-params"
					tmp13 := checkDerefVar(glojure_DOT_core_with_meta)
					tmp14 := lang.NewVector()
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4520), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(4520), lang.NewKeyword("end-column"), int(35))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := checkDerefVar(glojure_DOT_core_meta)
					tmp18 := lang.Apply(tmp17, []any{v12})
					tmp19 := lang.Apply(tmp13, []any{tmp16, tmp18})
					var v20 any = tmp19
					_ = v20
					// let binding "lets"
					tmp21 := lang.NewVector()
					tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4521), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(4521), lang.NewKeyword("end-column"), int(18))
					tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v24 any = tmp23
					_ = v24
					for {
						var tmp25 any
						if lang.IsTruthy(v12) {
							var tmp26 any
							tmp27 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
							tmp28 := checkDerefVar(glojure_DOT_core_first)
							tmp29 := lang.Apply(tmp28, []any{v12})
							tmp30 := lang.Apply(tmp27, []any{tmp29})
							if lang.IsTruthy(tmp30) {
								tmp32 := checkDerefVar(glojure_DOT_core_next)
								tmp33 := lang.Apply(tmp32, []any{v12})
								var tmp31 any = tmp33
								tmp35 := checkDerefVar(glojure_DOT_core_conj)
								tmp36 := checkDerefVar(glojure_DOT_core_first)
								tmp37 := lang.Apply(tmp36, []any{v12})
								tmp38 := lang.Apply(tmp35, []any{v20, tmp37})
								var tmp34 any = tmp38
								var tmp39 any = v24
								v12 = tmp31
								v20 = tmp34
								v24 = tmp39
								continue
							} else {
								var tmp40 any
								{ // let
									// let binding "gparam"
									tmp41 := checkDerefVar(glojure_DOT_core_gensym)
									tmp42 := lang.Apply(tmp41, []any{"p__"})
									var v43 any = tmp42
									_ = v43
									tmp45 := checkDerefVar(glojure_DOT_core_next)
									tmp46 := lang.Apply(tmp45, []any{v12})
									var tmp44 any = tmp46
									tmp48 := checkDerefVar(glojure_DOT_core_conj)
									tmp49 := lang.Apply(tmp48, []any{v20, v43})
									var tmp47 any = tmp49
									tmp51 := checkDerefVar(glojure_DOT_core_conj)
									tmp52 := checkDerefVar(glojure_DOT_core_conj)
									tmp53 := checkDerefVar(glojure_DOT_core_first)
									tmp54 := lang.Apply(tmp53, []any{v12})
									tmp55 := lang.Apply(tmp52, []any{v24, tmp54})
									tmp56 := lang.Apply(tmp51, []any{tmp55, v43})
									var tmp50 any = tmp56
									v12 = tmp44
									v20 = tmp47
									v24 = tmp50
									continue
								} // end let
								tmp26 = tmp40
							}
							tmp25 = tmp26
						} else {
							tmp41 := checkDerefVar(glojure_DOT_core_seq)
							tmp42 := checkDerefVar(glojure_DOT_core_concat)
							tmp43 := checkDerefVar(glojure_DOT_core_list)
							tmp44 := lang.Apply(tmp43, []any{v20})
							tmp45 := checkDerefVar(glojure_DOT_core_list)
							tmp46 := checkDerefVar(glojure_DOT_core_seq)
							tmp47 := checkDerefVar(glojure_DOT_core_concat)
							tmp48 := checkDerefVar(glojure_DOT_core_list)
							tmp49 := lang.Apply(tmp48, []any{lang.NewSymbol("glojure.core/let")})
							tmp50 := checkDerefVar(glojure_DOT_core_list)
							tmp51 := lang.Apply(tmp50, []any{v24})
							tmp52 := lang.Apply(tmp47, []any{tmp49, tmp51, v4})
							tmp53 := lang.Apply(tmp46, []any{tmp52})
							tmp54 := lang.Apply(tmp45, []any{tmp53})
							tmp55 := lang.Apply(tmp42, []any{tmp44, tmp54})
							tmp56 := lang.Apply(tmp41, []any{tmp55})
							tmp25 = tmp56
						}
						tmp11 = tmp25
						break
					}
				} // end let
				tmp5 = tmp11
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// maybe-min-hash
	{
		tmp0 := lang.NewSymbol("maybe-min-hash").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("hashes"))), lang.NewKeyword("doc"), "takes a collection of hashes and returns [shift mask] or nil if none found", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6604), lang.NewKeyword("end-line"), int(6604), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_first)
			tmp5 := checkDerefVar(glojure_DOT_core_filter)
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v7 := args[0]
				_ = v7
				var tmp8 any
				{ // let
					// let binding "vec__151"
					var v9 any = v7
					_ = v9
					// let binding "s"
					tmp10 := checkDerefVar(glojure_DOT_core_nth)
					tmp11 := lang.Apply(tmp10, []any{v9, int64(0), nil})
					var v12 any = tmp11
					_ = v12
					// let binding "m"
					tmp13 := checkDerefVar(glojure_DOT_core_nth)
					tmp14 := lang.Apply(tmp13, []any{v9, int64(1), nil})
					var v15 any = tmp14
					_ = v15
					tmp16 := checkDerefVar(glojure_DOT_core_apply)
					tmp17 := checkDerefVar(glojure_DOT_core_distinct_QMARK_)
					tmp18 := checkDerefVar(glojure_DOT_core_map)
					var tmp19 lang.FnFunc
					tmp19 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v20 := args[0]
						_ = v20
						tmp21 := checkDerefVar(glojure_DOT_core_shift_mask)
						tmp22 := lang.Apply(tmp21, []any{v12, v15, v20})
						return tmp22
					})
					tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6609), lang.NewKeyword("column"), int(37), lang.NewKeyword("end-line"), int(6609), lang.NewKeyword("end-column"), int(55))
					tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp22 := lang.Apply(tmp18, []any{tmp21, v3})
					tmp23 := lang.Apply(tmp16, []any{tmp17, tmp22})
					tmp8 = tmp23
				} // end let
				return tmp8
			})
			tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6608), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(6609), lang.NewKeyword("end-column"), int(65))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp9 any
			{ // let
				// let binding "iter__0__auto__"
				var tmp10 lang.FnFunc
				{ // function iter__154
					var v11 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v12 := args[0]
						_ = v12
						var tmp13 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							var tmp14 any
							{ // let
								// let binding "s__155"
								var v15 any = v12
								_ = v15
								for {
									var tmp16 any
									{ // let
										// let binding "temp__0__auto__"
										tmp17 := checkDerefVar(glojure_DOT_core_seq)
										tmp18 := lang.Apply(tmp17, []any{v15})
										var v19 any = tmp18
										_ = v19
										var tmp20 any
										if lang.IsTruthy(v19) {
											var tmp21 any
											{ // let
												// let binding "xs__0__auto__"
												var v22 any = v19
												_ = v22
												var tmp23 any
												{ // let
													// let binding "mask"
													tmp24 := checkDerefVar(glojure_DOT_core_first)
													tmp25 := lang.Apply(tmp24, []any{v22})
													var v26 any = tmp25
													_ = v26
													var tmp27 any
													{ // let
														// let binding "iterys__0__auto__"
														var tmp28 lang.FnFunc
														{ // function iter__156
															var v29 lang.FnFunc
															tmp28 = lang.NewFnFunc(func(args ...any) any {
																if len(args) != 1 {
																	panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
																}
																v30 := args[0]
																_ = v30
																var tmp31 lang.FnFunc
																tmp31 = lang.NewFnFunc(func(args ...any) any {
																	if len(args) != 0 {
																		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
																	}
																	var tmp32 any
																	{ // let
																		// let binding "s__157"
																		var v33 any = v30
																		_ = v33
																		for {
																			var tmp34 any
																			{ // let
																				// let binding "temp__0__auto__"
																				tmp35 := checkDerefVar(glojure_DOT_core_seq)
																				tmp36 := lang.Apply(tmp35, []any{v33})
																				var v37 any = tmp36
																				_ = v37
																				var tmp38 any
																				if lang.IsTruthy(v37) {
																					var tmp39 any
																					{ // let
																						// let binding "s__157"
																						var v40 any = v37
																						_ = v40
																						var tmp41 any
																						tmp42 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
																						tmp43 := lang.Apply(tmp42, []any{v40})
																						if lang.IsTruthy(tmp43) {
																							var tmp44 any
																							{ // let
																								// let binding "c__0__auto__"
																								tmp45 := checkDerefVar(glojure_DOT_core_chunk_first)
																								tmp46 := lang.Apply(tmp45, []any{v40})
																								var v47 any = tmp46
																								_ = v47
																								// let binding "size__1__auto__"
																								tmp48 := checkDerefVar(glojure_DOT_core_int)
																								tmp49 := checkDerefVar(glojure_DOT_core_count)
																								tmp50 := lang.Apply(tmp49, []any{v47})
																								tmp51 := lang.Apply(tmp48, []any{tmp50})
																								var v52 any = tmp51
																								_ = v52
																								// let binding "b__159"
																								tmp53 := checkDerefVar(glojure_DOT_core_chunk_buffer)
																								tmp54 := lang.Apply(tmp53, []any{v52})
																								var v55 any = tmp54
																								_ = v55
																								var tmp56 any
																								var tmp57 any
																								{ // let
																									// let binding "i__158"
																									tmp58 := checkDerefVar(glojure_DOT_core_int)
																									tmp59 := lang.Apply(tmp58, []any{int64(0)})
																									var v60 any = tmp59
																									_ = v60
																									for {
																										var tmp61 any
																										tmp62 := checkDerefVar(glojure_DOT_core__LT_)
																										tmp63 := lang.Apply(tmp62, []any{v60, v52})
																										if lang.IsTruthy(tmp63) {
																											var tmp64 any
																											{ // let
																												// let binding "shift"
																												tmp65, _ := lang.FieldOrMethod(v47, "nth")
																												if reflect.TypeOf(tmp65).Kind() != reflect.Func {
																													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
																												}
																												tmp66 := lang.Apply(tmp65, []any{v60})
																												var v67 any = tmp66
																												_ = v67
																												tmp68 := checkDerefVar(glojure_DOT_core_chunk_append)
																												tmp69 := lang.NewVector(v67, v26)
																												tmp70 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6612), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(6612), lang.NewKeyword("end-column"), int(26))
																												tmp71, err := lang.WithMeta(tmp69, tmp70.(lang.IPersistentMap))
																												if err != nil {
																													panic(err)
																												}
																												tmp72 := lang.Apply(tmp68, []any{v55, tmp71})
																												_ = tmp72
																												tmp74 := checkDerefVar(glojure_DOT_core_unchecked_inc)
																												tmp75 := lang.Apply(tmp74, []any{v60})
																												var tmp73 any = tmp75
																												v60 = tmp73
																												continue
																											} // end let
																											tmp61 = tmp64
																										} else {
																											tmp61 = true
																										}
																										tmp57 = tmp61
																										break
																									}
																								} // end let
																								if lang.IsTruthy(tmp57) {
																									tmp58 := checkDerefVar(glojure_DOT_core_chunk_cons)
																									tmp59 := checkDerefVar(glojure_DOT_core_chunk)
																									tmp60 := lang.Apply(tmp59, []any{v55})
																									tmp61 := checkDerefVar(glojure_DOT_core_chunk_rest)
																									tmp62 := lang.Apply(tmp61, []any{v40})
																									tmp63 := lang.Apply(v29, []any{tmp62})
																									tmp64 := lang.Apply(tmp58, []any{tmp60, tmp63})
																									tmp56 = tmp64
																								} else {
																									tmp65 := checkDerefVar(glojure_DOT_core_chunk_cons)
																									tmp66 := checkDerefVar(glojure_DOT_core_chunk)
																									tmp67 := lang.Apply(tmp66, []any{v55})
																									tmp68 := lang.Apply(tmp65, []any{tmp67, nil})
																									tmp56 = tmp68
																								}
																								tmp44 = tmp56
																							} // end let
																							tmp41 = tmp44
																						} else {
																							var tmp45 any
																							{ // let
																								// let binding "shift"
																								tmp46 := checkDerefVar(glojure_DOT_core_first)
																								tmp47 := lang.Apply(tmp46, []any{v40})
																								var v48 any = tmp47
																								_ = v48
																								tmp49 := checkDerefVar(glojure_DOT_core_cons)
																								tmp50 := lang.NewVector(v48, v26)
																								tmp51 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6612), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(6612), lang.NewKeyword("end-column"), int(26))
																								tmp52, err := lang.WithMeta(tmp50, tmp51.(lang.IPersistentMap))
																								if err != nil {
																									panic(err)
																								}
																								tmp53 := checkDerefVar(glojure_DOT_core_rest)
																								tmp54 := lang.Apply(tmp53, []any{v40})
																								tmp55 := lang.Apply(v29, []any{tmp54})
																								tmp56 := lang.Apply(tmp49, []any{tmp52, tmp55})
																								tmp45 = tmp56
																							} // end let
																							tmp41 = tmp45
																						}
																						tmp39 = tmp41
																					} // end let
																					tmp38 = tmp39
																				} else {
																				}
																				tmp34 = tmp38
																			} // end let
																			tmp32 = tmp34
																			break
																		}
																	} // end let
																	return tmp32
																})
																tmp32 := lang.Apply(lang.NewLazySeq, []any{tmp31})
																return tmp32
															})
															v29 = tmp28
															_ = v29
														}
														var v29 any = tmp28
														_ = v29
														// let binding "fs__1__auto__"
														tmp30 := checkDerefVar(glojure_DOT_core_seq)
														tmp31 := checkDerefVar(glojure_DOT_core_range)
														tmp32 := lang.Apply(tmp31, []any{int64(0), int64(31)})
														tmp33 := lang.Apply(v29, []any{tmp32})
														tmp34 := lang.Apply(tmp30, []any{tmp33})
														var v35 any = tmp34
														_ = v35
														var tmp36 any
														if lang.IsTruthy(v35) {
															tmp37 := checkDerefVar(glojure_DOT_core_concat)
															tmp38 := checkDerefVar(glojure_DOT_core_rest)
															tmp39 := lang.Apply(tmp38, []any{v15})
															tmp40 := lang.Apply(v11, []any{tmp39})
															tmp41 := lang.Apply(tmp37, []any{v35, tmp40})
															tmp36 = tmp41
														} else {
															tmp43 := checkDerefVar(glojure_DOT_core_rest)
															tmp44 := lang.Apply(tmp43, []any{v15})
															var tmp42 any = tmp44
															v15 = tmp42
															continue
														}
														tmp27 = tmp36
													} // end let
													tmp23 = tmp27
												} // end let
												tmp21 = tmp23
											} // end let
											tmp20 = tmp21
										} else {
										}
										tmp16 = tmp20
									} // end let
									tmp14 = tmp16
									break
								}
							} // end let
							return tmp14
						})
						tmp14 := lang.Apply(lang.NewLazySeq, []any{tmp13})
						return tmp14
					})
					v11 = tmp10
					_ = v11
				}
				var v11 any = tmp10
				_ = v11
				tmp12 := checkDerefVar(glojure_DOT_core_map)
				var tmp13 lang.FnFunc
				tmp13 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v14 := args[0]
					_ = v14
					tmp15 := checkDerefVar(glojure_DOT_core_dec)
					tmp16 := checkDerefVar(glojure_DOT_core_bit_shift_left)
					tmp17 := lang.Apply(tmp16, []any{int64(1), v14})
					tmp18 := lang.Apply(tmp15, []any{tmp17})
					return tmp18
				})
				tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6610), lang.NewKeyword("column"), int(29), lang.NewKeyword("end-line"), int(6610), lang.NewKeyword("end-column"), int(55))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp16 := checkDerefVar(glojure_DOT_core_range)
				tmp17 := checkDerefVar(glojure_DOT_core_inc)
				tmp18 := checkDerefVar(glojure_DOT_core_max_mask_bits)
				tmp19 := lang.Apply(tmp17, []any{tmp18})
				tmp20 := lang.Apply(tmp16, []any{int64(1), tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp15, tmp20})
				tmp22 := lang.Apply(v11, []any{tmp21})
				tmp9 = tmp22
			} // end let
			tmp10 := lang.Apply(tmp5, []any{tmp8, tmp9})
			tmp11 := lang.Apply(tmp4, []any{tmp10})
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// memfn
	{
		tmp0 := lang.NewSymbol("memfn").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3872), lang.NewKeyword("end-line"), int(3872))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "t"
					tmp8 := checkDerefVar(glojure_DOT_core_with_meta)
					tmp9 := checkDerefVar(glojure_DOT_core_gensym)
					tmp10 := lang.Apply(tmp9, []any{"target"})
					tmp11 := checkDerefVar(glojure_DOT_core_meta)
					tmp12 := lang.Apply(tmp11, []any{v5})
					tmp13 := lang.Apply(tmp8, []any{tmp10, tmp12})
					var v14 any = tmp13
					_ = v14
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.core/fn")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_apply)
					tmp21 := checkDerefVar(glojure_DOT_core_vector)
					tmp22 := checkDerefVar(glojure_DOT_core_seq)
					tmp23 := checkDerefVar(glojure_DOT_core_concat)
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v14})
					tmp26 := lang.Apply(tmp23, []any{tmp25, v6})
					tmp27 := lang.Apply(tmp22, []any{tmp26})
					tmp28 := lang.Apply(tmp20, []any{tmp21, tmp27})
					tmp29 := lang.Apply(tmp19, []any{tmp28})
					tmp30 := checkDerefVar(glojure_DOT_core_list)
					tmp31 := checkDerefVar(glojure_DOT_core_seq)
					tmp32 := checkDerefVar(glojure_DOT_core_concat)
					tmp33 := checkDerefVar(glojure_DOT_core_list)
					tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol(".")})
					tmp35 := checkDerefVar(glojure_DOT_core_list)
					tmp36 := lang.Apply(tmp35, []any{v14})
					tmp37 := checkDerefVar(glojure_DOT_core_list)
					tmp38 := checkDerefVar(glojure_DOT_core_seq)
					tmp39 := checkDerefVar(glojure_DOT_core_concat)
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{v5})
					tmp42 := lang.Apply(tmp39, []any{tmp41, v6})
					tmp43 := lang.Apply(tmp38, []any{tmp42})
					tmp44 := lang.Apply(tmp37, []any{tmp43})
					tmp45 := lang.Apply(tmp32, []any{tmp34, tmp36, tmp44})
					tmp46 := lang.Apply(tmp31, []any{tmp45})
					tmp47 := lang.Apply(tmp30, []any{tmp46})
					tmp48 := lang.Apply(tmp16, []any{tmp18, tmp29, tmp47})
					tmp49 := lang.Apply(tmp15, []any{tmp48})
					tmp7 = tmp49
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// memoize
	{
		tmp0 := lang.NewSymbol("memoize").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6337), lang.NewKeyword("end-line"), int(6337))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "mem"
				tmp5 := checkDerefVar(glojure_DOT_core_atom)
				tmp6 := lang.NewMap()
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6345), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(6345), lang.NewKeyword("end-column"), int(20))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				var v10 any = tmp9
				_ = v10
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						if len(args) < 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var v12 any = lang.NewList(args[0:]...)
						_ = v12
						var tmp13 any
						{ // let
							// let binding "temp__0__auto__"
							tmp14 := checkDerefVar(glojure_DOT_core_find)
							tmp15 := checkDerefVar(glojure_DOT_core_deref)
							tmp16 := lang.Apply(tmp15, []any{v10})
							tmp17 := lang.Apply(tmp14, []any{tmp16, v12})
							var v18 any = tmp17
							_ = v18
							var tmp19 any
							if lang.IsTruthy(v18) {
								var tmp20 any
								{ // let
									// let binding "e"
									var v21 any = v18
									_ = v21
									tmp22 := checkDerefVar(glojure_DOT_core_val)
									tmp23 := lang.Apply(tmp22, []any{v21})
									tmp20 = tmp23
								} // end let
								tmp19 = tmp20
							} else {
								var tmp21 any
								{ // let
									// let binding "ret"
									tmp22 := checkDerefVar(glojure_DOT_core_apply)
									tmp23 := lang.Apply(tmp22, []any{v3, v12})
									var v24 any = tmp23
									_ = v24
									tmp25 := checkDerefVar(glojure_DOT_core_swap_BANG_)
									tmp26 := checkDerefVar(glojure_DOT_core_assoc)
									tmp27 := lang.Apply(tmp25, []any{v10, tmp26, v12, v24})
									_ = tmp27
									tmp21 = v24
								} // end let
								tmp19 = tmp21
							}
							tmp13 = tmp19
						} // end let
						return tmp13
					}
				})
				tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6346), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(6351), lang.NewKeyword("end-column"), int(16))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp13
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge
	{
		tmp0 := lang.NewSymbol("merge").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("maps"))), lang.NewKeyword("doc"), "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3040), lang.NewKeyword("end-line"), int(3040))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(glojure_DOT_core_some)
				tmp6 := checkDerefVar(glojure_DOT_core_identity)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp9 lang.FnFunc
					tmp9 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v10 := args[0]
						_ = v10
						v11 := args[1]
						_ = v11
						tmp12 := checkDerefVar(glojure_DOT_core_conj)
						var tmp13 any
						{ // let
							// let binding "or__0__auto__"
							var v14 any = v10
							_ = v14
							var tmp15 any
							if lang.IsTruthy(v14) {
								tmp15 = v14
							} else {
								tmp16 := lang.NewMap()
								tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3048), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(3048), lang.NewKeyword("end-column"), int(29))
								tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp15 = tmp18
							}
							tmp13 = tmp15
						} // end let
						tmp14 := lang.Apply(tmp12, []any{tmp13, v11})
						return tmp14
					})
					tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3048), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(3048), lang.NewKeyword("end-column"), int(34))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 := lang.Apply(tmp8, []any{tmp11, v3})
					tmp4 = tmp12
				} else {
				}
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge-hash-collisions
	{
		tmp0 := lang.NewSymbol("merge-hash-collisions").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr-sym"), lang.NewSymbol("default"), lang.NewSymbol("tests"), lang.NewSymbol("thens"))), lang.NewKeyword("doc"), "Takes a case expression, default expression, and a sequence of test constants\n  and a corresponding sequence of then expressions. Returns a tuple of\n  [tests thens skip-check-set] where no tests have the same hash. Each set of\n  input test constants with the same hash is replaced with a single test\n  constant (the case int), and their respective thens are combined into:\n  (condp = expr\n    test-1 then-1\n    ...\n    test-n then-n\n    default).\n  The skip-check is a set of case ints for which post-switch equivalence\n  checking must not be done (the cases holding the above condp thens).", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6647), lang.NewKeyword("end-line"), int(6647), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			var tmp7 any
			{ // let
				// let binding "buckets"
				var tmp8 any
				{ // let
					// let binding "m"
					tmp9 := lang.NewMap()
					tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6661), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(6661), lang.NewKeyword("end-column"), int(27))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v12 any = tmp11
					_ = v12
					// let binding "ks"
					var v13 any = v5
					_ = v13
					// let binding "vs"
					var v14 any = v6
					_ = v14
					for {
						var tmp15 any
						var tmp16 any
						{ // let
							// let binding "and__0__auto__"
							var v17 any = v13
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								tmp18 = v14
							} else {
								tmp18 = v17
							}
							tmp16 = tmp18
						} // end let
						if lang.IsTruthy(tmp16) {
							tmp18 := checkDerefVar(glojure_DOT_core_update)
							tmp19 := checkDerefVar(glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v13})
							tmp21 := lang.Apply(lang.Hash, []any{tmp20})
							tmp22 := checkDerefVar(glojure_DOT_core_fnil)
							tmp23 := checkDerefVar(glojure_DOT_core_conj)
							tmp24 := lang.NewVector()
							tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6664), lang.NewKeyword("column"), int(102), lang.NewKeyword("end-line"), int(6664), lang.NewKeyword("end-column"), int(103))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp27 := lang.Apply(tmp22, []any{tmp23, tmp26})
							tmp28 := checkDerefVar(glojure_DOT_core_first)
							tmp29 := lang.Apply(tmp28, []any{v13})
							tmp30 := checkDerefVar(glojure_DOT_core_first)
							tmp31 := lang.Apply(tmp30, []any{v14})
							tmp32 := lang.NewVector(tmp29, tmp31)
							tmp33 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6664), lang.NewKeyword("column"), int(106), lang.NewKeyword("end-line"), int(6664), lang.NewKeyword("end-column"), int(128))
							tmp34, err := lang.WithMeta(tmp32, tmp33.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp35 := lang.Apply(tmp18, []any{v12, tmp21, tmp27, tmp34})
							var tmp17 any = tmp35
							tmp37 := checkDerefVar(glojure_DOT_core_next)
							tmp38 := lang.Apply(tmp37, []any{v13})
							var tmp36 any = tmp38
							tmp40 := checkDerefVar(glojure_DOT_core_next)
							tmp41 := lang.Apply(tmp40, []any{v14})
							var tmp39 any = tmp41
							v12 = tmp17
							v13 = tmp36
							v14 = tmp39
							continue
						} else {
							tmp15 = v12
						}
						tmp8 = tmp15
						break
					}
				} // end let
				var v9 any = tmp8
				_ = v9
				// let binding "assoc-multi"
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 3 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v11 := args[0]
					_ = v11
					v12 := args[1]
					_ = v12
					v13 := args[2]
					_ = v13
					var tmp14 any
					{ // let
						// let binding "testexprs"
						tmp15 := checkDerefVar(glojure_DOT_core_mapcat)
						var tmp16 lang.FnFunc
						tmp16 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v17 := args[0]
							_ = v17
							tmp18 := checkDerefVar(glojure_DOT_core_list)
							tmp19 := checkDerefVar(glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v17})
							tmp21 := lang.Apply(tmp18, []any{lang.NewSymbol("quote"), tmp20})
							tmp22 := checkDerefVar(glojure_DOT_core_second)
							tmp23 := lang.Apply(tmp22, []any{v17})
							tmp24 := lang.NewVector(tmp21, tmp23)
							tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6668), lang.NewKeyword("column"), int(56), lang.NewKeyword("end-line"), int(6668), lang.NewKeyword("end-column"), int(93))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							return tmp26
						})
						tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6668), lang.NewKeyword("column"), int(47), lang.NewKeyword("end-line"), int(6668), lang.NewKeyword("end-column"), int(94))
						tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp19 := lang.Apply(tmp15, []any{tmp18, v13})
						var v20 any = tmp19
						_ = v20
						// let binding "expr"
						tmp21 := checkDerefVar(glojure_DOT_core_seq)
						tmp22 := checkDerefVar(glojure_DOT_core_concat)
						tmp23 := checkDerefVar(glojure_DOT_core_list)
						tmp24 := lang.Apply(tmp23, []any{lang.NewSymbol("glojure.core/condp")})
						tmp25 := checkDerefVar(glojure_DOT_core_list)
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol("glojure.core/=")})
						tmp27 := checkDerefVar(glojure_DOT_core_list)
						tmp28 := lang.Apply(tmp27, []any{v3})
						tmp29 := checkDerefVar(glojure_DOT_core_list)
						tmp30 := lang.Apply(tmp29, []any{v4})
						tmp31 := lang.Apply(tmp22, []any{tmp24, tmp26, tmp28, v20, tmp30})
						tmp32 := lang.Apply(tmp21, []any{tmp31})
						var v33 any = tmp32
						_ = v33
						tmp34 := checkDerefVar(glojure_DOT_core_assoc)
						tmp35 := lang.Apply(tmp34, []any{v11, v12, v33})
						tmp14 = tmp35
					} // end let
					return tmp14
				})
				tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6667), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(6670), lang.NewKeyword("end-column"), int(42))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v13 any = tmp12
				_ = v13
				// let binding "hmap"
				tmp14 := checkDerefVar(glojure_DOT_core_reduce1)
				var tmp15 lang.FnFunc
				tmp15 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v16 := args[0]
					_ = v16
					v17 := args[1]
					_ = v17
					var tmp18 any
					{ // let
						// let binding "vec__164"
						var v19 any = v17
						_ = v19
						// let binding "h"
						tmp20 := checkDerefVar(glojure_DOT_core_nth)
						tmp21 := lang.Apply(tmp20, []any{v19, int64(0), nil})
						var v22 any = tmp21
						_ = v22
						// let binding "bucket"
						tmp23 := checkDerefVar(glojure_DOT_core_nth)
						tmp24 := lang.Apply(tmp23, []any{v19, int64(1), nil})
						var v25 any = tmp24
						_ = v25
						var tmp26 any
						tmp27 := checkDerefVar(glojure_DOT_core__EQ__EQ_)
						tmp28 := checkDerefVar(glojure_DOT_core_count)
						tmp29 := lang.Apply(tmp28, []any{v25})
						tmp30 := lang.Apply(tmp27, []any{int64(1), tmp29})
						if lang.IsTruthy(tmp30) {
							tmp31 := checkDerefVar(glojure_DOT_core_assoc)
							tmp32 := checkDerefVar(glojure_DOT_core_ffirst)
							tmp33 := lang.Apply(tmp32, []any{v25})
							tmp34 := checkDerefVar(glojure_DOT_core_second)
							tmp35 := checkDerefVar(glojure_DOT_core_first)
							tmp36 := lang.Apply(tmp35, []any{v25})
							tmp37 := lang.Apply(tmp34, []any{tmp36})
							tmp38 := lang.Apply(tmp31, []any{v16, tmp33, tmp37})
							tmp26 = tmp38
						} else {
							tmp39 := lang.Apply(v13, []any{v16, v22, v25})
							tmp26 = tmp39
						}
						tmp18 = tmp26
					} // end let
					return tmp18
				})
				tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6672), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(6675), lang.NewKeyword("end-column"), int(45))
				tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp18 := lang.NewMap()
				tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6676), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(6676), lang.NewKeyword("end-column"), int(17))
				tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp21 := lang.Apply(tmp14, []any{tmp17, tmp20, v9})
				var v22 any = tmp21
				_ = v22
				// let binding "skip-check"
				tmp23 := checkDerefVar(glojure_DOT_core_into1)
				tmp24 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6680), lang.NewKeyword("column"), int(29), lang.NewKeyword("end-line"), int(6680), lang.NewKeyword("end-column"), int(31))
				tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp27 := checkDerefVar(glojure_DOT_core_map)
				tmp28 := checkDerefVar(glojure_DOT_core_first)
				tmp29 := checkDerefVar(glojure_DOT_core_filter)
				var tmp30 lang.FnFunc
				tmp30 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v31 := args[0]
					_ = v31
					tmp32 := checkDerefVar(glojure_DOT_core__LT_)
					tmp33 := checkDerefVar(glojure_DOT_core_count)
					tmp34 := checkDerefVar(glojure_DOT_core_second)
					tmp35 := lang.Apply(tmp34, []any{v31})
					tmp36 := lang.Apply(tmp33, []any{tmp35})
					tmp37 := lang.Apply(tmp32, []any{int64(1), tmp36})
					return tmp37
				})
				tmp31 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6678), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(6678), lang.NewKeyword("end-column"), int(54))
				tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp33 := lang.Apply(tmp29, []any{tmp32, v9})
				tmp34 := lang.Apply(tmp27, []any{tmp28, tmp33})
				tmp35 := lang.Apply(tmp23, []any{tmp26, tmp34})
				var v36 any = tmp35
				_ = v36
				tmp37 := checkDerefVar(glojure_DOT_core_keys)
				tmp38 := lang.Apply(tmp37, []any{v22})
				tmp39 := checkDerefVar(glojure_DOT_core_vals)
				tmp40 := lang.Apply(tmp39, []any{v22})
				tmp41 := lang.NewVector(tmp38, tmp40, v36)
				tmp42 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6681), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(6681), lang.NewKeyword("end-column"), int(40))
				tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp7 = tmp43
			} // end let
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge-with
	{
		tmp0 := lang.NewSymbol("merge-with").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("maps"))), lang.NewKeyword("doc"), "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3050), lang.NewKeyword("end-line"), int(3050))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_some)
				tmp7 := checkDerefVar(glojure_DOT_core_identity)
				tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					{ // let
						// let binding "merge-entry"
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v11 := args[0]
							_ = v11
							v12 := args[1]
							_ = v12
							var tmp13 any
							{ // let
								// let binding "k"
								tmp14 := checkDerefVar(glojure_DOT_core_key)
								tmp15 := lang.Apply(tmp14, []any{v12})
								var v16 any = tmp15
								_ = v16
								// let binding "v"
								tmp17 := checkDerefVar(glojure_DOT_core_val)
								tmp18 := lang.Apply(tmp17, []any{v12})
								var v19 any = tmp18
								_ = v19
								var tmp20 any
								tmp21 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
								tmp22 := lang.Apply(tmp21, []any{v11, v16})
								if lang.IsTruthy(tmp22) {
									tmp23 := checkDerefVar(glojure_DOT_core_assoc)
									tmp24 := checkDerefVar(glojure_DOT_core_get)
									tmp25 := lang.Apply(tmp24, []any{v11, v16})
									tmp26 := lang.Apply(v3, []any{tmp25, v19})
									tmp27 := lang.Apply(tmp23, []any{v11, v16, tmp26})
									tmp20 = tmp27
								} else {
									tmp28 := checkDerefVar(glojure_DOT_core_assoc)
									tmp29 := lang.Apply(tmp28, []any{v11, v16, v19})
									tmp20 = tmp29
								}
								tmp13 = tmp20
							} // end let
							return tmp13
						})
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3059), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(3063), lang.NewKeyword("end-column"), int(23))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v13 any = tmp12
						_ = v13
						// let binding "merge2"
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v15 := args[0]
							_ = v15
							v16 := args[1]
							_ = v16
							tmp17 := checkDerefVar(glojure_DOT_core_reduce1)
							var tmp18 any
							{ // let
								// let binding "or__0__auto__"
								var v19 any = v15
								_ = v19
								var tmp20 any
								if lang.IsTruthy(v19) {
									tmp20 = v19
								} else {
									tmp21 := lang.NewMap()
									tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3065), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(3065), lang.NewKeyword("end-column"), int(35))
									tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp20 = tmp23
								}
								tmp18 = tmp20
							} // end let
							tmp19 := checkDerefVar(glojure_DOT_core_seq)
							tmp20 := lang.Apply(tmp19, []any{v16})
							tmp21 := lang.Apply(tmp17, []any{v13, tmp18, tmp20})
							return tmp21
						})
						tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3064), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(3065), lang.NewKeyword("end-column"), int(47))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v17 any = tmp16
						_ = v17
						tmp18 := checkDerefVar(glojure_DOT_core_reduce1)
						tmp19 := lang.Apply(tmp18, []any{v17, v4})
						tmp9 = tmp19
					} // end let
					tmp5 = tmp9
				} else {
				}
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// meta
	{
		tmp0 := lang.NewSymbol("meta").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("obj"))), lang.NewKeyword("doc"), "Returns the metadata of obj, returns nil if there is no metadata.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(202), lang.NewKeyword("end-line"), int(206))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function meta
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IMeta)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
				if lang.IsTruthy(tmp8) {
					tmp9, ok := lang.FieldOrMethod(v4, "Meta")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "Meta")))
					}
					var tmp10 any
					switch reflect.TypeOf(tmp9).Kind() {
					case reflect.Func:
						tmp10 = lang.Apply(tmp9, nil)
					default:
						tmp10 = tmp9
					}
					tmp5 = tmp10
				} else {
				}
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(206), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(208), lang.NewKeyword("end-column"), int(21))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// methods
	{
		tmp0 := lang.NewSymbol("methods").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"))), lang.NewKeyword("doc"), "Given a multimethod, returns a map of dispatch values -> dispatch fns", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1809), lang.NewKeyword("end-line"), int(1809))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getMethodTable")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMethodTable")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// min
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed34
					} else {
						tmp4 = closed34
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := checkDerefVar(glojure_DOT_core_concat)
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
					tmp11 := checkDerefVar(glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := checkDerefVar(glojure_DOT_core_seq)
					tmp15 := checkDerefVar(glojure_DOT_core_concat)
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed34
					} else {
						tmp5 = closed34
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core_seq)
					tmp9 := checkDerefVar(glojure_DOT_core_concat)
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol(".")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp14 := checkDerefVar(glojure_DOT_core_list)
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed34
					} else {
						tmp6 = closed34
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_seq)
						tmp14 := checkDerefVar(glojure_DOT_core_concat)
						tmp15 := checkDerefVar(glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
						tmp17 := checkDerefVar(glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := checkDerefVar(glojure_DOT_core_seq)
					tmp21 := checkDerefVar(glojure_DOT_core_concat)
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("min").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the least of the nums.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1118), lang.NewKeyword("end-line"), int(1118))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				return v5
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Min")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Min is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(glojure_DOT_core_min)
				tmp10 := checkDerefVar(glojure_DOT_core_min)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// min-key
	{
		tmp0 := lang.NewSymbol("min-key").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5033), lang.NewKeyword("end-line"), int(5033))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return v4
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(glojure_DOT_core__LT_)
				tmp8 := lang.Apply(v3, []any{v4})
				tmp9 := lang.Apply(v3, []any{v5})
				tmp10 := lang.Apply(tmp7, []any{tmp8, tmp9})
				if lang.IsTruthy(tmp10) {
					tmp6 = v4
				} else {
					tmp6 = v5
				}
				return tmp6
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "kx"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ky"
					tmp10 := lang.Apply(v3, []any{v5})
					var v11 any = tmp10
					_ = v11
					// let binding "vec__58"
					var tmp12 any
					tmp13 := checkDerefVar(glojure_DOT_core__LT_)
					tmp14 := lang.Apply(tmp13, []any{v9, v11})
					if lang.IsTruthy(tmp14) {
						tmp15 := lang.NewVector(v4, v9)
						tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5043), lang.NewKeyword("column"), int(31), lang.NewKeyword("end-line"), int(5043), lang.NewKeyword("end-column"), int(36))
						tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp17
					} else {
						tmp18 := lang.NewVector(v5, v11)
						tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5043), lang.NewKeyword("column"), int(38), lang.NewKeyword("end-line"), int(5043), lang.NewKeyword("end-column"), int(43))
						tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp20
					}
					var v21 any = tmp12
					_ = v21
					// let binding "v"
					tmp22 := checkDerefVar(glojure_DOT_core_nth)
					tmp23 := lang.Apply(tmp22, []any{v21, int64(0), nil})
					var v24 any = tmp23
					_ = v24
					// let binding "kv"
					tmp25 := checkDerefVar(glojure_DOT_core_nth)
					tmp26 := lang.Apply(tmp25, []any{v21, int64(1), nil})
					var v27 any = tmp26
					_ = v27
					var tmp28 any
					{ // let
						// let binding "v"
						var v29 any = v24
						_ = v29
						// let binding "kv"
						var v30 any = v27
						_ = v30
						// let binding "more"
						var v31 any = v6
						_ = v31
						for {
							var tmp32 any
							if lang.IsTruthy(v31) {
								var tmp33 any
								{ // let
									// let binding "w"
									tmp34 := checkDerefVar(glojure_DOT_core_first)
									tmp35 := lang.Apply(tmp34, []any{v31})
									var v36 any = tmp35
									_ = v36
									// let binding "kw"
									tmp37 := lang.Apply(v3, []any{v36})
									var v38 any = tmp37
									_ = v38
									var tmp39 any
									tmp40 := checkDerefVar(glojure_DOT_core__LT__EQ_)
									tmp41 := lang.Apply(tmp40, []any{v38, v30})
									if lang.IsTruthy(tmp41) {
										var tmp42 any = v36
										var tmp43 any = v38
										tmp45 := checkDerefVar(glojure_DOT_core_next)
										tmp46 := lang.Apply(tmp45, []any{v31})
										var tmp44 any = tmp46
										v29 = tmp42
										v30 = tmp43
										v31 = tmp44
										continue
									} else {
										var tmp47 any = v29
										var tmp48 any = v30
										tmp50 := checkDerefVar(glojure_DOT_core_next)
										tmp51 := lang.Apply(tmp50, []any{v31})
										var tmp49 any = tmp51
										v29 = tmp47
										v30 = tmp48
										v31 = tmp49
										continue
									}
									tmp33 = tmp39
								} // end let
								tmp32 = tmp33
							} else {
								tmp32 = v29
							}
							tmp28 = tmp32
							break
						}
					} // end let
					tmp7 = tmp28
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mix-collection-hash
	{
		tmp0 := lang.NewSymbol("mix-collection-hash").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("hash-basis"), lang.NewSymbol("count"))), lang.NewKeyword("doc"), "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://glojure.org/data_structures#hash for full algorithms.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5199), lang.NewKeyword("end-line"), int(5199))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mk-bound-fn
	{
		tmp0 := lang.NewSymbol("mk-bound-fn").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5127), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(5127), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sc"), lang.NewSymbol("test"), lang.NewSymbol("key"))), lang.NewKeyword("private"), true, lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v7 := args[0]
				_ = v7
				tmp8, ok := lang.FieldOrMethod(v3, "comparator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "comparator")))
				}
				var tmp9 any
				switch reflect.TypeOf(tmp8).Kind() {
				case reflect.Func:
					tmp9 = lang.Apply(tmp8, nil)
				default:
					tmp9 = tmp8
				}
				tmp10, _ := lang.FieldOrMethod(v3, "entryKey")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("entryKey is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{v7})
				tmp12, _ := lang.FieldOrMethod(tmp9, "compare")
				if reflect.TypeOf(tmp12).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("compare is not a function")))
				}
				tmp13 := lang.Apply(tmp12, []any{tmp11, v5})
				tmp14 := lang.Apply(v4, []any{tmp13, int64(0)})
				return tmp14
			})
			tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5130), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(5131), lang.NewKeyword("end-column"), int(64))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mod
	{
		tmp0 := lang.NewSymbol("mod").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"), lang.NewSymbol("div"))), lang.NewKeyword("doc"), "Modulus of num and div. Truncates toward negative infinity.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3567), lang.NewKeyword("end-line"), int(3567))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "m"
				tmp6 := checkDerefVar(glojure_DOT_core_rem)
				tmp7 := lang.Apply(tmp6, []any{v3, v4})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				var tmp10 any
				{ // let
					// let binding "or__0__auto__"
					tmp11 := checkDerefVar(glojure_DOT_core_zero_QMARK_)
					tmp12 := lang.Apply(tmp11, []any{v8})
					var v13 any = tmp12
					_ = v13
					var tmp14 any
					if lang.IsTruthy(v13) {
						tmp14 = v13
					} else {
						tmp15 := checkDerefVar(glojure_DOT_core__EQ_)
						tmp16 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
						tmp17 := lang.Apply(tmp16, []any{v3})
						tmp18 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v4})
						tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
						tmp14 = tmp20
					}
					tmp10 = tmp14
				} // end let
				if lang.IsTruthy(tmp10) {
					tmp9 = v8
				} else {
					tmp11 := checkDerefVar(glojure_DOT_core__PLUS_)
					tmp12 := lang.Apply(tmp11, []any{v8, v4})
					tmp9 = tmp12
				}
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// name
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("name").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns the name String of a string, symbol or keyword.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1585), lang.NewKeyword("end-line"), int(1585))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_string_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			if lang.IsTruthy(tmp7) {
				tmp5 = v4
			} else {
				tmp8, _ := lang.FieldOrMethod(v4, "Name")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Name is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{})
				tmp5 = tmp9
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// namespace
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("namespace").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns the namespace String of a symbol or keyword, or nil if not present.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1593), lang.NewKeyword("end-line"), int(1593))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v4, "Namespace")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Namespace is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{})
			return tmp6
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nary-inline
	{
		tmp0 := lang.NewSymbol("nary-inline").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(948), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(948), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("op")), lang.NewVector(lang.NewSymbol("op"), lang.NewSymbol("unchecked-op"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_nary_inline)
				tmp5 := lang.Apply(tmp4, []any{v3, v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 1:
						v6 := args[0]
						_ = v6
						var tmp7 any
						{ // let
							// let binding "op"
							var tmp8 any
							tmp9 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
							if lang.IsTruthy(tmp9) {
								tmp8 = v4
							} else {
								tmp8 = v3
							}
							var v10 any = tmp8
							_ = v10
							tmp11 := checkDerefVar(glojure_DOT_core_seq)
							tmp12 := checkDerefVar(glojure_DOT_core_concat)
							tmp13 := checkDerefVar(glojure_DOT_core_list)
							tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
							tmp15 := checkDerefVar(glojure_DOT_core_list)
							tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
							tmp17 := checkDerefVar(glojure_DOT_core_list)
							tmp18 := checkDerefVar(glojure_DOT_core_seq)
							tmp19 := checkDerefVar(glojure_DOT_core_concat)
							tmp20 := checkDerefVar(glojure_DOT_core_list)
							tmp21 := lang.Apply(tmp20, []any{v10})
							tmp22 := checkDerefVar(glojure_DOT_core_list)
							tmp23 := lang.Apply(tmp22, []any{v6})
							tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
							tmp25 := lang.Apply(tmp18, []any{tmp24})
							tmp26 := lang.Apply(tmp17, []any{tmp25})
							tmp27 := lang.Apply(tmp12, []any{tmp14, tmp16, tmp26})
							tmp28 := lang.Apply(tmp11, []any{tmp27})
							tmp7 = tmp28
						} // end let
						return tmp7
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						var tmp8 any
						{ // let
							// let binding "op"
							var tmp9 any
							tmp10 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
							if lang.IsTruthy(tmp10) {
								tmp9 = v4
							} else {
								tmp9 = v3
							}
							var v11 any = tmp9
							_ = v11
							tmp12 := checkDerefVar(glojure_DOT_core_seq)
							tmp13 := checkDerefVar(glojure_DOT_core_concat)
							tmp14 := checkDerefVar(glojure_DOT_core_list)
							tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol(".")})
							tmp16 := checkDerefVar(glojure_DOT_core_list)
							tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
							tmp18 := checkDerefVar(glojure_DOT_core_list)
							tmp19 := checkDerefVar(glojure_DOT_core_seq)
							tmp20 := checkDerefVar(glojure_DOT_core_concat)
							tmp21 := checkDerefVar(glojure_DOT_core_list)
							tmp22 := lang.Apply(tmp21, []any{v11})
							tmp23 := checkDerefVar(glojure_DOT_core_list)
							tmp24 := lang.Apply(tmp23, []any{v6})
							tmp25 := checkDerefVar(glojure_DOT_core_list)
							tmp26 := lang.Apply(tmp25, []any{v7})
							tmp27 := lang.Apply(tmp20, []any{tmp22, tmp24, tmp26})
							tmp28 := lang.Apply(tmp19, []any{tmp27})
							tmp29 := lang.Apply(tmp18, []any{tmp28})
							tmp30 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp29})
							tmp31 := lang.Apply(tmp12, []any{tmp30})
							tmp8 = tmp31
						} // end let
						return tmp8
					default:
						if len(args) < 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						var v8 any = lang.NewList(args[2:]...)
						_ = v8
						var tmp9 any
						{ // let
							// let binding "op"
							var tmp10 any
							tmp11 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
							if lang.IsTruthy(tmp11) {
								tmp10 = v4
							} else {
								tmp10 = v3
							}
							var v12 any = tmp10
							_ = v12
							tmp13 := checkDerefVar(glojure_DOT_core_reduce1)
							var tmp14 lang.FnFunc
							tmp14 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								tmp17 := checkDerefVar(glojure_DOT_core_seq)
								tmp18 := checkDerefVar(glojure_DOT_core_concat)
								tmp19 := checkDerefVar(glojure_DOT_core_list)
								tmp20 := lang.Apply(tmp19, []any{lang.NewSymbol(".")})
								tmp21 := checkDerefVar(glojure_DOT_core_list)
								tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
								tmp23 := checkDerefVar(glojure_DOT_core_list)
								tmp24 := checkDerefVar(glojure_DOT_core_seq)
								tmp25 := checkDerefVar(glojure_DOT_core_concat)
								tmp26 := checkDerefVar(glojure_DOT_core_list)
								tmp27 := lang.Apply(tmp26, []any{v12})
								tmp28 := checkDerefVar(glojure_DOT_core_list)
								tmp29 := lang.Apply(tmp28, []any{v15})
								tmp30 := checkDerefVar(glojure_DOT_core_list)
								tmp31 := lang.Apply(tmp30, []any{v16})
								tmp32 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp31})
								tmp33 := lang.Apply(tmp24, []any{tmp32})
								tmp34 := lang.Apply(tmp23, []any{tmp33})
								tmp35 := lang.Apply(tmp18, []any{tmp20, tmp22, tmp34})
								tmp36 := lang.Apply(tmp17, []any{tmp35})
								return tmp36
							})
							tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
							tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 := checkDerefVar(glojure_DOT_core_seq)
							tmp18 := checkDerefVar(glojure_DOT_core_concat)
							tmp19 := checkDerefVar(glojure_DOT_core_list)
							tmp20 := lang.Apply(tmp19, []any{lang.NewSymbol(".")})
							tmp21 := checkDerefVar(glojure_DOT_core_list)
							tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
							tmp23 := checkDerefVar(glojure_DOT_core_list)
							tmp24 := checkDerefVar(glojure_DOT_core_seq)
							tmp25 := checkDerefVar(glojure_DOT_core_concat)
							tmp26 := checkDerefVar(glojure_DOT_core_list)
							tmp27 := lang.Apply(tmp26, []any{v12})
							tmp28 := checkDerefVar(glojure_DOT_core_list)
							tmp29 := lang.Apply(tmp28, []any{v6})
							tmp30 := checkDerefVar(glojure_DOT_core_list)
							tmp31 := lang.Apply(tmp30, []any{v7})
							tmp32 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp31})
							tmp33 := lang.Apply(tmp24, []any{tmp32})
							tmp34 := lang.Apply(tmp23, []any{tmp33})
							tmp35 := lang.Apply(tmp18, []any{tmp20, tmp22, tmp34})
							tmp36 := lang.Apply(tmp17, []any{tmp35})
							tmp37 := lang.Apply(tmp13, []any{tmp16, tmp36, v8})
							tmp9 = tmp37
						} // end let
						return tmp9
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nat-int?
	{
		tmp0 := lang.NewSymbol("nat-int?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a non-negative fixed precision integer", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1415), lang.NewKeyword("end-line"), int(1415))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_int_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(glojure_DOT_core_not)
					tmp10 := checkDerefVar(glojure_DOT_core_neg_QMARK_)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					tmp8 = tmp12
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// neg-int?
	{
		tmp0 := lang.NewSymbol("neg-int?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a negative fixed precision integer", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1409), lang.NewKeyword("end-line"), int(1409))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_int_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(glojure_DOT_core_neg_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp8 = tmp10
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// neg?
	{
		var tmp1 lang.FnFunc
		{ // function neg?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/IsNeg")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("neg?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if num is less than zero, else false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1259), lang.NewKeyword("end-line"), int(1259))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IsNeg")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IsNeg is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// newline
	{
		tmp0 := lang.NewSymbol("newline").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Writes a platform-specific newline to *out*", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3698), lang.NewKeyword("end-line"), int(3698))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := checkDerefVar(glojure_DOT_core__STAR_out_STAR_)
			tmp4 := checkDerefVar(glojure_DOT_core_system_newline)
			tmp5 := lang.Apply(lang.AppendWriter, []any{tmp3, tmp4})
			_ = tmp5
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// next
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := lang.NewSymbol("next").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(55), lang.NewKeyword("end-line"), int(61))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		{ // function next
			var v4 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.Next, []any{v5})
				return tmp6
			})
			tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(61), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(61), lang.NewKeyword("end-column"), int(77))).(lang.FnFunc)
			v4 = tmp3
			_ = v4
		}
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nfirst
	{
		tmp0 := lang.NewSymbol("nfirst").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Same as (next (first x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(105), lang.NewKeyword("end-line"), int(109))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function nfirst
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_next)
				tmp6 := checkDerefVar(glojure_DOT_core_first)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(109), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(109), lang.NewKeyword("end-column"), int(49))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nil?
	{
		tmp1 := reflect.TypeOf(false)
		var tmp2 lang.FnFunc
		{ // function nil?__inliner
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_list)
				tmp6 := lang.Apply(tmp5, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Identical"), v4, nil})
				return tmp6
			})
			v3 = tmp2
			_ = v3
		}
		tmp0 := lang.NewSymbol("nil?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp2, lang.NewKeyword("doc"), "Returns true if x is nil, false otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(435), lang.NewKeyword("end-line"), int(435))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v5 := args[0]
			_ = v5
			tmp6 := lang.Apply(lang.IsNil, []any{v5})
			return tmp6
		})
		tmp5 := reflect.TypeOf(false)
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp5)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nnext
	{
		tmp0 := lang.NewSymbol("nnext").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Same as (next (next x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(119), lang.NewKeyword("end-line"), int(123))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function nnext
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_next)
				tmp6 := checkDerefVar(glojure_DOT_core_next)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(123), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(123), lang.NewKeyword("end-column"), int(46))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// normalize-slurp-opts
	{
		tmp0 := lang.NewSymbol("normalize-slurp-opts").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6974), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(6974), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("opts"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_string_QMARK_)
			tmp6 := checkDerefVar(glojure_DOT_core_first)
			tmp7 := lang.Apply(tmp6, []any{v3})
			tmp8 := lang.Apply(tmp5, []any{tmp7})
			if lang.IsTruthy(tmp8) {
				tmp9 := checkDerefVar(glojure_DOT_core_println)
				tmp10 := lang.Apply(tmp9, []any{"WARNING: (slurp f enc) is deprecated, use (slurp f :encoding enc)."})
				_ = tmp10
				tmp11 := checkDerefVar(glojure_DOT_core_first)
				tmp12 := lang.Apply(tmp11, []any{v3})
				tmp13 := lang.NewVector(lang.NewKeyword("encoding"), tmp12)
				tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6979), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(6979), lang.NewKeyword("end-column"), int(30))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp15
			} else {
				tmp4 = v3
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("not").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is logical false, false otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(523), lang.NewKeyword("end-line"), int(523))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			if lang.IsTruthy(v4) {
				tmp5 = false
			} else {
				tmp5 = true
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-any?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("not-any?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns false if (pred x) is logical true for any x in coll,\n  else true.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(2696), lang.NewKeyword("end-line"), int(2701))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp4 := lang.Apply(closed36, nil)
				tmp5 := lang.Apply(closed35, []any{tmp4})
				return tmp5
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(closed36, []any{v4})
				tmp6 := lang.Apply(closed35, []any{tmp5})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(closed36, []any{v4, v5})
				tmp7 := lang.Apply(closed35, []any{tmp6})
				return tmp7
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(closed36, []any{v4, v5, v6})
				tmp8 := lang.Apply(closed35, []any{tmp7})
				return tmp8
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				var v7 any = lang.NewList(args[3:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_apply)
				tmp9 := lang.Apply(tmp8, []any{closed36, v4, v5, v6, v7})
				tmp10 := lang.Apply(closed35, []any{tmp9})
				return tmp10
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2559), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2564), lang.NewKeyword("end-column"), int(49))).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-empty
	{
		tmp0 := lang.NewSymbol("not-empty").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "If coll is empty, returns nil, else coll", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5516), lang.NewKeyword("end-line"), int(5516))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_seq)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp4 = v3
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-every?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("not-every?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns false if (pred x) is logical true for every x in\n  coll, else true.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(2677), lang.NewKeyword("end-line"), int(2682))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp4 := lang.Apply(closed37, nil)
				tmp5 := lang.Apply(closed35, []any{tmp4})
				return tmp5
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(closed37, []any{v4})
				tmp6 := lang.Apply(closed35, []any{tmp5})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(closed37, []any{v4, v5})
				tmp7 := lang.Apply(closed35, []any{tmp6})
				return tmp7
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(closed37, []any{v4, v5, v6})
				tmp8 := lang.Apply(closed35, []any{tmp7})
				return tmp8
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				var v7 any = lang.NewList(args[3:]...)
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_apply)
				tmp9 := lang.Apply(tmp8, []any{closed37, v4, v5, v6, v7})
				tmp10 := lang.Apply(closed35, []any{tmp9})
				return tmp10
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2559), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2564), lang.NewKeyword("end-column"), int(49))).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not=
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("not=").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Same as (not (= obj1 obj2))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(812), lang.NewKeyword("end-line"), int(812))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return false
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_not)
				tmp7 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp8 := lang.Apply(tmp7, []any{v4, v5})
				tmp9 := lang.Apply(tmp6, []any{tmp8})
				return tmp9
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_not)
				tmp8 := checkDerefVar(glojure_DOT_core_apply)
				tmp9 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp10 := lang.Apply(tmp8, []any{tmp9, v4, v5, v6})
				tmp11 := lang.Apply(tmp7, []any{tmp10})
				return tmp11
			}
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns
	{
		tmp0 := lang.NewSymbol("ns").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("docstring?"), lang.NewSymbol("attr-map?"), lang.NewSymbol("references*"))), lang.NewKeyword("doc"), "Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-glojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-glojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-glojure is not used, a\n  default (refer 'glojure.core) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-glojure :exclude [ancestors printf])\n    (:require (glojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5742), lang.NewKeyword("end-line"), int(5742))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "process-reference"
					var tmp8 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v9 := args[0]
						_ = v9
						var tmp10 any
						{ // let
							// let binding "vec__107"
							var v11 any = v9
							_ = v11
							// let binding "seq__108"
							tmp12 := checkDerefVar(glojure_DOT_core_seq)
							tmp13 := lang.Apply(tmp12, []any{v11})
							var v14 any = tmp13
							_ = v14
							// let binding "first__109"
							tmp15 := checkDerefVar(glojure_DOT_core_first)
							tmp16 := lang.Apply(tmp15, []any{v14})
							var v17 any = tmp16
							_ = v17
							// let binding "seq__108"
							tmp18 := checkDerefVar(glojure_DOT_core_next)
							tmp19 := lang.Apply(tmp18, []any{v14})
							var v20 any = tmp19
							_ = v20
							// let binding "kname"
							var v21 any = v17
							_ = v21
							// let binding "args"
							var v22 any = v20
							_ = v22
							tmp23 := checkDerefVar(glojure_DOT_core_seq)
							tmp24 := checkDerefVar(glojure_DOT_core_concat)
							tmp25 := checkDerefVar(glojure_DOT_core_list)
							tmp26 := checkDerefVar(glojure_DOT_core_symbol)
							tmp27 := checkDerefVar(glojure_DOT_core_name)
							tmp28 := lang.Apply(tmp27, []any{v21})
							tmp29 := lang.Apply(tmp26, []any{"glojure.core", tmp28})
							tmp30 := lang.Apply(tmp25, []any{tmp29})
							tmp31 := checkDerefVar(glojure_DOT_core_map)
							var tmp32 lang.FnFunc
							tmp32 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v33 := args[0]
								_ = v33
								tmp34 := checkDerefVar(glojure_DOT_core_list)
								tmp35 := lang.Apply(tmp34, []any{lang.NewSymbol("quote"), v33})
								return tmp35
							})
							tmp33 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5769), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(5769), lang.NewKeyword("end-column"), int(36))
							tmp34, err := lang.WithMeta(tmp32, tmp33.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp35 := lang.Apply(tmp31, []any{tmp34, v22})
							tmp36 := lang.Apply(tmp24, []any{tmp30, tmp35})
							tmp37 := lang.Apply(tmp23, []any{tmp36})
							tmp10 = tmp37
						} // end let
						return tmp10
					})
					tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5767), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(5769), lang.NewKeyword("end-column"), int(44))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v11 any = tmp10
					_ = v11
					// let binding "docstring"
					var tmp12 any
					tmp13 := checkDerefVar(glojure_DOT_core_string_QMARK_)
					tmp14 := checkDerefVar(glojure_DOT_core_first)
					tmp15 := lang.Apply(tmp14, []any{v6})
					tmp16 := lang.Apply(tmp13, []any{tmp15})
					if lang.IsTruthy(tmp16) {
						tmp17 := checkDerefVar(glojure_DOT_core_first)
						tmp18 := lang.Apply(tmp17, []any{v6})
						tmp12 = tmp18
					} else {
					}
					var v19 any = tmp12
					_ = v19
					// let binding "references"
					var tmp20 any
					if lang.IsTruthy(v19) {
						tmp21 := checkDerefVar(glojure_DOT_core_next)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp20 = tmp22
					} else {
						tmp20 = v6
					}
					var v23 any = tmp20
					_ = v23
					// let binding "name"
					var tmp24 any
					if lang.IsTruthy(v19) {
						tmp25 := checkDerefVar(glojure_DOT_core_vary_meta)
						tmp26 := checkDerefVar(glojure_DOT_core_assoc)
						tmp27 := lang.Apply(tmp25, []any{v5, tmp26, lang.NewKeyword("doc"), v19})
						tmp24 = tmp27
					} else {
						tmp24 = v5
					}
					var v28 any = tmp24
					_ = v28
					// let binding "metadata"
					var tmp29 any
					tmp30 := checkDerefVar(glojure_DOT_core_map_QMARK_)
					tmp31 := checkDerefVar(glojure_DOT_core_first)
					tmp32 := lang.Apply(tmp31, []any{v23})
					tmp33 := lang.Apply(tmp30, []any{tmp32})
					if lang.IsTruthy(tmp33) {
						tmp34 := checkDerefVar(glojure_DOT_core_first)
						tmp35 := lang.Apply(tmp34, []any{v23})
						tmp29 = tmp35
					} else {
					}
					var v36 any = tmp29
					_ = v36
					// let binding "references"
					var tmp37 any
					if lang.IsTruthy(v36) {
						tmp38 := checkDerefVar(glojure_DOT_core_next)
						tmp39 := lang.Apply(tmp38, []any{v23})
						tmp37 = tmp39
					} else {
						tmp37 = v23
					}
					var v40 any = tmp37
					_ = v40
					// let binding "name"
					var tmp41 any
					if lang.IsTruthy(v36) {
						tmp42 := checkDerefVar(glojure_DOT_core_vary_meta)
						tmp43 := checkDerefVar(glojure_DOT_core_merge)
						tmp44 := lang.Apply(tmp42, []any{v28, tmp43, v36})
						tmp41 = tmp44
					} else {
						tmp41 = v28
					}
					var v45 any = tmp41
					_ = v45
					// let binding "gen-class-clause"
					tmp46 := checkDerefVar(glojure_DOT_core_first)
					tmp47 := checkDerefVar(glojure_DOT_core_filter)
					var tmp48 lang.FnFunc
					tmp48 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v49 := args[0]
						_ = v49
						tmp50 := checkDerefVar(glojure_DOT_core__EQ_)
						tmp51 := checkDerefVar(glojure_DOT_core_first)
						tmp52 := lang.Apply(tmp51, []any{v49})
						tmp53 := lang.Apply(tmp50, []any{lang.NewKeyword("gen-class"), tmp52})
						return tmp53
					})
					tmp49 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5780), lang.NewKeyword("column"), int(41), lang.NewKeyword("end-line"), int(5780), lang.NewKeyword("end-column"), int(65))
					tmp50, err := lang.WithMeta(tmp48, tmp49.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp51 := lang.Apply(tmp47, []any{tmp50, v40})
					tmp52 := lang.Apply(tmp46, []any{tmp51})
					var v53 any = tmp52
					_ = v53
					// let binding "gen-class-call"
					var tmp54 any
					if lang.IsTruthy(v53) {
						tmp55 := checkDerefVar(glojure_DOT_core_list_STAR_)
						tmp56 := checkDerefVar(glojure_DOT_core_str)
						tmp57 := lang.Apply(tmp56, []any{v45})
						tmp58, _ := lang.FieldOrMethod(tmp57, "replace")
						if reflect.TypeOf(tmp58).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("replace is not a function")))
						}
						tmp59 := lang.Apply(tmp58, []any{lang.NewChar(45), lang.NewChar(95)})
						tmp60 := checkDerefVar(glojure_DOT_core_next)
						tmp61 := lang.Apply(tmp60, []any{v53})
						tmp62 := lang.Apply(tmp55, []any{lang.NewSymbol("glojure.core/gen-class"), lang.NewKeyword("name"), tmp59, lang.NewKeyword("impl-ns"), v45, lang.NewKeyword("main"), true, tmp61})
						tmp54 = tmp62
					} else {
					}
					var v63 any = tmp54
					_ = v63
					// let binding "references"
					tmp64 := checkDerefVar(glojure_DOT_core_remove)
					var tmp65 lang.FnFunc
					tmp65 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v66 := args[0]
						_ = v66
						tmp67 := checkDerefVar(glojure_DOT_core__EQ_)
						tmp68 := checkDerefVar(glojure_DOT_core_first)
						tmp69 := lang.Apply(tmp68, []any{v66})
						tmp70 := lang.Apply(tmp67, []any{lang.NewKeyword("gen-class"), tmp69})
						return tmp70
					})
					tmp66 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5784), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(5784), lang.NewKeyword("end-column"), int(52))
					tmp67, err := lang.WithMeta(tmp65, tmp66.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp68 := lang.Apply(tmp64, []any{tmp67, v40})
					var v69 any = tmp68
					_ = v69
					// let binding "name-metadata"
					tmp70 := checkDerefVar(glojure_DOT_core_meta)
					tmp71 := lang.Apply(tmp70, []any{v45})
					var v72 any = tmp71
					_ = v72
					tmp73 := checkDerefVar(glojure_DOT_core_seq)
					tmp74 := checkDerefVar(glojure_DOT_core_concat)
					tmp75 := checkDerefVar(glojure_DOT_core_list)
					tmp76 := lang.Apply(tmp75, []any{lang.NewSymbol("do")})
					tmp77 := checkDerefVar(glojure_DOT_core_list)
					tmp78 := checkDerefVar(glojure_DOT_core_seq)
					tmp79 := checkDerefVar(glojure_DOT_core_concat)
					tmp80 := checkDerefVar(glojure_DOT_core_list)
					tmp81 := lang.Apply(tmp80, []any{lang.NewSymbol("glojure.core/in-ns")})
					tmp82 := checkDerefVar(glojure_DOT_core_list)
					tmp83 := checkDerefVar(glojure_DOT_core_seq)
					tmp84 := checkDerefVar(glojure_DOT_core_concat)
					tmp85 := checkDerefVar(glojure_DOT_core_list)
					tmp86 := lang.Apply(tmp85, []any{lang.NewSymbol("quote")})
					tmp87 := checkDerefVar(glojure_DOT_core_list)
					tmp88 := lang.Apply(tmp87, []any{v45})
					tmp89 := lang.Apply(tmp84, []any{tmp86, tmp88})
					tmp90 := lang.Apply(tmp83, []any{tmp89})
					tmp91 := lang.Apply(tmp82, []any{tmp90})
					tmp92 := lang.Apply(tmp79, []any{tmp81, tmp91})
					tmp93 := lang.Apply(tmp78, []any{tmp92})
					tmp94 := lang.Apply(tmp77, []any{tmp93})
					var tmp95 any
					if lang.IsTruthy(v72) {
						tmp96 := checkDerefVar(glojure_DOT_core_seq)
						tmp97 := checkDerefVar(glojure_DOT_core_concat)
						tmp98 := checkDerefVar(glojure_DOT_core_list)
						tmp99 := checkDerefVar(glojure_DOT_core_seq)
						tmp100 := checkDerefVar(glojure_DOT_core_concat)
						tmp101 := checkDerefVar(glojure_DOT_core_list)
						tmp102 := lang.Apply(tmp101, []any{lang.NewSymbol(".ResetMeta")})
						tmp103 := checkDerefVar(glojure_DOT_core_list)
						tmp104 := checkDerefVar(glojure_DOT_core_seq)
						tmp105 := checkDerefVar(glojure_DOT_core_concat)
						tmp106 := checkDerefVar(glojure_DOT_core_list)
						tmp107 := lang.Apply(tmp106, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.FindNamespace")})
						tmp108 := checkDerefVar(glojure_DOT_core_list)
						tmp109 := checkDerefVar(glojure_DOT_core_seq)
						tmp110 := checkDerefVar(glojure_DOT_core_concat)
						tmp111 := checkDerefVar(glojure_DOT_core_list)
						tmp112 := lang.Apply(tmp111, []any{lang.NewSymbol("quote")})
						tmp113 := checkDerefVar(glojure_DOT_core_list)
						tmp114 := lang.Apply(tmp113, []any{v45})
						tmp115 := lang.Apply(tmp110, []any{tmp112, tmp114})
						tmp116 := lang.Apply(tmp109, []any{tmp115})
						tmp117 := lang.Apply(tmp108, []any{tmp116})
						tmp118 := lang.Apply(tmp105, []any{tmp107, tmp117})
						tmp119 := lang.Apply(tmp104, []any{tmp118})
						tmp120 := lang.Apply(tmp103, []any{tmp119})
						tmp121 := checkDerefVar(glojure_DOT_core_list)
						tmp122 := lang.Apply(tmp121, []any{v72})
						tmp123 := lang.Apply(tmp100, []any{tmp102, tmp120, tmp122})
						tmp124 := lang.Apply(tmp99, []any{tmp123})
						tmp125 := lang.Apply(tmp98, []any{tmp124})
						tmp126 := lang.Apply(tmp97, []any{tmp125})
						tmp127 := lang.Apply(tmp96, []any{tmp126})
						tmp95 = tmp127
					} else {
					}
					tmp128 := checkDerefVar(glojure_DOT_core_list)
					tmp129 := checkDerefVar(glojure_DOT_core_seq)
					tmp130 := checkDerefVar(glojure_DOT_core_concat)
					tmp131 := checkDerefVar(glojure_DOT_core_list)
					tmp132 := lang.Apply(tmp131, []any{lang.NewSymbol("glojure.core/with-loading-context")})
					var tmp133 any
					if lang.IsTruthy(v63) {
						tmp134 := checkDerefVar(glojure_DOT_core_list)
						tmp135 := lang.Apply(tmp134, []any{v63})
						tmp133 = tmp135
					} else {
					}
					var tmp136 any
					var tmp137 any
					{ // let
						// let binding "and__0__auto__"
						tmp138 := checkDerefVar(glojure_DOT_core_not_EQ_)
						tmp139 := lang.Apply(tmp138, []any{v45, lang.NewSymbol("glojure.core")})
						var v140 any = tmp139
						_ = v140
						var tmp141 any
						if lang.IsTruthy(v140) {
							tmp142 := checkDerefVar(glojure_DOT_core_not_any_QMARK_)
							var tmp143 lang.FnFunc
							tmp143 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v144 := args[0]
								_ = v144
								tmp145 := checkDerefVar(glojure_DOT_core__EQ_)
								tmp146 := checkDerefVar(glojure_DOT_core_first)
								tmp147 := lang.Apply(tmp146, []any{v144})
								tmp148 := lang.Apply(tmp145, []any{lang.NewKeyword("refer-glojure"), tmp147})
								return tmp148
							})
							tmp144 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5793), lang.NewKeyword("column"), int(58), lang.NewKeyword("end-line"), int(5793), lang.NewKeyword("end-column"), int(86))
							tmp145, err := lang.WithMeta(tmp143, tmp144.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp146 := lang.Apply(tmp142, []any{tmp145, v69})
							tmp141 = tmp146
						} else {
							tmp141 = v140
						}
						tmp137 = tmp141
					} // end let
					if lang.IsTruthy(tmp137) {
						tmp138 := checkDerefVar(glojure_DOT_core_seq)
						tmp139 := checkDerefVar(glojure_DOT_core_concat)
						tmp140 := checkDerefVar(glojure_DOT_core_list)
						tmp141 := checkDerefVar(glojure_DOT_core_seq)
						tmp142 := checkDerefVar(glojure_DOT_core_concat)
						tmp143 := checkDerefVar(glojure_DOT_core_list)
						tmp144 := lang.Apply(tmp143, []any{lang.NewSymbol("glojure.core/refer")})
						tmp145 := checkDerefVar(glojure_DOT_core_list)
						tmp146 := checkDerefVar(glojure_DOT_core_seq)
						tmp147 := checkDerefVar(glojure_DOT_core_concat)
						tmp148 := checkDerefVar(glojure_DOT_core_list)
						tmp149 := lang.Apply(tmp148, []any{lang.NewSymbol("quote")})
						tmp150 := checkDerefVar(glojure_DOT_core_list)
						tmp151 := lang.Apply(tmp150, []any{lang.NewSymbol("glojure.core")})
						tmp152 := lang.Apply(tmp147, []any{tmp149, tmp151})
						tmp153 := lang.Apply(tmp146, []any{tmp152})
						tmp154 := lang.Apply(tmp145, []any{tmp153})
						tmp155 := lang.Apply(tmp142, []any{tmp144, tmp154})
						tmp156 := lang.Apply(tmp141, []any{tmp155})
						tmp157 := lang.Apply(tmp140, []any{tmp156})
						tmp158 := lang.Apply(tmp139, []any{tmp157})
						tmp159 := lang.Apply(tmp138, []any{tmp158})
						tmp136 = tmp159
					} else {
					}
					tmp160 := checkDerefVar(glojure_DOT_core_map)
					tmp161 := lang.Apply(tmp160, []any{v11, v69})
					tmp162 := lang.Apply(tmp130, []any{tmp132, tmp133, tmp136, tmp161})
					tmp163 := lang.Apply(tmp129, []any{tmp162})
					tmp164 := lang.Apply(tmp128, []any{tmp163})
					tmp165 := checkDerefVar(glojure_DOT_core_list)
					tmp166 := checkDerefVar(glojure_DOT_core_seq)
					tmp167 := checkDerefVar(glojure_DOT_core_concat)
					tmp168 := checkDerefVar(glojure_DOT_core_list)
					tmp169 := lang.Apply(tmp168, []any{lang.NewSymbol("if")})
					tmp170 := checkDerefVar(glojure_DOT_core_list)
					tmp171 := checkDerefVar(glojure_DOT_core_seq)
					tmp172 := checkDerefVar(glojure_DOT_core_concat)
					tmp173 := checkDerefVar(glojure_DOT_core_list)
					tmp174 := lang.Apply(tmp173, []any{lang.NewSymbol(".Equals")})
					tmp175 := checkDerefVar(glojure_DOT_core_list)
					tmp176 := checkDerefVar(glojure_DOT_core_seq)
					tmp177 := checkDerefVar(glojure_DOT_core_concat)
					tmp178 := checkDerefVar(glojure_DOT_core_list)
					tmp179 := lang.Apply(tmp178, []any{lang.NewSymbol("quote")})
					tmp180 := checkDerefVar(glojure_DOT_core_list)
					tmp181 := lang.Apply(tmp180, []any{v45})
					tmp182 := lang.Apply(tmp177, []any{tmp179, tmp181})
					tmp183 := lang.Apply(tmp176, []any{tmp182})
					tmp184 := lang.Apply(tmp175, []any{tmp183})
					tmp185 := checkDerefVar(glojure_DOT_core_list)
					tmp186 := checkDerefVar(glojure_DOT_core_seq)
					tmp187 := checkDerefVar(glojure_DOT_core_concat)
					tmp188 := checkDerefVar(glojure_DOT_core_list)
					tmp189 := lang.Apply(tmp188, []any{lang.NewSymbol("quote")})
					tmp190 := checkDerefVar(glojure_DOT_core_list)
					tmp191 := lang.Apply(tmp190, []any{lang.NewSymbol("glojure.core")})
					tmp192 := lang.Apply(tmp187, []any{tmp189, tmp191})
					tmp193 := lang.Apply(tmp186, []any{tmp192})
					tmp194 := lang.Apply(tmp185, []any{tmp193})
					tmp195 := lang.Apply(tmp172, []any{tmp174, tmp184, tmp194})
					tmp196 := lang.Apply(tmp171, []any{tmp195})
					tmp197 := lang.Apply(tmp170, []any{tmp196})
					tmp198 := checkDerefVar(glojure_DOT_core_list)
					tmp199 := lang.Apply(tmp198, []any{nil})
					tmp200 := checkDerefVar(glojure_DOT_core_list)
					tmp201 := checkDerefVar(glojure_DOT_core_seq)
					tmp202 := checkDerefVar(glojure_DOT_core_concat)
					tmp203 := checkDerefVar(glojure_DOT_core_list)
					tmp204 := lang.Apply(tmp203, []any{lang.NewSymbol("do")})
					tmp205 := checkDerefVar(glojure_DOT_core_list)
					tmp206 := checkDerefVar(glojure_DOT_core_seq)
					tmp207 := checkDerefVar(glojure_DOT_core_concat)
					tmp208 := checkDerefVar(glojure_DOT_core_list)
					tmp209 := lang.Apply(tmp208, []any{lang.NewSymbol("glojure.core/dosync")})
					tmp210 := checkDerefVar(glojure_DOT_core_list)
					tmp211 := checkDerefVar(glojure_DOT_core_seq)
					tmp212 := checkDerefVar(glojure_DOT_core_concat)
					tmp213 := checkDerefVar(glojure_DOT_core_list)
					tmp214 := lang.Apply(tmp213, []any{lang.NewSymbol("glojure.core/commute")})
					tmp215 := checkDerefVar(glojure_DOT_core_list)
					tmp216 := checkDerefVar(glojure_DOT_core_seq)
					tmp217 := checkDerefVar(glojure_DOT_core_concat)
					tmp218 := checkDerefVar(glojure_DOT_core_list)
					tmp219 := lang.Apply(tmp218, []any{lang.NewSymbol("glojure.core/deref")})
					tmp220 := checkDerefVar(glojure_DOT_core_list)
					tmp221 := checkDerefVar(glojure_DOT_core_seq)
					tmp222 := checkDerefVar(glojure_DOT_core_concat)
					tmp223 := checkDerefVar(glojure_DOT_core_list)
					tmp224 := lang.Apply(tmp223, []any{lang.NewSymbol("var")})
					tmp225 := checkDerefVar(glojure_DOT_core_list)
					tmp226 := lang.Apply(tmp225, []any{lang.NewSymbol("glojure.core/*loaded-libs*")})
					tmp227 := lang.Apply(tmp222, []any{tmp224, tmp226})
					tmp228 := lang.Apply(tmp221, []any{tmp227})
					tmp229 := lang.Apply(tmp220, []any{tmp228})
					tmp230 := lang.Apply(tmp217, []any{tmp219, tmp229})
					tmp231 := lang.Apply(tmp216, []any{tmp230})
					tmp232 := lang.Apply(tmp215, []any{tmp231})
					tmp233 := checkDerefVar(glojure_DOT_core_list)
					tmp234 := lang.Apply(tmp233, []any{lang.NewSymbol("glojure.core/conj")})
					tmp235 := checkDerefVar(glojure_DOT_core_list)
					tmp236 := checkDerefVar(glojure_DOT_core_seq)
					tmp237 := checkDerefVar(glojure_DOT_core_concat)
					tmp238 := checkDerefVar(glojure_DOT_core_list)
					tmp239 := lang.Apply(tmp238, []any{lang.NewSymbol("quote")})
					tmp240 := checkDerefVar(glojure_DOT_core_list)
					tmp241 := lang.Apply(tmp240, []any{v45})
					tmp242 := lang.Apply(tmp237, []any{tmp239, tmp241})
					tmp243 := lang.Apply(tmp236, []any{tmp242})
					tmp244 := lang.Apply(tmp235, []any{tmp243})
					tmp245 := lang.Apply(tmp212, []any{tmp214, tmp232, tmp234, tmp244})
					tmp246 := lang.Apply(tmp211, []any{tmp245})
					tmp247 := lang.Apply(tmp210, []any{tmp246})
					tmp248 := lang.Apply(tmp207, []any{tmp209, tmp247})
					tmp249 := lang.Apply(tmp206, []any{tmp248})
					tmp250 := lang.Apply(tmp205, []any{tmp249})
					tmp251 := checkDerefVar(glojure_DOT_core_list)
					tmp252 := lang.Apply(tmp251, []any{nil})
					tmp253 := lang.Apply(tmp202, []any{tmp204, tmp250, tmp252})
					tmp254 := lang.Apply(tmp201, []any{tmp253})
					tmp255 := lang.Apply(tmp200, []any{tmp254})
					tmp256 := lang.Apply(tmp167, []any{tmp169, tmp197, tmp199, tmp255})
					tmp257 := lang.Apply(tmp166, []any{tmp256})
					tmp258 := lang.Apply(tmp165, []any{tmp257})
					tmp259 := lang.Apply(tmp74, []any{tmp76, tmp94, tmp95, tmp164, tmp258})
					tmp260 := lang.Apply(tmp73, []any{tmp259})
					tmp7 = tmp260
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-aliases
	{
		tmp0 := lang.NewSymbol("ns-aliases").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of the aliases for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4273), lang.NewKeyword("end-line"), int(4273))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_the_ns)
			tmp5 := lang.Apply(tmp4, []any{v3})
			tmp6, ok := lang.FieldOrMethod(tmp5, "getAliases")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp5, "getAliases")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-imports
	{
		tmp0 := lang.NewSymbol("ns-imports").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of the import mappings for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4199), lang.NewKeyword("end-line"), int(4199))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_filter_key)
			tmp5 := checkDerefVar(glojure_DOT_core_val)
			tmp6 := checkDerefVar(glojure_DOT_core_partial)
			tmp7 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp8 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
			tmp9 := lang.Apply(tmp6, []any{tmp7, tmp8})
			tmp10 := checkDerefVar(glojure_DOT_core_ns_map)
			tmp11 := lang.Apply(tmp10, []any{v3})
			tmp12 := lang.Apply(tmp4, []any{tmp5, tmp9, tmp11})
			return tmp12
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-interns
	{
		tmp0 := lang.NewSymbol("ns-interns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of the intern mappings for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4206), lang.NewKeyword("end-line"), int(4206))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ns"
				tmp5 := checkDerefVar(glojure_DOT_core_the_ns)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_filter_key)
				tmp9 := checkDerefVar(glojure_DOT_core_val)
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v11 := args[0]
					_ = v11
					var tmp12 any
					{ // let
						// let binding "and__0__auto__"
						tmp13 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
						tmp14 := reflect.TypeOf((*lang.Var)(nil))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v11})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						if lang.IsTruthy(v16) {
							tmp18 := checkDerefVar(glojure_DOT_core__EQ_)
							tmp19, ok := lang.FieldOrMethod(v11, "Namespace")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Namespace")))
							}
							var tmp20 any
							switch reflect.TypeOf(tmp19).Kind() {
							case reflect.Func:
								tmp20 = lang.Apply(tmp19, nil)
							default:
								tmp20 = tmp19
							}
							tmp21 := lang.Apply(tmp18, []any{v7, tmp20})
							tmp17 = tmp21
						} else {
							tmp17 = v16
						}
						tmp12 = tmp17
					} // end let
					return tmp12
				})
				tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4212), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(4213), lang.NewKeyword("end-column"), int(56))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := checkDerefVar(glojure_DOT_core_ns_map)
				tmp14 := lang.Apply(tmp13, []any{v7})
				tmp15 := lang.Apply(tmp8, []any{tmp9, tmp12, tmp14})
				tmp4 = tmp15
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-map
	{
		tmp0 := lang.NewSymbol("ns-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of all the mappings for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4170), lang.NewKeyword("end-line"), int(4170))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_the_ns)
			tmp5 := lang.Apply(tmp4, []any{v3})
			tmp6, ok := lang.FieldOrMethod(tmp5, "Mappings")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp5, "Mappings")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-name
	{
		tmp0 := lang.NewSymbol("ns-name").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns the name of the namespace, a symbol.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4163), lang.NewKeyword("end-line"), int(4163))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_the_ns)
			tmp5 := lang.Apply(tmp4, []any{v3})
			tmp6, ok := lang.FieldOrMethod(tmp5, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp5, "Name")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-publics
	{
		tmp0 := lang.NewSymbol("ns-publics").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of the public intern mappings for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4188), lang.NewKeyword("end-line"), int(4188))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ns"
				tmp5 := checkDerefVar(glojure_DOT_core_the_ns)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_filter_key)
				tmp9 := checkDerefVar(glojure_DOT_core_val)
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v11 := args[0]
					_ = v11
					var tmp12 any
					{ // let
						// let binding "and__0__auto__"
						tmp13 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
						tmp14 := reflect.TypeOf((*lang.Var)(nil))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v11})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						if lang.IsTruthy(v16) {
							var tmp18 any
							{ // let
								// let binding "and__0__auto__"
								tmp19 := checkDerefVar(glojure_DOT_core__EQ_)
								tmp20, ok := lang.FieldOrMethod(v11, "Namespace")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Namespace")))
								}
								var tmp21 any
								switch reflect.TypeOf(tmp20).Kind() {
								case reflect.Func:
									tmp21 = lang.Apply(tmp20, nil)
								default:
									tmp21 = tmp20
								}
								tmp22 := lang.Apply(tmp19, []any{v7, tmp21})
								var v23 any = tmp22
								_ = v23
								var tmp24 any
								if lang.IsTruthy(v23) {
									tmp25, ok := lang.FieldOrMethod(v11, "IsPublic")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "IsPublic")))
									}
									var tmp26 any
									switch reflect.TypeOf(tmp25).Kind() {
									case reflect.Func:
										tmp26 = lang.Apply(tmp25, nil)
									default:
										tmp26 = tmp25
									}
									tmp24 = tmp26
								} else {
									tmp24 = v23
								}
								tmp18 = tmp24
							} // end let
							tmp17 = tmp18
						} else {
							tmp17 = v16
						}
						tmp12 = tmp17
					} // end let
					return tmp12
				})
				tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4194), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(4196), lang.NewKeyword("end-column"), int(48))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := checkDerefVar(glojure_DOT_core_ns_map)
				tmp14 := lang.Apply(tmp13, []any{v7})
				tmp15 := lang.Apply(tmp8, []any{tmp9, tmp12, tmp14})
				tmp4 = tmp15
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-refers
	{
		tmp0 := lang.NewSymbol("ns-refers").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of the refer mappings for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4253), lang.NewKeyword("end-line"), int(4253))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ns"
				tmp5 := checkDerefVar(glojure_DOT_core_the_ns)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_filter_key)
				tmp9 := checkDerefVar(glojure_DOT_core_val)
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v11 := args[0]
					_ = v11
					var tmp12 any
					{ // let
						// let binding "and__0__auto__"
						tmp13 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
						tmp14 := reflect.TypeOf((*lang.Var)(nil))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v11})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						if lang.IsTruthy(v16) {
							tmp18 := checkDerefVar(glojure_DOT_core_not_EQ_)
							tmp19, ok := lang.FieldOrMethod(v11, "Namespace")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Namespace")))
							}
							var tmp20 any
							switch reflect.TypeOf(tmp19).Kind() {
							case reflect.Func:
								tmp20 = lang.Apply(tmp19, nil)
							default:
								tmp20 = tmp19
							}
							tmp21 := lang.Apply(tmp18, []any{v7, tmp20})
							tmp17 = tmp21
						} else {
							tmp17 = v16
						}
						tmp12 = tmp17
					} // end let
					return tmp12
				})
				tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4259), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(4260), lang.NewKeyword("end-column"), int(59))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := checkDerefVar(glojure_DOT_core_ns_map)
				tmp14 := lang.Apply(tmp13, []any{v7})
				tmp15 := lang.Apply(tmp8, []any{tmp9, tmp12, tmp14})
				tmp4 = tmp15
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-resolve
	{
		tmp0 := lang.NewSymbol("ns-resolve").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("sym")), lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("env"), lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Returns the var or Class to which a symbol will be resolved in the\n  namespace (unless found in the environment), else nil.  Note that\n  if the symbol is fully qualified, the var/Class to which it resolves\n  need not be present in the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4358), lang.NewKeyword("end-line"), int(4358))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_ns_resolve)
				tmp6 := lang.Apply(tmp5, []any{v3, nil, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4, v5})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(glojure_DOT_core_the_ns)
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp11, _ := lang.FieldOrMethod(runtime7.Compiler, "maybeResolveIn")
					if reflect.TypeOf(tmp11).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("maybeResolveIn is not a function")))
					}
					tmp12 := lang.Apply(tmp11, []any{tmp10, v5})
					tmp6 = tmp12
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-unalias
	{
		tmp0 := lang.NewSymbol("ns-unalias").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Removes the alias for the symbol from the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4280), lang.NewKeyword("end-line"), int(4280))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_the_ns)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7, _ := lang.FieldOrMethod(tmp6, "removeAlias")
			if reflect.TypeOf(tmp7).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeAlias is not a function")))
			}
			tmp8 := lang.Apply(tmp7, []any{v4})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-unmap
	{
		tmp0 := lang.NewSymbol("ns-unmap").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Removes the mappings for the symbol from the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4177), lang.NewKeyword("end-line"), int(4177))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_the_ns)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7, _ := lang.FieldOrMethod(tmp6, "unmap")
			if reflect.TypeOf(tmp7).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unmap is not a function")))
			}
			tmp8 := lang.Apply(tmp7, []any{v4})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nth
	{
		var tmp1 lang.FnFunc
		{ // function nth__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					var v5 any = lang.NewList(args[2:]...)
					_ = v5
					tmp6 := checkDerefVar(glojure_DOT_core_seq)
					tmp7 := checkDerefVar(glojure_DOT_core_concat)
					tmp8 := checkDerefVar(glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol(".")})
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/Nth")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := checkDerefVar(glojure_DOT_core_seq)
					tmp19 := checkDerefVar(glojure_DOT_core_concat)
					tmp20 := checkDerefVar(glojure_DOT_core_list)
					tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/unquote")})
					tmp22 := checkDerefVar(glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("glojure.core/c")})
					tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
					tmp25 := lang.Apply(tmp18, []any{tmp24})
					tmp26 := lang.Apply(tmp17, []any{tmp25})
					tmp27 := checkDerefVar(glojure_DOT_core_list)
					tmp28 := checkDerefVar(glojure_DOT_core_seq)
					tmp29 := checkDerefVar(glojure_DOT_core_concat)
					tmp30 := checkDerefVar(glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/unquote")})
					tmp32 := checkDerefVar(glojure_DOT_core_list)
					tmp33 := lang.Apply(tmp32, []any{lang.NewSymbol("glojure.core/i")})
					tmp34 := lang.Apply(tmp29, []any{tmp31, tmp33})
					tmp35 := lang.Apply(tmp28, []any{tmp34})
					tmp36 := lang.Apply(tmp27, []any{tmp35})
					tmp37 := checkDerefVar(glojure_DOT_core_list)
					tmp38 := checkDerefVar(glojure_DOT_core_seq)
					tmp39 := checkDerefVar(glojure_DOT_core_concat)
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp42 := checkDerefVar(glojure_DOT_core_list)
					tmp43 := lang.Apply(tmp42, []any{lang.NewSymbol("glojure.core/nf")})
					tmp44 := lang.Apply(tmp39, []any{tmp41, tmp43})
					tmp45 := lang.Apply(tmp38, []any{tmp44})
					tmp46 := lang.Apply(tmp37, []any{tmp45})
					tmp47 := lang.Apply(tmp14, []any{tmp16, tmp26, tmp36, tmp46})
					tmp48 := lang.Apply(tmp13, []any{tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp50 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp49})
					tmp51 := lang.Apply(tmp6, []any{tmp50})
					return tmp51
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("nth").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("index")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("index"), lang.NewSymbol("not-found"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, Java arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2), int64(3)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(882), lang.NewKeyword("end-line"), int(882))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(runtime7.RT, "Nth")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Nth is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(runtime7.RT, "NthDefault")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("NthDefault is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v4, v5, v6})
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nthnext
	{
		tmp0 := lang.NewSymbol("nthnext").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns the nth next of coll, (seq coll) when n is 0.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3147), lang.NewKeyword("end-line"), int(3147))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			if lang.IsTruthy(tmp8) {
				var tmp9 any
				tmp10 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
				tmp11 := lang.Apply(tmp10, []any{v4})
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					tmp13 := checkDerefVar(glojure_DOT_core_int_QMARK_)
					tmp14 := lang.Apply(tmp13, []any{v4})
					if lang.IsTruthy(tmp14) {
						tmp12 = v4
					} else {
						tmp15 := lang.Apply(nil, []any{v4})
						tmp12 = tmp15
					}
					tmp16, _ := lang.FieldOrMethod(v3, "drop")
					if reflect.TypeOf(tmp16).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
					}
					tmp17 := lang.Apply(tmp16, []any{tmp12})
					tmp9 = tmp17
				} else {
					tmp18 := checkDerefVar(glojure_DOT_core_seq)
					tmp19 := lang.Apply(tmp18, []any{v3})
					tmp9 = tmp19
				}
				tmp5 = tmp9
			} else {
				var tmp20 any
				{ // let
					// let binding "n"
					var v21 any = v4
					_ = v21
					// let binding "xs"
					tmp22 := checkDerefVar(glojure_DOT_core_seq)
					tmp23 := lang.Apply(tmp22, []any{v3})
					var v24 any = tmp23
					_ = v24
					for {
						var tmp25 any
						var tmp26 any
						{ // let
							// let binding "and__0__auto__"
							var v27 any = v24
							_ = v27
							var tmp28 any
							if lang.IsTruthy(v27) {
								tmp29 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
								tmp30 := lang.Apply(tmp29, []any{v21})
								tmp28 = tmp30
							} else {
								tmp28 = v27
							}
							tmp26 = tmp28
						} // end let
						if lang.IsTruthy(tmp26) {
							tmp28 := checkDerefVar(glojure_DOT_core_dec)
							tmp29 := lang.Apply(tmp28, []any{v21})
							var tmp27 any = tmp29
							tmp31 := checkDerefVar(glojure_DOT_core_next)
							tmp32 := lang.Apply(tmp31, []any{v24})
							var tmp30 any = tmp32
							v21 = tmp27
							v24 = tmp30
							continue
						} else {
							tmp25 = v24
						}
						tmp20 = tmp25
						break
					}
				} // end let
				tmp5 = tmp20
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nthrest
	{
		tmp0 := lang.NewSymbol("nthrest").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns the nth rest of coll, coll when n is 0.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3161), lang.NewKeyword("end-line"), int(3161))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			if lang.IsTruthy(tmp7) {
				var tmp8 any
				{ // let
					// let binding "or__0__auto__"
					var tmp9 any
					tmp10 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
					tmp11 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
					tmp12 := lang.Apply(tmp10, []any{tmp11, v3})
					if lang.IsTruthy(tmp12) {
						var tmp13 any
						tmp14 := checkDerefVar(glojure_DOT_core_int_QMARK_)
						tmp15 := lang.Apply(tmp14, []any{v4})
						if lang.IsTruthy(tmp15) {
							tmp13 = v4
						} else {
							tmp16 := lang.Apply(nil, []any{v4})
							tmp13 = tmp16
						}
						tmp17, _ := lang.FieldOrMethod(v3, "drop")
						if reflect.TypeOf(tmp17).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
						}
						tmp18 := lang.Apply(tmp17, []any{tmp13})
						tmp9 = tmp18
					} else {
						var tmp19 any
						{ // let
							// let binding "n"
							var v20 any = v4
							_ = v20
							// let binding "xs"
							var v21 any = v3
							_ = v21
							for {
								var tmp22 any
								{ // let
									// let binding "temp__0__auto__"
									var tmp23 any
									{ // let
										// let binding "and__0__auto__"
										tmp24 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
										tmp25 := lang.Apply(tmp24, []any{v20})
										var v26 any = tmp25
										_ = v26
										var tmp27 any
										if lang.IsTruthy(v26) {
											tmp28 := checkDerefVar(glojure_DOT_core_seq)
											tmp29 := lang.Apply(tmp28, []any{v21})
											tmp27 = tmp29
										} else {
											tmp27 = v26
										}
										tmp23 = tmp27
									} // end let
									var v24 any = tmp23
									_ = v24
									var tmp25 any
									if lang.IsTruthy(v24) {
										var tmp26 any
										{ // let
											// let binding "xs"
											var v27 any = v24
											_ = v27
											tmp29 := checkDerefVar(glojure_DOT_core_dec)
											tmp30 := lang.Apply(tmp29, []any{v20})
											var tmp28 any = tmp30
											tmp32 := checkDerefVar(glojure_DOT_core_rest)
											tmp33 := lang.Apply(tmp32, []any{v27})
											var tmp31 any = tmp33
											v20 = tmp28
											v21 = tmp31
											continue
										} // end let
										tmp25 = tmp26
									} else {
										tmp27 := checkDerefVar(glojure_DOT_core_seq)
										tmp28 := lang.Apply(tmp27, []any{v21})
										tmp25 = tmp28
									}
									tmp22 = tmp25
								} // end let
								tmp19 = tmp22
								break
							}
						} // end let
						tmp9 = tmp19
					}
					var v20 any = tmp9
					_ = v20
					var tmp21 any
					if lang.IsTruthy(v20) {
						tmp21 = v20
					} else {
						tmp21 = lang.NewList()
					}
					tmp8 = tmp21
				} // end let
				tmp5 = tmp8
			} else {
				tmp5 = v3
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// num
	{
		var tmp1 lang.FnFunc
		{ // function num__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/Num")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("num").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to Number", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3474), lang.NewKeyword("end-line"), int(3474))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Num")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Num is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// number?
	{
		tmp0 := lang.NewSymbol("number?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is a Number", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3560), lang.NewKeyword("end-line"), int(3560))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.IsNumber, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// numerator
	{
		tmp1 := reflect.TypeOf((*big9.Int)(nil))
		tmp0 := lang.NewSymbol("numerator").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("r"))), lang.NewKeyword("doc"), "Returns the numerator part of a Ratio.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3583), lang.NewKeyword("end-line"), int(3583))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, ok := lang.FieldOrMethod(v4, "numerator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "numerator")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			return tmp6
		})
		tmp4 := reflect.TypeOf((*big9.Int)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// object-array
	{
		var tmp1 lang.FnFunc
		{ // function object-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/Object_array")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("object-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of objects", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5349), lang.NewKeyword("end-line"), int(5349))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime7.RT, "Object_array")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Object_array is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// odd?
	{
		tmp0 := lang.NewSymbol("odd?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is odd, throws an exception if n is not an integer", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1389), lang.NewKeyword("end-line"), int(1389))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_not)
			tmp5 := checkDerefVar(glojure_DOT_core_even_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// or
	{
		tmp0 := lang.NewSymbol("or").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("next"))), lang.NewKeyword("doc"), "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(847), lang.NewKeyword("end-line"), int(847))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return nil
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/let")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_apply)
				tmp13 := checkDerefVar(glojure_DOT_core_vector)
				tmp14 := checkDerefVar(glojure_DOT_core_seq)
				tmp15 := checkDerefVar(glojure_DOT_core_concat)
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("or__0__auto__")})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v5})
				tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
				tmp21 := lang.Apply(tmp14, []any{tmp20})
				tmp22 := lang.Apply(tmp12, []any{tmp13, tmp21})
				tmp23 := lang.Apply(tmp11, []any{tmp22})
				tmp24 := checkDerefVar(glojure_DOT_core_list)
				tmp25 := checkDerefVar(glojure_DOT_core_seq)
				tmp26 := checkDerefVar(glojure_DOT_core_concat)
				tmp27 := checkDerefVar(glojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("if")})
				tmp29 := checkDerefVar(glojure_DOT_core_list)
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("or__0__auto__")})
				tmp31 := checkDerefVar(glojure_DOT_core_list)
				tmp32 := lang.Apply(tmp31, []any{lang.NewSymbol("or__0__auto__")})
				tmp33 := checkDerefVar(glojure_DOT_core_list)
				tmp34 := checkDerefVar(glojure_DOT_core_seq)
				tmp35 := checkDerefVar(glojure_DOT_core_concat)
				tmp36 := checkDerefVar(glojure_DOT_core_list)
				tmp37 := lang.Apply(tmp36, []any{lang.NewSymbol("glojure.core/or")})
				tmp38 := lang.Apply(tmp35, []any{tmp37, v6})
				tmp39 := lang.Apply(tmp34, []any{tmp38})
				tmp40 := lang.Apply(tmp33, []any{tmp39})
				tmp41 := lang.Apply(tmp26, []any{tmp28, tmp30, tmp32, tmp40})
				tmp42 := lang.Apply(tmp25, []any{tmp41})
				tmp43 := lang.Apply(tmp24, []any{tmp42})
				tmp44 := lang.Apply(tmp8, []any{tmp10, tmp23, tmp43})
				tmp45 := lang.Apply(tmp7, []any{tmp44})
				return tmp45
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parents
	{
		tmp0 := lang.NewSymbol("parents").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("tag"))), lang.NewKeyword("doc"), "Returns the immediate parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5564), lang.NewKeyword("end-line"), int(5564))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_parents)
				tmp5 := checkDerefVar(glojure_DOT_core_global_hierarchy)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_not_empty)
				var tmp6 any
				{ // let
					// let binding "tp"
					tmp7 := checkDerefVar(glojure_DOT_core_get)
					tmp8 := lang.Apply(lang.NewKeyword("parents"), []any{v3})
					tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					tmp12 := checkDerefVar(glojure_DOT_core_class_QMARK_)
					tmp13 := lang.Apply(tmp12, []any{v4})
					if lang.IsTruthy(tmp13) {
						tmp14 := checkDerefVar(glojure_DOT_core_into1)
						tmp15 := checkDerefVar(glojure_DOT_core_set)
						tmp16 := checkDerefVar(glojure_DOT_core_bases)
						tmp17 := lang.Apply(tmp16, []any{v4})
						tmp18 := lang.Apply(tmp15, []any{tmp17})
						tmp19 := lang.Apply(tmp14, []any{tmp18, v10})
						tmp11 = tmp19
					} else {
						tmp11 = v10
					}
					tmp6 = tmp11
				} // end let
				tmp7 := lang.Apply(tmp5, []any{tmp6})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-boolean
	{
		tmp0 := lang.NewSymbol("parse-boolean").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Parse strings \"true\" or \"false\" and return a boolean, or nil if invalid", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7957), lang.NewKeyword("end-line"), int(7957))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_string_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				var tmp7 any
				{ // let
					// let binding "G__365"
					var v8 any = v3
					_ = v8
				} // end let
				tmp4 = tmp7
			} else {
				tmp8 := checkDerefVar(glojure_DOT_core_parsing_err)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp9})
				panic(tmp10)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-double
	{
		tmp0 := lang.NewSymbol("parse-double").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Parse string with floating point components and return a Double value,\n  or nil if parse fails.\n\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7935), lang.NewKeyword("end-line"), int(7935))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_string_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				var tmp7 any
				{ // let
					// let binding "result__3649__auto__"
					tmp8 := lang.Apply(strconv12.ParseFloat, []any{v3, int64(64)})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := lang.Apply(v9, []any{int64(1)})
					if lang.IsTruthy(tmp11) {
					} else {
						tmp12 := lang.Apply(v9, []any{int64(0)})
						tmp10 = tmp12
					}
					tmp7 = tmp10
				} // end let
				tmp4 = tmp7
			} else {
				tmp8 := checkDerefVar(glojure_DOT_core_parsing_err)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp9})
				panic(tmp10)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-impls
	{
		tmp0 := lang.NewSymbol("parse-impls").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(13), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(13), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("specs"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := lang.NewMap()
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(14), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(14), lang.NewKeyword("end-column"), int(15))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v8 any = tmp7
				_ = v8
				// let binding "s"
				var v9 any = v3
				_ = v9
				for {
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core_seq)
					tmp12 := lang.Apply(tmp11, []any{v9})
					if lang.IsTruthy(tmp12) {
						tmp14 := checkDerefVar(glojure_DOT_core_assoc)
						tmp15 := checkDerefVar(glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v9})
						tmp17 := checkDerefVar(glojure_DOT_core_take_while)
						tmp18 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
						tmp19 := checkDerefVar(glojure_DOT_core_next)
						tmp20 := lang.Apply(tmp19, []any{v9})
						tmp21 := lang.Apply(tmp17, []any{tmp18, tmp20})
						tmp22 := lang.Apply(tmp14, []any{v8, tmp16, tmp21})
						var tmp13 any = tmp22
						tmp24 := checkDerefVar(glojure_DOT_core_drop_while)
						tmp25 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
						tmp26 := checkDerefVar(glojure_DOT_core_next)
						tmp27 := lang.Apply(tmp26, []any{v9})
						tmp28 := lang.Apply(tmp24, []any{tmp25, tmp27})
						var tmp23 any = tmp28
						v8 = tmp13
						v9 = tmp23
						continue
					} else {
						tmp10 = v8
					}
					tmp4 = tmp10
					break
				}
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-long
	{
		tmp0 := lang.NewSymbol("parse-long").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Parse string of decimal digits with optional leading -/+ and return a\n  Long value, or nil if parse fails", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7926), lang.NewKeyword("end-line"), int(7926))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_string_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				var tmp7 any
				{ // let
					// let binding "result__3648__auto__"
					tmp8 := lang.Apply(strconv12.ParseInt, []any{v3, int64(10), int64(64)})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := lang.Apply(v9, []any{int64(1)})
					if lang.IsTruthy(tmp11) {
					} else {
						tmp12 := lang.Apply(v9, []any{int64(0)})
						tmp10 = tmp12
					}
					tmp7 = tmp10
				} // end let
				tmp4 = tmp7
			} else {
				tmp8 := checkDerefVar(glojure_DOT_core_parsing_err)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp9})
				panic(tmp10)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-uuid
	{
		tmp0 := lang.NewSymbol("parse-uuid").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Parse a string representing a UUID and return a java.util.UUID instance,\n  or nil if parse fails.\n\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#toString--", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7946), lang.NewKeyword("end-line"), int(7946))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						tmp5 := reflect.TypeOf((*lang.IllegalArgumentError)(nil))
						if lang.CatchMatches(r, tmp5) {
							v6 := r
							_ = v6
						} else {
							panic(r)
						}
					}
				}()
				var tmp6 any
				{ // let
					// let binding "vec__362"
					tmp7 := lang.Apply(uuid13.Parse, []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "uuid"
					tmp9 := checkDerefVar(glojure_DOT_core_nth)
					tmp10 := lang.Apply(tmp9, []any{v8, int64(0), nil})
					var v11 any = tmp10
					_ = v11
					// let binding "err"
					tmp12 := checkDerefVar(glojure_DOT_core_nth)
					tmp13 := lang.Apply(tmp12, []any{v8, int64(1), nil})
					var v14 any = tmp13
					_ = v14
					var tmp15 any
					if lang.IsTruthy(v14) {
						tmp16 := checkDerefVar(glojure_DOT_core_str)
						tmp17 := lang.Apply(tmp16, []any{"Error parsing UUID: ", v14})
						tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
						panic(tmp18)
					} else {
						tmp15 = v11
					}
					tmp6 = tmp15
				} // end let
				tmp4 = tmp6
			}()
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parsing-err
	{
		tmp0 := lang.NewSymbol("parsing-err").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Construct message for parsing for non-string parsing error", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(7921), lang.NewKeyword("end-line"), int(7921), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_str)
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v3})
			if lang.IsTruthy(tmp7) {
				tmp5 = "nil"
			} else {
				tmp8 := checkDerefVar(glojure_DOT_core_class)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10, ok := lang.FieldOrMethod(tmp9, "Name")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp9, "Name")))
				}
				var tmp11 any
				switch reflect.TypeOf(tmp10).Kind() {
				case reflect.Func:
					tmp11 = lang.Apply(tmp10, nil)
				default:
					tmp11 = tmp10
				}
				tmp5 = tmp11
			}
			tmp12 := lang.Apply(tmp4, []any{"Expected string, got ", tmp5})
			return tmp12
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partial
	{
		tmp0 := lang.NewSymbol("partial").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("arg1")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("arg1"), lang.NewSymbol("arg2")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("arg1"), lang.NewSymbol("arg2"), lang.NewSymbol("arg3")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("arg1"), lang.NewSymbol("arg2"), lang.NewSymbol("arg3"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2606), lang.NewKeyword("end-line"), int(2606))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v3, []any{v4})
						return tmp6
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v3, []any{v4, v6})
						return tmp7
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v4, v6, v7})
						return tmp8
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v4, v6, v7, v8})
						return tmp9
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := checkDerefVar(glojure_DOT_core_apply)
						tmp11 := lang.Apply(tmp10, []any{v3, v4, v6, v7, v8, v9})
						return tmp11
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2614), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(2619), lang.NewKeyword("end-column"), int(48))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp7 := lang.Apply(v3, []any{v4, v5})
						return tmp7
					case 1:
						v7 := args[0]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v4, v5, v7})
						return tmp8
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v4, v5, v7, v8})
						return tmp9
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						tmp10 := lang.Apply(v3, []any{v4, v5, v7, v8, v9})
						return tmp10
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := checkDerefVar(glojure_DOT_core_apply)
						tmp12 := lang.Apply(tmp11, []any{v3, v4, v5, v7, v8, v9, v10})
						return tmp12
					}
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2621), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(2626), lang.NewKeyword("end-column"), int(53))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp8 := lang.Apply(v3, []any{v4, v5, v6})
						return tmp8
					case 1:
						v8 := args[0]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v4, v5, v6, v8})
						return tmp9
					case 2:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						tmp10 := lang.Apply(v3, []any{v4, v5, v6, v8, v9})
						return tmp10
					case 3:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						tmp11 := lang.Apply(v3, []any{v4, v5, v6, v8, v9, v10})
						return tmp11
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var v11 any = lang.NewList(args[3:]...)
						_ = v11
						tmp12 := checkDerefVar(glojure_DOT_core_apply)
						tmp13 := lang.Apply(tmp12, []any{v3, v4, v5, v6, v8, v9, v10, v11})
						return tmp13
					}
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2628), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(2633), lang.NewKeyword("end-column"), int(58))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp9
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						if len(args) < 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var v9 any = lang.NewList(args[0:]...)
						_ = v9
						tmp10 := checkDerefVar(glojure_DOT_core_apply)
						tmp11 := checkDerefVar(glojure_DOT_core_concat)
						tmp12 := lang.Apply(tmp11, []any{v7, v9})
						tmp13 := lang.Apply(tmp10, []any{v3, v4, v5, v6, tmp12})
						return tmp13
					}
				})
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2635), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(2635), lang.NewKeyword("end-column"), int(60))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition
	{
		tmp0 := lang.NewSymbol("partition").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("pad"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3177), lang.NewKeyword("end-line"), int(3177))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_partition)
				tmp6 := lang.Apply(tmp5, []any{v3, v3, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v5})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "s"
								var v13 any = v10
								_ = v13
								var tmp14 any
								{ // let
									// let binding "p"
									tmp15 := checkDerefVar(glojure_DOT_core_doall)
									tmp16 := checkDerefVar(glojure_DOT_core_take)
									tmp17 := lang.Apply(tmp16, []any{v3, v13})
									tmp18 := lang.Apply(tmp15, []any{tmp17})
									var v19 any = tmp18
									_ = v19
									var tmp20 any
									tmp21 := checkDerefVar(glojure_DOT_core__EQ_)
									tmp22 := checkDerefVar(glojure_DOT_core_count)
									tmp23 := lang.Apply(tmp22, []any{v19})
									tmp24 := lang.Apply(tmp21, []any{v3, tmp23})
									if lang.IsTruthy(tmp24) {
										tmp25 := checkDerefVar(glojure_DOT_core_cons)
										tmp26 := checkDerefVar(glojure_DOT_core_partition)
										tmp27 := checkDerefVar(glojure_DOT_core_nthrest)
										tmp28 := lang.Apply(tmp27, []any{v13, v4})
										tmp29 := lang.Apply(tmp26, []any{v3, v4, tmp28})
										tmp30 := lang.Apply(tmp25, []any{v19, tmp29})
										tmp20 = tmp30
									} else {
									}
									tmp14 = tmp20
								} // end let
								tmp12 = tmp14
							} // end let
							tmp11 = tmp12
						} else {
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp8 any
					{ // let
						// let binding "temp__0__auto__"
						tmp9 := checkDerefVar(glojure_DOT_core_seq)
						tmp10 := lang.Apply(tmp9, []any{v6})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "s"
								var v14 any = v11
								_ = v14
								var tmp15 any
								{ // let
									// let binding "p"
									tmp16 := checkDerefVar(glojure_DOT_core_doall)
									tmp17 := checkDerefVar(glojure_DOT_core_take)
									tmp18 := lang.Apply(tmp17, []any{v3, v14})
									tmp19 := lang.Apply(tmp16, []any{tmp18})
									var v20 any = tmp19
									_ = v20
									var tmp21 any
									tmp22 := checkDerefVar(glojure_DOT_core__EQ_)
									tmp23 := checkDerefVar(glojure_DOT_core_count)
									tmp24 := lang.Apply(tmp23, []any{v20})
									tmp25 := lang.Apply(tmp22, []any{v3, tmp24})
									if lang.IsTruthy(tmp25) {
										tmp26 := checkDerefVar(glojure_DOT_core_cons)
										tmp27 := checkDerefVar(glojure_DOT_core_partition)
										tmp28 := checkDerefVar(glojure_DOT_core_nthrest)
										tmp29 := lang.Apply(tmp28, []any{v14, v4})
										tmp30 := lang.Apply(tmp27, []any{v3, v4, v5, tmp29})
										tmp31 := lang.Apply(tmp26, []any{v20, tmp30})
										tmp21 = tmp31
									} else {
										tmp32 := checkDerefVar(glojure_DOT_core_list)
										tmp33 := checkDerefVar(glojure_DOT_core_take)
										tmp34 := checkDerefVar(glojure_DOT_core_concat)
										tmp35 := lang.Apply(tmp34, []any{v20, v5})
										tmp36 := lang.Apply(tmp33, []any{v3, tmp35})
										tmp37 := lang.Apply(tmp32, []any{tmp36})
										tmp21 = tmp37
									}
									tmp15 = tmp21
								} // end let
								tmp13 = tmp15
							} // end let
							tmp12 = tmp13
						} else {
						}
						tmp8 = tmp12
					} // end let
					return tmp8
				})
				tmp8 := lang.Apply(lang.NewLazySeq, []any{tmp7})
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition-all
	{
		tmp0 := lang.NewSymbol("partition-all").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7222), lang.NewKeyword("end-line"), int(7222))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "a"
						tmp7 := checkDerefVar(glojure_DOT_core_to_array)
						tmp8 := lang.Apply(tmp7, []any{v3})
						tmp9 := lang.Apply(lang.NewArrayList, []any{tmp8})
						var v10 any = tmp9
						_ = v10
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp12 := lang.Apply(v5, nil)
								return tmp12
							case 1:
								v12 := args[0]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "result"
									var tmp14 any
									tmp15, ok := lang.FieldOrMethod(v10, "isEmpty")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "isEmpty")))
									}
									var tmp16 any
									switch reflect.TypeOf(tmp15).Kind() {
									case reflect.Func:
										tmp16 = lang.Apply(tmp15, nil)
									default:
										tmp16 = tmp15
									}
									if lang.IsTruthy(tmp16) {
										tmp14 = v12
									} else {
										var tmp17 any
										{ // let
											// let binding "v"
											tmp18 := checkDerefVar(glojure_DOT_core_vec)
											tmp19, ok := lang.FieldOrMethod(v10, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "toArray")))
											}
											var tmp20 any
											switch reflect.TypeOf(tmp19).Kind() {
											case reflect.Func:
												tmp20 = lang.Apply(tmp19, nil)
											default:
												tmp20 = tmp19
											}
											tmp21 := lang.Apply(tmp18, []any{tmp20})
											var v22 any = tmp21
											_ = v22
											tmp23, ok := lang.FieldOrMethod(v10, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "clear")))
											}
											var tmp24 any
											switch reflect.TypeOf(tmp23).Kind() {
											case reflect.Func:
												tmp24 = lang.Apply(tmp23, nil)
											default:
												tmp24 = tmp23
											}
											_ = tmp24
											tmp25 := checkDerefVar(glojure_DOT_core_unreduced)
											tmp26 := lang.Apply(v5, []any{v12, v22})
											tmp27 := lang.Apply(tmp25, []any{tmp26})
											tmp17 = tmp27
										} // end let
										tmp14 = tmp17
									}
									var v18 any = tmp14
									_ = v18
									tmp19 := lang.Apply(v5, []any{v18})
									tmp13 = tmp19
								} // end let
								return tmp13
							case 2:
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								tmp14, _ := lang.FieldOrMethod(v10, "add")
								if reflect.TypeOf(tmp14).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
								}
								tmp15 := lang.Apply(tmp14, []any{v13})
								_ = tmp15
								var tmp16 any
								tmp17 := checkDerefVar(glojure_DOT_core__EQ_)
								tmp18, ok := lang.FieldOrMethod(v10, "size")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "size")))
								}
								var tmp19 any
								switch reflect.TypeOf(tmp18).Kind() {
								case reflect.Func:
									tmp19 = lang.Apply(tmp18, nil)
								default:
									tmp19 = tmp18
								}
								tmp20 := lang.Apply(tmp17, []any{v3, tmp19})
								if lang.IsTruthy(tmp20) {
									var tmp21 any
									{ // let
										// let binding "v"
										tmp22 := checkDerefVar(glojure_DOT_core_vec)
										tmp23, ok := lang.FieldOrMethod(v10, "toArray")
										if !ok {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "toArray")))
										}
										var tmp24 any
										switch reflect.TypeOf(tmp23).Kind() {
										case reflect.Func:
											tmp24 = lang.Apply(tmp23, nil)
										default:
											tmp24 = tmp23
										}
										tmp25 := lang.Apply(tmp22, []any{tmp24})
										var v26 any = tmp25
										_ = v26
										tmp27, ok := lang.FieldOrMethod(v10, "clear")
										if !ok {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "clear")))
										}
										var tmp28 any
										switch reflect.TypeOf(tmp27).Kind() {
										case reflect.Func:
											tmp28 = lang.Apply(tmp27, nil)
										default:
											tmp28 = tmp27
										}
										_ = tmp28
										tmp29 := lang.Apply(v5, []any{v12, v26})
										tmp21 = tmp29
									} // end let
									tmp16 = tmp21
								} else {
									tmp16 = v12
								}
								return tmp16
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7231), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7247), lang.NewKeyword("end-column"), int(23))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp13
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7229), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(7247), lang.NewKeyword("end-column"), int(25))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_partition_all)
				tmp6 := lang.Apply(tmp5, []any{v3, v3, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v5})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "s"
								var v13 any = v10
								_ = v13
								var tmp14 any
								{ // let
									// let binding "seg"
									tmp15 := checkDerefVar(glojure_DOT_core_doall)
									tmp16 := checkDerefVar(glojure_DOT_core_take)
									tmp17 := lang.Apply(tmp16, []any{v3, v13})
									tmp18 := lang.Apply(tmp15, []any{tmp17})
									var v19 any = tmp18
									_ = v19
									tmp20 := checkDerefVar(glojure_DOT_core_cons)
									tmp21 := checkDerefVar(glojure_DOT_core_partition_all)
									tmp22 := checkDerefVar(glojure_DOT_core_nthrest)
									tmp23 := lang.Apply(tmp22, []any{v13, v4})
									tmp24 := lang.Apply(tmp21, []any{v3, v4, tmp23})
									tmp25 := lang.Apply(tmp20, []any{v19, tmp24})
									tmp14 = tmp25
								} // end let
								tmp12 = tmp14
							} // end let
							tmp11 = tmp12
						} else {
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition-by
	{
		tmp0 := lang.NewSymbol("partition-by").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7142), lang.NewKeyword("end-line"), int(7142))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "a"
						var v7 any = "unimplemented: new with non-constant class type"
						_ = v7
						// let binding "pv"
						tmp8 := checkDerefVar(glojure_DOT_core_volatile_BANG_)
						tmp9 := lang.Apply(tmp8, []any{lang.NewKeyword("glojure.core/none")})
						var v10 any = tmp9
						_ = v10
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp12 := lang.Apply(v5, nil)
								return tmp12
							case 1:
								v12 := args[0]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "result"
									var tmp14 any
									tmp15, ok := lang.FieldOrMethod(v7, "isEmpty")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "isEmpty")))
									}
									var tmp16 any
									switch reflect.TypeOf(tmp15).Kind() {
									case reflect.Func:
										tmp16 = lang.Apply(tmp15, nil)
									default:
										tmp16 = tmp15
									}
									if lang.IsTruthy(tmp16) {
										tmp14 = v12
									} else {
										var tmp17 any
										{ // let
											// let binding "v"
											tmp18 := checkDerefVar(glojure_DOT_core_vec)
											tmp19, ok := lang.FieldOrMethod(v7, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "toArray")))
											}
											var tmp20 any
											switch reflect.TypeOf(tmp19).Kind() {
											case reflect.Func:
												tmp20 = lang.Apply(tmp19, nil)
											default:
												tmp20 = tmp19
											}
											tmp21 := lang.Apply(tmp18, []any{tmp20})
											var v22 any = tmp21
											_ = v22
											tmp23, ok := lang.FieldOrMethod(v7, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "clear")))
											}
											var tmp24 any
											switch reflect.TypeOf(tmp23).Kind() {
											case reflect.Func:
												tmp24 = lang.Apply(tmp23, nil)
											default:
												tmp24 = tmp23
											}
											_ = tmp24
											tmp25 := checkDerefVar(glojure_DOT_core_unreduced)
											tmp26 := lang.Apply(v5, []any{v12, v22})
											tmp27 := lang.Apply(tmp25, []any{tmp26})
											tmp17 = tmp27
										} // end let
										tmp14 = tmp17
									}
									var v18 any = tmp14
									_ = v18
									tmp19 := lang.Apply(v5, []any{v18})
									tmp13 = tmp19
								} // end let
								return tmp13
							case 2:
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								var tmp14 any
								{ // let
									// let binding "pval"
									tmp15 := checkDerefVar(glojure_DOT_core_deref)
									tmp16 := lang.Apply(tmp15, []any{v10})
									var v17 any = tmp16
									_ = v17
									// let binding "val"
									tmp18 := lang.Apply(v3, []any{v13})
									var v19 any = tmp18
									_ = v19
									tmp20 := checkDerefVar(glojure_DOT_core_vreset_BANG_)
									tmp21 := lang.Apply(tmp20, []any{v10, v19})
									_ = tmp21
									var tmp22 any
									var tmp23 any
									{ // let
										// let binding "or__0__auto__"
										tmp24 := checkDerefVar(glojure_DOT_core_identical_QMARK_)
										tmp25 := lang.Apply(tmp24, []any{v17, lang.NewKeyword("glojure.core/none")})
										var v26 any = tmp25
										_ = v26
										var tmp27 any
										if lang.IsTruthy(v26) {
											tmp27 = v26
										} else {
											tmp28 := checkDerefVar(glojure_DOT_core__EQ_)
											tmp29 := lang.Apply(tmp28, []any{v19, v17})
											tmp27 = tmp29
										}
										tmp23 = tmp27
									} // end let
									if lang.IsTruthy(tmp23) {
										tmp24, _ := lang.FieldOrMethod(v7, "add")
										if reflect.TypeOf(tmp24).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
										}
										tmp25 := lang.Apply(tmp24, []any{v13})
										_ = tmp25
										tmp22 = v12
									} else {
										var tmp26 any
										{ // let
											// let binding "v"
											tmp27 := checkDerefVar(glojure_DOT_core_vec)
											tmp28, ok := lang.FieldOrMethod(v7, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "toArray")))
											}
											var tmp29 any
											switch reflect.TypeOf(tmp28).Kind() {
											case reflect.Func:
												tmp29 = lang.Apply(tmp28, nil)
											default:
												tmp29 = tmp28
											}
											tmp30 := lang.Apply(tmp27, []any{tmp29})
											var v31 any = tmp30
											_ = v31
											tmp32, ok := lang.FieldOrMethod(v7, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "clear")))
											}
											var tmp33 any
											switch reflect.TypeOf(tmp32).Kind() {
											case reflect.Func:
												tmp33 = lang.Apply(tmp32, nil)
											default:
												tmp33 = tmp32
											}
											_ = tmp33
											var tmp34 any
											{ // let
												// let binding "ret"
												tmp35 := lang.Apply(v5, []any{v12, v31})
												var v36 any = tmp35
												_ = v36
												var tmp37 any
												tmp38 := checkDerefVar(glojure_DOT_core_reduced_QMARK_)
												tmp39 := lang.Apply(tmp38, []any{v36})
												if lang.IsTruthy(tmp39) {
												} else {
													tmp40, _ := lang.FieldOrMethod(v7, "add")
													if reflect.TypeOf(tmp40).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
													}
													tmp41 := lang.Apply(tmp40, []any{v13})
													tmp37 = tmp41
												}
												_ = tmp37
												tmp34 = v36
											} // end let
											tmp26 = tmp34
										} // end let
										tmp22 = tmp26
									}
									tmp14 = tmp22
								} // end let
								return tmp14
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7152), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(7176), lang.NewKeyword("end-column"), int(28))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp13
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7149), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(7176), lang.NewKeyword("end-column"), int(30))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								{ // let
									// let binding "fst"
									tmp14 := checkDerefVar(glojure_DOT_core_first)
									tmp15 := lang.Apply(tmp14, []any{v12})
									var v16 any = tmp15
									_ = v16
									// let binding "fv"
									tmp17 := lang.Apply(v3, []any{v16})
									var v18 any = tmp17
									_ = v18
									// let binding "run"
									tmp19 := checkDerefVar(glojure_DOT_core_cons)
									tmp20 := checkDerefVar(glojure_DOT_core_take_while)
									var tmp21 lang.FnFunc
									tmp21 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v22 := args[0]
										_ = v22
										tmp23 := checkDerefVar(glojure_DOT_core__EQ_)
										tmp24 := lang.Apply(v3, []any{v22})
										tmp25 := lang.Apply(tmp23, []any{v18, tmp24})
										return tmp25
									})
									tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7182), lang.NewKeyword("column"), int(41), lang.NewKeyword("end-line"), int(7182), lang.NewKeyword("end-column"), int(53))
									tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp24 := checkDerefVar(glojure_DOT_core_next)
									tmp25 := lang.Apply(tmp24, []any{v12})
									tmp26 := lang.Apply(tmp20, []any{tmp23, tmp25})
									tmp27 := lang.Apply(tmp19, []any{v16, tmp26})
									var v28 any = tmp27
									_ = v28
									tmp29 := checkDerefVar(glojure_DOT_core_cons)
									tmp30 := checkDerefVar(glojure_DOT_core_partition_by)
									var tmp31 lang.FnFunc
									tmp31 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 0 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										tmp32 := checkDerefVar(glojure_DOT_core_drop)
										tmp33 := checkDerefVar(glojure_DOT_core_count)
										tmp34 := lang.Apply(tmp33, []any{v28})
										tmp35 := lang.Apply(tmp32, []any{tmp34, v12})
										return tmp35
									})
									tmp32 := lang.Apply(lang.NewLazySeq, []any{tmp31})
									tmp33 := lang.Apply(tmp30, []any{v3, tmp32})
									tmp34 := lang.Apply(tmp29, []any{v28, tmp33})
									tmp13 = tmp34
								} // end let
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partitionv
	{
		tmp0 := lang.NewSymbol("partitionv").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("pad"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of vectors of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7262), lang.NewKeyword("end-line"), int(7262))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_partitionv)
				tmp6 := lang.Apply(tmp5, []any{v3, v3, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v5})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "s"
								var v13 any = v10
								_ = v13
								var tmp14 any
								{ // let
									// let binding "p"
									tmp15 := checkDerefVar(glojure_DOT_core_into)
									tmp16 := lang.NewVector()
									tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7274), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(7274), lang.NewKeyword("end-column"), int(23))
									tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp19 := checkDerefVar(glojure_DOT_core_take)
									tmp20 := lang.Apply(tmp19, []any{v3})
									tmp21 := lang.Apply(tmp15, []any{tmp18, tmp20, v13})
									var v22 any = tmp21
									_ = v22
									var tmp23 any
									tmp24 := checkDerefVar(glojure_DOT_core__EQ_)
									tmp25 := checkDerefVar(glojure_DOT_core_count)
									tmp26 := lang.Apply(tmp25, []any{v22})
									tmp27 := lang.Apply(tmp24, []any{v3, tmp26})
									if lang.IsTruthy(tmp27) {
										tmp28 := checkDerefVar(glojure_DOT_core_cons)
										tmp29 := checkDerefVar(glojure_DOT_core_partitionv)
										tmp30 := checkDerefVar(glojure_DOT_core_nthrest)
										tmp31 := lang.Apply(tmp30, []any{v13, v4})
										tmp32 := lang.Apply(tmp29, []any{v3, v4, tmp31})
										tmp33 := lang.Apply(tmp28, []any{v22, tmp32})
										tmp23 = tmp33
									} else {
									}
									tmp14 = tmp23
								} // end let
								tmp12 = tmp14
							} // end let
							tmp11 = tmp12
						} else {
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp8 any
					{ // let
						// let binding "temp__0__auto__"
						tmp9 := checkDerefVar(glojure_DOT_core_seq)
						tmp10 := lang.Apply(tmp9, []any{v6})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "s"
								var v14 any = v11
								_ = v14
								var tmp15 any
								{ // let
									// let binding "p"
									tmp16 := checkDerefVar(glojure_DOT_core_into)
									tmp17 := lang.NewVector()
									tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7280), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(7280), lang.NewKeyword("end-column"), int(23))
									tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp20 := checkDerefVar(glojure_DOT_core_take)
									tmp21 := lang.Apply(tmp20, []any{v3})
									tmp22 := lang.Apply(tmp16, []any{tmp19, tmp21, v14})
									var v23 any = tmp22
									_ = v23
									var tmp24 any
									tmp25 := checkDerefVar(glojure_DOT_core__EQ_)
									tmp26 := checkDerefVar(glojure_DOT_core_count)
									tmp27 := lang.Apply(tmp26, []any{v23})
									tmp28 := lang.Apply(tmp25, []any{v3, tmp27})
									if lang.IsTruthy(tmp28) {
										tmp29 := checkDerefVar(glojure_DOT_core_cons)
										tmp30 := checkDerefVar(glojure_DOT_core_partitionv)
										tmp31 := checkDerefVar(glojure_DOT_core_nthrest)
										tmp32 := lang.Apply(tmp31, []any{v14, v4})
										tmp33 := lang.Apply(tmp30, []any{v3, v4, v5, tmp32})
										tmp34 := lang.Apply(tmp29, []any{v23, tmp33})
										tmp24 = tmp34
									} else {
										tmp35 := checkDerefVar(glojure_DOT_core_list)
										tmp36 := checkDerefVar(glojure_DOT_core_into)
										tmp37 := lang.NewVector()
										tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7283), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(7283), lang.NewKeyword("end-column"), int(25))
										tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp40 := checkDerefVar(glojure_DOT_core_take)
										tmp41 := lang.Apply(tmp40, []any{v3})
										tmp42 := checkDerefVar(glojure_DOT_core_concat)
										tmp43 := lang.Apply(tmp42, []any{v23, v5})
										tmp44 := lang.Apply(tmp36, []any{tmp39, tmp41, tmp43})
										tmp45 := lang.Apply(tmp35, []any{tmp44})
										tmp24 = tmp45
									}
									tmp15 = tmp24
								} // end let
								tmp13 = tmp15
							} // end let
							tmp12 = tmp13
						} else {
						}
						tmp8 = tmp12
					} // end let
					return tmp8
				})
				tmp8 := lang.Apply(lang.NewLazySeq, []any{tmp7})
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partitionv-all
	{
		tmp0 := lang.NewSymbol("partitionv-all").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of vector partitions, but may include\n  partitions with fewer than n items at the end.\n  Returns a stateful transducer when no collection is provided.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7285), lang.NewKeyword("end-line"), int(7285))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_partition_all)
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_partitionv_all)
				tmp6 := lang.Apply(tmp5, []any{v3, v3, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v5})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "s"
								var v13 any = v10
								_ = v13
								var tmp14 any
								{ // let
									// let binding "seg"
									tmp15 := checkDerefVar(glojure_DOT_core_into)
									tmp16 := lang.NewVector()
									tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7297), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(7297), lang.NewKeyword("end-column"), int(25))
									tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp19 := checkDerefVar(glojure_DOT_core_take)
									tmp20 := lang.Apply(tmp19, []any{v3})
									tmp21 := lang.Apply(tmp15, []any{tmp18, tmp20, v5})
									var v22 any = tmp21
									_ = v22
									tmp23 := checkDerefVar(glojure_DOT_core_cons)
									tmp24 := checkDerefVar(glojure_DOT_core_partitionv_all)
									tmp25 := checkDerefVar(glojure_DOT_core_drop)
									tmp26 := lang.Apply(tmp25, []any{v4, v13})
									tmp27 := lang.Apply(tmp24, []any{v3, v4, tmp26})
									tmp28 := lang.Apply(tmp23, []any{v22, tmp27})
									tmp14 = tmp28
								} // end let
								tmp12 = tmp14
							} // end let
							tmp11 = tmp12
						} else {
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pcalls
	{
		tmp0 := lang.NewSymbol("pcalls").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("fns"))), lang.NewKeyword("doc"), "Executes the no-arg fns in parallel, returning a lazy sequence of\n  their values", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7056), lang.NewKeyword("end-line"), int(7056))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_pmap)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v6 := args[0]
					_ = v6
					tmp7 := lang.Apply(v6, nil)
					return tmp7
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7061), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(7061), lang.NewKeyword("end-column"), int(20))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7, v3})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// peek
	{
		tmp0 := lang.NewSymbol("peek").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1455), lang.NewKeyword("end-line"), int(1455))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime7.RT, "Peek")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Peek is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// persistent!
	{
		tmp0 := lang.NewSymbol("persistent!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3350), lang.NewKeyword("end-line"), int(3350))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "Persistent")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Persistent")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pmap
	{
		tmp0 := lang.NewSymbol("pmap").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7031), lang.NewKeyword("end-line"), int(7031))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "n"
					tmp6 := checkDerefVar(glojure_DOT_core__PLUS_)
					tmp7 := lang.Apply(runtime14.NumCPU, nil)
					tmp8 := lang.Apply(tmp6, []any{int64(2), tmp7})
					var v9 any = tmp8
					_ = v9
					// let binding "rets"
					tmp10 := checkDerefVar(glojure_DOT_core_map)
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v12 := args[0]
						_ = v12
						tmp13 := checkDerefVar(glojure_DOT_core_future_call)
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							tmp15 := lang.Apply(v3, []any{v12})
							return tmp15
						})
						tmp15 := lang.Apply(tmp13, []any{tmp14})
						return tmp15
					})
					tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7041), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7041), lang.NewKeyword("end-column"), int(34))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp14 := lang.Apply(tmp10, []any{tmp13, v4})
					var v15 any = tmp14
					_ = v15
					// let binding "step"
					var tmp16 lang.FnFunc
					{ // function step
						var v17 lang.FnFunc
						tmp16 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v18 := args[0]
							_ = v18
							v19 := args[1]
							_ = v19
							var tmp20 any
							{ // let
								// let binding "vec__335"
								var v21 any = v18
								_ = v21
								// let binding "seq__336"
								tmp22 := checkDerefVar(glojure_DOT_core_seq)
								tmp23 := lang.Apply(tmp22, []any{v21})
								var v24 any = tmp23
								_ = v24
								// let binding "first__337"
								tmp25 := checkDerefVar(glojure_DOT_core_first)
								tmp26 := lang.Apply(tmp25, []any{v24})
								var v27 any = tmp26
								_ = v27
								// let binding "seq__336"
								tmp28 := checkDerefVar(glojure_DOT_core_next)
								tmp29 := lang.Apply(tmp28, []any{v24})
								var v30 any = tmp29
								_ = v30
								// let binding "x"
								var v31 any = v27
								_ = v31
								// let binding "xs"
								var v32 any = v30
								_ = v32
								// let binding "vs"
								var v33 any = v21
								_ = v33
								var tmp34 lang.FnFunc
								tmp34 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 0 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									var tmp35 any
									{ // let
										// let binding "temp__0__auto__"
										tmp36 := checkDerefVar(glojure_DOT_core_seq)
										tmp37 := lang.Apply(tmp36, []any{v19})
										var v38 any = tmp37
										_ = v38
										var tmp39 any
										if lang.IsTruthy(v38) {
											var tmp40 any
											{ // let
												// let binding "s"
												var v41 any = v38
												_ = v41
												tmp42 := checkDerefVar(glojure_DOT_core_cons)
												tmp43 := checkDerefVar(glojure_DOT_core_deref)
												tmp44 := lang.Apply(tmp43, []any{v31})
												tmp45 := checkDerefVar(glojure_DOT_core_rest)
												tmp46 := lang.Apply(tmp45, []any{v41})
												tmp47 := lang.Apply(v17, []any{v32, tmp46})
												tmp48 := lang.Apply(tmp42, []any{tmp44, tmp47})
												tmp40 = tmp48
											} // end let
											tmp39 = tmp40
										} else {
											tmp41 := checkDerefVar(glojure_DOT_core_map)
											tmp42 := checkDerefVar(glojure_DOT_core_deref)
											tmp43 := lang.Apply(tmp41, []any{tmp42, v33})
											tmp39 = tmp43
										}
										tmp35 = tmp39
									} // end let
									return tmp35
								})
								tmp35 := lang.Apply(lang.NewLazySeq, []any{tmp34})
								tmp20 = tmp35
							} // end let
							return tmp20
						})
						v17 = tmp16
						_ = v17
					}
					tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7042), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(7046), lang.NewKeyword("end-column"), int(36))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v19 any = tmp18
					_ = v19
					tmp20 := checkDerefVar(glojure_DOT_core_drop)
					tmp21 := lang.Apply(tmp20, []any{v9, v15})
					tmp22 := lang.Apply(v19, []any{v15, tmp21})
					tmp5 = tmp22
				} // end let
				return tmp5
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "step"
					var tmp7 lang.FnFunc
					{ // function step
						var v8 lang.FnFunc
						tmp7 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v9 := args[0]
							_ = v9
							var tmp10 lang.FnFunc
							tmp10 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								var tmp11 any
								{ // let
									// let binding "ss"
									tmp12 := checkDerefVar(glojure_DOT_core_map)
									tmp13 := checkDerefVar(glojure_DOT_core_seq)
									tmp14 := lang.Apply(tmp12, []any{tmp13, v9})
									var v15 any = tmp14
									_ = v15
									var tmp16 any
									tmp17 := checkDerefVar(glojure_DOT_core_every_QMARK_)
									tmp18 := checkDerefVar(glojure_DOT_core_identity)
									tmp19 := lang.Apply(tmp17, []any{tmp18, v15})
									if lang.IsTruthy(tmp19) {
										tmp20 := checkDerefVar(glojure_DOT_core_cons)
										tmp21 := checkDerefVar(glojure_DOT_core_map)
										tmp22 := checkDerefVar(glojure_DOT_core_first)
										tmp23 := lang.Apply(tmp21, []any{tmp22, v15})
										tmp24 := checkDerefVar(glojure_DOT_core_map)
										tmp25 := checkDerefVar(glojure_DOT_core_rest)
										tmp26 := lang.Apply(tmp24, []any{tmp25, v15})
										tmp27 := lang.Apply(v8, []any{tmp26})
										tmp28 := lang.Apply(tmp20, []any{tmp23, tmp27})
										tmp16 = tmp28
									} else {
									}
									tmp11 = tmp16
								} // end let
								return tmp11
							})
							tmp11 := lang.Apply(lang.NewLazySeq, []any{tmp10})
							return tmp11
						})
						v8 = tmp7
						_ = v8
					}
					tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7049), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(7053), lang.NewKeyword("end-column"), int(67))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v10 any = tmp9
					_ = v10
					tmp11 := checkDerefVar(glojure_DOT_core_pmap)
					var tmp12 lang.FnFunc
					tmp12 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v13 := args[0]
						_ = v13
						tmp14 := checkDerefVar(glojure_DOT_core_apply)
						tmp15 := lang.Apply(tmp14, []any{v3, v13})
						return tmp15
					})
					tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7054), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(7054), lang.NewKeyword("end-column"), int(23))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := checkDerefVar(glojure_DOT_core_cons)
					tmp16 := lang.Apply(tmp15, []any{v4, v5})
					tmp17 := lang.Apply(v10, []any{tmp16})
					tmp18 := lang.Apply(tmp11, []any{tmp14, tmp17})
					tmp6 = tmp18
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop
	{
		tmp0 := lang.NewSymbol("pop").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item. If\n  the collection is empty, throws an exception.  Note - not the same\n  as next/butlast.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1462), lang.NewKeyword("end-line"), int(1462))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime7.RT, "Pop")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Pop is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop!
	{
		tmp0 := lang.NewSymbol("pop!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3393), lang.NewKeyword("end-line"), int(3393))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "pop")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "pop")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop-thread-bindings
	{
		tmp0 := lang.NewSymbol("pop-thread-bindings").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Pop one set of bindings pushed with push-binding before. It is an error to\n  pop bindings without pushing before.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1929), lang.NewKeyword("end-line"), int(1929))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(lang.PopThreadBindings, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pos-int?
	{
		tmp0 := lang.NewSymbol("pos-int?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a positive fixed precision integer", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1403), lang.NewKeyword("end-line"), int(1403))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_int_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp8 = tmp10
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pos?
	{
		var tmp1 lang.FnFunc
		{ // function pos?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/IsPos")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("pos?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if num is greater than zero, else false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1252), lang.NewKeyword("end-line"), int(1252))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IsPos")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IsPos is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pr
	{
		tmp0 := lang.NewSymbol("pr").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Prints the object(s) to the output stream that is the current value\n  of *out*.  Prints the object(s), separated by spaces if there is\n  more than one.  By default, pr and prn print in a way that objects\n  can be read by the reader", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3678), lang.NewKeyword("end-line"), int(3678), lang.NewKeyword("dynamic"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return nil
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_pr_on)
				tmp5 := checkDerefVar(glojure_DOT_core__STAR_out_STAR_)
				tmp6 := lang.Apply(tmp4, []any{v3, tmp5})
				return tmp6
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
			recur_loop_671:
				tmp5 := checkDerefVar(glojure_DOT_core_pr)
				tmp6 := lang.Apply(tmp5, []any{v3})
				_ = tmp6
				tmp7 := checkDerefVar(glojure_DOT_core__STAR_out_STAR_)
				tmp8 := lang.Apply(lang.AppendWriter, []any{tmp7, lang.NewChar(32)})
				_ = tmp8
				var tmp9 any
				{ // let
					// let binding "temp__0__auto__"
					tmp10 := checkDerefVar(glojure_DOT_core_next)
					tmp11 := lang.Apply(tmp10, []any{v4})
					var v12 any = tmp11
					_ = v12
					var tmp13 any
					if lang.IsTruthy(v12) {
						var tmp14 any
						{ // let
							// let binding "nmore"
							var v15 any = v12
							_ = v15
							tmp17 := checkDerefVar(glojure_DOT_core_first)
							tmp18 := lang.Apply(tmp17, []any{v4})
							var tmp16 any = tmp18
							var tmp19 any = v15
							v3 = tmp16
							v4 = tmp19
							goto recur_loop_671
						} // end let
						tmp13 = tmp14
					} else {
						tmp15 := checkDerefVar(glojure_DOT_core_apply)
						tmp16 := checkDerefVar(glojure_DOT_core_pr)
						tmp17 := lang.Apply(tmp15, []any{tmp16, v4})
						tmp13 = tmp17
					}
					tmp9 = tmp13
				} // end let
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pr-on
	{
		tmp0 := lang.NewSymbol("pr-on").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("w"))), lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3669), lang.NewKeyword("end-line"), int(3669), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core__STAR_print_dup_STAR_)
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(glojure_DOT_core_print_dup)
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				tmp5 = tmp8
			} else {
				tmp9 := checkDerefVar(glojure_DOT_core_print_method)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp5 = tmp10
			}
			_ = tmp5
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pr-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("pr-str").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("xs"))), lang.NewKeyword("doc"), "pr to a string, returning it", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4758), lang.NewKeyword("end-line"), int(4758))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
						tmp9 := checkDerefVar(glojure_DOT_core_hash_map)
						tmp10 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*out*"))
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(glojure_DOT_core_apply)
							tmp17 := checkDerefVar(glojure_DOT_core_pr)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v4})
							_ = tmp18
							tmp19 := checkDerefVar(glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prefer-method
	{
		tmp0 := lang.NewSymbol("prefer-method").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"), lang.NewSymbol("dispatch-val-x"), lang.NewSymbol("dispatch-val-y"))), lang.NewKeyword("doc"), "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \n   when there is a conflict", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1801), lang.NewKeyword("end-line"), int(1801))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(v3, "PreferMethod")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("PreferMethod is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prefers
	{
		tmp0 := lang.NewSymbol("prefers").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"))), lang.NewKeyword("doc"), "Given a multimethod, returns a map of preferred value -> set of other values", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1822), lang.NewKeyword("end-line"), int(1822))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getPreferTable")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getPreferTable")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prep-hashes
	{
		tmp0 := lang.NewSymbol("prep-hashes").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr-sym"), lang.NewSymbol("default"), lang.NewSymbol("tests"), lang.NewSymbol("thens"))), lang.NewKeyword("doc"), "Takes a sequence of test constants and a corresponding sequence of then\n  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]\n  where case-map is a map of int case values to [test then] tuples, switch-type\n  is either :sparse or :compact, and skip-check is a set of case ints for which\n  post-switch equivalence checking must not be done (occurs with hash\n  collisions).", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6683), lang.NewKeyword("end-line"), int(6683), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			var tmp7 any
			{ // let
				// let binding "hashcode"
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v9 := args[0]
					_ = v9
					tmp10 := lang.Apply(lang.Hash, []any{v9})
					return tmp10
				})
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6691), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(6691), lang.NewKeyword("end-column"), int(66))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v11 any = tmp10
				_ = v11
				// let binding "hashes"
				tmp12 := checkDerefVar(glojure_DOT_core_into1)
				tmp13 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6692), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(6692), lang.NewKeyword("end-column"), int(25))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp16 := checkDerefVar(glojure_DOT_core_map)
				tmp17 := lang.Apply(tmp16, []any{v11, v5})
				tmp18 := lang.Apply(tmp12, []any{tmp15, tmp17})
				var v19 any = tmp18
				_ = v19
				var tmp20 any
				tmp21 := checkDerefVar(glojure_DOT_core__EQ__EQ_)
				tmp22 := checkDerefVar(glojure_DOT_core_count)
				tmp23 := lang.Apply(tmp22, []any{v5})
				tmp24 := checkDerefVar(glojure_DOT_core_count)
				tmp25 := lang.Apply(tmp24, []any{v19})
				tmp26 := lang.Apply(tmp21, []any{tmp23, tmp25})
				if lang.IsTruthy(tmp26) {
					var tmp27 any
					tmp28 := checkDerefVar(glojure_DOT_core_fits_table_QMARK_)
					tmp29 := lang.Apply(tmp28, []any{v19})
					if lang.IsTruthy(tmp29) {
						tmp30 := checkDerefVar(glojure_DOT_core_case_map)
						tmp31 := checkDerefVar(glojure_DOT_core_identity)
						tmp32 := lang.Apply(tmp30, []any{v11, tmp31, v5, v6})
						tmp33 := lang.NewVector(int64(0), int64(0), tmp32, lang.NewKeyword("compact"))
						tmp34 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6696), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(6696), lang.NewKeyword("end-column"), int(63))
						tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp27 = tmp35
					} else {
						var tmp36 any
						{ // let
							// let binding "vec__167"
							var tmp37 any
							{ // let
								// let binding "or__0__auto__"
								tmp38 := checkDerefVar(glojure_DOT_core_maybe_min_hash)
								tmp39 := lang.Apply(tmp38, []any{v19})
								var v40 any = tmp39
								_ = v40
								var tmp41 any
								if lang.IsTruthy(v40) {
									tmp41 = v40
								} else {
									tmp42 := lang.NewVector(int64(0), int64(0))
									tmp43 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6697), lang.NewKeyword("column"), int(56), lang.NewKeyword("end-line"), int(6697), lang.NewKeyword("end-column"), int(60))
									tmp44, err := lang.WithMeta(tmp42, tmp43.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp41 = tmp44
								}
								tmp37 = tmp41
							} // end let
							var v38 any = tmp37
							_ = v38
							// let binding "shift"
							tmp39 := checkDerefVar(glojure_DOT_core_nth)
							tmp40 := lang.Apply(tmp39, []any{v38, int64(0), nil})
							var v41 any = tmp40
							_ = v41
							// let binding "mask"
							tmp42 := checkDerefVar(glojure_DOT_core_nth)
							tmp43 := lang.Apply(tmp42, []any{v38, int64(1), nil})
							var v44 any = tmp43
							_ = v44
							var tmp45 any
							tmp46 := checkDerefVar(glojure_DOT_core_zero_QMARK_)
							tmp47 := lang.Apply(tmp46, []any{v44})
							if lang.IsTruthy(tmp47) {
								tmp48 := checkDerefVar(glojure_DOT_core_case_map)
								tmp49 := checkDerefVar(glojure_DOT_core_identity)
								tmp50 := lang.Apply(tmp48, []any{v11, tmp49, v5, v6})
								tmp51 := lang.NewVector(int64(0), int64(0), tmp50, lang.NewKeyword("sparse"))
								tmp52 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6700), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(6700), lang.NewKeyword("end-column"), int(66))
								tmp53, err := lang.WithMeta(tmp51, tmp52.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp45 = tmp53
							} else {
								tmp54 := checkDerefVar(glojure_DOT_core_case_map)
								var tmp55 lang.FnFunc
								tmp55 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v56 := args[0]
									_ = v56
									tmp57 := checkDerefVar(glojure_DOT_core_shift_mask)
									tmp58 := lang.Apply(v11, []any{v56})
									tmp59 := lang.Apply(tmp57, []any{v41, v44, tmp58})
									return tmp59
								})
								tmp56 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6702), lang.NewKeyword("column"), int(35), lang.NewKeyword("end-line"), int(6702), lang.NewKeyword("end-column"), int(71))
								tmp57, err := lang.WithMeta(tmp55, tmp56.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp58 := checkDerefVar(glojure_DOT_core_identity)
								tmp59 := lang.Apply(tmp54, []any{tmp57, tmp58, v5, v6})
								tmp60 := lang.NewVector(v41, v44, tmp59, lang.NewKeyword("compact"))
								tmp61 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6702), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(6702), lang.NewKeyword("end-column"), int(103))
								tmp62, err := lang.WithMeta(tmp60, tmp61.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp45 = tmp62
							}
							tmp36 = tmp45
						} // end let
						tmp27 = tmp36
					}
					tmp20 = tmp27
				} else {
					var tmp37 any
					{ // let
						// let binding "vec__170"
						tmp38 := checkDerefVar(glojure_DOT_core_merge_hash_collisions)
						tmp39 := lang.Apply(tmp38, []any{v3, v4, v5, v6})
						var v40 any = tmp39
						_ = v40
						// let binding "tests"
						tmp41 := checkDerefVar(glojure_DOT_core_nth)
						tmp42 := lang.Apply(tmp41, []any{v40, int64(0), nil})
						var v43 any = tmp42
						_ = v43
						// let binding "thens"
						tmp44 := checkDerefVar(glojure_DOT_core_nth)
						tmp45 := lang.Apply(tmp44, []any{v40, int64(1), nil})
						var v46 any = tmp45
						_ = v46
						// let binding "skip-check"
						tmp47 := checkDerefVar(glojure_DOT_core_nth)
						tmp48 := lang.Apply(tmp47, []any{v40, int64(2), nil})
						var v49 any = tmp48
						_ = v49
						// let binding "vec__173"
						tmp50 := checkDerefVar(glojure_DOT_core_prep_hashes)
						tmp51 := lang.Apply(tmp50, []any{v3, v4, v43, v46})
						var v52 any = tmp51
						_ = v52
						// let binding "shift"
						tmp53 := checkDerefVar(glojure_DOT_core_nth)
						tmp54 := lang.Apply(tmp53, []any{v52, int64(0), nil})
						var v55 any = tmp54
						_ = v55
						// let binding "mask"
						tmp56 := checkDerefVar(glojure_DOT_core_nth)
						tmp57 := lang.Apply(tmp56, []any{v52, int64(1), nil})
						var v58 any = tmp57
						_ = v58
						// let binding "case-map"
						tmp59 := checkDerefVar(glojure_DOT_core_nth)
						tmp60 := lang.Apply(tmp59, []any{v52, int64(2), nil})
						var v61 any = tmp60
						_ = v61
						// let binding "switch-type"
						tmp62 := checkDerefVar(glojure_DOT_core_nth)
						tmp63 := lang.Apply(tmp62, []any{v52, int64(3), nil})
						var v64 any = tmp63
						_ = v64
						// let binding "skip-check"
						var tmp65 any
						tmp66 := checkDerefVar(glojure_DOT_core_zero_QMARK_)
						tmp67 := lang.Apply(tmp66, []any{v58})
						if lang.IsTruthy(tmp67) {
							tmp65 = v49
						} else {
							tmp68 := checkDerefVar(glojure_DOT_core_into1)
							tmp69 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp70 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6708), lang.NewKeyword("column"), int(33), lang.NewKeyword("end-line"), int(6708), lang.NewKeyword("end-column"), int(35))
							tmp71, err := lang.WithMeta(tmp69, tmp70.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp72 := checkDerefVar(glojure_DOT_core_map)
							var tmp73 lang.FnFunc
							tmp73 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v74 := args[0]
								_ = v74
								tmp75 := checkDerefVar(glojure_DOT_core_shift_mask)
								tmp76 := lang.Apply(tmp75, []any{v55, v58, v74})
								return tmp76
							})
							tmp74 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6708), lang.NewKeyword("column"), int(42), lang.NewKeyword("end-line"), int(6708), lang.NewKeyword("end-column"), int(67))
							tmp75, err := lang.WithMeta(tmp73, tmp74.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp76 := lang.Apply(tmp72, []any{tmp75, v49})
							tmp77 := lang.Apply(tmp68, []any{tmp71, tmp76})
							tmp65 = tmp77
						}
						var v78 any = tmp65
						_ = v78
						tmp79 := lang.NewVector(v55, v58, v61, v64, v78)
						tmp80 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6709), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(6709), lang.NewKeyword("end-column"), int(52))
						tmp81, err := lang.WithMeta(tmp79, tmp80.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp37 = tmp81
					} // end let
					tmp20 = tmp37
				}
				tmp7 = tmp20
			} // end let
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prep-ints
	{
		tmp0 := lang.NewSymbol("prep-ints").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tests"), lang.NewSymbol("thens"))), lang.NewKeyword("doc"), "Takes a sequence of int-sized test constants and a corresponding sequence of\n  then expressions. Returns a tuple of [shift mask case-map switch-type] where\n  case-map is a map of int case values to [test then] tuples, and switch-type\n  is either :sparse or :compact.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6631), lang.NewKeyword("end-line"), int(6631), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_fits_table_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v3})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(glojure_DOT_core_case_map)
				tmp9 := checkDerefVar(glojure_DOT_core_int)
				tmp10 := checkDerefVar(glojure_DOT_core_int)
				tmp11 := lang.Apply(tmp8, []any{tmp9, tmp10, v3, v4})
				tmp12 := lang.NewVector(int64(0), int64(0), tmp11, lang.NewKeyword("compact"))
				tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6639), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(6639), lang.NewKeyword("end-column"), int(49))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp5 = tmp14
			} else {
				var tmp15 any
				{ // let
					// let binding "vec__160"
					var tmp16 any
					{ // let
						// let binding "or__0__auto__"
						tmp17 := checkDerefVar(glojure_DOT_core_maybe_min_hash)
						tmp18 := checkDerefVar(glojure_DOT_core_map)
						tmp19 := checkDerefVar(glojure_DOT_core_int)
						tmp20 := lang.Apply(tmp18, []any{tmp19, v3})
						tmp21 := lang.Apply(tmp17, []any{tmp20})
						var v22 any = tmp21
						_ = v22
						var tmp23 any
						if lang.IsTruthy(v22) {
							tmp23 = v22
						} else {
							tmp24 := lang.NewVector(int64(0), int64(0))
							tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6640), lang.NewKeyword("column"), int(61), lang.NewKeyword("end-line"), int(6640), lang.NewKeyword("end-column"), int(65))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp23 = tmp26
						}
						tmp16 = tmp23
					} // end let
					var v17 any = tmp16
					_ = v17
					// let binding "shift"
					tmp18 := checkDerefVar(glojure_DOT_core_nth)
					tmp19 := lang.Apply(tmp18, []any{v17, int64(0), nil})
					var v20 any = tmp19
					_ = v20
					// let binding "mask"
					tmp21 := checkDerefVar(glojure_DOT_core_nth)
					tmp22 := lang.Apply(tmp21, []any{v17, int64(1), nil})
					var v23 any = tmp22
					_ = v23
					var tmp24 any
					tmp25 := checkDerefVar(glojure_DOT_core_zero_QMARK_)
					tmp26 := lang.Apply(tmp25, []any{v23})
					if lang.IsTruthy(tmp26) {
						tmp27 := checkDerefVar(glojure_DOT_core_case_map)
						tmp28 := checkDerefVar(glojure_DOT_core_int)
						tmp29 := checkDerefVar(glojure_DOT_core_int)
						tmp30 := lang.Apply(tmp27, []any{tmp28, tmp29, v3, v4})
						tmp31 := lang.NewVector(int64(0), int64(0), tmp30, lang.NewKeyword("sparse"))
						tmp32 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6643), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(6643), lang.NewKeyword("end-column"), int(52))
						tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp24 = tmp33
					} else {
						tmp34 := checkDerefVar(glojure_DOT_core_case_map)
						var tmp35 lang.FnFunc
						tmp35 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v36 := args[0]
							_ = v36
							tmp37 := checkDerefVar(glojure_DOT_core_shift_mask)
							tmp38 := checkDerefVar(glojure_DOT_core_int)
							tmp39 := lang.Apply(tmp38, []any{v36})
							tmp40 := lang.Apply(tmp37, []any{v20, v23, tmp39})
							return tmp40
						})
						tmp36 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6645), lang.NewKeyword("column"), int(31), lang.NewKeyword("end-line"), int(6645), lang.NewKeyword("end-column"), int(62))
						tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp38 := checkDerefVar(glojure_DOT_core_int)
						tmp39 := lang.Apply(tmp34, []any{tmp37, tmp38, v3, v4})
						tmp40 := lang.NewVector(v20, v23, tmp39, lang.NewKeyword("compact"))
						tmp41 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6645), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(6645), lang.NewKeyword("end-column"), int(89))
						tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp24 = tmp42
					}
					tmp15 = tmp24
				} // end let
				tmp5 = tmp15
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prependss
	{
		tmp0 := lang.NewSymbol("prependss").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Prepends a symbol or a seq to coll", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5857), lang.NewKeyword("end-line"), int(5857), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v3})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(glojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v3, v4})
				tmp5 = tmp9
			} else {
				tmp10 := checkDerefVar(glojure_DOT_core_concat)
				tmp11 := lang.Apply(tmp10, []any{v3, v4})
				tmp5 = tmp11
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// preserving-reduced
	{
		tmp0 := lang.NewSymbol("preserving-reduced").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7638), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(7638), lang.NewKeyword("end-column"), int(34), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rf"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ret"
					tmp8 := lang.Apply(v3, []any{v5, v6})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core_reduced_QMARK_)
					tmp12 := lang.Apply(tmp11, []any{v9})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(glojure_DOT_core_reduced)
						tmp14 := lang.Apply(tmp13, []any{v9})
						tmp10 = tmp14
					} else {
						tmp10 = v9
					}
					tmp7 = tmp10
				} // end let
				return tmp7
			})
			tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7640), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(7643), lang.NewKeyword("end-column"), int(12))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print
	{
		tmp0 := lang.NewSymbol("print").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Prints the object(s) to the output stream that is the current value\n  of *out*.  print and println produce output for human consumption.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3725), lang.NewKeyword("end-line"), int(3725))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					tmp5 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
					tmp6 := checkDerefVar(glojure_DOT_core_hash_map)
					tmp7 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-readably*"))
					tmp8 := lang.Apply(tmp6, []any{tmp7, nil})
					tmp9 := lang.Apply(tmp5, []any{tmp8})
					_ = tmp9
					var tmp10 any
					func() {
						defer func() {
							tmp11 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
							tmp12 := lang.Apply(tmp11, nil)
							_ = tmp12
						}()
						tmp13 := checkDerefVar(glojure_DOT_core_apply)
						tmp14 := checkDerefVar(glojure_DOT_core_pr)
						tmp15 := lang.Apply(tmp13, []any{tmp14, v3})
						tmp10 = tmp15
					}()
					tmp4 = tmp10
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-ctor
	{
		tmp0 := lang.NewSymbol("print-ctor").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(95), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(95), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("print-args"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := lang.Apply(lang.WriteWriter, []any{v5, "#=("})
			_ = tmp6
			tmp7 := checkDerefVar(glojure_DOT_core_class)
			tmp8 := lang.Apply(tmp7, []any{v3})
			tmp9, ok := lang.FieldOrMethod(tmp8, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp8, "Name")))
			}
			var tmp10 any
			switch reflect.TypeOf(tmp9).Kind() {
			case reflect.Func:
				tmp10 = lang.Apply(tmp9, nil)
			default:
				tmp10 = tmp9
			}
			tmp11 := lang.Apply(lang.WriteWriter, []any{v5, tmp10})
			_ = tmp11
			tmp12 := lang.Apply(lang.WriteWriter, []any{v5, ". "})
			_ = tmp12
			tmp13 := lang.Apply(v4, []any{v3, v5})
			_ = tmp13
			tmp14 := lang.Apply(lang.WriteWriter, []any{v5, ")"})
			return tmp14
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-dup
	{
		tmp0 := lang.NewSymbol("print-dup").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3667), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(3667), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := checkDerefVar(glojure_DOT_core_class)
			tmp7 := lang.Apply(tmp6, []any{v4})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3667), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(3667), lang.NewKeyword("end-column"), int(45))).(lang.FnFunc)
		tmp2 := lang.NewMultiFn("print-dup", tmp3, lang.NewKeyword("default"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")).FindInternedVar(lang.NewSymbol("global-hierarchy")))
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v5 := args[0]
			_ = v5
			v6 := args[1]
			_ = v6
			tmp7 := checkDerefVar(glojure_DOT_core_print_method)
			tmp8 := lang.Apply(tmp7, []any{v5, v6})
			return tmp8
		})
		tmp2.AddMethod(nil, tmp4)
		tmp5 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v7 := args[0]
			_ = v7
			v8 := args[1]
			_ = v8
			tmp9 := checkDerefVar(glojure_DOT_core_print_method)
			tmp10 := lang.Apply(tmp9, []any{v7, v8})
			return tmp10
		})
		tmp2.AddMethod(tmp5, tmp6)
		tmp7 := reflect.TypeOf((*lang.IPersistentList)(nil)).Elem()
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v9 := args[0]
			_ = v9
			v10 := args[1]
			_ = v10
			tmp11 := checkDerefVar(glojure_DOT_core_print_method)
			tmp12 := lang.Apply(tmp11, []any{v9, v10})
			return tmp12
		})
		tmp2.AddMethod(tmp7, tmp8)
		tmp9 := reflect.TypeOf((*lang.Symbol)(nil))
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v11 := args[0]
			_ = v11
			v12 := args[1]
			_ = v12
			tmp13 := checkDerefVar(glojure_DOT_core_print_method)
			tmp14 := lang.Apply(tmp13, []any{v11, v12})
			return tmp14
		})
		tmp2.AddMethod(tmp9, tmp10)
		tmp11 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		var tmp12 lang.FnFunc
		tmp12 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v13 := args[0]
			_ = v13
			v14 := args[1]
			_ = v14
			tmp15 := checkDerefVar(glojure_DOT_core_print_meta)
			tmp16 := lang.Apply(tmp15, []any{v13, v14})
			_ = tmp16
			tmp17 := lang.Apply(lang.WriteWriter, []any{v14, "#"})
			_ = tmp17
			tmp18 := checkDerefVar(glojure_DOT_core_class)
			tmp19 := lang.Apply(tmp18, []any{v13})
			tmp20, ok := lang.FieldOrMethod(tmp19, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp19, "Name")))
			}
			var tmp21 any
			switch reflect.TypeOf(tmp20).Kind() {
			case reflect.Func:
				tmp21 = lang.Apply(tmp20, nil)
			default:
				tmp21 = tmp20
			}
			tmp22 := lang.Apply(lang.WriteWriter, []any{v14, tmp21})
			_ = tmp22
			var tmp23 any
			tmp24 := checkDerefVar(glojure_DOT_core__STAR_verbose_defrecords_STAR_)
			if lang.IsTruthy(tmp24) {
				tmp25 := checkDerefVar(glojure_DOT_core_print_map)
				tmp26 := checkDerefVar(glojure_DOT_core_print_dup)
				tmp27 := lang.Apply(tmp25, []any{v13, tmp26, v14})
				tmp23 = tmp27
			} else {
				tmp28 := checkDerefVar(glojure_DOT_core_print_sequential)
				tmp29 := checkDerefVar(glojure_DOT_core_pr_on)
				tmp30 := checkDerefVar(glojure_DOT_core_vals)
				tmp31 := lang.Apply(tmp30, []any{v13})
				tmp32 := lang.Apply(tmp28, []any{"[", tmp29, ", ", "]", tmp31, v14})
				tmp23 = tmp32
			}
			return tmp23
		})
		tmp2.AddMethod(tmp11, tmp12)
		tmp13 := reflect.TypeOf((*lang.Set)(nil))
		var tmp14 lang.FnFunc
		tmp14 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v15 := args[0]
			_ = v15
			v16 := args[1]
			_ = v16
			tmp17 := checkDerefVar(glojure_DOT_core_print_method)
			tmp18 := lang.Apply(tmp17, []any{v15, v16})
			return tmp18
		})
		tmp2.AddMethod(tmp13, tmp14)
		tmp15 := reflect.TypeOf((*lang.PersistentHashMap)(nil))
		var tmp16 lang.FnFunc
		tmp16 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v17 := args[0]
			_ = v17
			v18 := args[1]
			_ = v18
			tmp19 := checkDerefVar(glojure_DOT_core_print_method)
			tmp20 := lang.Apply(tmp19, []any{v17, v18})
			return tmp20
		})
		tmp2.AddMethod(tmp15, tmp16)
		tmp17 := reflect.TypeOf(int64(0))
		var tmp18 lang.FnFunc
		tmp18 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v19 := args[0]
			_ = v19
			v20 := args[1]
			_ = v20
			tmp21 := checkDerefVar(glojure_DOT_core_print_method)
			tmp22 := lang.Apply(tmp21, []any{v19, v20})
			return tmp22
		})
		tmp2.AddMethod(tmp17, tmp18)
		tmp19 := reflect.TypeOf((*lang.Vector)(nil))
		var tmp20 lang.FnFunc
		tmp20 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v21 := args[0]
			_ = v21
			v22 := args[1]
			_ = v22
			tmp23 := checkDerefVar(glojure_DOT_core_print_method)
			tmp24 := lang.Apply(tmp23, []any{v21, v22})
			return tmp24
		})
		tmp2.AddMethod(tmp19, tmp20)
		tmp21 := reflect.TypeOf(float64(0))
		var tmp22 lang.FnFunc
		tmp22 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v23 := args[0]
			_ = v23
			v24 := args[1]
			_ = v24
			tmp25 := checkDerefVar(glojure_DOT_core_print_method)
			tmp26 := lang.Apply(tmp25, []any{v23, v24})
			return tmp26
		})
		tmp2.AddMethod(tmp21, tmp22)
		tmp23 := reflect.TypeOf("")
		var tmp24 lang.FnFunc
		tmp24 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v25 := args[0]
			_ = v25
			v26 := args[1]
			_ = v26
			tmp27 := checkDerefVar(glojure_DOT_core_print_method)
			tmp28 := lang.Apply(tmp27, []any{v25, v26})
			return tmp28
		})
		tmp2.AddMethod(tmp23, tmp24)
		tmp25 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		var tmp26 lang.FnFunc
		tmp26 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v27 := args[0]
			_ = v27
			v28 := args[1]
			_ = v28
			tmp29 := checkDerefVar(glojure_DOT_core_print_meta)
			tmp30 := lang.Apply(tmp29, []any{v27, v28})
			_ = tmp30
			tmp31 := lang.Apply(lang.WriteWriter, []any{v28, "#=("})
			_ = tmp31
			tmp32 := checkDerefVar(glojure_DOT_core_class)
			tmp33 := lang.Apply(tmp32, []any{v27})
			tmp34, ok := lang.FieldOrMethod(tmp33, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp33, "Name")))
			}
			var tmp35 any
			switch reflect.TypeOf(tmp34).Kind() {
			case reflect.Func:
				tmp35 = lang.Apply(tmp34, nil)
			default:
				tmp35 = tmp34
			}
			tmp36 := lang.Apply(lang.WriteWriter, []any{v28, tmp35})
			_ = tmp36
			tmp37 := lang.Apply(lang.WriteWriter, []any{v28, "/create "})
			_ = tmp37
			tmp38 := checkDerefVar(glojure_DOT_core_print_sequential)
			tmp39 := checkDerefVar(glojure_DOT_core_print_dup)
			tmp40 := lang.Apply(tmp38, []any{"[", tmp39, " ", "]", v27, v28})
			_ = tmp40
			tmp41 := lang.Apply(lang.WriteWriter, []any{v28, ")"})
			return tmp41
		})
		tmp2.AddMethod(tmp25, tmp26)
		tmp27 := reflect.TypeOf(int32(0))
		var tmp28 lang.FnFunc
		tmp28 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v29 := args[0]
			_ = v29
			v30 := args[1]
			_ = v30
			tmp31 := checkDerefVar(glojure_DOT_core_print_method)
			tmp32 := lang.Apply(tmp31, []any{v29, v30})
			return tmp32
		})
		tmp2.AddMethod(tmp27, tmp28)
		tmp29 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		var tmp30 lang.FnFunc
		tmp30 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v31 := args[0]
			_ = v31
			v32 := args[1]
			_ = v32
			tmp33 := checkDerefVar(glojure_DOT_core_print_meta)
			tmp34 := lang.Apply(tmp33, []any{v31, v32})
			_ = tmp34
			tmp35 := lang.Apply(lang.WriteWriter, []any{v32, "#=("})
			_ = tmp35
			tmp36 := checkDerefVar(glojure_DOT_core_class)
			tmp37 := lang.Apply(tmp36, []any{v31})
			tmp38, ok := lang.FieldOrMethod(tmp37, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp37, "Name")))
			}
			var tmp39 any
			switch reflect.TypeOf(tmp38).Kind() {
			case reflect.Func:
				tmp39 = lang.Apply(tmp38, nil)
			default:
				tmp39 = tmp38
			}
			tmp40 := lang.Apply(lang.WriteWriter, []any{v32, tmp39})
			_ = tmp40
			tmp41 := lang.Apply(lang.WriteWriter, []any{v32, "/create "})
			_ = tmp41
			tmp42 := checkDerefVar(glojure_DOT_core_print_map)
			tmp43 := checkDerefVar(glojure_DOT_core_print_dup)
			tmp44 := lang.Apply(tmp42, []any{v31, tmp43, v32})
			_ = tmp44
			tmp45 := lang.Apply(lang.WriteWriter, []any{v32, ")"})
			return tmp45
		})
		tmp2.AddMethod(tmp29, tmp30)
		tmp31 := reflect.TypeOf((*lang.Namespace)(nil))
		var tmp32 lang.FnFunc
		tmp32 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v33 := args[0]
			_ = v33
			v34 := args[1]
			_ = v34
			tmp35 := lang.Apply(lang.WriteWriter, []any{v34, "#=(find-ns "})
			_ = tmp35
			tmp36 := checkDerefVar(glojure_DOT_core_print_dup)
			tmp37, ok := lang.FieldOrMethod(v33, "name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v33, "name")))
			}
			var tmp38 any
			switch reflect.TypeOf(tmp37).Kind() {
			case reflect.Func:
				tmp38 = lang.Apply(tmp37, nil)
			default:
				tmp38 = tmp37
			}
			tmp39 := lang.Apply(tmp36, []any{tmp38, v34})
			_ = tmp39
			tmp40 := lang.Apply(lang.WriteWriter, []any{v34, ")"})
			return tmp40
		})
		tmp2.AddMethod(tmp31, tmp32)
		tmp33 := reflect.TypeOf(false)
		var tmp34 lang.FnFunc
		tmp34 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v35 := args[0]
			_ = v35
			v36 := args[1]
			_ = v36
			tmp37 := checkDerefVar(glojure_DOT_core_print_method)
			tmp38 := lang.Apply(tmp37, []any{v35, v36})
			return tmp38
		})
		tmp2.AddMethod(tmp33, tmp34)
		tmp35 := reflect.TypeOf((*regexp15.Regexp)(nil))
		var tmp36 lang.FnFunc
		tmp36 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v37 := args[0]
			_ = v37
			v38 := args[1]
			_ = v38
			tmp39 := checkDerefVar(glojure_DOT_core_print_method)
			tmp40 := lang.Apply(tmp39, []any{v37, v38})
			return tmp40
		})
		tmp2.AddMethod(tmp35, tmp36)
		tmp37 := reflect.TypeOf((*lang.Ratio)(nil))
		var tmp38 lang.FnFunc
		tmp38 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v39 := args[0]
			_ = v39
			v40 := args[1]
			_ = v40
			tmp41 := checkDerefVar(glojure_DOT_core_print_method)
			tmp42 := lang.Apply(tmp41, []any{v39, v40})
			return tmp42
		})
		tmp2.AddMethod(tmp37, tmp38)
		tmp39 := reflect.TypeOf((*lang.Var)(nil))
		var tmp40 lang.FnFunc
		tmp40 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v41 := args[0]
			_ = v41
			v42 := args[1]
			_ = v42
			tmp43 := checkDerefVar(glojure_DOT_core_str)
			tmp44, ok := lang.FieldOrMethod(v41, "Namespace")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v41, "Namespace")))
			}
			var tmp45 any
			switch reflect.TypeOf(tmp44).Kind() {
			case reflect.Func:
				tmp45 = lang.Apply(tmp44, nil)
			default:
				tmp45 = tmp44
			}
			tmp46, ok := lang.FieldOrMethod(tmp45, "name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp45, "name")))
			}
			var tmp47 any
			switch reflect.TypeOf(tmp46).Kind() {
			case reflect.Func:
				tmp47 = lang.Apply(tmp46, nil)
			default:
				tmp47 = tmp46
			}
			tmp48, ok := lang.FieldOrMethod(v41, "sym")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v41, "sym")))
			}
			var tmp49 any
			switch reflect.TypeOf(tmp48).Kind() {
			case reflect.Func:
				tmp49 = lang.Apply(tmp48, nil)
			default:
				tmp49 = tmp48
			}
			tmp50 := lang.Apply(tmp43, []any{"#=(var ", tmp47, "/", tmp49, ")"})
			tmp51 := lang.Apply(lang.WriteWriter, []any{v42, tmp50})
			return tmp51
		})
		tmp2.AddMethod(tmp39, tmp40)
		tmp41 := reflect.TypeOf((*lang.BigDecimal)(nil))
		var tmp42 lang.FnFunc
		tmp42 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v43 := args[0]
			_ = v43
			v44 := args[1]
			_ = v44
			tmp45 := checkDerefVar(glojure_DOT_core_print_method)
			tmp46 := lang.Apply(tmp45, []any{v43, v44})
			return tmp46
		})
		tmp2.AddMethod(tmp41, tmp42)
		tmp43 := reflect.TypeOf((*lang.BigInt)(nil))
		var tmp44 lang.FnFunc
		tmp44 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v45 := args[0]
			_ = v45
			v46 := args[1]
			_ = v46
			tmp47 := checkDerefVar(glojure_DOT_core_print_method)
			tmp48 := lang.Apply(tmp47, []any{v45, v46})
			return tmp48
		})
		tmp2.AddMethod(tmp43, tmp44)
		tmp45 := reflect.TypeOf((*runtime7.Fn)(nil))
		var tmp46 lang.FnFunc
		tmp46 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v47 := args[0]
			_ = v47
			v48 := args[1]
			_ = v48
			tmp49 := checkDerefVar(glojure_DOT_core_print_ctor)
			var tmp50 lang.FnFunc
			tmp50 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v51 := args[0]
				_ = v51
				v52 := args[1]
				_ = v52
				return nil
			})
			tmp51 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(167), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(167), lang.NewKeyword("end-column"), int(26))
			tmp52, err := lang.WithMeta(tmp50, tmp51.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp53 := lang.Apply(tmp49, []any{v47, tmp52, v48})
			return tmp53
		})
		tmp2.AddMethod(tmp45, tmp46)
		tmp47 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		var tmp48 lang.FnFunc
		tmp48 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v49 := args[0]
			_ = v49
			v50 := args[1]
			_ = v50
			tmp51 := checkDerefVar(glojure_DOT_core_print_method)
			tmp52 := lang.Apply(tmp51, []any{v49, v50})
			return tmp52
		})
		tmp2.AddMethod(tmp47, tmp48)
		tmp49 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp50 := reflect.TypeOf((*runtime7.Fn)(nil))
		tmp2.PreferMethod(tmp49, tmp50)
		tmp51 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp52 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp2.PreferMethod(tmp51, tmp52)
		tmp53 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		tmp54 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		tmp2.PreferMethod(tmp53, tmp54)
		tmp55 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		tmp56 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp2.PreferMethod(tmp55, tmp56)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-initialized
	{
		tmp0 := lang.NewSymbol("print-initialized").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(520), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(520), lang.NewKeyword("end-column"), int(39), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, true, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-map
	{
		tmp0 := lang.NewSymbol("print-map").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(252), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(252), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("print-one"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := checkDerefVar(glojure_DOT_core_print_prefix_map)
			tmp7 := lang.Apply(tmp6, []any{nil, v3, v4, v5})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-meta
	{
		tmp0 := lang.NewSymbol("print-meta").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(70), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(70), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "temp__0__auto__"
				tmp6 := checkDerefVar(glojure_DOT_core_meta)
				tmp7 := lang.Apply(tmp6, []any{v3})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "m"
						var v11 any = v8
						_ = v11
						var tmp12 any
						var tmp13 any
						{ // let
							// let binding "and__0__auto__"
							tmp14 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
							tmp15 := checkDerefVar(glojure_DOT_core_count)
							tmp16 := lang.Apply(tmp15, []any{v11})
							tmp17 := lang.Apply(tmp14, []any{tmp16})
							var v18 any = tmp17
							_ = v18
							var tmp19 any
							if lang.IsTruthy(v18) {
								var tmp20 any
								{ // let
									// let binding "or__0__auto__"
									tmp21 := checkDerefVar(glojure_DOT_core__STAR_print_dup_STAR_)
									var v22 any = tmp21
									_ = v22
									var tmp23 any
									if lang.IsTruthy(v22) {
										tmp23 = v22
									} else {
										var tmp24 any
										{ // let
											// let binding "and__0__auto__"
											tmp25 := checkDerefVar(glojure_DOT_core__STAR_print_meta_STAR_)
											var v26 any = tmp25
											_ = v26
											var tmp27 any
											if lang.IsTruthy(v26) {
												tmp28 := checkDerefVar(glojure_DOT_core__STAR_print_readably_STAR_)
												tmp27 = tmp28
											} else {
												tmp27 = v26
											}
											tmp24 = tmp27
										} // end let
										tmp23 = tmp24
									}
									tmp20 = tmp23
								} // end let
								tmp19 = tmp20
							} else {
								tmp19 = v18
							}
							tmp13 = tmp19
						} // end let
						if lang.IsTruthy(tmp13) {
							tmp14 := lang.Apply(lang.WriteWriter, []any{v4, "^"})
							_ = tmp14
							var tmp15 any
							var tmp16 any
							{ // let
								// let binding "and__0__auto__"
								tmp17 := checkDerefVar(glojure_DOT_core__EQ_)
								tmp18 := checkDerefVar(glojure_DOT_core_count)
								tmp19 := lang.Apply(tmp18, []any{v11})
								tmp20 := lang.Apply(tmp17, []any{tmp19, int64(1)})
								var v21 any = tmp20
								_ = v21
								var tmp22 any
								if lang.IsTruthy(v21) {
									tmp23 := lang.Apply(lang.NewKeyword("tag"), []any{v11})
									tmp22 = tmp23
								} else {
									tmp22 = v21
								}
								tmp16 = tmp22
							} // end let
							if lang.IsTruthy(tmp16) {
								tmp17 := checkDerefVar(glojure_DOT_core_pr_on)
								tmp18 := lang.Apply(lang.NewKeyword("tag"), []any{v11})
								tmp19 := lang.Apply(tmp17, []any{tmp18, v4})
								tmp15 = tmp19
							} else {
								tmp20 := checkDerefVar(glojure_DOT_core_pr_on)
								tmp21 := lang.Apply(tmp20, []any{v11, v4})
								tmp15 = tmp21
							}
							_ = tmp15
							tmp22 := lang.Apply(lang.WriteWriter, []any{v4, " "})
							tmp12 = tmp22
						} else {
						}
						tmp10 = tmp12
					} // end let
					tmp9 = tmp10
				} else {
				}
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-method
	{
		tmp0 := lang.NewSymbol("print-method").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3664), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(3664), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "t"
				tmp7 := checkDerefVar(glojure_DOT_core_get)
				tmp8 := checkDerefVar(glojure_DOT_core_meta)
				tmp9 := lang.Apply(tmp8, []any{v4})
				tmp10 := lang.Apply(tmp7, []any{tmp9, lang.NewKeyword("type")})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				tmp13 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
				tmp14 := lang.Apply(tmp13, []any{v11})
				if lang.IsTruthy(tmp14) {
					tmp12 = v11
				} else {
					tmp15 := checkDerefVar(glojure_DOT_core_class)
					tmp16 := lang.Apply(tmp15, []any{v4})
					tmp12 = tmp16
				}
				tmp6 = tmp12
			} // end let
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3664), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(3666), lang.NewKeyword("end-column"), int(58))).(lang.FnFunc)
		tmp2 := lang.NewMultiFn("print-method", tmp3, lang.NewKeyword("default"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")).FindInternedVar(lang.NewSymbol("global-hierarchy")))
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v5 := args[0]
			_ = v5
			v6 := args[1]
			_ = v6
			tmp7 := lang.Apply(lang.WriteWriter, []any{v6, "nil"})
			return tmp7
		})
		tmp2.AddMethod(nil, tmp4)
		tmp5 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v7 := args[0]
			_ = v7
			v8 := args[1]
			_ = v8
			tmp9 := checkDerefVar(glojure_DOT_core_str)
			tmp10 := lang.Apply(tmp9, []any{v7})
			tmp11 := lang.Apply(lang.WriteWriter, []any{v8, tmp10})
			return tmp11
		})
		tmp2.AddMethod(tmp5, tmp6)
		tmp7 := reflect.TypeOf(uint32(0))
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v9 := args[0]
			_ = v9
			v10 := args[1]
			_ = v10
			tmp11 := checkDerefVar(glojure_DOT_core_str)
			tmp12 := lang.Apply(tmp11, []any{v9})
			tmp13, _ := lang.FieldOrMethod(v10, "write")
			if reflect.TypeOf(tmp13).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp14 := lang.Apply(tmp13, []any{tmp12})
			return tmp14
		})
		tmp2.AddMethod(tmp7, tmp8)
		tmp9 := reflect.TypeOf((*lang.Symbol)(nil))
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v11 := args[0]
			_ = v11
			v12 := args[1]
			_ = v12
			tmp13 := checkDerefVar(glojure_DOT_core_print_simple)
			tmp14 := lang.Apply(tmp13, []any{v11, v12})
			return tmp14
		})
		tmp2.AddMethod(tmp9, tmp10)
		tmp11 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		var tmp12 lang.FnFunc
		tmp12 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v13 := args[0]
			_ = v13
			v14 := args[1]
			_ = v14
			tmp15 := checkDerefVar(glojure_DOT_core_print_meta)
			tmp16 := lang.Apply(tmp15, []any{v13, v14})
			_ = tmp16
			tmp17 := lang.Apply(lang.WriteWriter, []any{v14, "#"})
			_ = tmp17
			tmp18 := checkDerefVar(glojure_DOT_core_class)
			tmp19 := lang.Apply(tmp18, []any{v13})
			tmp20, ok := lang.FieldOrMethod(tmp19, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp19, "Name")))
			}
			var tmp21 any
			switch reflect.TypeOf(tmp20).Kind() {
			case reflect.Func:
				tmp21 = lang.Apply(tmp20, nil)
			default:
				tmp21 = tmp20
			}
			tmp22 := lang.Apply(lang.WriteWriter, []any{v14, tmp21})
			_ = tmp22
			tmp23 := checkDerefVar(glojure_DOT_core_print_map)
			tmp24 := checkDerefVar(glojure_DOT_core_pr_on)
			tmp25 := lang.Apply(tmp23, []any{v13, tmp24, v14})
			return tmp25
		})
		tmp2.AddMethod(tmp11, tmp12)
		tmp13 := reflect.TypeOf(uint(0))
		var tmp14 lang.FnFunc
		tmp14 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v15 := args[0]
			_ = v15
			v16 := args[1]
			_ = v16
			tmp17 := checkDerefVar(glojure_DOT_core_str)
			tmp18 := lang.Apply(tmp17, []any{v15})
			tmp19, _ := lang.FieldOrMethod(v16, "write")
			if reflect.TypeOf(tmp19).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp20 := lang.Apply(tmp19, []any{tmp18})
			return tmp20
		})
		tmp2.AddMethod(tmp13, tmp14)
		tmp15 := reflect.TypeOf(int64(0))
		var tmp16 lang.FnFunc
		tmp16 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v17 := args[0]
			_ = v17
			v18 := args[1]
			_ = v18
			tmp19 := checkDerefVar(glojure_DOT_core_str)
			tmp20 := lang.Apply(tmp19, []any{v17})
			tmp21, _ := lang.FieldOrMethod(v18, "write")
			if reflect.TypeOf(tmp21).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp22 := lang.Apply(tmp21, []any{tmp20})
			return tmp22
		})
		tmp2.AddMethod(tmp15, tmp16)
		var tmp17 lang.FnFunc
		tmp17 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v18 := args[0]
			_ = v18
			v19 := args[1]
			_ = v19
			var tmp20 any
			tmp21 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp22 := reflect.TypeOf((*lang.IObj)(nil)).Elem()
			tmp23 := lang.Apply(tmp21, []any{tmp22, v18})
			if lang.IsTruthy(tmp23) {
				tmp24 := checkDerefVar(glojure_DOT_core_print_method)
				tmp25 := checkDerefVar(glojure_DOT_core_vary_meta)
				var tmp26 lang.FnFunc
				tmp26 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v27 := args[0]
					_ = v27
					tmp28 := checkDerefVar(glojure_DOT_core_dissoc)
					tmp29 := lang.Apply(tmp28, []any{v27, lang.NewKeyword("type")})
					return tmp29
				})
				tmp27 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(87), lang.NewKeyword("column"), int(32), lang.NewKeyword("end-line"), int(87), lang.NewKeyword("end-column"), int(48))
				tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp29 := lang.Apply(tmp25, []any{v18, tmp28})
				tmp30 := lang.Apply(tmp24, []any{tmp29, v19})
				tmp20 = tmp30
			} else {
				tmp31 := checkDerefVar(glojure_DOT_core_print_simple)
				tmp32 := lang.Apply(tmp31, []any{v18, v19})
				tmp20 = tmp32
			}
			return tmp20
		})
		tmp2.AddMethod(lang.NewKeyword("default"), tmp17)
		tmp18 := reflect.TypeOf(float64(0))
		var tmp19 lang.FnFunc
		tmp19 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v20 := args[0]
			_ = v20
			v21 := args[1]
			_ = v21
			var tmp22 any
			tmp23 := checkDerefVar(glojure_DOT_core__EQ_)
			tmp24 := lang.Apply(math6.Inf, []any{int64(1)})
			tmp25 := lang.Apply(tmp23, []any{tmp24, v20})
			if lang.IsTruthy(tmp25) {
				tmp26 := lang.Apply(lang.WriteWriter, []any{v21, "##Inf"})
				tmp22 = tmp26
			} else {
				var tmp27 any
				tmp28 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp29 := lang.Apply(math6.Inf, []any{int64(-1)})
				tmp30 := lang.Apply(tmp28, []any{tmp29, v20})
				if lang.IsTruthy(tmp30) {
					tmp31 := lang.Apply(lang.WriteWriter, []any{v21, "##-Inf"})
					tmp27 = tmp31
				} else {
					var tmp32 any
					tmp33 := lang.Apply(math6.IsNaN, []any{v20})
					if lang.IsTruthy(tmp33) {
						tmp34 := lang.Apply(lang.WriteWriter, []any{v21, "##NaN"})
						tmp32 = tmp34
					} else {
						var tmp35 any
						if lang.IsTruthy(lang.NewKeyword("else")) {
							tmp36 := checkDerefVar(glojure_DOT_core_str)
							tmp37 := lang.Apply(tmp36, []any{v20})
							tmp38 := lang.Apply(lang.WriteWriter, []any{v21, tmp37})
							tmp35 = tmp38
						} else {
						}
						tmp32 = tmp35
					}
					tmp27 = tmp32
				}
				tmp22 = tmp27
			}
			return tmp22
		})
		tmp2.AddMethod(tmp18, tmp19)
		tmp20 := reflect.TypeOf("")
		var tmp21 lang.FnFunc
		tmp21 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v22 := args[0]
			_ = v22
			v23 := args[1]
			_ = v23
			var tmp24 any
			var tmp25 any
			{ // let
				// let binding "or__0__auto__"
				tmp26 := checkDerefVar(glojure_DOT_core__STAR_print_dup_STAR_)
				var v27 any = tmp26
				_ = v27
				var tmp28 any
				if lang.IsTruthy(v27) {
					tmp28 = v27
				} else {
					tmp29 := checkDerefVar(glojure_DOT_core__STAR_print_readably_STAR_)
					tmp28 = tmp29
				}
				tmp25 = tmp28
			} // end let
			if lang.IsTruthy(tmp25) {
				tmp26 := lang.Apply(lang.AppendWriter, []any{v23, lang.NewChar(34)})
				_ = tmp26
				var tmp27 any
				{ // let
					// let binding "n__0__auto__"
					tmp28 := checkDerefVar(glojure_DOT_core_long)
					tmp29 := checkDerefVar(glojure_DOT_core_count)
					tmp30 := lang.Apply(tmp29, []any{v22})
					tmp31 := lang.Apply(tmp28, []any{tmp30})
					var v32 any = tmp31
					_ = v32
					var tmp33 any
					{ // let
						// let binding "n"
						var v34 any = int64(0)
						_ = v34
						for {
							var tmp35 any
							tmp36 := checkDerefVar(glojure_DOT_core__LT_)
							tmp37 := lang.Apply(tmp36, []any{v34, v32})
							if lang.IsTruthy(tmp37) {
								var tmp38 any
								{ // let
									// let binding "c"
									tmp39 := lang.Apply(lang.CharAt, []any{v22, v34})
									var v40 any = tmp39
									_ = v40
									// let binding "e"
									tmp41 := checkDerefVar(glojure_DOT_core_char_escape_string)
									tmp42 := lang.Apply(tmp41, []any{v40})
									var v43 any = tmp42
									_ = v43
									var tmp44 any
									if lang.IsTruthy(v43) {
										tmp45 := lang.Apply(lang.WriteWriter, []any{v23, v43})
										tmp44 = tmp45
									} else {
										tmp46 := lang.Apply(lang.AppendWriter, []any{v23, v40})
										tmp44 = tmp46
									}
									tmp38 = tmp44
								} // end let
								_ = tmp38
								tmp40 := checkDerefVar(glojure_DOT_core_unchecked_inc)
								tmp41 := lang.Apply(tmp40, []any{v34})
								var tmp39 any = tmp41
								v34 = tmp39
								continue
							} else {
							}
							tmp33 = tmp35
							break
						}
					} // end let
					tmp27 = tmp33
				} // end let
				_ = tmp27
				tmp28 := lang.Apply(lang.AppendWriter, []any{v23, lang.NewChar(34)})
				tmp24 = tmp28
			} else {
				tmp29 := lang.Apply(lang.WriteWriter, []any{v23, v22})
				tmp24 = tmp29
			}
			_ = tmp24
			return nil
		})
		tmp2.AddMethod(tmp20, tmp21)
		tmp22 := reflect.TypeOf(int32(0))
		var tmp23 lang.FnFunc
		tmp23 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v24 := args[0]
			_ = v24
			v25 := args[1]
			_ = v25
			var tmp26 any
			var tmp27 any
			{ // let
				// let binding "or__0__auto__"
				tmp28 := checkDerefVar(glojure_DOT_core__STAR_print_dup_STAR_)
				var v29 any = tmp28
				_ = v29
				var tmp30 any
				if lang.IsTruthy(v29) {
					tmp30 = v29
				} else {
					tmp31 := checkDerefVar(glojure_DOT_core__STAR_print_readably_STAR_)
					tmp30 = tmp31
				}
				tmp27 = tmp30
			} // end let
			if lang.IsTruthy(tmp27) {
				tmp28 := lang.Apply(lang.AppendWriter, []any{v25, lang.NewChar(92)})
				_ = tmp28
				var tmp29 any
				{ // let
					// let binding "n"
					tmp30 := checkDerefVar(glojure_DOT_core_char_name_string)
					tmp31 := lang.Apply(tmp30, []any{v24})
					var v32 any = tmp31
					_ = v32
					var tmp33 any
					if lang.IsTruthy(v32) {
						tmp34 := lang.Apply(lang.WriteWriter, []any{v25, v32})
						tmp33 = tmp34
					} else {
						tmp35 := lang.Apply(lang.AppendWriter, []any{v25, v24})
						tmp33 = tmp35
					}
					tmp29 = tmp33
				} // end let
				tmp26 = tmp29
			} else {
				tmp30 := lang.Apply(lang.AppendWriter, []any{v25, v24})
				tmp26 = tmp30
			}
			_ = tmp26
			return nil
		})
		tmp2.AddMethod(tmp22, tmp23)
		tmp24 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		var tmp25 lang.FnFunc
		tmp25 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v26 := args[0]
			_ = v26
			v27 := args[1]
			_ = v27
			tmp28 := checkDerefVar(glojure_DOT_core_print_meta)
			tmp29 := lang.Apply(tmp28, []any{v26, v27})
			_ = tmp29
			var tmp30 any
			{ // let
				// let binding "vec__234"
				tmp31 := checkDerefVar(glojure_DOT_core_lift_ns)
				tmp32 := lang.Apply(tmp31, []any{v26})
				var v33 any = tmp32
				_ = v33
				// let binding "ns"
				tmp34 := checkDerefVar(glojure_DOT_core_nth)
				tmp35 := lang.Apply(tmp34, []any{v33, int64(0), nil})
				var v36 any = tmp35
				_ = v36
				// let binding "lift-kvs"
				tmp37 := checkDerefVar(glojure_DOT_core_nth)
				tmp38 := lang.Apply(tmp37, []any{v33, int64(1), nil})
				var v39 any = tmp38
				_ = v39
				var tmp40 any
				if lang.IsTruthy(v36) {
					tmp41 := checkDerefVar(glojure_DOT_core_print_prefix_map)
					tmp42 := checkDerefVar(glojure_DOT_core_str)
					tmp43 := lang.Apply(tmp42, []any{"#:", v36})
					tmp44 := checkDerefVar(glojure_DOT_core_pr_on)
					tmp45 := lang.Apply(tmp41, []any{tmp43, v39, tmp44, v27})
					tmp40 = tmp45
				} else {
					tmp46 := checkDerefVar(glojure_DOT_core_print_map)
					tmp47 := checkDerefVar(glojure_DOT_core_pr_on)
					tmp48 := lang.Apply(tmp46, []any{v26, tmp47, v27})
					tmp40 = tmp48
				}
				tmp30 = tmp40
			} // end let
			return tmp30
		})
		tmp2.AddMethod(tmp24, tmp25)
		tmp26 := reflect.TypeOf((*lang.IPersistentVector)(nil)).Elem()
		var tmp27 lang.FnFunc
		tmp27 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v28 := args[0]
			_ = v28
			v29 := args[1]
			_ = v29
			tmp30 := checkDerefVar(glojure_DOT_core_print_meta)
			tmp31 := lang.Apply(tmp30, []any{v28, v29})
			_ = tmp31
			tmp32 := checkDerefVar(glojure_DOT_core_print_sequential)
			tmp33 := checkDerefVar(glojure_DOT_core_pr_on)
			tmp34 := lang.Apply(tmp32, []any{"[", tmp33, " ", "]", v28, v29})
			return tmp34
		})
		tmp2.AddMethod(tmp26, tmp27)
		tmp28 := reflect.TypeOf((*lang.IPersistentSet)(nil)).Elem()
		var tmp29 lang.FnFunc
		tmp29 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v30 := args[0]
			_ = v30
			v31 := args[1]
			_ = v31
			tmp32 := checkDerefVar(glojure_DOT_core_print_meta)
			tmp33 := lang.Apply(tmp32, []any{v30, v31})
			_ = tmp33
			tmp34 := checkDerefVar(glojure_DOT_core_print_sequential)
			tmp35 := checkDerefVar(glojure_DOT_core_pr_on)
			tmp36 := checkDerefVar(glojure_DOT_core_seq)
			tmp37 := lang.Apply(tmp36, []any{v30})
			tmp38 := lang.Apply(tmp34, []any{"#{", tmp35, " ", "}", tmp37, v31})
			return tmp38
		})
		tmp2.AddMethod(tmp28, tmp29)
		tmp30 := reflect.TypeOf(uint8(0))
		var tmp31 lang.FnFunc
		tmp31 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v32 := args[0]
			_ = v32
			v33 := args[1]
			_ = v33
			tmp34 := checkDerefVar(glojure_DOT_core_str)
			tmp35 := lang.Apply(tmp34, []any{v32})
			tmp36, _ := lang.FieldOrMethod(v33, "write")
			if reflect.TypeOf(tmp36).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp37 := lang.Apply(tmp36, []any{tmp35})
			return tmp37
		})
		tmp2.AddMethod(tmp30, tmp31)
		tmp32 := reflect.TypeOf((*lang.IDeref)(nil)).Elem()
		var tmp33 lang.FnFunc
		tmp33 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v34 := args[0]
			_ = v34
			v35 := args[1]
			_ = v35
			tmp36 := checkDerefVar(glojure_DOT_core_print_tagged_object)
			tmp37 := checkDerefVar(glojure_DOT_core_deref_as_map)
			tmp38 := lang.Apply(tmp37, []any{v34})
			tmp39 := lang.Apply(tmp36, []any{v34, tmp38, v35})
			return tmp39
		})
		tmp2.AddMethod(tmp32, tmp33)
		tmp34 := reflect.TypeOf(false)
		var tmp35 lang.FnFunc
		tmp35 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v36 := args[0]
			_ = v36
			v37 := args[1]
			_ = v37
			tmp38 := checkDerefVar(glojure_DOT_core_str)
			tmp39 := lang.Apply(tmp38, []any{v36})
			tmp40 := lang.Apply(lang.WriteWriter, []any{v37, tmp39})
			return tmp40
		})
		tmp2.AddMethod(tmp34, tmp35)
		tmp36 := reflect.TypeOf((*lang.Object)(nil)).Elem()
		var tmp37 lang.FnFunc
		tmp37 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v38 := args[0]
			_ = v38
			v39 := args[1]
			_ = v39
			tmp40 := checkDerefVar(glojure_DOT_core_print_object)
			tmp41 := lang.Apply(tmp40, []any{v38, v39})
			return tmp41
		})
		tmp2.AddMethod(tmp36, tmp37)
		tmp38 := reflect.TypeOf(int(0))
		var tmp39 lang.FnFunc
		tmp39 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v40 := args[0]
			_ = v40
			v41 := args[1]
			_ = v41
			tmp42 := checkDerefVar(glojure_DOT_core_str)
			tmp43 := lang.Apply(tmp42, []any{v40})
			tmp44, _ := lang.FieldOrMethod(v41, "write")
			if reflect.TypeOf(tmp44).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp45 := lang.Apply(tmp44, []any{tmp43})
			return tmp45
		})
		tmp2.AddMethod(tmp38, tmp39)
		tmp40 := reflect.TypeOf((*regexp15.Regexp)(nil))
		var tmp41 lang.FnFunc
		tmp41 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v42 := args[0]
			_ = v42
			v43 := args[1]
			_ = v43
			tmp44 := lang.Apply(lang.WriteWriter, []any{v43, "#\""})
			_ = tmp44
			var tmp45 any
			{ // let
				// let binding "G__240"
				tmp46 := checkDerefVar(glojure_DOT_core_seq)
				tmp47, ok := lang.FieldOrMethod(v42, "String")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v42, "String")))
				}
				var tmp48 any
				switch reflect.TypeOf(tmp47).Kind() {
				case reflect.Func:
					tmp48 = lang.Apply(tmp47, nil)
				default:
					tmp48 = tmp47
				}
				tmp49 := lang.Apply(tmp46, []any{tmp48})
				var v50 any = tmp49
				_ = v50
				// let binding "vec__241"
				var v51 any = v50
				_ = v51
				// let binding "seq__242"
				tmp52 := checkDerefVar(glojure_DOT_core_seq)
				tmp53 := lang.Apply(tmp52, []any{v51})
				var v54 any = tmp53
				_ = v54
				// let binding "first__243"
				tmp55 := checkDerefVar(glojure_DOT_core_first)
				tmp56 := lang.Apply(tmp55, []any{v54})
				var v57 any = tmp56
				_ = v57
				// let binding "seq__242"
				tmp58 := checkDerefVar(glojure_DOT_core_next)
				tmp59 := lang.Apply(tmp58, []any{v54})
				var v60 any = tmp59
				_ = v60
				// let binding "c"
				var v61 any = v57
				_ = v61
				// let binding "r"
				var v62 any = v60
				_ = v62
				// let binding "s"
				var v63 any = v51
				_ = v63
				// let binding "qmode"
				var v64 any = false
				_ = v64
				var tmp65 any
				{ // let
					// let binding "G__240"
					var v66 any = v50
					_ = v66
					// let binding "qmode"
					var v67 any = v64
					_ = v67
					for {
						var tmp68 any
						{ // let
							// let binding "vec__244"
							var v69 any = v66
							_ = v69
							// let binding "seq__245"
							tmp70 := checkDerefVar(glojure_DOT_core_seq)
							tmp71 := lang.Apply(tmp70, []any{v69})
							var v72 any = tmp71
							_ = v72
							// let binding "first__246"
							tmp73 := checkDerefVar(glojure_DOT_core_first)
							tmp74 := lang.Apply(tmp73, []any{v72})
							var v75 any = tmp74
							_ = v75
							// let binding "seq__245"
							tmp76 := checkDerefVar(glojure_DOT_core_next)
							tmp77 := lang.Apply(tmp76, []any{v72})
							var v78 any = tmp77
							_ = v78
							// let binding "c"
							var v79 any = v75
							_ = v79
							// let binding "r"
							var v80 any = v78
							_ = v80
							// let binding "s"
							var v81 any = v69
							_ = v81
							// let binding "qmode"
							var v82 any = v67
							_ = v82
							var tmp83 any
							if lang.IsTruthy(v81) {
								var tmp84 any
								tmp85 := checkDerefVar(glojure_DOT_core__EQ_)
								tmp86 := lang.Apply(tmp85, []any{v79, lang.NewChar(92)})
								if lang.IsTruthy(tmp86) {
									var tmp87 any
									{ // let
										// let binding "vec__247"
										var v88 any = v80
										_ = v88
										// let binding "seq__248"
										tmp89 := checkDerefVar(glojure_DOT_core_seq)
										tmp90 := lang.Apply(tmp89, []any{v88})
										var v91 any = tmp90
										_ = v91
										// let binding "first__249"
										tmp92 := checkDerefVar(glojure_DOT_core_first)
										tmp93 := lang.Apply(tmp92, []any{v91})
										var v94 any = tmp93
										_ = v94
										// let binding "seq__248"
										tmp95 := checkDerefVar(glojure_DOT_core_next)
										tmp96 := lang.Apply(tmp95, []any{v91})
										var v97 any = tmp96
										_ = v97
										// let binding "c2"
										var v98 any = v94
										_ = v98
										// let binding "r2"
										var v99 any = v97
										_ = v99
										tmp100 := lang.Apply(lang.AppendWriter, []any{v43, lang.NewChar(92)})
										_ = tmp100
										tmp101 := lang.Apply(lang.AppendWriter, []any{v43, v98})
										_ = tmp101
										var tmp102 any
										if lang.IsTruthy(v82) {
											var tmp103 any = v99
											tmp105 := checkDerefVar(glojure_DOT_core_not_EQ_)
											tmp106 := lang.Apply(tmp105, []any{v98, lang.NewChar(69)})
											var tmp104 any = tmp106
											v66 = tmp103
											v67 = tmp104
											continue
										} else {
											var tmp107 any = v99
											tmp109 := checkDerefVar(glojure_DOT_core__EQ_)
											tmp110 := lang.Apply(tmp109, []any{v98, lang.NewChar(81)})
											var tmp108 any = tmp110
											v66 = tmp107
											v67 = tmp108
											continue
										}
										tmp87 = tmp102
									} // end let
									tmp84 = tmp87
								} else {
									var tmp88 any
									tmp89 := checkDerefVar(glojure_DOT_core__EQ_)
									tmp90 := lang.Apply(tmp89, []any{v79, lang.NewChar(34)})
									if lang.IsTruthy(tmp90) {
										var tmp91 any
										if lang.IsTruthy(v82) {
											tmp92 := lang.Apply(lang.WriteWriter, []any{v43, "\\E\\\"\\Q"})
											tmp91 = tmp92
										} else {
											tmp93 := lang.Apply(lang.WriteWriter, []any{v43, "\\\""})
											tmp91 = tmp93
										}
										_ = tmp91
										var tmp94 any = v80
										var tmp95 any = v82
										v66 = tmp94
										v67 = tmp95
										continue
									} else {
										var tmp96 any
										if lang.IsTruthy(lang.NewKeyword("else")) {
											tmp97 := lang.Apply(lang.AppendWriter, []any{v43, v79})
											_ = tmp97
											var tmp98 any = v80
											var tmp99 any = v82
											v66 = tmp98
											v67 = tmp99
											continue
										} else {
										}
										tmp88 = tmp96
									}
									tmp84 = tmp88
								}
								tmp83 = tmp84
							} else {
							}
							tmp68 = tmp83
						} // end let
						tmp65 = tmp68
						break
					}
				} // end let
				tmp45 = tmp65
			} // end let
			_ = tmp45
			tmp46 := lang.Apply(lang.AppendWriter, []any{v43, lang.NewChar(34)})
			return tmp46
		})
		tmp2.AddMethod(tmp40, tmp41)
		tmp42 := reflect.TypeOf(int32(0))
		var tmp43 lang.FnFunc
		tmp43 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v44 := args[0]
			_ = v44
			v45 := args[1]
			_ = v45
			tmp46 := checkDerefVar(glojure_DOT_core_str)
			tmp47 := lang.Apply(tmp46, []any{v44})
			tmp48, _ := lang.FieldOrMethod(v45, "write")
			if reflect.TypeOf(tmp48).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp49 := lang.Apply(tmp48, []any{tmp47})
			return tmp49
		})
		tmp2.AddMethod(tmp42, tmp43)
		tmp44 := reflect.TypeOf((*lang.Ratio)(nil))
		var tmp45 lang.FnFunc
		tmp45 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v46 := args[0]
			_ = v46
			v47 := args[1]
			_ = v47
			tmp48 := checkDerefVar(glojure_DOT_core_str)
			tmp49 := lang.Apply(tmp48, []any{v46})
			tmp50, _ := lang.FieldOrMethod(v47, "write")
			if reflect.TypeOf(tmp50).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp51 := lang.Apply(tmp50, []any{tmp49})
			return tmp51
		})
		tmp2.AddMethod(tmp44, tmp45)
		tmp46 := reflect.TypeOf(float32(0))
		var tmp47 lang.FnFunc
		tmp47 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v48 := args[0]
			_ = v48
			v49 := args[1]
			_ = v49
			var tmp50 any
			tmp51 := checkDerefVar(glojure_DOT_core__EQ_)
			tmp52 := lang.Apply(math6.Inf, []any{int64(1)})
			tmp53 := lang.Apply(lang.Builtins["float32"], []any{tmp52})
			tmp54 := lang.Apply(tmp51, []any{tmp53, v48})
			if lang.IsTruthy(tmp54) {
				tmp55 := lang.Apply(lang.WriteWriter, []any{v49, "##Inf"})
				tmp50 = tmp55
			} else {
				var tmp56 any
				tmp57 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp58 := lang.Apply(math6.Inf, []any{int64(-1)})
				tmp59 := lang.Apply(lang.Builtins["float32"], []any{tmp58})
				tmp60 := lang.Apply(tmp57, []any{tmp59, v48})
				if lang.IsTruthy(tmp60) {
					tmp61 := lang.Apply(lang.WriteWriter, []any{v49, "##-Inf"})
					tmp56 = tmp61
				} else {
					var tmp62 any
					tmp63 := lang.Apply(math6.IsNaN, []any{v48})
					if lang.IsTruthy(tmp63) {
						tmp64 := lang.Apply(lang.WriteWriter, []any{v49, "##NaN"})
						tmp62 = tmp64
					} else {
						var tmp65 any
						if lang.IsTruthy(lang.NewKeyword("else")) {
							tmp66 := checkDerefVar(glojure_DOT_core_str)
							tmp67 := lang.Apply(tmp66, []any{v48})
							tmp68 := lang.Apply(lang.WriteWriter, []any{v49, tmp67})
							tmp65 = tmp68
						} else {
						}
						tmp62 = tmp65
					}
					tmp56 = tmp62
				}
				tmp50 = tmp56
			}
			return tmp50
		})
		tmp2.AddMethod(tmp46, tmp47)
		tmp48 := reflect.TypeOf(int16(0))
		var tmp49 lang.FnFunc
		tmp49 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v50 := args[0]
			_ = v50
			v51 := args[1]
			_ = v51
			tmp52 := checkDerefVar(glojure_DOT_core_str)
			tmp53 := lang.Apply(tmp52, []any{v50})
			tmp54, _ := lang.FieldOrMethod(v51, "write")
			if reflect.TypeOf(tmp54).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp55 := lang.Apply(tmp54, []any{tmp53})
			return tmp55
		})
		tmp2.AddMethod(tmp48, tmp49)
		tmp50 := reflect.TypeOf((*lang.Var)(nil))
		var tmp51 lang.FnFunc
		tmp51 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v52 := args[0]
			_ = v52
			v53 := args[1]
			_ = v53
			tmp54 := checkDerefVar(glojure_DOT_core_print_simple)
			tmp55 := lang.Apply(tmp54, []any{v52, v53})
			return tmp55
		})
		tmp2.AddMethod(tmp50, tmp51)
		tmp52 := reflect.TypeOf(int8(0))
		var tmp53 lang.FnFunc
		tmp53 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v54 := args[0]
			_ = v54
			v55 := args[1]
			_ = v55
			tmp56 := checkDerefVar(glojure_DOT_core_str)
			tmp57 := lang.Apply(tmp56, []any{v54})
			tmp58, _ := lang.FieldOrMethod(v55, "write")
			if reflect.TypeOf(tmp58).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp59 := lang.Apply(tmp58, []any{tmp57})
			return tmp59
		})
		tmp2.AddMethod(tmp52, tmp53)
		tmp54 := reflect.TypeOf(uint16(0))
		var tmp55 lang.FnFunc
		tmp55 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v56 := args[0]
			_ = v56
			v57 := args[1]
			_ = v57
			tmp58 := checkDerefVar(glojure_DOT_core_str)
			tmp59 := lang.Apply(tmp58, []any{v56})
			tmp60, _ := lang.FieldOrMethod(v57, "write")
			if reflect.TypeOf(tmp60).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp61 := lang.Apply(tmp60, []any{tmp59})
			return tmp61
		})
		tmp2.AddMethod(tmp54, tmp55)
		tmp56 := reflect.TypeOf(uint64(0))
		var tmp57 lang.FnFunc
		tmp57 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v58 := args[0]
			_ = v58
			v59 := args[1]
			_ = v59
			tmp60 := checkDerefVar(glojure_DOT_core_str)
			tmp61 := lang.Apply(tmp60, []any{v58})
			tmp62, _ := lang.FieldOrMethod(v59, "write")
			if reflect.TypeOf(tmp62).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp63 := lang.Apply(tmp62, []any{tmp61})
			return tmp63
		})
		tmp2.AddMethod(tmp56, tmp57)
		tmp58 := reflect.TypeOf((*lang.BigDecimal)(nil))
		var tmp59 lang.FnFunc
		tmp59 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v60 := args[0]
			_ = v60
			v61 := args[1]
			_ = v61
			tmp62 := checkDerefVar(glojure_DOT_core_str)
			tmp63 := lang.Apply(tmp62, []any{v60})
			tmp64 := lang.Apply(lang.WriteWriter, []any{v61, tmp63})
			_ = tmp64
			tmp65 := lang.Apply(lang.WriteWriter, []any{v61, "M"})
			return tmp65
		})
		tmp2.AddMethod(tmp58, tmp59)
		tmp60 := reflect.TypeOf((*lang.BigInt)(nil))
		var tmp61 lang.FnFunc
		tmp61 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v62 := args[0]
			_ = v62
			v63 := args[1]
			_ = v63
			tmp64 := checkDerefVar(glojure_DOT_core_str)
			tmp65 := lang.Apply(tmp64, []any{v62})
			tmp66 := lang.Apply(lang.WriteWriter, []any{v63, tmp65})
			_ = tmp66
			tmp67 := lang.Apply(lang.WriteWriter, []any{v63, "N"})
			return tmp67
		})
		tmp2.AddMethod(tmp60, tmp61)
		tmp62 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		var tmp63 lang.FnFunc
		tmp63 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v64 := args[0]
			_ = v64
			v65 := args[1]
			_ = v65
			tmp66 := checkDerefVar(glojure_DOT_core_print_meta)
			tmp67 := lang.Apply(tmp66, []any{v64, v65})
			_ = tmp67
			tmp68 := checkDerefVar(glojure_DOT_core_print_sequential)
			tmp69 := checkDerefVar(glojure_DOT_core_pr_on)
			tmp70 := lang.Apply(tmp68, []any{"(", tmp69, " ", ")", v64, v65})
			return tmp70
		})
		tmp2.AddMethod(tmp62, tmp63)
		tmp64 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp65 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp2.PreferMethod(tmp64, tmp65)
		tmp66 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		tmp67 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		tmp2.PreferMethod(tmp66, tmp67)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-object
	{
		tmp0 := lang.NewSymbol("print-object").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(115), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(115), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_print_tagged_object)
			tmp6 := checkDerefVar(glojure_DOT_core_str)
			tmp7 := lang.Apply(tmp6, []any{v3})
			tmp8 := lang.Apply(tmp5, []any{v3, tmp7, v4})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-prefix-map
	{
		tmp0 := lang.NewSymbol("print-prefix-map").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(243), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(243), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("prefix"), lang.NewSymbol("kvs"), lang.NewSymbol("print-one"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			tmp7 := checkDerefVar(glojure_DOT_core_print_sequential)
			tmp8 := checkDerefVar(glojure_DOT_core_str)
			tmp9 := lang.Apply(tmp8, []any{v3, "{"})
			var tmp10 lang.FnFunc
			tmp10 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v11 := args[0]
				_ = v11
				v12 := args[1]
				_ = v12
				var tmp13 any
				{ // let
					// let binding "vec__212"
					var v14 any = v11
					_ = v14
					// let binding "k"
					tmp15 := checkDerefVar(glojure_DOT_core_nth)
					tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
					var v17 any = tmp16
					_ = v17
					// let binding "v"
					tmp18 := checkDerefVar(glojure_DOT_core_nth)
					tmp19 := lang.Apply(tmp18, []any{v14, int64(1), nil})
					var v20 any = tmp19
					_ = v20
					tmp21 := lang.Apply(v5, []any{v17, v12})
					_ = tmp21
					tmp22 := lang.Apply(lang.AppendWriter, []any{v12, lang.NewChar(32)})
					_ = tmp22
					tmp23 := lang.Apply(v5, []any{v20, v12})
					tmp13 = tmp23
				} // end let
				return tmp13
			})
			tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(246), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(247), lang.NewKeyword("end-column"), int(107))
			tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp13 := lang.Apply(tmp7, []any{tmp9, tmp12, ", ", "}", v4, v6})
			return tmp13
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-sequential
	{
		tmp0 := lang.NewSymbol("print-sequential").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(46), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(46), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("begin"), lang.NewSymbol("print-one"), lang.NewSymbol("sep"), lang.NewSymbol("end"), lang.NewSymbol("sequence"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 6 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			v8 := args[5]
			_ = v8
			var tmp9 any
			{ // let
				tmp10 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
				tmp11 := checkDerefVar(glojure_DOT_core_hash_map)
				tmp12 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-level*"))
				var tmp13 any
				{ // let
					// let binding "and__0__auto__"
					tmp14 := checkDerefVar(glojure_DOT_core_not)
					tmp15 := checkDerefVar(glojure_DOT_core__STAR_print_dup_STAR_)
					tmp16 := lang.Apply(tmp14, []any{tmp15})
					var v17 any = tmp16
					_ = v17
					var tmp18 any
					if lang.IsTruthy(v17) {
						var tmp19 any
						{ // let
							// let binding "and__0__auto__"
							tmp20 := checkDerefVar(glojure_DOT_core__STAR_print_level_STAR_)
							var v21 any = tmp20
							_ = v21
							var tmp22 any
							if lang.IsTruthy(v21) {
								tmp23 := checkDerefVar(glojure_DOT_core_dec)
								tmp24 := checkDerefVar(glojure_DOT_core__STAR_print_level_STAR_)
								tmp25 := lang.Apply(tmp23, []any{tmp24})
								tmp22 = tmp25
							} else {
								tmp22 = v21
							}
							tmp19 = tmp22
						} // end let
						tmp18 = tmp19
					} else {
						tmp18 = v17
					}
					tmp13 = tmp18
				} // end let
				tmp14 := lang.Apply(tmp11, []any{tmp12, tmp13})
				tmp15 := lang.Apply(tmp10, []any{tmp14})
				_ = tmp15
				var tmp16 any
				func() {
					defer func() {
						tmp17 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
						tmp18 := lang.Apply(tmp17, nil)
						_ = tmp18
					}()
					var tmp19 any
					var tmp20 any
					{ // let
						// let binding "and__0__auto__"
						tmp21 := checkDerefVar(glojure_DOT_core__STAR_print_level_STAR_)
						var v22 any = tmp21
						_ = v22
						var tmp23 any
						if lang.IsTruthy(v22) {
							tmp24 := checkDerefVar(glojure_DOT_core_neg_QMARK_)
							tmp25 := checkDerefVar(glojure_DOT_core__STAR_print_level_STAR_)
							tmp26 := lang.Apply(tmp24, []any{tmp25})
							tmp23 = tmp26
						} else {
							tmp23 = v22
						}
						tmp20 = tmp23
					} // end let
					if lang.IsTruthy(tmp20) {
						tmp21 := lang.Apply(lang.WriteWriter, []any{v8, "#"})
						tmp19 = tmp21
					} else {
						tmp22 := lang.Apply(lang.WriteWriter, []any{v8, v3})
						_ = tmp22
						var tmp23 any
						{ // let
							// let binding "temp__0__auto__"
							tmp24 := checkDerefVar(glojure_DOT_core_seq)
							tmp25 := lang.Apply(tmp24, []any{v7})
							var v26 any = tmp25
							_ = v26
							var tmp27 any
							if lang.IsTruthy(v26) {
								var tmp28 any
								{ // let
									// let binding "xs"
									var v29 any = v26
									_ = v29
									var tmp30 any
									var tmp31 any
									{ // let
										// let binding "and__0__auto__"
										tmp32 := checkDerefVar(glojure_DOT_core_not)
										tmp33 := checkDerefVar(glojure_DOT_core__STAR_print_dup_STAR_)
										tmp34 := lang.Apply(tmp32, []any{tmp33})
										var v35 any = tmp34
										_ = v35
										var tmp36 any
										if lang.IsTruthy(v35) {
											tmp37 := checkDerefVar(glojure_DOT_core__STAR_print_length_STAR_)
											tmp36 = tmp37
										} else {
											tmp36 = v35
										}
										tmp31 = tmp36
									} // end let
									if lang.IsTruthy(tmp31) {
										var tmp32 any
										{ // let
											// let binding "G__194"
											var v33 any = v29
											_ = v33
											// let binding "vec__195"
											var v34 any = v33
											_ = v34
											// let binding "seq__196"
											tmp35 := checkDerefVar(glojure_DOT_core_seq)
											tmp36 := lang.Apply(tmp35, []any{v34})
											var v37 any = tmp36
											_ = v37
											// let binding "first__197"
											tmp38 := checkDerefVar(glojure_DOT_core_first)
											tmp39 := lang.Apply(tmp38, []any{v37})
											var v40 any = tmp39
											_ = v40
											// let binding "seq__196"
											tmp41 := checkDerefVar(glojure_DOT_core_next)
											tmp42 := lang.Apply(tmp41, []any{v37})
											var v43 any = tmp42
											_ = v43
											// let binding "x"
											var v44 any = v40
											_ = v44
											// let binding "xs"
											var v45 any = v43
											_ = v45
											// let binding "print-length"
											tmp46 := checkDerefVar(glojure_DOT_core__STAR_print_length_STAR_)
											var v47 any = tmp46
											_ = v47
											var tmp48 any
											{ // let
												// let binding "G__194"
												var v49 any = v33
												_ = v49
												// let binding "print-length"
												var v50 any = v47
												_ = v50
												for {
													var tmp51 any
													{ // let
														// let binding "vec__198"
														var v52 any = v49
														_ = v52
														// let binding "seq__199"
														tmp53 := checkDerefVar(glojure_DOT_core_seq)
														tmp54 := lang.Apply(tmp53, []any{v52})
														var v55 any = tmp54
														_ = v55
														// let binding "first__200"
														tmp56 := checkDerefVar(glojure_DOT_core_first)
														tmp57 := lang.Apply(tmp56, []any{v55})
														var v58 any = tmp57
														_ = v58
														// let binding "seq__199"
														tmp59 := checkDerefVar(glojure_DOT_core_next)
														tmp60 := lang.Apply(tmp59, []any{v55})
														var v61 any = tmp60
														_ = v61
														// let binding "x"
														var v62 any = v58
														_ = v62
														// let binding "xs"
														var v63 any = v61
														_ = v63
														// let binding "print-length"
														var v64 any = v50
														_ = v64
														var tmp65 any
														tmp66 := checkDerefVar(glojure_DOT_core_zero_QMARK_)
														tmp67 := lang.Apply(tmp66, []any{v64})
														if lang.IsTruthy(tmp67) {
															tmp68 := lang.Apply(lang.WriteWriter, []any{v8, "..."})
															tmp65 = tmp68
														} else {
															tmp69 := lang.Apply(v4, []any{v62, v8})
															_ = tmp69
															var tmp70 any
															if lang.IsTruthy(v63) {
																tmp71 := lang.Apply(lang.WriteWriter, []any{v8, v5})
																_ = tmp71
																var tmp72 any = v63
																tmp74 := checkDerefVar(glojure_DOT_core_dec)
																tmp75 := lang.Apply(tmp74, []any{v64})
																var tmp73 any = tmp75
																v49 = tmp72
																v50 = tmp73
																continue
															} else {
															}
															tmp65 = tmp70
														}
														tmp51 = tmp65
													} // end let
													tmp48 = tmp51
													break
												}
											} // end let
											tmp32 = tmp48
										} // end let
										tmp30 = tmp32
									} else {
										var tmp33 any
										{ // let
											// let binding "G__204"
											var v34 any = v29
											_ = v34
											// let binding "vec__205"
											var v35 any = v34
											_ = v35
											// let binding "seq__206"
											tmp36 := checkDerefVar(glojure_DOT_core_seq)
											tmp37 := lang.Apply(tmp36, []any{v35})
											var v38 any = tmp37
											_ = v38
											// let binding "first__207"
											tmp39 := checkDerefVar(glojure_DOT_core_first)
											tmp40 := lang.Apply(tmp39, []any{v38})
											var v41 any = tmp40
											_ = v41
											// let binding "seq__206"
											tmp42 := checkDerefVar(glojure_DOT_core_next)
											tmp43 := lang.Apply(tmp42, []any{v38})
											var v44 any = tmp43
											_ = v44
											// let binding "x"
											var v45 any = v41
											_ = v45
											// let binding "xs"
											var v46 any = v44
											_ = v46
											var tmp47 any
											{ // let
												// let binding "G__204"
												var v48 any = v34
												_ = v48
												for {
													var tmp49 any
													{ // let
														// let binding "vec__208"
														var v50 any = v48
														_ = v50
														// let binding "seq__209"
														tmp51 := checkDerefVar(glojure_DOT_core_seq)
														tmp52 := lang.Apply(tmp51, []any{v50})
														var v53 any = tmp52
														_ = v53
														// let binding "first__210"
														tmp54 := checkDerefVar(glojure_DOT_core_first)
														tmp55 := lang.Apply(tmp54, []any{v53})
														var v56 any = tmp55
														_ = v56
														// let binding "seq__209"
														tmp57 := checkDerefVar(glojure_DOT_core_next)
														tmp58 := lang.Apply(tmp57, []any{v53})
														var v59 any = tmp58
														_ = v59
														// let binding "x"
														var v60 any = v56
														_ = v60
														// let binding "xs"
														var v61 any = v59
														_ = v61
														tmp62 := lang.Apply(v4, []any{v60, v8})
														_ = tmp62
														var tmp63 any
														if lang.IsTruthy(v61) {
															tmp64 := lang.Apply(lang.WriteWriter, []any{v8, v5})
															_ = tmp64
															var tmp65 any = v61
															v48 = tmp65
															continue
														} else {
														}
														tmp49 = tmp63
													} // end let
													tmp47 = tmp49
													break
												}
											} // end let
											tmp33 = tmp47
										} // end let
										tmp30 = tmp33
									}
									tmp28 = tmp30
								} // end let
								tmp27 = tmp28
							} else {
							}
							tmp23 = tmp27
						} // end let
						_ = tmp23
						tmp24 := lang.Apply(lang.WriteWriter, []any{v8, v6})
						tmp19 = tmp24
					}
					tmp16 = tmp19
				}()
				tmp9 = tmp16
			} // end let
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-simple
	{
		tmp0 := lang.NewSymbol("print-simple").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(81), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(81), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_print_meta)
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			_ = tmp6
			tmp7 := checkDerefVar(glojure_DOT_core_str)
			tmp8 := lang.Apply(tmp7, []any{v3})
			tmp9 := lang.Apply(lang.WriteWriter, []any{v4, tmp8})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("print-str").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("xs"))), lang.NewKeyword("doc"), "print to a string, returning it", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4776), lang.NewKeyword("end-line"), int(4776))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
						tmp9 := checkDerefVar(glojure_DOT_core_hash_map)
						tmp10 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*out*"))
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(glojure_DOT_core_apply)
							tmp17 := checkDerefVar(glojure_DOT_core_print)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v4})
							_ = tmp18
							tmp19 := checkDerefVar(glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-tagged-object
	{
		tmp0 := lang.NewSymbol("print-tagged-object").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(102), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(102), lang.NewKeyword("end-column"), int(26), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("rep"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			tmp7 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp8 := reflect.TypeOf((*lang.IMeta)(nil)).Elem()
			tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
			if lang.IsTruthy(tmp9) {
				tmp10 := checkDerefVar(glojure_DOT_core_print_meta)
				tmp11 := lang.Apply(tmp10, []any{v3, v5})
				tmp6 = tmp11
			} else {
			}
			_ = tmp6
			tmp12 := lang.Apply(lang.WriteWriter, []any{v5, "#object["})
			_ = tmp12
			var tmp13 any
			{ // let
				// let binding "c"
				tmp14 := checkDerefVar(glojure_DOT_core_class)
				tmp15 := lang.Apply(tmp14, []any{v3})
				var v16 any = tmp15
				_ = v16
				var tmp17 any
				if lang.IsTruthy(false) {
					tmp18 := checkDerefVar(glojure_DOT_core_print_method)
					tmp19, ok := lang.FieldOrMethod(v16, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v16, "Name")))
					}
					var tmp20 any
					switch reflect.TypeOf(tmp19).Kind() {
					case reflect.Func:
						tmp20 = lang.Apply(tmp19, nil)
					default:
						tmp20 = tmp19
					}
					tmp21 := lang.Apply(tmp18, []any{tmp20, v5})
					tmp17 = tmp21
				} else {
					tmp22, ok := lang.FieldOrMethod(v16, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v16, "Name")))
					}
					var tmp23 any
					switch reflect.TypeOf(tmp22).Kind() {
					case reflect.Func:
						tmp23 = lang.Apply(tmp22, nil)
					default:
						tmp23 = tmp22
					}
					tmp24 := lang.Apply(lang.WriteWriter, []any{v5, tmp23})
					tmp17 = tmp24
				}
				tmp13 = tmp17
			} // end let
			_ = tmp13
			tmp14 := lang.Apply(lang.WriteWriter, []any{v5, " "})
			_ = tmp14
			tmp15 := checkDerefVar(glojure_DOT_core_format)
			tmp16 := lang.Apply(lang.IdentityHash, []any{v3})
			tmp17 := lang.Apply(tmp15, []any{"0x%x ", tmp16})
			tmp18 := lang.Apply(lang.WriteWriter, []any{v5, tmp17})
			_ = tmp18
			tmp19 := checkDerefVar(glojure_DOT_core_print_method)
			tmp20 := lang.Apply(tmp19, []any{v4, v5})
			_ = tmp20
			tmp21 := lang.Apply(lang.WriteWriter, []any{v5, "]"})
			return tmp21
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-throwable
	{
		tmp0 := lang.NewSymbol("print-throwable").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(478), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(478), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(lang.WriteWriter, []any{v4, "#error {\n :cause "})
			_ = tmp5
			var tmp6 any
			{ // let
				// let binding "map__253"
				tmp7 := checkDerefVar(glojure_DOT_core_Throwable__GT_map)
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				// let binding "map__253"
				var tmp10 any
				tmp11 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
				tmp12 := lang.Apply(tmp11, []any{v9})
				if lang.IsTruthy(tmp12) {
					var tmp13 any
					tmp14 := checkDerefVar(glojure_DOT_core_next)
					tmp15 := lang.Apply(tmp14, []any{v9})
					if lang.IsTruthy(tmp15) {
						tmp16 := checkDerefVar(glojure_DOT_core_to_array)
						tmp17 := lang.Apply(tmp16, []any{v9})
						tmp18 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp17})
						tmp13 = tmp18
					} else {
						var tmp19 any
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := lang.Apply(tmp20, []any{v9})
						if lang.IsTruthy(tmp21) {
							tmp22 := checkDerefVar(glojure_DOT_core_first)
							tmp23 := lang.Apply(tmp22, []any{v9})
							tmp19 = tmp23
						} else {
						}
						tmp13 = tmp19
					}
					tmp10 = tmp13
				} else {
					tmp10 = v9
				}
				var v24 any = tmp10
				_ = v24
				// let binding "cause"
				tmp25 := checkDerefVar(glojure_DOT_core_get)
				tmp26 := lang.Apply(tmp25, []any{v24, lang.NewKeyword("cause")})
				var v27 any = tmp26
				_ = v27
				// let binding "data"
				tmp28 := checkDerefVar(glojure_DOT_core_get)
				tmp29 := lang.Apply(tmp28, []any{v24, lang.NewKeyword("data")})
				var v30 any = tmp29
				_ = v30
				// let binding "via"
				tmp31 := checkDerefVar(glojure_DOT_core_get)
				tmp32 := lang.Apply(tmp31, []any{v24, lang.NewKeyword("via")})
				var v33 any = tmp32
				_ = v33
				// let binding "trace"
				tmp34 := checkDerefVar(glojure_DOT_core_get)
				tmp35 := lang.Apply(tmp34, []any{v24, lang.NewKeyword("trace")})
				var v36 any = tmp35
				_ = v36
				// let binding "print-via"
				var tmp37 lang.FnFunc
				tmp37 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v38 := args[0]
					_ = v38
					tmp39 := lang.Apply(lang.WriteWriter, []any{v4, "{:type "})
					_ = tmp39
					tmp40 := checkDerefVar(glojure_DOT_core_print_method)
					tmp41 := lang.Apply(lang.NewKeyword("type"), []any{v38})
					tmp42 := lang.Apply(tmp40, []any{tmp41, v4})
					_ = tmp42
					tmp43 := lang.Apply(lang.WriteWriter, []any{v4, "\n   :message "})
					_ = tmp43
					tmp44 := checkDerefVar(glojure_DOT_core_print_method)
					tmp45 := lang.Apply(lang.NewKeyword("message"), []any{v38})
					tmp46 := lang.Apply(tmp44, []any{tmp45, v4})
					_ = tmp46
					var tmp47 any
					{ // let
						// let binding "temp__0__auto__"
						tmp48 := lang.Apply(lang.NewKeyword("data"), []any{v38})
						var v49 any = tmp48
						_ = v49
						var tmp50 any
						if lang.IsTruthy(v49) {
							var tmp51 any
							{ // let
								// let binding "data"
								var v52 any = v49
								_ = v52
								tmp53 := lang.Apply(lang.WriteWriter, []any{v4, "\n   :data "})
								_ = tmp53
								tmp54 := checkDerefVar(glojure_DOT_core_print_method)
								tmp55 := lang.Apply(tmp54, []any{v52, v4})
								tmp51 = tmp55
							} // end let
							tmp50 = tmp51
						} else {
						}
						tmp47 = tmp50
					} // end let
					_ = tmp47
					var tmp48 any
					{ // let
						// let binding "temp__0__auto__"
						tmp49 := lang.Apply(lang.NewKeyword("at"), []any{v38})
						var v50 any = tmp49
						_ = v50
						var tmp51 any
						if lang.IsTruthy(v50) {
							var tmp52 any
							{ // let
								// let binding "at"
								var v53 any = v50
								_ = v53
								tmp54 := lang.Apply(lang.WriteWriter, []any{v4, "\n   :at "})
								_ = tmp54
								tmp55 := checkDerefVar(glojure_DOT_core_print_method)
								tmp56 := lang.Apply(lang.NewKeyword("at"), []any{v38})
								tmp57 := lang.Apply(tmp55, []any{tmp56, v4})
								tmp52 = tmp57
							} // end let
							tmp51 = tmp52
						} else {
						}
						tmp48 = tmp51
					} // end let
					_ = tmp48
					tmp49 := lang.Apply(lang.WriteWriter, []any{v4, "}"})
					return tmp49
				})
				tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(481), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(491), lang.NewKeyword("end-column"), int(73))
				tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v40 any = tmp39
				_ = v40
				tmp41 := checkDerefVar(glojure_DOT_core_print_method)
				tmp42 := lang.Apply(tmp41, []any{v27, v4})
				_ = tmp42
				var tmp43 any
				if lang.IsTruthy(v30) {
					tmp44 := lang.Apply(lang.WriteWriter, []any{v4, "\n :data "})
					_ = tmp44
					tmp45 := checkDerefVar(glojure_DOT_core_print_method)
					tmp46 := lang.Apply(tmp45, []any{v30, v4})
					tmp43 = tmp46
				} else {
				}
				_ = tmp43
				var tmp47 any
				if lang.IsTruthy(v33) {
					tmp48 := lang.Apply(lang.WriteWriter, []any{v4, "\n :via\n ["})
					_ = tmp48
					var tmp49 any
					{ // let
						// let binding "temp__0__auto__"
						tmp50 := checkDerefVar(glojure_DOT_core_first)
						tmp51 := lang.Apply(tmp50, []any{v33})
						var v52 any = tmp51
						_ = v52
						var tmp53 any
						if lang.IsTruthy(v52) {
							var tmp54 any
							{ // let
								// let binding "fv"
								var v55 any = v52
								_ = v55
								tmp56 := lang.Apply(v40, []any{v55})
								_ = tmp56
								var tmp57 any
								{ // let
									// let binding "seq_254"
									tmp58 := checkDerefVar(glojure_DOT_core_seq)
									tmp59 := checkDerefVar(glojure_DOT_core_rest)
									tmp60 := lang.Apply(tmp59, []any{v33})
									tmp61 := lang.Apply(tmp58, []any{tmp60})
									var v62 any = tmp61
									_ = v62
									// let binding "chunk_255"
									var v63 any = nil
									_ = v63
									// let binding "count_256"
									var v64 any = int64(0)
									_ = v64
									// let binding "i_257"
									var v65 any = int64(0)
									_ = v65
									for {
										var tmp66 any
										tmp67 := checkDerefVar(glojure_DOT_core__LT_)
										tmp68 := lang.Apply(tmp67, []any{v65, v64})
										if lang.IsTruthy(tmp68) {
											var tmp69 any
											{ // let
												// let binding "v"
												tmp70, _ := lang.FieldOrMethod(v63, "nth")
												if reflect.TypeOf(tmp70).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
												}
												tmp71 := lang.Apply(tmp70, []any{v65})
												var v72 any = tmp71
												_ = v72
												tmp73 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
												_ = tmp73
												tmp74 := lang.Apply(v40, []any{v72})
												_ = tmp74
												var tmp75 any = v62
												var tmp76 any = v63
												var tmp77 any = v64
												tmp79 := checkDerefVar(glojure_DOT_core_unchecked_inc)
												tmp80 := lang.Apply(tmp79, []any{v65})
												var tmp78 any = tmp80
												v62 = tmp75
												v63 = tmp76
												v64 = tmp77
												v65 = tmp78
												continue
											} // end let
											tmp66 = tmp69
										} else {
											var tmp70 any
											{ // let
												// let binding "temp__0__auto__"
												tmp71 := checkDerefVar(glojure_DOT_core_seq)
												tmp72 := lang.Apply(tmp71, []any{v62})
												var v73 any = tmp72
												_ = v73
												var tmp74 any
												if lang.IsTruthy(v73) {
													var tmp75 any
													{ // let
														// let binding "seq_254"
														var v76 any = v73
														_ = v76
														var tmp77 any
														tmp78 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
														tmp79 := lang.Apply(tmp78, []any{v76})
														if lang.IsTruthy(tmp79) {
															var tmp80 any
															{ // let
																// let binding "c__0__auto__"
																tmp81 := checkDerefVar(glojure_DOT_core_chunk_first)
																tmp82 := lang.Apply(tmp81, []any{v76})
																var v83 any = tmp82
																_ = v83
																tmp85 := checkDerefVar(glojure_DOT_core_chunk_rest)
																tmp86 := lang.Apply(tmp85, []any{v76})
																var tmp84 any = tmp86
																var tmp87 any = v83
																tmp89 := checkDerefVar(glojure_DOT_core_int)
																tmp90 := checkDerefVar(glojure_DOT_core_count)
																tmp91 := lang.Apply(tmp90, []any{v83})
																tmp92 := lang.Apply(tmp89, []any{tmp91})
																var tmp88 any = tmp92
																tmp94 := checkDerefVar(glojure_DOT_core_int)
																tmp95 := lang.Apply(tmp94, []any{int64(0)})
																var tmp93 any = tmp95
																v62 = tmp84
																v63 = tmp87
																v64 = tmp88
																v65 = tmp93
																continue
															} // end let
															tmp77 = tmp80
														} else {
															var tmp81 any
															{ // let
																// let binding "v"
																tmp82 := checkDerefVar(glojure_DOT_core_first)
																tmp83 := lang.Apply(tmp82, []any{v76})
																var v84 any = tmp83
																_ = v84
																tmp85 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
																_ = tmp85
																tmp86 := lang.Apply(v40, []any{v84})
																_ = tmp86
																tmp88 := checkDerefVar(glojure_DOT_core_next)
																tmp89 := lang.Apply(tmp88, []any{v76})
																var tmp87 any = tmp89
																var tmp90 any = nil
																var tmp91 any = int64(0)
																var tmp92 any = int64(0)
																v62 = tmp87
																v63 = tmp90
																v64 = tmp91
																v65 = tmp92
																continue
															} // end let
															tmp77 = tmp81
														}
														tmp75 = tmp77
													} // end let
													tmp74 = tmp75
												} else {
												}
												tmp70 = tmp74
											} // end let
											tmp66 = tmp70
										}
										tmp57 = tmp66
										break
									}
								} // end let
								tmp54 = tmp57
							} // end let
							tmp53 = tmp54
						} else {
						}
						tmp49 = tmp53
					} // end let
					_ = tmp49
					tmp50 := lang.Apply(lang.WriteWriter, []any{v4, "]"})
					tmp47 = tmp50
				} else {
				}
				_ = tmp47
				var tmp51 any
				if lang.IsTruthy(v36) {
					tmp52 := lang.Apply(lang.WriteWriter, []any{v4, "\n :trace\n ["})
					_ = tmp52
					var tmp53 any
					{ // let
						// let binding "temp__0__auto__"
						tmp54 := checkDerefVar(glojure_DOT_core_first)
						tmp55 := lang.Apply(tmp54, []any{v36})
						var v56 any = tmp55
						_ = v56
						var tmp57 any
						if lang.IsTruthy(v56) {
							var tmp58 any
							{ // let
								// let binding "ft"
								var v59 any = v56
								_ = v59
								tmp60 := checkDerefVar(glojure_DOT_core_print_method)
								tmp61 := lang.Apply(tmp60, []any{v59, v4})
								_ = tmp61
								var tmp62 any
								{ // let
									// let binding "seq_258"
									tmp63 := checkDerefVar(glojure_DOT_core_seq)
									tmp64 := checkDerefVar(glojure_DOT_core_rest)
									tmp65 := lang.Apply(tmp64, []any{v36})
									tmp66 := lang.Apply(tmp63, []any{tmp65})
									var v67 any = tmp66
									_ = v67
									// let binding "chunk_259"
									var v68 any = nil
									_ = v68
									// let binding "count_260"
									var v69 any = int64(0)
									_ = v69
									// let binding "i_261"
									var v70 any = int64(0)
									_ = v70
									for {
										var tmp71 any
										tmp72 := checkDerefVar(glojure_DOT_core__LT_)
										tmp73 := lang.Apply(tmp72, []any{v70, v69})
										if lang.IsTruthy(tmp73) {
											var tmp74 any
											{ // let
												// let binding "t"
												tmp75, _ := lang.FieldOrMethod(v68, "nth")
												if reflect.TypeOf(tmp75).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
												}
												tmp76 := lang.Apply(tmp75, []any{v70})
												var v77 any = tmp76
												_ = v77
												tmp78 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
												_ = tmp78
												tmp79 := checkDerefVar(glojure_DOT_core_print_method)
												tmp80 := lang.Apply(tmp79, []any{v77, v4})
												_ = tmp80
												var tmp81 any = v67
												var tmp82 any = v68
												var tmp83 any = v69
												tmp85 := checkDerefVar(glojure_DOT_core_unchecked_inc)
												tmp86 := lang.Apply(tmp85, []any{v70})
												var tmp84 any = tmp86
												v67 = tmp81
												v68 = tmp82
												v69 = tmp83
												v70 = tmp84
												continue
											} // end let
											tmp71 = tmp74
										} else {
											var tmp75 any
											{ // let
												// let binding "temp__0__auto__"
												tmp76 := checkDerefVar(glojure_DOT_core_seq)
												tmp77 := lang.Apply(tmp76, []any{v67})
												var v78 any = tmp77
												_ = v78
												var tmp79 any
												if lang.IsTruthy(v78) {
													var tmp80 any
													{ // let
														// let binding "seq_258"
														var v81 any = v78
														_ = v81
														var tmp82 any
														tmp83 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
														tmp84 := lang.Apply(tmp83, []any{v81})
														if lang.IsTruthy(tmp84) {
															var tmp85 any
															{ // let
																// let binding "c__0__auto__"
																tmp86 := checkDerefVar(glojure_DOT_core_chunk_first)
																tmp87 := lang.Apply(tmp86, []any{v81})
																var v88 any = tmp87
																_ = v88
																tmp90 := checkDerefVar(glojure_DOT_core_chunk_rest)
																tmp91 := lang.Apply(tmp90, []any{v81})
																var tmp89 any = tmp91
																var tmp92 any = v88
																tmp94 := checkDerefVar(glojure_DOT_core_int)
																tmp95 := checkDerefVar(glojure_DOT_core_count)
																tmp96 := lang.Apply(tmp95, []any{v88})
																tmp97 := lang.Apply(tmp94, []any{tmp96})
																var tmp93 any = tmp97
																tmp99 := checkDerefVar(glojure_DOT_core_int)
																tmp100 := lang.Apply(tmp99, []any{int64(0)})
																var tmp98 any = tmp100
																v67 = tmp89
																v68 = tmp92
																v69 = tmp93
																v70 = tmp98
																continue
															} // end let
															tmp82 = tmp85
														} else {
															var tmp86 any
															{ // let
																// let binding "t"
																tmp87 := checkDerefVar(glojure_DOT_core_first)
																tmp88 := lang.Apply(tmp87, []any{v81})
																var v89 any = tmp88
																_ = v89
																tmp90 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
																_ = tmp90
																tmp91 := checkDerefVar(glojure_DOT_core_print_method)
																tmp92 := lang.Apply(tmp91, []any{v89, v4})
																_ = tmp92
																tmp94 := checkDerefVar(glojure_DOT_core_next)
																tmp95 := lang.Apply(tmp94, []any{v81})
																var tmp93 any = tmp95
																var tmp96 any = nil
																var tmp97 any = int64(0)
																var tmp98 any = int64(0)
																v67 = tmp93
																v68 = tmp96
																v69 = tmp97
																v70 = tmp98
																continue
															} // end let
															tmp82 = tmp86
														}
														tmp80 = tmp82
													} // end let
													tmp79 = tmp80
												} else {
												}
												tmp75 = tmp79
											} // end let
											tmp71 = tmp75
										}
										tmp62 = tmp71
										break
									}
								} // end let
								tmp58 = tmp62
							} // end let
							tmp57 = tmp58
						} else {
						}
						tmp53 = tmp57
					} // end let
					_ = tmp53
					tmp54 := lang.Apply(lang.WriteWriter, []any{v4, "]"})
					tmp51 = tmp54
				} else {
				}
				tmp6 = tmp51
			} // end let
			_ = tmp6
			tmp7 := lang.Apply(lang.WriteWriter, []any{v4, "}"})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// printf
	{
		tmp0 := lang.NewSymbol("printf").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("fmt"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Prints formatted output, as per format", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5725), lang.NewKeyword("end-line"), int(5725))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_print)
				tmp6 := checkDerefVar(glojure_DOT_core_apply)
				tmp7 := checkDerefVar(glojure_DOT_core_format)
				tmp8 := lang.Apply(tmp6, []any{tmp7, v3, v4})
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// println
	{
		tmp0 := lang.NewSymbol("println").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Same as print followed by (newline)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3734), lang.NewKeyword("end-line"), int(3734))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					tmp5 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
					tmp6 := checkDerefVar(glojure_DOT_core_hash_map)
					tmp7 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-readably*"))
					tmp8 := lang.Apply(tmp6, []any{tmp7, nil})
					tmp9 := lang.Apply(tmp5, []any{tmp8})
					_ = tmp9
					var tmp10 any
					func() {
						defer func() {
							tmp11 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
							tmp12 := lang.Apply(tmp11, nil)
							_ = tmp12
						}()
						tmp13 := checkDerefVar(glojure_DOT_core_apply)
						tmp14 := checkDerefVar(glojure_DOT_core_prn)
						tmp15 := lang.Apply(tmp13, []any{tmp14, v3})
						tmp10 = tmp15
					}()
					tmp4 = tmp10
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// println-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("println-str").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("xs"))), lang.NewKeyword("doc"), "println to a string, returning it", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4785), lang.NewKeyword("end-line"), int(4785))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
						tmp9 := checkDerefVar(glojure_DOT_core_hash_map)
						tmp10 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*out*"))
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(glojure_DOT_core_apply)
							tmp17 := checkDerefVar(glojure_DOT_core_println)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v4})
							_ = tmp18
							tmp19 := checkDerefVar(glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prn
	{
		tmp0 := lang.NewSymbol("prn").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Same as pr followed by (newline). Observes *flush-on-newline*", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3715), lang.NewKeyword("end-line"), int(3715))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_apply)
				tmp5 := checkDerefVar(glojure_DOT_core_pr)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				_ = tmp6
				tmp7 := checkDerefVar(glojure_DOT_core_newline)
				tmp8 := lang.Apply(tmp7, nil)
				_ = tmp8
				var tmp9 any
				tmp10 := checkDerefVar(glojure_DOT_core__STAR_flush_on_newline_STAR_)
				if lang.IsTruthy(tmp10) {
					tmp11 := checkDerefVar(glojure_DOT_core_flush)
					tmp12 := lang.Apply(tmp11, nil)
					tmp9 = tmp12
				} else {
				}
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prn-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("prn-str").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("xs"))), lang.NewKeyword("doc"), "prn to a string, returning it", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4767), lang.NewKeyword("end-line"), int(4767))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
						tmp9 := checkDerefVar(glojure_DOT_core_hash_map)
						tmp10 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*out*"))
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(glojure_DOT_core_apply)
							tmp17 := checkDerefVar(glojure_DOT_core_prn)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v4})
							_ = tmp18
							tmp19 := checkDerefVar(glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// promise
	{
		tmp0 := lang.NewSymbol("promise").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Returns a promise object that can be read with deref/@, and set,\n  once only, with deliver. Calls to deref/@ prior to delivery will\n  block, unless the variant of deref with timeout is used. All\n  subsequent derefs will return the same delivered value without\n  blocking. See also - realized?.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7078), lang.NewKeyword("end-line"), int(7078))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			var tmp3 any
			{ // let
				// let binding "d"
				tmp4 := lang.Apply(nil, []any{int64(1)})
				var v5 any = tmp4
				_ = v5
				// let binding "v"
				tmp6 := checkDerefVar(glojure_DOT_core_atom)
				tmp7 := lang.Apply(tmp6, []any{v5})
				var v8 any = tmp7
				_ = v8
				tmp9 := reflect.TypeOf((*lang.IDeref)(nil)).Elem()
				tmp10 := checkDerefVar(glojure_DOT_core_deref)
				tmp11 := lang.NewVector(nil)
				tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7091), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(7091), lang.NewKeyword("end-column"), int(17))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14, ok := lang.FieldOrMethod(v5, "await")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "await")))
				}
				var tmp15 any
				switch reflect.TypeOf(tmp14).Kind() {
				case reflect.Func:
					tmp15 = lang.Apply(tmp14, nil)
				default:
					tmp15 = tmp14
				}
				tmp16 := checkDerefVar(glojure_DOT_core_deref)
				tmp17 := lang.Apply(tmp16, []any{v8})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp15, tmp17})
				tmp19 := reflect.TypeOf((*lang.IBlockingDeref)(nil)).Elem()
				tmp20 := checkDerefVar(glojure_DOT_core_deref)
				tmp21 := lang.NewVector(nil, nil, nil)
				tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7094), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(7094), lang.NewKeyword("end-column"), int(34))
				tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp24 any
				tmp25, _ := lang.FieldOrMethod(v5, "await")
				if reflect.TypeOf(tmp25).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
				}
				tmp26 := lang.Apply(tmp25, []any{nil, time10.Millisecond})
				if lang.IsTruthy(tmp26) {
					tmp27 := checkDerefVar(glojure_DOT_core_deref)
					tmp28 := lang.Apply(tmp27, []any{v8})
					tmp24 = tmp28
				} else {
				}
				tmp29 := lang.Apply(tmp20, []any{tmp23, tmp24})
				tmp30 := reflect.TypeOf((*lang.IPending)(nil)).Elem()
				tmp31 := lang.NewVector(nil)
				tmp32 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7099), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(7099), lang.NewKeyword("end-column"), int(24))
				tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp34 := checkDerefVar(glojure_DOT_core_zero_QMARK_)
				tmp35, ok := lang.FieldOrMethod(v5, "getCount")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "getCount")))
				}
				var tmp36 any
				switch reflect.TypeOf(tmp35).Kind() {
				case reflect.Func:
					tmp36 = lang.Apply(tmp35, nil)
				default:
					tmp36 = tmp35
				}
				tmp37 := lang.Apply(tmp34, []any{tmp36})
				tmp38 := lang.Apply(nil, []any{tmp33, tmp37})
				tmp39 := lang.NewVector(nil, nil)
				tmp40 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7103), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(7103), lang.NewKeyword("end-column"), int(14))
				tmp41, err := lang.WithMeta(tmp39, tmp40.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp42 any
				var tmp43 any
				{ // let
					// let binding "and__0__auto__"
					tmp44 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
					tmp45, ok := lang.FieldOrMethod(v5, "getCount")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "getCount")))
					}
					var tmp46 any
					switch reflect.TypeOf(tmp45).Kind() {
					case reflect.Func:
						tmp46 = lang.Apply(tmp45, nil)
					default:
						tmp46 = tmp45
					}
					tmp47 := lang.Apply(tmp44, []any{tmp46})
					var v48 any = tmp47
					_ = v48
					var tmp49 any
					if lang.IsTruthy(v48) {
						tmp50 := checkDerefVar(glojure_DOT_core_compare_and_set_BANG_)
						tmp51 := lang.Apply(tmp50, []any{v8, v5, nil})
						tmp49 = tmp51
					} else {
						tmp49 = v48
					}
					tmp43 = tmp49
				} // end let
				if lang.IsTruthy(tmp43) {
					tmp44, ok := lang.FieldOrMethod(v5, "countDown")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "countDown")))
					}
					var tmp45 any
					switch reflect.TypeOf(tmp44).Kind() {
					case reflect.Func:
						tmp45 = lang.Apply(tmp44, nil)
					default:
						tmp45 = tmp44
					}
					_ = tmp45
				} else {
				}
				tmp46 := lang.Apply(nil, []any{tmp41, tmp42})
				tmp47 := lang.Apply(nil, []any{tmp9, tmp18, tmp19, tmp29, tmp30, tmp38, nil, tmp46})
				tmp3 = tmp47
			} // end let
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// protocol?
	{
		tmp0 := lang.NewSymbol("protocol?").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(110), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(110), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("maybe-p"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp6 := reflect.TypeOf((*lang.IAtom)(nil)).Elem()
			tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(glojure_DOT_core_boolean)
				tmp9 := checkDerefVar(glojure_DOT_core_deref)
				tmp10 := lang.Apply(tmp9, []any{v3})
				tmp11 := lang.Apply(lang.NewKeyword("on-interface"), []any{tmp10})
				tmp12 := lang.Apply(tmp8, []any{tmp11})
				tmp4 = tmp12
			} else {
				tmp4 = false
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// push-thread-bindings
	{
		tmp0 := lang.NewSymbol("push-thread-bindings").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"))), lang.NewKeyword("doc"), "WARNING: This is a low-level function. Prefer high-level macros like\n  binding where ever possible.\n\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\n  the current thread. Each call *MUST* be accompanied by a matching call to\n  pop-thread-bindings wrapped in a try-finally!\n  \n      (push-thread-bindings bindings)\n      (try\n        ...\n        (finally\n          (pop-thread-bindings)))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(26), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1911), lang.NewKeyword("end-line"), int(1911))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.PushThreadBindings, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pvalues
	{
		tmp0 := lang.NewSymbol("pvalues").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("exprs"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the values of the exprs, which are\n  evaluated in parallel", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7063), lang.NewKeyword("end-line"), int(7063))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_concat)
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("glojure.core/pcalls")})
				tmp10 := checkDerefVar(glojure_DOT_core_map)
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v12 := args[0]
					_ = v12
					tmp13 := checkDerefVar(glojure_DOT_core_list)
					tmp14 := lang.NewVector()
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7069), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(7069), lang.NewKeyword("end-column"), int(31))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/fn"), tmp16, v12})
					return tmp17
				})
				tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7069), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(7069), lang.NewKeyword("end-column"), int(34))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.Apply(tmp10, []any{tmp13, v5})
				tmp15 := lang.Apply(tmp7, []any{tmp9, tmp14})
				tmp16 := lang.Apply(tmp6, []any{tmp15})
				return tmp16
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-ident?
	{
		tmp0 := lang.NewSymbol("qualified-ident?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a symbol or keyword with a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1618), lang.NewKeyword("end-line"), int(1618))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_boolean)
			var tmp5 any
			{ // let
				// let binding "and__0__auto__"
				tmp6 := checkDerefVar(glojure_DOT_core_ident_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "and__0__auto__"
						tmp11 := checkDerefVar(glojure_DOT_core_namespace)
						tmp12 := lang.Apply(tmp11, []any{v3})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						if lang.IsTruthy(v13) {
							tmp14 = true
						} else {
							tmp14 = v13
						}
						tmp10 = tmp14
					} // end let
					tmp9 = tmp10
				} else {
					tmp9 = v8
				}
				tmp5 = tmp9
			} // end let
			tmp6 := lang.Apply(tmp4, []any{tmp5})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-keyword?
	{
		tmp0 := lang.NewSymbol("qualified-keyword?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a keyword with a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1638), lang.NewKeyword("end-line"), int(1638))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_boolean)
			var tmp5 any
			{ // let
				// let binding "and__0__auto__"
				tmp6 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "and__0__auto__"
						tmp11 := checkDerefVar(glojure_DOT_core_namespace)
						tmp12 := lang.Apply(tmp11, []any{v3})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						if lang.IsTruthy(v13) {
							tmp14 = true
						} else {
							tmp14 = v13
						}
						tmp10 = tmp14
					} // end let
					tmp9 = tmp10
				} else {
					tmp9 = v8
				}
				tmp5 = tmp9
			} // end let
			tmp6 := lang.Apply(tmp4, []any{tmp5})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-symbol?
	{
		tmp0 := lang.NewSymbol("qualified-symbol?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a symbol with a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1628), lang.NewKeyword("end-line"), int(1628))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_boolean)
			var tmp5 any
			{ // let
				// let binding "and__0__auto__"
				tmp6 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "and__0__auto__"
						tmp11 := checkDerefVar(glojure_DOT_core_namespace)
						tmp12 := lang.Apply(tmp11, []any{v3})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						if lang.IsTruthy(v13) {
							tmp14 = true
						} else {
							tmp14 = v13
						}
						tmp10 = tmp14
					} // end let
					tmp9 = tmp10
				} else {
					tmp9 = v8
				}
				tmp5 = tmp9
			} // end let
			tmp6 := lang.Apply(tmp4, []any{tmp5})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// quot
	{
		var tmp1 lang.FnFunc
		{ // function quot__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Quotient")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("quot").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"), lang.NewSymbol("div"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "quot[ient] of dividing numerator by denominator.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1266), lang.NewKeyword("end-line"), int(1266))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Quotient")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Quotient is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand
	{
		tmp0 := lang.NewSymbol("rand").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4935), lang.NewKeyword("end-line"), int(4935))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.Apply(rand16.Float64, nil)
				return tmp3
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core__STAR_)
				tmp5 := checkDerefVar(glojure_DOT_core_rand)
				tmp6 := lang.Apply(tmp5, nil)
				tmp7 := lang.Apply(tmp4, []any{v3, tmp6})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand-int
	{
		tmp0 := lang.NewSymbol("rand-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns a random integer between 0 (inclusive) and n (exclusive).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4943), lang.NewKeyword("end-line"), int(4943))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_int)
			tmp5 := checkDerefVar(glojure_DOT_core_rand)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand-nth
	{
		tmp0 := lang.NewSymbol("rand-nth").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7213), lang.NewKeyword("end-line"), int(7213))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_nth)
			tmp5 := checkDerefVar(glojure_DOT_core_rand_int)
			tmp6 := checkDerefVar(glojure_DOT_core_count)
			tmp7 := lang.Apply(tmp6, []any{v3})
			tmp8 := lang.Apply(tmp5, []any{tmp7})
			tmp9 := lang.Apply(tmp4, []any{v3, tmp8})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// random-sample
	{
		tmp0 := lang.NewSymbol("random-sample").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("prob")), lang.NewVector(lang.NewSymbol("prob"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7699), lang.NewKeyword("end-line"), int(7699))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_filter)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v6 := args[0]
					_ = v6
					tmp7 := checkDerefVar(glojure_DOT_core__LT_)
					tmp8 := checkDerefVar(glojure_DOT_core_rand)
					tmp9 := lang.Apply(tmp8, nil)
					tmp10 := lang.Apply(tmp7, []any{tmp9, v3})
					return tmp10
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7704), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(7704), lang.NewKeyword("end-column"), int(37))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7})
				return tmp8
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_filter)
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v7 := args[0]
					_ = v7
					tmp8 := checkDerefVar(glojure_DOT_core__LT_)
					tmp9 := checkDerefVar(glojure_DOT_core_rand)
					tmp10 := lang.Apply(tmp9, nil)
					tmp11 := lang.Apply(tmp8, []any{tmp10, v3})
					return tmp11
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7706), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(7706), lang.NewKeyword("end-column"), int(37))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(tmp5, []any{tmp8, v4})
				return tmp9
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// random-uuid
	{
		tmp0 := lang.NewSymbol("random-uuid").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Returns a pseudo-randomly generated java.util.UUID instance (i.e. type 4).\n\n  See: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#randomUUID--", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6852), lang.NewKeyword("end-line"), int(6852))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(uuid13.NewV7, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// range
	{
		tmp0 := lang.NewSymbol("range").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("end")), lang.NewVector(lang.NewSymbol("start"), lang.NewSymbol("end")), lang.NewVector(lang.NewSymbol("start"), lang.NewSymbol("end"), lang.NewSymbol("step"))), lang.NewKeyword("doc"), "Returns a lazy seq of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end to\n  infinity. When step is equal to 0, returns an infinite sequence of\n  start. When start is equal to end, returns empty list.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3018), lang.NewKeyword("end-line"), int(3018))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(glojure_DOT_core_iterate)
				tmp4 := checkDerefVar(glojure_DOT_core_inc_U0027_)
				tmp5 := lang.Apply(tmp3, []any{tmp4, int64(0)})
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(glojure_DOT_core_int_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					tmp7 := lang.Apply(lang.NewLongRange, []any{int64(0), v3, int64(1)})
					tmp4 = tmp7
				} else {
					tmp8 := lang.Apply(lang.NewRange, []any{int64(0), v3, int64(1)})
					tmp4 = tmp8
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				var tmp6 any
				{ // let
					// let binding "and__0__auto__"
					tmp7 := checkDerefVar(glojure_DOT_core_int_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{v3})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp11 := checkDerefVar(glojure_DOT_core_int_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v4})
						tmp10 = tmp12
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				if lang.IsTruthy(tmp6) {
					tmp7 := lang.Apply(lang.NewLongRange, []any{v3, v4, int64(1)})
					tmp5 = tmp7
				} else {
					tmp8 := lang.Apply(lang.NewRange, []any{v3, v4, int64(1)})
					tmp5 = tmp8
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				var tmp7 any
				{ // let
					// let binding "and__0__auto__"
					tmp8 := checkDerefVar(glojure_DOT_core_int_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v3})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						var tmp12 any
						{ // let
							// let binding "and__0__auto__"
							tmp13 := checkDerefVar(glojure_DOT_core_int_QMARK_)
							tmp14 := lang.Apply(tmp13, []any{v4})
							var v15 any = tmp14
							_ = v15
							var tmp16 any
							if lang.IsTruthy(v15) {
								tmp17 := checkDerefVar(glojure_DOT_core_int_QMARK_)
								tmp18 := lang.Apply(tmp17, []any{v5})
								tmp16 = tmp18
							} else {
								tmp16 = v15
							}
							tmp12 = tmp16
						} // end let
						tmp11 = tmp12
					} else {
						tmp11 = v10
					}
					tmp7 = tmp11
				} // end let
				if lang.IsTruthy(tmp7) {
					tmp8 := lang.Apply(lang.NewLongRange, []any{v3, v4, v5})
					tmp6 = tmp8
				} else {
					tmp9 := lang.Apply(lang.NewRange, []any{v3, v4, v5})
					tmp6 = tmp9
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ratio?
	{
		tmp0 := lang.NewSymbol("ratio?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is a Ratio", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3577), lang.NewKeyword("end-line"), int(3577))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Ratio)(nil))
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rational?
	{
		tmp0 := lang.NewSymbol("rational?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is a rational number", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3613), lang.NewKeyword("end-line"), int(3613))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_integer_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp8 = v7
				} else {
					var tmp9 any
					{ // let
						// let binding "or__0__auto__"
						tmp10 := checkDerefVar(glojure_DOT_core_ratio_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v3})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							tmp13 = v12
						} else {
							tmp14 := checkDerefVar(glojure_DOT_core_decimal_QMARK_)
							tmp15 := lang.Apply(tmp14, []any{v3})
							tmp13 = tmp15
						}
						tmp9 = tmp13
					} // end let
					tmp8 = tmp9
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rationalize
	{
		tmp0 := lang.NewSymbol("rationalize").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("doc"), "returns the rational value of num", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1282), lang.NewKeyword("end-line"), int(1282))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Rationalize")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Rationalize is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-find
	{
		tmp0 := lang.NewSymbol("re-find").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m")), lang.NewVector(lang.NewSymbol("re"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns the next regex match, if any, of string to pattern, using\n  java.util.regex.Matcher.find().  Uses re-groups to return the\n  groups.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4922), lang.NewKeyword("end-line"), int(4922))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5, _ := lang.FieldOrMethod(v3, "find")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("find is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{})
				if lang.IsTruthy(tmp6) {
					tmp7 := checkDerefVar(glojure_DOT_core_re_groups)
					tmp8 := lang.Apply(tmp7, []any{v3})
					tmp4 = tmp8
				} else {
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "m"
					tmp6 := checkDerefVar(glojure_DOT_core_re_matcher)
					tmp7 := lang.Apply(tmp6, []any{v3, v4})
					var v8 any = tmp7
					_ = v8
					tmp9 := checkDerefVar(glojure_DOT_core_re_find)
					tmp10 := lang.Apply(tmp9, []any{v8})
					tmp5 = tmp10
				} // end let
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-groups
	{
		tmp0 := lang.NewSymbol("re-groups").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"))), lang.NewKeyword("doc"), "Returns the groups from the most recent match/find. If there are no\n  nested groups, returns a string of the entire match. If there are\n  nested groups, returns a vector of the groups, the first element\n  being the entire match.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4882), lang.NewKeyword("end-line"), int(4882))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "gc"
				tmp5, _ := lang.FieldOrMethod(v3, "groupCount")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("groupCount is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(glojure_DOT_core_zero_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v7})
				if lang.IsTruthy(tmp10) {
					tmp11, _ := lang.FieldOrMethod(v3, "group")
					if reflect.TypeOf(tmp11).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("group is not a function")))
					}
					tmp12 := lang.Apply(tmp11, []any{})
					tmp8 = tmp12
				} else {
					var tmp13 any
					{ // let
						// let binding "ret"
						tmp14 := lang.NewVector()
						tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4893), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(4893), lang.NewKeyword("end-column"), int(21))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v17 any = tmp16
						_ = v17
						// let binding "c"
						var v18 any = int64(0)
						_ = v18
						for {
							var tmp19 any
							tmp20 := checkDerefVar(glojure_DOT_core__LT__EQ_)
							tmp21 := lang.Apply(tmp20, []any{v18, v7})
							if lang.IsTruthy(tmp21) {
								tmp23 := checkDerefVar(glojure_DOT_core_conj)
								tmp24, _ := lang.FieldOrMethod(v3, "groupInt")
								if reflect.TypeOf(tmp24).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("groupInt is not a function")))
								}
								tmp25 := lang.Apply(tmp24, []any{v18})
								tmp26 := lang.Apply(tmp23, []any{v17, tmp25})
								var tmp22 any = tmp26
								tmp28 := checkDerefVar(glojure_DOT_core_inc)
								tmp29 := lang.Apply(tmp28, []any{v18})
								var tmp27 any = tmp29
								v17 = tmp22
								v18 = tmp27
								continue
							} else {
								tmp19 = v17
							}
							tmp13 = tmp19
							break
						}
					} // end let
					tmp8 = tmp13
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-matcher
	{
		tmp1 := reflect.TypeOf((*lang.RegexpMatcher)(nil))
		tmp0 := lang.NewSymbol("re-matcher").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("re"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns an instance of java.util.regex.Matcher, for use, e.g. in\n  re-find.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4873), lang.NewKeyword("end-line"), int(4873))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := lang.Apply(lang.NewRegexpMatcher, []any{v4, v5})
			return tmp6
		})
		tmp4 := reflect.TypeOf((*lang.RegexpMatcher)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-matches
	{
		tmp0 := lang.NewSymbol("re-matches").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("re"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns the match, if any, of string to pattern, using\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\n  groups.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4910), lang.NewKeyword("end-line"), int(4910))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "m"
				tmp6 := checkDerefVar(glojure_DOT_core_re_matcher)
				tmp7 := lang.Apply(tmp6, []any{v3, v4})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				tmp10, _ := lang.FieldOrMethod(v8, "matches")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("matches is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{})
				if lang.IsTruthy(tmp11) {
					tmp12 := checkDerefVar(glojure_DOT_core_re_groups)
					tmp13 := lang.Apply(tmp12, []any{v8})
					tmp9 = tmp13
				} else {
				}
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-pattern
	{
		tmp1 := reflect.TypeOf((*regexp15.Regexp)(nil))
		tmp0 := lang.NewSymbol("re-pattern").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns an instance of java.util.regex.Pattern, for use, e.g. in\n  re-matcher.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4863), lang.NewKeyword("end-line"), int(4863))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*regexp15.Regexp)(nil))
			tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
			if lang.IsTruthy(tmp8) {
				tmp5 = v4
			} else {
				tmp9 := lang.Apply(regexp15.MustCompile, []any{v4})
				tmp5 = tmp9
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*regexp15.Regexp)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-seq
	{
		tmp0 := lang.NewSymbol("re-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("re"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns a lazy sequence of successive matches of pattern in string,\n  using java.util.regex.Matcher.find(), each such match processed with\n  re-groups.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4898), lang.NewKeyword("end-line"), int(4898))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "m"
				tmp6 := checkDerefVar(glojure_DOT_core_re_matcher)
				tmp7 := lang.Apply(tmp6, []any{v3, v4})
				var v8 any = tmp7
				_ = v8
				var tmp9 lang.FnFunc
				{ // function step
					var v10 lang.FnFunc
					tmp9 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var tmp11 any
						tmp12, _ := lang.FieldOrMethod(v8, "find")
						if reflect.TypeOf(tmp12).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("find is not a function")))
						}
						tmp13 := lang.Apply(tmp12, []any{})
						if lang.IsTruthy(tmp13) {
							tmp14 := checkDerefVar(glojure_DOT_core_cons)
							tmp15 := checkDerefVar(glojure_DOT_core_re_groups)
							tmp16 := lang.Apply(tmp15, []any{v8})
							var tmp17 lang.FnFunc
							tmp17 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								tmp18 := lang.Apply(v10, nil)
								return tmp18
							})
							tmp18 := lang.Apply(lang.NewLazySeq, []any{tmp17})
							tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
							tmp11 = tmp19
						} else {
						}
						return tmp11
					})
					v10 = tmp9
					_ = v10
				}
				tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4906), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(4908), lang.NewKeyword("end-column"), int(49))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := lang.Apply(tmp11, nil)
				tmp5 = tmp12
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read
	{
		tmp0 := lang.NewSymbol("read").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("stream")), lang.NewVector(lang.NewSymbol("stream"), lang.NewSymbol("eof-error?"), lang.NewSymbol("eof-value")), lang.NewVector(lang.NewSymbol("stream"), lang.NewSymbol("eof-error?"), lang.NewSymbol("eof-value"), lang.NewSymbol("recursive?")), lang.NewVector(lang.NewSymbol("opts"), lang.NewSymbol("stream"))), lang.NewKeyword("doc"), "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n  Note that read can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use glojure.edn/read", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3742), lang.NewKeyword("end-line"), int(3742))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(glojure_DOT_core_read)
				tmp4 := checkDerefVar(glojure_DOT_core__STAR_in_STAR_)
				tmp5 := lang.Apply(tmp3, []any{tmp4})
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_read)
				tmp5 := lang.Apply(tmp4, []any{v3, true, nil})
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_read)
				tmp7 := lang.Apply(tmp6, []any{v3, v4, v5, false})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_boolean)
				tmp8 := lang.Apply(tmp7, []any{v4})
				tmp9, _ := lang.FieldOrMethod(nil, "read")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("read is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{v3, tmp8, v5, v6})
				return tmp10
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(nil, "read")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("read is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4, v3})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read+string
	{
		tmp0 := lang.NewSymbol("read+string").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("stream")), lang.NewVector(lang.NewSymbol("stream"), lang.NewSymbol("eof-error?"), lang.NewSymbol("eof-value")), lang.NewVector(lang.NewSymbol("stream"), lang.NewSymbol("eof-error?"), lang.NewSymbol("eof-value"), lang.NewSymbol("recursive?")), lang.NewVector(lang.NewSymbol("opts"), lang.NewSymbol("stream"))), lang.NewKeyword("doc"), "Like read, and taking the same args. stream must be a LineNumberingPushbackReader.\n  Returns a vector containing the object read and the (whitespace-trimmed) string read.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3771), lang.NewKeyword("end-line"), int(3771))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(glojure_DOT_core_read_PLUS_string)
				tmp4 := checkDerefVar(glojure_DOT_core__STAR_in_STAR_)
				tmp5 := lang.Apply(tmp3, []any{tmp4})
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_read_PLUS_string)
				tmp5 := lang.Apply(tmp4, []any{v3, true, nil})
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_read_PLUS_string)
				tmp7 := lang.Apply(tmp6, []any{v3, v4, v5, false})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							if lang.CatchMatches(r, lang.Throwable) {
								v8 := r
								_ = v8
								tmp9, ok := lang.FieldOrMethod(v3, "getString")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getString")))
								}
								var tmp10 any
								switch reflect.TypeOf(tmp9).Kind() {
								case reflect.Func:
									tmp10 = lang.Apply(tmp9, nil)
								default:
									tmp10 = tmp9
								}
								_ = tmp10
								panic(v8)
							} else {
								panic(r)
							}
						}
					}()
					tmp8, ok := lang.FieldOrMethod(v3, "captureString")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "captureString")))
					}
					var tmp9 any
					switch reflect.TypeOf(tmp8).Kind() {
					case reflect.Func:
						tmp9 = lang.Apply(tmp8, nil)
					default:
						tmp9 = tmp8
					}
					_ = tmp9
					var tmp10 any
					{ // let
						// let binding "o"
						tmp11 := checkDerefVar(glojure_DOT_core_read)
						tmp12 := lang.Apply(tmp11, []any{v3, v4, v5, v6})
						var v13 any = tmp12
						_ = v13
						// let binding "s"
						tmp14, ok := lang.FieldOrMethod(v3, "getString")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getString")))
						}
						var tmp15 any
						switch reflect.TypeOf(tmp14).Kind() {
						case reflect.Func:
							tmp15 = lang.Apply(tmp14, nil)
						default:
							tmp15 = tmp14
						}
						tmp16, ok := lang.FieldOrMethod(tmp15, "trim")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp15, "trim")))
						}
						var tmp17 any
						switch reflect.TypeOf(tmp16).Kind() {
						case reflect.Func:
							tmp17 = lang.Apply(tmp16, nil)
						default:
							tmp17 = tmp16
						}
						var v18 any = tmp17
						_ = v18
						tmp19 := lang.NewVector(v13, v18)
						tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3783), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(3783), lang.NewKeyword("end-column"), int(12))
						tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp10 = tmp21
					} // end let
					tmp7 = tmp10
				}()
				return tmp7
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							if lang.CatchMatches(r, lang.Throwable) {
								v6 := r
								_ = v6
								tmp7, ok := lang.FieldOrMethod(v4, "getString")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getString")))
								}
								var tmp8 any
								switch reflect.TypeOf(tmp7).Kind() {
								case reflect.Func:
									tmp8 = lang.Apply(tmp7, nil)
								default:
									tmp8 = tmp7
								}
								_ = tmp8
								panic(v6)
							} else {
								panic(r)
							}
						}
					}()
					tmp6, ok := lang.FieldOrMethod(v4, "captureString")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "captureString")))
					}
					var tmp7 any
					switch reflect.TypeOf(tmp6).Kind() {
					case reflect.Func:
						tmp7 = lang.Apply(tmp6, nil)
					default:
						tmp7 = tmp6
					}
					_ = tmp7
					var tmp8 any
					{ // let
						// let binding "o"
						tmp9 := checkDerefVar(glojure_DOT_core_read)
						tmp10 := lang.Apply(tmp9, []any{v3, v4})
						var v11 any = tmp10
						_ = v11
						// let binding "s"
						tmp12, ok := lang.FieldOrMethod(v4, "getString")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getString")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						tmp14, ok := lang.FieldOrMethod(tmp13, "trim")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp13, "trim")))
						}
						var tmp15 any
						switch reflect.TypeOf(tmp14).Kind() {
						case reflect.Func:
							tmp15 = lang.Apply(tmp14, nil)
						default:
							tmp15 = tmp14
						}
						var v16 any = tmp15
						_ = v16
						tmp17 := lang.NewVector(v11, v16)
						tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3792), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(3792), lang.NewKeyword("end-column"), int(12))
						tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp19
					} // end let
					tmp5 = tmp8
				}()
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read-line
	{
		tmp0 := lang.NewSymbol("read-line").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Reads the next line from stream that is the current value of *in* .", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3797), lang.NewKeyword("end-line"), int(3797))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			var tmp3 any
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := checkDerefVar(glojure_DOT_core__STAR_in_STAR_)
			tmp6 := lang.Apply(tmp4, []any{nil, tmp5})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(glojure_DOT_core__STAR_in_STAR_)
				tmp8, ok := lang.FieldOrMethod(tmp7, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp7, "readLine")))
				}
				var tmp9 any
				switch reflect.TypeOf(tmp8).Kind() {
				case reflect.Func:
					tmp9 = lang.Apply(tmp8, nil)
				default:
					tmp9 = tmp8
				}
				tmp3 = tmp9
			} else {
				tmp10 := checkDerefVar(glojure_DOT_core__STAR_in_STAR_)
				tmp11, ok := lang.FieldOrMethod(tmp10, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp10, "readLine")))
				}
				var tmp12 any
				switch reflect.TypeOf(tmp11).Kind() {
				case reflect.Func:
					tmp12 = lang.Apply(tmp11, nil)
				default:
					tmp12 = tmp11
				}
				tmp3 = tmp12
			}
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read-string
	{
		tmp0 := lang.NewSymbol("read-string").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s")), lang.NewVector(lang.NewSymbol("opts"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Reads one object from the string s. Optionally include reader\n  options, as specified in read.\n\n  Note that read-string can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use glojure.edn/read-string", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3806), lang.NewKeyword("end-line"), int(3806))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(runtime7.RTReadString, []any{v3})
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(runtime7.RTReadString, []any{v4, v3})
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reader-conditional
	{
		tmp0 := lang.NewSymbol("reader-conditional").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("form"), lang.NewSymbol("splicing?"))), lang.NewKeyword("doc"), "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7782), lang.NewKeyword("end-line"), int(7782))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reader-conditional?
	{
		tmp0 := lang.NewSymbol("reader-conditional?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("value"))), lang.NewKeyword("doc"), "Return true if the value is the data representation of a reader conditional", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7776), lang.NewKeyword("end-line"), int(7776))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// realized?
	{
		tmp0 := lang.NewSymbol("realized?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7559), lang.NewKeyword("end-line"), int(7559))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "isRealized")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isRealized")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce
	{
		tmp0 := lang.NewSymbol("reduce").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("val"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6860), lang.NewKeyword("end-line"), int(6860))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IReduce)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
				if lang.IsTruthy(tmp8) {
					tmp9, _ := lang.FieldOrMethod(v4, "Reduce")
					if reflect.TypeOf(tmp9).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Reduce is not a function")))
					}
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp5 = tmp10
				} else {
					tmp11 := checkDerefVar(glojure_DOT_core_DOT_protocols_coll_reduce)
					tmp12 := lang.Apply(tmp11, []any{v4, v3})
					tmp5 = tmp12
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp8 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v5})
				if lang.IsTruthy(tmp9) {
					tmp10, _ := lang.FieldOrMethod(v5, "ReduceInit")
					if reflect.TypeOf(tmp10).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
					}
					tmp11 := lang.Apply(tmp10, []any{v3, v4})
					tmp6 = tmp11
				} else {
					tmp12 := checkDerefVar(glojure_DOT_core_DOT_protocols_coll_reduce)
					tmp13 := lang.Apply(tmp12, []any{v5, v3, v4})
					tmp6 = tmp13
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce-kv
	{
		tmp0 := lang.NewSymbol("reduce-kv").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("init"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6882), lang.NewKeyword("end-line"), int(6882))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := checkDerefVar(glojure_DOT_core_DOT_protocols_kv_reduce)
			tmp7 := lang.Apply(tmp6, []any{v5, v3, v4})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce1
	{
		tmp0 := lang.NewSymbol("reduce1").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(923), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(924), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("val"), lang.NewSymbol("coll"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s"
					tmp6 := checkDerefVar(glojure_DOT_core_seq)
					tmp7 := lang.Apply(tmp6, []any{v4})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp10 := checkDerefVar(glojure_DOT_core_reduce1)
						tmp11 := checkDerefVar(glojure_DOT_core_first)
						tmp12 := lang.Apply(tmp11, []any{v8})
						tmp13 := checkDerefVar(glojure_DOT_core_next)
						tmp14 := lang.Apply(tmp13, []any{v8})
						tmp15 := lang.Apply(tmp10, []any{v3, tmp12, tmp14})
						tmp9 = tmp15
					} else {
						tmp16 := lang.Apply(v3, nil)
						tmp9 = tmp16
					}
					tmp5 = tmp9
				} // end let
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
			recur_loop_156:
				var tmp6 any
				{ // let
					// let binding "s"
					tmp7 := checkDerefVar(glojure_DOT_core_seq)
					tmp8 := lang.Apply(tmp7, []any{v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						var tmp11 any
						tmp12 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v9})
						if lang.IsTruthy(tmp13) {
							var tmp14 any = v3
							tmp16 := checkDerefVar(glojure_DOT_core_chunk_first)
							tmp17 := lang.Apply(tmp16, []any{v9})
							tmp18, _ := lang.FieldOrMethod(tmp17, "ReduceInit")
							if reflect.TypeOf(tmp18).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
							}
							tmp19 := lang.Apply(tmp18, []any{v3, v4})
							var tmp15 any = tmp19
							tmp21 := checkDerefVar(glojure_DOT_core_chunk_next)
							tmp22 := lang.Apply(tmp21, []any{v9})
							var tmp20 any = tmp22
							v3 = tmp14
							v4 = tmp15
							v5 = tmp20
							goto recur_loop_156
						} else {
							var tmp23 any = v3
							tmp25 := checkDerefVar(glojure_DOT_core_first)
							tmp26 := lang.Apply(tmp25, []any{v9})
							tmp27 := lang.Apply(v3, []any{v4, tmp26})
							var tmp24 any = tmp27
							tmp29 := checkDerefVar(glojure_DOT_core_next)
							tmp30 := lang.Apply(tmp29, []any{v9})
							var tmp28 any = tmp30
							v3 = tmp23
							v4 = tmp24
							v5 = tmp28
							goto recur_loop_156
						}
						tmp10 = tmp11
					} else {
						tmp10 = v4
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduced
	{
		tmp0 := lang.NewSymbol("reduced").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Wraps x in a way such that a reduce will terminate with the value x", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2828), lang.NewKeyword("end-line"), int(2828))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.NewReduced, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduced?
	{
		var tmp1 lang.FnFunc
		{ // function reduced?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.IsReduced")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("reduced?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if x is the result of a call to reduced", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2834), lang.NewKeyword("end-line"), int(2834))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.IsReduced, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reductions
	{
		tmp0 := lang.NewSymbol("reductions").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("init"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7196), lang.NewKeyword("end-line"), int(7196))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								tmp13 := checkDerefVar(glojure_DOT_core_reductions)
								tmp14 := checkDerefVar(glojure_DOT_core_first)
								tmp15 := lang.Apply(tmp14, []any{v12})
								tmp16 := checkDerefVar(glojure_DOT_core_rest)
								tmp17 := lang.Apply(tmp16, []any{v12})
								tmp18 := lang.Apply(tmp13, []any{v3, tmp15, tmp17})
								tmp11 = tmp18
							} // end let
							tmp10 = tmp11
						} else {
							tmp12 := checkDerefVar(glojure_DOT_core_list)
							tmp13 := lang.Apply(v3, nil)
							tmp14 := lang.Apply(tmp12, []any{tmp13})
							tmp10 = tmp14
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(glojure_DOT_core_reduced_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(glojure_DOT_core_list)
					tmp10 := checkDerefVar(glojure_DOT_core_deref)
					tmp11 := lang.Apply(tmp10, []any{v4})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					tmp6 = tmp12
				} else {
					tmp13 := checkDerefVar(glojure_DOT_core_cons)
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var tmp15 any
						{ // let
							// let binding "temp__0__auto__"
							tmp16 := checkDerefVar(glojure_DOT_core_seq)
							tmp17 := lang.Apply(tmp16, []any{v5})
							var v18 any = tmp17
							_ = v18
							var tmp19 any
							if lang.IsTruthy(v18) {
								var tmp20 any
								{ // let
									// let binding "s"
									var v21 any = v18
									_ = v21
									tmp22 := checkDerefVar(glojure_DOT_core_reductions)
									tmp23 := checkDerefVar(glojure_DOT_core_first)
									tmp24 := lang.Apply(tmp23, []any{v21})
									tmp25 := lang.Apply(v3, []any{v4, tmp24})
									tmp26 := checkDerefVar(glojure_DOT_core_rest)
									tmp27 := lang.Apply(tmp26, []any{v21})
									tmp28 := lang.Apply(tmp22, []any{v3, tmp25, tmp27})
									tmp20 = tmp28
								} // end let
								tmp19 = tmp20
							} else {
							}
							tmp15 = tmp19
						} // end let
						return tmp15
					})
					tmp15 := lang.Apply(lang.NewLazySeq, []any{tmp14})
					tmp16 := lang.Apply(tmp13, []any{v4, tmp15})
					tmp6 = tmp16
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref
	{
		tmp0 := lang.NewSymbol("ref").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Creates and returns a Ref with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :min-history (default 0)\n  :max-history (default 10)\n\n  If metadata-map is supplied, it will become the metadata on the\n  ref. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception. validate-fn will be called on\n  transaction commit, when all refs have their final values.\n\n  Normally refs accumulate history dynamically as needed to deal with\n  read demands. If you know in advance you will need history you can\n  set :min-history to ensure it will be available when first needed (instead\n  of after a read fault). History is limited, and the limit can be set\n  with :max-history.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2260), lang.NewKeyword("end-line"), int(2260))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(lang.NewRef, []any{v3})
				return tmp4
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "r"
					tmp6 := checkDerefVar(glojure_DOT_core_setup_reference)
					tmp7 := checkDerefVar(glojure_DOT_core_ref)
					tmp8 := lang.Apply(tmp7, []any{v3})
					tmp9 := lang.Apply(tmp6, []any{tmp8, v4})
					var v10 any = tmp9
					_ = v10
					// let binding "opts"
					tmp11 := checkDerefVar(glojure_DOT_core_apply)
					tmp12 := checkDerefVar(glojure_DOT_core_hash_map)
					tmp13 := lang.Apply(tmp11, []any{tmp12, v4})
					var v14 any = tmp13
					_ = v14
					var tmp15 any
					tmp16 := lang.Apply(lang.NewKeyword("max-history"), []any{v14})
					if lang.IsTruthy(tmp16) {
						tmp17 := lang.Apply(lang.NewKeyword("max-history"), []any{v14})
						tmp18, _ := lang.FieldOrMethod(v10, "setMaxHistory")
						if reflect.TypeOf(tmp18).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMaxHistory is not a function")))
						}
						tmp19 := lang.Apply(tmp18, []any{tmp17})
						tmp15 = tmp19
					} else {
					}
					_ = tmp15
					var tmp20 any
					tmp21 := lang.Apply(lang.NewKeyword("min-history"), []any{v14})
					if lang.IsTruthy(tmp21) {
						tmp22 := lang.Apply(lang.NewKeyword("min-history"), []any{v14})
						tmp23, _ := lang.FieldOrMethod(v10, "setMinHistory")
						if reflect.TypeOf(tmp23).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMinHistory is not a function")))
						}
						tmp24 := lang.Apply(tmp23, []any{tmp22})
						tmp20 = tmp24
					} else {
					}
					_ = tmp20
					tmp5 = v10
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-history-count
	{
		tmp0 := lang.NewSymbol("ref-history-count").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref"))), lang.NewKeyword("doc"), "Returns the history count of a ref", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2455), lang.NewKeyword("end-line"), int(2455))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getHistoryCount")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getHistoryCount")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-max-history
	{
		tmp0 := lang.NewSymbol("ref-max-history").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref")), lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Gets the max-history of a ref, or sets it and returns the ref", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2471), lang.NewKeyword("end-line"), int(2471))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, ok := lang.FieldOrMethod(v3, "getMaxHistory")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMaxHistory")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "setMaxHistory")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMaxHistory is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-min-history
	{
		tmp0 := lang.NewSymbol("ref-min-history").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref")), lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Gets the min-history of a ref, or sets it and returns the ref", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2462), lang.NewKeyword("end-line"), int(2462))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, ok := lang.FieldOrMethod(v3, "getMinHistory")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMinHistory")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "setMinHistory")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMinHistory is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-set
	{
		tmp0 := lang.NewSymbol("ref-set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Must be called in a transaction. Sets the value of ref.\n  Returns val.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2447), lang.NewKeyword("end-line"), int(2447))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "set")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("set is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// refer
	{
		tmp0 := lang.NewSymbol("refer").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns-sym"), lang.NewSymbol("&"), lang.NewSymbol("filters"))), lang.NewKeyword("doc"), "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4216), lang.NewKeyword("end-line"), int(4216))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "ns"
					var tmp6 any
					{ // let
						// let binding "or__0__auto__"
						tmp7 := checkDerefVar(glojure_DOT_core_find_ns)
						tmp8 := lang.Apply(tmp7, []any{v3})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							tmp10 = v9
						} else {
							tmp11 := checkDerefVar(glojure_DOT_core_str)
							tmp12 := lang.Apply(tmp11, []any{"No namespace: ", v3})
							tmp13 := lang.Apply(errors8.New, []any{tmp12})
							panic(tmp13)
						}
						tmp6 = tmp10
					} // end let
					var v7 any = tmp6
					_ = v7
					// let binding "fs"
					tmp8 := checkDerefVar(glojure_DOT_core_apply)
					tmp9 := checkDerefVar(glojure_DOT_core_hash_map)
					tmp10 := lang.Apply(tmp8, []any{tmp9, v4})
					var v11 any = tmp10
					_ = v11
					// let binding "nspublics"
					tmp12 := checkDerefVar(glojure_DOT_core_ns_publics)
					tmp13 := lang.Apply(tmp12, []any{v7})
					var v14 any = tmp13
					_ = v14
					// let binding "rename"
					var tmp15 any
					{ // let
						// let binding "or__0__auto__"
						tmp16 := lang.Apply(lang.NewKeyword("rename"), []any{v11})
						var v17 any = tmp16
						_ = v17
						var tmp18 any
						if lang.IsTruthy(v17) {
							tmp18 = v17
						} else {
							tmp19 := lang.NewMap()
							tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4236), lang.NewKeyword("column"), int(35), lang.NewKeyword("end-line"), int(4236), lang.NewKeyword("end-column"), int(36))
							tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp18 = tmp21
						}
						tmp15 = tmp18
					} // end let
					var v16 any = tmp15
					_ = v16
					// let binding "exclude"
					tmp17 := checkDerefVar(glojure_DOT_core_set)
					tmp18 := lang.Apply(lang.NewKeyword("exclude"), []any{v11})
					tmp19 := lang.Apply(tmp17, []any{tmp18})
					var v20 any = tmp19
					_ = v20
					// let binding "to-do"
					var tmp21 any
					tmp22 := checkDerefVar(glojure_DOT_core__EQ_)
					tmp23 := lang.Apply(lang.NewKeyword("refer"), []any{v11})
					tmp24 := lang.Apply(tmp22, []any{lang.NewKeyword("all"), tmp23})
					if lang.IsTruthy(tmp24) {
						tmp25 := checkDerefVar(glojure_DOT_core_keys)
						tmp26 := lang.Apply(tmp25, []any{v14})
						tmp21 = tmp26
					} else {
						var tmp27 any
						{ // let
							// let binding "or__0__auto__"
							tmp28 := lang.Apply(lang.NewKeyword("refer"), []any{v11})
							var v29 any = tmp28
							_ = v29
							var tmp30 any
							if lang.IsTruthy(v29) {
								tmp30 = v29
							} else {
								var tmp31 any
								{ // let
									// let binding "or__0__auto__"
									tmp32 := lang.Apply(lang.NewKeyword("only"), []any{v11})
									var v33 any = tmp32
									_ = v33
									var tmp34 any
									if lang.IsTruthy(v33) {
										tmp34 = v33
									} else {
										tmp35 := checkDerefVar(glojure_DOT_core_keys)
										tmp36 := lang.Apply(tmp35, []any{v14})
										tmp34 = tmp36
									}
									tmp31 = tmp34
								} // end let
								tmp30 = tmp31
							}
							tmp27 = tmp30
						} // end let
						tmp21 = tmp27
					}
					var v28 any = tmp21
					_ = v28
					var tmp29 any
					var tmp30 any
					{ // let
						// let binding "and__0__auto__"
						var v31 any = v28
						_ = v31
						var tmp32 any
						if lang.IsTruthy(v31) {
							tmp33 := checkDerefVar(glojure_DOT_core_not)
							tmp34 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
							tmp35 := reflect.TypeOf((*lang.Sequential)(nil)).Elem()
							tmp36 := lang.Apply(tmp34, []any{tmp35, v28})
							tmp37 := lang.Apply(tmp33, []any{tmp36})
							tmp32 = tmp37
						} else {
							tmp32 = v31
						}
						tmp30 = tmp32
					} // end let
					if lang.IsTruthy(tmp30) {
						tmp31 := lang.Apply(errors8.New, []any{":only/:refer value must be a sequential collection of symbols"})
						panic(tmp31)
					} else {
					}
					_ = tmp29
					var tmp32 any
					{ // let
						// let binding "seq_9"
						tmp33 := checkDerefVar(glojure_DOT_core_seq)
						tmp34 := lang.Apply(tmp33, []any{v28})
						var v35 any = tmp34
						_ = v35
						// let binding "chunk_10"
						var v36 any = nil
						_ = v36
						// let binding "count_11"
						var v37 any = int64(0)
						_ = v37
						// let binding "i_12"
						var v38 any = int64(0)
						_ = v38
						for {
							var tmp39 any
							tmp40 := checkDerefVar(glojure_DOT_core__LT_)
							tmp41 := lang.Apply(tmp40, []any{v38, v37})
							if lang.IsTruthy(tmp41) {
								var tmp42 any
								{ // let
									// let binding "sym"
									tmp43, _ := lang.FieldOrMethod(v36, "nth")
									if reflect.TypeOf(tmp43).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp44 := lang.Apply(tmp43, []any{v38})
									var v45 any = tmp44
									_ = v45
									var tmp46 any
									tmp47 := lang.Apply(v20, []any{v45})
									if lang.IsTruthy(tmp47) {
									} else {
										var tmp48 any
										{ // let
											// let binding "v"
											tmp49 := lang.Apply(v14, []any{v45})
											var v50 any = tmp49
											_ = v50
											var tmp51 any
											if lang.IsTruthy(v50) {
											} else {
												panic("unimplemented: new with non-constant class type")
											}
											_ = tmp51
											tmp52 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
											var tmp53 any
											{ // let
												// let binding "or__0__auto__"
												tmp54 := lang.Apply(v16, []any{v45})
												var v55 any = tmp54
												_ = v55
												var tmp56 any
												if lang.IsTruthy(v55) {
													tmp56 = v55
												} else {
													tmp56 = v45
												}
												tmp53 = tmp56
											} // end let
											tmp54, _ := lang.FieldOrMethod(tmp52, "Refer")
											if reflect.TypeOf(tmp54).Kind() != reflect.Func {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("Refer is not a function")))
											}
											tmp55 := lang.Apply(tmp54, []any{tmp53, v50})
											tmp48 = tmp55
										} // end let
										tmp46 = tmp48
									}
									_ = tmp46
									var tmp49 any = v35
									var tmp50 any = v36
									var tmp51 any = v37
									tmp53 := checkDerefVar(glojure_DOT_core_unchecked_inc)
									tmp54 := lang.Apply(tmp53, []any{v38})
									var tmp52 any = tmp54
									v35 = tmp49
									v36 = tmp50
									v37 = tmp51
									v38 = tmp52
									continue
								} // end let
								tmp39 = tmp42
							} else {
								var tmp43 any
								{ // let
									// let binding "temp__0__auto__"
									tmp44 := checkDerefVar(glojure_DOT_core_seq)
									tmp45 := lang.Apply(tmp44, []any{v35})
									var v46 any = tmp45
									_ = v46
									var tmp47 any
									if lang.IsTruthy(v46) {
										var tmp48 any
										{ // let
											// let binding "seq_9"
											var v49 any = v46
											_ = v49
											var tmp50 any
											tmp51 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
											tmp52 := lang.Apply(tmp51, []any{v49})
											if lang.IsTruthy(tmp52) {
												var tmp53 any
												{ // let
													// let binding "c__0__auto__"
													tmp54 := checkDerefVar(glojure_DOT_core_chunk_first)
													tmp55 := lang.Apply(tmp54, []any{v49})
													var v56 any = tmp55
													_ = v56
													tmp58 := checkDerefVar(glojure_DOT_core_chunk_rest)
													tmp59 := lang.Apply(tmp58, []any{v49})
													var tmp57 any = tmp59
													var tmp60 any = v56
													tmp62 := checkDerefVar(glojure_DOT_core_int)
													tmp63 := checkDerefVar(glojure_DOT_core_count)
													tmp64 := lang.Apply(tmp63, []any{v56})
													tmp65 := lang.Apply(tmp62, []any{tmp64})
													var tmp61 any = tmp65
													tmp67 := checkDerefVar(glojure_DOT_core_int)
													tmp68 := lang.Apply(tmp67, []any{int64(0)})
													var tmp66 any = tmp68
													v35 = tmp57
													v36 = tmp60
													v37 = tmp61
													v38 = tmp66
													continue
												} // end let
												tmp50 = tmp53
											} else {
												var tmp54 any
												{ // let
													// let binding "sym"
													tmp55 := checkDerefVar(glojure_DOT_core_first)
													tmp56 := lang.Apply(tmp55, []any{v49})
													var v57 any = tmp56
													_ = v57
													var tmp58 any
													tmp59 := lang.Apply(v20, []any{v57})
													if lang.IsTruthy(tmp59) {
													} else {
														var tmp60 any
														{ // let
															// let binding "v"
															tmp61 := lang.Apply(v14, []any{v57})
															var v62 any = tmp61
															_ = v62
															var tmp63 any
															if lang.IsTruthy(v62) {
															} else {
																panic("unimplemented: new with non-constant class type")
															}
															_ = tmp63
															tmp64 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
															var tmp65 any
															{ // let
																// let binding "or__0__auto__"
																tmp66 := lang.Apply(v16, []any{v57})
																var v67 any = tmp66
																_ = v67
																var tmp68 any
																if lang.IsTruthy(v67) {
																	tmp68 = v67
																} else {
																	tmp68 = v57
																}
																tmp65 = tmp68
															} // end let
															tmp66, _ := lang.FieldOrMethod(tmp64, "Refer")
															if reflect.TypeOf(tmp66).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("Refer is not a function")))
															}
															tmp67 := lang.Apply(tmp66, []any{tmp65, v62})
															tmp60 = tmp67
														} // end let
														tmp58 = tmp60
													}
													_ = tmp58
													tmp62 := checkDerefVar(glojure_DOT_core_next)
													tmp63 := lang.Apply(tmp62, []any{v49})
													var tmp61 any = tmp63
													var tmp64 any = nil
													var tmp65 any = int64(0)
													var tmp66 any = int64(0)
													v35 = tmp61
													v36 = tmp64
													v37 = tmp65
													v38 = tmp66
													continue
												} // end let
												tmp50 = tmp54
											}
											tmp48 = tmp50
										} // end let
										tmp47 = tmp48
									} else {
									}
									tmp43 = tmp47
								} // end let
								tmp39 = tmp43
							}
							tmp32 = tmp39
							break
						}
					} // end let
					tmp5 = tmp32
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// refer-glojure
	{
		tmp0 := lang.NewSymbol("refer-glojure").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("filters"))), lang.NewKeyword("doc"), "Same as (refer 'glojure.core <filters>)", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5800), lang.NewKeyword("end-line"), int(5800))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_concat)
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("glojure.core/refer")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("quote")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core")})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp7, []any{tmp9, tmp19, v5})
				tmp21 := lang.Apply(tmp6, []any{tmp20})
				return tmp21
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// release-pending-sends
	{
		tmp0 := lang.NewSymbol("release-pending-sends").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Normally, actions sent directly or indirectly during another action\n  are held until the action completes (changes the agent's\n  state). This function can be used to dispatch any pending sent\n  actions immediately. This has no impact on actions sent during a\n  transaction, which are still held until commit. If no action is\n  occurring, does nothing. Returns the number of actions dispatched.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2131), lang.NewKeyword("end-line"), int(2131))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(nil, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rem
	{
		var tmp1 lang.FnFunc
		{ // function rem__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Remainder")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("rem").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"), lang.NewSymbol("div"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "remainder of dividing numerator by denominator.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1274), lang.NewKeyword("end-line"), int(1274))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Remainder")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Remainder is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove
	{
		tmp0 := lang.NewSymbol("remove").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred")), lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2818), lang.NewKeyword("end-line"), int(2818))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_filter)
				tmp5 := checkDerefVar(glojure_DOT_core_complement)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(tmp4, []any{tmp6})
				return tmp7
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_filter)
				tmp6 := checkDerefVar(glojure_DOT_core_complement)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := lang.Apply(tmp5, []any{tmp7, v4})
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-all-methods
	{
		tmp0 := lang.NewSymbol("remove-all-methods").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"))), lang.NewKeyword("doc"), "Removes all of the methods of multimethod.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1787), lang.NewKeyword("end-line"), int(1787))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "reset")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "reset")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-method
	{
		tmp0 := lang.NewSymbol("remove-method").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"), lang.NewSymbol("dispatch-val"))), lang.NewKeyword("doc"), "Removes the method of multimethod associated with dispatch-value.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1794), lang.NewKeyword("end-line"), int(1794))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "removeMethod")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeMethod is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-ns
	{
		tmp0 := lang.NewSymbol("remove-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Removes the namespace named by the symbol. Use with caution.\n  Cannot be used to remove the glojure namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4139), lang.NewKeyword("end-line"), int(4139))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.RemoveNamespace, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-tap
	{
		tmp0 := lang.NewSymbol("remove-tap").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Remove f from the tap set.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7883), lang.NewKeyword("end-line"), int(7883))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_swap_BANG_)
			tmp5 := checkDerefVar(glojure_DOT_core_tapset)
			tmp6 := checkDerefVar(glojure_DOT_core_disj)
			tmp7 := lang.Apply(tmp4, []any{tmp5, tmp6, v3})
			_ = tmp7
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-watch
	{
		tmp0 := lang.NewSymbol("remove-watch").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("reference"), lang.NewSymbol("key"))), lang.NewKeyword("doc"), "Removes a watch (set by add-watch) from a reference", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2160), lang.NewKeyword("end-line"), int(2160))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "removeWatch")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeWatch is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// repeat
	{
		tmp0 := lang.NewSymbol("repeat").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2997), lang.NewKeyword("end-line"), int(2997))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(lang.NewRepeat, []any{v3})
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.NewRepeatN, []any{v3, v4})
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// repeatedly
	{
		tmp0 := lang.NewSymbol("repeatedly").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5167), lang.NewKeyword("end-line"), int(5167))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					tmp5 := checkDerefVar(glojure_DOT_core_cons)
					tmp6 := lang.Apply(v3, nil)
					tmp7 := checkDerefVar(glojure_DOT_core_repeatedly)
					tmp8 := lang.Apply(tmp7, []any{v3})
					tmp9 := lang.Apply(tmp5, []any{tmp6, tmp8})
					return tmp9
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_take)
				tmp6 := checkDerefVar(glojure_DOT_core_repeatedly)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{v3, tmp7})
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace
	{
		tmp0 := lang.NewSymbol("replace").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("smap")), lang.NewVector(lang.NewSymbol("smap"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5082), lang.NewKeyword("end-line"), int(5082))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_map)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v6 := args[0]
					_ = v6
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(glojure_DOT_core_find)
						tmp9 := lang.Apply(tmp8, []any{v3, v6})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "e"
								var v13 any = v10
								_ = v13
								tmp14 := checkDerefVar(glojure_DOT_core_val)
								tmp15 := lang.Apply(tmp14, []any{v13})
								tmp12 = tmp15
							} // end let
							tmp11 = tmp12
						} else {
							tmp11 = v6
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5090), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5090), lang.NewKeyword("end-column"), int(47))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7})
				return tmp8
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(glojure_DOT_core_reduce1)
					var tmp9 lang.FnFunc
					tmp9 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v10 := args[0]
						_ = v10
						v11 := args[1]
						_ = v11
						var tmp12 any
						{ // let
							// let binding "temp__0__auto__"
							tmp13 := checkDerefVar(glojure_DOT_core_find)
							tmp14 := checkDerefVar(glojure_DOT_core_nth)
							tmp15 := lang.Apply(tmp14, []any{v10, v11})
							tmp16 := lang.Apply(tmp13, []any{v3, tmp15})
							var v17 any = tmp16
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								var tmp19 any
								{ // let
									// let binding "e"
									var v20 any = v17
									_ = v20
									tmp21 := checkDerefVar(glojure_DOT_core_assoc)
									tmp22 := checkDerefVar(glojure_DOT_core_val)
									tmp23 := lang.Apply(tmp22, []any{v20})
									tmp24 := lang.Apply(tmp21, []any{v10, v11, tmp23})
									tmp19 = tmp24
								} // end let
								tmp18 = tmp19
							} else {
								tmp18 = v10
							}
							tmp12 = tmp18
						} // end let
						return tmp12
					})
					tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5093), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(5096), lang.NewKeyword("end-column"), int(23))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 := checkDerefVar(glojure_DOT_core_range)
					tmp13 := checkDerefVar(glojure_DOT_core_count)
					tmp14 := lang.Apply(tmp13, []any{v4})
					tmp15 := lang.Apply(tmp12, []any{tmp14})
					tmp16 := lang.Apply(tmp8, []any{tmp11, v4, tmp15})
					tmp5 = tmp16
				} else {
					tmp17 := checkDerefVar(glojure_DOT_core_map)
					var tmp18 lang.FnFunc
					tmp18 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v19 := args[0]
						_ = v19
						var tmp20 any
						{ // let
							// let binding "temp__0__auto__"
							tmp21 := checkDerefVar(glojure_DOT_core_find)
							tmp22 := lang.Apply(tmp21, []any{v3, v19})
							var v23 any = tmp22
							_ = v23
							var tmp24 any
							if lang.IsTruthy(v23) {
								var tmp25 any
								{ // let
									// let binding "e"
									var v26 any = v23
									_ = v26
									tmp27 := checkDerefVar(glojure_DOT_core_val)
									tmp28 := lang.Apply(tmp27, []any{v26})
									tmp25 = tmp28
								} // end let
								tmp24 = tmp25
							} else {
								tmp24 = v19
							}
							tmp20 = tmp24
						} // end let
						return tmp20
					})
					tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5098), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(5098), lang.NewKeyword("end-column"), int(49))
					tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp21 := lang.Apply(tmp17, []any{tmp20, v4})
					tmp5 = tmp21
				}
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replicate
	{
		tmp0 := lang.NewSymbol("replicate").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "DEPRECATED: Use 'repeat' instead.\n   Returns a lazy seq of n xs.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("deprecated"), "1.3", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3004), lang.NewKeyword("end-line"), int(3004))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_take)
			tmp6 := checkDerefVar(glojure_DOT_core_repeat)
			tmp7 := lang.Apply(tmp6, []any{v4})
			tmp8 := lang.Apply(tmp5, []any{v3, tmp7})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// require
	{
		tmp0 := lang.NewSymbol("require").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib, a prefix list that identifies\n  multiple libs whose names share a common prefix, or a flag that modifies\n  how all the identified libs are loaded. Use :require in the ns macro\n  in preference to calling this directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of Clojure code. Lib names are symbols and each lib is associated\n  with a Clojure namespace and a Java package that share its name. A lib's\n  name also locates its root directory within classpath using Java's\n  package name to classpath-relative path mapping. All resources in a lib\n  should be contained in the directory structure under its root directory.\n  All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or\n  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The\n  root resource should contain code to create the lib's\n  namespace (usually by using the ns macro) and load any additional\n  lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :as-alias takes a symbol as its argument and aliases like :as, however\n    the lib will not be loaded. If the lib has not been loaded, a new\n    empty namespace will be created (as with create-ns).\n  :refer takes a list of symbols to refer from the namespace or the :all\n    keyword to bring in all public vars.\n\n  Prefix Lists\n\n  It's common for Clojure code to depend on several libs whose names have\n  the same prefix. When specifying libs, prefix lists can be used to reduce\n  repetition. A prefix list contains the shared prefix followed by libspecs\n  with the shared prefix removed from the lib names. After removing the\n  prefix, the names that remain must not contain any periods.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded (has no effect on libspecs using :as-alias)\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n    (has no effect on libspecs using :as-alias)\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the libraries glojure.zip and glojure.set\n  abbreviated as 's'.\n\n  (require '(glojure zip [set :as s]))", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5989), lang.NewKeyword("end-line"), int(5989))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_apply)
				tmp5 := checkDerefVar(glojure_DOT_core_load_libs)
				tmp6 := lang.Apply(tmp4, []any{tmp5, lang.NewKeyword("require"), v3})
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// requiring-resolve
	{
		tmp0 := lang.NewSymbol("requiring-resolve").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Resolves namespace-qualified sym per 'resolve'. If initial resolve\nfails, attempts to require sym's namespace and retries.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6068), lang.NewKeyword("end-line"), int(6068))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_qualified_symbol_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				var tmp7 any
				{ // let
					// let binding "or__0__auto__"
					tmp8 := checkDerefVar(glojure_DOT_core_resolve)
					tmp9 := lang.Apply(tmp8, []any{v3})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						tmp11 = v10
					} else {
						tmp12 := checkDerefVar(glojure_DOT_core_serialized_require)
						tmp13 := checkDerefVar(glojure_DOT_core_symbol)
						tmp14 := checkDerefVar(glojure_DOT_core_namespace)
						tmp15 := lang.Apply(tmp14, []any{v3})
						tmp16 := lang.Apply(tmp13, []any{tmp15})
						tmp17 := lang.Apply(tmp12, []any{tmp16})
						_ = tmp17
						tmp18 := checkDerefVar(glojure_DOT_core_resolve)
						tmp19 := lang.Apply(tmp18, []any{v3})
						tmp11 = tmp19
					}
					tmp7 = tmp11
				} // end let
				tmp4 = tmp7
			} else {
				tmp8 := checkDerefVar(glojure_DOT_core_str)
				tmp9 := lang.Apply(tmp8, []any{"Not a qualified symbol: ", v3})
				tmp10 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp9})
				panic(tmp10)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset!
	{
		tmp0 := lang.NewSymbol("reset!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atom"), lang.NewSymbol("newval"))), lang.NewKeyword("doc"), "Sets the value of atom to newval without regard for the\n  current value. Returns newval.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2368), lang.NewKeyword("end-line"), int(2368))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "reset")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset-meta!
	{
		tmp0 := lang.NewSymbol("reset-meta!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("iref"), lang.NewSymbol("metadata-map"))), lang.NewKeyword("doc"), "Atomically resets the metadata for a namespace/var/ref/agent/atom", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2408), lang.NewKeyword("end-line"), int(2408))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "ResetMeta")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ResetMeta is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset-vals!
	{
		tmp0 := lang.NewSymbol("reset-vals!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atom"), lang.NewSymbol("newval"))), lang.NewKeyword("doc"), "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2375), lang.NewKeyword("end-line"), int(2375))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "resetVals")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("resetVals is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// resolve
	{
		tmp0 := lang.NewSymbol("resolve").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym")), lang.NewVector(lang.NewSymbol("env"), lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4371), lang.NewKeyword("end-line"), int(4371))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_ns_resolve)
				tmp5 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_ns_resolve)
				tmp6 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3, v4})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rest
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := lang.NewSymbol("rest").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(64), lang.NewKeyword("end-line"), int(70))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		{ // function rest
			var v4 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.Rest, []any{v5})
				return tmp6
			})
			tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(70), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(70), lang.NewKeyword("end-column"), int(77))).(lang.FnFunc)
			v4 = tmp3
			_ = v4
		}
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// restart-agent
	{
		tmp0 := lang.NewSymbol("restart-agent").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("new-state"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "When an agent is failed, changes the agent state to new-state and\n  then un-fails the agent so that sends are allowed again.  If\n  a :clear-actions true option is given, any actions queued on the\n  agent that were being held while it was failed will be discarded,\n  otherwise those held actions will proceed.  The new-state must pass\n  the validator if any, or restart will throw an exception and the\n  agent will remain failed with its old state and error.  Watchers, if\n  any, will NOT be notified of the new state.  Throws an exception if\n  the agent is not failed.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2175), lang.NewKeyword("end-line"), int(2175))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "opts"
					tmp7 := checkDerefVar(glojure_DOT_core_apply)
					tmp8 := checkDerefVar(glojure_DOT_core_hash_map)
					tmp9 := lang.Apply(tmp7, []any{tmp8, v5})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					tmp12 := lang.Apply(lang.NewKeyword("clear-actions"), []any{v10})
					if lang.IsTruthy(tmp12) {
						tmp11 = true
					} else {
						tmp11 = false
					}
					tmp13, _ := lang.FieldOrMethod(v3, "restart")
					if reflect.TypeOf(tmp13).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("restart is not a function")))
					}
					tmp14 := lang.Apply(tmp13, []any{v4, tmp11})
					tmp6 = tmp14
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// resultset-seq
	{
		tmp0 := lang.NewSymbol("resultset-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rs"))), lang.NewKeyword("doc"), "Creates and returns a lazy sequence of structmaps corresponding to\n  the rows in the java.sql.ResultSet rs", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5681), lang.NewKeyword("end-line"), int(5681))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "rsmeta"
				tmp5, _ := lang.FieldOrMethod(v3, "getMetaData")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("getMetaData is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{})
				var v7 any = tmp6
				_ = v7
				// let binding "idxs"
				tmp8 := checkDerefVar(glojure_DOT_core_range)
				tmp9 := checkDerefVar(glojure_DOT_core_inc)
				tmp10, _ := lang.FieldOrMethod(v7, "getColumnCount")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("getColumnCount is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{})
				tmp12 := lang.Apply(tmp9, []any{tmp11})
				tmp13 := lang.Apply(tmp8, []any{int64(1), tmp12})
				var v14 any = tmp13
				_ = v14
				// let binding "keys"
				tmp15 := checkDerefVar(glojure_DOT_core_map)
				tmp16 := checkDerefVar(glojure_DOT_core_comp)
				tmp17 := checkDerefVar(glojure_DOT_core_keyword)
				var tmp18 lang.FnFunc
				tmp18 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v19 := args[0]
					_ = v19
					tmp20, ok := lang.FieldOrMethod(v19, "toLowerCase")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v19, "toLowerCase")))
					}
					var tmp21 any
					switch reflect.TypeOf(tmp20).Kind() {
					case reflect.Func:
						tmp21 = lang.Apply(tmp20, nil)
					default:
						tmp21 = tmp20
					}
					return tmp21
				})
				tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5688), lang.NewKeyword("column"), int(35), lang.NewKeyword("end-line"), int(5688), lang.NewKeyword("end-column"), int(62))
				tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp21 := lang.Apply(tmp16, []any{tmp17, tmp20})
				tmp22 := checkDerefVar(glojure_DOT_core_map)
				var tmp23 lang.FnFunc
				tmp23 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v24 := args[0]
					_ = v24
					tmp25, _ := lang.FieldOrMethod(v7, "getColumnLabel")
					if reflect.TypeOf(tmp25).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("getColumnLabel is not a function")))
					}
					tmp26 := lang.Apply(tmp25, []any{v24})
					return tmp26
				})
				tmp24 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5689), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(5689), lang.NewKeyword("end-column"), int(63))
				tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp26 := lang.Apply(tmp22, []any{tmp25, v14})
				tmp27 := lang.Apply(tmp15, []any{tmp21, tmp26})
				var v28 any = tmp27
				_ = v28
				// let binding "check-keys"
				var tmp29 any
				{ // let
					// let binding "or__0__auto__"
					tmp30 := checkDerefVar(glojure_DOT_core_apply)
					tmp31 := checkDerefVar(glojure_DOT_core_distinct_QMARK_)
					tmp32 := lang.Apply(tmp30, []any{tmp31, v28})
					var v33 any = tmp32
					_ = v33
					var tmp34 any
					if lang.IsTruthy(v33) {
						tmp34 = v33
					} else {
						tmp35 := lang.Apply(lang.NewError, []any{"ResultSet must have unique column labels"})
						panic(tmp35)
					}
					tmp29 = tmp34
				} // end let
				var v30 any = tmp29
				_ = v30
				// let binding "row-struct"
				tmp31 := checkDerefVar(glojure_DOT_core_apply)
				tmp32 := checkDerefVar(glojure_DOT_core_create_struct)
				tmp33 := lang.Apply(tmp31, []any{tmp32, v28})
				var v34 any = tmp33
				_ = v34
				// let binding "row-values"
				var tmp35 lang.FnFunc
				tmp35 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					tmp36 := checkDerefVar(glojure_DOT_core_map)
					var tmp37 lang.FnFunc
					tmp37 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v38 := args[0]
						_ = v38
						tmp39, _ := lang.FieldOrMethod(v3, "getObject")
						if reflect.TypeOf(tmp39).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("getObject is not a function")))
						}
						tmp40 := lang.Apply(tmp39, []any{v38})
						return tmp40
					})
					tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5694), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(5694), lang.NewKeyword("end-column"), int(71))
					tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp40 := lang.Apply(tmp36, []any{tmp39, v14})
					return tmp40
				})
				tmp36 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5694), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(5694), lang.NewKeyword("end-column"), int(78))
				tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v38 any = tmp37
				_ = v38
				// let binding "rows"
				var tmp39 lang.FnFunc
				{ // function thisfn
					var v40 lang.FnFunc
					tmp39 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var tmp41 any
						tmp42, _ := lang.FieldOrMethod(v3, "next")
						if reflect.TypeOf(tmp42).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("next is not a function")))
						}
						tmp43 := lang.Apply(tmp42, []any{})
						if lang.IsTruthy(tmp43) {
							tmp44 := checkDerefVar(glojure_DOT_core_cons)
							tmp45 := checkDerefVar(glojure_DOT_core_apply)
							tmp46 := checkDerefVar(glojure_DOT_core_struct)
							tmp47 := lang.Apply(v38, nil)
							tmp48 := lang.Apply(tmp45, []any{tmp46, v34, tmp47})
							var tmp49 lang.FnFunc
							tmp49 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								tmp50 := lang.Apply(v40, nil)
								return tmp50
							})
							tmp50 := lang.Apply(lang.NewLazySeq, []any{tmp49})
							tmp51 := lang.Apply(tmp44, []any{tmp48, tmp50})
							tmp41 = tmp51
						} else {
						}
						return tmp41
					})
					v40 = tmp39
					_ = v40
				}
				tmp40 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5695), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(5697), lang.NewKeyword("end-column"), int(86))
				tmp41, err := lang.WithMeta(tmp39, tmp40.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v42 any = tmp41
				_ = v42
				tmp43 := lang.Apply(v42, nil)
				tmp4 = tmp43
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reverse
	{
		tmp0 := lang.NewSymbol("reverse").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a seq of the items in coll in reverse order. Not lazy.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(940), lang.NewKeyword("end-line"), int(940))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_reduce1)
			tmp5 := checkDerefVar(glojure_DOT_core_conj)
			tmp6 := lang.Apply(tmp4, []any{tmp5, lang.NewList(), v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reversible?
	{
		tmp0 := lang.NewSymbol("reversible?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll implements Reversible", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6257), lang.NewKeyword("end-line"), int(6257))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// root-directory
	{
		tmp0 := lang.NewSymbol("root-directory").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("lib"))), lang.NewKeyword("doc"), "Returns the root resource path for a lib", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5871), lang.NewKeyword("end-line"), int(5871), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "d"
				tmp5 := checkDerefVar(glojure_DOT_core_root_resource)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_subs)
				tmp9 := lang.Apply(strings11.LastIndex, []any{v7, "/"})
				tmp10 := lang.Apply(tmp8, []any{v7, int64(0), tmp9})
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// root-resource
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("root-resource").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("lib"))), lang.NewKeyword("doc"), "Returns the root directory path for a lib", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5864), lang.NewKeyword("end-line"), int(5864), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_str)
			tmp6 := checkDerefVar(glojure_DOT_core_name)
			tmp7 := lang.Apply(tmp6, []any{v4})
			tmp8 := lang.Apply(strings11.ReplaceAll, []any{tmp7, "-", "_"})
			tmp9 := lang.Apply(strings11.ReplaceAll, []any{tmp8, ".", "/"})
			tmp10 := lang.Apply(tmp5, []any{lang.NewChar(47), tmp9})
			return tmp10
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rseq
	{
		tmp0 := lang.NewSymbol("rseq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rev"))), lang.NewKeyword("doc"), "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1577), lang.NewKeyword("end-line"), int(1577))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "rseq")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("rseq is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rsubseq
	{
		tmp0 := lang.NewSymbol("rsubseq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sc"), lang.NewSymbol("test"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("sc"), lang.NewSymbol("start-test"), lang.NewSymbol("start-key"), lang.NewSymbol("end-test"), lang.NewSymbol("end-key"))), lang.NewKeyword("doc"), "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5150), lang.NewKeyword("end-line"), int(5150))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "include"
					tmp7 := checkDerefVar(glojure_DOT_core_mk_bound_fn)
					tmp8 := lang.Apply(tmp7, []any{v3, v4, v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core__LT_)
					tmp12 := checkDerefVar(glojure_DOT_core__LT__EQ_)
					tmp13 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{tmp11, tmp12}))
					tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5158), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5158), lang.NewKeyword("end-column"), int(17))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp16 := lang.Apply(tmp15, []any{v4})
					if lang.IsTruthy(tmp16) {
						var tmp17 any
						{ // let
							// let binding "temp__0__auto__"
							tmp18, _ := lang.FieldOrMethod(v3, "seqFrom")
							if reflect.TypeOf(tmp18).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
							}
							tmp19 := lang.Apply(tmp18, []any{v5, false})
							var v20 any = tmp19
							_ = v20
							var tmp21 any
							if lang.IsTruthy(v20) {
								var tmp22 any
								{ // let
									// let binding "vec__74"
									var v23 any = v20
									_ = v23
									// let binding "e"
									tmp24 := checkDerefVar(glojure_DOT_core_nth)
									tmp25 := lang.Apply(tmp24, []any{v23, int64(0), nil})
									var v26 any = tmp25
									_ = v26
									// let binding "s"
									var v27 any = v23
									_ = v27
									var tmp28 any
									tmp29 := lang.Apply(v9, []any{v26})
									if lang.IsTruthy(tmp29) {
										tmp28 = v27
									} else {
										tmp30 := checkDerefVar(glojure_DOT_core_next)
										tmp31 := lang.Apply(tmp30, []any{v27})
										tmp28 = tmp31
									}
									tmp22 = tmp28
								} // end let
								tmp21 = tmp22
							} else {
							}
							tmp17 = tmp21
						} // end let
						tmp10 = tmp17
					} else {
						tmp18 := checkDerefVar(glojure_DOT_core_take_while)
						tmp19, _ := lang.FieldOrMethod(v3, "seq")
						if reflect.TypeOf(tmp19).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("seq is not a function")))
						}
						tmp20 := lang.Apply(tmp19, []any{false})
						tmp21 := lang.Apply(tmp18, []any{v9, tmp20})
						tmp10 = tmp21
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var tmp8 any
				{ // let
					// let binding "temp__0__auto__"
					tmp9, _ := lang.FieldOrMethod(v3, "seqFrom")
					if reflect.TypeOf(tmp9).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
					}
					tmp10 := lang.Apply(tmp9, []any{v7, false})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						var tmp13 any
						{ // let
							// let binding "vec__77"
							var v14 any = v11
							_ = v14
							// let binding "e"
							tmp15 := checkDerefVar(glojure_DOT_core_nth)
							tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
							var v17 any = tmp16
							_ = v17
							// let binding "s"
							var v18 any = v14
							_ = v18
							tmp19 := checkDerefVar(glojure_DOT_core_take_while)
							tmp20 := checkDerefVar(glojure_DOT_core_mk_bound_fn)
							tmp21 := lang.Apply(tmp20, []any{v3, v4, v5})
							var tmp22 any
							tmp23 := checkDerefVar(glojure_DOT_core_mk_bound_fn)
							tmp24 := lang.Apply(tmp23, []any{v3, v6, v7})
							tmp25 := lang.Apply(tmp24, []any{v17})
							if lang.IsTruthy(tmp25) {
								tmp22 = v18
							} else {
								tmp26 := checkDerefVar(glojure_DOT_core_next)
								tmp27 := lang.Apply(tmp26, []any{v18})
								tmp22 = tmp27
							}
							tmp28 := lang.Apply(tmp19, []any{tmp21, tmp22})
							tmp13 = tmp28
						} // end let
						tmp12 = tmp13
					} else {
					}
					tmp8 = tmp12
				} // end let
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// run!
	{
		tmp0 := lang.NewSymbol("run!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("proc"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7708), lang.NewKeyword("end-line"), int(7708))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_reduce)
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v7 := args[0]
				_ = v7
				v8 := args[1]
				_ = v8
				tmp9 := lang.Apply(v3, []any{v8})
				return tmp9
			})
			tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7713), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(7713), lang.NewKeyword("end-column"), int(20))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := lang.Apply(tmp5, []any{tmp8, nil, v4})
			_ = tmp9
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// second
	{
		tmp0 := lang.NewSymbol("second").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Same as (first (next x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(91), lang.NewKeyword("end-line"), int(95))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function second
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_first)
				tmp6 := checkDerefVar(glojure_DOT_core_next)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(95), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(95), lang.NewKeyword("end-column"), int(49))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// select-keys
	{
		tmp0 := lang.NewSymbol("select-keys").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("keyseq"))), lang.NewKeyword("doc"), "Returns a map containing only those entries in map whose key is in keys", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1536), lang.NewKeyword("end-line"), int(1536))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "ret"
				tmp6 := lang.NewMap()
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1541), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(1541), lang.NewKeyword("end-column"), int(17))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v9 any = tmp8
				_ = v9
				// let binding "keys"
				tmp10 := checkDerefVar(glojure_DOT_core_seq)
				tmp11 := lang.Apply(tmp10, []any{v4})
				var v12 any = tmp11
				_ = v12
				for {
					var tmp13 any
					if lang.IsTruthy(v12) {
						var tmp14 any
						{ // let
							// let binding "entry"
							tmp15 := checkDerefVar(glojure_DOT_core_first)
							tmp16 := lang.Apply(tmp15, []any{v12})
							tmp17, _ := lang.FieldOrMethod(runtime7.RT, "Find")
							if reflect.TypeOf(tmp17).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("Find is not a function")))
							}
							tmp18 := lang.Apply(tmp17, []any{v3, tmp16})
							var v19 any = tmp18
							_ = v19
							var tmp21 any
							if lang.IsTruthy(v19) {
								tmp22 := checkDerefVar(glojure_DOT_core_conj)
								tmp23 := lang.Apply(tmp22, []any{v9, v19})
								tmp21 = tmp23
							} else {
								tmp21 = v9
							}
							var tmp20 any = tmp21
							tmp25 := checkDerefVar(glojure_DOT_core_next)
							tmp26 := lang.Apply(tmp25, []any{v12})
							var tmp24 any = tmp26
							v9 = tmp20
							v12 = tmp24
							continue
						} // end let
						tmp13 = tmp14
					} else {
						tmp15 := checkDerefVar(glojure_DOT_core_with_meta)
						tmp16 := checkDerefVar(glojure_DOT_core_meta)
						tmp17 := lang.Apply(tmp16, []any{v3})
						tmp18 := lang.Apply(tmp15, []any{v9, tmp17})
						tmp13 = tmp18
					}
					tmp5 = tmp13
					break
				}
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send
	{
		tmp0 := lang.NewSymbol("send").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread from a thread pool, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2109), lang.NewKeyword("end-line"), int(2109))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_apply)
				tmp7 := checkDerefVar(glojure_DOT_core_send_via)
				tmp8 := lang.Apply(tmp6, []any{tmp7, nil, v3, v4, v5})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send-off
	{
		tmp0 := lang.NewSymbol("send-off").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Dispatch a potentially blocking action to an agent. Returns the\n  agent immediately. Subsequently, in a separate thread, the state of\n  the agent will be set to the value of:\n\n  (apply action-fn state-of-agent args)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2120), lang.NewKeyword("end-line"), int(2120))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_apply)
				tmp7 := checkDerefVar(glojure_DOT_core_send_via)
				tmp8 := lang.Apply(tmp6, []any{tmp7, nil, v3, v4, v5})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send-via
	{
		tmp0 := lang.NewSymbol("send-via").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("executor"), lang.NewSymbol("a"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread supplied by executor, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2099), lang.NewKeyword("end-line"), int(2099))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					tmp8 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
					tmp9 := checkDerefVar(glojure_DOT_core_hash_map)
					tmp10 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*agent*"))
					tmp11 := lang.Apply(tmp9, []any{tmp10, v4})
					tmp12 := lang.Apply(tmp8, []any{tmp11})
					_ = tmp12
					var tmp13 any
					func() {
						defer func() {
							tmp14 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
							tmp15 := lang.Apply(tmp14, nil)
							_ = tmp15
						}()
						tmp16 := checkDerefVar(glojure_DOT_core_binding_conveyor_fn)
						tmp17 := lang.Apply(tmp16, []any{v5})
						tmp13 = tmp17
					}()
					tmp7 = tmp13
				} // end let
				tmp8, _ := lang.FieldOrMethod(v4, "dispatch")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("dispatch is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{tmp7, v6, v3})
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := lang.NewSymbol("seq").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a seq on the collection. If the collection is\n    empty, returns nil.  (seq nil) returns nil. seq also works on\n    Strings, native Java arrays (of reference types) and any objects\n    that implement Iterable. Note that seqs cache values, thus seq\n    should not be used on any Iterable whose iterator repeatedly\n    returns the same mutable object.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(4), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(126), lang.NewKeyword("end-line"), int(136))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		{ // function seq
			var v4 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.Seq, []any{v5})
				return tmp6
			})
			tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(136), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(136), lang.NewKeyword("end-column"), int(126))).(lang.FnFunc)
			v4 = tmp3
			_ = v4
		}
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq-to-map-for-destructuring
	{
		tmp0 := lang.NewSymbol("seq-to-map-for-destructuring").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Builds a map from a seq as described in\n  https://glojure.org/reference/special_forms#keyword-arguments", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(34), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4390), lang.NewKeyword("end-line"), int(4390))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_next)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(glojure_DOT_core_to_array)
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp9 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp8})
				tmp4 = tmp9
			} else {
				var tmp10 any
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := lang.Apply(tmp11, []any{v3})
				if lang.IsTruthy(tmp12) {
					tmp13 := checkDerefVar(glojure_DOT_core_first)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp10 = tmp14
				} else {
				}
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq?
	{
		tmp0 := lang.NewSymbol("seq?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x implements ISeq", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(146), lang.NewKeyword("end-line"), int(150))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function seq?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v4})
				return tmp7
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(150), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(150), lang.NewKeyword("end-column"), int(87))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seqable?
	{
		tmp0 := lang.NewSymbol("seqable?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if the seq function is supported for x", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6204), lang.NewKeyword("end-line"), int(6204))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seque
	{
		tmp0 := lang.NewSymbol("seque").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s")), lang.NewVector(lang.NewSymbol("n-or-q"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Creates a queued seq on another (presumably lazy) seq s. The queued\n  seq will produce a concrete seq in the background, and can get up to\n  n items ahead of the consumer. n-or-q can be an integer n buffer\n  size, or an instance of java.util.concurrent BlockingQueue. Note\n  that reading from a seque can block if the reader gets ahead of the\n  producer.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5419), lang.NewKeyword("end-line"), int(5419))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seque)
				tmp5 := lang.Apply(tmp4, []any{int64(100), v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "q"
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{nil, v3})
					if lang.IsTruthy(tmp8) {
						tmp6 = v3
					} else {
						tmp9 := checkDerefVar(glojure_DOT_core_int)
						tmp10 := lang.Apply(tmp9, []any{v3})
						tmp11 := lang.Apply(nil, []any{tmp10})
						tmp6 = tmp11
					}
					var v12 any = tmp6
					_ = v12
					// let binding "NIL"
					tmp13 := lang.Apply(reflect.StructOf, []any{nil})
					tmp14 := lang.Apply(reflect.New, []any{tmp13})
					tmp15, ok := lang.FieldOrMethod(tmp14, "Interface")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp14, "Interface")))
					}
					var tmp16 any
					switch reflect.TypeOf(tmp15).Kind() {
					case reflect.Func:
						tmp16 = lang.Apply(tmp15, nil)
					default:
						tmp16 = tmp15
					}
					var v17 any = tmp16
					_ = v17
					// let binding "agt"
					tmp18 := checkDerefVar(glojure_DOT_core_agent)
					var tmp19 lang.FnFunc
					tmp19 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						return v4
					})
					tmp20 := lang.Apply(lang.NewLazySeq, []any{tmp19})
					tmp21 := lang.Apply(tmp18, []any{tmp20})
					var v22 any = tmp21
					_ = v22
					// let binding "log-error"
					var tmp23 lang.FnFunc
					tmp23 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v24 := args[0]
						_ = v24
						v25 := args[1]
						_ = v25
						var tmp26 any
						tmp27, _ := lang.FieldOrMethod(v24, "offer")
						if reflect.TypeOf(tmp27).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
						}
						tmp28 := lang.Apply(tmp27, []any{v24})
						if lang.IsTruthy(tmp28) {
							panic(v25)
						} else {
							tmp26 = v25
						}
						return tmp26
					})
					tmp24 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5435), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(5438), lang.NewKeyword("end-column"), int(26))
					tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v26 any = tmp25
					_ = v26
					// let binding "fill"
					var tmp27 lang.FnFunc
					tmp27 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v28 := args[0]
						_ = v28
						var tmp29 any
						if lang.IsTruthy(v28) {
							var tmp30 any
							tmp31 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
							tmp32 := lang.Apply(tmp31, []any{nil, v28})
							if lang.IsTruthy(tmp32) {
								tmp33 := lang.Apply(v26, []any{v12, v28})
								tmp30 = tmp33
							} else {
								var tmp34 any
								func() {
									defer func() {
										if r := recover(); r != nil {
											if lang.CatchMatches(r, lang.Builtins["any"]) {
												v35 := r
												_ = v35
												tmp36 := lang.Apply(v26, []any{v12, v35})
												tmp34 = tmp36
											} else {
												panic(r)
											}
										}
									}()
									var tmp35 any
									{ // let
										// let binding "G__89"
										tmp36 := checkDerefVar(glojure_DOT_core_seq)
										tmp37 := lang.Apply(tmp36, []any{v28})
										var v38 any = tmp37
										_ = v38
										// let binding "vec__90"
										var v39 any = v38
										_ = v39
										// let binding "seq__91"
										tmp40 := checkDerefVar(glojure_DOT_core_seq)
										tmp41 := lang.Apply(tmp40, []any{v39})
										var v42 any = tmp41
										_ = v42
										// let binding "first__92"
										tmp43 := checkDerefVar(glojure_DOT_core_first)
										tmp44 := lang.Apply(tmp43, []any{v42})
										var v45 any = tmp44
										_ = v45
										// let binding "seq__91"
										tmp46 := checkDerefVar(glojure_DOT_core_next)
										tmp47 := lang.Apply(tmp46, []any{v42})
										var v48 any = tmp47
										_ = v48
										// let binding "x"
										var v49 any = v45
										_ = v49
										// let binding "xs"
										var v50 any = v48
										_ = v50
										// let binding "s"
										var v51 any = v39
										_ = v51
										var tmp52 any
										{ // let
											// let binding "G__89"
											var v53 any = v38
											_ = v53
											for {
												var tmp54 any
												{ // let
													// let binding "vec__93"
													var v55 any = v53
													_ = v55
													// let binding "seq__94"
													tmp56 := checkDerefVar(glojure_DOT_core_seq)
													tmp57 := lang.Apply(tmp56, []any{v55})
													var v58 any = tmp57
													_ = v58
													// let binding "first__95"
													tmp59 := checkDerefVar(glojure_DOT_core_first)
													tmp60 := lang.Apply(tmp59, []any{v58})
													var v61 any = tmp60
													_ = v61
													// let binding "seq__94"
													tmp62 := checkDerefVar(glojure_DOT_core_next)
													tmp63 := lang.Apply(tmp62, []any{v58})
													var v64 any = tmp63
													_ = v64
													// let binding "x"
													var v65 any = v61
													_ = v65
													// let binding "xs"
													var v66 any = v64
													_ = v66
													// let binding "s"
													var v67 any = v55
													_ = v67
													var tmp68 any
													if lang.IsTruthy(v67) {
														var tmp69 any
														var tmp70 any
														tmp71 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
														tmp72 := lang.Apply(tmp71, []any{v65})
														if lang.IsTruthy(tmp72) {
															tmp70 = v17
														} else {
															tmp70 = v65
														}
														tmp73, _ := lang.FieldOrMethod(v12, "offer")
														if reflect.TypeOf(tmp73).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
														}
														tmp74 := lang.Apply(tmp73, []any{tmp70})
														if lang.IsTruthy(tmp74) {
															var tmp75 any = v66
															v53 = tmp75
															continue
														} else {
															tmp69 = v67
														}
														tmp68 = tmp69
													} else {
														var tmp76 any
														tmp77, _ := lang.FieldOrMethod(v12, "offer")
														if reflect.TypeOf(tmp77).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
														}
														tmp78 := lang.Apply(tmp77, []any{v12})
														if lang.IsTruthy(tmp78) {
														} else {
															tmp76 = lang.NewList()
														}
														tmp68 = tmp76
													}
													tmp54 = tmp68
												} // end let
												tmp52 = tmp54
												break
											}
										} // end let
										tmp35 = tmp52
									} // end let
									tmp34 = tmp35
								}()
								tmp30 = tmp34
							}
							tmp29 = tmp30
						} else {
						}
						return tmp29
					})
					tmp28 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5439), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(5452), lang.NewKeyword("end-column"), int(44))
					tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v30 any = tmp29
					_ = v30
					// let binding "drain"
					var tmp31 lang.FnFunc
					{ // function drain
						var v32 lang.FnFunc
						tmp31 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							var tmp33 lang.FnFunc
							tmp33 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								var tmp34 any
								{ // let
									// let binding "x"
									tmp35, ok := lang.FieldOrMethod(v12, "take")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "take")))
									}
									var tmp36 any
									switch reflect.TypeOf(tmp35).Kind() {
									case reflect.Func:
										tmp36 = lang.Apply(tmp35, nil)
									default:
										tmp36 = tmp35
									}
									var v37 any = tmp36
									_ = v37
									var tmp38 any
									tmp39 := checkDerefVar(glojure_DOT_core_identical_QMARK_)
									tmp40 := lang.Apply(tmp39, []any{v37, v12})
									if lang.IsTruthy(tmp40) {
										tmp41 := checkDerefVar(glojure_DOT_core_deref)
										tmp42 := lang.Apply(tmp41, []any{v22})
										_ = tmp42
									} else {
										tmp43 := checkDerefVar(glojure_DOT_core_send_off)
										tmp44 := lang.Apply(tmp43, []any{v22, v30})
										_ = tmp44
										tmp45 := checkDerefVar(glojure_DOT_core_release_pending_sends)
										tmp46 := lang.Apply(tmp45, nil)
										_ = tmp46
										tmp47 := checkDerefVar(glojure_DOT_core_cons)
										var tmp48 any
										tmp49 := checkDerefVar(glojure_DOT_core_identical_QMARK_)
										tmp50 := lang.Apply(tmp49, []any{v37, v17})
										if lang.IsTruthy(tmp50) {
										} else {
											tmp48 = v37
										}
										tmp51 := lang.Apply(v32, nil)
										tmp52 := lang.Apply(tmp47, []any{tmp48, tmp51})
										tmp38 = tmp52
									}
									tmp34 = tmp38
								} // end let
								return tmp34
							})
							tmp34 := lang.Apply(lang.NewLazySeq, []any{tmp33})
							return tmp34
						})
						v32 = tmp31
						_ = v32
					}
					tmp32 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5453), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(5461), lang.NewKeyword("end-column"), int(73))
					tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v34 any = tmp33
					_ = v34
					tmp35 := checkDerefVar(glojure_DOT_core_send_off)
					tmp36 := lang.Apply(tmp35, []any{v22, v30})
					_ = tmp36
					tmp37 := lang.Apply(v34, nil)
					tmp5 = tmp37
				} // end let
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sequence
	{
		tmp0 := lang.NewSymbol("sequence").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("coll"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2639), lang.NewKeyword("end-line"), int(2639))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					tmp4 = v3
				} else {
					var tmp7 any
					{ // let
						// let binding "or__0__auto__"
						tmp8 := checkDerefVar(glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v3})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							tmp11 = v10
						} else {
							tmp11 = lang.NewList()
						}
						tmp7 = tmp11
					} // end let
					tmp4 = tmp7
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "or__0__auto__"
					tmp6 := lang.Apply(nil, []any{v4})
					tmp7 := lang.Apply(nil, []any{v3, tmp6})
					tmp8 := lang.Apply(nil, []any{tmp7})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp10 = v9
					} else {
						tmp10 = lang.NewList()
					}
					tmp5 = tmp10
				} // end let
				return tmp5
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "or__0__auto__"
					tmp7 := checkDerefVar(glojure_DOT_core_map)
					var tmp8 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v9 := args[0]
						_ = v9
						tmp10 := lang.Apply(nil, []any{v9})
						return tmp10
					})
					tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2661), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(2661), lang.NewKeyword("end-column"), int(41))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp11 := checkDerefVar(glojure_DOT_core_cons)
					tmp12 := lang.Apply(tmp11, []any{v4, v5})
					tmp13 := lang.Apply(tmp7, []any{tmp10, tmp12})
					tmp14 := lang.Apply(nil, []any{v3, tmp13})
					tmp15 := lang.Apply(nil, []any{tmp14})
					var v16 any = tmp15
					_ = v16
					var tmp17 any
					if lang.IsTruthy(v16) {
						tmp17 = v16
					} else {
						tmp17 = lang.NewList()
					}
					tmp6 = tmp17
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sequential?
	{
		tmp0 := lang.NewSymbol("sequential?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll implements Sequential", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6229), lang.NewKeyword("end-line"), int(6229))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Sequential)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// serialized-require
	{
		tmp0 := lang.NewSymbol("serialized-require").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Like 'require', but serializes loading.\n  Interim function preferred over 'require' for known asynchronous loads.\n  Future changes may make these equivalent.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6059), lang.NewKeyword("end-line"), int(6059), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "lockee__0__auto__"
					var v5 any = nil
					_ = v5
					var tmp6 any
					func() {
						var tmp7 any
						{ // let
							// let binding "locklocal__1__auto__"
							var v8 any = v5
							_ = v8
							tmp9 := lang.Apply(nil, []any{v8})
							_ = tmp9
							var tmp10 any
							func() {
								defer func() {
									tmp11 := lang.Apply(nil, []any{v8})
									_ = tmp11
								}()
								tmp12 := checkDerefVar(glojure_DOT_core_apply)
								tmp13 := checkDerefVar(glojure_DOT_core_require)
								tmp14 := lang.Apply(tmp12, []any{tmp13, v3})
								tmp10 = tmp14
							}()
							tmp7 = tmp10
						} // end let
						tmp6 = tmp7
					}()
					tmp4 = tmp6
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set
	{
		tmp0 := lang.NewSymbol("set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a set of the distinct elements of coll.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4104), lang.NewKeyword("end-line"), int(4104))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_set_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(glojure_DOT_core_with_meta)
				tmp8 := lang.Apply(tmp7, []any{v3, nil})
				tmp4 = tmp8
			} else {
				var tmp9 any
				tmp10 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp11 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
				tmp12 := lang.Apply(tmp10, []any{tmp11, v3})
				if lang.IsTruthy(tmp12) {
					tmp13 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
					tmp14 := checkDerefVar(glojure_DOT_core_conj_BANG_)
					tmp15 := checkDerefVar(glojure_DOT_core_transient)
					tmp16 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4112), lang.NewKeyword("column"), int(108), lang.NewKeyword("end-line"), int(4112), lang.NewKeyword("end-column"), int(110))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp19 := lang.Apply(tmp15, []any{tmp18})
					tmp20, _ := lang.FieldOrMethod(v3, "ReduceInit")
					if reflect.TypeOf(tmp20).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
					}
					tmp21 := lang.Apply(tmp20, []any{tmp14, tmp19})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp9 = tmp22
				} else {
					tmp23 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
					tmp24 := checkDerefVar(glojure_DOT_core_reduce1)
					tmp25 := checkDerefVar(glojure_DOT_core_conj_BANG_)
					tmp26 := checkDerefVar(glojure_DOT_core_transient)
					tmp27 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp28 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4113), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(4113), lang.NewKeyword("end-column"), int(48))
					tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp30 := lang.Apply(tmp26, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp25, tmp30, v3})
					tmp32 := lang.Apply(tmp23, []any{tmp31})
					tmp9 = tmp32
				}
				tmp4 = tmp9
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-agent-send-executor!
	{
		tmp0 := lang.NewSymbol("set-agent-send-executor!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("executor"))), lang.NewKeyword("doc"), "Sets the ExecutorService to be used by send", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(30), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2087), lang.NewKeyword("end-line"), int(2087))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-agent-send-off-executor!
	{
		tmp0 := lang.NewSymbol("set-agent-send-off-executor!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("executor"))), lang.NewKeyword("doc"), "Sets the ExecutorService to be used by send-off", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(34), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2093), lang.NewKeyword("end-line"), int(2093))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-error-handler!
	{
		tmp0 := lang.NewSymbol("set-error-handler!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("handler-fn"))), lang.NewKeyword("doc"), "Sets the error-handler of agent a to handler-fn.  If an action\n  being run by the agent throws an exception or doesn't pass the\n  validator fn, handler-fn will be called with two arguments: the\n  agent and the exception.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2192), lang.NewKeyword("end-line"), int(2192))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "setErrorHandler")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorHandler is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-error-mode!
	{
		tmp0 := lang.NewSymbol("set-error-mode!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("mode-keyword"))), lang.NewKeyword("doc"), "Sets the error-mode of agent a to mode-keyword, which must be\n  either :fail or :continue.  If an action being run by the agent\n  throws an exception or doesn't pass the validator fn, an\n  error-handler may be called (see set-error-handler!), after which,\n  if the mode is :continue, the agent will continue as if neither the\n  action that caused the error nor the error itself ever happened.\n  \n  If the mode is :fail, the agent will become failed and will stop\n  accepting new 'send' and 'send-off' actions, and any previously\n  queued actions will be held until a 'restart-agent'.  Deref will\n  still work, returning the state of the agent before the error.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2210), lang.NewKeyword("end-line"), int(2210))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "setErrorMode")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorMode is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-validator!
	{
		tmp0 := lang.NewSymbol("set-validator!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("iref"), lang.NewSymbol("validator-fn"))), lang.NewKeyword("doc"), "Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an exception. If the current state (root\n  value if var) is not acceptable to the new validator, an exception\n  will be thrown and the validator will not be changed.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2381), lang.NewKeyword("end-line"), int(2381))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "setValidator")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setValidator is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set?
	{
		tmp0 := lang.NewSymbol("set?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x implements IPersistentSet", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4098), lang.NewKeyword("end-line"), int(4098))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.IPersistentSet)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// setup-reference
	{
		tmp0 := lang.NewSymbol("setup-reference").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2043), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(2044), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("r"), lang.NewSymbol("options"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "opts"
				tmp6 := checkDerefVar(glojure_DOT_core_apply)
				tmp7 := checkDerefVar(glojure_DOT_core_hash_map)
				tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				tmp11 := lang.Apply(lang.NewKeyword("meta"), []any{v9})
				if lang.IsTruthy(tmp11) {
					tmp12 := lang.Apply(lang.NewKeyword("meta"), []any{v9})
					tmp13, _ := lang.FieldOrMethod(v3, "ResetMeta")
					if reflect.TypeOf(tmp13).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ResetMeta is not a function")))
					}
					tmp14 := lang.Apply(tmp13, []any{tmp12})
					tmp10 = tmp14
				} else {
				}
				_ = tmp10
				var tmp15 any
				tmp16 := lang.Apply(lang.NewKeyword("validator"), []any{v9})
				if lang.IsTruthy(tmp16) {
					tmp17 := lang.Apply(lang.NewKeyword("validator"), []any{v9})
					tmp18, _ := lang.FieldOrMethod(v3, "setValidator")
					if reflect.TypeOf(tmp18).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setValidator is not a function")))
					}
					tmp19 := lang.Apply(tmp18, []any{tmp17})
					tmp15 = tmp19
				} else {
				}
				_ = tmp15
				tmp5 = v3
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shift-mask
	{
		tmp0 := lang.NewSymbol("shift-mask").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6598), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(6598), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("shift"), lang.NewSymbol("mask"), lang.NewSymbol("x"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := checkDerefVar(glojure_DOT_core_bit_and)
			tmp7 := checkDerefVar(glojure_DOT_core_bit_shift_right)
			tmp8 := lang.Apply(tmp7, []any{v5, v3})
			tmp9 := lang.Apply(tmp6, []any{tmp8, v4})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// short
	{
		var tmp1 lang.FnFunc
		{ // function short__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(glojure_DOT_core__STAR_unchecked_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = lang.NewSymbol("uncheckedShortCast")
				} else {
					tmp14 = lang.NewSymbol("shortCast")
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("short").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to short", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3499), lang.NewKeyword("end-line"), int(3499))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.ShortCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// short-array
	{
		var tmp1 lang.FnFunc
		{ // function short-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(glojure_DOT_core_seq)
					tmp5 := checkDerefVar(glojure_DOT_core_concat)
					tmp6 := checkDerefVar(glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
					tmp8 := checkDerefVar(glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp10 := checkDerefVar(glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/ShortArray")})
					tmp12 := checkDerefVar(glojure_DOT_core_list)
					tmp13 := checkDerefVar(glojure_DOT_core_seq)
					tmp14 := checkDerefVar(glojure_DOT_core_concat)
					tmp15 := checkDerefVar(glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.core/args")})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("short-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of shorts", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5333), lang.NewKeyword("end-line"), int(5333))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "ShortArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShortArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ShortArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShortArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shorts
	{
		var tmp1 lang.FnFunc
		{ // function shorts
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{lang.NewSymbol("glojure.core/Shorts")})
				tmp12 := checkDerefVar(glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("shorts").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to shorts[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5387), lang.NewKeyword("end-line"), int(5387))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Shorts")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Shorts is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shuffle
	{
		tmp0 := lang.NewSymbol("shuffle").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return a random permutation of coll", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7300), lang.NewKeyword("end-line"), int(7300))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "al"
				tmp5 := checkDerefVar(glojure_DOT_core_to_array)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(lang.NewArrayList, []any{tmp6})
				var v8 any = tmp7
				_ = v8
				tmp9 := lang.Apply(nil, []any{v8})
				_ = tmp9
				tmp10, ok := lang.FieldOrMethod(v8, "toArray")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "toArray")))
				}
				var tmp11 any
				switch reflect.TypeOf(tmp10).Kind() {
				case reflect.Func:
					tmp11 = lang.Apply(tmp10, nil)
				default:
					tmp11 = tmp10
				}
				tmp12 := lang.Apply(nil, []any{tmp11})
				tmp4 = tmp12
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shutdown-agents
	{
		tmp0 := lang.NewSymbol("shutdown-agents").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Initiates a shutdown of the thread pools that back the agent\n  system. Running actions will complete, but no new actions will be\n  accepted", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2252), lang.NewKeyword("end-line"), int(2252))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(lang.ShutdownAgents, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sigs
	{
		tmp0 := lang.NewSymbol("sigs").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(223), lang.NewKeyword("column"), int(2), lang.NewKeyword("end-line"), int(224), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_assert_valid_fdecl)
			tmp5 := lang.Apply(tmp4, []any{v3})
			_ = tmp5
			var tmp6 any
			{ // let
				// let binding "asig"
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v8 := args[0]
					_ = v8
					var tmp9 any
					{ // let
						// let binding "arglist"
						tmp10 := checkDerefVar(glojure_DOT_core_first)
						tmp11 := lang.Apply(tmp10, []any{v8})
						var v12 any = tmp11
						_ = v12
						// let binding "arglist"
						var tmp13 any
						tmp14 := checkDerefVar(glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v12})
						tmp16 := lang.Apply(lang.Equals, []any{lang.NewSymbol("&form"), tmp15})
						if lang.IsTruthy(tmp16) {
							tmp17 := lang.Apply(lang.Count, []any{v12})
							tmp18 := lang.Apply(lang.Subvec, []any{v12, int64(2), tmp17})
							tmp13 = tmp18
						} else {
							tmp13 = v12
						}
						var v19 any = tmp13
						_ = v19
						// let binding "body"
						tmp20 := checkDerefVar(glojure_DOT_core_next)
						tmp21 := lang.Apply(tmp20, []any{v8})
						var v22 any = tmp21
						_ = v22
						var tmp23 any
						tmp24 := checkDerefVar(glojure_DOT_core_map_QMARK_)
						tmp25 := checkDerefVar(glojure_DOT_core_first)
						tmp26 := lang.Apply(tmp25, []any{v22})
						tmp27 := lang.Apply(tmp24, []any{tmp26})
						if lang.IsTruthy(tmp27) {
							var tmp28 any
							tmp29 := checkDerefVar(glojure_DOT_core_next)
							tmp30 := lang.Apply(tmp29, []any{v22})
							if lang.IsTruthy(tmp30) {
								tmp31 := checkDerefVar(glojure_DOT_core_with_meta)
								tmp32 := checkDerefVar(glojure_DOT_core_conj)
								var tmp33 any
								tmp34 := checkDerefVar(glojure_DOT_core_meta)
								tmp35 := lang.Apply(tmp34, []any{v19})
								if lang.IsTruthy(tmp35) {
									tmp36 := checkDerefVar(glojure_DOT_core_meta)
									tmp37 := lang.Apply(tmp36, []any{v19})
									tmp33 = tmp37
								} else {
									tmp38 := lang.NewMap()
									tmp39 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(237), lang.NewKeyword("column"), int(77), lang.NewKeyword("end-line"), int(237), lang.NewKeyword("end-column"), int(78))
									tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp33 = tmp40
								}
								tmp41 := checkDerefVar(glojure_DOT_core_first)
								tmp42 := lang.Apply(tmp41, []any{v22})
								tmp43 := lang.Apply(tmp32, []any{tmp33, tmp42})
								tmp44 := lang.Apply(tmp31, []any{v19, tmp43})
								tmp28 = tmp44
							} else {
								tmp28 = v19
							}
							tmp23 = tmp28
						} else {
							tmp23 = v19
						}
						tmp9 = tmp23
					} // end let
					return tmp9
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(228), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(239), lang.NewKeyword("end-column"), int(25))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v10 any = tmp9
				_ = v10
				// let binding "resolve-tag"
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v12 := args[0]
					_ = v12
					var tmp13 any
					{ // let
						// let binding "m"
						tmp14 := checkDerefVar(glojure_DOT_core_meta)
						tmp15 := lang.Apply(tmp14, []any{v12})
						var v16 any = tmp15
						_ = v16
						// let binding "tag"
						tmp17 := lang.Apply(lang.NewKeyword("tag"), []any{v16})
						var v18 any = tmp17
						_ = v18
						var tmp19 any
						tmp20 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
						tmp21 := reflect.TypeOf((*lang.Symbol)(nil))
						tmp22 := lang.Apply(tmp20, []any{tmp21, v18})
						if lang.IsTruthy(tmp22) {
							var tmp23 any
							tmp24, ok := lang.FieldOrMethod(v18, "Name")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v18, "Name")))
							}
							var tmp25 any
							switch reflect.TypeOf(tmp24).Kind() {
							case reflect.Func:
								tmp25 = lang.Apply(tmp24, nil)
							default:
								tmp25 = tmp24
							}
							tmp26 := lang.Apply(strings11.Index, []any{tmp25, "."})
							tmp27 := lang.Apply(lang.Equiv, []any{tmp26, int64(-1)})
							if lang.IsTruthy(tmp27) {
								var tmp28 any
								tmp29 := lang.Apply(lang.Equals, []any{nil, nil})
								if lang.IsTruthy(tmp29) {
									var tmp30 any
									{ // let
										// let binding "c"
										var v31 any = nil
										_ = v31
										var tmp32 any
										if lang.IsTruthy(v31) {
											tmp33 := checkDerefVar(glojure_DOT_core_with_meta)
											tmp34 := checkDerefVar(glojure_DOT_core_assoc)
											tmp35, ok := lang.FieldOrMethod(v31, "Name")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v31, "Name")))
											}
											var tmp36 any
											switch reflect.TypeOf(tmp35).Kind() {
											case reflect.Func:
												tmp36 = lang.Apply(tmp35, nil)
											default:
												tmp36 = tmp35
											}
											tmp37 := lang.Apply(lang.NewSymbol, []any{tmp36})
											tmp38 := lang.Apply(tmp34, []any{v16, lang.NewKeyword("tag"), tmp37})
											tmp39 := lang.Apply(tmp33, []any{v12, tmp38})
											tmp32 = tmp39
										} else {
											tmp32 = v12
										}
										tmp30 = tmp32
									} // end let
									tmp28 = tmp30
								} else {
									tmp28 = v12
								}
								tmp23 = tmp28
							} else {
								tmp23 = v12
							}
							tmp19 = tmp23
						} else {
							tmp19 = v12
						}
						tmp13 = tmp19
					} // end let
					return tmp13
				})
				tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(240), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(252), lang.NewKeyword("end-column"), int(37))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v14 any = tmp13
				_ = v14
				var tmp15 any
				tmp16 := checkDerefVar(glojure_DOT_core_seq_QMARK_)
				tmp17 := checkDerefVar(glojure_DOT_core_first)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp16, []any{tmp18})
				if lang.IsTruthy(tmp19) {
					var tmp20 any
					{ // let
						// let binding "ret"
						tmp21 := lang.NewVector()
						tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(254), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(254), lang.NewKeyword("end-column"), int(20))
						tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v24 any = tmp23
						_ = v24
						// let binding "fdecls"
						var v25 any = v3
						_ = v25
						for {
							var tmp26 any
							if lang.IsTruthy(v25) {
								tmp28 := checkDerefVar(glojure_DOT_core_conj)
								tmp29 := checkDerefVar(glojure_DOT_core_first)
								tmp30 := lang.Apply(tmp29, []any{v25})
								tmp31 := lang.Apply(v10, []any{tmp30})
								tmp32 := lang.Apply(v14, []any{tmp31})
								tmp33 := lang.Apply(tmp28, []any{v24, tmp32})
								var tmp27 any = tmp33
								tmp35 := checkDerefVar(glojure_DOT_core_next)
								tmp36 := lang.Apply(tmp35, []any{v25})
								var tmp34 any = tmp36
								v24 = tmp27
								v25 = tmp34
								continue
							} else {
								tmp37 := checkDerefVar(glojure_DOT_core_seq)
								tmp38 := lang.Apply(tmp37, []any{v24})
								tmp26 = tmp38
							}
							tmp20 = tmp26
							break
						}
					} // end let
					tmp15 = tmp20
				} else {
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := lang.Apply(v10, []any{v3})
					tmp23 := lang.Apply(v14, []any{tmp22})
					tmp24 := lang.Apply(tmp21, []any{tmp23})
					tmp15 = tmp24
				}
				tmp6 = tmp15
			} // end let
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(225), lang.NewKeyword("column"), int(2), lang.NewKeyword("end-line"), int(258), lang.NewKeyword("end-column"), int(43))).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-ident?
	{
		tmp0 := lang.NewSymbol("simple-ident?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a symbol or keyword without a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1613), lang.NewKeyword("end-line"), int(1613))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_ident_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
					tmp10 := checkDerefVar(glojure_DOT_core_namespace)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					tmp8 = tmp12
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-keyword?
	{
		tmp0 := lang.NewSymbol("simple-keyword?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a keyword without a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1633), lang.NewKeyword("end-line"), int(1633))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_keyword_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
					tmp10 := checkDerefVar(glojure_DOT_core_namespace)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					tmp8 = tmp12
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-symbol?
	{
		tmp0 := lang.NewSymbol("simple-symbol?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a symbol without a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1623), lang.NewKeyword("end-line"), int(1623))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
					tmp10 := checkDerefVar(glojure_DOT_core_namespace)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					tmp8 = tmp12
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// slurp
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("slurp").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("opts"))), lang.NewKeyword("doc"), "Opens a reader on f and reads all its contents, returning a string.\n  See glojure.java.io/reader for a complete list of supported arguments.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6982), lang.NewKeyword("end-line"), int(6982))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				var v5 any = lang.NewList(args[1:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "opts"
					tmp7 := checkDerefVar(glojure_DOT_core_normalize_slurp_opts)
					tmp8 := lang.Apply(tmp7, []any{v5})
					var v9 any = tmp8
					_ = v9
					// let binding "sw"
					var v10 any = "unimplemented: new with non-constant class type"
					_ = v10
					var tmp11 any
					{ // let
						// let binding "r"
						tmp12 := checkDerefVar(glojure_DOT_core_apply)
						tmp13 := checkDerefVar(glojure_DOT_go_DOT_io_reader)
						tmp14 := lang.Apply(tmp12, []any{tmp13, v4, v9})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						func() {
							defer func() {
								tmp17, ok := lang.FieldOrMethod(v15, "close")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v15, "close")))
								}
								var tmp18 any
								switch reflect.TypeOf(tmp17).Kind() {
								case reflect.Func:
									tmp18 = lang.Apply(tmp17, nil)
								default:
									tmp18 = tmp17
								}
								_ = tmp18
							}()
							tmp19 := checkDerefVar(glojure_DOT_go_DOT_io_copy)
							tmp20 := lang.Apply(tmp19, []any{v15, v10})
							_ = tmp20
							tmp21 := lang.Apply(lang.ToString, []any{v10})
							tmp16 = tmp21
						}()
						tmp11 = tmp16
					} // end let
					tmp6 = tmp11
				} // end let
				return tmp6
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some
	{
		tmp0 := lang.NewSymbol("some").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2684), lang.NewKeyword("end-line"), int(2684))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
		recur_loop_481:
			var tmp5 any
			{ // let
				// let binding "temp__0__auto__"
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := lang.Apply(tmp6, []any{v4})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "s"
						var v11 any = v8
						_ = v11
						var tmp12 any
						{ // let
							// let binding "or__0__auto__"
							tmp13 := checkDerefVar(glojure_DOT_core_first)
							tmp14 := lang.Apply(tmp13, []any{v11})
							tmp15 := lang.Apply(v3, []any{tmp14})
							var v16 any = tmp15
							_ = v16
							var tmp17 any
							if lang.IsTruthy(v16) {
								tmp17 = v16
							} else {
								var tmp18 any = v3
								tmp20 := checkDerefVar(glojure_DOT_core_next)
								tmp21 := lang.Apply(tmp20, []any{v11})
								var tmp19 any = tmp21
								v3 = tmp18
								v4 = tmp19
								goto recur_loop_481
							}
							tmp12 = tmp17
						} // end let
						tmp10 = tmp12
					} // end let
					tmp9 = tmp10
				} else {
				}
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some->
	{
		tmp0 := lang.NewSymbol("some->").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7610), lang.NewKeyword("end-line"), int(7610))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := checkDerefVar(glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, nil)
					var v10 any = tmp9
					_ = v10
					// let binding "steps"
					tmp11 := checkDerefVar(glojure_DOT_core_map)
					var tmp12 lang.FnFunc
					tmp12 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v13 := args[0]
						_ = v13
						tmp14 := checkDerefVar(glojure_DOT_core_seq)
						tmp15 := checkDerefVar(glojure_DOT_core_concat)
						tmp16 := checkDerefVar(glojure_DOT_core_list)
						tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("if")})
						tmp18 := checkDerefVar(glojure_DOT_core_list)
						tmp19 := checkDerefVar(glojure_DOT_core_seq)
						tmp20 := checkDerefVar(glojure_DOT_core_concat)
						tmp21 := checkDerefVar(glojure_DOT_core_list)
						tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/nil?")})
						tmp23 := checkDerefVar(glojure_DOT_core_list)
						tmp24 := lang.Apply(tmp23, []any{v10})
						tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
						tmp26 := lang.Apply(tmp19, []any{tmp25})
						tmp27 := lang.Apply(tmp18, []any{tmp26})
						tmp28 := checkDerefVar(glojure_DOT_core_list)
						tmp29 := lang.Apply(tmp28, []any{nil})
						tmp30 := checkDerefVar(glojure_DOT_core_list)
						tmp31 := checkDerefVar(glojure_DOT_core_seq)
						tmp32 := checkDerefVar(glojure_DOT_core_concat)
						tmp33 := checkDerefVar(glojure_DOT_core_list)
						tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/->")})
						tmp35 := checkDerefVar(glojure_DOT_core_list)
						tmp36 := lang.Apply(tmp35, []any{v10})
						tmp37 := checkDerefVar(glojure_DOT_core_list)
						tmp38 := lang.Apply(tmp37, []any{v13})
						tmp39 := lang.Apply(tmp32, []any{tmp34, tmp36, tmp38})
						tmp40 := lang.Apply(tmp31, []any{tmp39})
						tmp41 := lang.Apply(tmp30, []any{tmp40})
						tmp42 := lang.Apply(tmp15, []any{tmp17, tmp27, tmp29, tmp41})
						tmp43 := lang.Apply(tmp14, []any{tmp42})
						return tmp43
					})
					tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7616), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7616), lang.NewKeyword("end-column"), int(64))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := lang.Apply(tmp11, []any{tmp14, v6})
					var v16 any = tmp15
					_ = v16
					tmp17 := checkDerefVar(glojure_DOT_core_seq)
					tmp18 := checkDerefVar(glojure_DOT_core_concat)
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{lang.NewSymbol("glojure.core/let")})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := checkDerefVar(glojure_DOT_core_apply)
					tmp23 := checkDerefVar(glojure_DOT_core_vector)
					tmp24 := checkDerefVar(glojure_DOT_core_seq)
					tmp25 := checkDerefVar(glojure_DOT_core_concat)
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v10})
					tmp28 := checkDerefVar(glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{v5})
					tmp30 := checkDerefVar(glojure_DOT_core_interleave)
					tmp31 := checkDerefVar(glojure_DOT_core_repeat)
					tmp32 := lang.Apply(tmp31, []any{v10})
					tmp33 := checkDerefVar(glojure_DOT_core_butlast)
					tmp34 := lang.Apply(tmp33, []any{v16})
					tmp35 := lang.Apply(tmp30, []any{tmp32, tmp34})
					tmp36 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp35})
					tmp37 := lang.Apply(tmp24, []any{tmp36})
					tmp38 := lang.Apply(tmp22, []any{tmp23, tmp37})
					tmp39 := lang.Apply(tmp21, []any{tmp38})
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					var tmp41 any
					tmp42 := checkDerefVar(glojure_DOT_core_empty_QMARK_)
					tmp43 := lang.Apply(tmp42, []any{v16})
					if lang.IsTruthy(tmp43) {
						tmp41 = v10
					} else {
						tmp44 := checkDerefVar(glojure_DOT_core_last)
						tmp45 := lang.Apply(tmp44, []any{v16})
						tmp41 = tmp45
					}
					tmp46 := lang.Apply(tmp40, []any{tmp41})
					tmp47 := lang.Apply(tmp18, []any{tmp20, tmp39, tmp46})
					tmp48 := lang.Apply(tmp17, []any{tmp47})
					tmp7 = tmp48
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some->>
	{
		tmp0 := lang.NewSymbol("some->>").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7624), lang.NewKeyword("end-line"), int(7624))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := checkDerefVar(glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, nil)
					var v10 any = tmp9
					_ = v10
					// let binding "steps"
					tmp11 := checkDerefVar(glojure_DOT_core_map)
					var tmp12 lang.FnFunc
					tmp12 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v13 := args[0]
						_ = v13
						tmp14 := checkDerefVar(glojure_DOT_core_seq)
						tmp15 := checkDerefVar(glojure_DOT_core_concat)
						tmp16 := checkDerefVar(glojure_DOT_core_list)
						tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("if")})
						tmp18 := checkDerefVar(glojure_DOT_core_list)
						tmp19 := checkDerefVar(glojure_DOT_core_seq)
						tmp20 := checkDerefVar(glojure_DOT_core_concat)
						tmp21 := checkDerefVar(glojure_DOT_core_list)
						tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/nil?")})
						tmp23 := checkDerefVar(glojure_DOT_core_list)
						tmp24 := lang.Apply(tmp23, []any{v10})
						tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
						tmp26 := lang.Apply(tmp19, []any{tmp25})
						tmp27 := lang.Apply(tmp18, []any{tmp26})
						tmp28 := checkDerefVar(glojure_DOT_core_list)
						tmp29 := lang.Apply(tmp28, []any{nil})
						tmp30 := checkDerefVar(glojure_DOT_core_list)
						tmp31 := checkDerefVar(glojure_DOT_core_seq)
						tmp32 := checkDerefVar(glojure_DOT_core_concat)
						tmp33 := checkDerefVar(glojure_DOT_core_list)
						tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/->>")})
						tmp35 := checkDerefVar(glojure_DOT_core_list)
						tmp36 := lang.Apply(tmp35, []any{v10})
						tmp37 := checkDerefVar(glojure_DOT_core_list)
						tmp38 := lang.Apply(tmp37, []any{v13})
						tmp39 := lang.Apply(tmp32, []any{tmp34, tmp36, tmp38})
						tmp40 := lang.Apply(tmp31, []any{tmp39})
						tmp41 := lang.Apply(tmp30, []any{tmp40})
						tmp42 := lang.Apply(tmp15, []any{tmp17, tmp27, tmp29, tmp41})
						tmp43 := lang.Apply(tmp14, []any{tmp42})
						return tmp43
					})
					tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7630), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7630), lang.NewKeyword("end-column"), int(65))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := lang.Apply(tmp11, []any{tmp14, v6})
					var v16 any = tmp15
					_ = v16
					tmp17 := checkDerefVar(glojure_DOT_core_seq)
					tmp18 := checkDerefVar(glojure_DOT_core_concat)
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{lang.NewSymbol("glojure.core/let")})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := checkDerefVar(glojure_DOT_core_apply)
					tmp23 := checkDerefVar(glojure_DOT_core_vector)
					tmp24 := checkDerefVar(glojure_DOT_core_seq)
					tmp25 := checkDerefVar(glojure_DOT_core_concat)
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v10})
					tmp28 := checkDerefVar(glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{v5})
					tmp30 := checkDerefVar(glojure_DOT_core_interleave)
					tmp31 := checkDerefVar(glojure_DOT_core_repeat)
					tmp32 := lang.Apply(tmp31, []any{v10})
					tmp33 := checkDerefVar(glojure_DOT_core_butlast)
					tmp34 := lang.Apply(tmp33, []any{v16})
					tmp35 := lang.Apply(tmp30, []any{tmp32, tmp34})
					tmp36 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp35})
					tmp37 := lang.Apply(tmp24, []any{tmp36})
					tmp38 := lang.Apply(tmp22, []any{tmp23, tmp37})
					tmp39 := lang.Apply(tmp21, []any{tmp38})
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					var tmp41 any
					tmp42 := checkDerefVar(glojure_DOT_core_empty_QMARK_)
					tmp43 := lang.Apply(tmp42, []any{v16})
					if lang.IsTruthy(tmp43) {
						tmp41 = v10
					} else {
						tmp44 := checkDerefVar(glojure_DOT_core_last)
						tmp45 := lang.Apply(tmp44, []any{v16})
						tmp41 = tmp45
					}
					tmp46 := lang.Apply(tmp40, []any{tmp41})
					tmp47 := lang.Apply(tmp18, []any{tmp20, tmp39, tmp46})
					tmp48 := lang.Apply(tmp17, []any{tmp47})
					tmp7 = tmp48
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some-fn
	{
		tmp0 := lang.NewSymbol("some-fn").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("p")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2"), lang.NewSymbol("p3")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2"), lang.NewSymbol("p3"), lang.NewSymbol("&"), lang.NewSymbol("ps"))), lang.NewKeyword("doc"), "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7462), lang.NewKeyword("end-line"), int(7462))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				{ // function sp1
					var v5 lang.FnFunc
					tmp4 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v6 := args[0]
							_ = v6
							tmp7 := lang.Apply(v3, []any{v6})
							return tmp7
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							var tmp8 any
							{ // let
								// let binding "or__0__auto__"
								tmp9 := lang.Apply(v3, []any{v6})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								if lang.IsTruthy(v10) {
									tmp11 = v10
								} else {
									tmp12 := lang.Apply(v3, []any{v7})
									tmp11 = tmp12
								}
								tmp8 = tmp11
							} // end let
							return tmp8
						case 3:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v3, []any{v6})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									var tmp13 any
									{ // let
										// let binding "or__0__auto__"
										tmp14 := lang.Apply(v3, []any{v7})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp16 = v15
										} else {
											tmp17 := lang.Apply(v3, []any{v8})
											tmp16 = tmp17
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var v9 any = lang.NewList(args[3:]...)
							_ = v9
							var tmp10 any
							{ // let
								// let binding "or__0__auto__"
								tmp11 := lang.Apply(v5, []any{v6, v7, v8})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp13 = v12
								} else {
									tmp14 := checkDerefVar(glojure_DOT_core_some)
									tmp15 := lang.Apply(tmp14, []any{v3, v9})
									tmp13 = tmp15
								}
								tmp10 = tmp13
							} // end let
							return tmp10
						}
					})
					v5 = tmp4
					_ = v5
				}
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7469), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7475), lang.NewKeyword("end-column"), int(43))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				{ // function sp2
					var v6 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v7 := args[0]
							_ = v7
							var tmp8 any
							{ // let
								// let binding "or__0__auto__"
								tmp9 := lang.Apply(v3, []any{v7})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								if lang.IsTruthy(v10) {
									tmp11 = v10
								} else {
									tmp12 := lang.Apply(v4, []any{v7})
									tmp11 = tmp12
								}
								tmp8 = tmp11
							} // end let
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v3, []any{v7})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									var tmp13 any
									{ // let
										// let binding "or__0__auto__"
										tmp14 := lang.Apply(v3, []any{v8})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp16 = v15
										} else {
											var tmp17 any
											{ // let
												// let binding "or__0__auto__"
												tmp18 := lang.Apply(v4, []any{v7})
												var v19 any = tmp18
												_ = v19
												var tmp20 any
												if lang.IsTruthy(v19) {
													tmp20 = v19
												} else {
													tmp21 := lang.Apply(v4, []any{v8})
													tmp20 = tmp21
												}
												tmp17 = tmp20
											} // end let
											tmp16 = tmp17
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						case 3:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var tmp10 any
							{ // let
								// let binding "or__0__auto__"
								tmp11 := lang.Apply(v3, []any{v7})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp13 = v12
								} else {
									var tmp14 any
									{ // let
										// let binding "or__0__auto__"
										tmp15 := lang.Apply(v3, []any{v8})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											tmp17 = v16
										} else {
											var tmp18 any
											{ // let
												// let binding "or__0__auto__"
												tmp19 := lang.Apply(v3, []any{v9})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													tmp21 = v20
												} else {
													var tmp22 any
													{ // let
														// let binding "or__0__auto__"
														tmp23 := lang.Apply(v4, []any{v7})
														var v24 any = tmp23
														_ = v24
														var tmp25 any
														if lang.IsTruthy(v24) {
															tmp25 = v24
														} else {
															var tmp26 any
															{ // let
																// let binding "or__0__auto__"
																tmp27 := lang.Apply(v4, []any{v8})
																var v28 any = tmp27
																_ = v28
																var tmp29 any
																if lang.IsTruthy(v28) {
																	tmp29 = v28
																} else {
																	tmp30 := lang.Apply(v4, []any{v9})
																	tmp29 = tmp30
																}
																tmp26 = tmp29
															} // end let
															tmp25 = tmp26
														}
														tmp22 = tmp25
													} // end let
													tmp21 = tmp22
												}
												tmp18 = tmp21
											} // end let
											tmp17 = tmp18
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								}
								tmp10 = tmp13
							} // end let
							return tmp10
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var v10 any = lang.NewList(args[3:]...)
							_ = v10
							var tmp11 any
							{ // let
								// let binding "or__0__auto__"
								tmp12 := lang.Apply(v6, []any{v7, v8, v9})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp14 = v13
								} else {
									tmp15 := checkDerefVar(glojure_DOT_core_some)
									var tmp16 lang.FnFunc
									tmp16 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v17 := args[0]
										_ = v17
										var tmp18 any
										{ // let
											// let binding "or__0__auto__"
											tmp19 := lang.Apply(v3, []any{v17})
											var v20 any = tmp19
											_ = v20
											var tmp21 any
											if lang.IsTruthy(v20) {
												tmp21 = v20
											} else {
												tmp22 := lang.Apply(v4, []any{v17})
												tmp21 = tmp22
											}
											tmp18 = tmp21
										} // end let
										return tmp18
									})
									tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7483), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(7483), lang.NewKeyword("end-column"), int(52))
									tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp19 := lang.Apply(tmp15, []any{tmp18, v10})
									tmp14 = tmp19
								}
								tmp11 = tmp14
							} // end let
							return tmp11
						}
					})
					v6 = tmp5
					_ = v6
				}
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7477), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7483), lang.NewKeyword("end-column"), int(61))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				{ // function sp3
					var v7 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v8 := args[0]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v3, []any{v8})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									var tmp13 any
									{ // let
										// let binding "or__0__auto__"
										tmp14 := lang.Apply(v4, []any{v8})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp16 = v15
										} else {
											tmp17 := lang.Apply(v5, []any{v8})
											tmp16 = tmp17
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						case 2:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							var tmp10 any
							{ // let
								// let binding "or__0__auto__"
								tmp11 := lang.Apply(v3, []any{v8})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp13 = v12
								} else {
									var tmp14 any
									{ // let
										// let binding "or__0__auto__"
										tmp15 := lang.Apply(v3, []any{v9})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											tmp17 = v16
										} else {
											var tmp18 any
											{ // let
												// let binding "or__0__auto__"
												tmp19 := lang.Apply(v4, []any{v8})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													tmp21 = v20
												} else {
													var tmp22 any
													{ // let
														// let binding "or__0__auto__"
														tmp23 := lang.Apply(v4, []any{v9})
														var v24 any = tmp23
														_ = v24
														var tmp25 any
														if lang.IsTruthy(v24) {
															tmp25 = v24
														} else {
															var tmp26 any
															{ // let
																// let binding "or__0__auto__"
																tmp27 := lang.Apply(v5, []any{v8})
																var v28 any = tmp27
																_ = v28
																var tmp29 any
																if lang.IsTruthy(v28) {
																	tmp29 = v28
																} else {
																	tmp30 := lang.Apply(v5, []any{v9})
																	tmp29 = tmp30
																}
																tmp26 = tmp29
															} // end let
															tmp25 = tmp26
														}
														tmp22 = tmp25
													} // end let
													tmp21 = tmp22
												}
												tmp18 = tmp21
											} // end let
											tmp17 = tmp18
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								}
								tmp10 = tmp13
							} // end let
							return tmp10
						case 3:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							var tmp11 any
							{ // let
								// let binding "or__0__auto__"
								tmp12 := lang.Apply(v3, []any{v8})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp14 = v13
								} else {
									var tmp15 any
									{ // let
										// let binding "or__0__auto__"
										tmp16 := lang.Apply(v3, []any{v9})
										var v17 any = tmp16
										_ = v17
										var tmp18 any
										if lang.IsTruthy(v17) {
											tmp18 = v17
										} else {
											var tmp19 any
											{ // let
												// let binding "or__0__auto__"
												tmp20 := lang.Apply(v3, []any{v10})
												var v21 any = tmp20
												_ = v21
												var tmp22 any
												if lang.IsTruthy(v21) {
													tmp22 = v21
												} else {
													var tmp23 any
													{ // let
														// let binding "or__0__auto__"
														tmp24 := lang.Apply(v4, []any{v8})
														var v25 any = tmp24
														_ = v25
														var tmp26 any
														if lang.IsTruthy(v25) {
															tmp26 = v25
														} else {
															var tmp27 any
															{ // let
																// let binding "or__0__auto__"
																tmp28 := lang.Apply(v4, []any{v9})
																var v29 any = tmp28
																_ = v29
																var tmp30 any
																if lang.IsTruthy(v29) {
																	tmp30 = v29
																} else {
																	var tmp31 any
																	{ // let
																		// let binding "or__0__auto__"
																		tmp32 := lang.Apply(v4, []any{v10})
																		var v33 any = tmp32
																		_ = v33
																		var tmp34 any
																		if lang.IsTruthy(v33) {
																			tmp34 = v33
																		} else {
																			var tmp35 any
																			{ // let
																				// let binding "or__0__auto__"
																				tmp36 := lang.Apply(v5, []any{v8})
																				var v37 any = tmp36
																				_ = v37
																				var tmp38 any
																				if lang.IsTruthy(v37) {
																					tmp38 = v37
																				} else {
																					var tmp39 any
																					{ // let
																						// let binding "or__0__auto__"
																						tmp40 := lang.Apply(v5, []any{v9})
																						var v41 any = tmp40
																						_ = v41
																						var tmp42 any
																						if lang.IsTruthy(v41) {
																							tmp42 = v41
																						} else {
																							tmp43 := lang.Apply(v5, []any{v10})
																							tmp42 = tmp43
																						}
																						tmp39 = tmp42
																					} // end let
																					tmp38 = tmp39
																				}
																				tmp35 = tmp38
																			} // end let
																			tmp34 = tmp35
																		}
																		tmp31 = tmp34
																	} // end let
																	tmp30 = tmp31
																}
																tmp27 = tmp30
															} // end let
															tmp26 = tmp27
														}
														tmp23 = tmp26
													} // end let
													tmp22 = tmp23
												}
												tmp19 = tmp22
											} // end let
											tmp18 = tmp19
										}
										tmp15 = tmp18
									} // end let
									tmp14 = tmp15
								}
								tmp11 = tmp14
							} // end let
							return tmp11
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							var v11 any = lang.NewList(args[3:]...)
							_ = v11
							var tmp12 any
							{ // let
								// let binding "or__0__auto__"
								tmp13 := lang.Apply(v7, []any{v8, v9, v10})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									tmp15 = v14
								} else {
									tmp16 := checkDerefVar(glojure_DOT_core_some)
									var tmp17 lang.FnFunc
									tmp17 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v18 := args[0]
										_ = v18
										var tmp19 any
										{ // let
											// let binding "or__0__auto__"
											tmp20 := lang.Apply(v3, []any{v18})
											var v21 any = tmp20
											_ = v21
											var tmp22 any
											if lang.IsTruthy(v21) {
												tmp22 = v21
											} else {
												var tmp23 any
												{ // let
													// let binding "or__0__auto__"
													tmp24 := lang.Apply(v4, []any{v18})
													var v25 any = tmp24
													_ = v25
													var tmp26 any
													if lang.IsTruthy(v25) {
														tmp26 = v25
													} else {
														tmp27 := lang.Apply(v5, []any{v18})
														tmp26 = tmp27
													}
													tmp23 = tmp26
												} // end let
												tmp22 = tmp23
											}
											tmp19 = tmp22
										} // end let
										return tmp19
									})
									tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7491), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(7491), lang.NewKeyword("end-column"), int(59))
									tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp20 := lang.Apply(tmp16, []any{tmp19, v11})
									tmp15 = tmp20
								}
								tmp12 = tmp15
							} // end let
							return tmp12
						}
					})
					v7 = tmp6
					_ = v7
				}
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7485), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7491), lang.NewKeyword("end-column"), int(68))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ps"
					tmp8 := checkDerefVar(glojure_DOT_core_list_STAR_)
					tmp9 := lang.Apply(tmp8, []any{v3, v4, v5, v6})
					var v10 any = tmp9
					_ = v10
					var tmp11 lang.FnFunc
					{ // function spn
						var v12 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								return nil
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := checkDerefVar(glojure_DOT_core_some)
								var tmp15 lang.FnFunc
								tmp15 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v16 := args[0]
									_ = v16
									tmp17 := lang.Apply(v16, []any{v13})
									return tmp17
								})
								tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7496), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(7496), lang.NewKeyword("end-column"), int(26))
								tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp18 := lang.Apply(tmp14, []any{tmp17, v10})
								return tmp18
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								tmp15 := checkDerefVar(glojure_DOT_core_some)
								var tmp16 lang.FnFunc
								tmp16 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v17 := args[0]
									_ = v17
									var tmp18 any
									{ // let
										// let binding "or__0__auto__"
										tmp19 := lang.Apply(v17, []any{v13})
										var v20 any = tmp19
										_ = v20
										var tmp21 any
										if lang.IsTruthy(v20) {
											tmp21 = v20
										} else {
											tmp22 := lang.Apply(v17, []any{v14})
											tmp21 = tmp22
										}
										tmp18 = tmp21
									} // end let
									return tmp18
								})
								tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7497), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(7497), lang.NewKeyword("end-column"), int(39))
								tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp19 := lang.Apply(tmp15, []any{tmp18, v10})
								return tmp19
							case 3:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								v15 := args[2]
								_ = v15
								tmp16 := checkDerefVar(glojure_DOT_core_some)
								var tmp17 lang.FnFunc
								tmp17 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v18 := args[0]
									_ = v18
									var tmp19 any
									{ // let
										// let binding "or__0__auto__"
										tmp20 := lang.Apply(v18, []any{v13})
										var v21 any = tmp20
										_ = v21
										var tmp22 any
										if lang.IsTruthy(v21) {
											tmp22 = v21
										} else {
											var tmp23 any
											{ // let
												// let binding "or__0__auto__"
												tmp24 := lang.Apply(v18, []any{v14})
												var v25 any = tmp24
												_ = v25
												var tmp26 any
												if lang.IsTruthy(v25) {
													tmp26 = v25
												} else {
													tmp27 := lang.Apply(v18, []any{v15})
													tmp26 = tmp27
												}
												tmp23 = tmp26
											} // end let
											tmp22 = tmp23
										}
										tmp19 = tmp22
									} // end let
									return tmp19
								})
								tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7498), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(7498), lang.NewKeyword("end-column"), int(47))
								tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp20 := lang.Apply(tmp16, []any{tmp19, v10})
								return tmp20
							default:
								if len(args) < 3 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								v15 := args[2]
								_ = v15
								var v16 any = lang.NewList(args[3:]...)
								_ = v16
								var tmp17 any
								{ // let
									// let binding "or__0__auto__"
									tmp18 := lang.Apply(v12, []any{v13, v14, v15})
									var v19 any = tmp18
									_ = v19
									var tmp20 any
									if lang.IsTruthy(v19) {
										tmp20 = v19
									} else {
										tmp21 := checkDerefVar(glojure_DOT_core_some)
										var tmp22 lang.FnFunc
										tmp22 = lang.NewFnFunc(func(args ...any) any {
											if len(args) != 1 {
												panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
											}
											v23 := args[0]
											_ = v23
											tmp24 := checkDerefVar(glojure_DOT_core_some)
											tmp25 := lang.Apply(tmp24, []any{v23, v16})
											return tmp25
										})
										tmp23 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7500), lang.NewKeyword("column"), int(36), lang.NewKeyword("end-line"), int(7500), lang.NewKeyword("end-column"), int(49))
										tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp25 := lang.Apply(tmp21, []any{tmp24, v10})
										tmp20 = tmp25
									}
									tmp17 = tmp20
								} // end let
								return tmp17
							}
						})
						v12 = tmp11
						_ = v12
					}
					tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7494), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7500), lang.NewKeyword("end-column"), int(56))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp7 = tmp13
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("some?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is not nil, false otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(530), lang.NewKeyword("end-line"), int(530))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_not)
			tmp6 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			tmp8 := lang.Apply(tmp5, []any{tmp7})
			return tmp8
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sort
	{
		tmp0 := lang.NewSymbol("sort").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("comp"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a sorted sequence of the items in coll. If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3085), lang.NewKeyword("end-line"), int(3085))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_sort)
				tmp5 := checkDerefVar(glojure_DOT_core_compare)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					var tmp8 any
					{ // let
						// let binding "a"
						tmp9 := checkDerefVar(glojure_DOT_core_to_array)
						tmp10 := lang.Apply(tmp9, []any{v4})
						var v11 any = tmp10
						_ = v11
						tmp12 := lang.Apply(lang.SortSlice, []any{v11, v3})
						_ = tmp12
						tmp13 := checkDerefVar(glojure_DOT_core_with_meta)
						tmp14 := checkDerefVar(glojure_DOT_core_seq)
						tmp15 := lang.Apply(tmp14, []any{v11})
						tmp16 := checkDerefVar(glojure_DOT_core_meta)
						tmp17 := lang.Apply(tmp16, []any{v4})
						tmp18 := lang.Apply(tmp13, []any{tmp15, tmp17})
						tmp8 = tmp18
					} // end let
					tmp5 = tmp8
				} else {
					tmp5 = lang.NewList()
				}
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sort-by
	{
		tmp0 := lang.NewSymbol("sort-by").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("keyfn"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("keyfn"), lang.NewSymbol("comp"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn item).  If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3102), lang.NewKeyword("end-line"), int(3102))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_sort_by)
				tmp6 := checkDerefVar(glojure_DOT_core_compare)
				tmp7 := lang.Apply(tmp5, []any{v3, tmp6, v4})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_sort)
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v8 := args[0]
					_ = v8
					v9 := args[1]
					_ = v9
					tmp10 := lang.Apply(v3, []any{v8})
					tmp11 := lang.Apply(v3, []any{v9})
					tmp12 := lang.Apply(v4, []any{tmp10, tmp11})
					return tmp12
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3114), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(3114), lang.NewKeyword("end-column"), int(46))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := lang.Apply(tmp6, []any{tmp9, v5})
				return tmp10
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-map
	{
		tmp0 := lang.NewSymbol("sorted-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keyvals"))), lang.NewKeyword("doc"), "keyval => key val\n  Returns a new sorted map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(397), lang.NewKeyword("end-line"), int(397))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentTreeMap, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-map-by
	{
		tmp0 := lang.NewSymbol("sorted-map-by").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("comparator"), lang.NewSymbol("&"), lang.NewSymbol("keyvals"))), lang.NewKeyword("doc"), "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.  If any keys are equal, they are handled as if by\n  repeated uses of assoc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(406), lang.NewKeyword("end-line"), int(406))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(nil, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-set
	{
		tmp0 := lang.NewSymbol("sorted-set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keys"))), lang.NewKeyword("doc"), "Returns a new sorted set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(416), lang.NewKeyword("end-line"), int(416))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentTreeSet, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-set-by
	{
		tmp0 := lang.NewSymbol("sorted-set-by").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("comparator"), lang.NewSymbol("&"), lang.NewSymbol("keys"))), lang.NewKeyword("doc"), "Returns a new sorted set with supplied keys, using the supplied\n  comparator.  Any equal keys are handled as if by repeated uses of\n  conj.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(424), lang.NewKeyword("end-line"), int(424))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(lang.CreatePersistentTreeSetWithComparator, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted?
	{
		tmp0 := lang.NewSymbol("sorted?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll implements Sorted", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6235), lang.NewKeyword("end-line"), int(6235))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// special-symbol?
	{
		tmp0 := lang.NewSymbol("special-symbol?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns true if s names a special form", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4992), lang.NewKeyword("end-line"), int(4992))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
			tmp5, ok := lang.FieldOrMethod(runtime7.Compiler, "specials")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", runtime7.Compiler, "specials")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{tmp6, v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// spit
	{
		tmp0 := lang.NewSymbol("spit").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("content"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Opposite of slurp.  Opens f with writer, writes content, then\n  closes f. Options passed to glojure.java.io/writer.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6994), lang.NewKeyword("end-line"), int(6994))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "w"
					tmp7 := checkDerefVar(glojure_DOT_core_apply)
					tmp8 := lang.Apply(tmp7, []any{nil, v3, v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					func() {
						defer func() {
							tmp11, ok := lang.FieldOrMethod(v9, "close")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "close")))
							}
							var tmp12 any
							switch reflect.TypeOf(tmp11).Kind() {
							case reflect.Func:
								tmp12 = lang.Apply(tmp11, nil)
							default:
								tmp12 = tmp11
							}
							_ = tmp12
						}()
						tmp13 := checkDerefVar(glojure_DOT_core_str)
						tmp14 := lang.Apply(tmp13, []any{v4})
						tmp15 := lang.Apply(lang.WriteWriter, []any{v9, tmp14})
						tmp10 = tmp15
					}()
					tmp6 = tmp10
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// split-at
	{
		tmp0 := lang.NewSymbol("split-at").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a vector of [(take n coll) (drop n coll)]", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2983), lang.NewKeyword("end-line"), int(2983))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_take)
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			tmp7 := checkDerefVar(glojure_DOT_core_drop)
			tmp8 := lang.Apply(tmp7, []any{v3, v4})
			tmp9 := lang.NewVector(tmp6, tmp8)
			tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2988), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2988), lang.NewKeyword("end-column"), int(33))
			tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// split-with
	{
		tmp0 := lang.NewSymbol("split-with").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2990), lang.NewKeyword("end-line"), int(2990))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_take_while)
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			tmp7 := checkDerefVar(glojure_DOT_core_drop_while)
			tmp8 := lang.Apply(tmp7, []any{v3, v4})
			tmp9 := lang.NewVector(tmp6, tmp8)
			tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2995), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2995), lang.NewKeyword("end-column"), int(51))
			tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// splitv-at
	{
		tmp0 := lang.NewSymbol("splitv-at").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a vector of [(into [] (take n) coll) (drop n coll)]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7256), lang.NewKeyword("end-line"), int(7256))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_into)
			tmp6 := lang.NewVector()
			tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7260), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(7260), lang.NewKeyword("end-column"), int(11))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := checkDerefVar(glojure_DOT_core_take)
			tmp10 := lang.Apply(tmp9, []any{v3})
			tmp11 := lang.Apply(tmp5, []any{tmp8, tmp10, v4})
			tmp12 := checkDerefVar(glojure_DOT_core_drop)
			tmp13 := lang.Apply(tmp12, []any{v3, v4})
			tmp14 := lang.NewVector(tmp11, tmp13)
			tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7260), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(7260), lang.NewKeyword("end-column"), int(41))
			tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp16
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// spread
	{
		tmp0 := lang.NewSymbol("spread").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("arglist"))), lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(632), lang.NewKeyword("end-line"), int(632), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
			} else {
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
				tmp9 := checkDerefVar(glojure_DOT_core_next)
				tmp10 := lang.Apply(tmp9, []any{v3})
				tmp11 := lang.Apply(tmp8, []any{tmp10})
				if lang.IsTruthy(tmp11) {
					tmp12 := checkDerefVar(glojure_DOT_core_seq)
					tmp13 := checkDerefVar(glojure_DOT_core_first)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp15 := lang.Apply(tmp12, []any{tmp14})
					tmp7 = tmp15
				} else {
					var tmp16 any
					if lang.IsTruthy(lang.NewKeyword("else")) {
						tmp17 := checkDerefVar(glojure_DOT_core_cons)
						tmp18 := checkDerefVar(glojure_DOT_core_first)
						tmp19 := lang.Apply(tmp18, []any{v3})
						tmp20 := checkDerefVar(glojure_DOT_core_spread)
						tmp21 := checkDerefVar(glojure_DOT_core_next)
						tmp22 := lang.Apply(tmp21, []any{v3})
						tmp23 := lang.Apply(tmp20, []any{tmp22})
						tmp24 := lang.Apply(tmp17, []any{tmp19, tmp23})
						tmp16 = tmp24
					} else {
					}
					tmp7 = tmp16
				}
				tmp4 = tmp7
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("str").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("ys"))), lang.NewKeyword("doc"), "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(543), lang.NewKeyword("end-line"), int(543))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return ""
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_nil_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp5 = ""
				} else {
					tmp8 := lang.Apply(lang.ToString, []any{v4})
					tmp5 = tmp8
				}
				return tmp5
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				var v5 any = lang.NewList(args[1:]...)
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v7 := args[0]
					_ = v7
					v8 := args[1]
					_ = v8
				recur_loop_74:
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp11 := checkDerefVar(glojure_DOT_core_str)
						tmp12 := checkDerefVar(glojure_DOT_core_first)
						tmp13 := lang.Apply(tmp12, []any{v8})
						tmp14 := lang.Apply(tmp11, []any{tmp13})
						tmp15, _ := lang.FieldOrMethod(v7, "WriteString")
						if reflect.TypeOf(tmp15).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("WriteString is not a function")))
						}
						tmp16 := lang.Apply(tmp15, []any{tmp14})
						_ = tmp16
						var tmp10 any = v7
						tmp18 := checkDerefVar(glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v8})
						var tmp17 any = tmp19
						v7 = tmp10
						v8 = tmp17
						goto recur_loop_74
					} else {
						tmp20, ok := lang.FieldOrMethod(v7, "String")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "String")))
						}
						var tmp21 any
						switch reflect.TypeOf(tmp20).Kind() {
						case reflect.Func:
							tmp21 = lang.Apply(tmp20, nil)
						default:
							tmp21 = tmp20
						}
						tmp9 = tmp21
					}
					return tmp9
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(554), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(554), lang.NewKeyword("end-column"), int(127))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := checkDerefVar(glojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp8, []any{"unimplemented: new with non-constant class type", tmp10})
				return tmp11
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-into!
	{
		tmp0 := lang.NewSymbol("stream-into!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("to"), lang.NewSymbol("stream")), lang.NewVector(lang.NewSymbol("to"), lang.NewSymbol("xform"), lang.NewSymbol("stream"))), lang.NewKeyword("doc"), "Returns a new coll consisting of coll with all of the items of the\n  stream conjoined. This is a terminal operation on the stream.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6810), lang.NewKeyword("end-line"), int(6810))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(glojure_DOT_core_with_meta)
					tmp10 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
					tmp11 := checkDerefVar(glojure_DOT_core_stream_reduce_BANG_)
					tmp12 := checkDerefVar(glojure_DOT_core_conj_BANG_)
					tmp13 := checkDerefVar(glojure_DOT_core_transient)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp15 := lang.Apply(tmp11, []any{tmp12, tmp14, v4})
					tmp16 := lang.Apply(tmp10, []any{tmp15})
					tmp17 := checkDerefVar(glojure_DOT_core_meta)
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.Apply(tmp9, []any{tmp16, tmp18})
					tmp5 = tmp19
				} else {
					tmp20 := checkDerefVar(glojure_DOT_core_stream_reduce_BANG_)
					tmp21 := checkDerefVar(glojure_DOT_core_conj)
					tmp22 := lang.Apply(tmp20, []any{tmp21, v3, v4})
					tmp5 = tmp22
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp8 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(glojure_DOT_core_with_meta)
					tmp11 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
					tmp12 := checkDerefVar(glojure_DOT_core_stream_transduce_BANG_)
					tmp13 := checkDerefVar(glojure_DOT_core_conj_BANG_)
					tmp14 := checkDerefVar(glojure_DOT_core_transient)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(tmp12, []any{v4, tmp13, tmp15, v5})
					tmp17 := lang.Apply(tmp11, []any{tmp16})
					tmp18 := checkDerefVar(glojure_DOT_core_meta)
					tmp19 := lang.Apply(tmp18, []any{v3})
					tmp20 := lang.Apply(tmp10, []any{tmp17, tmp19})
					tmp6 = tmp20
				} else {
					tmp21 := checkDerefVar(glojure_DOT_core_stream_transduce_BANG_)
					tmp22 := checkDerefVar(glojure_DOT_core_conj)
					tmp23 := lang.Apply(tmp21, []any{v4, tmp22, v3, v5})
					tmp6 = tmp23
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-reduce!
	{
		tmp0 := lang.NewSymbol("stream-reduce!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("s")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("init"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Works like reduce but takes a java.util.stream.BaseStream as its source.\n  Honors 'reduced', is a terminal operation on the stream", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6784), lang.NewKeyword("end-line"), int(6784))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, ok := lang.FieldOrMethod(v4, "iterator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "iterator")))
				}
				var tmp6 any
				switch reflect.TypeOf(tmp5).Kind() {
				case reflect.Func:
					tmp6 = lang.Apply(tmp5, nil)
				default:
					tmp6 = tmp5
				}
				tmp7 := lang.Apply(nil, []any{tmp6, v3})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6, ok := lang.FieldOrMethod(v5, "iterator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "iterator")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				tmp8 := lang.Apply(nil, []any{tmp7, v3, v4})
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-seq!
	{
		tmp0 := lang.NewSymbol("stream-seq!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("stream"))), lang.NewKeyword("doc"), "Takes a java.util.stream.BaseStream instance s and returns a seq of its\n  contents. This is a terminal operation on the stream.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6793), lang.NewKeyword("end-line"), int(6793))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_iterator_seq)
			tmp5, ok := lang.FieldOrMethod(v3, "iterator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "iterator")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-transduce!
	{
		tmp0 := lang.NewSymbol("stream-transduce!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("f"), lang.NewSymbol("stream")), lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("f"), lang.NewSymbol("init"), lang.NewSymbol("stream"))), lang.NewKeyword("doc"), "Works like transduce but takes a java.util.stream.BaseStream as its source.\n  This is a terminal operation on the stream.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6800), lang.NewKeyword("end-line"), int(6800))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_stream_transduce_BANG_)
				tmp7 := lang.Apply(v4, nil)
				tmp8 := lang.Apply(tmp6, []any{v3, v4, tmp7, v5})
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "f"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ret"
					tmp10 := checkDerefVar(glojure_DOT_core_stream_reduce_BANG_)
					tmp11 := lang.Apply(tmp10, []any{v9, v5, v6})
					var v12 any = tmp11
					_ = v12
					tmp13 := lang.Apply(v9, []any{v12})
					tmp7 = tmp13
				} // end let
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// string?
	{
		tmp0 := lang.NewSymbol("string?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a String", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(160), lang.NewKeyword("end-line"), int(164))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function string?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{lang.Builtins["string"], v4})
				return tmp6
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(164), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(164), lang.NewKeyword("end-column"), int(58))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// strip-ns
	{
		tmp0 := lang.NewSymbol("strip-ns").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(255), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(255), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("named"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(glojure_DOT_core_symbol)
				tmp8 := checkDerefVar(glojure_DOT_core_name)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp7, []any{nil, tmp9})
				tmp4 = tmp10
			} else {
				tmp11 := checkDerefVar(glojure_DOT_core_keyword)
				tmp12 := checkDerefVar(glojure_DOT_core_name)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp11, []any{nil, tmp13})
				tmp4 = tmp14
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// struct
	{
		tmp0 := lang.NewSymbol("struct").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("&"), lang.NewSymbol("vals"))), lang.NewKeyword("doc"), "Returns a new structmap instance with the keys of the\n  structure-basis. vals must be supplied for basis keys in order -\n  where values are not supplied they will default to nil.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4061), lang.NewKeyword("end-line"), int(4061))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(lang.ConstructPersistentStructMap, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// struct-map
	{
		tmp0 := lang.NewSymbol("struct-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("&"), lang.NewSymbol("inits"))), lang.NewKeyword("doc"), "Returns a new structmap instance with the keys of the\n  structure-basis. keyvals may contain all, some or none of the basis\n  keys - where values are not supplied they will default to nil.\n  keyvals can also contain keys not in the basis.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4051), lang.NewKeyword("end-line"), int(4051))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(lang.CreatePersistentStructMap, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subs
	{
		tmp0 := lang.NewSymbol("subs").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("start")), lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("start"), lang.NewSymbol("end"))), lang.NewKeyword("doc"), "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5005), lang.NewKeyword("end-line"), int(5005))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.Builtins["slice"], []any{v3, v4})
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.Apply(lang.Builtins["slice"], []any{v3, v4, v5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subseq
	{
		tmp0 := lang.NewSymbol("subseq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sc"), lang.NewSymbol("test"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("sc"), lang.NewSymbol("start-test"), lang.NewSymbol("start-key"), lang.NewSymbol("end-test"), lang.NewSymbol("end-key"))), lang.NewKeyword("doc"), "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5133), lang.NewKeyword("end-line"), int(5133))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "include"
					tmp7 := checkDerefVar(glojure_DOT_core_mk_bound_fn)
					tmp8 := lang.Apply(tmp7, []any{v3, v4, v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core__GT_)
					tmp12 := checkDerefVar(glojure_DOT_core__GT__EQ_)
					tmp13 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{tmp11, tmp12}))
					tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5141), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5141), lang.NewKeyword("end-column"), int(17))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp16 := lang.Apply(tmp15, []any{v4})
					if lang.IsTruthy(tmp16) {
						var tmp17 any
						{ // let
							// let binding "temp__0__auto__"
							tmp18, _ := lang.FieldOrMethod(v3, "seqFrom")
							if reflect.TypeOf(tmp18).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
							}
							tmp19 := lang.Apply(tmp18, []any{v5, true})
							var v20 any = tmp19
							_ = v20
							var tmp21 any
							if lang.IsTruthy(v20) {
								var tmp22 any
								{ // let
									// let binding "vec__68"
									var v23 any = v20
									_ = v23
									// let binding "e"
									tmp24 := checkDerefVar(glojure_DOT_core_nth)
									tmp25 := lang.Apply(tmp24, []any{v23, int64(0), nil})
									var v26 any = tmp25
									_ = v26
									// let binding "s"
									var v27 any = v23
									_ = v27
									var tmp28 any
									tmp29 := lang.Apply(v9, []any{v26})
									if lang.IsTruthy(tmp29) {
										tmp28 = v27
									} else {
										tmp30 := checkDerefVar(glojure_DOT_core_next)
										tmp31 := lang.Apply(tmp30, []any{v27})
										tmp28 = tmp31
									}
									tmp22 = tmp28
								} // end let
								tmp21 = tmp22
							} else {
							}
							tmp17 = tmp21
						} // end let
						tmp10 = tmp17
					} else {
						tmp18 := checkDerefVar(glojure_DOT_core_take_while)
						tmp19, _ := lang.FieldOrMethod(v3, "seq")
						if reflect.TypeOf(tmp19).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("seq is not a function")))
						}
						tmp20 := lang.Apply(tmp19, []any{true})
						tmp21 := lang.Apply(tmp18, []any{v9, tmp20})
						tmp10 = tmp21
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var tmp8 any
				{ // let
					// let binding "temp__0__auto__"
					tmp9, _ := lang.FieldOrMethod(v3, "seqFrom")
					if reflect.TypeOf(tmp9).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
					}
					tmp10 := lang.Apply(tmp9, []any{v5, true})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						var tmp13 any
						{ // let
							// let binding "vec__71"
							var v14 any = v11
							_ = v14
							// let binding "e"
							tmp15 := checkDerefVar(glojure_DOT_core_nth)
							tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
							var v17 any = tmp16
							_ = v17
							// let binding "s"
							var v18 any = v14
							_ = v18
							tmp19 := checkDerefVar(glojure_DOT_core_take_while)
							tmp20 := checkDerefVar(glojure_DOT_core_mk_bound_fn)
							tmp21 := lang.Apply(tmp20, []any{v3, v6, v7})
							var tmp22 any
							tmp23 := checkDerefVar(glojure_DOT_core_mk_bound_fn)
							tmp24 := lang.Apply(tmp23, []any{v3, v4, v5})
							tmp25 := lang.Apply(tmp24, []any{v17})
							if lang.IsTruthy(tmp25) {
								tmp22 = v18
							} else {
								tmp26 := checkDerefVar(glojure_DOT_core_next)
								tmp27 := lang.Apply(tmp26, []any{v18})
								tmp22 = tmp27
							}
							tmp28 := lang.Apply(tmp19, []any{tmp21, tmp22})
							tmp13 = tmp28
						} // end let
						tmp12 = tmp13
					} else {
					}
					tmp8 = tmp12
				} // end let
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subvec
	{
		tmp0 := lang.NewSymbol("subvec").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("v"), lang.NewSymbol("start")), lang.NewVector(lang.NewSymbol("v"), lang.NewSymbol("start"), lang.NewSymbol("end"))), lang.NewKeyword("doc"), "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3819), lang.NewKeyword("end-line"), int(3819))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_subvec)
				tmp6 := checkDerefVar(glojure_DOT_core_count)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := lang.Apply(tmp5, []any{v3, v4, tmp7})
				return tmp8
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(runtime7.RT, "Subvec")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Subvec is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v3, v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// supers
	{
		tmp0 := lang.NewSymbol("supers").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("class"))), lang.NewKeyword("doc"), "Returns the immediate and indirect superclasses and interfaces of c, if any", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5532), lang.NewKeyword("end-line"), int(5532))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := checkDerefVar(glojure_DOT_core_set)
				tmp6 := checkDerefVar(glojure_DOT_core_bases)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				var v9 any = tmp8
				_ = v9
				// let binding "cs"
				var v10 any = v9
				_ = v10
				for {
					var tmp11 any
					tmp12 := checkDerefVar(glojure_DOT_core_seq)
					tmp13 := lang.Apply(tmp12, []any{v10})
					if lang.IsTruthy(tmp13) {
						var tmp14 any
						{ // let
							// let binding "c"
							tmp15 := checkDerefVar(glojure_DOT_core_first)
							tmp16 := lang.Apply(tmp15, []any{v10})
							var v17 any = tmp16
							_ = v17
							// let binding "bs"
							tmp18 := checkDerefVar(glojure_DOT_core_bases)
							tmp19 := lang.Apply(tmp18, []any{v17})
							var v20 any = tmp19
							_ = v20
							tmp22 := checkDerefVar(glojure_DOT_core_into1)
							tmp23 := lang.Apply(tmp22, []any{v9, v20})
							var tmp21 any = tmp23
							tmp25 := checkDerefVar(glojure_DOT_core_into1)
							tmp26 := checkDerefVar(glojure_DOT_core_disj)
							tmp27 := lang.Apply(tmp26, []any{v10, v17})
							tmp28 := lang.Apply(tmp25, []any{tmp27, v20})
							var tmp24 any = tmp28
							v9 = tmp21
							v10 = tmp24
							continue
						} // end let
						tmp11 = tmp14
					} else {
						tmp15 := checkDerefVar(glojure_DOT_core_not_empty)
						tmp16 := lang.Apply(tmp15, []any{v9})
						tmp11 = tmp16
					}
					tmp4 = tmp11
					break
				}
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// swap!
	{
		tmp0 := lang.NewSymbol("swap!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atom"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2343), lang.NewKeyword("end-line"), int(2343))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "swap")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("swap is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// swap-vals!
	{
		tmp0 := lang.NewSymbol("swap-vals!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atom"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2352), lang.NewKeyword("end-line"), int(2352))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "swapVals")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("swapVals is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// symbol
	{
		tmp1 := reflect.TypeOf((*lang.Symbol)(nil))
		tmp0 := lang.NewSymbol("symbol").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name")), lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("name"))), lang.NewKeyword("doc"), "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(584), lang.NewKeyword("end-line"), int(584))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp5 = v4
				} else {
					var tmp8 any
					tmp9 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{lang.Builtins["string"], v4})
					if lang.IsTruthy(tmp10) {
						tmp11 := lang.Apply(lang.NewSymbol, []any{v4})
						tmp8 = tmp11
					} else {
						var tmp12 any
						tmp13 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
						tmp14 := reflect.TypeOf((*lang.Var)(nil))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v4})
						if lang.IsTruthy(tmp15) {
							tmp16, ok := lang.FieldOrMethod(v4, "toSymbol")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toSymbol")))
							}
							var tmp17 any
							switch reflect.TypeOf(tmp16).Kind() {
							case reflect.Func:
								tmp17 = lang.Apply(tmp16, nil)
							default:
								tmp17 = tmp16
							}
							tmp12 = tmp17
						} else {
							var tmp18 any
							tmp19 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
							tmp20 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
							tmp21 := lang.Apply(tmp19, []any{tmp20, v4})
							if lang.IsTruthy(tmp21) {
								tmp22, ok := lang.FieldOrMethod(v4, "sym")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "sym")))
								}
								var tmp23 any
								switch reflect.TypeOf(tmp22).Kind() {
								case reflect.Func:
									tmp23 = lang.Apply(tmp22, nil)
								default:
									tmp23 = tmp22
								}
								tmp18 = tmp23
							} else {
								var tmp24 any
								if lang.IsTruthy(lang.NewKeyword("else")) {
									tmp25 := lang.Apply(lang.NewIllegalArgumentError, []any{"no conversion to symbol"})
									panic(tmp25)
								} else {
								}
								tmp18 = tmp24
							}
							tmp12 = tmp18
						}
						tmp8 = tmp12
					}
					tmp5 = tmp8
				}
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.InternSymbol, []any{v4, v5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp4 := reflect.TypeOf((*lang.Symbol)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// symbol?
	{
		tmp0 := lang.NewSymbol("symbol?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a Symbol", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(557), lang.NewKeyword("end-line"), int(557))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Symbol)(nil))
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sync
	{
		tmp0 := lang.NewSymbol("sync").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("flags-ignored-for-now"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "transaction-flags => TBD, pass nil for now\n\n  Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of sync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(2490), lang.NewKeyword("end-line"), int(2490))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol(".")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.LockingTransaction")})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := checkDerefVar(glojure_DOT_core_seq)
				tmp15 := checkDerefVar(glojure_DOT_core_concat)
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("glojure.core/RunInTransaction")})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := checkDerefVar(glojure_DOT_core_seq)
				tmp20 := checkDerefVar(glojure_DOT_core_concat)
				tmp21 := checkDerefVar(glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/fn")})
				tmp23 := checkDerefVar(glojure_DOT_core_list)
				tmp24 := checkDerefVar(glojure_DOT_core_apply)
				tmp25 := checkDerefVar(glojure_DOT_core_vector)
				tmp26 := checkDerefVar(glojure_DOT_core_seq)
				tmp27 := checkDerefVar(glojure_DOT_core_concat)
				tmp28 := lang.Apply(tmp27, nil)
				tmp29 := lang.Apply(tmp26, []any{tmp28})
				tmp30 := lang.Apply(tmp24, []any{tmp25, tmp29})
				tmp31 := lang.Apply(tmp23, []any{tmp30})
				tmp32 := lang.Apply(tmp20, []any{tmp22, tmp31, v6})
				tmp33 := lang.Apply(tmp19, []any{tmp32})
				tmp34 := lang.Apply(tmp18, []any{tmp33})
				tmp35 := lang.Apply(tmp15, []any{tmp17, tmp34})
				tmp36 := lang.Apply(tmp14, []any{tmp35})
				tmp37 := lang.Apply(tmp13, []any{tmp36})
				tmp38 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp37})
				tmp39 := lang.Apply(tmp7, []any{tmp38})
				return tmp39
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// system-newline
	{
		tmp0 := lang.NewSymbol("system-newline").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3695), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(3695), lang.NewKeyword("end-column"), int(40), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, "\n", true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tagged-literal
	{
		tmp0 := lang.NewSymbol("tagged-literal").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag"), lang.NewSymbol("form"))), lang.NewKeyword("doc"), "Construct a data representation of a tagged literal from a\n  tag symbol and a form.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7769), lang.NewKeyword("end-line"), int(7769))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tagged-literal?
	{
		tmp0 := lang.NewSymbol("tagged-literal?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("value"))), lang.NewKeyword("doc"), "Return true if the value is the data representation of a tagged literal", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7763), lang.NewKeyword("end-line"), int(7763))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take
	{
		tmp0 := lang.NewSymbol("take").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2853), lang.NewKeyword("end-line"), int(2853))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "nv"
						tmp7 := checkDerefVar(glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{v3})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "n"
									tmp14 := checkDerefVar(glojure_DOT_core_deref)
									tmp15 := lang.Apply(tmp14, []any{v9})
									var v16 any = tmp15
									_ = v16
									// let binding "nn"
									tmp17 := checkDerefVar(glojure_DOT_core_dec)
									tmp18, ok := lang.FieldOrMethod(v9, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Deref")))
									}
									var tmp19 any
									switch reflect.TypeOf(tmp18).Kind() {
									case reflect.Func:
										tmp19 = lang.Apply(tmp18, nil)
									default:
										tmp19 = tmp18
									}
									tmp20 := lang.Apply(tmp17, []any{tmp19})
									tmp21, _ := lang.FieldOrMethod(v9, "reset")
									if reflect.TypeOf(tmp21).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp22 := lang.Apply(tmp21, []any{tmp20})
									var v23 any = tmp22
									_ = v23
									// let binding "result"
									var tmp24 any
									tmp25 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
									tmp26 := lang.Apply(tmp25, []any{v16})
									if lang.IsTruthy(tmp26) {
										tmp27 := lang.Apply(v5, []any{v11, v12})
										tmp24 = tmp27
									} else {
										tmp24 = v11
									}
									var v28 any = tmp24
									_ = v28
									var tmp29 any
									tmp30 := checkDerefVar(glojure_DOT_core_not)
									tmp31 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
									tmp32 := lang.Apply(tmp31, []any{v23})
									tmp33 := lang.Apply(tmp30, []any{tmp32})
									if lang.IsTruthy(tmp33) {
										tmp34 := checkDerefVar(glojure_DOT_core_ensure_reduced)
										tmp35 := lang.Apply(tmp34, []any{v28})
										tmp29 = tmp35
									} else {
										tmp29 = v28
									}
									tmp13 = tmp29
								} // end let
								return tmp13
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2862), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(2873), lang.NewKeyword("end-column"), int(28))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2860), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2873), lang.NewKeyword("end-column"), int(30))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					tmp7 := checkDerefVar(glojure_DOT_core_pos_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{v3})
					if lang.IsTruthy(tmp8) {
						var tmp9 any
						{ // let
							// let binding "temp__0__auto__"
							tmp10 := checkDerefVar(glojure_DOT_core_seq)
							tmp11 := lang.Apply(tmp10, []any{v4})
							var v12 any = tmp11
							_ = v12
							var tmp13 any
							if lang.IsTruthy(v12) {
								var tmp14 any
								{ // let
									// let binding "s"
									var v15 any = v12
									_ = v15
									tmp16 := checkDerefVar(glojure_DOT_core_cons)
									tmp17 := checkDerefVar(glojure_DOT_core_first)
									tmp18 := lang.Apply(tmp17, []any{v15})
									tmp19 := checkDerefVar(glojure_DOT_core_take)
									tmp20 := checkDerefVar(glojure_DOT_core_dec)
									tmp21 := lang.Apply(tmp20, []any{v3})
									tmp22 := checkDerefVar(glojure_DOT_core_rest)
									tmp23 := lang.Apply(tmp22, []any{v15})
									tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
									tmp25 := lang.Apply(tmp16, []any{tmp18, tmp24})
									tmp14 = tmp25
								} // end let
								tmp13 = tmp14
							} else {
							}
							tmp9 = tmp13
						} // end let
						tmp6 = tmp9
					} else {
					}
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-last
	{
		tmp0 := lang.NewSymbol("take-last").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2939), lang.NewKeyword("end-line"), int(2939))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "s"
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := lang.Apply(tmp6, []any{v4})
				var v8 any = tmp7
				_ = v8
				// let binding "lead"
				tmp9 := checkDerefVar(glojure_DOT_core_seq)
				tmp10 := checkDerefVar(glojure_DOT_core_drop)
				tmp11 := lang.Apply(tmp10, []any{v3, v4})
				tmp12 := lang.Apply(tmp9, []any{tmp11})
				var v13 any = tmp12
				_ = v13
				for {
					var tmp14 any
					if lang.IsTruthy(v13) {
						tmp16 := checkDerefVar(glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v8})
						var tmp15 any = tmp17
						tmp19 := checkDerefVar(glojure_DOT_core_next)
						tmp20 := lang.Apply(tmp19, []any{v13})
						var tmp18 any = tmp20
						v8 = tmp15
						v13 = tmp18
						continue
					} else {
						tmp14 = v8
					}
					tmp5 = tmp14
					break
				}
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-nth
	{
		tmp0 := lang.NewSymbol("take-nth").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4287), lang.NewKeyword("end-line"), int(4287))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "iv"
						tmp7 := checkDerefVar(glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{int64(-1)})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "i"
									tmp14 := checkDerefVar(glojure_DOT_core_inc)
									tmp15, ok := lang.FieldOrMethod(v9, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Deref")))
									}
									var tmp16 any
									switch reflect.TypeOf(tmp15).Kind() {
									case reflect.Func:
										tmp16 = lang.Apply(tmp15, nil)
									default:
										tmp16 = tmp15
									}
									tmp17 := lang.Apply(tmp14, []any{tmp16})
									tmp18, _ := lang.FieldOrMethod(v9, "reset")
									if reflect.TypeOf(tmp18).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp19 := lang.Apply(tmp18, []any{tmp17})
									var v20 any = tmp19
									_ = v20
									var tmp21 any
									tmp22 := checkDerefVar(glojure_DOT_core_zero_QMARK_)
									tmp23 := checkDerefVar(glojure_DOT_core_rem)
									tmp24 := lang.Apply(tmp23, []any{v20, v3})
									tmp25 := lang.Apply(tmp22, []any{tmp24})
									if lang.IsTruthy(tmp25) {
										tmp26 := lang.Apply(v5, []any{v11, v12})
										tmp21 = tmp26
									} else {
										tmp21 = v11
									}
									tmp13 = tmp21
								} // end let
								return tmp13
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4295), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(4302), lang.NewKeyword("end-column"), int(28))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4293), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(4302), lang.NewKeyword("end-column"), int(30))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								tmp13 := checkDerefVar(glojure_DOT_core_cons)
								tmp14 := checkDerefVar(glojure_DOT_core_first)
								tmp15 := lang.Apply(tmp14, []any{v12})
								tmp16 := checkDerefVar(glojure_DOT_core_take_nth)
								tmp17 := checkDerefVar(glojure_DOT_core_drop)
								tmp18 := lang.Apply(tmp17, []any{v3, v12})
								tmp19 := lang.Apply(tmp16, []any{v3, tmp18})
								tmp20 := lang.Apply(tmp13, []any{tmp15, tmp19})
								tmp11 = tmp20
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-while
	{
		tmp0 := lang.NewSymbol("take-while").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred")), lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2880), lang.NewKeyword("end-line"), int(2880))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							tmp10 := lang.Apply(v3, []any{v8})
							if lang.IsTruthy(tmp10) {
								tmp11 := lang.Apply(v5, []any{v7, v8})
								tmp9 = tmp11
							} else {
								tmp12 := checkDerefVar(glojure_DOT_core_reduced)
								tmp13 := lang.Apply(tmp12, []any{v7})
								tmp9 = tmp13
							}
							return tmp9
						default:
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
					})
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2888), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(2894), lang.NewKeyword("end-column"), int(33))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2887), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2894), lang.NewKeyword("end-column"), int(34))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								tmp14 := checkDerefVar(glojure_DOT_core_first)
								tmp15 := lang.Apply(tmp14, []any{v12})
								tmp16 := lang.Apply(v3, []any{tmp15})
								if lang.IsTruthy(tmp16) {
									tmp17 := checkDerefVar(glojure_DOT_core_cons)
									tmp18 := checkDerefVar(glojure_DOT_core_first)
									tmp19 := lang.Apply(tmp18, []any{v12})
									tmp20 := checkDerefVar(glojure_DOT_core_take_while)
									tmp21 := checkDerefVar(glojure_DOT_core_rest)
									tmp22 := lang.Apply(tmp21, []any{v12})
									tmp23 := lang.Apply(tmp20, []any{v3, tmp22})
									tmp24 := lang.Apply(tmp17, []any{tmp19, tmp23})
									tmp13 = tmp24
								} else {
								}
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tapset
	{
		tmp0 := lang.NewSymbol("tapset").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7882), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(7882), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp2 := lang.NewAtom(lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{})))
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// test
	{
		tmp0 := lang.NewSymbol("test").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("v"))), lang.NewKeyword("doc"), "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4853), lang.NewKeyword("end-line"), int(4853))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "f"
				tmp5 := checkDerefVar(glojure_DOT_core_meta)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(lang.NewKeyword("test"), []any{tmp6})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					tmp10 := lang.Apply(v8, nil)
					_ = tmp10
					tmp9 = lang.NewKeyword("ok")
				} else {
					tmp9 = lang.NewKeyword("no-test")
				}
				tmp4 = tmp9
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// the-ns
	{
		tmp0 := lang.NewSymbol("the-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "If passed a namespace, returns it. Else, when passed a symbol,\n  returns the namespace named by it, throwing an exception if not\n  found.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4152), lang.NewKeyword("end-line"), int(4152))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp6 := reflect.TypeOf((*lang.Namespace)(nil))
			tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
			if lang.IsTruthy(tmp7) {
				tmp4 = v3
			} else {
				var tmp8 any
				{ // let
					// let binding "or__0__auto__"
					tmp9 := checkDerefVar(glojure_DOT_core_find_ns)
					tmp10 := lang.Apply(tmp9, []any{v3})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						tmp12 = v11
					} else {
						tmp13 := checkDerefVar(glojure_DOT_core_str)
						tmp14 := lang.Apply(tmp13, []any{"No namespace: ", v3, " found"})
						tmp15 := lang.Apply(lang.NewError, []any{tmp14})
						panic(tmp15)
					}
					tmp8 = tmp12
				} // end let
				tmp4 = tmp8
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// thread-bound?
	{
		tmp0 := lang.NewSymbol("thread-bound?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("vars"))), lang.NewKeyword("doc"), "Returns true if all of the vars provided as arguments have thread-local bindings.\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5499), lang.NewKeyword("end-line"), int(5499))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_every_QMARK_)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v6 := args[0]
					_ = v6
					tmp7, ok := lang.FieldOrMethod(v6, "getThreadBinding")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "getThreadBinding")))
					}
					var tmp8 any
					switch reflect.TypeOf(tmp7).Kind() {
					case reflect.Func:
						tmp8 = lang.Apply(tmp7, nil)
					default:
						tmp8 = tmp7
					}
					return tmp8
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5505), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5505), lang.NewKeyword("end-column"), int(78))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7, v3})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// throw-if
	{
		tmp0 := lang.NewSymbol("throw-if").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("fmt"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Throws a CompilerException with a message if pred is true", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5832), lang.NewKeyword("end-line"), int(5832), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v3) {
					var tmp7 any
					{ // let
						// let binding "message"
						tmp8 := checkDerefVar(glojure_DOT_core_apply)
						tmp9 := checkDerefVar(glojure_DOT_core_format)
						tmp10 := lang.Apply(tmp8, []any{tmp9, v4, v5})
						var v11 any = tmp10
						_ = v11
						// let binding "exception"
						tmp12 := lang.Apply(lang.NewError, []any{v11})
						var v13 any = tmp12
						_ = v13
						// let binding "raw-trace"
						tmp14, ok := lang.FieldOrMethod(v13, "getStackTrace")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v13, "getStackTrace")))
						}
						var tmp15 any
						switch reflect.TypeOf(tmp14).Kind() {
						case reflect.Func:
							tmp15 = lang.Apply(tmp14, nil)
						default:
							tmp15 = tmp14
						}
						var v16 any = tmp15
						_ = v16
						// let binding "boring?"
						var tmp17 lang.FnFunc
						tmp17 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v18 := args[0]
							_ = v18
							tmp19 := checkDerefVar(glojure_DOT_core_not_EQ_)
							tmp20, ok := lang.FieldOrMethod(v18, "getMethodName")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v18, "getMethodName")))
							}
							var tmp21 any
							switch reflect.TypeOf(tmp20).Kind() {
							case reflect.Func:
								tmp21 = lang.Apply(tmp20, nil)
							default:
								tmp21 = tmp20
							}
							tmp22 := lang.Apply(tmp19, []any{tmp21, "doInvoke"})
							return tmp22
						})
						tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5839), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(5839), lang.NewKeyword("end-column"), int(74))
						tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v20 any = tmp19
						_ = v20
						// let binding "trace"
						tmp21 := checkDerefVar(glojure_DOT_core_into_array)
						tmp22 := checkDerefVar(glojure_DOT_core_drop)
						tmp23 := checkDerefVar(glojure_DOT_core_drop_while)
						tmp24 := lang.Apply(tmp23, []any{v20, v16})
						tmp25 := lang.Apply(tmp22, []any{int64(2), tmp24})
						tmp26 := lang.Apply(tmp21, []any{nil, tmp25})
						var v27 any = tmp26
						_ = v27
						tmp28, _ := lang.FieldOrMethod(v13, "setStackTrace")
						if reflect.TypeOf(tmp28).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setStackTrace is not a function")))
						}
						tmp29 := lang.Apply(tmp28, []any{v27})
						_ = tmp29
						tmp30 := checkDerefVar(glojure_DOT_core__STAR_file_STAR_)
						tmp31, ok := lang.FieldOrMethod(nil, "Deref")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "Deref")))
						}
						var tmp32 any
						switch reflect.TypeOf(tmp31).Kind() {
						case reflect.Func:
							tmp32 = lang.Apply(tmp31, nil)
						default:
							tmp32 = tmp31
						}
						tmp33, ok := lang.FieldOrMethod(nil, "Deref")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "Deref")))
						}
						var tmp34 any
						switch reflect.TypeOf(tmp33).Kind() {
						case reflect.Func:
							tmp34 = lang.Apply(tmp33, nil)
						default:
							tmp34 = tmp33
						}
						tmp35 := lang.Apply(lang.NewCompilerError, []any{tmp30, tmp32, tmp34, v13})
						panic(tmp35)
					} // end let
					tmp6 = tmp7
				} else {
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// time
	{
		tmp0 := lang.NewSymbol("time").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"))), lang.NewKeyword("doc"), "Evaluates expr and prints the time it took.  Returns the value of\n expr.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3885), lang.NewKeyword("end-line"), int(3885))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := checkDerefVar(glojure_DOT_core_seq)
			tmp7 := checkDerefVar(glojure_DOT_core_concat)
			tmp8 := checkDerefVar(glojure_DOT_core_list)
			tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("glojure.core/let")})
			tmp10 := checkDerefVar(glojure_DOT_core_list)
			tmp11 := checkDerefVar(glojure_DOT_core_apply)
			tmp12 := checkDerefVar(glojure_DOT_core_vector)
			tmp13 := checkDerefVar(glojure_DOT_core_seq)
			tmp14 := checkDerefVar(glojure_DOT_core_concat)
			tmp15 := checkDerefVar(glojure_DOT_core_list)
			tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("start__0__auto__")})
			tmp17 := checkDerefVar(glojure_DOT_core_list)
			tmp18 := checkDerefVar(glojure_DOT_core_seq)
			tmp19 := checkDerefVar(glojure_DOT_core_concat)
			tmp20 := checkDerefVar(glojure_DOT_core_list)
			tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol(".UnixNano")})
			tmp22 := checkDerefVar(glojure_DOT_core_list)
			tmp23 := checkDerefVar(glojure_DOT_core_seq)
			tmp24 := checkDerefVar(glojure_DOT_core_concat)
			tmp25 := checkDerefVar(glojure_DOT_core_list)
			tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol("time.Now")})
			tmp27 := lang.Apply(tmp24, []any{tmp26})
			tmp28 := lang.Apply(tmp23, []any{tmp27})
			tmp29 := lang.Apply(tmp22, []any{tmp28})
			tmp30 := lang.Apply(tmp19, []any{tmp21, tmp29})
			tmp31 := lang.Apply(tmp18, []any{tmp30})
			tmp32 := lang.Apply(tmp17, []any{tmp31})
			tmp33 := checkDerefVar(glojure_DOT_core_list)
			tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("ret__1__auto__")})
			tmp35 := checkDerefVar(glojure_DOT_core_list)
			tmp36 := lang.Apply(tmp35, []any{v5})
			tmp37 := lang.Apply(tmp14, []any{tmp16, tmp32, tmp34, tmp36})
			tmp38 := lang.Apply(tmp13, []any{tmp37})
			tmp39 := lang.Apply(tmp11, []any{tmp12, tmp38})
			tmp40 := lang.Apply(tmp10, []any{tmp39})
			tmp41 := checkDerefVar(glojure_DOT_core_list)
			tmp42 := checkDerefVar(glojure_DOT_core_seq)
			tmp43 := checkDerefVar(glojure_DOT_core_concat)
			tmp44 := checkDerefVar(glojure_DOT_core_list)
			tmp45 := lang.Apply(tmp44, []any{lang.NewSymbol("glojure.core/prn")})
			tmp46 := checkDerefVar(glojure_DOT_core_list)
			tmp47 := checkDerefVar(glojure_DOT_core_seq)
			tmp48 := checkDerefVar(glojure_DOT_core_concat)
			tmp49 := checkDerefVar(glojure_DOT_core_list)
			tmp50 := lang.Apply(tmp49, []any{lang.NewSymbol("glojure.core/str")})
			tmp51 := checkDerefVar(glojure_DOT_core_list)
			tmp52 := lang.Apply(tmp51, []any{"Elapsed time: "})
			tmp53 := checkDerefVar(glojure_DOT_core_list)
			tmp54 := checkDerefVar(glojure_DOT_core_seq)
			tmp55 := checkDerefVar(glojure_DOT_core_concat)
			tmp56 := checkDerefVar(glojure_DOT_core_list)
			tmp57 := lang.Apply(tmp56, []any{lang.NewSymbol("glojure.core//")})
			tmp58 := checkDerefVar(glojure_DOT_core_list)
			tmp59 := checkDerefVar(glojure_DOT_core_seq)
			tmp60 := checkDerefVar(glojure_DOT_core_concat)
			tmp61 := checkDerefVar(glojure_DOT_core_list)
			tmp62 := lang.Apply(tmp61, []any{lang.NewSymbol("glojure.core/double")})
			tmp63 := checkDerefVar(glojure_DOT_core_list)
			tmp64 := checkDerefVar(glojure_DOT_core_seq)
			tmp65 := checkDerefVar(glojure_DOT_core_concat)
			tmp66 := checkDerefVar(glojure_DOT_core_list)
			tmp67 := lang.Apply(tmp66, []any{lang.NewSymbol("glojure.core/-")})
			tmp68 := checkDerefVar(glojure_DOT_core_list)
			tmp69 := checkDerefVar(glojure_DOT_core_seq)
			tmp70 := checkDerefVar(glojure_DOT_core_concat)
			tmp71 := checkDerefVar(glojure_DOT_core_list)
			tmp72 := lang.Apply(tmp71, []any{lang.NewSymbol(".UnixNano")})
			tmp73 := checkDerefVar(glojure_DOT_core_list)
			tmp74 := checkDerefVar(glojure_DOT_core_seq)
			tmp75 := checkDerefVar(glojure_DOT_core_concat)
			tmp76 := checkDerefVar(glojure_DOT_core_list)
			tmp77 := lang.Apply(tmp76, []any{lang.NewSymbol("time.Now")})
			tmp78 := lang.Apply(tmp75, []any{tmp77})
			tmp79 := lang.Apply(tmp74, []any{tmp78})
			tmp80 := lang.Apply(tmp73, []any{tmp79})
			tmp81 := lang.Apply(tmp70, []any{tmp72, tmp80})
			tmp82 := lang.Apply(tmp69, []any{tmp81})
			tmp83 := lang.Apply(tmp68, []any{tmp82})
			tmp84 := checkDerefVar(glojure_DOT_core_list)
			tmp85 := lang.Apply(tmp84, []any{lang.NewSymbol("start__0__auto__")})
			tmp86 := lang.Apply(tmp65, []any{tmp67, tmp83, tmp85})
			tmp87 := lang.Apply(tmp64, []any{tmp86})
			tmp88 := lang.Apply(tmp63, []any{tmp87})
			tmp89 := lang.Apply(tmp60, []any{tmp62, tmp88})
			tmp90 := lang.Apply(tmp59, []any{tmp89})
			tmp91 := lang.Apply(tmp58, []any{tmp90})
			tmp92 := checkDerefVar(glojure_DOT_core_list)
			tmp93 := lang.Apply(tmp92, []any{float64(1e+06)})
			tmp94 := lang.Apply(tmp55, []any{tmp57, tmp91, tmp93})
			tmp95 := lang.Apply(tmp54, []any{tmp94})
			tmp96 := lang.Apply(tmp53, []any{tmp95})
			tmp97 := checkDerefVar(glojure_DOT_core_list)
			tmp98 := lang.Apply(tmp97, []any{" msecs"})
			tmp99 := lang.Apply(tmp48, []any{tmp50, tmp52, tmp96, tmp98})
			tmp100 := lang.Apply(tmp47, []any{tmp99})
			tmp101 := lang.Apply(tmp46, []any{tmp100})
			tmp102 := lang.Apply(tmp43, []any{tmp45, tmp101})
			tmp103 := lang.Apply(tmp42, []any{tmp102})
			tmp104 := lang.Apply(tmp41, []any{tmp103})
			tmp105 := checkDerefVar(glojure_DOT_core_list)
			tmp106 := lang.Apply(tmp105, []any{lang.NewSymbol("ret__1__auto__")})
			tmp107 := lang.Apply(tmp7, []any{tmp9, tmp40, tmp104, tmp106})
			tmp108 := lang.Apply(tmp6, []any{tmp107})
			return tmp108
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-array
	{
		tmp0 := lang.NewSymbol("to-array").WithMeta(lang.NewMap(lang.NewKeyword("tag"), "[Ljava.lang.Object;", lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns an array of Objects containing the contents of coll, which\n  can be any Collection.  Maps to java.util.Collection.toArray().", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(337), lang.NewKeyword("end-line"), int(337))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime7.RT, "ToArray")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ToArray is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), "[Ljava.lang.Object;")).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-array-2d
	{
		tmp0 := lang.NewSymbol("to-array-2d").WithMeta(lang.NewMap(lang.NewKeyword("tag"), "[[Ljava.lang.Object;", lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a (potentially-ragged) 2-dimensional array of Objects\n  containing the contents of coll, which can be any Collection of any\n  Collection.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4002), lang.NewKeyword("end-line"), int(4002))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := checkDerefVar(glojure_DOT_core_make_array)
				tmp6 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
				tmp7, _ := lang.FieldOrMethod(tmp6, "forName")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("forName is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{"[Ljava.lang.Object;"})
				tmp9, _ := lang.FieldOrMethod(v3, "size")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("size is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{})
				tmp11 := lang.Apply(tmp5, []any{tmp8, tmp10})
				var v12 any = tmp11
				_ = v12
				var tmp13 any
				{ // let
					// let binding "i"
					var v14 any = int64(0)
					_ = v14
					// let binding "xs"
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := lang.Apply(tmp15, []any{v3})
					var v17 any = tmp16
					_ = v17
					for {
						var tmp18 any
						if lang.IsTruthy(v17) {
							tmp19 := checkDerefVar(glojure_DOT_core_aset)
							tmp20 := checkDerefVar(glojure_DOT_core_to_array)
							tmp21 := checkDerefVar(glojure_DOT_core_first)
							tmp22 := lang.Apply(tmp21, []any{v17})
							tmp23 := lang.Apply(tmp20, []any{tmp22})
							tmp24 := lang.Apply(tmp19, []any{v12, v14, tmp23})
							_ = tmp24
							tmp26 := checkDerefVar(glojure_DOT_core_inc)
							tmp27 := lang.Apply(tmp26, []any{v14})
							var tmp25 any = tmp27
							tmp29 := checkDerefVar(glojure_DOT_core_next)
							tmp30 := lang.Apply(tmp29, []any{v17})
							var tmp28 any = tmp30
							v14 = tmp25
							v17 = tmp28
							continue
						} else {
						}
						tmp13 = tmp18
						break
					}
				} // end let
				_ = tmp13
				tmp4 = v12
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), "[[Ljava.lang.Object;")).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// trampoline
	{
		tmp0 := lang.NewSymbol("trampoline").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6293), lang.NewKeyword("end-line"), int(6293))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
			recur_loop_1073:
				var tmp4 any
				{ // let
					// let binding "ret"
					tmp5 := lang.Apply(v3, nil)
					var v6 any = tmp5
					_ = v6
					var tmp7 any
					tmp8 := checkDerefVar(glojure_DOT_core_fn_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v6})
					if lang.IsTruthy(tmp9) {
						var tmp10 any = v6
						v3 = tmp10
						goto recur_loop_1073
					} else {
						tmp7 = v6
					}
					tmp4 = tmp7
				} // end let
				return tmp4
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_trampoline)
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					tmp7 := checkDerefVar(glojure_DOT_core_apply)
					tmp8 := lang.Apply(tmp7, []any{v3, v4})
					return tmp8
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6309), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(6309), lang.NewKeyword("end-column"), int(32))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// transduce
	{
		tmp0 := lang.NewSymbol("transduce").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("f"), lang.NewSymbol("init"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6905), lang.NewKeyword("end-line"), int(6905))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_transduce)
				tmp7 := lang.Apply(v4, nil)
				tmp8 := lang.Apply(tmp6, []any{v3, v4, tmp7, v5})
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "f"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ret"
					var tmp10 any
					tmp11 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
					tmp12 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
					tmp13 := lang.Apply(tmp11, []any{tmp12, v6})
					if lang.IsTruthy(tmp13) {
						tmp14, _ := lang.FieldOrMethod(v6, "ReduceInit")
						if reflect.TypeOf(tmp14).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
						}
						tmp15 := lang.Apply(tmp14, []any{v9, v5})
						tmp10 = tmp15
					} else {
						tmp16 := checkDerefVar(glojure_DOT_core_DOT_protocols_coll_reduce)
						tmp17 := lang.Apply(tmp16, []any{v6, v9, v5})
						tmp10 = tmp17
					}
					var v18 any = tmp10
					_ = v18
					tmp19 := lang.Apply(v9, []any{v18})
					tmp7 = tmp19
				} // end let
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// transient
	{
		tmp0 := lang.NewSymbol("transient").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a new, transient version of the collection, in constant time.\n\n  Transients support a parallel set of 'changing' operations, with similar names\n  followed by ! - assoc!, conj! etc. These do the same things as their persistent\n  counterparts except the return values are themselves transient.\n\n  Note in particular that transients are not designed to be bashed in-place. You\n  must capture and use the return value in the next call. In this way, they support\n  the same code structure as the functional persistent code they replace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3335), lang.NewKeyword("end-line"), int(3335))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "AsTransient")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "AsTransient")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tree-seq
	{
		tmp0 := lang.NewSymbol("tree-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("branch?"), lang.NewSymbol("children"), lang.NewSymbol("root"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4955), lang.NewKeyword("end-line"), int(4955))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "walk"
				var tmp7 lang.FnFunc
				{ // function walk
					var v8 lang.FnFunc
					tmp7 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v9 := args[0]
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							tmp11 := checkDerefVar(glojure_DOT_core_cons)
							var tmp12 any
							tmp13 := lang.Apply(v3, []any{v9})
							if lang.IsTruthy(tmp13) {
								tmp14 := checkDerefVar(glojure_DOT_core_mapcat)
								tmp15 := lang.Apply(v4, []any{v9})
								tmp16 := lang.Apply(tmp14, []any{v8, tmp15})
								tmp12 = tmp16
							} else {
							}
							tmp17 := lang.Apply(tmp11, []any{v9, tmp12})
							return tmp17
						})
						tmp11 := lang.Apply(lang.NewLazySeq, []any{tmp10})
						return tmp11
					})
					v8 = tmp7
					_ = v8
				}
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4965), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(4969), lang.NewKeyword("end-column"), int(53))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v10 any = tmp9
				_ = v10
				tmp11 := lang.Apply(v10, []any{v5})
				tmp6 = tmp11
			} // end let
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// true?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("true?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is the value true, false otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(511), lang.NewKeyword("end-line"), int(511))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Identical, []any{v4, true})
			return tmp5
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// type
	{
		tmp0 := lang.NewSymbol("type").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns the :type metadata of x, or its Class if none", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3467), lang.NewKeyword("end-line"), int(3467))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(glojure_DOT_core_get)
				tmp6 := checkDerefVar(glojure_DOT_core_meta)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := lang.Apply(tmp5, []any{tmp7, lang.NewKeyword("type")})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp10 = v9
				} else {
					tmp11 := checkDerefVar(glojure_DOT_core_class)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp10 = tmp12
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-add
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-add__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/UncheckedAdd")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-add").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the sum of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1203), lang.NewKeyword("end-line"), int(1203))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "UncheckedAdd")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedAdd is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-add-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-add-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Unchecked_int_add")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-add-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the sum of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1196), lang.NewKeyword("end-line"), int(1196))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_add")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_add is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-byte
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-byte__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/UncheckedByteCast")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-byte").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to byte. Subject to rounding or truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3517), lang.NewKeyword("end-line"), int(3517))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedByteCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-char
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-char__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/UncheckedCharCast")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-char").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to char. Subject to rounding or truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3529), lang.NewKeyword("end-line"), int(3529))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime7.RT, "UncheckedCharCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedCharCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-dec
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-dec__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/UncheckedDec")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-dec").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one less than x, a long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1175), lang.NewKeyword("end-line"), int(1175))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "UncheckedDec")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedDec is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-dec-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-dec-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/Unchecked_int_dec")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-dec-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one less than x, an int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1168), lang.NewKeyword("end-line"), int(1168))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_dec")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_dec is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-divide-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-divide-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/UncheckedIntDivide")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-divide-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(26), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1238), lang.NewKeyword("end-line"), int(1238))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "UncheckedIntDivide")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedIntDivide is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-double
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-double__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/UncheckedDoubleCast")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-double").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to double. Subject to rounding.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3553), lang.NewKeyword("end-line"), int(3553))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.AsFloat64, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-float
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-float__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/UncheckedFloatCast")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-float").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to float. Subject to rounding.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3547), lang.NewKeyword("end-line"), int(3547))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedFloatCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-inc
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-inc__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/Unchecked_inc")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-inc").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one greater than x, a long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1161), lang.NewKeyword("end-line"), int(1161))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_inc")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_inc is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-inc-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-inc-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/Unchecked_int_inc")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-inc-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one greater than x, an int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1154), lang.NewKeyword("end-line"), int(1154))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_inc")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_inc is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/UncheckedIntCast")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to int. Subject to rounding or truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3535), lang.NewKeyword("end-line"), int(3535))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedIntCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-long
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-long__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/UncheckedLongCast")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-long").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to long. Subject to rounding or truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3541), lang.NewKeyword("end-line"), int(3541))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedLongCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-multiply
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-multiply__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Unchecked_multiply")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-multiply").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the product of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1231), lang.NewKeyword("end-line"), int(1231))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_multiply")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_multiply is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-multiply-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-multiply-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Unchecked_int_multiply")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-multiply-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the product of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1224), lang.NewKeyword("end-line"), int(1224))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_multiply")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_multiply is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-negate
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-negate__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/Unchecked_minus")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-negate").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the negation of x, a long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1189), lang.NewKeyword("end-line"), int(1189))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_negate")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_negate is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-negate-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-negate-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/Unchecked_int_negate")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-negate-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the negation of x, an int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(26), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1182), lang.NewKeyword("end-line"), int(1182))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_negate")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_negate is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-remainder-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-remainder-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Unchecked_int_remainder")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-remainder-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the remainder of division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(29), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1245), lang.NewKeyword("end-line"), int(1245))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_remainder")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_remainder is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-short
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-short__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/UncheckedShortCast")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-short").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to short. Subject to rounding or truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3523), lang.NewKeyword("end-line"), int(3523))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedShortCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-subtract
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-subtract__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Unchecked_minus")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-subtract").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the difference of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1217), lang.NewKeyword("end-line"), int(1217))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_minus")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_minus is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-subtract-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-subtract-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/Unchecked_int_subtract")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-subtract-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the difference of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1210), lang.NewKeyword("end-line"), int(1210))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_subtract")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_subtract is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// underive
	{
		tmp0 := lang.NewSymbol("underive").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag"), lang.NewSymbol("parent")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("tag"), lang.NewSymbol("parent"))), lang.NewKeyword("doc"), "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5643), lang.NewKeyword("end-line"), int(5643))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_alter_var_root)
				tmp6 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("global-hierarchy"))
				tmp7 := checkDerefVar(glojure_DOT_core_underive)
				tmp8 := lang.Apply(tmp5, []any{tmp6, tmp7, v3, v4})
				_ = tmp8
				return nil
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "parentMap"
					tmp7 := lang.Apply(lang.NewKeyword("parents"), []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "childsParents"
					var tmp9 any
					tmp10 := lang.Apply(v8, []any{v4})
					if lang.IsTruthy(tmp10) {
						tmp11 := checkDerefVar(glojure_DOT_core_disj)
						tmp12 := lang.Apply(v8, []any{v4})
						tmp13 := lang.Apply(tmp11, []any{tmp12, v5})
						tmp9 = tmp13
					} else {
						tmp14 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
						tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5652), lang.NewKeyword("column"), int(36), lang.NewKeyword("end-line"), int(5652), lang.NewKeyword("end-column"), int(38))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp16
					}
					var v17 any = tmp9
					_ = v17
					// let binding "newParents"
					var tmp18 any
					tmp19 := checkDerefVar(glojure_DOT_core_not_empty)
					tmp20 := lang.Apply(tmp19, []any{v17})
					if lang.IsTruthy(tmp20) {
						tmp21 := checkDerefVar(glojure_DOT_core_assoc)
						tmp22 := lang.Apply(tmp21, []any{v8, v4, v17})
						tmp18 = tmp22
					} else {
						tmp23 := checkDerefVar(glojure_DOT_core_dissoc)
						tmp24 := lang.Apply(tmp23, []any{v8, v4})
						tmp18 = tmp24
					}
					var v25 any = tmp18
					_ = v25
					// let binding "deriv-seq"
					tmp26 := checkDerefVar(glojure_DOT_core_flatten)
					tmp27 := checkDerefVar(glojure_DOT_core_map)
					var tmp28 lang.FnFunc
					tmp28 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v29 := args[0]
						_ = v29
						tmp30 := checkDerefVar(glojure_DOT_core_cons)
						tmp31 := checkDerefVar(glojure_DOT_core_key)
						tmp32 := lang.Apply(tmp31, []any{v29})
						tmp33 := checkDerefVar(glojure_DOT_core_interpose)
						tmp34 := checkDerefVar(glojure_DOT_core_key)
						tmp35 := lang.Apply(tmp34, []any{v29})
						tmp36 := checkDerefVar(glojure_DOT_core_val)
						tmp37 := lang.Apply(tmp36, []any{v29})
						tmp38 := lang.Apply(tmp33, []any{tmp35, tmp37})
						tmp39 := lang.Apply(tmp30, []any{tmp32, tmp38})
						return tmp39
					})
					tmp29 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5656), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(5656), lang.NewKeyword("end-column"), int(70))
					tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp31 := checkDerefVar(glojure_DOT_core_seq)
					tmp32 := lang.Apply(tmp31, []any{v25})
					tmp33 := lang.Apply(tmp27, []any{tmp30, tmp32})
					tmp34 := lang.Apply(tmp26, []any{tmp33})
					var v35 any = tmp34
					_ = v35
					var tmp36 any
					tmp37 := checkDerefVar(glojure_DOT_core_contains_QMARK_)
					tmp38 := lang.Apply(v8, []any{v4})
					tmp39 := lang.Apply(tmp37, []any{tmp38, v5})
					if lang.IsTruthy(tmp39) {
						tmp40 := checkDerefVar(glojure_DOT_core_reduce1)
						var tmp41 lang.FnFunc
						tmp41 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v42 := args[0]
							_ = v42
							v43 := args[1]
							_ = v43
							tmp44 := checkDerefVar(glojure_DOT_core_apply)
							tmp45 := checkDerefVar(glojure_DOT_core_derive)
							tmp46 := lang.Apply(tmp44, []any{tmp45, v42, v43})
							return tmp46
						})
						tmp42 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5659), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5659), lang.NewKeyword("end-column"), int(31))
						tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp44 := checkDerefVar(glojure_DOT_core_make_hierarchy)
						tmp45 := lang.Apply(tmp44, nil)
						tmp46 := checkDerefVar(glojure_DOT_core_partition)
						tmp47 := lang.Apply(tmp46, []any{int64(2), v35})
						tmp48 := lang.Apply(tmp40, []any{tmp43, tmp45, tmp47})
						tmp36 = tmp48
					} else {
						tmp36 = v3
					}
					tmp6 = tmp36
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unquote
	{
		tmp0 := lang.NewSymbol("unquote").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unquote-splicing
	{
		tmp0 := lang.NewSymbol("unquote-splicing").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unreduced
	{
		tmp0 := lang.NewSymbol("unreduced").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "If x is reduced?, returns (deref x), else returns x", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2847), lang.NewKeyword("end-line"), int(2847))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_reduced_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(glojure_DOT_core_deref)
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp4 = tmp8
			} else {
				tmp4 = v3
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unsigned-bit-shift-right
	{
		var tmp1 lang.FnFunc
		{ // function unsigned-bit-shift-right__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_seq)
				tmp6 := checkDerefVar(glojure_DOT_core_concat)
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol(".")})
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := checkDerefVar(glojure_DOT_core_concat)
				tmp14 := checkDerefVar(glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/UnsignedShiftRight")})
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unsigned-bit-shift-right").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise shift right, without sign-extension.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(30), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1373), lang.NewKeyword("end-line"), int(1373))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "UnsignedShiftRight")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UnsignedShiftRight is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update
	{
		tmp0 := lang.NewSymbol("update").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("k"), lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("k"), lang.NewSymbol("f"), lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("k"), lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("k"), lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("z")), lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("k"), lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("z"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6174), lang.NewKeyword("end-line"), int(6174))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_assoc)
				tmp7 := checkDerefVar(glojure_DOT_core_get)
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				tmp9 := lang.Apply(v5, []any{tmp8})
				tmp10 := lang.Apply(tmp6, []any{v3, v4, tmp9})
				return tmp10
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_assoc)
				tmp8 := checkDerefVar(glojure_DOT_core_get)
				tmp9 := lang.Apply(tmp8, []any{v3, v4})
				tmp10 := lang.Apply(v5, []any{tmp9, v6})
				tmp11 := lang.Apply(tmp7, []any{v3, v4, tmp10})
				return tmp11
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := checkDerefVar(glojure_DOT_core_assoc)
				tmp9 := checkDerefVar(glojure_DOT_core_get)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(v5, []any{tmp10, v6, v7})
				tmp12 := lang.Apply(tmp8, []any{v3, v4, tmp11})
				return tmp12
			case 6:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				tmp9 := checkDerefVar(glojure_DOT_core_assoc)
				tmp10 := checkDerefVar(glojure_DOT_core_get)
				tmp11 := lang.Apply(tmp10, []any{v3, v4})
				tmp12 := lang.Apply(v5, []any{tmp11, v6, v7, v8})
				tmp13 := lang.Apply(tmp9, []any{v3, v4, tmp12})
				return tmp13
			default:
				if len(args) < 6 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				var v9 any = lang.NewList(args[6:]...)
				_ = v9
				tmp10 := checkDerefVar(glojure_DOT_core_assoc)
				tmp11 := checkDerefVar(glojure_DOT_core_apply)
				tmp12 := checkDerefVar(glojure_DOT_core_get)
				tmp13 := lang.Apply(tmp12, []any{v3, v4})
				tmp14 := lang.Apply(tmp11, []any{v5, tmp13, v6, v7, v8, v9})
				tmp15 := lang.Apply(tmp10, []any{v3, v4, tmp14})
				return tmp15
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-in
	{
		tmp0 := lang.NewSymbol("update-in").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("ks"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6158), lang.NewKeyword("end-line"), int(6158))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "up"
					var tmp8 lang.FnFunc
					{ // function up
						var v9 lang.FnFunc
						tmp8 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 4 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v10 := args[0]
							_ = v10
							v11 := args[1]
							_ = v11
							v12 := args[2]
							_ = v12
							v13 := args[3]
							_ = v13
							var tmp14 any
							{ // let
								// let binding "vec__141"
								var v15 any = v11
								_ = v15
								// let binding "seq__142"
								tmp16 := checkDerefVar(glojure_DOT_core_seq)
								tmp17 := lang.Apply(tmp16, []any{v15})
								var v18 any = tmp17
								_ = v18
								// let binding "first__143"
								tmp19 := checkDerefVar(glojure_DOT_core_first)
								tmp20 := lang.Apply(tmp19, []any{v18})
								var v21 any = tmp20
								_ = v21
								// let binding "seq__142"
								tmp22 := checkDerefVar(glojure_DOT_core_next)
								tmp23 := lang.Apply(tmp22, []any{v18})
								var v24 any = tmp23
								_ = v24
								// let binding "k"
								var v25 any = v21
								_ = v25
								// let binding "ks"
								var v26 any = v24
								_ = v26
								var tmp27 any
								if lang.IsTruthy(v26) {
									tmp28 := checkDerefVar(glojure_DOT_core_assoc)
									tmp29 := checkDerefVar(glojure_DOT_core_get)
									tmp30 := lang.Apply(tmp29, []any{v10, v25})
									tmp31 := lang.Apply(v9, []any{tmp30, v26, v12, v13})
									tmp32 := lang.Apply(tmp28, []any{v10, v25, tmp31})
									tmp27 = tmp32
								} else {
									tmp33 := checkDerefVar(glojure_DOT_core_assoc)
									tmp34 := checkDerefVar(glojure_DOT_core_apply)
									tmp35 := checkDerefVar(glojure_DOT_core_get)
									tmp36 := lang.Apply(tmp35, []any{v10, v25})
									tmp37 := lang.Apply(tmp34, []any{v12, tmp36, v13})
									tmp38 := lang.Apply(tmp33, []any{v10, v25, tmp37})
									tmp27 = tmp38
								}
								tmp14 = tmp27
							} // end let
							return tmp14
						})
						v9 = tmp8
						_ = v9
					}
					tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6167), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(6171), lang.NewKeyword("end-column"), int(59))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v11 any = tmp10
					_ = v11
					tmp12 := lang.Apply(v11, []any{v3, v4, v5, v6})
					tmp7 = tmp12
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-keys
	{
		tmp0 := lang.NewSymbol("update-keys").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("f"))), lang.NewKeyword("doc"), "m f => {(f k) v ...}\n\n  Given a map m and a function f of 1-argument, returns a new map whose\n  keys are the result of applying f to the keys of m, mapped to the\n  corresponding values of m.\n  f must return a unique key for each key of m, else the behavior is undefined.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7906), lang.NewKeyword("end-line"), int(7906))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "ret"
				tmp6 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
				tmp7 := checkDerefVar(glojure_DOT_core_reduce_kv)
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 3 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v9 := args[0]
					_ = v9
					v10 := args[1]
					_ = v10
					v11 := args[2]
					_ = v11
					tmp12 := checkDerefVar(glojure_DOT_core_assoc_BANG_)
					tmp13 := lang.Apply(v4, []any{v10})
					tmp14 := lang.Apply(tmp12, []any{v9, tmp13, v11})
					return tmp14
				})
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7916), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(7916), lang.NewKeyword("end-column"), int(59))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := checkDerefVar(glojure_DOT_core_transient)
				tmp12 := lang.NewMap()
				tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7917), lang.NewKeyword("column"), int(36), lang.NewKeyword("end-line"), int(7917), lang.NewKeyword("end-column"), int(37))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp15 := lang.Apply(tmp11, []any{tmp14})
				tmp16 := lang.Apply(tmp7, []any{tmp10, tmp15, v3})
				tmp17 := lang.Apply(tmp6, []any{tmp16})
				var v18 any = tmp17
				_ = v18
				tmp19 := checkDerefVar(glojure_DOT_core_with_meta)
				tmp20 := checkDerefVar(glojure_DOT_core_meta)
				tmp21 := lang.Apply(tmp20, []any{v3})
				tmp22 := lang.Apply(tmp19, []any{v18, tmp21})
				tmp5 = tmp22
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-vals
	{
		tmp0 := lang.NewSymbol("update-vals").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("f"))), lang.NewKeyword("doc"), "m f => {k (f v) ...}\n\n  Given a map m and a function f of 1-argument, returns a new map where the keys of m\n  are mapped to result of applying f to the corresponding values of m.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7890), lang.NewKeyword("end-line"), int(7890))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(glojure_DOT_core_with_meta)
			tmp6 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
			tmp7 := checkDerefVar(glojure_DOT_core_reduce_kv)
			var tmp8 lang.FnFunc
			tmp8 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v9 := args[0]
				_ = v9
				v10 := args[1]
				_ = v10
				v11 := args[2]
				_ = v11
				tmp12 := checkDerefVar(glojure_DOT_core_assoc_BANG_)
				tmp13 := lang.Apply(v4, []any{v11})
				tmp14 := lang.Apply(tmp12, []any{v9, v10, tmp13})
				return tmp14
			})
			tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7899), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(7899), lang.NewKeyword("end-column"), int(51))
			tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp11 any
			tmp12 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp13 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
			tmp14 := lang.Apply(tmp12, []any{tmp13, v3})
			if lang.IsTruthy(tmp14) {
				tmp15 := checkDerefVar(glojure_DOT_core_transient)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp11 = tmp16
			} else {
				tmp17 := checkDerefVar(glojure_DOT_core_transient)
				tmp18 := lang.NewMap()
				tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7902), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(7902), lang.NewKeyword("end-column"), int(31))
				tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp21 := lang.Apply(tmp17, []any{tmp20})
				tmp11 = tmp21
			}
			tmp22 := lang.Apply(tmp7, []any{tmp10, tmp11, v3})
			tmp23 := lang.Apply(tmp6, []any{tmp22})
			tmp24 := checkDerefVar(glojure_DOT_core_meta)
			tmp25 := lang.Apply(tmp24, []any{v3})
			tmp26 := lang.Apply(tmp5, []any{tmp23, tmp25})
			return tmp26
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// uri?
	{
		tmp0 := lang.NewSymbol("uri?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a java.net.URI", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7877), lang.NewKeyword("end-line"), int(7877))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*url4.URL)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// use
	{
		tmp0 := lang.NewSymbol("use").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Like 'require, but also refers to each lib's namespace using\n  glojure.core/refer. Use :use in the ns macro in preference to calling\n  this directly.\n\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\n  The arguments and semantics for :exclude, :only, and :rename are the same\n  as those documented for glojure.core/refer.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6079), lang.NewKeyword("end-line"), int(6079))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_apply)
				tmp5 := checkDerefVar(glojure_DOT_core_load_libs)
				tmp6 := lang.Apply(tmp4, []any{tmp5, lang.NewKeyword("require"), lang.NewKeyword("use"), v3})
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// uuid?
	{
		tmp0 := lang.NewSymbol("uuid?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a java.util.UUID", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6847), lang.NewKeyword("end-line"), int(6847))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf([16]uint8{})
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// val
	{
		tmp0 := lang.NewSymbol("val").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("e"))), lang.NewKeyword("doc"), "Returns the value in the map entry.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1570), lang.NewKeyword("end-line"), int(1570))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "GetValue")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("GetValue is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vals
	{
		tmp0 := lang.NewSymbol("vals").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"))), lang.NewKeyword("doc"), "Returns a sequence of the map's values, in the same order as (seq map).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1557), lang.NewKeyword("end-line"), int(1557))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.Vals, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var-get
	{
		tmp0 := lang.NewSymbol("var-get").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Gets the value in the var object", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4326), lang.NewKeyword("end-line"), int(4326))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "Get")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Get is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var-set
	{
		tmp0 := lang.NewSymbol("var-set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Sets the value in the var object to val. The var must be\n thread-locally bound.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4332), lang.NewKeyword("end-line"), int(4332))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "Set")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Set is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var?
	{
		tmp0 := lang.NewSymbol("var?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("v"))), lang.NewKeyword("doc"), "Returns true if v is of type glojure.lang.Var", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4999), lang.NewKeyword("end-line"), int(4999))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Var)(nil))
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vary-meta
	{
		tmp0 := lang.NewSymbol("vary-meta").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("obj"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(668), lang.NewKeyword("end-line"), int(668))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_with_meta)
				tmp7 := checkDerefVar(glojure_DOT_core_apply)
				tmp8 := checkDerefVar(glojure_DOT_core_meta)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp7, []any{v4, tmp9, v5})
				tmp11 := lang.Apply(tmp6, []any{v3, tmp10})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vec
	{
		tmp0 := lang.NewSymbol("vec").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Creates a new vector containing the contents of coll. Java arrays\n  will be aliased and should not be modified.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(366), lang.NewKeyword("end-line"), int(366))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp9 := reflect.TypeOf((*lang.IObj)(nil)).Elem()
				tmp10 := lang.Apply(tmp8, []any{tmp9, v3})
				if lang.IsTruthy(tmp10) {
					tmp11 := checkDerefVar(glojure_DOT_core_with_meta)
					tmp12 := lang.Apply(tmp11, []any{v3, nil})
					tmp7 = tmp12
				} else {
					tmp13 := lang.Apply(lang.CreateLazilyPersistentVector, []any{v3})
					tmp7 = tmp13
				}
				tmp4 = tmp7
			} else {
				tmp14 := lang.Apply(lang.CreateLazilyPersistentVector, []any{v3})
				tmp4 = tmp14
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vector
	{
		tmp0 := lang.NewSymbol("vector").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("a")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d"), lang.NewSymbol("e")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d"), lang.NewSymbol("e"), lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d"), lang.NewSymbol("e"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Creates a new vector containing the args.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(352), lang.NewKeyword("end-line"), int(352))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.NewVector()
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(356), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(356), lang.NewKeyword("end-column"), int(8))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.NewVector(v3)
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(357), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(357), lang.NewKeyword("end-column"), int(10))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.NewVector(v3, v4)
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.NewVector(v3, v4, v5)
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(359), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(359), lang.NewKeyword("end-column"), int(18))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.NewVector(v3, v4, v5, v6)
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(360), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(360), lang.NewKeyword("end-column"), int(22))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp9
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := lang.NewVector(v3, v4, v5, v6, v7)
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(361), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(361), lang.NewKeyword("end-column"), int(25))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp10
			case 6:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				tmp9 := lang.NewVector(v3, v4, v5, v6, v7, v8)
				tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(362), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(362), lang.NewKeyword("end-column"), int(29))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp11
			default:
				if len(args) < 6 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				var v9 any = lang.NewList(args[6:]...)
				_ = v9
				tmp10 := checkDerefVar(glojure_DOT_core_cons)
				tmp11 := checkDerefVar(glojure_DOT_core_cons)
				tmp12 := checkDerefVar(glojure_DOT_core_cons)
				tmp13 := checkDerefVar(glojure_DOT_core_cons)
				tmp14 := checkDerefVar(glojure_DOT_core_cons)
				tmp15 := checkDerefVar(glojure_DOT_core_cons)
				tmp16 := lang.Apply(tmp15, []any{v8, v9})
				tmp17 := lang.Apply(tmp14, []any{v7, tmp16})
				tmp18 := lang.Apply(tmp13, []any{v6, tmp17})
				tmp19 := lang.Apply(tmp12, []any{v5, tmp18})
				tmp20 := lang.Apply(tmp11, []any{v4, tmp19})
				tmp21 := lang.Apply(tmp10, []any{v3, tmp20})
				tmp22 := lang.Apply(lang.CreateLazilyPersistentVector, []any{tmp21})
				return tmp22
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vector?
	{
		tmp0 := lang.NewSymbol("vector?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x implements IPersistentVector", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(174), lang.NewKeyword("end-line"), int(178))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function vector?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.IPersistentVector)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v4})
				return tmp7
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(178), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(178), lang.NewKeyword("end-column"), int(106))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// volatile!
	{
		tmp1 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
		tmp0 := lang.NewSymbol("volatile!").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Creates and returns a Volatile with an initial value of val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2517), lang.NewKeyword("end-line"), int(2517))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.NewVolatile, []any{v4})
			return tmp5
		})
		tmp4 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// volatile?
	{
		tmp0 := lang.NewSymbol("volatile?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is a volatile.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2540), lang.NewKeyword("end-line"), int(2540))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vreset!
	{
		tmp0 := lang.NewSymbol("vreset!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("vol"), lang.NewSymbol("newval"))), lang.NewKeyword("doc"), "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2524), lang.NewKeyword("end-line"), int(2524))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "reset")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vswap!
	{
		tmp0 := lang.NewSymbol("vswap!").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("vol"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(2531), lang.NewKeyword("end-line"), int(2531))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 any
				{ // let
					// let binding "v"
					tmp9 := checkDerefVar(glojure_DOT_core_with_meta)
					tmp10 := lang.NewMap(lang.NewKeyword("tag"), lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Volatile"))
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2537), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(2537), lang.NewKeyword("end-column"), int(81))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := lang.Apply(tmp9, []any{v5, tmp12})
					var v14 any = tmp13
					_ = v14
					tmp15 := checkDerefVar(glojure_DOT_core_seq)
					tmp16 := checkDerefVar(glojure_DOT_core_concat)
					tmp17 := checkDerefVar(glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".reset")})
					tmp19 := checkDerefVar(glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v14})
					tmp21 := checkDerefVar(glojure_DOT_core_list)
					tmp22 := checkDerefVar(glojure_DOT_core_seq)
					tmp23 := checkDerefVar(glojure_DOT_core_concat)
					tmp24 := checkDerefVar(glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v6})
					tmp26 := checkDerefVar(glojure_DOT_core_list)
					tmp27 := checkDerefVar(glojure_DOT_core_seq)
					tmp28 := checkDerefVar(glojure_DOT_core_concat)
					tmp29 := checkDerefVar(glojure_DOT_core_list)
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol(".Deref")})
					tmp31 := checkDerefVar(glojure_DOT_core_list)
					tmp32 := lang.Apply(tmp31, []any{v14})
					tmp33 := lang.Apply(tmp28, []any{tmp30, tmp32})
					tmp34 := lang.Apply(tmp27, []any{tmp33})
					tmp35 := lang.Apply(tmp26, []any{tmp34})
					tmp36 := lang.Apply(tmp23, []any{tmp25, tmp35, v7})
					tmp37 := lang.Apply(tmp22, []any{tmp36})
					tmp38 := lang.Apply(tmp21, []any{tmp37})
					tmp39 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp38})
					tmp40 := lang.Apply(tmp15, []any{tmp39})
					tmp8 = tmp40
				} // end let
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when
	{
		tmp0 := lang.NewSymbol("when").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("test"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Evaluates test. If logical true, evaluates body in an implicit do.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(492), lang.NewKeyword("end-line"), int(492))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := checkDerefVar(glojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("do"), v6})
				tmp10 := lang.Apply(tmp7, []any{lang.NewSymbol("if"), v5, tmp9})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-first
	{
		tmp0 := lang.NewSymbol("when-first").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4622), lang.NewKeyword("end-line"), int(4622))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(glojure_DOT_core_str)
					tmp11 := checkDerefVar(glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(lang.NewKeyword("line"), []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp21 := checkDerefVar(glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{int64(2), tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "exactly 2 forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "vec__20"
					var v34 any = v5
					_ = v34
					// let binding "x"
					tmp35 := checkDerefVar(glojure_DOT_core_nth)
					tmp36 := lang.Apply(tmp35, []any{v34, int64(0), nil})
					var v37 any = tmp36
					_ = v37
					// let binding "xs"
					tmp38 := checkDerefVar(glojure_DOT_core_nth)
					tmp39 := lang.Apply(tmp38, []any{v34, int64(1), nil})
					var v40 any = tmp39
					_ = v40
					tmp41 := checkDerefVar(glojure_DOT_core_seq)
					tmp42 := checkDerefVar(glojure_DOT_core_concat)
					tmp43 := checkDerefVar(glojure_DOT_core_list)
					tmp44 := lang.Apply(tmp43, []any{lang.NewSymbol("glojure.core/when-let")})
					tmp45 := checkDerefVar(glojure_DOT_core_list)
					tmp46 := checkDerefVar(glojure_DOT_core_apply)
					tmp47 := checkDerefVar(glojure_DOT_core_vector)
					tmp48 := checkDerefVar(glojure_DOT_core_seq)
					tmp49 := checkDerefVar(glojure_DOT_core_concat)
					tmp50 := checkDerefVar(glojure_DOT_core_list)
					tmp51 := lang.Apply(tmp50, []any{lang.NewSymbol("xs__0__auto__")})
					tmp52 := checkDerefVar(glojure_DOT_core_list)
					tmp53 := checkDerefVar(glojure_DOT_core_seq)
					tmp54 := checkDerefVar(glojure_DOT_core_concat)
					tmp55 := checkDerefVar(glojure_DOT_core_list)
					tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("glojure.core/seq")})
					tmp57 := checkDerefVar(glojure_DOT_core_list)
					tmp58 := lang.Apply(tmp57, []any{v40})
					tmp59 := lang.Apply(tmp54, []any{tmp56, tmp58})
					tmp60 := lang.Apply(tmp53, []any{tmp59})
					tmp61 := lang.Apply(tmp52, []any{tmp60})
					tmp62 := lang.Apply(tmp49, []any{tmp51, tmp61})
					tmp63 := lang.Apply(tmp48, []any{tmp62})
					tmp64 := lang.Apply(tmp46, []any{tmp47, tmp63})
					tmp65 := lang.Apply(tmp45, []any{tmp64})
					tmp66 := checkDerefVar(glojure_DOT_core_list)
					tmp67 := checkDerefVar(glojure_DOT_core_seq)
					tmp68 := checkDerefVar(glojure_DOT_core_concat)
					tmp69 := checkDerefVar(glojure_DOT_core_list)
					tmp70 := lang.Apply(tmp69, []any{lang.NewSymbol("glojure.core/let")})
					tmp71 := checkDerefVar(glojure_DOT_core_list)
					tmp72 := checkDerefVar(glojure_DOT_core_apply)
					tmp73 := checkDerefVar(glojure_DOT_core_vector)
					tmp74 := checkDerefVar(glojure_DOT_core_seq)
					tmp75 := checkDerefVar(glojure_DOT_core_concat)
					tmp76 := checkDerefVar(glojure_DOT_core_list)
					tmp77 := lang.Apply(tmp76, []any{v37})
					tmp78 := checkDerefVar(glojure_DOT_core_list)
					tmp79 := checkDerefVar(glojure_DOT_core_seq)
					tmp80 := checkDerefVar(glojure_DOT_core_concat)
					tmp81 := checkDerefVar(glojure_DOT_core_list)
					tmp82 := lang.Apply(tmp81, []any{lang.NewSymbol("glojure.core/first")})
					tmp83 := checkDerefVar(glojure_DOT_core_list)
					tmp84 := lang.Apply(tmp83, []any{lang.NewSymbol("xs__0__auto__")})
					tmp85 := lang.Apply(tmp80, []any{tmp82, tmp84})
					tmp86 := lang.Apply(tmp79, []any{tmp85})
					tmp87 := lang.Apply(tmp78, []any{tmp86})
					tmp88 := lang.Apply(tmp75, []any{tmp77, tmp87})
					tmp89 := lang.Apply(tmp74, []any{tmp88})
					tmp90 := lang.Apply(tmp72, []any{tmp73, tmp89})
					tmp91 := lang.Apply(tmp71, []any{tmp90})
					tmp92 := lang.Apply(tmp68, []any{tmp70, tmp91, v6})
					tmp93 := lang.Apply(tmp67, []any{tmp92})
					tmp94 := lang.Apply(tmp66, []any{tmp93})
					tmp95 := lang.Apply(tmp42, []any{tmp44, tmp65, tmp94})
					tmp96 := lang.Apply(tmp41, []any{tmp95})
					tmp33 = tmp96
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-let
	{
		tmp0 := lang.NewSymbol("when-let").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1859), lang.NewKeyword("end-line"), int(1859))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(glojure_DOT_core_str)
					tmp11 := checkDerefVar(glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(lang.NewKeyword("line"), []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp21 := checkDerefVar(glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{int64(2), tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "exactly 2 forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "form"
					tmp34 := lang.Apply(v5, []any{int64(0)})
					var v35 any = tmp34
					_ = v35
					// let binding "tst"
					tmp36 := lang.Apply(v5, []any{int64(1)})
					var v37 any = tmp36
					_ = v37
					tmp38 := checkDerefVar(glojure_DOT_core_seq)
					tmp39 := checkDerefVar(glojure_DOT_core_concat)
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{lang.NewSymbol("glojure.core/let")})
					tmp42 := checkDerefVar(glojure_DOT_core_list)
					tmp43 := checkDerefVar(glojure_DOT_core_apply)
					tmp44 := checkDerefVar(glojure_DOT_core_vector)
					tmp45 := checkDerefVar(glojure_DOT_core_seq)
					tmp46 := checkDerefVar(glojure_DOT_core_concat)
					tmp47 := checkDerefVar(glojure_DOT_core_list)
					tmp48 := lang.Apply(tmp47, []any{lang.NewSymbol("temp__0__auto__")})
					tmp49 := checkDerefVar(glojure_DOT_core_list)
					tmp50 := lang.Apply(tmp49, []any{v37})
					tmp51 := lang.Apply(tmp46, []any{tmp48, tmp50})
					tmp52 := lang.Apply(tmp45, []any{tmp51})
					tmp53 := lang.Apply(tmp43, []any{tmp44, tmp52})
					tmp54 := lang.Apply(tmp42, []any{tmp53})
					tmp55 := checkDerefVar(glojure_DOT_core_list)
					tmp56 := checkDerefVar(glojure_DOT_core_seq)
					tmp57 := checkDerefVar(glojure_DOT_core_concat)
					tmp58 := checkDerefVar(glojure_DOT_core_list)
					tmp59 := lang.Apply(tmp58, []any{lang.NewSymbol("glojure.core/when")})
					tmp60 := checkDerefVar(glojure_DOT_core_list)
					tmp61 := lang.Apply(tmp60, []any{lang.NewSymbol("temp__0__auto__")})
					tmp62 := checkDerefVar(glojure_DOT_core_list)
					tmp63 := checkDerefVar(glojure_DOT_core_seq)
					tmp64 := checkDerefVar(glojure_DOT_core_concat)
					tmp65 := checkDerefVar(glojure_DOT_core_list)
					tmp66 := lang.Apply(tmp65, []any{lang.NewSymbol("glojure.core/let")})
					tmp67 := checkDerefVar(glojure_DOT_core_list)
					tmp68 := checkDerefVar(glojure_DOT_core_apply)
					tmp69 := checkDerefVar(glojure_DOT_core_vector)
					tmp70 := checkDerefVar(glojure_DOT_core_seq)
					tmp71 := checkDerefVar(glojure_DOT_core_concat)
					tmp72 := checkDerefVar(glojure_DOT_core_list)
					tmp73 := lang.Apply(tmp72, []any{v35})
					tmp74 := checkDerefVar(glojure_DOT_core_list)
					tmp75 := lang.Apply(tmp74, []any{lang.NewSymbol("temp__0__auto__")})
					tmp76 := lang.Apply(tmp71, []any{tmp73, tmp75})
					tmp77 := lang.Apply(tmp70, []any{tmp76})
					tmp78 := lang.Apply(tmp68, []any{tmp69, tmp77})
					tmp79 := lang.Apply(tmp67, []any{tmp78})
					tmp80 := lang.Apply(tmp64, []any{tmp66, tmp79, v6})
					tmp81 := lang.Apply(tmp63, []any{tmp80})
					tmp82 := lang.Apply(tmp62, []any{tmp81})
					tmp83 := lang.Apply(tmp57, []any{tmp59, tmp61, tmp82})
					tmp84 := lang.Apply(tmp56, []any{tmp83})
					tmp85 := lang.Apply(tmp55, []any{tmp84})
					tmp86 := lang.Apply(tmp39, []any{tmp41, tmp54, tmp85})
					tmp87 := lang.Apply(tmp38, []any{tmp86})
					tmp33 = tmp87
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-not
	{
		tmp0 := lang.NewSymbol("when-not").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("test"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Evaluates test. If logical false, evaluates body in an implicit do.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(498), lang.NewKeyword("end-line"), int(498))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_list)
				tmp8 := checkDerefVar(glojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("do"), v6})
				tmp10 := lang.Apply(tmp7, []any{lang.NewSymbol("if"), v5, nil, tmp9})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-some
	{
		tmp0 := lang.NewSymbol("when-some").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "bindings => binding-form test\n\n   When test is not nil, evaluates body with binding-form bound to the\n   value of test", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1894), lang.NewKeyword("end-line"), int(1894))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(glojure_DOT_core_str)
					tmp11 := checkDerefVar(glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(lang.NewKeyword("line"), []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp21 := checkDerefVar(glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{int64(2), tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "exactly 2 forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "form"
					tmp34 := lang.Apply(v5, []any{int64(0)})
					var v35 any = tmp34
					_ = v35
					// let binding "tst"
					tmp36 := lang.Apply(v5, []any{int64(1)})
					var v37 any = tmp36
					_ = v37
					tmp38 := checkDerefVar(glojure_DOT_core_seq)
					tmp39 := checkDerefVar(glojure_DOT_core_concat)
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{lang.NewSymbol("glojure.core/let")})
					tmp42 := checkDerefVar(glojure_DOT_core_list)
					tmp43 := checkDerefVar(glojure_DOT_core_apply)
					tmp44 := checkDerefVar(glojure_DOT_core_vector)
					tmp45 := checkDerefVar(glojure_DOT_core_seq)
					tmp46 := checkDerefVar(glojure_DOT_core_concat)
					tmp47 := checkDerefVar(glojure_DOT_core_list)
					tmp48 := lang.Apply(tmp47, []any{lang.NewSymbol("temp__0__auto__")})
					tmp49 := checkDerefVar(glojure_DOT_core_list)
					tmp50 := lang.Apply(tmp49, []any{v37})
					tmp51 := lang.Apply(tmp46, []any{tmp48, tmp50})
					tmp52 := lang.Apply(tmp45, []any{tmp51})
					tmp53 := lang.Apply(tmp43, []any{tmp44, tmp52})
					tmp54 := lang.Apply(tmp42, []any{tmp53})
					tmp55 := checkDerefVar(glojure_DOT_core_list)
					tmp56 := checkDerefVar(glojure_DOT_core_seq)
					tmp57 := checkDerefVar(glojure_DOT_core_concat)
					tmp58 := checkDerefVar(glojure_DOT_core_list)
					tmp59 := lang.Apply(tmp58, []any{lang.NewSymbol("if")})
					tmp60 := checkDerefVar(glojure_DOT_core_list)
					tmp61 := checkDerefVar(glojure_DOT_core_seq)
					tmp62 := checkDerefVar(glojure_DOT_core_concat)
					tmp63 := checkDerefVar(glojure_DOT_core_list)
					tmp64 := lang.Apply(tmp63, []any{lang.NewSymbol("glojure.core/nil?")})
					tmp65 := checkDerefVar(glojure_DOT_core_list)
					tmp66 := lang.Apply(tmp65, []any{lang.NewSymbol("temp__0__auto__")})
					tmp67 := lang.Apply(tmp62, []any{tmp64, tmp66})
					tmp68 := lang.Apply(tmp61, []any{tmp67})
					tmp69 := lang.Apply(tmp60, []any{tmp68})
					tmp70 := checkDerefVar(glojure_DOT_core_list)
					tmp71 := lang.Apply(tmp70, []any{nil})
					tmp72 := checkDerefVar(glojure_DOT_core_list)
					tmp73 := checkDerefVar(glojure_DOT_core_seq)
					tmp74 := checkDerefVar(glojure_DOT_core_concat)
					tmp75 := checkDerefVar(glojure_DOT_core_list)
					tmp76 := lang.Apply(tmp75, []any{lang.NewSymbol("glojure.core/let")})
					tmp77 := checkDerefVar(glojure_DOT_core_list)
					tmp78 := checkDerefVar(glojure_DOT_core_apply)
					tmp79 := checkDerefVar(glojure_DOT_core_vector)
					tmp80 := checkDerefVar(glojure_DOT_core_seq)
					tmp81 := checkDerefVar(glojure_DOT_core_concat)
					tmp82 := checkDerefVar(glojure_DOT_core_list)
					tmp83 := lang.Apply(tmp82, []any{v35})
					tmp84 := checkDerefVar(glojure_DOT_core_list)
					tmp85 := lang.Apply(tmp84, []any{lang.NewSymbol("temp__0__auto__")})
					tmp86 := lang.Apply(tmp81, []any{tmp83, tmp85})
					tmp87 := lang.Apply(tmp80, []any{tmp86})
					tmp88 := lang.Apply(tmp78, []any{tmp79, tmp87})
					tmp89 := lang.Apply(tmp77, []any{tmp88})
					tmp90 := lang.Apply(tmp74, []any{tmp76, tmp89, v6})
					tmp91 := lang.Apply(tmp73, []any{tmp90})
					tmp92 := lang.Apply(tmp72, []any{tmp91})
					tmp93 := lang.Apply(tmp57, []any{tmp59, tmp69, tmp71, tmp92})
					tmp94 := lang.Apply(tmp56, []any{tmp93})
					tmp95 := lang.Apply(tmp55, []any{tmp94})
					tmp96 := lang.Apply(tmp39, []any{tmp41, tmp54, tmp95})
					tmp97 := lang.Apply(tmp38, []any{tmp96})
					tmp33 = tmp97
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// while
	{
		tmp0 := lang.NewSymbol("while").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("test"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(6327), lang.NewKeyword("end-line"), int(6327))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/loop")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_apply)
				tmp13 := checkDerefVar(glojure_DOT_core_vector)
				tmp14 := checkDerefVar(glojure_DOT_core_seq)
				tmp15 := checkDerefVar(glojure_DOT_core_concat)
				tmp16 := lang.Apply(tmp15, nil)
				tmp17 := lang.Apply(tmp14, []any{tmp16})
				tmp18 := lang.Apply(tmp12, []any{tmp13, tmp17})
				tmp19 := lang.Apply(tmp11, []any{tmp18})
				tmp20 := checkDerefVar(glojure_DOT_core_list)
				tmp21 := checkDerefVar(glojure_DOT_core_seq)
				tmp22 := checkDerefVar(glojure_DOT_core_concat)
				tmp23 := checkDerefVar(glojure_DOT_core_list)
				tmp24 := lang.Apply(tmp23, []any{lang.NewSymbol("glojure.core/when")})
				tmp25 := checkDerefVar(glojure_DOT_core_list)
				tmp26 := lang.Apply(tmp25, []any{v5})
				tmp27 := checkDerefVar(glojure_DOT_core_list)
				tmp28 := checkDerefVar(glojure_DOT_core_seq)
				tmp29 := checkDerefVar(glojure_DOT_core_concat)
				tmp30 := checkDerefVar(glojure_DOT_core_list)
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("recur")})
				tmp32 := lang.Apply(tmp29, []any{tmp31})
				tmp33 := lang.Apply(tmp28, []any{tmp32})
				tmp34 := lang.Apply(tmp27, []any{tmp33})
				tmp35 := lang.Apply(tmp22, []any{tmp24, tmp26, v6, tmp34})
				tmp36 := lang.Apply(tmp21, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp8, []any{tmp10, tmp19, tmp37})
				tmp39 := lang.Apply(tmp7, []any{tmp38})
				return tmp39
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-bindings
	{
		tmp0 := lang.NewSymbol("with-bindings").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("binding-map"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then executes body. Pops the installed\n  bindings after body was evaluated. Returns the value of body.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1984), lang.NewKeyword("end-line"), int(1984))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/with-bindings*")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := checkDerefVar(glojure_DOT_core_seq)
				tmp15 := checkDerefVar(glojure_DOT_core_concat)
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("glojure.core/fn")})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := checkDerefVar(glojure_DOT_core_apply)
				tmp20 := checkDerefVar(glojure_DOT_core_vector)
				tmp21 := checkDerefVar(glojure_DOT_core_seq)
				tmp22 := checkDerefVar(glojure_DOT_core_concat)
				tmp23 := lang.Apply(tmp22, nil)
				tmp24 := lang.Apply(tmp21, []any{tmp23})
				tmp25 := lang.Apply(tmp19, []any{tmp20, tmp24})
				tmp26 := lang.Apply(tmp18, []any{tmp25})
				tmp27 := lang.Apply(tmp15, []any{tmp17, tmp26, v6})
				tmp28 := lang.Apply(tmp14, []any{tmp27})
				tmp29 := lang.Apply(tmp13, []any{tmp28})
				tmp30 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp29})
				tmp31 := lang.Apply(tmp7, []any{tmp30})
				return tmp31
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-bindings*
	{
		tmp0 := lang.NewSymbol("with-bindings*").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("binding-map"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then calls f with the supplied arguments.\n  Pops the installed bindings after f returned. Returns whatever f returns.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1971), lang.NewKeyword("end-line"), int(1971))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_push_thread_bindings)
				tmp7 := lang.Apply(tmp6, []any{v3})
				_ = tmp7
				var tmp8 any
				func() {
					defer func() {
						tmp9 := checkDerefVar(glojure_DOT_core_pop_thread_bindings)
						tmp10 := lang.Apply(tmp9, nil)
						_ = tmp10
					}()
					tmp11 := checkDerefVar(glojure_DOT_core_apply)
					tmp12 := lang.Apply(tmp11, []any{v4, v5})
					tmp8 = tmp12
				}()
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-in-str
	{
		tmp0 := lang.NewSymbol("with-in-str").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Evaluates body in a context in which *in* is bound to a fresh\n  StringReader initialized with the string s.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4749), lang.NewKeyword("end-line"), int(4749))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/with-open")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_apply)
				tmp13 := checkDerefVar(glojure_DOT_core_vector)
				tmp14 := checkDerefVar(glojure_DOT_core_seq)
				tmp15 := checkDerefVar(glojure_DOT_core_concat)
				tmp16 := checkDerefVar(glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("s__0__auto__")})
				tmp18 := checkDerefVar(glojure_DOT_core_list)
				tmp19 := checkDerefVar(glojure_DOT_core_seq)
				tmp20 := checkDerefVar(glojure_DOT_core_concat)
				tmp21 := checkDerefVar(glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/->")})
				tmp23 := checkDerefVar(glojure_DOT_core_list)
				tmp24 := checkDerefVar(glojure_DOT_core_seq)
				tmp25 := checkDerefVar(glojure_DOT_core_concat)
				tmp26 := checkDerefVar(glojure_DOT_core_list)
				tmp27 := lang.Apply(tmp26, []any{lang.NewSymbol("java.io.StringReader.")})
				tmp28 := checkDerefVar(glojure_DOT_core_list)
				tmp29 := lang.Apply(tmp28, []any{v5})
				tmp30 := lang.Apply(tmp25, []any{tmp27, tmp29})
				tmp31 := lang.Apply(tmp24, []any{tmp30})
				tmp32 := lang.Apply(tmp23, []any{tmp31})
				tmp33 := checkDerefVar(glojure_DOT_core_list)
				tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.lang.LineNumberingPushbackReader.")})
				tmp35 := lang.Apply(tmp20, []any{tmp22, tmp32, tmp34})
				tmp36 := lang.Apply(tmp19, []any{tmp35})
				tmp37 := lang.Apply(tmp18, []any{tmp36})
				tmp38 := lang.Apply(tmp15, []any{tmp17, tmp37})
				tmp39 := lang.Apply(tmp14, []any{tmp38})
				tmp40 := lang.Apply(tmp12, []any{tmp13, tmp39})
				tmp41 := lang.Apply(tmp11, []any{tmp40})
				tmp42 := checkDerefVar(glojure_DOT_core_list)
				tmp43 := checkDerefVar(glojure_DOT_core_seq)
				tmp44 := checkDerefVar(glojure_DOT_core_concat)
				tmp45 := checkDerefVar(glojure_DOT_core_list)
				tmp46 := lang.Apply(tmp45, []any{lang.NewSymbol("glojure.core/binding")})
				tmp47 := checkDerefVar(glojure_DOT_core_list)
				tmp48 := checkDerefVar(glojure_DOT_core_apply)
				tmp49 := checkDerefVar(glojure_DOT_core_vector)
				tmp50 := checkDerefVar(glojure_DOT_core_seq)
				tmp51 := checkDerefVar(glojure_DOT_core_concat)
				tmp52 := checkDerefVar(glojure_DOT_core_list)
				tmp53 := lang.Apply(tmp52, []any{lang.NewSymbol("glojure.core/*in*")})
				tmp54 := checkDerefVar(glojure_DOT_core_list)
				tmp55 := lang.Apply(tmp54, []any{lang.NewSymbol("s__0__auto__")})
				tmp56 := lang.Apply(tmp51, []any{tmp53, tmp55})
				tmp57 := lang.Apply(tmp50, []any{tmp56})
				tmp58 := lang.Apply(tmp48, []any{tmp49, tmp57})
				tmp59 := lang.Apply(tmp47, []any{tmp58})
				tmp60 := lang.Apply(tmp44, []any{tmp46, tmp59, v6})
				tmp61 := lang.Apply(tmp43, []any{tmp60})
				tmp62 := lang.Apply(tmp42, []any{tmp61})
				tmp63 := lang.Apply(tmp8, []any{tmp10, tmp41, tmp62})
				tmp64 := lang.Apply(tmp7, []any{tmp63})
				return tmp64
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-loading-context
	{
		tmp0 := lang.NewSymbol("with-loading-context").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5734), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5734), lang.NewKeyword("end-column"), int(30), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("macro"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_concat)
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := checkDerefVar(glojure_DOT_core_seq)
				tmp10 := checkDerefVar(glojure_DOT_core_concat)
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{lang.NewSymbol("glojure.core/fn")})
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("loading__0__auto__")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := checkDerefVar(glojure_DOT_core_apply)
				tmp17 := checkDerefVar(glojure_DOT_core_vector)
				tmp18 := checkDerefVar(glojure_DOT_core_seq)
				tmp19 := checkDerefVar(glojure_DOT_core_concat)
				tmp20 := lang.Apply(tmp19, nil)
				tmp21 := lang.Apply(tmp18, []any{tmp20})
				tmp22 := lang.Apply(tmp16, []any{tmp17, tmp21})
				tmp23 := lang.Apply(tmp15, []any{tmp22})
				tmp24 := checkDerefVar(glojure_DOT_core_list)
				tmp25 := checkDerefVar(glojure_DOT_core_seq)
				tmp26 := checkDerefVar(glojure_DOT_core_concat)
				tmp27 := checkDerefVar(glojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PushThreadBindings")})
				tmp29 := checkDerefVar(glojure_DOT_core_list)
				tmp30 := checkDerefVar(glojure_DOT_core_apply)
				tmp31 := checkDerefVar(glojure_DOT_core_hash_map)
				tmp32 := checkDerefVar(glojure_DOT_core_seq)
				tmp33 := checkDerefVar(glojure_DOT_core_concat)
				tmp34 := lang.Apply(tmp33, nil)
				tmp35 := lang.Apply(tmp32, []any{tmp34})
				tmp36 := lang.Apply(tmp30, []any{tmp31, tmp35})
				tmp37 := lang.Apply(tmp29, []any{tmp36})
				tmp38 := lang.Apply(tmp26, []any{tmp28, tmp37})
				tmp39 := lang.Apply(tmp25, []any{tmp38})
				tmp40 := lang.Apply(tmp24, []any{tmp39})
				tmp41 := checkDerefVar(glojure_DOT_core_list)
				tmp42 := checkDerefVar(glojure_DOT_core_seq)
				tmp43 := checkDerefVar(glojure_DOT_core_concat)
				tmp44 := checkDerefVar(glojure_DOT_core_list)
				tmp45 := lang.Apply(tmp44, []any{lang.NewSymbol("try")})
				tmp46 := checkDerefVar(glojure_DOT_core_list)
				tmp47 := checkDerefVar(glojure_DOT_core_seq)
				tmp48 := checkDerefVar(glojure_DOT_core_concat)
				tmp49 := checkDerefVar(glojure_DOT_core_list)
				tmp50 := lang.Apply(tmp49, []any{lang.NewSymbol("finally")})
				tmp51 := checkDerefVar(glojure_DOT_core_list)
				tmp52 := checkDerefVar(glojure_DOT_core_seq)
				tmp53 := checkDerefVar(glojure_DOT_core_concat)
				tmp54 := checkDerefVar(glojure_DOT_core_list)
				tmp55 := lang.Apply(tmp54, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PopThreadBindings")})
				tmp56 := lang.Apply(tmp53, []any{tmp55})
				tmp57 := lang.Apply(tmp52, []any{tmp56})
				tmp58 := lang.Apply(tmp51, []any{tmp57})
				tmp59 := lang.Apply(tmp48, []any{tmp50, tmp58})
				tmp60 := lang.Apply(tmp47, []any{tmp59})
				tmp61 := lang.Apply(tmp46, []any{tmp60})
				tmp62 := lang.Apply(tmp43, []any{tmp45, v5, tmp61})
				tmp63 := lang.Apply(tmp42, []any{tmp62})
				tmp64 := lang.Apply(tmp41, []any{tmp63})
				tmp65 := lang.Apply(tmp10, []any{tmp12, tmp14, tmp23, tmp40, tmp64})
				tmp66 := lang.Apply(tmp9, []any{tmp65})
				tmp67 := lang.Apply(tmp8, []any{tmp66})
				tmp68 := lang.Apply(tmp7, []any{tmp67})
				tmp69 := lang.Apply(tmp6, []any{tmp68})
				return tmp69
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-local-vars
	{
		tmp0 := lang.NewSymbol("with-local-vars").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name-vals-vec"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "varbinding=> symbol init-expr\n\n  Executes the exprs in a context in which the symbols are bound to\n  vars with per-thread bindings to the init-exprs.  The symbols refer\n  to the var objects themselves, and must be accessed with var-get and\n  var-set", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4339), lang.NewKeyword("end-line"), int(4339))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(glojure_DOT_core_str)
					tmp11 := checkDerefVar(glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(lang.NewKeyword("line"), []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				tmp33 := checkDerefVar(glojure_DOT_core_seq)
				tmp34 := checkDerefVar(glojure_DOT_core_concat)
				tmp35 := checkDerefVar(glojure_DOT_core_list)
				tmp36 := lang.Apply(tmp35, []any{lang.NewSymbol("glojure.core/let")})
				tmp37 := checkDerefVar(glojure_DOT_core_list)
				tmp38 := checkDerefVar(glojure_DOT_core_apply)
				tmp39 := checkDerefVar(glojure_DOT_core_vector)
				tmp40 := checkDerefVar(glojure_DOT_core_seq)
				tmp41 := checkDerefVar(glojure_DOT_core_concat)
				tmp42 := checkDerefVar(glojure_DOT_core_interleave)
				tmp43 := checkDerefVar(glojure_DOT_core_take_nth)
				tmp44 := lang.Apply(tmp43, []any{int64(2), v5})
				tmp45 := checkDerefVar(glojure_DOT_core_repeat)
				tmp46 := lang.Apply(tmp45, []any{lang.NewList(lang.NewSymbol(".."), lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.*Var"), lang.NewSymbol("create"), lang.NewSymbol("setDynamic"))})
				tmp47 := lang.Apply(tmp42, []any{tmp44, tmp46})
				tmp48 := lang.Apply(tmp41, []any{tmp47})
				tmp49 := lang.Apply(tmp40, []any{tmp48})
				tmp50 := lang.Apply(tmp38, []any{tmp39, tmp49})
				tmp51 := lang.Apply(tmp37, []any{tmp50})
				tmp52 := checkDerefVar(glojure_DOT_core_list)
				tmp53 := checkDerefVar(glojure_DOT_core_seq)
				tmp54 := checkDerefVar(glojure_DOT_core_concat)
				tmp55 := checkDerefVar(glojure_DOT_core_list)
				tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PushThreadBindings")})
				tmp57 := checkDerefVar(glojure_DOT_core_list)
				tmp58 := checkDerefVar(glojure_DOT_core_apply)
				tmp59 := checkDerefVar(glojure_DOT_core_hash_map)
				tmp60 := checkDerefVar(glojure_DOT_core_seq)
				tmp61 := checkDerefVar(glojure_DOT_core_concat)
				tmp62 := lang.Apply(tmp61, nil)
				tmp63 := lang.Apply(tmp60, []any{tmp62})
				tmp64 := lang.Apply(tmp58, []any{tmp59, tmp63})
				tmp65 := lang.Apply(tmp57, []any{tmp64})
				tmp66 := lang.Apply(tmp54, []any{tmp56, tmp65})
				tmp67 := lang.Apply(tmp53, []any{tmp66})
				tmp68 := lang.Apply(tmp52, []any{tmp67})
				tmp69 := checkDerefVar(glojure_DOT_core_list)
				tmp70 := checkDerefVar(glojure_DOT_core_seq)
				tmp71 := checkDerefVar(glojure_DOT_core_concat)
				tmp72 := checkDerefVar(glojure_DOT_core_list)
				tmp73 := lang.Apply(tmp72, []any{lang.NewSymbol("try")})
				tmp74 := checkDerefVar(glojure_DOT_core_list)
				tmp75 := checkDerefVar(glojure_DOT_core_seq)
				tmp76 := checkDerefVar(glojure_DOT_core_concat)
				tmp77 := checkDerefVar(glojure_DOT_core_list)
				tmp78 := lang.Apply(tmp77, []any{lang.NewSymbol("finally")})
				tmp79 := checkDerefVar(glojure_DOT_core_list)
				tmp80 := checkDerefVar(glojure_DOT_core_seq)
				tmp81 := checkDerefVar(glojure_DOT_core_concat)
				tmp82 := checkDerefVar(glojure_DOT_core_list)
				tmp83 := lang.Apply(tmp82, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PopThreadBindings")})
				tmp84 := lang.Apply(tmp81, []any{tmp83})
				tmp85 := lang.Apply(tmp80, []any{tmp84})
				tmp86 := lang.Apply(tmp79, []any{tmp85})
				tmp87 := lang.Apply(tmp76, []any{tmp78, tmp86})
				tmp88 := lang.Apply(tmp75, []any{tmp87})
				tmp89 := lang.Apply(tmp74, []any{tmp88})
				tmp90 := lang.Apply(tmp71, []any{tmp73, v6, tmp89})
				tmp91 := lang.Apply(tmp70, []any{tmp90})
				tmp92 := lang.Apply(tmp69, []any{tmp91})
				tmp93 := lang.Apply(tmp34, []any{tmp36, tmp51, tmp68, tmp92})
				tmp94 := lang.Apply(tmp33, []any{tmp93})
				return tmp94
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-meta
	{
		tmp0 := lang.NewSymbol("with-meta").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("obj"), lang.NewSymbol("m"))), lang.NewKeyword("doc"), "Returns an object of the same type and value as obj, with\n    map m as its metadata.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(211), lang.NewKeyword("end-line"), int(216))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function with-meta
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v4, "WithMeta")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("WithMeta is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v5})
				return tmp7
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(216), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(217), lang.NewKeyword("end-column"), int(32))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-open
	{
		tmp0 := lang.NewSymbol("with-open").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "bindings => [name init ...]\n\n  Evaluates body in a try expression with names bound to the values\n  of the inits, and a finally clause that calls (.close name) on each\n  name in reverse order.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3832), lang.NewKeyword("end-line"), int(3832))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(glojure_DOT_core_str)
					tmp11 := checkDerefVar(glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(lang.NewKeyword("line"), []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(glojure_DOT_core_str)
					tmp25 := checkDerefVar(glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(lang.NewKeyword("line"), []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				tmp34 := checkDerefVar(glojure_DOT_core__EQ_)
				tmp35 := checkDerefVar(glojure_DOT_core_count)
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp34, []any{tmp36, int64(0)})
				if lang.IsTruthy(tmp37) {
					tmp38 := checkDerefVar(glojure_DOT_core_seq)
					tmp39 := checkDerefVar(glojure_DOT_core_concat)
					tmp40 := checkDerefVar(glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{lang.NewSymbol("do")})
					tmp42 := lang.Apply(tmp39, []any{tmp41, v6})
					tmp43 := lang.Apply(tmp38, []any{tmp42})
					tmp33 = tmp43
				} else {
					var tmp44 any
					tmp45 := checkDerefVar(glojure_DOT_core_symbol_QMARK_)
					tmp46 := lang.Apply(v5, []any{int64(0)})
					tmp47 := lang.Apply(tmp45, []any{tmp46})
					if lang.IsTruthy(tmp47) {
						tmp48 := checkDerefVar(glojure_DOT_core_seq)
						tmp49 := checkDerefVar(glojure_DOT_core_concat)
						tmp50 := checkDerefVar(glojure_DOT_core_list)
						tmp51 := lang.Apply(tmp50, []any{lang.NewSymbol("glojure.core/let")})
						tmp52 := checkDerefVar(glojure_DOT_core_list)
						tmp53 := checkDerefVar(glojure_DOT_core_subvec)
						tmp54 := lang.Apply(tmp53, []any{v5, int64(0), int64(2)})
						tmp55 := lang.Apply(tmp52, []any{tmp54})
						tmp56 := checkDerefVar(glojure_DOT_core_list)
						tmp57 := checkDerefVar(glojure_DOT_core_seq)
						tmp58 := checkDerefVar(glojure_DOT_core_concat)
						tmp59 := checkDerefVar(glojure_DOT_core_list)
						tmp60 := lang.Apply(tmp59, []any{lang.NewSymbol("try")})
						tmp61 := checkDerefVar(glojure_DOT_core_list)
						tmp62 := checkDerefVar(glojure_DOT_core_seq)
						tmp63 := checkDerefVar(glojure_DOT_core_concat)
						tmp64 := checkDerefVar(glojure_DOT_core_list)
						tmp65 := lang.Apply(tmp64, []any{lang.NewSymbol("glojure.core/with-open")})
						tmp66 := checkDerefVar(glojure_DOT_core_list)
						tmp67 := checkDerefVar(glojure_DOT_core_subvec)
						tmp68 := lang.Apply(tmp67, []any{v5, int64(2)})
						tmp69 := lang.Apply(tmp66, []any{tmp68})
						tmp70 := lang.Apply(tmp63, []any{tmp65, tmp69, v6})
						tmp71 := lang.Apply(tmp62, []any{tmp70})
						tmp72 := lang.Apply(tmp61, []any{tmp71})
						tmp73 := checkDerefVar(glojure_DOT_core_list)
						tmp74 := checkDerefVar(glojure_DOT_core_seq)
						tmp75 := checkDerefVar(glojure_DOT_core_concat)
						tmp76 := checkDerefVar(glojure_DOT_core_list)
						tmp77 := lang.Apply(tmp76, []any{lang.NewSymbol("finally")})
						tmp78 := checkDerefVar(glojure_DOT_core_list)
						tmp79 := checkDerefVar(glojure_DOT_core_seq)
						tmp80 := checkDerefVar(glojure_DOT_core_concat)
						tmp81 := checkDerefVar(glojure_DOT_core_list)
						tmp82 := lang.Apply(tmp81, []any{lang.NewSymbol(".")})
						tmp83 := checkDerefVar(glojure_DOT_core_list)
						tmp84 := lang.Apply(v5, []any{int64(0)})
						tmp85 := lang.Apply(tmp83, []any{tmp84})
						tmp86 := checkDerefVar(glojure_DOT_core_list)
						tmp87 := lang.Apply(tmp86, []any{lang.NewSymbol("close")})
						tmp88 := lang.Apply(tmp80, []any{tmp82, tmp85, tmp87})
						tmp89 := lang.Apply(tmp79, []any{tmp88})
						tmp90 := lang.Apply(tmp78, []any{tmp89})
						tmp91 := lang.Apply(tmp75, []any{tmp77, tmp90})
						tmp92 := lang.Apply(tmp74, []any{tmp91})
						tmp93 := lang.Apply(tmp73, []any{tmp92})
						tmp94 := lang.Apply(tmp58, []any{tmp60, tmp72, tmp93})
						tmp95 := lang.Apply(tmp57, []any{tmp94})
						tmp96 := lang.Apply(tmp56, []any{tmp95})
						tmp97 := lang.Apply(tmp49, []any{tmp51, tmp55, tmp96})
						tmp98 := lang.Apply(tmp48, []any{tmp97})
						tmp44 = tmp98
					} else {
						var tmp99 any
						if lang.IsTruthy(lang.NewKeyword("else")) {
							tmp100 := lang.Apply(lang.NewIllegalArgumentError, []any{"with-open only allows Symbols in bindings"})
							panic(tmp100)
						} else {
						}
						tmp44 = tmp99
					}
					tmp33 = tmp44
				}
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-out-str
	{
		tmp0 := lang.NewSymbol("with-out-str").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Evaluates exprs in a context in which *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4738), lang.NewKeyword("end-line"), int(4738))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(glojure_DOT_core_seq)
				tmp7 := checkDerefVar(glojure_DOT_core_concat)
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("glojure.core/let")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_apply)
				tmp12 := checkDerefVar(glojure_DOT_core_vector)
				tmp13 := checkDerefVar(glojure_DOT_core_seq)
				tmp14 := checkDerefVar(glojure_DOT_core_concat)
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("s__0__auto__")})
				tmp17 := checkDerefVar(glojure_DOT_core_list)
				tmp18 := checkDerefVar(glojure_DOT_core_seq)
				tmp19 := checkDerefVar(glojure_DOT_core_concat)
				tmp20 := checkDerefVar(glojure_DOT_core_list)
				tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("new")})
				tmp22 := checkDerefVar(glojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("strings.Builder")})
				tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
				tmp25 := lang.Apply(tmp18, []any{tmp24})
				tmp26 := lang.Apply(tmp17, []any{tmp25})
				tmp27 := lang.Apply(tmp14, []any{tmp16, tmp26})
				tmp28 := lang.Apply(tmp13, []any{tmp27})
				tmp29 := lang.Apply(tmp11, []any{tmp12, tmp28})
				tmp30 := lang.Apply(tmp10, []any{tmp29})
				tmp31 := checkDerefVar(glojure_DOT_core_list)
				tmp32 := checkDerefVar(glojure_DOT_core_seq)
				tmp33 := checkDerefVar(glojure_DOT_core_concat)
				tmp34 := checkDerefVar(glojure_DOT_core_list)
				tmp35 := lang.Apply(tmp34, []any{lang.NewSymbol("glojure.core/binding")})
				tmp36 := checkDerefVar(glojure_DOT_core_list)
				tmp37 := checkDerefVar(glojure_DOT_core_apply)
				tmp38 := checkDerefVar(glojure_DOT_core_vector)
				tmp39 := checkDerefVar(glojure_DOT_core_seq)
				tmp40 := checkDerefVar(glojure_DOT_core_concat)
				tmp41 := checkDerefVar(glojure_DOT_core_list)
				tmp42 := lang.Apply(tmp41, []any{lang.NewSymbol("glojure.core/*out*")})
				tmp43 := checkDerefVar(glojure_DOT_core_list)
				tmp44 := lang.Apply(tmp43, []any{lang.NewSymbol("s__0__auto__")})
				tmp45 := lang.Apply(tmp40, []any{tmp42, tmp44})
				tmp46 := lang.Apply(tmp39, []any{tmp45})
				tmp47 := lang.Apply(tmp37, []any{tmp38, tmp46})
				tmp48 := lang.Apply(tmp36, []any{tmp47})
				tmp49 := checkDerefVar(glojure_DOT_core_list)
				tmp50 := checkDerefVar(glojure_DOT_core_seq)
				tmp51 := checkDerefVar(glojure_DOT_core_concat)
				tmp52 := checkDerefVar(glojure_DOT_core_list)
				tmp53 := lang.Apply(tmp52, []any{lang.NewSymbol("glojure.core/str")})
				tmp54 := checkDerefVar(glojure_DOT_core_list)
				tmp55 := lang.Apply(tmp54, []any{lang.NewSymbol("s__0__auto__")})
				tmp56 := lang.Apply(tmp51, []any{tmp53, tmp55})
				tmp57 := lang.Apply(tmp50, []any{tmp56})
				tmp58 := lang.Apply(tmp49, []any{tmp57})
				tmp59 := lang.Apply(tmp33, []any{tmp35, tmp48, v5, tmp58})
				tmp60 := lang.Apply(tmp32, []any{tmp59})
				tmp61 := lang.Apply(tmp31, []any{tmp60})
				tmp62 := lang.Apply(tmp7, []any{tmp9, tmp30, tmp61})
				tmp63 := lang.Apply(tmp6, []any{tmp62})
				return tmp63
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-precision
	{
		tmp0 := lang.NewSymbol("with-precision").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("precision"), lang.NewSymbol("&"), lang.NewSymbol("exprs"))), lang.NewKeyword("doc"), "Sets the precision and rounding mode to be used for BigDecimal operations.\n\n  Usage: (with-precision 10 (/ 1M 3))\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\n\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5110), lang.NewKeyword("end-line"), int(5110))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "vec__65"
					var tmp8 any
					tmp9 := checkDerefVar(glojure_DOT_core__EQ_)
					tmp10 := checkDerefVar(glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v6})
					tmp12 := lang.Apply(tmp9, []any{tmp11, lang.NewKeyword("rounding")})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(glojure_DOT_core_next)
						tmp14 := checkDerefVar(glojure_DOT_core_next)
						tmp15 := lang.Apply(tmp14, []any{v6})
						tmp16 := lang.Apply(tmp13, []any{tmp15})
						tmp17 := checkDerefVar(glojure_DOT_core_seq)
						tmp18 := checkDerefVar(glojure_DOT_core_concat)
						tmp19 := checkDerefVar(glojure_DOT_core_list)
						tmp20 := checkDerefVar(glojure_DOT_core_seq)
						tmp21 := checkDerefVar(glojure_DOT_core_concat)
						tmp22 := checkDerefVar(glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol(".")})
						tmp24 := checkDerefVar(glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{lang.NewSymbol("java.math.RoundingMode")})
						tmp26 := checkDerefVar(glojure_DOT_core_list)
						tmp27 := checkDerefVar(glojure_DOT_core_second)
						tmp28 := lang.Apply(tmp27, []any{v6})
						tmp29 := lang.Apply(tmp26, []any{tmp28})
						tmp30 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp29})
						tmp31 := lang.Apply(tmp20, []any{tmp30})
						tmp32 := lang.Apply(tmp19, []any{tmp31})
						tmp33 := lang.Apply(tmp18, []any{tmp32})
						tmp34 := lang.Apply(tmp17, []any{tmp33})
						tmp35 := lang.NewVector(tmp16, tmp34)
						tmp36 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5121), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(5122), lang.NewKeyword("end-column"), int(69))
						tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp37
					} else {
						tmp38 := lang.NewVector(v6, nil)
						tmp39 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5123), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(5123), lang.NewKeyword("end-column"), int(33))
						tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp40
					}
					var v41 any = tmp8
					_ = v41
					// let binding "body"
					tmp42 := checkDerefVar(glojure_DOT_core_nth)
					tmp43 := lang.Apply(tmp42, []any{v41, int64(0), nil})
					var v44 any = tmp43
					_ = v44
					// let binding "rm"
					tmp45 := checkDerefVar(glojure_DOT_core_nth)
					tmp46 := lang.Apply(tmp45, []any{v41, int64(1), nil})
					var v47 any = tmp46
					_ = v47
					tmp48 := checkDerefVar(glojure_DOT_core_seq)
					tmp49 := checkDerefVar(glojure_DOT_core_concat)
					tmp50 := checkDerefVar(glojure_DOT_core_list)
					tmp51 := lang.Apply(tmp50, []any{lang.NewSymbol("glojure.core/binding")})
					tmp52 := checkDerefVar(glojure_DOT_core_list)
					tmp53 := checkDerefVar(glojure_DOT_core_apply)
					tmp54 := checkDerefVar(glojure_DOT_core_vector)
					tmp55 := checkDerefVar(glojure_DOT_core_seq)
					tmp56 := checkDerefVar(glojure_DOT_core_concat)
					tmp57 := checkDerefVar(glojure_DOT_core_list)
					tmp58 := lang.Apply(tmp57, []any{lang.NewSymbol("glojure.core/*math-context*")})
					tmp59 := checkDerefVar(glojure_DOT_core_list)
					tmp60 := checkDerefVar(glojure_DOT_core_seq)
					tmp61 := checkDerefVar(glojure_DOT_core_concat)
					tmp62 := checkDerefVar(glojure_DOT_core_list)
					tmp63 := lang.Apply(tmp62, []any{lang.NewSymbol("java.math.MathContext.")})
					tmp64 := checkDerefVar(glojure_DOT_core_list)
					tmp65 := lang.Apply(tmp64, []any{v5})
					tmp66 := lang.Apply(tmp61, []any{tmp63, tmp65, v47})
					tmp67 := lang.Apply(tmp60, []any{tmp66})
					tmp68 := lang.Apply(tmp59, []any{tmp67})
					tmp69 := lang.Apply(tmp56, []any{tmp58, tmp68})
					tmp70 := lang.Apply(tmp55, []any{tmp69})
					tmp71 := lang.Apply(tmp53, []any{tmp54, tmp70})
					tmp72 := lang.Apply(tmp52, []any{tmp71})
					tmp73 := lang.Apply(tmp49, []any{tmp51, tmp72, v44})
					tmp74 := lang.Apply(tmp48, []any{tmp73})
					tmp7 = tmp74
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-redefs
	{
		tmp0 := lang.NewSymbol("with-redefs").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "binding => var-symbol temp-value-expr\n\n  Temporarily redefines Vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var.  After the body is\n  executed, the root values of all the Vars will be set back to their\n  old values.  These temporary changes will be visible in all threads.\n  Useful for mocking out functions during testing.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7544), lang.NewKeyword("end-line"), int(7544))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(glojure_DOT_core_seq)
				tmp8 := checkDerefVar(glojure_DOT_core_concat)
				tmp9 := checkDerefVar(glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/with-redefs-fn")})
				tmp11 := checkDerefVar(glojure_DOT_core_list)
				tmp12 := checkDerefVar(glojure_DOT_core_zipmap)
				tmp13 := checkDerefVar(glojure_DOT_core_map)
				var tmp14 lang.FnFunc
				tmp14 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v15 := args[0]
					_ = v15
					tmp16 := checkDerefVar(glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("var"), v15})
					return tmp17
				})
				tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7555), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(7555), lang.NewKeyword("end-column"), int(47))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp17 := checkDerefVar(glojure_DOT_core_take_nth)
				tmp18 := lang.Apply(tmp17, []any{int64(2), v5})
				tmp19 := lang.Apply(tmp13, []any{tmp16, tmp18})
				tmp20 := checkDerefVar(glojure_DOT_core_take_nth)
				tmp21 := checkDerefVar(glojure_DOT_core_next)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{int64(2), tmp22})
				tmp24 := lang.Apply(tmp12, []any{tmp19, tmp23})
				tmp25 := lang.Apply(tmp11, []any{tmp24})
				tmp26 := checkDerefVar(glojure_DOT_core_list)
				tmp27 := checkDerefVar(glojure_DOT_core_seq)
				tmp28 := checkDerefVar(glojure_DOT_core_concat)
				tmp29 := checkDerefVar(glojure_DOT_core_list)
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/fn")})
				tmp31 := checkDerefVar(glojure_DOT_core_list)
				tmp32 := checkDerefVar(glojure_DOT_core_apply)
				tmp33 := checkDerefVar(glojure_DOT_core_vector)
				tmp34 := checkDerefVar(glojure_DOT_core_seq)
				tmp35 := checkDerefVar(glojure_DOT_core_concat)
				tmp36 := lang.Apply(tmp35, nil)
				tmp37 := lang.Apply(tmp34, []any{tmp36})
				tmp38 := lang.Apply(tmp32, []any{tmp33, tmp37})
				tmp39 := lang.Apply(tmp31, []any{tmp38})
				tmp40 := lang.Apply(tmp28, []any{tmp30, tmp39, v6})
				tmp41 := lang.Apply(tmp27, []any{tmp40})
				tmp42 := lang.Apply(tmp26, []any{tmp41})
				tmp43 := lang.Apply(tmp8, []any{tmp10, tmp25, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-redefs-fn
	{
		tmp0 := lang.NewSymbol("with-redefs-fn").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("binding-map"), lang.NewSymbol("func"))), lang.NewKeyword("doc"), "Temporarily redefines Vars during a call to func.  Each val of\n  binding-map will replace the root value of its key which must be\n  a Var.  After func is called with no args, the root values of all\n  the Vars will be set back to their old values.  These temporary\n  changes will be visible in all threads.  Useful for mocking out\n  functions during testing.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7524), lang.NewKeyword("end-line"), int(7524))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "root-bind"
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v7 := args[0]
					_ = v7
					var tmp8 any
					{ // let
						// let binding "seq_338"
						tmp9 := checkDerefVar(glojure_DOT_core_seq)
						tmp10 := lang.Apply(tmp9, []any{v7})
						var v11 any = tmp10
						_ = v11
						// let binding "chunk_339"
						var v12 any = nil
						_ = v12
						// let binding "count_340"
						var v13 any = int64(0)
						_ = v13
						// let binding "i_341"
						var v14 any = int64(0)
						_ = v14
						for {
							var tmp15 any
							tmp16 := checkDerefVar(glojure_DOT_core__LT_)
							tmp17 := lang.Apply(tmp16, []any{v14, v13})
							if lang.IsTruthy(tmp17) {
								var tmp18 any
								{ // let
									// let binding "vec__342"
									tmp19, _ := lang.FieldOrMethod(v12, "nth")
									if reflect.TypeOf(tmp19).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp20 := lang.Apply(tmp19, []any{v14})
									var v21 any = tmp20
									_ = v21
									// let binding "a-var"
									tmp22 := checkDerefVar(glojure_DOT_core_nth)
									tmp23 := lang.Apply(tmp22, []any{v21, int64(0), nil})
									var v24 any = tmp23
									_ = v24
									// let binding "a-val"
									tmp25 := checkDerefVar(glojure_DOT_core_nth)
									tmp26 := lang.Apply(tmp25, []any{v21, int64(1), nil})
									var v27 any = tmp26
									_ = v27
									tmp28, _ := lang.FieldOrMethod(v24, "bindRoot")
									if reflect.TypeOf(tmp28).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("bindRoot is not a function")))
									}
									tmp29 := lang.Apply(tmp28, []any{v27})
									_ = tmp29
									var tmp30 any = v11
									var tmp31 any = v12
									var tmp32 any = v13
									tmp34 := checkDerefVar(glojure_DOT_core_unchecked_inc)
									tmp35 := lang.Apply(tmp34, []any{v14})
									var tmp33 any = tmp35
									v11 = tmp30
									v12 = tmp31
									v13 = tmp32
									v14 = tmp33
									continue
								} // end let
								tmp15 = tmp18
							} else {
								var tmp19 any
								{ // let
									// let binding "temp__0__auto__"
									tmp20 := checkDerefVar(glojure_DOT_core_seq)
									tmp21 := lang.Apply(tmp20, []any{v11})
									var v22 any = tmp21
									_ = v22
									var tmp23 any
									if lang.IsTruthy(v22) {
										var tmp24 any
										{ // let
											// let binding "seq_338"
											var v25 any = v22
											_ = v25
											var tmp26 any
											tmp27 := checkDerefVar(glojure_DOT_core_chunked_seq_QMARK_)
											tmp28 := lang.Apply(tmp27, []any{v25})
											if lang.IsTruthy(tmp28) {
												var tmp29 any
												{ // let
													// let binding "c__0__auto__"
													tmp30 := checkDerefVar(glojure_DOT_core_chunk_first)
													tmp31 := lang.Apply(tmp30, []any{v25})
													var v32 any = tmp31
													_ = v32
													tmp34 := checkDerefVar(glojure_DOT_core_chunk_rest)
													tmp35 := lang.Apply(tmp34, []any{v25})
													var tmp33 any = tmp35
													var tmp36 any = v32
													tmp38 := checkDerefVar(glojure_DOT_core_int)
													tmp39 := checkDerefVar(glojure_DOT_core_count)
													tmp40 := lang.Apply(tmp39, []any{v32})
													tmp41 := lang.Apply(tmp38, []any{tmp40})
													var tmp37 any = tmp41
													tmp43 := checkDerefVar(glojure_DOT_core_int)
													tmp44 := lang.Apply(tmp43, []any{int64(0)})
													var tmp42 any = tmp44
													v11 = tmp33
													v12 = tmp36
													v13 = tmp37
													v14 = tmp42
													continue
												} // end let
												tmp26 = tmp29
											} else {
												var tmp30 any
												{ // let
													// let binding "vec__345"
													tmp31 := checkDerefVar(glojure_DOT_core_first)
													tmp32 := lang.Apply(tmp31, []any{v25})
													var v33 any = tmp32
													_ = v33
													// let binding "a-var"
													tmp34 := checkDerefVar(glojure_DOT_core_nth)
													tmp35 := lang.Apply(tmp34, []any{v33, int64(0), nil})
													var v36 any = tmp35
													_ = v36
													// let binding "a-val"
													tmp37 := checkDerefVar(glojure_DOT_core_nth)
													tmp38 := lang.Apply(tmp37, []any{v33, int64(1), nil})
													var v39 any = tmp38
													_ = v39
													tmp40, _ := lang.FieldOrMethod(v36, "bindRoot")
													if reflect.TypeOf(tmp40).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("bindRoot is not a function")))
													}
													tmp41 := lang.Apply(tmp40, []any{v39})
													_ = tmp41
													tmp43 := checkDerefVar(glojure_DOT_core_next)
													tmp44 := lang.Apply(tmp43, []any{v25})
													var tmp42 any = tmp44
													var tmp45 any = nil
													var tmp46 any = int64(0)
													var tmp47 any = int64(0)
													v11 = tmp42
													v12 = tmp45
													v13 = tmp46
													v14 = tmp47
													continue
												} // end let
												tmp26 = tmp30
											}
											tmp24 = tmp26
										} // end let
										tmp23 = tmp24
									} else {
									}
									tmp19 = tmp23
								} // end let
								tmp15 = tmp19
							}
							tmp8 = tmp15
							break
						}
					} // end let
					return tmp8
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7533), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(7535), lang.NewKeyword("end-column"), int(93))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v9 any = tmp8
				_ = v9
				// let binding "old-vals"
				tmp10 := checkDerefVar(glojure_DOT_core_zipmap)
				tmp11 := checkDerefVar(glojure_DOT_core_keys)
				tmp12 := lang.Apply(tmp11, []any{v3})
				tmp13 := checkDerefVar(glojure_DOT_core_map)
				var tmp14 lang.FnFunc
				tmp14 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v15 := args[0]
					_ = v15
					tmp16, ok := lang.FieldOrMethod(v15, "getRawRoot")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v15, "getRawRoot")))
					}
					var tmp17 any
					switch reflect.TypeOf(tmp16).Kind() {
					case reflect.Func:
						tmp17 = lang.Apply(tmp16, nil)
					default:
						tmp17 = tmp16
					}
					return tmp17
				})
				tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7537), lang.NewKeyword("column"), int(31), lang.NewKeyword("end-line"), int(7537), lang.NewKeyword("end-column"), int(92))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp17 := checkDerefVar(glojure_DOT_core_keys)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp13, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp10, []any{tmp12, tmp19})
				var v21 any = tmp20
				_ = v21
				var tmp22 any
				func() {
					defer func() {
						tmp23 := lang.Apply(v9, []any{v21})
						_ = tmp23
					}()
					tmp24 := lang.Apply(v9, []any{v3})
					_ = tmp24
					tmp25 := lang.Apply(v4, nil)
					tmp22 = tmp25
				}()
				tmp5 = tmp22
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// xml-seq
	{
		tmp0 := lang.NewSymbol("xml-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("root"))), lang.NewKeyword("doc"), "A tree seq on the xml elements as per xml/parse", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4982), lang.NewKeyword("end-line"), int(4982))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(glojure_DOT_core_tree_seq)
			tmp5 := checkDerefVar(glojure_DOT_core_complement)
			tmp6 := checkDerefVar(glojure_DOT_core_string_QMARK_)
			tmp7 := lang.Apply(tmp5, []any{tmp6})
			tmp8 := checkDerefVar(glojure_DOT_core_comp)
			tmp9 := checkDerefVar(glojure_DOT_core_seq)
			tmp10 := lang.Apply(tmp8, []any{tmp9, lang.NewKeyword("content")})
			tmp11 := lang.Apply(tmp4, []any{tmp7, tmp10, v3})
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// zero?
	{
		var tmp1 lang.FnFunc
		{ // function zero?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(glojure_DOT_core_seq)
				tmp5 := checkDerefVar(glojure_DOT_core_concat)
				tmp6 := checkDerefVar(glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{lang.NewSymbol(".")})
				tmp8 := checkDerefVar(glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp10 := checkDerefVar(glojure_DOT_core_list)
				tmp11 := checkDerefVar(glojure_DOT_core_seq)
				tmp12 := checkDerefVar(glojure_DOT_core_concat)
				tmp13 := checkDerefVar(glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol("glojure.core/IsZero")})
				tmp15 := checkDerefVar(glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("zero?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if num is zero, else false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(860), lang.NewKeyword("end-line"), int(860))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IsZero")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IsZero is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// zipmap
	{
		tmp0 := lang.NewSymbol("zipmap").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("keys"), lang.NewSymbol("vals"))), lang.NewKeyword("doc"), "Returns a map with the keys mapped to the corresponding vals.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6583), lang.NewKeyword("end-line"), int(6583))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "map"
				tmp6 := checkDerefVar(glojure_DOT_core_transient)
				tmp7 := lang.NewMap()
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6588), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(6588), lang.NewKeyword("end-column"), int(28))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := lang.Apply(tmp6, []any{tmp9})
				var v11 any = tmp10
				_ = v11
				// let binding "ks"
				tmp12 := checkDerefVar(glojure_DOT_core_seq)
				tmp13 := lang.Apply(tmp12, []any{v3})
				var v14 any = tmp13
				_ = v14
				// let binding "vs"
				tmp15 := checkDerefVar(glojure_DOT_core_seq)
				tmp16 := lang.Apply(tmp15, []any{v4})
				var v17 any = tmp16
				_ = v17
				for {
					var tmp18 any
					var tmp19 any
					{ // let
						// let binding "and__0__auto__"
						var v20 any = v14
						_ = v20
						var tmp21 any
						if lang.IsTruthy(v20) {
							tmp21 = v17
						} else {
							tmp21 = v20
						}
						tmp19 = tmp21
					} // end let
					if lang.IsTruthy(tmp19) {
						tmp21 := checkDerefVar(glojure_DOT_core_assoc_BANG_)
						tmp22 := checkDerefVar(glojure_DOT_core_first)
						tmp23 := lang.Apply(tmp22, []any{v14})
						tmp24 := checkDerefVar(glojure_DOT_core_first)
						tmp25 := lang.Apply(tmp24, []any{v17})
						tmp26 := lang.Apply(tmp21, []any{v11, tmp23, tmp25})
						var tmp20 any = tmp26
						tmp28 := checkDerefVar(glojure_DOT_core_next)
						tmp29 := lang.Apply(tmp28, []any{v14})
						var tmp27 any = tmp29
						tmp31 := checkDerefVar(glojure_DOT_core_next)
						tmp32 := lang.Apply(tmp31, []any{v17})
						var tmp30 any = tmp32
						v11 = tmp20
						v14 = tmp27
						v17 = tmp30
						continue
					} else {
						tmp33 := checkDerefVar(glojure_DOT_core_persistent_BANG_)
						tmp34 := lang.Apply(tmp33, []any{v11})
						tmp18 = tmp34
					}
					tmp5 = tmp18
					break
				}
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}

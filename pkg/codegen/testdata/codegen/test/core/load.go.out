// Code generated by glojure codegen. DO NOT EDIT.

package core

import (
	errors8 "errors"
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
	uuid13 "github.com/google/uuid"
	io4 "io"
	math7 "math"
	big9 "math/big"
	rand16 "math/rand"
	http17 "net/http"
	url5 "net/url"
	os6 "os"
	reflect "reflect"
	regexp15 "regexp"
	runtime14 "runtime"
	strconv12 "strconv"
	strings11 "strings"
	time10 "time"
)

func init() {
	runtime.RegisterNSLoader("glojure.core", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "glojure.core"
func LoadNS() {
	sym__PCT_ := lang.NewSymbol("%")
	sym__AMP_ := lang.NewSymbol("&")
	sym__AMP_env := lang.NewSymbol("&env")
	sym__AMP_form := lang.NewSymbol("&form")
	sym__STAR_ := lang.NewSymbol("*")
	sym__STAR__TICK_ := lang.NewSymbol("*'")
	sym__STAR_1 := lang.NewSymbol("*1")
	sym__STAR_2 := lang.NewSymbol("*2")
	sym__STAR_3 := lang.NewSymbol("*3")
	sym__STAR_agent_STAR_ := lang.NewSymbol("*agent*")
	sym__STAR_assert_STAR_ := lang.NewSymbol("*assert*")
	sym__STAR_command_DASH_line_DASH_args_STAR_ := lang.NewSymbol("*command-line-args*")
	sym__STAR_compile_DASH_files_STAR_ := lang.NewSymbol("*compile-files*")
	sym__STAR_compile_DASH_path_STAR_ := lang.NewSymbol("*compile-path*")
	sym__STAR_compiler_DASH_options_STAR_ := lang.NewSymbol("*compiler-options*")
	sym__STAR_data_DASH_readers_STAR_ := lang.NewSymbol("*data-readers*")
	sym__STAR_default_DASH_data_DASH_reader_DASH_fn_STAR_ := lang.NewSymbol("*default-data-reader-fn*")
	sym__STAR_e := lang.NewSymbol("*e")
	sym__STAR_err_STAR_ := lang.NewSymbol("*err*")
	sym__STAR_file_STAR_ := lang.NewSymbol("*file*")
	sym__STAR_flush_DASH_on_DASH_newline_STAR_ := lang.NewSymbol("*flush-on-newline*")
	sym__STAR_in_STAR_ := lang.NewSymbol("*in*")
	sym__STAR_loaded_DASH_libs_STAR_ := lang.NewSymbol("*loaded-libs*")
	sym__STAR_loading_DASH_verbosely_STAR_ := lang.NewSymbol("*loading-verbosely*")
	sym__STAR_ns_STAR_ := lang.NewSymbol("*ns*")
	sym__STAR_out_STAR_ := lang.NewSymbol("*out*")
	sym__STAR_pending_DASH_paths_STAR_ := lang.NewSymbol("*pending-paths*")
	sym__STAR_print_DASH_dup_STAR_ := lang.NewSymbol("*print-dup*")
	sym__STAR_print_DASH_length_STAR_ := lang.NewSymbol("*print-length*")
	sym__STAR_print_DASH_level_STAR_ := lang.NewSymbol("*print-level*")
	sym__STAR_print_DASH_meta_STAR_ := lang.NewSymbol("*print-meta*")
	sym__STAR_print_DASH_namespace_DASH_maps_STAR_ := lang.NewSymbol("*print-namespace-maps*")
	sym__STAR_print_DASH_readably_STAR_ := lang.NewSymbol("*print-readably*")
	sym__STAR_read_DASH_eval_STAR_ := lang.NewSymbol("*read-eval*")
	sym__STAR_repl_STAR_ := lang.NewSymbol("*repl*")
	sym__STAR_unchecked_DASH_math_STAR_ := lang.NewSymbol("*unchecked-math*")
	sym__STAR_verbose_DASH_defrecords_STAR_ := lang.NewSymbol("*verbose-defrecords*")
	sym__STAR_warn_DASH_on_DASH_reflection_STAR_ := lang.NewSymbol("*warn-on-reflection*")
	sym__PLUS_ := lang.NewSymbol("+")
	sym__PLUS__TICK_ := lang.NewSymbol("+'")
	sym__DASH_ := lang.NewSymbol("-")
	sym__DASH__TICK_ := lang.NewSymbol("-'")
	sym__DASH__GT_ := lang.NewSymbol("->")
	sym__DASH__GT__GT_ := lang.NewSymbol("->>")
	sym__DASH_protocols := lang.NewSymbol("-protocols")
	sym__DOT_ := lang.NewSymbol(".")
	sym__DOT__DOT_ := lang.NewSymbol("..")
	sym__DOT_Deref := lang.NewSymbol(".Deref")
	sym__DOT_Equals := lang.NewSymbol(".Equals")
	sym__DOT_HasRoot := lang.NewSymbol(".HasRoot")
	sym__DOT_ResetMeta := lang.NewSymbol(".ResetMeta")
	sym__DOT_UnixNano := lang.NewSymbol(".UnixNano")
	sym__DOT_nth := lang.NewSymbol(".nth")
	sym__DOT_reset := lang.NewSymbol(".reset")
	sym__SLASH_ := lang.NewSymbol("/")
	sym__LT_ := lang.NewSymbol("<")
	sym__LT__EQ_ := lang.NewSymbol("<=")
	sym__EQ_ := lang.NewSymbol("=")
	sym__EQ__EQ_ := lang.NewSymbol("==")
	sym__GT_ := lang.NewSymbol(">")
	sym__GT_0_QMARK_ := lang.NewSymbol(">0?")
	sym__GT_1_QMARK_ := lang.NewSymbol(">1?")
	sym__GT__EQ_ := lang.NewSymbol(">=")
	sym_CollReduce := lang.NewSymbol("CollReduce")
	sym_Datafiable := lang.NewSymbol("Datafiable")
	sym_Double_SLASH_isInfinite := lang.NewSymbol("Double/isInfinite")
	sym_IKVReduce := lang.NewSymbol("IKVReduce")
	sym_IOFactory := lang.NewSymbol("IOFactory")
	sym_InternalReduce := lang.NewSymbol("InternalReduce")
	sym_NaN_QMARK_ := lang.NewSymbol("NaN?")
	sym_Navigable := lang.NewSymbol("Navigable")
	sym_SetMacro := lang.NewSymbol("SetMacro")
	sym_StackTraceElement_DASH__GT_vec := lang.NewSymbol("StackTraceElement->vec")
	sym_Throwable_DASH__GT_map := lang.NewSymbol("Throwable->map")
	sym_a := lang.NewSymbol("a")
	sym_a__0__auto__ := lang.NewSymbol("a__0__auto__")
	sym_abs := lang.NewSymbol("abs")
	sym_accessor := lang.NewSymbol("accessor")
	sym_aclone := lang.NewSymbol("aclone")
	sym_add := lang.NewSymbol("add")
	sym_add_DASH_classpath := lang.NewSymbol("add-classpath")
	sym_add_DASH_doc_DASH_and_DASH_meta := lang.NewSymbol("add-doc-and-meta")
	sym_add_DASH_watch := lang.NewSymbol("add-watch")
	sym_addP := lang.NewSymbol("addP")
	sym_agent := lang.NewSymbol("agent")
	sym_agent_DASH_error := lang.NewSymbol("agent-error")
	sym_agent_DASH_errors := lang.NewSymbol("agent-errors")
	sym_agents := lang.NewSymbol("agents")
	sym_aget := lang.NewSymbol("aget")
	sym_alength := lang.NewSymbol("alength")
	sym_alias := lang.NewSymbol("alias")
	sym_all_DASH_ns := lang.NewSymbol("all-ns")
	sym_alter := lang.NewSymbol("alter")
	sym_alter_DASH_meta_BANG_ := lang.NewSymbol("alter-meta!")
	sym_alter_DASH_var_DASH_root := lang.NewSymbol("alter-var-root")
	sym_amap := lang.NewSymbol("amap")
	sym_ancestors := lang.NewSymbol("ancestors")
	sym_and := lang.NewSymbol("and")
	sym_andNot := lang.NewSymbol("andNot")
	sym_and__0__auto__ := lang.NewSymbol("and__0__auto__")
	sym_any_QMARK_ := lang.NewSymbol("any?")
	sym_apply := lang.NewSymbol("apply")
	sym_areduce := lang.NewSymbol("areduce")
	sym_arg1 := lang.NewSymbol("arg1")
	sym_arg2 := lang.NewSymbol("arg2")
	sym_arg3 := lang.NewSymbol("arg3")
	sym_arglist := lang.NewSymbol("arglist")
	sym_args := lang.NewSymbol("args")
	sym_array := lang.NewSymbol("array")
	sym_array_DASH_map := lang.NewSymbol("array-map")
	sym_array__0__auto__ := lang.NewSymbol("array__0__auto__")
	sym_as_DASH__GT_ := lang.NewSymbol("as->")
	sym_aseq := lang.NewSymbol("aseq")
	sym_aset := lang.NewSymbol("aset")
	sym_aset_DASH_boolean := lang.NewSymbol("aset-boolean")
	sym_aset_DASH_byte := lang.NewSymbol("aset-byte")
	sym_aset_DASH_char := lang.NewSymbol("aset-char")
	sym_aset_DASH_double := lang.NewSymbol("aset-double")
	sym_aset_DASH_float := lang.NewSymbol("aset-float")
	sym_aset_DASH_int := lang.NewSymbol("aset-int")
	sym_aset_DASH_long := lang.NewSymbol("aset-long")
	sym_aset_DASH_short := lang.NewSymbol("aset-short")
	sym_assert := lang.NewSymbol("assert")
	sym_assert_DASH_args := lang.NewSymbol("assert-args")
	sym_assert_DASH_valid_DASH_fdecl := lang.NewSymbol("assert-valid-fdecl")
	sym_assoc := lang.NewSymbol("assoc")
	sym_assoc_BANG_ := lang.NewSymbol("assoc!")
	sym_assoc_DASH_in := lang.NewSymbol("assoc-in")
	sym_associative_QMARK_ := lang.NewSymbol("associative?")
	sym_atom := lang.NewSymbol("atom")
	sym_attr_DASH_map_QMARK_ := lang.NewSymbol("attr-map?")
	sym_atype := lang.NewSymbol("atype")
	sym_await := lang.NewSymbol("await")
	sym_await_DASH_for := lang.NewSymbol("await-for")
	sym_await1 := lang.NewSymbol("await1")
	sym_b := lang.NewSymbol("b")
	sym_bases := lang.NewSymbol("bases")
	sym_begin := lang.NewSymbol("begin")
	sym_bigdec := lang.NewSymbol("bigdec")
	sym_bigint := lang.NewSymbol("bigint")
	sym_biginteger := lang.NewSymbol("biginteger")
	sym_binding := lang.NewSymbol("binding")
	sym_binding_DASH_conveyor_DASH_fn := lang.NewSymbol("binding-conveyor-fn")
	sym_binding_DASH_map := lang.NewSymbol("binding-map")
	sym_bindings := lang.NewSymbol("bindings")
	sym_bindings_STAR_ := lang.NewSymbol("bindings*")
	sym_bit_DASH_and := lang.NewSymbol("bit-and")
	sym_bit_DASH_and_DASH_not := lang.NewSymbol("bit-and-not")
	sym_bit_DASH_clear := lang.NewSymbol("bit-clear")
	sym_bit_DASH_flip := lang.NewSymbol("bit-flip")
	sym_bit_DASH_not := lang.NewSymbol("bit-not")
	sym_bit_DASH_or := lang.NewSymbol("bit-or")
	sym_bit_DASH_set := lang.NewSymbol("bit-set")
	sym_bit_DASH_shift_DASH_left := lang.NewSymbol("bit-shift-left")
	sym_bit_DASH_shift_DASH_right := lang.NewSymbol("bit-shift-right")
	sym_bit_DASH_test := lang.NewSymbol("bit-test")
	sym_bit_DASH_xor := lang.NewSymbol("bit-xor")
	sym_body := lang.NewSymbol("body")
	sym_body_DASH_expr := lang.NewSymbol("body-expr")
	sym_boolean := lang.NewSymbol("boolean")
	sym_boolean_DASH_array := lang.NewSymbol("boolean-array")
	sym_boolean_QMARK_ := lang.NewSymbol("boolean?")
	sym_booleans := lang.NewSymbol("booleans")
	sym_bound_DASH_fn := lang.NewSymbol("bound-fn")
	sym_bound_DASH_fn_STAR_ := lang.NewSymbol("bound-fn*")
	sym_bound_QMARK_ := lang.NewSymbol("bound?")
	sym_bounded_DASH_count := lang.NewSymbol("bounded-count")
	sym_branch_QMARK_ := lang.NewSymbol("branch?")
	sym_butlast := lang.NewSymbol("butlast")
	sym_byte := lang.NewSymbol("byte")
	sym_byte_DASH_array := lang.NewSymbol("byte-array")
	sym_byteCast := lang.NewSymbol("byteCast")
	sym_bytes := lang.NewSymbol("bytes")
	sym_bytes_QMARK_ := lang.NewSymbol("bytes?")
	sym_c := lang.NewSymbol("c")
	sym_c1 := lang.NewSymbol("c1")
	sym_c2 := lang.NewSymbol("c2")
	sym_c3 := lang.NewSymbol("c3")
	sym_c__0__auto__ := lang.NewSymbol("c__0__auto__")
	sym_capacity := lang.NewSymbol("capacity")
	sym_case := lang.NewSymbol("case")
	sym_case_STAR_ := lang.NewSymbol("case*")
	sym_case_DASH_f := lang.NewSymbol("case-f")
	sym_case_DASH_map := lang.NewSymbol("case-map")
	sym_cast := lang.NewSymbol("cast")
	sym_cat := lang.NewSymbol("cat")
	sym_cause := lang.NewSymbol("cause")
	sym_cf := lang.NewSymbol("cf")
	sym_char := lang.NewSymbol("char")
	sym_char_DASH_array := lang.NewSymbol("char-array")
	sym_char_DASH_escape_DASH_string := lang.NewSymbol("char-escape-string")
	sym_char_DASH_name_DASH_string := lang.NewSymbol("char-name-string")
	sym_char_QMARK_ := lang.NewSymbol("char?")
	sym_charCast := lang.NewSymbol("charCast")
	sym_chars := lang.NewSymbol("chars")
	sym_check_DASH_cyclic_DASH_dependency := lang.NewSymbol("check-cyclic-dependency")
	sym_check_DASH_valid_DASH_options := lang.NewSymbol("check-valid-options")
	sym_child := lang.NewSymbol("child")
	sym_children := lang.NewSymbol("children")
	sym_chunk := lang.NewSymbol("chunk")
	sym_chunk_DASH_append := lang.NewSymbol("chunk-append")
	sym_chunk_DASH_buffer := lang.NewSymbol("chunk-buffer")
	sym_chunk_DASH_cons := lang.NewSymbol("chunk-cons")
	sym_chunk_DASH_first := lang.NewSymbol("chunk-first")
	sym_chunk_DASH_next := lang.NewSymbol("chunk-next")
	sym_chunk_DASH_rest := lang.NewSymbol("chunk-rest")
	sym_chunked_DASH_seq_QMARK_ := lang.NewSymbol("chunked-seq?")
	sym_class := lang.NewSymbol("class")
	sym_class_DASH_name := lang.NewSymbol("class-name")
	sym_class_QMARK_ := lang.NewSymbol("class?")
	sym_clauses := lang.NewSymbol("clauses")
	sym_clear_DASH_agent_DASH_errors := lang.NewSymbol("clear-agent-errors")
	sym_close := lang.NewSymbol("close")
	sym_codegen_DOT_test_DOT_const_DASH_keyword := lang.NewSymbol("codegen.test.const-keyword")
	sym_codegen_DOT_test_DOT_const_DASH_number := lang.NewSymbol("codegen.test.const-number")
	sym_codegen_DOT_test_DOT_const_DASH_string := lang.NewSymbol("codegen.test.const-string")
	sym_codegen_DOT_test_DOT_def_DASH_simple := lang.NewSymbol("codegen.test.def-simple")
	sym_codegen_DOT_test_DOT_fn_DASH_closure := lang.NewSymbol("codegen.test.fn-closure")
	sym_codegen_DOT_test_DOT_fn_DASH_recur := lang.NewSymbol("codegen.test.fn-recur")
	sym_codegen_DOT_test_DOT_loop_DASH_simple := lang.NewSymbol("codegen.test.loop-simple")
	sym_codegen_DOT_test_DOT_maybe_DASH_class := lang.NewSymbol("codegen.test.maybe-class")
	sym_codegen_DOT_test_DOT_multifn := lang.NewSymbol("codegen.test.multifn")
	sym_codegen_DOT_test_DOT_ns_DASH_skip := lang.NewSymbol("codegen.test.ns-skip")
	sym_codegen_DOT_test_DOT_quote_DASH_simple := lang.NewSymbol("codegen.test.quote-simple")
	sym_codegen_DOT_test_DOT_ref := lang.NewSymbol("codegen.test.ref")
	sym_codegen_DOT_test_DOT_the_DASH_var := lang.NewSymbol("codegen.test.the-var")
	sym_codegen_DOT_test_DOT_throw_DASH_simple := lang.NewSymbol("codegen.test.throw-simple")
	sym_codegen_DOT_test_DOT_try_DASH_advanced := lang.NewSymbol("codegen.test.try-advanced")
	sym_codegen_DOT_test_DOT_try_DASH_basic := lang.NewSymbol("codegen.test.try-basic")
	sym_codegen_DOT_test_DOT_values := lang.NewSymbol("codegen.test.values")
	sym_codegen_DOT_test_DOT_with_DASH_meta := lang.NewSymbol("codegen.test.with-meta")
	sym_coerce := lang.NewSymbol("coerce")
	sym_coll := lang.NewSymbol("coll")
	sym_coll_DASH_reduce := lang.NewSymbol("coll-reduce")
	sym_coll_QMARK_ := lang.NewSymbol("coll?")
	sym_colls := lang.NewSymbol("colls")
	sym_comment := lang.NewSymbol("comment")
	sym_commute := lang.NewSymbol("commute")
	sym_comp := lang.NewSymbol("comp")
	sym_comparator := lang.NewSymbol("comparator")
	sym_compare := lang.NewSymbol("compare")
	sym_compare_DASH_and_DASH_set_BANG_ := lang.NewSymbol("compare-and-set!")
	sym_compile := lang.NewSymbol("compile")
	sym_complement := lang.NewSymbol("complement")
	sym_completing := lang.NewSymbol("completing")
	sym_concat := lang.NewSymbol("concat")
	sym_cond := lang.NewSymbol("cond")
	sym_cond_DASH__GT_ := lang.NewSymbol("cond->")
	sym_cond_DASH__GT__GT_ := lang.NewSymbol("cond->>")
	sym_condp := lang.NewSymbol("condp")
	sym_conj := lang.NewSymbol("conj")
	sym_conj_BANG_ := lang.NewSymbol("conj!")
	sym_cons := lang.NewSymbol("cons")
	sym_constantly := lang.NewSymbol("constantly")
	sym_contains_QMARK_ := lang.NewSymbol("contains?")
	sym_content := lang.NewSymbol("content")
	sym_copy := lang.NewSymbol("copy")
	sym_count := lang.NewSymbol("count")
	sym_counted_QMARK_ := lang.NewSymbol("counted?")
	sym_create := lang.NewSymbol("create")
	sym_create_DASH_ns := lang.NewSymbol("create-ns")
	sym_create_DASH_struct := lang.NewSymbol("create-struct")
	sym_cycle := lang.NewSymbol("cycle")
	sym_d := lang.NewSymbol("d")
	sym_data_DASH_reader_DASH_urls := lang.NewSymbol("data-reader-urls")
	sym_data_DASH_reader_DASH_var := lang.NewSymbol("data-reader-var")
	sym_datafy := lang.NewSymbol("datafy")
	sym_dec := lang.NewSymbol("dec")
	sym_dec_TICK_ := lang.NewSymbol("dec'")
	sym_decimal_QMARK_ := lang.NewSymbol("decimal?")
	sym_decl := lang.NewSymbol("decl")
	sym_declare := lang.NewSymbol("declare")
	sym_decls := lang.NewSymbol("decls")
	sym_dedupe := lang.NewSymbol("dedupe")
	sym_def := lang.NewSymbol("def")
	sym_def_DASH_aset := lang.NewSymbol("def-aset")
	sym_default := lang.NewSymbol("default")
	sym_definline := lang.NewSymbol("definline")
	sym_defmacro := lang.NewSymbol("defmacro")
	sym_defmethod := lang.NewSymbol("defmethod")
	sym_defmulti := lang.NewSymbol("defmulti")
	sym_defn := lang.NewSymbol("defn")
	sym_defn_DASH_ := lang.NewSymbol("defn-")
	sym_defonce := lang.NewSymbol("defonce")
	sym_defprotocol := lang.NewSymbol("defprotocol")
	sym_defstruct := lang.NewSymbol("defstruct")
	sym_delay := lang.NewSymbol("delay")
	sym_delay_QMARK_ := lang.NewSymbol("delay?")
	sym_deliver := lang.NewSymbol("deliver")
	sym_denominator := lang.NewSymbol("denominator")
	sym_deref := lang.NewSymbol("deref")
	sym_deref_DASH_as_DASH_map := lang.NewSymbol("deref-as-map")
	sym_deref_DASH_future := lang.NewSymbol("deref-future")
	sym_derive := lang.NewSymbol("derive")
	sym_descendants := lang.NewSymbol("descendants")
	sym_destructure := lang.NewSymbol("destructure")
	sym_dim := lang.NewSymbol("dim")
	sym_dir := lang.NewSymbol("dir")
	sym_disj := lang.NewSymbol("disj")
	sym_disj_BANG_ := lang.NewSymbol("disj!")
	sym_dispatch_DASH_fn := lang.NewSymbol("dispatch-fn")
	sym_dispatch_DASH_val := lang.NewSymbol("dispatch-val")
	sym_dispatch_DASH_val_DASH_x := lang.NewSymbol("dispatch-val-x")
	sym_dispatch_DASH_val_DASH_y := lang.NewSymbol("dispatch-val-y")
	sym_dissoc := lang.NewSymbol("dissoc")
	sym_dissoc_BANG_ := lang.NewSymbol("dissoc!")
	sym_distinct := lang.NewSymbol("distinct")
	sym_distinct_QMARK_ := lang.NewSymbol("distinct?")
	sym_div := lang.NewSymbol("div")
	sym_divide := lang.NewSymbol("divide")
	sym_do := lang.NewSymbol("do")
	sym_doall := lang.NewSymbol("doall")
	sym_doc_DASH_string_QMARK_ := lang.NewSymbol("doc-string?")
	sym_docstring := lang.NewSymbol("docstring")
	sym_docstring_QMARK_ := lang.NewSymbol("docstring?")
	sym_dorun := lang.NewSymbol("dorun")
	sym_doseq := lang.NewSymbol("doseq")
	sym_dosync := lang.NewSymbol("dosync")
	sym_dotimes := lang.NewSymbol("dotimes")
	sym_doto := lang.NewSymbol("doto")
	sym_double := lang.NewSymbol("double")
	sym_double_DASH_array := lang.NewSymbol("double-array")
	sym_double_QMARK_ := lang.NewSymbol("double?")
	sym_doubles := lang.NewSymbol("doubles")
	sym_drop := lang.NewSymbol("drop")
	sym_drop_DASH_last := lang.NewSymbol("drop-last")
	sym_drop_DASH_while := lang.NewSymbol("drop-while")
	sym_e := lang.NewSymbol("e")
	sym_elide_DASH_top_DASH_frames := lang.NewSymbol("elide-top-frames")
	sym_else := lang.NewSymbol("else")
	sym_emit_DASH_extend_DASH_protocol := lang.NewSymbol("emit-extend-protocol")
	sym_emit_DASH_extend_DASH_type := lang.NewSymbol("emit-extend-type")
	sym_emit_DASH_hinted_DASH_impl := lang.NewSymbol("emit-hinted-impl")
	sym_empty := lang.NewSymbol("empty")
	sym_empty_QMARK_ := lang.NewSymbol("empty?")
	sym_end := lang.NewSymbol("end")
	sym_end_DASH_key := lang.NewSymbol("end-key")
	sym_end_DASH_test := lang.NewSymbol("end-test")
	sym_ensure := lang.NewSymbol("ensure")
	sym_ensure_DASH_reduced := lang.NewSymbol("ensure-reduced")
	sym_enumeration_DASH_seq := lang.NewSymbol("enumeration-seq")
	sym_env := lang.NewSymbol("env")
	sym_eof_DASH_error_QMARK_ := lang.NewSymbol("eof-error?")
	sym_eof_DASH_value := lang.NewSymbol("eof-value")
	sym_error_DASH_handler := lang.NewSymbol("error-handler")
	sym_error_DASH_mode := lang.NewSymbol("error-mode")
	sym_eval := lang.NewSymbol("eval")
	sym_even_QMARK_ := lang.NewSymbol("even?")
	sym_every_DASH_pred := lang.NewSymbol("every-pred")
	sym_every_QMARK_ := lang.NewSymbol("every?")
	sym_ex := lang.NewSymbol("ex")
	sym_ex_DASH_cause := lang.NewSymbol("ex-cause")
	sym_ex_DASH_data := lang.NewSymbol("ex-data")
	sym_ex_DASH_info := lang.NewSymbol("ex-info")
	sym_ex_DASH_message := lang.NewSymbol("ex-message")
	sym_executor := lang.NewSymbol("executor")
	sym_expr := lang.NewSymbol("expr")
	sym_expr_DASH_sym := lang.NewSymbol("expr-sym")
	sym_exprs := lang.NewSymbol("exprs")
	sym_exprs_STAR_ := lang.NewSymbol("exprs*")
	sym_extend := lang.NewSymbol("extend")
	sym_extend_DASH_protocol := lang.NewSymbol("extend-protocol")
	sym_extend_DASH_type := lang.NewSymbol("extend-type")
	sym_f := lang.NewSymbol("f")
	sym_false_QMARK_ := lang.NewSymbol("false?")
	sym_fdecl := lang.NewSymbol("fdecl")
	sym_ffirst := lang.NewSymbol("ffirst")
	sym_file_DASH_seq := lang.NewSymbol("file-seq")
	sym_filter := lang.NewSymbol("filter")
	sym_filter_DASH_key := lang.NewSymbol("filter-key")
	sym_filters := lang.NewSymbol("filters")
	sym_filterv := lang.NewSymbol("filterv")
	sym_finally := lang.NewSymbol("finally")
	sym_find := lang.NewSymbol("find")
	sym_find_DASH_keyword := lang.NewSymbol("find-keyword")
	sym_find_DASH_ns := lang.NewSymbol("find-ns")
	sym_find_DASH_var := lang.NewSymbol("find-var")
	sym_first := lang.NewSymbol("first")
	sym_fits_DASH_table_QMARK_ := lang.NewSymbol("fits-table?")
	sym_flags_DASH_ignored_DASH_for_DASH_now := lang.NewSymbol("flags-ignored-for-now")
	sym_flatten := lang.NewSymbol("flatten")
	sym_float := lang.NewSymbol("float")
	sym_float_DASH_array := lang.NewSymbol("float-array")
	sym_float_QMARK_ := lang.NewSymbol("float?")
	sym_floatCast := lang.NewSymbol("floatCast")
	sym_floats := lang.NewSymbol("floats")
	sym_flush := lang.NewSymbol("flush")
	sym_fmt := lang.NewSymbol("fmt")
	sym_fn := lang.NewSymbol("fn")
	sym_fn_STAR_ := lang.NewSymbol("fn*")
	sym_fn_DASH_tail := lang.NewSymbol("fn-tail")
	sym_fn_QMARK_ := lang.NewSymbol("fn?")
	sym_fnext := lang.NewSymbol("fnext")
	sym_fnil := lang.NewSymbol("fnil")
	sym_fns := lang.NewSymbol("fns")
	sym_fnspecs := lang.NewSymbol("fnspecs")
	sym_fnspecs_STAR_ := lang.NewSymbol("fnspecs*")
	sym_fntail := lang.NewSymbol("fntail")
	sym_for := lang.NewSymbol("for")
	sym_force := lang.NewSymbol("force")
	sym_form := lang.NewSymbol("form")
	sym_format := lang.NewSymbol("format")
	sym_forms := lang.NewSymbol("forms")
	sym_frequencies := lang.NewSymbol("frequencies")
	sym_from := lang.NewSymbol("from")
	sym_fs := lang.NewSymbol("fs")
	sym_fs__1__auto__ := lang.NewSymbol("fs__1__auto__")
	sym_fun := lang.NewSymbol("fun")
	sym_func := lang.NewSymbol("func")
	sym_fut := lang.NewSymbol("fut")
	sym_future := lang.NewSymbol("future")
	sym_future_DASH_call := lang.NewSymbol("future-call")
	sym_future_DASH_cancel := lang.NewSymbol("future-cancel")
	sym_future_DASH_cancelled_QMARK_ := lang.NewSymbol("future-cancelled?")
	sym_future_DASH_done_QMARK_ := lang.NewSymbol("future-done?")
	sym_future_QMARK_ := lang.NewSymbol("future?")
	sym_g := lang.NewSymbol("g")
	sym_gen_DASH_class := lang.NewSymbol("gen-class")
	sym_gensym := lang.NewSymbol("gensym")
	sym_get := lang.NewSymbol("get")
	sym_get_DASH_in := lang.NewSymbol("get-in")
	sym_get_DASH_method := lang.NewSymbol("get-method")
	sym_get_DASH_thread_DASH_bindings := lang.NewSymbol("get-thread-bindings")
	sym_get_DASH_validator := lang.NewSymbol("get-validator")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT__STAR_MultiFn := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.*MultiFn")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT__STAR_Var := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.*Var")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Abs := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Abs")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_FindNamespace := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.FindNamespace")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_ISeq := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.ISeq")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Identical := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Identical")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Import := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Import")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_IsReduced := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.IsReduced")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_LockingTransaction := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.LockingTransaction")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewIllegalArgumentError := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewIllegalArgumentError")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewLazySeq := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewLazySeq")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewMultiFn := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewMultiFn")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewPersistentArrayMapAsIfByAssoc := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewPersistentArrayMapAsIfByAssoc")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PopThreadBindings := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PopThreadBindings")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PushThreadBindings := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PushThreadBindings")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Volatile := lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Volatile")
	sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT := lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")
	sym_global_DASH_hierarchy := lang.NewSymbol("global-hierarchy")
	sym_glojure_DOT_core := lang.NewSymbol("glojure.core")
	sym_glojure_DOT_core_DOT_protocols := lang.NewSymbol("glojure.core.protocols")
	sym_glojure_DOT_core_SLASH__STAR_in_STAR_ := lang.NewSymbol("glojure.core/*in*")
	sym_glojure_DOT_core_SLASH__STAR_loaded_DASH_libs_STAR_ := lang.NewSymbol("glojure.core/*loaded-libs*")
	sym_glojure_DOT_core_SLASH__STAR_math_DASH_context_STAR_ := lang.NewSymbol("glojure.core/*math-context*")
	sym_glojure_DOT_core_SLASH__STAR_out_STAR_ := lang.NewSymbol("glojure.core/*out*")
	sym_glojure_DOT_core_SLASH__DASH_ := lang.NewSymbol("glojure.core/-")
	sym_glojure_DOT_core_SLASH__DASH__GT_ := lang.NewSymbol("glojure.core/->")
	sym_glojure_DOT_core_SLASH__DASH__GT__GT_ := lang.NewSymbol("glojure.core/->>")
	sym_glojure_DOT_core_SLASH__DASH_protocols := lang.NewSymbol("glojure.core/-protocols")
	sym_glojure_DOT_core_SLASH__SLASH_ := lang.NewSymbol("glojure.core//")
	sym_glojure_DOT_core_SLASH__LT_ := lang.NewSymbol("glojure.core/<")
	sym_glojure_DOT_core_SLASH__EQ_ := lang.NewSymbol("glojure.core/=")
	sym_glojure_DOT_core_SLASH_Aclone := lang.NewSymbol("glojure.core/Aclone")
	sym_glojure_DOT_core_SLASH_AddMethod := lang.NewSymbol("glojure.core/AddMethod")
	sym_glojure_DOT_core_SLASH_Aget := lang.NewSymbol("glojure.core/Aget")
	sym_glojure_DOT_core_SLASH_Alength := lang.NewSymbol("glojure.core/Alength")
	sym_glojure_DOT_core_SLASH_Array := lang.NewSymbol("glojure.core/Array")
	sym_glojure_DOT_core_SLASH_Aset := lang.NewSymbol("glojure.core/Aset")
	sym_glojure_DOT_core_SLASH_AssertionError := lang.NewSymbol("glojure.core/AssertionError")
	sym_glojure_DOT_core_SLASH_BooleanArray := lang.NewSymbol("glojure.core/BooleanArray")
	sym_glojure_DOT_core_SLASH_BooleanCast := lang.NewSymbol("glojure.core/BooleanCast")
	sym_glojure_DOT_core_SLASH_Booleans := lang.NewSymbol("glojure.core/Booleans")
	sym_glojure_DOT_core_SLASH_ByteArray := lang.NewSymbol("glojure.core/ByteArray")
	sym_glojure_DOT_core_SLASH_Bytes := lang.NewSymbol("glojure.core/Bytes")
	sym_glojure_DOT_core_SLASH_CharArray := lang.NewSymbol("glojure.core/CharArray")
	sym_glojure_DOT_core_SLASH_Chars := lang.NewSymbol("glojure.core/Chars")
	sym_glojure_DOT_core_SLASH_Count := lang.NewSymbol("glojure.core/Count")
	sym_glojure_DOT_core_SLASH_DecP := lang.NewSymbol("glojure.core/DecP")
	sym_glojure_DOT_core_SLASH_DoubleArray := lang.NewSymbol("glojure.core/DoubleArray")
	sym_glojure_DOT_core_SLASH_DoubleCast := lang.NewSymbol("glojure.core/DoubleCast")
	sym_glojure_DOT_core_SLASH_Doubles := lang.NewSymbol("glojure.core/Doubles")
	sym_glojure_DOT_core_SLASH_Equiv := lang.NewSymbol("glojure.core/Equiv")
	sym_glojure_DOT_core_SLASH_FloatArray := lang.NewSymbol("glojure.core/FloatArray")
	sym_glojure_DOT_core_SLASH_Floats := lang.NewSymbol("glojure.core/Floats")
	sym_glojure_DOT_core_SLASH_Get := lang.NewSymbol("glojure.core/Get")
	sym_glojure_DOT_core_SLASH_Gt := lang.NewSymbol("glojure.core/Gt")
	sym_glojure_DOT_core_SLASH_Gte := lang.NewSymbol("glojure.core/Gte")
	sym_glojure_DOT_core_SLASH_IllegalStateException := lang.NewSymbol("glojure.core/IllegalStateException")
	sym_glojure_DOT_core_SLASH_IncP := lang.NewSymbol("glojure.core/IncP")
	sym_glojure_DOT_core_SLASH_IntArray := lang.NewSymbol("glojure.core/IntArray")
	sym_glojure_DOT_core_SLASH_Ints := lang.NewSymbol("glojure.core/Ints")
	sym_glojure_DOT_core_SLASH_IsNeg := lang.NewSymbol("glojure.core/IsNeg")
	sym_glojure_DOT_core_SLASH_IsPos := lang.NewSymbol("glojure.core/IsPos")
	sym_glojure_DOT_core_SLASH_IsZero := lang.NewSymbol("glojure.core/IsZero")
	sym_glojure_DOT_core_SLASH_LongArray := lang.NewSymbol("glojure.core/LongArray")
	sym_glojure_DOT_core_SLASH_LongCast := lang.NewSymbol("glojure.core/LongCast")
	sym_glojure_DOT_core_SLASH_Longs := lang.NewSymbol("glojure.core/Longs")
	sym_glojure_DOT_core_SLASH_Lt := lang.NewSymbol("glojure.core/Lt")
	sym_glojure_DOT_core_SLASH_Lte := lang.NewSymbol("glojure.core/Lte")
	sym_glojure_DOT_core_SLASH_Not := lang.NewSymbol("glojure.core/Not")
	sym_glojure_DOT_core_SLASH_Nth := lang.NewSymbol("glojure.core/Nth")
	sym_glojure_DOT_core_SLASH_Num := lang.NewSymbol("glojure.core/Num")
	sym_glojure_DOT_core_SLASH_Object_array := lang.NewSymbol("glojure.core/Object_array")
	sym_glojure_DOT_core_SLASH_Quotient := lang.NewSymbol("glojure.core/Quotient")
	sym_glojure_DOT_core_SLASH_Remainder := lang.NewSymbol("glojure.core/Remainder")
	sym_glojure_DOT_core_SLASH_RunInTransaction := lang.NewSymbol("glojure.core/RunInTransaction")
	sym_glojure_DOT_core_SLASH_ShiftLeft := lang.NewSymbol("glojure.core/ShiftLeft")
	sym_glojure_DOT_core_SLASH_ShiftRight := lang.NewSymbol("glojure.core/ShiftRight")
	sym_glojure_DOT_core_SLASH_ShortArray := lang.NewSymbol("glojure.core/ShortArray")
	sym_glojure_DOT_core_SLASH_Shorts := lang.NewSymbol("glojure.core/Shorts")
	sym_glojure_DOT_core_SLASH_UncheckedAdd := lang.NewSymbol("glojure.core/UncheckedAdd")
	sym_glojure_DOT_core_SLASH_UncheckedByteCast := lang.NewSymbol("glojure.core/UncheckedByteCast")
	sym_glojure_DOT_core_SLASH_UncheckedCharCast := lang.NewSymbol("glojure.core/UncheckedCharCast")
	sym_glojure_DOT_core_SLASH_UncheckedDec := lang.NewSymbol("glojure.core/UncheckedDec")
	sym_glojure_DOT_core_SLASH_UncheckedDoubleCast := lang.NewSymbol("glojure.core/UncheckedDoubleCast")
	sym_glojure_DOT_core_SLASH_UncheckedFloatCast := lang.NewSymbol("glojure.core/UncheckedFloatCast")
	sym_glojure_DOT_core_SLASH_UncheckedIntCast := lang.NewSymbol("glojure.core/UncheckedIntCast")
	sym_glojure_DOT_core_SLASH_UncheckedIntDivide := lang.NewSymbol("glojure.core/UncheckedIntDivide")
	sym_glojure_DOT_core_SLASH_UncheckedLongCast := lang.NewSymbol("glojure.core/UncheckedLongCast")
	sym_glojure_DOT_core_SLASH_UncheckedShortCast := lang.NewSymbol("glojure.core/UncheckedShortCast")
	sym_glojure_DOT_core_SLASH_Unchecked_inc := lang.NewSymbol("glojure.core/Unchecked_inc")
	sym_glojure_DOT_core_SLASH_Unchecked_int_add := lang.NewSymbol("glojure.core/Unchecked_int_add")
	sym_glojure_DOT_core_SLASH_Unchecked_int_dec := lang.NewSymbol("glojure.core/Unchecked_int_dec")
	sym_glojure_DOT_core_SLASH_Unchecked_int_inc := lang.NewSymbol("glojure.core/Unchecked_int_inc")
	sym_glojure_DOT_core_SLASH_Unchecked_int_multiply := lang.NewSymbol("glojure.core/Unchecked_int_multiply")
	sym_glojure_DOT_core_SLASH_Unchecked_int_negate := lang.NewSymbol("glojure.core/Unchecked_int_negate")
	sym_glojure_DOT_core_SLASH_Unchecked_int_remainder := lang.NewSymbol("glojure.core/Unchecked_int_remainder")
	sym_glojure_DOT_core_SLASH_Unchecked_int_subtract := lang.NewSymbol("glojure.core/Unchecked_int_subtract")
	sym_glojure_DOT_core_SLASH_Unchecked_minus := lang.NewSymbol("glojure.core/Unchecked_minus")
	sym_glojure_DOT_core_SLASH_Unchecked_multiply := lang.NewSymbol("glojure.core/Unchecked_multiply")
	sym_glojure_DOT_core_SLASH_UnsignedShiftRight := lang.NewSymbol("glojure.core/UnsignedShiftRight")
	sym_glojure_DOT_core_SLASH_aclone := lang.NewSymbol("glojure.core/aclone")
	sym_glojure_DOT_core_SLASH_aget := lang.NewSymbol("glojure.core/aget")
	sym_glojure_DOT_core_SLASH_alength := lang.NewSymbol("glojure.core/alength")
	sym_glojure_DOT_core_SLASH_alter_DASH_meta_BANG_ := lang.NewSymbol("glojure.core/alter-meta!")
	sym_glojure_DOT_core_SLASH_and := lang.NewSymbol("glojure.core/and")
	sym_glojure_DOT_core_SLASH_apply := lang.NewSymbol("glojure.core/apply")
	sym_glojure_DOT_core_SLASH_args := lang.NewSymbol("glojure.core/args")
	sym_glojure_DOT_core_SLASH_aset := lang.NewSymbol("glojure.core/aset")
	sym_glojure_DOT_core_SLASH_assert := lang.NewSymbol("glojure.core/assert")
	sym_glojure_DOT_core_SLASH_assert_DASH_args := lang.NewSymbol("glojure.core/assert-args")
	sym_glojure_DOT_core_SLASH_assoc := lang.NewSymbol("glojure.core/assoc")
	sym_glojure_DOT_core_SLASH_assoc_DASH_in := lang.NewSymbol("glojure.core/assoc-in")
	sym_glojure_DOT_core_SLASH_atom := lang.NewSymbol("glojure.core/atom")
	sym_glojure_DOT_core_SLASH_binding := lang.NewSymbol("glojure.core/binding")
	sym_glojure_DOT_core_SLASH_bound_DASH_fn_STAR_ := lang.NewSymbol("glojure.core/bound-fn*")
	sym_glojure_DOT_core_SLASH_c := lang.NewSymbol("glojure.core/c")
	sym_glojure_DOT_core_SLASH_chunk := lang.NewSymbol("glojure.core/chunk")
	sym_glojure_DOT_core_SLASH_chunk_DASH_append := lang.NewSymbol("glojure.core/chunk-append")
	sym_glojure_DOT_core_SLASH_chunk_DASH_buffer := lang.NewSymbol("glojure.core/chunk-buffer")
	sym_glojure_DOT_core_SLASH_chunk_DASH_cons := lang.NewSymbol("glojure.core/chunk-cons")
	sym_glojure_DOT_core_SLASH_chunk_DASH_first := lang.NewSymbol("glojure.core/chunk-first")
	sym_glojure_DOT_core_SLASH_chunk_DASH_rest := lang.NewSymbol("glojure.core/chunk-rest")
	sym_glojure_DOT_core_SLASH_chunked_DASH_seq_QMARK_ := lang.NewSymbol("glojure.core/chunked-seq?")
	sym_glojure_DOT_core_SLASH_class := lang.NewSymbol("glojure.core/class")
	sym_glojure_DOT_core_SLASH_commute := lang.NewSymbol("glojure.core/commute")
	sym_glojure_DOT_core_SLASH_compare := lang.NewSymbol("glojure.core/compare")
	sym_glojure_DOT_core_SLASH_concat := lang.NewSymbol("glojure.core/concat")
	sym_glojure_DOT_core_SLASH_cond := lang.NewSymbol("glojure.core/cond")
	sym_glojure_DOT_core_SLASH_condp := lang.NewSymbol("glojure.core/condp")
	sym_glojure_DOT_core_SLASH_conj := lang.NewSymbol("glojure.core/conj")
	sym_glojure_DOT_core_SLASH_cons := lang.NewSymbol("glojure.core/cons")
	sym_glojure_DOT_core_SLASH_count := lang.NewSymbol("glojure.core/count")
	sym_glojure_DOT_core_SLASH_create_DASH_struct := lang.NewSymbol("glojure.core/create-struct")
	sym_glojure_DOT_core_SLASH_defmulti := lang.NewSymbol("glojure.core/defmulti")
	sym_glojure_DOT_core_SLASH_defn := lang.NewSymbol("glojure.core/defn")
	sym_glojure_DOT_core_SLASH_deref := lang.NewSymbol("glojure.core/deref")
	sym_glojure_DOT_core_SLASH_dosync := lang.NewSymbol("glojure.core/dosync")
	sym_glojure_DOT_core_SLASH_double := lang.NewSymbol("glojure.core/double")
	sym_glojure_DOT_core_SLASH_equiv := lang.NewSymbol("glojure.core/equiv")
	sym_glojure_DOT_core_SLASH_extend := lang.NewSymbol("glojure.core/extend")
	sym_glojure_DOT_core_SLASH_extend_DASH_type := lang.NewSymbol("glojure.core/extend-type")
	sym_glojure_DOT_core_SLASH_first := lang.NewSymbol("glojure.core/first")
	sym_glojure_DOT_core_SLASH_fn := lang.NewSymbol("glojure.core/fn")
	sym_glojure_DOT_core_SLASH_future_DASH_call := lang.NewSymbol("glojure.core/future-call")
	sym_glojure_DOT_core_SLASH_gen_DASH_class := lang.NewSymbol("glojure.core/gen-class")
	sym_glojure_DOT_core_SLASH_get := lang.NewSymbol("glojure.core/get")
	sym_glojure_DOT_core_SLASH_hash_DASH_map := lang.NewSymbol("glojure.core/hash-map")
	sym_glojure_DOT_core_SLASH_i := lang.NewSymbol("glojure.core/i")
	sym_glojure_DOT_core_SLASH_identical := lang.NewSymbol("glojure.core/identical")
	sym_glojure_DOT_core_SLASH_if_DASH_let := lang.NewSymbol("glojure.core/if-let")
	sym_glojure_DOT_core_SLASH_if_DASH_not := lang.NewSymbol("glojure.core/if-not")
	sym_glojure_DOT_core_SLASH_if_DASH_some := lang.NewSymbol("glojure.core/if-some")
	sym_glojure_DOT_core_SLASH_in_DASH_ns := lang.NewSymbol("glojure.core/in-ns")
	sym_glojure_DOT_core_SLASH_instance_QMARK_ := lang.NewSymbol("glojure.core/instance?")
	sym_glojure_DOT_core_SLASH_int := lang.NewSymbol("glojure.core/int")
	sym_glojure_DOT_core_SLASH_keyword := lang.NewSymbol("glojure.core/keyword")
	sym_glojure_DOT_core_SLASH_lazy_DASH_seq := lang.NewSymbol("glojure.core/lazy-seq")
	sym_glojure_DOT_core_SLASH_let := lang.NewSymbol("glojure.core/let")
	sym_glojure_DOT_core_SLASH_long := lang.NewSymbol("glojure.core/long")
	sym_glojure_DOT_core_SLASH_loop := lang.NewSymbol("glojure.core/loop")
	sym_glojure_DOT_core_SLASH_merge := lang.NewSymbol("glojure.core/merge")
	sym_glojure_DOT_core_SLASH_meta := lang.NewSymbol("glojure.core/meta")
	sym_glojure_DOT_core_SLASH_next := lang.NewSymbol("glojure.core/next")
	sym_glojure_DOT_core_SLASH_nf := lang.NewSymbol("glojure.core/nf")
	sym_glojure_DOT_core_SLASH_nil_QMARK_ := lang.NewSymbol("glojure.core/nil?")
	sym_glojure_DOT_core_SLASH_not := lang.NewSymbol("glojure.core/not")
	sym_glojure_DOT_core_SLASH_nth := lang.NewSymbol("glojure.core/nth")
	sym_glojure_DOT_core_SLASH_or := lang.NewSymbol("glojure.core/or")
	sym_glojure_DOT_core_SLASH_pcalls := lang.NewSymbol("glojure.core/pcalls")
	sym_glojure_DOT_core_SLASH_pop_DASH_thread_DASH_bindings := lang.NewSymbol("glojure.core/pop-thread-bindings")
	sym_glojure_DOT_core_SLASH_pr_DASH_str := lang.NewSymbol("glojure.core/pr-str")
	sym_glojure_DOT_core_SLASH_prn := lang.NewSymbol("glojure.core/prn")
	sym_glojure_DOT_core_SLASH_push_DASH_thread_DASH_bindings := lang.NewSymbol("glojure.core/push-thread-bindings")
	sym_glojure_DOT_core_SLASH_refer := lang.NewSymbol("glojure.core/refer")
	sym_glojure_DOT_core_SLASH_rest := lang.NewSymbol("glojure.core/rest")
	sym_glojure_DOT_core_SLASH_seq := lang.NewSymbol("glojure.core/seq")
	sym_glojure_DOT_core_SLASH_seq_QMARK_ := lang.NewSymbol("glojure.core/seq?")
	sym_glojure_DOT_core_SLASH_str := lang.NewSymbol("glojure.core/str")
	sym_glojure_DOT_core_SLASH_swap_BANG_ := lang.NewSymbol("glojure.core/swap!")
	sym_glojure_DOT_core_SLASH_sync := lang.NewSymbol("glojure.core/sync")
	sym_glojure_DOT_core_SLASH_to_DASH_array := lang.NewSymbol("glojure.core/to-array")
	sym_glojure_DOT_core_SLASH_unchecked_DASH_inc := lang.NewSymbol("glojure.core/unchecked-inc")
	sym_glojure_DOT_core_SLASH_unchecked_DASH_inc_DASH_int := lang.NewSymbol("glojure.core/unchecked-inc-int")
	sym_glojure_DOT_core_SLASH_unquote := lang.NewSymbol("glojure.core/unquote")
	sym_glojure_DOT_core_SLASH_unquote_DASH_splicing := lang.NewSymbol("glojure.core/unquote-splicing")
	sym_glojure_DOT_core_SLASH_when := lang.NewSymbol("glojure.core/when")
	sym_glojure_DOT_core_SLASH_when_DASH_first := lang.NewSymbol("glojure.core/when-first")
	sym_glojure_DOT_core_SLASH_when_DASH_let := lang.NewSymbol("glojure.core/when-let")
	sym_glojure_DOT_core_SLASH_when_DASH_not := lang.NewSymbol("glojure.core/when-not")
	sym_glojure_DOT_core_SLASH_with_DASH_bindings_STAR_ := lang.NewSymbol("glojure.core/with-bindings*")
	sym_glojure_DOT_core_SLASH_with_DASH_loading_DASH_context := lang.NewSymbol("glojure.core/with-loading-context")
	sym_glojure_DOT_core_SLASH_with_DASH_open := lang.NewSymbol("glojure.core/with-open")
	sym_glojure_DOT_core_SLASH_with_DASH_redefs_DASH_fn := lang.NewSymbol("glojure.core/with-redefs-fn")
	sym_glojure_DOT_go_DOT_io := lang.NewSymbol("glojure.go.io")
	sym_glojure_DOT_lang_DOT_Delay := lang.NewSymbol("glojure.lang.Delay")
	sym_glojure_DOT_lang_DOT_IChunk := lang.NewSymbol("glojure.lang.IChunk")
	sym_glojure_DOT_lang_DOT_LineNumberingPushbackReader_DOT_ := lang.NewSymbol("glojure.lang.LineNumberingPushbackReader.")
	sym_glojure_DOT_lang_DOT_LockingTransaction_SLASH_isRunning := lang.NewSymbol("glojure.lang.LockingTransaction/isRunning")
	sym_glojure_DOT_lang_DOT_PersistentArrayMap_SLASH_EMPTY := lang.NewSymbol("glojure.lang.PersistentArrayMap/EMPTY")
	sym_glojure_DOT_lang_DOT_Util := lang.NewSymbol("glojure.lang.Util")
	sym_glojure_DOT_string := lang.NewSymbol("glojure.string")
	sym_group_DASH_by := lang.NewSymbol("group-by")
	sym_h := lang.NewSymbol("h")
	sym_halt_DASH_when := lang.NewSymbol("halt-when")
	sym_handler_DASH_fn := lang.NewSymbol("handler-fn")
	sym_hash := lang.NewSymbol("hash")
	sym_hash_DASH_basis := lang.NewSymbol("hash-basis")
	sym_hash_DASH_map := lang.NewSymbol("hash-map")
	sym_hash_DASH_ordered_DASH_coll := lang.NewSymbol("hash-ordered-coll")
	sym_hash_DASH_set := lang.NewSymbol("hash-set")
	sym_hash_DASH_unordered_DASH_coll := lang.NewSymbol("hash-unordered-coll")
	sym_hashes := lang.NewSymbol("hashes")
	sym_ident_QMARK_ := lang.NewSymbol("ident?")
	sym_identical_QMARK_ := lang.NewSymbol("identical?")
	sym_identity := lang.NewSymbol("identity")
	sym_idx := lang.NewSymbol("idx")
	sym_idx2 := lang.NewSymbol("idx2")
	sym_idx2__3__auto__ := lang.NewSymbol("idx2__3__auto__")
	sym_idx__1__auto__ := lang.NewSymbol("idx__1__auto__")
	sym_idxs := lang.NewSymbol("idxs")
	sym_idxv := lang.NewSymbol("idxv")
	sym_idxv__4__auto__ := lang.NewSymbol("idxv__4__auto__")
	sym_if := lang.NewSymbol("if")
	sym_if_DASH_let := lang.NewSymbol("if-let")
	sym_if_DASH_not := lang.NewSymbol("if-not")
	sym_if_DASH_some := lang.NewSymbol("if-some")
	sym_ifn_QMARK_ := lang.NewSymbol("ifn?")
	sym_import := lang.NewSymbol("import")
	sym_import_DASH_symbols_DASH_or_DASH_lists := lang.NewSymbol("import-symbols-or-lists")
	sym_inc := lang.NewSymbol("inc")
	sym_inc_TICK_ := lang.NewSymbol("inc'")
	sym_index := lang.NewSymbol("index")
	sym_indexed_QMARK_ := lang.NewSymbol("indexed?")
	sym_infinite_QMARK_ := lang.NewSymbol("infinite?")
	sym_init := lang.NewSymbol("init")
	sym_init_DASH_val_DASH_or_DASH_seq := lang.NewSymbol("init-val-or-seq")
	sym_initk := lang.NewSymbol("initk")
	sym_inits := lang.NewSymbol("inits")
	sym_inst := lang.NewSymbol("inst")
	sym_inst_DASH_ms := lang.NewSymbol("inst-ms")
	sym_inst_QMARK_ := lang.NewSymbol("inst?")
	sym_instance_QMARK_ := lang.NewSymbol("instance?")
	sym_int := lang.NewSymbol("int")
	sym_int_DASH_array := lang.NewSymbol("int-array")
	sym_int_QMARK_ := lang.NewSymbol("int?")
	sym_intCast := lang.NewSymbol("intCast")
	sym_integer_QMARK_ := lang.NewSymbol("integer?")
	sym_interface_DASH_or_DASH_naive_DASH_reduce := lang.NewSymbol("interface-or-naive-reduce")
	sym_interleave := lang.NewSymbol("interleave")
	sym_intern := lang.NewSymbol("intern")
	sym_internal_DASH_reduce := lang.NewSymbol("internal-reduce")
	sym_interpose := lang.NewSymbol("interpose")
	sym_into := lang.NewSymbol("into")
	sym_into_DASH_array := lang.NewSymbol("into-array")
	sym_into1 := lang.NewSymbol("into1")
	sym_ints := lang.NewSymbol("ints")
	sym_io_BANG_ := lang.NewSymbol("io!")
	sym_iref := lang.NewSymbol("iref")
	sym_isa_QMARK_ := lang.NewSymbol("isa?")
	sym_items := lang.NewSymbol("items")
	sym_iter := lang.NewSymbol("iter")
	sym_iter__0__auto__ := lang.NewSymbol("iter__0__auto__")
	sym_iterate := lang.NewSymbol("iterate")
	sym_iteration := lang.NewSymbol("iteration")
	sym_iterator_DASH_seq := lang.NewSymbol("iterator-seq")
	sym_iterys__0__auto__ := lang.NewSymbol("iterys__0__auto__")
	sym_java_DOT_io_DOT_StringReader_DOT_ := lang.NewSymbol("java.io.StringReader.")
	sym_java_DOT_math_DOT_MathContext_DOT_ := lang.NewSymbol("java.math.MathContext.")
	sym_java_DOT_math_DOT_RoundingMode := lang.NewSymbol("java.math.RoundingMode")
	sym_juxt := lang.NewSymbol("juxt")
	sym_k := lang.NewSymbol("k")
	sym_keep := lang.NewSymbol("keep")
	sym_keep_DASH_indexed := lang.NewSymbol("keep-indexed")
	sym_key := lang.NewSymbol("key")
	sym_keyfn := lang.NewSymbol("keyfn")
	sym_keys := lang.NewSymbol("keys")
	sym_keyseq := lang.NewSymbol("keyseq")
	sym_keyvals := lang.NewSymbol("keyvals")
	sym_keyword := lang.NewSymbol("keyword")
	sym_keyword_QMARK_ := lang.NewSymbol("keyword?")
	sym_kf := lang.NewSymbol("kf")
	sym_ks := lang.NewSymbol("ks")
	sym_kv_DASH_reduce := lang.NewSymbol("kv-reduce")
	sym_kvs := lang.NewSymbol("kvs")
	sym_l__1__auto__ := lang.NewSymbol("l__1__auto__")
	sym_last := lang.NewSymbol("last")
	sym_lazy_DASH_cat := lang.NewSymbol("lazy-cat")
	sym_lazy_DASH_seq := lang.NewSymbol("lazy-seq")
	sym_len := lang.NewSymbol("len")
	sym_let := lang.NewSymbol("let")
	sym_let_STAR_ := lang.NewSymbol("let*")
	sym_letfn := lang.NewSymbol("letfn")
	sym_letfn_STAR_ := lang.NewSymbol("letfn*")
	sym_lib := lang.NewSymbol("lib")
	sym_libspec_QMARK_ := lang.NewSymbol("libspec?")
	sym_lift_DASH_ns := lang.NewSymbol("lift-ns")
	sym_line_DASH_seq := lang.NewSymbol("line-seq")
	sym_list := lang.NewSymbol("list")
	sym_list_STAR_ := lang.NewSymbol("list*")
	sym_list_QMARK_ := lang.NewSymbol("list?")
	sym_load := lang.NewSymbol("load")
	sym_load_DASH_all := lang.NewSymbol("load-all")
	sym_load_DASH_data_DASH_reader_DASH_file := lang.NewSymbol("load-data-reader-file")
	sym_load_DASH_data_DASH_readers := lang.NewSymbol("load-data-readers")
	sym_load_DASH_file := lang.NewSymbol("load-file")
	sym_load_DASH_lib := lang.NewSymbol("load-lib")
	sym_load_DASH_libs := lang.NewSymbol("load-libs")
	sym_load_DASH_one := lang.NewSymbol("load-one")
	sym_load_DASH_reader := lang.NewSymbol("load-reader")
	sym_load_DASH_string := lang.NewSymbol("load-string")
	sym_loaded_DASH_libs := lang.NewSymbol("loaded-libs")
	sym_loading__0__auto__ := lang.NewSymbol("loading__0__auto__")
	sym_lockee__0__auto__ := lang.NewSymbol("lockee__0__auto__")
	sym_locking := lang.NewSymbol("locking")
	sym_locklocal__1__auto__ := lang.NewSymbol("locklocal__1__auto__")
	sym_long := lang.NewSymbol("long")
	sym_long_DASH_array := lang.NewSymbol("long-array")
	sym_longs := lang.NewSymbol("longs")
	sym_loop := lang.NewSymbol("loop")
	sym_loop_STAR_ := lang.NewSymbol("loop*")
	sym_m := lang.NewSymbol("m")
	sym_macroexpand := lang.NewSymbol("macroexpand")
	sym_macroexpand_DASH_1 := lang.NewSymbol("macroexpand-1")
	sym_make_DASH_array := lang.NewSymbol("make-array")
	sym_make_DASH_hierarchy := lang.NewSymbol("make-hierarchy")
	sym_make_DASH_input_DASH_stream := lang.NewSymbol("make-input-stream")
	sym_make_DASH_output_DASH_stream := lang.NewSymbol("make-output-stream")
	sym_make_DASH_reader := lang.NewSymbol("make-reader")
	sym_make_DASH_writer := lang.NewSymbol("make-writer")
	sym_map := lang.NewSymbol("map")
	sym_map_DASH_entry_QMARK_ := lang.NewSymbol("map-entry?")
	sym_map_DASH_indexed := lang.NewSymbol("map-indexed")
	sym_map_QMARK_ := lang.NewSymbol("map?")
	sym_mapcat := lang.NewSymbol("mapcat")
	sym_mappings := lang.NewSymbol("mappings")
	sym_maps := lang.NewSymbol("maps")
	sym_mapv := lang.NewSymbol("mapv")
	sym_mask := lang.NewSymbol("mask")
	sym_math_DOT_IsNaN := lang.NewSymbol("math.IsNaN")
	sym_max := lang.NewSymbol("max")
	sym_max_DASH_key := lang.NewSymbol("max-key")
	sym_max_DASH_mask_DASH_bits := lang.NewSymbol("max-mask-bits")
	sym_max_DASH_switch_DASH_table_DASH_size := lang.NewSymbol("max-switch-table-size")
	sym_maybe_DASH_destructured := lang.NewSymbol("maybe-destructured")
	sym_maybe_DASH_min_DASH_hash := lang.NewSymbol("maybe-min-hash")
	sym_maybe_DASH_p := lang.NewSymbol("maybe-p")
	sym_memfn := lang.NewSymbol("memfn")
	sym_memoize := lang.NewSymbol("memoize")
	sym_merge := lang.NewSymbol("merge")
	sym_merge_DASH_hash_DASH_collisions := lang.NewSymbol("merge-hash-collisions")
	sym_merge_DASH_with := lang.NewSymbol("merge-with")
	sym_message := lang.NewSymbol("message")
	sym_meta := lang.NewSymbol("meta")
	sym_metadata_DASH_map := lang.NewSymbol("metadata-map")
	sym_method := lang.NewSymbol("method")
	sym_methods := lang.NewSymbol("methods")
	sym_min := lang.NewSymbol("min")
	sym_min_DASH_key := lang.NewSymbol("min-key")
	sym_minus := lang.NewSymbol("minus")
	sym_minusP := lang.NewSymbol("minusP")
	sym_mix_DASH_collection_DASH_hash := lang.NewSymbol("mix-collection-hash")
	sym_mk_DASH_bound_DASH_fn := lang.NewSymbol("mk-bound-fn")
	sym_mod := lang.NewSymbol("mod")
	sym_mode_DASH_keyword := lang.NewSymbol("mode-keyword")
	sym_monitor_DASH_enter := lang.NewSymbol("monitor-enter")
	sym_monitor_DASH_exit := lang.NewSymbol("monitor-exit")
	sym_more := lang.NewSymbol("more")
	sym_more_DASH_dims := lang.NewSymbol("more-dims")
	sym_msg := lang.NewSymbol("msg")
	sym_multifn := lang.NewSymbol("multifn")
	sym_multiply := lang.NewSymbol("multiply")
	sym_multiplyP := lang.NewSymbol("multiplyP")
	sym_n := lang.NewSymbol("n")
	sym_n_DASH_or_DASH_q := lang.NewSymbol("n-or-q")
	sym_n__0__auto__ := lang.NewSymbol("n__0__auto__")
	sym_name := lang.NewSymbol("name")
	sym_name_DASH_vals_DASH_vec := lang.NewSymbol("name-vals-vec")
	sym_name_QMARK_ := lang.NewSymbol("name?")
	sym_named := lang.NewSymbol("named")
	sym_names := lang.NewSymbol("names")
	sym_namespace := lang.NewSymbol("namespace")
	sym_namespace_DASH_sym := lang.NewSymbol("namespace-sym")
	sym_nary_DASH_inline := lang.NewSymbol("nary-inline")
	sym_nat_DASH_int_QMARK_ := lang.NewSymbol("nat-int?")
	sym_nav := lang.NewSymbol("nav")
	sym_need_DASH_ns := lang.NewSymbol("need-ns")
	sym_neg_DASH_int_QMARK_ := lang.NewSymbol("neg-int?")
	sym_neg_QMARK_ := lang.NewSymbol("neg?")
	sym_new := lang.NewSymbol("new")
	sym_new_DASH_state := lang.NewSymbol("new-state")
	sym_newline := lang.NewSymbol("newline")
	sym_newval := lang.NewSymbol("newval")
	sym_next := lang.NewSymbol("next")
	sym_nfirst := lang.NewSymbol("nfirst")
	sym_nil_QMARK_ := lang.NewSymbol("nil?")
	sym_nnext := lang.NewSymbol("nnext")
	sym_normalize_DASH_slurp_DASH_opts := lang.NewSymbol("normalize-slurp-opts")
	sym_not := lang.NewSymbol("not")
	sym_not_DASH_any_QMARK_ := lang.NewSymbol("not-any?")
	sym_not_DASH_empty := lang.NewSymbol("not-empty")
	sym_not_DASH_every_QMARK_ := lang.NewSymbol("not-every?")
	sym_not_DASH_found := lang.NewSymbol("not-found")
	sym_not_EQ_ := lang.NewSymbol("not=")
	sym_ns := lang.NewSymbol("ns")
	sym_ns_DASH_aliases := lang.NewSymbol("ns-aliases")
	sym_ns_DASH_imports := lang.NewSymbol("ns-imports")
	sym_ns_DASH_interns := lang.NewSymbol("ns-interns")
	sym_ns_DASH_map := lang.NewSymbol("ns-map")
	sym_ns_DASH_name := lang.NewSymbol("ns-name")
	sym_ns_DASH_publics := lang.NewSymbol("ns-publics")
	sym_ns_DASH_refers := lang.NewSymbol("ns-refers")
	sym_ns_DASH_resolve := lang.NewSymbol("ns-resolve")
	sym_ns_DASH_sym := lang.NewSymbol("ns-sym")
	sym_ns_DASH_unalias := lang.NewSymbol("ns-unalias")
	sym_ns_DASH_unmap := lang.NewSymbol("ns-unmap")
	sym_nth := lang.NewSymbol("nth")
	sym_nthnext := lang.NewSymbol("nthnext")
	sym_nthrest := lang.NewSymbol("nthrest")
	sym_num := lang.NewSymbol("num")
	sym_number_QMARK_ := lang.NewSymbol("number?")
	sym_numerator := lang.NewSymbol("numerator")
	sym_o := lang.NewSymbol("o")
	sym_obj := lang.NewSymbol("obj")
	sym_object_DASH_array := lang.NewSymbol("object-array")
	sym_odd_QMARK_ := lang.NewSymbol("odd?")
	sym_oldform := lang.NewSymbol("oldform")
	sym_oldval := lang.NewSymbol("oldval")
	sym_op := lang.NewSymbol("op")
	sym_options := lang.NewSymbol("options")
	sym_opts := lang.NewSymbol("opts")
	sym_opts_PLUS_sigs := lang.NewSymbol("opts+sigs")
	sym_or := lang.NewSymbol("or")
	sym_or__0__auto__ := lang.NewSymbol("or__0__auto__")
	sym_p := lang.NewSymbol("p")
	sym_p1 := lang.NewSymbol("p1")
	sym_p2 := lang.NewSymbol("p2")
	sym_p3 := lang.NewSymbol("p3")
	sym_p__0__auto__ := lang.NewSymbol("p__0__auto__")
	sym_pad := lang.NewSymbol("pad")
	sym_pairs := lang.NewSymbol("pairs")
	sym_params := lang.NewSymbol("params")
	sym_params_STAR_ := lang.NewSymbol("params*")
	sym_parent := lang.NewSymbol("parent")
	sym_parents := lang.NewSymbol("parents")
	sym_parse_DASH_boolean := lang.NewSymbol("parse-boolean")
	sym_parse_DASH_double := lang.NewSymbol("parse-double")
	sym_parse_DASH_impls := lang.NewSymbol("parse-impls")
	sym_parse_DASH_long := lang.NewSymbol("parse-long")
	sym_parse_DASH_uuid := lang.NewSymbol("parse-uuid")
	sym_parsing_DASH_err := lang.NewSymbol("parsing-err")
	sym_partial := lang.NewSymbol("partial")
	sym_partition := lang.NewSymbol("partition")
	sym_partition_DASH_all := lang.NewSymbol("partition-all")
	sym_partition_DASH_by := lang.NewSymbol("partition-by")
	sym_partitionv := lang.NewSymbol("partitionv")
	sym_partitionv_DASH_all := lang.NewSymbol("partitionv-all")
	sym_path := lang.NewSymbol("path")
	sym_paths := lang.NewSymbol("paths")
	sym_pcalls := lang.NewSymbol("pcalls")
	sym_peek := lang.NewSymbol("peek")
	sym_persistent_BANG_ := lang.NewSymbol("persistent!")
	sym_pmap := lang.NewSymbol("pmap")
	sym_pop := lang.NewSymbol("pop")
	sym_pop_BANG_ := lang.NewSymbol("pop!")
	sym_pop_DASH_thread_DASH_bindings := lang.NewSymbol("pop-thread-bindings")
	sym_pos_DASH_int_QMARK_ := lang.NewSymbol("pos-int?")
	sym_pos_QMARK_ := lang.NewSymbol("pos?")
	sym_pr := lang.NewSymbol("pr")
	sym_pr_DASH_on := lang.NewSymbol("pr-on")
	sym_pr_DASH_str := lang.NewSymbol("pr-str")
	sym_precision := lang.NewSymbol("precision")
	sym_pred := lang.NewSymbol("pred")
	sym_prefer_DASH_method := lang.NewSymbol("prefer-method")
	sym_prefers := lang.NewSymbol("prefers")
	sym_prefix := lang.NewSymbol("prefix")
	sym_prefix_DASH_string := lang.NewSymbol("prefix-string")
	sym_prep_DASH_hashes := lang.NewSymbol("prep-hashes")
	sym_prep_DASH_ints := lang.NewSymbol("prep-ints")
	sym_prependss := lang.NewSymbol("prependss")
	sym_prepost_DASH_map_QMARK_ := lang.NewSymbol("prepost-map?")
	sym_preserving_DASH_reduced := lang.NewSymbol("preserving-reduced")
	sym_print := lang.NewSymbol("print")
	sym_print_DASH_args := lang.NewSymbol("print-args")
	sym_print_DASH_ctor := lang.NewSymbol("print-ctor")
	sym_print_DASH_dup := lang.NewSymbol("print-dup")
	sym_print_DASH_initialized := lang.NewSymbol("print-initialized")
	sym_print_DASH_map := lang.NewSymbol("print-map")
	sym_print_DASH_meta := lang.NewSymbol("print-meta")
	sym_print_DASH_method := lang.NewSymbol("print-method")
	sym_print_DASH_object := lang.NewSymbol("print-object")
	sym_print_DASH_one := lang.NewSymbol("print-one")
	sym_print_DASH_prefix_DASH_map := lang.NewSymbol("print-prefix-map")
	sym_print_DASH_sequential := lang.NewSymbol("print-sequential")
	sym_print_DASH_simple := lang.NewSymbol("print-simple")
	sym_print_DASH_str := lang.NewSymbol("print-str")
	sym_print_DASH_tagged_DASH_object := lang.NewSymbol("print-tagged-object")
	sym_print_DASH_throwable := lang.NewSymbol("print-throwable")
	sym_printf := lang.NewSymbol("printf")
	sym_println := lang.NewSymbol("println")
	sym_println_DASH_str := lang.NewSymbol("println-str")
	sym_prn := lang.NewSymbol("prn")
	sym_prn_DASH_str := lang.NewSymbol("prn-str")
	sym_prob := lang.NewSymbol("prob")
	sym_proc := lang.NewSymbol("proc")
	sym_promise := lang.NewSymbol("promise")
	sym_proto_PLUS_mmaps := lang.NewSymbol("proto+mmaps")
	sym_protocol_QMARK_ := lang.NewSymbol("protocol?")
	sym_ps := lang.NewSymbol("ps")
	sym_push_DASH_thread_DASH_bindings := lang.NewSymbol("push-thread-bindings")
	sym_pvalues := lang.NewSymbol("pvalues")
	sym_qualified_DASH_ident_QMARK_ := lang.NewSymbol("qualified-ident?")
	sym_qualified_DASH_keyword_QMARK_ := lang.NewSymbol("qualified-keyword?")
	sym_qualified_DASH_symbol_QMARK_ := lang.NewSymbol("qualified-symbol?")
	sym_quot := lang.NewSymbol("quot")
	sym_quote := lang.NewSymbol("quote")
	sym_r := lang.NewSymbol("r")
	sym_rand := lang.NewSymbol("rand")
	sym_rand_DASH_int := lang.NewSymbol("rand-int")
	sym_rand_DASH_nth := lang.NewSymbol("rand-nth")
	sym_random_DASH_sample := lang.NewSymbol("random-sample")
	sym_random_DASH_uuid := lang.NewSymbol("random-uuid")
	sym_range := lang.NewSymbol("range")
	sym_ratio_QMARK_ := lang.NewSymbol("ratio?")
	sym_rational_QMARK_ := lang.NewSymbol("rational?")
	sym_rationalize := lang.NewSymbol("rationalize")
	sym_rdr := lang.NewSymbol("rdr")
	sym_re := lang.NewSymbol("re")
	sym_re_DASH_find := lang.NewSymbol("re-find")
	sym_re_DASH_groups := lang.NewSymbol("re-groups")
	sym_re_DASH_matcher := lang.NewSymbol("re-matcher")
	sym_re_DASH_matches := lang.NewSymbol("re-matches")
	sym_re_DASH_pattern := lang.NewSymbol("re-pattern")
	sym_re_DASH_seq := lang.NewSymbol("re-seq")
	sym_read := lang.NewSymbol("read")
	sym_read_PLUS_string := lang.NewSymbol("read+string")
	sym_read_DASH_line := lang.NewSymbol("read-line")
	sym_read_DASH_string := lang.NewSymbol("read-string")
	sym_reader := lang.NewSymbol("reader")
	sym_reader_DASH_conditional := lang.NewSymbol("reader-conditional")
	sym_reader_DASH_conditional_QMARK_ := lang.NewSymbol("reader-conditional?")
	sym_realized_QMARK_ := lang.NewSymbol("realized?")
	sym_recur := lang.NewSymbol("recur")
	sym_recursive_QMARK_ := lang.NewSymbol("recursive?")
	sym_reduce := lang.NewSymbol("reduce")
	sym_reduce_DASH_kv := lang.NewSymbol("reduce-kv")
	sym_reduce1 := lang.NewSymbol("reduce1")
	sym_reduced := lang.NewSymbol("reduced")
	sym_reduced_QMARK_ := lang.NewSymbol("reduced?")
	sym_reductions := lang.NewSymbol("reductions")
	sym_ref := lang.NewSymbol("ref")
	sym_ref_DASH_history_DASH_count := lang.NewSymbol("ref-history-count")
	sym_ref_DASH_max_DASH_history := lang.NewSymbol("ref-max-history")
	sym_ref_DASH_min_DASH_history := lang.NewSymbol("ref-min-history")
	sym_ref_DASH_set := lang.NewSymbol("ref-set")
	sym_refer := lang.NewSymbol("refer")
	sym_refer_DASH_glojure := lang.NewSymbol("refer-glojure")
	sym_reference := lang.NewSymbol("reference")
	sym_references_STAR_ := lang.NewSymbol("references*")
	sym_release_DASH_pending_DASH_sends := lang.NewSymbol("release-pending-sends")
	sym_rem := lang.NewSymbol("rem")
	sym_remove := lang.NewSymbol("remove")
	sym_remove_DASH_all_DASH_methods := lang.NewSymbol("remove-all-methods")
	sym_remove_DASH_method := lang.NewSymbol("remove-method")
	sym_remove_DASH_ns := lang.NewSymbol("remove-ns")
	sym_remove_DASH_tap := lang.NewSymbol("remove-tap")
	sym_remove_DASH_watch := lang.NewSymbol("remove-watch")
	sym_rep := lang.NewSymbol("rep")
	sym_repeat := lang.NewSymbol("repeat")
	sym_repeatedly := lang.NewSymbol("repeatedly")
	sym_replace := lang.NewSymbol("replace")
	sym_replicate := lang.NewSymbol("replicate")
	sym_require := lang.NewSymbol("require")
	sym_requiring_DASH_resolve := lang.NewSymbol("requiring-resolve")
	sym_reset_BANG_ := lang.NewSymbol("reset!")
	sym_reset_DASH_meta_BANG_ := lang.NewSymbol("reset-meta!")
	sym_reset_DASH_vals_BANG_ := lang.NewSymbol("reset-vals!")
	sym_resolve := lang.NewSymbol("resolve")
	sym_rest := lang.NewSymbol("rest")
	sym_restart_DASH_agent := lang.NewSymbol("restart-agent")
	sym_resultset_DASH_seq := lang.NewSymbol("resultset-seq")
	sym_ret := lang.NewSymbol("ret")
	sym_ret__1__auto__ := lang.NewSymbol("ret__1__auto__")
	sym_retf := lang.NewSymbol("retf")
	sym_rev := lang.NewSymbol("rev")
	sym_reverse := lang.NewSymbol("reverse")
	sym_reversible_QMARK_ := lang.NewSymbol("reversible?")
	sym_rf := lang.NewSymbol("rf")
	sym_root := lang.NewSymbol("root")
	sym_root_DASH_directory := lang.NewSymbol("root-directory")
	sym_root_DASH_resource := lang.NewSymbol("root-resource")
	sym_rs := lang.NewSymbol("rs")
	sym_rseq := lang.NewSymbol("rseq")
	sym_rsubseq := lang.NewSymbol("rsubseq")
	sym_run_BANG_ := lang.NewSymbol("run!")
	sym_s := lang.NewSymbol("s")
	sym_s__0__auto__ := lang.NewSymbol("s__0__auto__")
	sym_sc := lang.NewSymbol("sc")
	sym_second := lang.NewSymbol("second")
	sym_select_DASH_keys := lang.NewSymbol("select-keys")
	sym_send := lang.NewSymbol("send")
	sym_send_DASH_off := lang.NewSymbol("send-off")
	sym_send_DASH_via := lang.NewSymbol("send-via")
	sym_sep := lang.NewSymbol("sep")
	sym_seq := lang.NewSymbol("seq")
	sym_seq_DASH_exprs := lang.NewSymbol("seq-exprs")
	sym_seq_DASH_reduce := lang.NewSymbol("seq-reduce")
	sym_seq_DASH_to_DASH_map_DASH_for_DASH_destructuring := lang.NewSymbol("seq-to-map-for-destructuring")
	sym_seq_QMARK_ := lang.NewSymbol("seq?")
	sym_seqable_QMARK_ := lang.NewSymbol("seqable?")
	sym_seque := lang.NewSymbol("seque")
	sym_sequence := lang.NewSymbol("sequence")
	sym_sequential_QMARK_ := lang.NewSymbol("sequential?")
	sym_serialized_DASH_require := lang.NewSymbol("serialized-require")
	sym_set := lang.NewSymbol("set")
	sym_set_DASH_agent_DASH_send_DASH_executor_BANG_ := lang.NewSymbol("set-agent-send-executor!")
	sym_set_DASH_agent_DASH_send_DASH_off_DASH_executor_BANG_ := lang.NewSymbol("set-agent-send-off-executor!")
	sym_set_DASH_error_DASH_handler_BANG_ := lang.NewSymbol("set-error-handler!")
	sym_set_DASH_error_DASH_mode_BANG_ := lang.NewSymbol("set-error-mode!")
	sym_set_DASH_validator_BANG_ := lang.NewSymbol("set-validator!")
	sym_set_QMARK_ := lang.NewSymbol("set?")
	sym_setDynamic := lang.NewSymbol("setDynamic")
	sym_setup_DASH_reference := lang.NewSymbol("setup-reference")
	sym_shift := lang.NewSymbol("shift")
	sym_shift_DASH_mask := lang.NewSymbol("shift-mask")
	sym_short := lang.NewSymbol("short")
	sym_short_DASH_array := lang.NewSymbol("short-array")
	sym_shortCast := lang.NewSymbol("shortCast")
	sym_shorts := lang.NewSymbol("shorts")
	sym_shuffle := lang.NewSymbol("shuffle")
	sym_shutdown_DASH_agents := lang.NewSymbol("shutdown-agents")
	sym_sigs := lang.NewSymbol("sigs")
	sym_simple_DASH_ident_QMARK_ := lang.NewSymbol("simple-ident?")
	sym_simple_DASH_keyword_QMARK_ := lang.NewSymbol("simple-keyword?")
	sym_simple_DASH_symbol_QMARK_ := lang.NewSymbol("simple-symbol?")
	sym_size := lang.NewSymbol("size")
	sym_size_DASH_or_DASH_seq := lang.NewSymbol("size-or-seq")
	sym_size__1__auto__ := lang.NewSymbol("size__1__auto__")
	sym_slurp := lang.NewSymbol("slurp")
	sym_smap := lang.NewSymbol("smap")
	sym_some := lang.NewSymbol("some")
	sym_some_DASH__GT_ := lang.NewSymbol("some->")
	sym_some_DASH__GT__GT_ := lang.NewSymbol("some->>")
	sym_some_DASH_fn := lang.NewSymbol("some-fn")
	sym_some_QMARK_ := lang.NewSymbol("some?")
	sym_somef := lang.NewSymbol("somef")
	sym_sort := lang.NewSymbol("sort")
	sym_sort_DASH_by := lang.NewSymbol("sort-by")
	sym_sorted_DASH_map := lang.NewSymbol("sorted-map")
	sym_sorted_DASH_map_DASH_by := lang.NewSymbol("sorted-map-by")
	sym_sorted_DASH_set := lang.NewSymbol("sorted-set")
	sym_sorted_DASH_set_DASH_by := lang.NewSymbol("sorted-set-by")
	sym_sorted_QMARK_ := lang.NewSymbol("sorted?")
	sym_special_DASH_symbol_QMARK_ := lang.NewSymbol("special-symbol?")
	sym_specs := lang.NewSymbol("specs")
	sym_spit := lang.NewSymbol("spit")
	sym_splicing_QMARK_ := lang.NewSymbol("splicing?")
	sym_split_DASH_at := lang.NewSymbol("split-at")
	sym_split_DASH_with := lang.NewSymbol("split-with")
	sym_splitv_DASH_at := lang.NewSymbol("splitv-at")
	sym_spread := lang.NewSymbol("spread")
	sym_start := lang.NewSymbol("start")
	sym_start_DASH_key := lang.NewSymbol("start-key")
	sym_start_DASH_test := lang.NewSymbol("start-test")
	sym_start__0__auto__ := lang.NewSymbol("start__0__auto__")
	sym_state := lang.NewSymbol("state")
	sym_step := lang.NewSymbol("step")
	sym_str := lang.NewSymbol("str")
	sym_stream := lang.NewSymbol("stream")
	sym_stream_DASH_into_BANG_ := lang.NewSymbol("stream-into!")
	sym_stream_DASH_reduce_BANG_ := lang.NewSymbol("stream-reduce!")
	sym_stream_DASH_seq_BANG_ := lang.NewSymbol("stream-seq!")
	sym_stream_DASH_transduce_BANG_ := lang.NewSymbol("stream-transduce!")
	sym_string_QMARK_ := lang.NewSymbol("string?")
	sym_strings_DOT_Builder := lang.NewSymbol("strings.Builder")
	sym_strip_DASH_ns := lang.NewSymbol("strip-ns")
	sym_struct := lang.NewSymbol("struct")
	sym_struct_DASH_map := lang.NewSymbol("struct-map")
	sym_subs := lang.NewSymbol("subs")
	sym_subseq := lang.NewSymbol("subseq")
	sym_subvec := lang.NewSymbol("subvec")
	sym_supers := lang.NewSymbol("supers")
	sym_swap_BANG_ := lang.NewSymbol("swap!")
	sym_swap_DASH_vals_BANG_ := lang.NewSymbol("swap-vals!")
	sym_sym := lang.NewSymbol("sym")
	sym_symbol := lang.NewSymbol("symbol")
	sym_symbol_QMARK_ := lang.NewSymbol("symbol?")
	sym_sync := lang.NewSymbol("sync")
	sym_system_DASH_newline := lang.NewSymbol("system-newline")
	sym_t := lang.NewSymbol("t")
	sym_tag := lang.NewSymbol("tag")
	sym_tagged_DASH_literal := lang.NewSymbol("tagged-literal")
	sym_tagged_DASH_literal_QMARK_ := lang.NewSymbol("tagged-literal?")
	sym_take := lang.NewSymbol("take")
	sym_take_DASH_last := lang.NewSymbol("take-last")
	sym_take_DASH_nth := lang.NewSymbol("take-nth")
	sym_take_DASH_while := lang.NewSymbol("take-while")
	sym_tapset := lang.NewSymbol("tapset")
	sym_temp__0__auto__ := lang.NewSymbol("temp__0__auto__")
	sym_test := lang.NewSymbol("test")
	sym_test_DASH_f := lang.NewSymbol("test-f")
	sym_tests := lang.NewSymbol("tests")
	sym_the_DASH_ns := lang.NewSymbol("the-ns")
	sym_then := lang.NewSymbol("then")
	sym_thens := lang.NewSymbol("thens")
	sym_this := lang.NewSymbol("this")
	sym_thread_DASH_bound_QMARK_ := lang.NewSymbol("thread-bound?")
	sym_throw := lang.NewSymbol("throw")
	sym_throw_DASH_if := lang.NewSymbol("throw-if")
	sym_time := lang.NewSymbol("time")
	sym_time_DOT_Now := lang.NewSymbol("time.Now")
	sym_timeout_DASH_ms := lang.NewSymbol("timeout-ms")
	sym_timeout_DASH_val := lang.NewSymbol("timeout-val")
	sym_to := lang.NewSymbol("to")
	sym_to_DASH_array := lang.NewSymbol("to-array")
	sym_to_DASH_array_DASH_2d := lang.NewSymbol("to-array-2d")
	sym_trampoline := lang.NewSymbol("trampoline")
	sym_transduce := lang.NewSymbol("transduce")
	sym_transient := lang.NewSymbol("transient")
	sym_tree_DASH_seq := lang.NewSymbol("tree-seq")
	sym_true_QMARK_ := lang.NewSymbol("true?")
	sym_try := lang.NewSymbol("try")
	sym_type := lang.NewSymbol("type")
	sym_unchecked_DASH_add := lang.NewSymbol("unchecked-add")
	sym_unchecked_DASH_add_DASH_int := lang.NewSymbol("unchecked-add-int")
	sym_unchecked_DASH_byte := lang.NewSymbol("unchecked-byte")
	sym_unchecked_DASH_char := lang.NewSymbol("unchecked-char")
	sym_unchecked_DASH_dec := lang.NewSymbol("unchecked-dec")
	sym_unchecked_DASH_dec_DASH_int := lang.NewSymbol("unchecked-dec-int")
	sym_unchecked_DASH_divide_DASH_int := lang.NewSymbol("unchecked-divide-int")
	sym_unchecked_DASH_double := lang.NewSymbol("unchecked-double")
	sym_unchecked_DASH_float := lang.NewSymbol("unchecked-float")
	sym_unchecked_DASH_inc := lang.NewSymbol("unchecked-inc")
	sym_unchecked_DASH_inc_DASH_int := lang.NewSymbol("unchecked-inc-int")
	sym_unchecked_DASH_int := lang.NewSymbol("unchecked-int")
	sym_unchecked_DASH_long := lang.NewSymbol("unchecked-long")
	sym_unchecked_DASH_multiply := lang.NewSymbol("unchecked-multiply")
	sym_unchecked_DASH_multiply_DASH_int := lang.NewSymbol("unchecked-multiply-int")
	sym_unchecked_DASH_negate := lang.NewSymbol("unchecked-negate")
	sym_unchecked_DASH_negate_DASH_int := lang.NewSymbol("unchecked-negate-int")
	sym_unchecked_DASH_op := lang.NewSymbol("unchecked-op")
	sym_unchecked_DASH_remainder_DASH_int := lang.NewSymbol("unchecked-remainder-int")
	sym_unchecked_DASH_short := lang.NewSymbol("unchecked-short")
	sym_unchecked_DASH_subtract := lang.NewSymbol("unchecked-subtract")
	sym_unchecked_DASH_subtract_DASH_int := lang.NewSymbol("unchecked-subtract-int")
	sym_uncheckedByteCast := lang.NewSymbol("uncheckedByteCast")
	sym_uncheckedCharCast := lang.NewSymbol("uncheckedCharCast")
	sym_uncheckedFloatCast := lang.NewSymbol("uncheckedFloatCast")
	sym_uncheckedIntCast := lang.NewSymbol("uncheckedIntCast")
	sym_uncheckedShortCast := lang.NewSymbol("uncheckedShortCast")
	sym_unchecked_add := lang.NewSymbol("unchecked_add")
	sym_unchecked_dec := lang.NewSymbol("unchecked_dec")
	sym_unchecked_inc := lang.NewSymbol("unchecked_inc")
	sym_unchecked_minus := lang.NewSymbol("unchecked_minus")
	sym_unchecked_multiply := lang.NewSymbol("unchecked_multiply")
	sym_underive := lang.NewSymbol("underive")
	sym_unquote := lang.NewSymbol("unquote")
	sym_unquote_DASH_splicing := lang.NewSymbol("unquote-splicing")
	sym_unreduced := lang.NewSymbol("unreduced")
	sym_unsigned_DASH_bit_DASH_shift_DASH_right := lang.NewSymbol("unsigned-bit-shift-right")
	sym_update := lang.NewSymbol("update")
	sym_update_DASH_in := lang.NewSymbol("update-in")
	sym_update_DASH_keys := lang.NewSymbol("update-keys")
	sym_update_DASH_vals := lang.NewSymbol("update-vals")
	sym_uri_QMARK_ := lang.NewSymbol("uri?")
	sym_url := lang.NewSymbol("url")
	sym_use := lang.NewSymbol("use")
	sym_uuid_QMARK_ := lang.NewSymbol("uuid?")
	sym_v := lang.NewSymbol("v")
	sym_v__0__auto__ := lang.NewSymbol("v__0__auto__")
	sym_val := lang.NewSymbol("val")
	sym_val__2__auto__ := lang.NewSymbol("val__2__auto__")
	sym_valid_DASH_keys := lang.NewSymbol("valid-keys")
	sym_validator_DASH_fn := lang.NewSymbol("validator-fn")
	sym_vals := lang.NewSymbol("vals")
	sym_value := lang.NewSymbol("value")
	sym_var := lang.NewSymbol("var")
	sym_var_DASH_get := lang.NewSymbol("var-get")
	sym_var_DASH_set := lang.NewSymbol("var-set")
	sym_var_QMARK_ := lang.NewSymbol("var?")
	sym_vars := lang.NewSymbol("vars")
	sym_vary_DASH_meta := lang.NewSymbol("vary-meta")
	sym_vec := lang.NewSymbol("vec")
	sym_vector := lang.NewSymbol("vector")
	sym_vector_QMARK_ := lang.NewSymbol("vector?")
	sym_vf := lang.NewSymbol("vf")
	sym_vol := lang.NewSymbol("vol")
	sym_volatile_BANG_ := lang.NewSymbol("volatile!")
	sym_volatile_QMARK_ := lang.NewSymbol("volatile?")
	sym_vreset_BANG_ := lang.NewSymbol("vreset!")
	sym_vswap_BANG_ := lang.NewSymbol("vswap!")
	sym_w := lang.NewSymbol("w")
	sym_when := lang.NewSymbol("when")
	sym_when_DASH_first := lang.NewSymbol("when-first")
	sym_when_DASH_let := lang.NewSymbol("when-let")
	sym_when_DASH_not := lang.NewSymbol("when-not")
	sym_when_DASH_some := lang.NewSymbol("when-some")
	sym_while := lang.NewSymbol("while")
	sym_with_DASH_bindings := lang.NewSymbol("with-bindings")
	sym_with_DASH_bindings_STAR_ := lang.NewSymbol("with-bindings*")
	sym_with_DASH_in_DASH_str := lang.NewSymbol("with-in-str")
	sym_with_DASH_loading_DASH_context := lang.NewSymbol("with-loading-context")
	sym_with_DASH_local_DASH_vars := lang.NewSymbol("with-local-vars")
	sym_with_DASH_meta := lang.NewSymbol("with-meta")
	sym_with_DASH_open := lang.NewSymbol("with-open")
	sym_with_DASH_out_DASH_str := lang.NewSymbol("with-out-str")
	sym_with_DASH_precision := lang.NewSymbol("with-precision")
	sym_with_DASH_redefs := lang.NewSymbol("with-redefs")
	sym_with_DASH_redefs_DASH_fn := lang.NewSymbol("with-redefs-fn")
	sym_x := lang.NewSymbol("x")
	sym_xform := lang.NewSymbol("xform")
	sym_xml_DASH_seq := lang.NewSymbol("xml-seq")
	sym_xor := lang.NewSymbol("xor")
	sym_xs := lang.NewSymbol("xs")
	sym_xs__0__auto__ := lang.NewSymbol("xs__0__auto__")
	sym_y := lang.NewSymbol("y")
	sym_ys := lang.NewSymbol("ys")
	sym_z := lang.NewSymbol("z")
	sym_zero_QMARK_ := lang.NewSymbol("zero?")
	sym_zipmap := lang.NewSymbol("zipmap")
	sym_zs := lang.NewSymbol("zs")
	kw__GT__GT_ := lang.NewKeyword(">>")
	kw_added := lang.NewKeyword("added")
	kw_all := lang.NewKeyword("all")
	kw_allow := lang.NewKeyword("allow")
	kw_ancestors := lang.NewKeyword("ancestors")
	kw_arglists := lang.NewKeyword("arglists")
	kw_as := lang.NewKeyword("as")
	kw_as_DASH_alias := lang.NewKeyword("as-alias")
	kw_at := lang.NewKeyword("at")
	kw_cause := lang.NewKeyword("cause")
	kw_clear_DASH_actions := lang.NewKeyword("clear-actions")
	kw_coll_DASH_reduce := lang.NewKeyword("coll-reduce")
	kw_column := lang.NewKeyword("column")
	kw_compact := lang.NewKeyword("compact")
	kw_conflict := lang.NewKeyword("conflict")
	kw_content := lang.NewKeyword("content")
	kw_continue := lang.NewKeyword("continue")
	kw_data := lang.NewKeyword("data")
	kw_datafy := lang.NewKeyword("datafy")
	kw_declared := lang.NewKeyword("declared")
	kw_default := lang.NewKeyword("default")
	kw_deprecated := lang.NewKeyword("deprecated")
	kw_descendants := lang.NewKeyword("descendants")
	kw_doc := lang.NewKeyword("doc")
	kw_dynamic := lang.NewKeyword("dynamic")
	kw_else := lang.NewKeyword("else")
	kw_encoding := lang.NewKeyword("encoding")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_eof := lang.NewKeyword("eof")
	kw_error_DASH_handler := lang.NewKeyword("error-handler")
	kw_error_DASH_mode := lang.NewKeyword("error-mode")
	kw_exclude := lang.NewKeyword("exclude")
	kw_fail := lang.NewKeyword("fail")
	kw_failed := lang.NewKeyword("failed")
	kw_file := lang.NewKeyword("file")
	kw_form := lang.NewKeyword("form")
	kw_forms := lang.NewKeyword("forms")
	kw_gen_DASH_class := lang.NewKeyword("gen-class")
	kw_glojure_DOT_core_SLASH_halt := lang.NewKeyword("glojure.core/halt")
	kw_glojure_DOT_core_SLASH_none := lang.NewKeyword("glojure.core/none")
	kw_glojure_DOT_error_SLASH_phase := lang.NewKeyword("glojure.error/phase")
	kw_hash_DASH_equiv := lang.NewKeyword("hash-equiv")
	kw_hash_DASH_identity := lang.NewKeyword("hash-identity")
	kw_hashes := lang.NewKeyword("hashes")
	kw_hierarchy := lang.NewKeyword("hierarchy")
	kw_identity := lang.NewKeyword("identity")
	kw_impl_DASH_ns := lang.NewKeyword("impl-ns")
	kw_initk := lang.NewKeyword("initk")
	kw_inline := lang.NewKeyword("inline")
	kw_inline_DASH_arities := lang.NewKeyword("inline-arities")
	kw_int := lang.NewKeyword("int")
	kw_internal_DASH_reduce := lang.NewKeyword("internal-reduce")
	kw_ints := lang.NewKeyword("ints")
	kw_keys := lang.NewKeyword("keys")
	kw_kf := lang.NewKeyword("kf")
	kw_kv_DASH_reduce := lang.NewKeyword("kv-reduce")
	kw_let := lang.NewKeyword("let")
	kw_line := lang.NewKeyword("line")
	kw_macro := lang.NewKeyword("macro")
	kw_main := lang.NewKeyword("main")
	kw_make_DASH_input_DASH_stream := lang.NewKeyword("make-input-stream")
	kw_make_DASH_output_DASH_stream := lang.NewKeyword("make-output-stream")
	kw_make_DASH_reader := lang.NewKeyword("make-reader")
	kw_make_DASH_writer := lang.NewKeyword("make-writer")
	kw_mappings := lang.NewKeyword("mappings")
	kw_max_DASH_history := lang.NewKeyword("max-history")
	kw_message := lang.NewKeyword("message")
	kw_meta := lang.NewKeyword("meta")
	kw_min_DASH_history := lang.NewKeyword("min-history")
	kw_multis := lang.NewKeyword("multis")
	kw_name := lang.NewKeyword("name")
	kw_nav := lang.NewKeyword("nav")
	kw_no_DASH_test := lang.NewKeyword("no-test")
	kw_ns := lang.NewKeyword("ns")
	kw_ok := lang.NewKeyword("ok")
	kw_on_DASH_interface := lang.NewKeyword("on-interface")
	kw_only := lang.NewKeyword("only")
	kw_or := lang.NewKeyword("or")
	kw_parents := lang.NewKeyword("parents")
	kw_pending := lang.NewKeyword("pending")
	kw_phase := lang.NewKeyword("phase")
	kw_post := lang.NewKeyword("post")
	kw_pre := lang.NewKeyword("pre")
	kw_private := lang.NewKeyword("private")
	kw_read_DASH_cond := lang.NewKeyword("read-cond")
	kw_ready := lang.NewKeyword("ready")
	kw_redef := lang.NewKeyword("redef")
	kw_refer := lang.NewKeyword("refer")
	kw_refer_DASH_glojure := lang.NewKeyword("refer-glojure")
	kw_reload := lang.NewKeyword("reload")
	kw_reload_DASH_all := lang.NewKeyword("reload-all")
	kw_rename := lang.NewKeyword("rename")
	kw_require := lang.NewKeyword("require")
	kw_rettag := lang.NewKeyword("rettag")
	kw_rounding := lang.NewKeyword("rounding")
	kw_sigs := lang.NewKeyword("sigs")
	kw_somef := lang.NewKeyword("somef")
	kw_sparse := lang.NewKeyword("sparse")
	kw_special_DASH_form := lang.NewKeyword("special-form")
	kw_static := lang.NewKeyword("static")
	kw_status := lang.NewKeyword("status")
	kw_tag := lang.NewKeyword("tag")
	kw_test := lang.NewKeyword("test")
	kw_trace := lang.NewKeyword("trace")
	kw_type := lang.NewKeyword("type")
	kw_url := lang.NewKeyword("url")
	kw_use := lang.NewKeyword("use")
	kw_val := lang.NewKeyword("val")
	kw_validator := lang.NewKeyword("validator")
	kw_verbose := lang.NewKeyword("verbose")
	kw_vf := lang.NewKeyword("vf")
	kw_via := lang.NewKeyword("via")
	kw_when := lang.NewKeyword("when")
	kw_while := lang.NewKeyword("while")
	// var glojure.core.protocols/coll-reduce
	var_glojure_DOT_core_DOT_protocols_coll_DASH_reduce := lang.InternVarName(sym_glojure_DOT_core_DOT_protocols, sym_coll_DASH_reduce)
	// var glojure.core.protocols/interface-or-naive-reduce
	var_glojure_DOT_core_DOT_protocols_interface_DASH_or_DASH_naive_DASH_reduce := lang.InternVarName(sym_glojure_DOT_core_DOT_protocols, sym_interface_DASH_or_DASH_naive_DASH_reduce)
	// var glojure.core.protocols/kv-reduce
	var_glojure_DOT_core_DOT_protocols_kv_DASH_reduce := lang.InternVarName(sym_glojure_DOT_core_DOT_protocols, sym_kv_DASH_reduce)
	// var glojure.core.protocols/seq-reduce
	var_glojure_DOT_core_DOT_protocols_seq_DASH_reduce := lang.InternVarName(sym_glojure_DOT_core_DOT_protocols, sym_seq_DASH_reduce)
	// var glojure.core/StackTraceElement->vec
	var_glojure_DOT_core_StackTraceElement_DASH__GT_vec := lang.InternVarName(sym_glojure_DOT_core, sym_StackTraceElement_DASH__GT_vec)
	// var glojure.core/Throwable->map
	var_glojure_DOT_core_Throwable_DASH__GT_map := lang.InternVarName(sym_glojure_DOT_core, sym_Throwable_DASH__GT_map)
	// var glojure.core/-
	var_glojure_DOT_core__DASH_ := lang.InternVarName(sym_glojure_DOT_core, sym__DASH_)
	// var glojure.core/-'
	var_glojure_DOT_core__DASH__TICK_ := lang.InternVarName(sym_glojure_DOT_core, sym__DASH__TICK_)
	// var glojure.core/=
	var_glojure_DOT_core__EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym__EQ_)
	// var glojure.core/==
	var_glojure_DOT_core__EQ__EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym__EQ__EQ_)
	// var glojure.core/>
	var_glojure_DOT_core__GT_ := lang.InternVarName(sym_glojure_DOT_core, sym__GT_)
	// var glojure.core/>=
	var_glojure_DOT_core__GT__EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym__GT__EQ_)
	// var glojure.core/<
	var_glojure_DOT_core__LT_ := lang.InternVarName(sym_glojure_DOT_core, sym__LT_)
	// var glojure.core/<=
	var_glojure_DOT_core__LT__EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym__LT__EQ_)
	// var glojure.core/+
	var_glojure_DOT_core__PLUS_ := lang.InternVarName(sym_glojure_DOT_core, sym__PLUS_)
	// var glojure.core/+'
	var_glojure_DOT_core__PLUS__TICK_ := lang.InternVarName(sym_glojure_DOT_core, sym__PLUS__TICK_)
	// var glojure.core//
	var_glojure_DOT_core__SLASH_ := lang.InternVarName(sym_glojure_DOT_core, sym__SLASH_)
	// var glojure.core/*
	var_glojure_DOT_core__STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_)
	// var glojure.core/*'
	var_glojure_DOT_core__STAR__TICK_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR__TICK_)
	// var glojure.core/*agent*
	var_glojure_DOT_core__STAR_agent_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_agent_STAR_)
	// var glojure.core/*assert*
	var_glojure_DOT_core__STAR_assert_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_assert_STAR_)
	// var glojure.core/*file*
	var_glojure_DOT_core__STAR_file_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_file_STAR_)
	// var glojure.core/*flush-on-newline*
	var_glojure_DOT_core__STAR_flush_DASH_on_DASH_newline_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_flush_DASH_on_DASH_newline_STAR_)
	// var glojure.core/*in*
	var_glojure_DOT_core__STAR_in_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_in_STAR_)
	// var glojure.core/*loaded-libs*
	var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_loaded_DASH_libs_STAR_)
	// var glojure.core/*loading-verbosely*
	var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_loading_DASH_verbosely_STAR_)
	// var glojure.core/*ns*
	var_glojure_DOT_core__STAR_ns_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_ns_STAR_)
	// var glojure.core/*out*
	var_glojure_DOT_core__STAR_out_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_out_STAR_)
	// var glojure.core/*pending-paths*
	var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_pending_DASH_paths_STAR_)
	// var glojure.core/*print-dup*
	var_glojure_DOT_core__STAR_print_DASH_dup_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_dup_STAR_)
	// var glojure.core/*print-length*
	var_glojure_DOT_core__STAR_print_DASH_length_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_length_STAR_)
	// var glojure.core/*print-level*
	var_glojure_DOT_core__STAR_print_DASH_level_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_level_STAR_)
	// var glojure.core/*print-meta*
	var_glojure_DOT_core__STAR_print_DASH_meta_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_meta_STAR_)
	// var glojure.core/*print-namespace-maps*
	var_glojure_DOT_core__STAR_print_DASH_namespace_DASH_maps_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_namespace_DASH_maps_STAR_)
	// var glojure.core/*print-readably*
	var_glojure_DOT_core__STAR_print_DASH_readably_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_readably_STAR_)
	// var glojure.core/*unchecked-math*
	var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_unchecked_DASH_math_STAR_)
	// var glojure.core/*verbose-defrecords*
	var_glojure_DOT_core__STAR_verbose_DASH_defrecords_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_verbose_DASH_defrecords_STAR_)
	// var glojure.core/agent
	var_glojure_DOT_core_agent := lang.InternVarName(sym_glojure_DOT_core, sym_agent)
	// var glojure.core/agent-error
	var_glojure_DOT_core_agent_DASH_error := lang.InternVarName(sym_glojure_DOT_core, sym_agent_DASH_error)
	// var glojure.core/aget
	var_glojure_DOT_core_aget := lang.InternVarName(sym_glojure_DOT_core, sym_aget)
	// var glojure.core/alength
	var_glojure_DOT_core_alength := lang.InternVarName(sym_glojure_DOT_core, sym_alength)
	// var glojure.core/alias
	var_glojure_DOT_core_alias := lang.InternVarName(sym_glojure_DOT_core, sym_alias)
	// var glojure.core/alter-var-root
	var_glojure_DOT_core_alter_DASH_var_DASH_root := lang.InternVarName(sym_glojure_DOT_core, sym_alter_DASH_var_DASH_root)
	// var glojure.core/ancestors
	var_glojure_DOT_core_ancestors := lang.InternVarName(sym_glojure_DOT_core, sym_ancestors)
	// var glojure.core/apply
	var_glojure_DOT_core_apply := lang.InternVarName(sym_glojure_DOT_core, sym_apply)
	// var glojure.core/aset
	var_glojure_DOT_core_aset := lang.InternVarName(sym_glojure_DOT_core, sym_aset)
	// var glojure.core/aset-boolean
	var_glojure_DOT_core_aset_DASH_boolean := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_boolean)
	// var glojure.core/aset-byte
	var_glojure_DOT_core_aset_DASH_byte := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_byte)
	// var glojure.core/aset-char
	var_glojure_DOT_core_aset_DASH_char := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_char)
	// var glojure.core/aset-double
	var_glojure_DOT_core_aset_DASH_double := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_double)
	// var glojure.core/aset-float
	var_glojure_DOT_core_aset_DASH_float := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_float)
	// var glojure.core/aset-int
	var_glojure_DOT_core_aset_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_int)
	// var glojure.core/aset-long
	var_glojure_DOT_core_aset_DASH_long := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_long)
	// var glojure.core/aset-short
	var_glojure_DOT_core_aset_DASH_short := lang.InternVarName(sym_glojure_DOT_core, sym_aset_DASH_short)
	// var glojure.core/assert-valid-fdecl
	var_glojure_DOT_core_assert_DASH_valid_DASH_fdecl := lang.InternVarName(sym_glojure_DOT_core, sym_assert_DASH_valid_DASH_fdecl)
	// var glojure.core/assoc
	var_glojure_DOT_core_assoc := lang.InternVarName(sym_glojure_DOT_core, sym_assoc)
	// var glojure.core/assoc!
	var_glojure_DOT_core_assoc_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_assoc_BANG_)
	// var glojure.core/assoc-in
	var_glojure_DOT_core_assoc_DASH_in := lang.InternVarName(sym_glojure_DOT_core, sym_assoc_DASH_in)
	// var glojure.core/atom
	var_glojure_DOT_core_atom := lang.InternVarName(sym_glojure_DOT_core, sym_atom)
	// var glojure.core/await
	var_glojure_DOT_core_await := lang.InternVarName(sym_glojure_DOT_core, sym_await)
	// var glojure.core/bases
	var_glojure_DOT_core_bases := lang.InternVarName(sym_glojure_DOT_core, sym_bases)
	// var glojure.core/bigint
	var_glojure_DOT_core_bigint := lang.InternVarName(sym_glojure_DOT_core, sym_bigint)
	// var glojure.core/binding-conveyor-fn
	var_glojure_DOT_core_binding_DASH_conveyor_DASH_fn := lang.InternVarName(sym_glojure_DOT_core, sym_binding_DASH_conveyor_DASH_fn)
	// var glojure.core/bit-and
	var_glojure_DOT_core_bit_DASH_and := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_and)
	// var glojure.core/bit-and-not
	var_glojure_DOT_core_bit_DASH_and_DASH_not := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_and_DASH_not)
	// var glojure.core/bit-or
	var_glojure_DOT_core_bit_DASH_or := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_or)
	// var glojure.core/bit-shift-left
	var_glojure_DOT_core_bit_DASH_shift_DASH_left := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_shift_DASH_left)
	// var glojure.core/bit-shift-right
	var_glojure_DOT_core_bit_DASH_shift_DASH_right := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_shift_DASH_right)
	// var glojure.core/bit-xor
	var_glojure_DOT_core_bit_DASH_xor := lang.InternVarName(sym_glojure_DOT_core, sym_bit_DASH_xor)
	// var glojure.core/boolean
	var_glojure_DOT_core_boolean := lang.InternVarName(sym_glojure_DOT_core, sym_boolean)
	// var glojure.core/butlast
	var_glojure_DOT_core_butlast := lang.InternVarName(sym_glojure_DOT_core, sym_butlast)
	// var glojure.core/byte
	var_glojure_DOT_core_byte := lang.InternVarName(sym_glojure_DOT_core, sym_byte)
	// var glojure.core/case-map
	var_glojure_DOT_core_case_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_case_DASH_map)
	// var glojure.core/cat
	var_glojure_DOT_core_cat := lang.InternVarName(sym_glojure_DOT_core, sym_cat)
	// var glojure.core/char
	var_glojure_DOT_core_char := lang.InternVarName(sym_glojure_DOT_core, sym_char)
	// var glojure.core/char-escape-string
	var_glojure_DOT_core_char_DASH_escape_DASH_string := lang.InternVarName(sym_glojure_DOT_core, sym_char_DASH_escape_DASH_string)
	// var glojure.core/char-name-string
	var_glojure_DOT_core_char_DASH_name_DASH_string := lang.InternVarName(sym_glojure_DOT_core, sym_char_DASH_name_DASH_string)
	// var glojure.core/check-cyclic-dependency
	var_glojure_DOT_core_check_DASH_cyclic_DASH_dependency := lang.InternVarName(sym_glojure_DOT_core, sym_check_DASH_cyclic_DASH_dependency)
	// var glojure.core/check-valid-options
	var_glojure_DOT_core_check_DASH_valid_DASH_options := lang.InternVarName(sym_glojure_DOT_core, sym_check_DASH_valid_DASH_options)
	// var glojure.core/chunk
	var_glojure_DOT_core_chunk := lang.InternVarName(sym_glojure_DOT_core, sym_chunk)
	// var glojure.core/chunk-append
	var_glojure_DOT_core_chunk_DASH_append := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_append)
	// var glojure.core/chunk-buffer
	var_glojure_DOT_core_chunk_DASH_buffer := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_buffer)
	// var glojure.core/chunk-cons
	var_glojure_DOT_core_chunk_DASH_cons := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_cons)
	// var glojure.core/chunk-first
	var_glojure_DOT_core_chunk_DASH_first := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_first)
	// var glojure.core/chunk-next
	var_glojure_DOT_core_chunk_DASH_next := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_next)
	// var glojure.core/chunk-rest
	var_glojure_DOT_core_chunk_DASH_rest := lang.InternVarName(sym_glojure_DOT_core, sym_chunk_DASH_rest)
	// var glojure.core/chunked-seq?
	var_glojure_DOT_core_chunked_DASH_seq_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_chunked_DASH_seq_QMARK_)
	// var glojure.core/class
	var_glojure_DOT_core_class := lang.InternVarName(sym_glojure_DOT_core, sym_class)
	// var glojure.core/class?
	var_glojure_DOT_core_class_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_class_QMARK_)
	// var glojure.core/commute
	var_glojure_DOT_core_commute := lang.InternVarName(sym_glojure_DOT_core, sym_commute)
	// var glojure.core/comp
	var_glojure_DOT_core_comp := lang.InternVarName(sym_glojure_DOT_core, sym_comp)
	// var glojure.core/compare
	var_glojure_DOT_core_compare := lang.InternVarName(sym_glojure_DOT_core, sym_compare)
	// var glojure.core/compare-and-set!
	var_glojure_DOT_core_compare_DASH_and_DASH_set_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_compare_DASH_and_DASH_set_BANG_)
	// var glojure.core/complement
	var_glojure_DOT_core_complement := lang.InternVarName(sym_glojure_DOT_core, sym_complement)
	// var glojure.core/completing
	var_glojure_DOT_core_completing := lang.InternVarName(sym_glojure_DOT_core, sym_completing)
	// var glojure.core/concat
	var_glojure_DOT_core_concat := lang.InternVarName(sym_glojure_DOT_core, sym_concat)
	// var glojure.core/conj
	var_glojure_DOT_core_conj := lang.InternVarName(sym_glojure_DOT_core, sym_conj)
	// var glojure.core/conj!
	var_glojure_DOT_core_conj_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_conj_BANG_)
	// var glojure.core/cons
	var_glojure_DOT_core_cons := lang.InternVarName(sym_glojure_DOT_core, sym_cons)
	// var glojure.core/contains?
	var_glojure_DOT_core_contains_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_contains_QMARK_)
	// var glojure.core/count
	var_glojure_DOT_core_count := lang.InternVarName(sym_glojure_DOT_core, sym_count)
	// var glojure.core/counted?
	var_glojure_DOT_core_counted_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_counted_QMARK_)
	// var glojure.core/create-ns
	var_glojure_DOT_core_create_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_create_DASH_ns)
	// var glojure.core/create-struct
	var_glojure_DOT_core_create_DASH_struct := lang.InternVarName(sym_glojure_DOT_core, sym_create_DASH_struct)
	// var glojure.core/data-reader-urls
	var_glojure_DOT_core_data_DASH_reader_DASH_urls := lang.InternVarName(sym_glojure_DOT_core, sym_data_DASH_reader_DASH_urls)
	// var glojure.core/data-reader-var
	var_glojure_DOT_core_data_DASH_reader_DASH_var := lang.InternVarName(sym_glojure_DOT_core, sym_data_DASH_reader_DASH_var)
	// var glojure.core/dec
	var_glojure_DOT_core_dec := lang.InternVarName(sym_glojure_DOT_core, sym_dec)
	// var glojure.core/decimal?
	var_glojure_DOT_core_decimal_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_decimal_QMARK_)
	// var glojure.core/dedupe
	var_glojure_DOT_core_dedupe := lang.InternVarName(sym_glojure_DOT_core, sym_dedupe)
	// var glojure.core/deref
	var_glojure_DOT_core_deref := lang.InternVarName(sym_glojure_DOT_core, sym_deref)
	// var glojure.core/deref-as-map
	var_glojure_DOT_core_deref_DASH_as_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_deref_DASH_as_DASH_map)
	// var glojure.core/deref-future
	var_glojure_DOT_core_deref_DASH_future := lang.InternVarName(sym_glojure_DOT_core, sym_deref_DASH_future)
	// var glojure.core/derive
	var_glojure_DOT_core_derive := lang.InternVarName(sym_glojure_DOT_core, sym_derive)
	// var glojure.core/descendants
	var_glojure_DOT_core_descendants := lang.InternVarName(sym_glojure_DOT_core, sym_descendants)
	// var glojure.core/destructure
	var_glojure_DOT_core_destructure := lang.InternVarName(sym_glojure_DOT_core, sym_destructure)
	// var glojure.core/disj
	var_glojure_DOT_core_disj := lang.InternVarName(sym_glojure_DOT_core, sym_disj)
	// var glojure.core/dissoc
	var_glojure_DOT_core_dissoc := lang.InternVarName(sym_glojure_DOT_core, sym_dissoc)
	// var glojure.core/distinct?
	var_glojure_DOT_core_distinct_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_distinct_QMARK_)
	// var glojure.core/doall
	var_glojure_DOT_core_doall := lang.InternVarName(sym_glojure_DOT_core, sym_doall)
	// var glojure.core/dorun
	var_glojure_DOT_core_dorun := lang.InternVarName(sym_glojure_DOT_core, sym_dorun)
	// var glojure.core/double
	var_glojure_DOT_core_double := lang.InternVarName(sym_glojure_DOT_core, sym_double)
	// var glojure.core/drop
	var_glojure_DOT_core_drop := lang.InternVarName(sym_glojure_DOT_core, sym_drop)
	// var glojure.core/drop-last
	var_glojure_DOT_core_drop_DASH_last := lang.InternVarName(sym_glojure_DOT_core, sym_drop_DASH_last)
	// var glojure.core/drop-while
	var_glojure_DOT_core_drop_DASH_while := lang.InternVarName(sym_glojure_DOT_core, sym_drop_DASH_while)
	// var glojure.core/elide-top-frames
	var_glojure_DOT_core_elide_DASH_top_DASH_frames := lang.InternVarName(sym_glojure_DOT_core, sym_elide_DASH_top_DASH_frames)
	// var glojure.core/emit-extend-protocol
	var_glojure_DOT_core_emit_DASH_extend_DASH_protocol := lang.InternVarName(sym_glojure_DOT_core, sym_emit_DASH_extend_DASH_protocol)
	// var glojure.core/emit-extend-type
	var_glojure_DOT_core_emit_DASH_extend_DASH_type := lang.InternVarName(sym_glojure_DOT_core, sym_emit_DASH_extend_DASH_type)
	// var glojure.core/emit-hinted-impl
	var_glojure_DOT_core_emit_DASH_hinted_DASH_impl := lang.InternVarName(sym_glojure_DOT_core, sym_emit_DASH_hinted_DASH_impl)
	// var glojure.core/empty?
	var_glojure_DOT_core_empty_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_empty_QMARK_)
	// var glojure.core/ensure-reduced
	var_glojure_DOT_core_ensure_DASH_reduced := lang.InternVarName(sym_glojure_DOT_core, sym_ensure_DASH_reduced)
	// var glojure.core/eval
	var_glojure_DOT_core_eval := lang.InternVarName(sym_glojure_DOT_core, sym_eval)
	// var glojure.core/even?
	var_glojure_DOT_core_even_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_even_QMARK_)
	// var glojure.core/every?
	var_glojure_DOT_core_every_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_every_QMARK_)
	// var glojure.core/ex-data
	var_glojure_DOT_core_ex_DASH_data := lang.InternVarName(sym_glojure_DOT_core, sym_ex_DASH_data)
	// var glojure.core/ex-info
	var_glojure_DOT_core_ex_DASH_info := lang.InternVarName(sym_glojure_DOT_core, sym_ex_DASH_info)
	// var glojure.core/ffirst
	var_glojure_DOT_core_ffirst := lang.InternVarName(sym_glojure_DOT_core, sym_ffirst)
	// var glojure.core/filter
	var_glojure_DOT_core_filter := lang.InternVarName(sym_glojure_DOT_core, sym_filter)
	// var glojure.core/filter-key
	var_glojure_DOT_core_filter_DASH_key := lang.InternVarName(sym_glojure_DOT_core, sym_filter_DASH_key)
	// var glojure.core/find
	var_glojure_DOT_core_find := lang.InternVarName(sym_glojure_DOT_core, sym_find)
	// var glojure.core/find-ns
	var_glojure_DOT_core_find_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_find_DASH_ns)
	// var glojure.core/first
	var_glojure_DOT_core_first := lang.InternVarName(sym_glojure_DOT_core, sym_first)
	// var glojure.core/fits-table?
	var_glojure_DOT_core_fits_DASH_table_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_fits_DASH_table_QMARK_)
	// var glojure.core/flatten
	var_glojure_DOT_core_flatten := lang.InternVarName(sym_glojure_DOT_core, sym_flatten)
	// var glojure.core/float
	var_glojure_DOT_core_float := lang.InternVarName(sym_glojure_DOT_core, sym_float)
	// var glojure.core/float?
	var_glojure_DOT_core_float_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_float_QMARK_)
	// var glojure.core/flush
	var_glojure_DOT_core_flush := lang.InternVarName(sym_glojure_DOT_core, sym_flush)
	// var glojure.core/fn?
	var_glojure_DOT_core_fn_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_fn_QMARK_)
	// var glojure.core/fnil
	var_glojure_DOT_core_fnil := lang.InternVarName(sym_glojure_DOT_core, sym_fnil)
	// var glojure.core/format
	var_glojure_DOT_core_format := lang.InternVarName(sym_glojure_DOT_core, sym_format)
	// var glojure.core/future-call
	var_glojure_DOT_core_future_DASH_call := lang.InternVarName(sym_glojure_DOT_core, sym_future_DASH_call)
	// var glojure.core/gensym
	var_glojure_DOT_core_gensym := lang.InternVarName(sym_glojure_DOT_core, sym_gensym)
	// var glojure.core/get
	var_glojure_DOT_core_get := lang.InternVarName(sym_glojure_DOT_core, sym_get)
	// var glojure.core/get-in
	var_glojure_DOT_core_get_DASH_in := lang.InternVarName(sym_glojure_DOT_core, sym_get_DASH_in)
	// var glojure.core/get-thread-bindings
	var_glojure_DOT_core_get_DASH_thread_DASH_bindings := lang.InternVarName(sym_glojure_DOT_core, sym_get_DASH_thread_DASH_bindings)
	// var glojure.core/global-hierarchy
	var_glojure_DOT_core_global_DASH_hierarchy := lang.InternVarName(sym_glojure_DOT_core, sym_global_DASH_hierarchy)
	// var glojure.core/halt-when
	var_glojure_DOT_core_halt_DASH_when := lang.InternVarName(sym_glojure_DOT_core, sym_halt_DASH_when)
	// var glojure.core/hash-map
	var_glojure_DOT_core_hash_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_hash_DASH_map)
	// var glojure.core/hash-set
	var_glojure_DOT_core_hash_DASH_set := lang.InternVarName(sym_glojure_DOT_core, sym_hash_DASH_set)
	// var glojure.core/ident?
	var_glojure_DOT_core_ident_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_ident_QMARK_)
	// var glojure.core/identical?
	var_glojure_DOT_core_identical_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_identical_QMARK_)
	// var glojure.core/identity
	var_glojure_DOT_core_identity := lang.InternVarName(sym_glojure_DOT_core, sym_identity)
	// var glojure.core/inc
	var_glojure_DOT_core_inc := lang.InternVarName(sym_glojure_DOT_core, sym_inc)
	// var glojure.core/inc'
	var_glojure_DOT_core_inc_TICK_ := lang.InternVarName(sym_glojure_DOT_core, sym_inc_TICK_)
	// var glojure.core/instance?
	var_glojure_DOT_core_instance_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_instance_QMARK_)
	// var glojure.core/int
	var_glojure_DOT_core_int := lang.InternVarName(sym_glojure_DOT_core, sym_int)
	// var glojure.core/int?
	var_glojure_DOT_core_int_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_int_QMARK_)
	// var glojure.core/integer?
	var_glojure_DOT_core_integer_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_integer_QMARK_)
	// var glojure.core/interleave
	var_glojure_DOT_core_interleave := lang.InternVarName(sym_glojure_DOT_core, sym_interleave)
	// var glojure.core/intern
	var_glojure_DOT_core_intern := lang.InternVarName(sym_glojure_DOT_core, sym_intern)
	// var glojure.core/interpose
	var_glojure_DOT_core_interpose := lang.InternVarName(sym_glojure_DOT_core, sym_interpose)
	// var glojure.core/into
	var_glojure_DOT_core_into := lang.InternVarName(sym_glojure_DOT_core, sym_into)
	// var glojure.core/into1
	var_glojure_DOT_core_into1 := lang.InternVarName(sym_glojure_DOT_core, sym_into1)
	// var glojure.core/into-array
	var_glojure_DOT_core_into_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_into_DASH_array)
	// var glojure.core/isa?
	var_glojure_DOT_core_isa_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_isa_QMARK_)
	// var glojure.core/iterate
	var_glojure_DOT_core_iterate := lang.InternVarName(sym_glojure_DOT_core, sym_iterate)
	// var glojure.core/iterator-seq
	var_glojure_DOT_core_iterator_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_iterator_DASH_seq)
	// var glojure.core/keep
	var_glojure_DOT_core_keep := lang.InternVarName(sym_glojure_DOT_core, sym_keep)
	// var glojure.core/key
	var_glojure_DOT_core_key := lang.InternVarName(sym_glojure_DOT_core, sym_key)
	// var glojure.core/keys
	var_glojure_DOT_core_keys := lang.InternVarName(sym_glojure_DOT_core, sym_keys)
	// var glojure.core/keyword
	var_glojure_DOT_core_keyword := lang.InternVarName(sym_glojure_DOT_core, sym_keyword)
	// var glojure.core/keyword?
	var_glojure_DOT_core_keyword_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_keyword_QMARK_)
	// var glojure.core/last
	var_glojure_DOT_core_last := lang.InternVarName(sym_glojure_DOT_core, sym_last)
	// var glojure.core/libspec?
	var_glojure_DOT_core_libspec_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_libspec_QMARK_)
	// var glojure.core/lift-ns
	var_glojure_DOT_core_lift_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_lift_DASH_ns)
	// var glojure.core/line-seq
	var_glojure_DOT_core_line_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_line_DASH_seq)
	// var glojure.core/list
	var_glojure_DOT_core_list := lang.InternVarName(sym_glojure_DOT_core, sym_list)
	// var glojure.core/list*
	var_glojure_DOT_core_list_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym_list_STAR_)
	// var glojure.core/load
	var_glojure_DOT_core_load := lang.InternVarName(sym_glojure_DOT_core, sym_load)
	// var glojure.core/load-all
	var_glojure_DOT_core_load_DASH_all := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_all)
	// var glojure.core/load-data-reader-file
	var_glojure_DOT_core_load_DASH_data_DASH_reader_DASH_file := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_data_DASH_reader_DASH_file)
	// var glojure.core/load-lib
	var_glojure_DOT_core_load_DASH_lib := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_lib)
	// var glojure.core/load-libs
	var_glojure_DOT_core_load_DASH_libs := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_libs)
	// var glojure.core/load-one
	var_glojure_DOT_core_load_DASH_one := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_one)
	// var glojure.core/load-reader
	var_glojure_DOT_core_load_DASH_reader := lang.InternVarName(sym_glojure_DOT_core, sym_load_DASH_reader)
	// var glojure.core/long
	var_glojure_DOT_core_long := lang.InternVarName(sym_glojure_DOT_core, sym_long)
	// var glojure.core/macroexpand
	var_glojure_DOT_core_macroexpand := lang.InternVarName(sym_glojure_DOT_core, sym_macroexpand)
	// var glojure.core/macroexpand-1
	var_glojure_DOT_core_macroexpand_DASH_1 := lang.InternVarName(sym_glojure_DOT_core, sym_macroexpand_DASH_1)
	// var glojure.core/make-array
	var_glojure_DOT_core_make_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_make_DASH_array)
	// var glojure.core/make-hierarchy
	var_glojure_DOT_core_make_DASH_hierarchy := lang.InternVarName(sym_glojure_DOT_core, sym_make_DASH_hierarchy)
	// var glojure.core/map
	var_glojure_DOT_core_map := lang.InternVarName(sym_glojure_DOT_core, sym_map)
	// var glojure.core/map?
	var_glojure_DOT_core_map_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_map_QMARK_)
	// var glojure.core/mapcat
	var_glojure_DOT_core_mapcat := lang.InternVarName(sym_glojure_DOT_core, sym_mapcat)
	// var glojure.core/max
	var_glojure_DOT_core_max := lang.InternVarName(sym_glojure_DOT_core, sym_max)
	// var glojure.core/max-mask-bits
	var_glojure_DOT_core_max_DASH_mask_DASH_bits := lang.InternVarName(sym_glojure_DOT_core, sym_max_DASH_mask_DASH_bits)
	// var glojure.core/max-switch-table-size
	var_glojure_DOT_core_max_DASH_switch_DASH_table_DASH_size := lang.InternVarName(sym_glojure_DOT_core, sym_max_DASH_switch_DASH_table_DASH_size)
	// var glojure.core/maybe-destructured
	var_glojure_DOT_core_maybe_DASH_destructured := lang.InternVarName(sym_glojure_DOT_core, sym_maybe_DASH_destructured)
	// var glojure.core/maybe-min-hash
	var_glojure_DOT_core_maybe_DASH_min_DASH_hash := lang.InternVarName(sym_glojure_DOT_core, sym_maybe_DASH_min_DASH_hash)
	// var glojure.core/merge
	var_glojure_DOT_core_merge := lang.InternVarName(sym_glojure_DOT_core, sym_merge)
	// var glojure.core/merge-hash-collisions
	var_glojure_DOT_core_merge_DASH_hash_DASH_collisions := lang.InternVarName(sym_glojure_DOT_core, sym_merge_DASH_hash_DASH_collisions)
	// var glojure.core/meta
	var_glojure_DOT_core_meta := lang.InternVarName(sym_glojure_DOT_core, sym_meta)
	// var glojure.core/min
	var_glojure_DOT_core_min := lang.InternVarName(sym_glojure_DOT_core, sym_min)
	// var glojure.core/mk-bound-fn
	var_glojure_DOT_core_mk_DASH_bound_DASH_fn := lang.InternVarName(sym_glojure_DOT_core, sym_mk_DASH_bound_DASH_fn)
	// var glojure.core/name
	var_glojure_DOT_core_name := lang.InternVarName(sym_glojure_DOT_core, sym_name)
	// var glojure.core/namespace
	var_glojure_DOT_core_namespace := lang.InternVarName(sym_glojure_DOT_core, sym_namespace)
	// var glojure.core/nary-inline
	var_glojure_DOT_core_nary_DASH_inline := lang.InternVarName(sym_glojure_DOT_core, sym_nary_DASH_inline)
	// var glojure.core/neg?
	var_glojure_DOT_core_neg_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_neg_QMARK_)
	// var glojure.core/newline
	var_glojure_DOT_core_newline := lang.InternVarName(sym_glojure_DOT_core, sym_newline)
	// var glojure.core/next
	var_glojure_DOT_core_next := lang.InternVarName(sym_glojure_DOT_core, sym_next)
	// var glojure.core/nil?
	var_glojure_DOT_core_nil_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_nil_QMARK_)
	// var glojure.core/nnext
	var_glojure_DOT_core_nnext := lang.InternVarName(sym_glojure_DOT_core, sym_nnext)
	// var glojure.core/normalize-slurp-opts
	var_glojure_DOT_core_normalize_DASH_slurp_DASH_opts := lang.InternVarName(sym_glojure_DOT_core, sym_normalize_DASH_slurp_DASH_opts)
	// var glojure.core/not
	var_glojure_DOT_core_not := lang.InternVarName(sym_glojure_DOT_core, sym_not)
	// var glojure.core/not-any?
	var_glojure_DOT_core_not_DASH_any_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_not_DASH_any_QMARK_)
	// var glojure.core/not-empty
	var_glojure_DOT_core_not_DASH_empty := lang.InternVarName(sym_glojure_DOT_core, sym_not_DASH_empty)
	// var glojure.core/not=
	var_glojure_DOT_core_not_EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym_not_EQ_)
	// var glojure.core/ns-map
	var_glojure_DOT_core_ns_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_map)
	// var glojure.core/ns-name
	var_glojure_DOT_core_ns_DASH_name := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_name)
	// var glojure.core/ns-publics
	var_glojure_DOT_core_ns_DASH_publics := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_publics)
	// var glojure.core/ns-resolve
	var_glojure_DOT_core_ns_DASH_resolve := lang.InternVarName(sym_glojure_DOT_core, sym_ns_DASH_resolve)
	// var glojure.core/nth
	var_glojure_DOT_core_nth := lang.InternVarName(sym_glojure_DOT_core, sym_nth)
	// var glojure.core/nthrest
	var_glojure_DOT_core_nthrest := lang.InternVarName(sym_glojure_DOT_core, sym_nthrest)
	// var glojure.core/number?
	var_glojure_DOT_core_number_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_number_QMARK_)
	// var glojure.core/odd?
	var_glojure_DOT_core_odd_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_odd_QMARK_)
	// var glojure.core/parents
	var_glojure_DOT_core_parents := lang.InternVarName(sym_glojure_DOT_core, sym_parents)
	// var glojure.core/parse-impls
	var_glojure_DOT_core_parse_DASH_impls := lang.InternVarName(sym_glojure_DOT_core, sym_parse_DASH_impls)
	// var glojure.core/parsing-err
	var_glojure_DOT_core_parsing_DASH_err := lang.InternVarName(sym_glojure_DOT_core, sym_parsing_DASH_err)
	// var glojure.core/partial
	var_glojure_DOT_core_partial := lang.InternVarName(sym_glojure_DOT_core, sym_partial)
	// var glojure.core/partition
	var_glojure_DOT_core_partition := lang.InternVarName(sym_glojure_DOT_core, sym_partition)
	// var glojure.core/partition-all
	var_glojure_DOT_core_partition_DASH_all := lang.InternVarName(sym_glojure_DOT_core, sym_partition_DASH_all)
	// var glojure.core/partition-by
	var_glojure_DOT_core_partition_DASH_by := lang.InternVarName(sym_glojure_DOT_core, sym_partition_DASH_by)
	// var glojure.core/partitionv
	var_glojure_DOT_core_partitionv := lang.InternVarName(sym_glojure_DOT_core, sym_partitionv)
	// var glojure.core/partitionv-all
	var_glojure_DOT_core_partitionv_DASH_all := lang.InternVarName(sym_glojure_DOT_core, sym_partitionv_DASH_all)
	// var glojure.core/peek
	var_glojure_DOT_core_peek := lang.InternVarName(sym_glojure_DOT_core, sym_peek)
	// var glojure.core/persistent!
	var_glojure_DOT_core_persistent_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_persistent_BANG_)
	// var glojure.core/pmap
	var_glojure_DOT_core_pmap := lang.InternVarName(sym_glojure_DOT_core, sym_pmap)
	// var glojure.core/pop
	var_glojure_DOT_core_pop := lang.InternVarName(sym_glojure_DOT_core, sym_pop)
	// var glojure.core/pop-thread-bindings
	var_glojure_DOT_core_pop_DASH_thread_DASH_bindings := lang.InternVarName(sym_glojure_DOT_core, sym_pop_DASH_thread_DASH_bindings)
	// var glojure.core/pos?
	var_glojure_DOT_core_pos_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_pos_QMARK_)
	// var glojure.core/pr
	var_glojure_DOT_core_pr := lang.InternVarName(sym_glojure_DOT_core, sym_pr)
	// var glojure.core/pr-on
	var_glojure_DOT_core_pr_DASH_on := lang.InternVarName(sym_glojure_DOT_core, sym_pr_DASH_on)
	// var glojure.core/pr-str
	var_glojure_DOT_core_pr_DASH_str := lang.InternVarName(sym_glojure_DOT_core, sym_pr_DASH_str)
	// var glojure.core/prep-hashes
	var_glojure_DOT_core_prep_DASH_hashes := lang.InternVarName(sym_glojure_DOT_core, sym_prep_DASH_hashes)
	// var glojure.core/prep-ints
	var_glojure_DOT_core_prep_DASH_ints := lang.InternVarName(sym_glojure_DOT_core, sym_prep_DASH_ints)
	// var glojure.core/prependss
	var_glojure_DOT_core_prependss := lang.InternVarName(sym_glojure_DOT_core, sym_prependss)
	// var glojure.core/preserving-reduced
	var_glojure_DOT_core_preserving_DASH_reduced := lang.InternVarName(sym_glojure_DOT_core, sym_preserving_DASH_reduced)
	// var glojure.core/print
	var_glojure_DOT_core_print := lang.InternVarName(sym_glojure_DOT_core, sym_print)
	// var glojure.core/print-ctor
	var_glojure_DOT_core_print_DASH_ctor := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_ctor)
	// var glojure.core/print-dup
	var_glojure_DOT_core_print_DASH_dup := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_dup)
	// var glojure.core/print-map
	var_glojure_DOT_core_print_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_map)
	// var glojure.core/print-meta
	var_glojure_DOT_core_print_DASH_meta := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_meta)
	// var glojure.core/print-method
	var_glojure_DOT_core_print_DASH_method := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_method)
	// var glojure.core/print-object
	var_glojure_DOT_core_print_DASH_object := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_object)
	// var glojure.core/print-prefix-map
	var_glojure_DOT_core_print_DASH_prefix_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_prefix_DASH_map)
	// var glojure.core/print-sequential
	var_glojure_DOT_core_print_DASH_sequential := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_sequential)
	// var glojure.core/print-simple
	var_glojure_DOT_core_print_DASH_simple := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_simple)
	// var glojure.core/print-str
	var_glojure_DOT_core_print_DASH_str := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_str)
	// var glojure.core/print-tagged-object
	var_glojure_DOT_core_print_DASH_tagged_DASH_object := lang.InternVarName(sym_glojure_DOT_core, sym_print_DASH_tagged_DASH_object)
	// var glojure.core/printf
	var_glojure_DOT_core_printf := lang.InternVarName(sym_glojure_DOT_core, sym_printf)
	// var glojure.core/println
	var_glojure_DOT_core_println := lang.InternVarName(sym_glojure_DOT_core, sym_println)
	// var glojure.core/prn
	var_glojure_DOT_core_prn := lang.InternVarName(sym_glojure_DOT_core, sym_prn)
	// var glojure.core/protocol?
	var_glojure_DOT_core_protocol_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_protocol_QMARK_)
	// var glojure.core/push-thread-bindings
	var_glojure_DOT_core_push_DASH_thread_DASH_bindings := lang.InternVarName(sym_glojure_DOT_core, sym_push_DASH_thread_DASH_bindings)
	// var glojure.core/qualified-ident?
	var_glojure_DOT_core_qualified_DASH_ident_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_qualified_DASH_ident_QMARK_)
	// var glojure.core/qualified-symbol?
	var_glojure_DOT_core_qualified_DASH_symbol_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_qualified_DASH_symbol_QMARK_)
	// var glojure.core/rand
	var_glojure_DOT_core_rand := lang.InternVarName(sym_glojure_DOT_core, sym_rand)
	// var glojure.core/rand-int
	var_glojure_DOT_core_rand_DASH_int := lang.InternVarName(sym_glojure_DOT_core, sym_rand_DASH_int)
	// var glojure.core/range
	var_glojure_DOT_core_range := lang.InternVarName(sym_glojure_DOT_core, sym_range)
	// var glojure.core/ratio?
	var_glojure_DOT_core_ratio_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_ratio_QMARK_)
	// var glojure.core/re-find
	var_glojure_DOT_core_re_DASH_find := lang.InternVarName(sym_glojure_DOT_core, sym_re_DASH_find)
	// var glojure.core/re-groups
	var_glojure_DOT_core_re_DASH_groups := lang.InternVarName(sym_glojure_DOT_core, sym_re_DASH_groups)
	// var glojure.core/re-matcher
	var_glojure_DOT_core_re_DASH_matcher := lang.InternVarName(sym_glojure_DOT_core, sym_re_DASH_matcher)
	// var glojure.core/read
	var_glojure_DOT_core_read := lang.InternVarName(sym_glojure_DOT_core, sym_read)
	// var glojure.core/read+string
	var_glojure_DOT_core_read_PLUS_string := lang.InternVarName(sym_glojure_DOT_core, sym_read_PLUS_string)
	// var glojure.core/reduce
	var_glojure_DOT_core_reduce := lang.InternVarName(sym_glojure_DOT_core, sym_reduce)
	// var glojure.core/reduce1
	var_glojure_DOT_core_reduce1 := lang.InternVarName(sym_glojure_DOT_core, sym_reduce1)
	// var glojure.core/reduce-kv
	var_glojure_DOT_core_reduce_DASH_kv := lang.InternVarName(sym_glojure_DOT_core, sym_reduce_DASH_kv)
	// var glojure.core/reduced
	var_glojure_DOT_core_reduced := lang.InternVarName(sym_glojure_DOT_core, sym_reduced)
	// var glojure.core/reduced?
	var_glojure_DOT_core_reduced_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_reduced_QMARK_)
	// var glojure.core/reductions
	var_glojure_DOT_core_reductions := lang.InternVarName(sym_glojure_DOT_core, sym_reductions)
	// var glojure.core/ref
	var_glojure_DOT_core_ref := lang.InternVarName(sym_glojure_DOT_core, sym_ref)
	// var glojure.core/refer
	var_glojure_DOT_core_refer := lang.InternVarName(sym_glojure_DOT_core, sym_refer)
	// var glojure.core/release-pending-sends
	var_glojure_DOT_core_release_DASH_pending_DASH_sends := lang.InternVarName(sym_glojure_DOT_core, sym_release_DASH_pending_DASH_sends)
	// var glojure.core/rem
	var_glojure_DOT_core_rem := lang.InternVarName(sym_glojure_DOT_core, sym_rem)
	// var glojure.core/remove
	var_glojure_DOT_core_remove := lang.InternVarName(sym_glojure_DOT_core, sym_remove)
	// var glojure.core/remove-ns
	var_glojure_DOT_core_remove_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_remove_DASH_ns)
	// var glojure.core/repeat
	var_glojure_DOT_core_repeat := lang.InternVarName(sym_glojure_DOT_core, sym_repeat)
	// var glojure.core/repeatedly
	var_glojure_DOT_core_repeatedly := lang.InternVarName(sym_glojure_DOT_core, sym_repeatedly)
	// var glojure.core/require
	var_glojure_DOT_core_require := lang.InternVarName(sym_glojure_DOT_core, sym_require)
	// var glojure.core/resolve
	var_glojure_DOT_core_resolve := lang.InternVarName(sym_glojure_DOT_core, sym_resolve)
	// var glojure.core/rest
	var_glojure_DOT_core_rest := lang.InternVarName(sym_glojure_DOT_core, sym_rest)
	// var glojure.core/restart-agent
	var_glojure_DOT_core_restart_DASH_agent := lang.InternVarName(sym_glojure_DOT_core, sym_restart_DASH_agent)
	// var glojure.core/root-directory
	var_glojure_DOT_core_root_DASH_directory := lang.InternVarName(sym_glojure_DOT_core, sym_root_DASH_directory)
	// var glojure.core/root-resource
	var_glojure_DOT_core_root_DASH_resource := lang.InternVarName(sym_glojure_DOT_core, sym_root_DASH_resource)
	// var glojure.core/second
	var_glojure_DOT_core_second := lang.InternVarName(sym_glojure_DOT_core, sym_second)
	// var glojure.core/select-keys
	var_glojure_DOT_core_select_DASH_keys := lang.InternVarName(sym_glojure_DOT_core, sym_select_DASH_keys)
	// var glojure.core/send
	var_glojure_DOT_core_send := lang.InternVarName(sym_glojure_DOT_core, sym_send)
	// var glojure.core/send-off
	var_glojure_DOT_core_send_DASH_off := lang.InternVarName(sym_glojure_DOT_core, sym_send_DASH_off)
	// var glojure.core/send-via
	var_glojure_DOT_core_send_DASH_via := lang.InternVarName(sym_glojure_DOT_core, sym_send_DASH_via)
	// var glojure.core/seq
	var_glojure_DOT_core_seq := lang.InternVarName(sym_glojure_DOT_core, sym_seq)
	// var glojure.core/seq?
	var_glojure_DOT_core_seq_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_seq_QMARK_)
	// var glojure.core/seque
	var_glojure_DOT_core_seque := lang.InternVarName(sym_glojure_DOT_core, sym_seque)
	// var glojure.core/sequence
	var_glojure_DOT_core_sequence := lang.InternVarName(sym_glojure_DOT_core, sym_sequence)
	// var glojure.core/sequential?
	var_glojure_DOT_core_sequential_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_sequential_QMARK_)
	// var glojure.core/serialized-require
	var_glojure_DOT_core_serialized_DASH_require := lang.InternVarName(sym_glojure_DOT_core, sym_serialized_DASH_require)
	// var glojure.core/set
	var_glojure_DOT_core_set := lang.InternVarName(sym_glojure_DOT_core, sym_set)
	// var glojure.core/set?
	var_glojure_DOT_core_set_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_set_QMARK_)
	// var glojure.core/setup-reference
	var_glojure_DOT_core_setup_DASH_reference := lang.InternVarName(sym_glojure_DOT_core, sym_setup_DASH_reference)
	// var glojure.core/shift-mask
	var_glojure_DOT_core_shift_DASH_mask := lang.InternVarName(sym_glojure_DOT_core, sym_shift_DASH_mask)
	// var glojure.core/short
	var_glojure_DOT_core_short := lang.InternVarName(sym_glojure_DOT_core, sym_short)
	// var glojure.core/sigs
	var_glojure_DOT_core_sigs := lang.InternVarName(sym_glojure_DOT_core, sym_sigs)
	// var glojure.core/some
	var_glojure_DOT_core_some := lang.InternVarName(sym_glojure_DOT_core, sym_some)
	// var glojure.core/some?
	var_glojure_DOT_core_some_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_some_QMARK_)
	// var glojure.core/sort
	var_glojure_DOT_core_sort := lang.InternVarName(sym_glojure_DOT_core, sym_sort)
	// var glojure.core/sort-by
	var_glojure_DOT_core_sort_DASH_by := lang.InternVarName(sym_glojure_DOT_core, sym_sort_DASH_by)
	// var glojure.core/sorted-map
	var_glojure_DOT_core_sorted_DASH_map := lang.InternVarName(sym_glojure_DOT_core, sym_sorted_DASH_map)
	// var glojure.core/sorted-set
	var_glojure_DOT_core_sorted_DASH_set := lang.InternVarName(sym_glojure_DOT_core, sym_sorted_DASH_set)
	// var glojure.core/split-at
	var_glojure_DOT_core_split_DASH_at := lang.InternVarName(sym_glojure_DOT_core, sym_split_DASH_at)
	// var glojure.core/split-with
	var_glojure_DOT_core_split_DASH_with := lang.InternVarName(sym_glojure_DOT_core, sym_split_DASH_with)
	// var glojure.core/spread
	var_glojure_DOT_core_spread := lang.InternVarName(sym_glojure_DOT_core, sym_spread)
	// var glojure.core/str
	var_glojure_DOT_core_str := lang.InternVarName(sym_glojure_DOT_core, sym_str)
	// var glojure.core/stream-reduce!
	var_glojure_DOT_core_stream_DASH_reduce_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_stream_DASH_reduce_BANG_)
	// var glojure.core/stream-transduce!
	var_glojure_DOT_core_stream_DASH_transduce_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_stream_DASH_transduce_BANG_)
	// var glojure.core/string?
	var_glojure_DOT_core_string_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_string_QMARK_)
	// var glojure.core/strip-ns
	var_glojure_DOT_core_strip_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_strip_DASH_ns)
	// var glojure.core/struct
	var_glojure_DOT_core_struct := lang.InternVarName(sym_glojure_DOT_core, sym_struct)
	// var glojure.core/subs
	var_glojure_DOT_core_subs := lang.InternVarName(sym_glojure_DOT_core, sym_subs)
	// var glojure.core/subvec
	var_glojure_DOT_core_subvec := lang.InternVarName(sym_glojure_DOT_core, sym_subvec)
	// var glojure.core/supers
	var_glojure_DOT_core_supers := lang.InternVarName(sym_glojure_DOT_core, sym_supers)
	// var glojure.core/swap!
	var_glojure_DOT_core_swap_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_swap_BANG_)
	// var glojure.core/symbol
	var_glojure_DOT_core_symbol := lang.InternVarName(sym_glojure_DOT_core, sym_symbol)
	// var glojure.core/symbol?
	var_glojure_DOT_core_symbol_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_symbol_QMARK_)
	// var glojure.core/system-newline
	var_glojure_DOT_core_system_DASH_newline := lang.InternVarName(sym_glojure_DOT_core, sym_system_DASH_newline)
	// var glojure.core/take
	var_glojure_DOT_core_take := lang.InternVarName(sym_glojure_DOT_core, sym_take)
	// var glojure.core/take-nth
	var_glojure_DOT_core_take_DASH_nth := lang.InternVarName(sym_glojure_DOT_core, sym_take_DASH_nth)
	// var glojure.core/take-while
	var_glojure_DOT_core_take_DASH_while := lang.InternVarName(sym_glojure_DOT_core, sym_take_DASH_while)
	// var glojure.core/tapset
	var_glojure_DOT_core_tapset := lang.InternVarName(sym_glojure_DOT_core, sym_tapset)
	// var glojure.core/the-ns
	var_glojure_DOT_core_the_DASH_ns := lang.InternVarName(sym_glojure_DOT_core, sym_the_DASH_ns)
	// var glojure.core/throw-if
	var_glojure_DOT_core_throw_DASH_if := lang.InternVarName(sym_glojure_DOT_core, sym_throw_DASH_if)
	// var glojure.core/to-array
	var_glojure_DOT_core_to_DASH_array := lang.InternVarName(sym_glojure_DOT_core, sym_to_DASH_array)
	// var glojure.core/trampoline
	var_glojure_DOT_core_trampoline := lang.InternVarName(sym_glojure_DOT_core, sym_trampoline)
	// var glojure.core/transduce
	var_glojure_DOT_core_transduce := lang.InternVarName(sym_glojure_DOT_core, sym_transduce)
	// var glojure.core/transient
	var_glojure_DOT_core_transient := lang.InternVarName(sym_glojure_DOT_core, sym_transient)
	// var glojure.core/tree-seq
	var_glojure_DOT_core_tree_DASH_seq := lang.InternVarName(sym_glojure_DOT_core, sym_tree_DASH_seq)
	// var glojure.core/unchecked-inc
	var_glojure_DOT_core_unchecked_DASH_inc := lang.InternVarName(sym_glojure_DOT_core, sym_unchecked_DASH_inc)
	// var glojure.core/underive
	var_glojure_DOT_core_underive := lang.InternVarName(sym_glojure_DOT_core, sym_underive)
	// var glojure.core/unreduced
	var_glojure_DOT_core_unreduced := lang.InternVarName(sym_glojure_DOT_core, sym_unreduced)
	// var glojure.core/update
	var_glojure_DOT_core_update := lang.InternVarName(sym_glojure_DOT_core, sym_update)
	// var glojure.core/val
	var_glojure_DOT_core_val := lang.InternVarName(sym_glojure_DOT_core, sym_val)
	// var glojure.core/vals
	var_glojure_DOT_core_vals := lang.InternVarName(sym_glojure_DOT_core, sym_vals)
	// var glojure.core/vary-meta
	var_glojure_DOT_core_vary_DASH_meta := lang.InternVarName(sym_glojure_DOT_core, sym_vary_DASH_meta)
	// var glojure.core/vec
	var_glojure_DOT_core_vec := lang.InternVarName(sym_glojure_DOT_core, sym_vec)
	// var glojure.core/vector
	var_glojure_DOT_core_vector := lang.InternVarName(sym_glojure_DOT_core, sym_vector)
	// var glojure.core/vector?
	var_glojure_DOT_core_vector_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_vector_QMARK_)
	// var glojure.core/volatile!
	var_glojure_DOT_core_volatile_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_volatile_BANG_)
	// var glojure.core/vreset!
	var_glojure_DOT_core_vreset_BANG_ := lang.InternVarName(sym_glojure_DOT_core, sym_vreset_BANG_)
	// var glojure.core/with-bindings*
	var_glojure_DOT_core_with_DASH_bindings_STAR_ := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_bindings_STAR_)
	// var glojure.core/with-meta
	var_glojure_DOT_core_with_DASH_meta := lang.InternVarName(sym_glojure_DOT_core, sym_with_DASH_meta)
	// var glojure.core/zero?
	var_glojure_DOT_core_zero_QMARK_ := lang.InternVarName(sym_glojure_DOT_core, sym_zero_QMARK_)
	// var glojure.core/zipmap
	var_glojure_DOT_core_zipmap := lang.InternVarName(sym_glojure_DOT_core, sym_zipmap)
	// var glojure.go.io/copy
	var_glojure_DOT_go_DOT_io_copy := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_copy)
	// var glojure.go.io/make-input-stream
	var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_make_DASH_input_DASH_stream)
	// var glojure.go.io/make-output-stream
	var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_make_DASH_output_DASH_stream)
	// var glojure.go.io/make-writer
	var_glojure_DOT_go_DOT_io_make_DASH_writer := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_make_DASH_writer)
	// var glojure.go.io/reader
	var_glojure_DOT_go_DOT_io_reader := lang.InternVarName(sym_glojure_DOT_go_DOT_io, sym_reader)
	// //////////////////////////////////////////////////////////////////////////////// Closed-over values
	var closed0 any
	{
		closed0 = sym_unchecked_multiply
	}
	var closed1 any
	{
		closed1 = sym_multiply
	}
	var closed10 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3, _ := lang.FieldOrMethod(v1, "Reduce")
				if reflect.TypeOf(tmp3).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Reduce is not a function")))
				}
				tmp4 := lang.Apply(tmp3, []any{v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4, _ := lang.FieldOrMethod(v1, "ReduceInit")
				if reflect.TypeOf(tmp4).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
				}
				tmp5 := lang.Apply(tmp4, []any{v2, v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed10 = tmp0
	}
	var closed11 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp4 := lang.Apply(tmp3, []any{v1, v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp5 := lang.Apply(tmp4, []any{v1, v2, v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed11 = tmp0
	}
	var closed12 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp4 := lang.Apply(tmp3, []any{v1, v2})
				return tmp4
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_seq_DASH_reduce)
				tmp5 := lang.Apply(tmp4, []any{v1, v2, v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed12 = tmp0
	}
	var closed13 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
			return v3
		})
		closed13 = tmp0
	}
	var closed14 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
		recur_loop_1275:
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := lang.Apply(tmp5, []any{v1})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "s"
						var v10 any = v7
						_ = v10
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v10})
						if lang.IsTruthy(tmp13) {
							var tmp14 any
							{ // let
								// let binding "ret"
								tmp15 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
								tmp16 := lang.Apply(tmp15, []any{v10})
								tmp17, _ := lang.FieldOrMethod(tmp16, "ReduceInit")
								if reflect.TypeOf(tmp17).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
								}
								tmp18 := lang.Apply(tmp17, []any{v2, v3})
								var v19 any = tmp18
								_ = v19
								var tmp20 any
								tmp21 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
								tmp22 := lang.Apply(tmp21, []any{v19})
								if lang.IsTruthy(tmp22) {
									tmp23 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp24 := lang.Apply(tmp23, []any{v19})
									tmp20 = tmp24
								} else {
									tmp26 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_next)
									tmp27 := lang.Apply(tmp26, []any{v10})
									var tmp25 any = tmp27
									var tmp28 any = v2
									var tmp29 any = v19
									v1 = tmp25
									v2 = tmp28
									v3 = tmp29
									goto recur_loop_1275
								}
								tmp14 = tmp20
							} // end let
							tmp11 = tmp14
						} else {
							tmp15 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_interface_DASH_or_DASH_naive_DASH_reduce)
							tmp16 := lang.Apply(tmp15, []any{v10, v2, v3})
							tmp11 = tmp16
						}
						tmp9 = tmp11
					} // end let
					tmp8 = tmp9
				} else {
					tmp8 = v3
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		closed14 = tmp0
	}
	var closed15 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			v3 := args[2]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "cls"
				tmp5 := checkDerefVar(var_glojure_DOT_core_class)
				tmp6 := lang.Apply(tmp5, []any{v1})
				var v7 any = tmp6
				_ = v7
				// let binding "s"
				var v8 any = v1
				_ = v8
				// let binding "f"
				var v9 any = v2
				_ = v9
				// let binding "val"
				var v10 any = v3
				_ = v10
				for {
					var tmp11 any
					{ // let
						// let binding "temp__0__auto__"
						tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp13 := lang.Apply(tmp12, []any{v8})
						var v14 any = tmp13
						_ = v14
						var tmp15 any
						if lang.IsTruthy(v14) {
							var tmp16 any
							{ // let
								// let binding "s"
								var v17 any = v14
								_ = v17
								var tmp18 any
								tmp19 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
								tmp20 := checkDerefVar(var_glojure_DOT_core_class)
								tmp21 := lang.Apply(tmp20, []any{v17})
								tmp22 := lang.Apply(tmp19, []any{tmp21, v7})
								if lang.IsTruthy(tmp22) {
									var tmp23 any
									{ // let
										// let binding "ret"
										tmp24 := checkDerefVar(var_glojure_DOT_core_first)
										tmp25 := lang.Apply(tmp24, []any{v17})
										tmp26 := lang.Apply(v9, []any{v10, tmp25})
										var v27 any = tmp26
										_ = v27
										var tmp28 any
										tmp29 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
										tmp30 := lang.Apply(tmp29, []any{v27})
										if lang.IsTruthy(tmp30) {
											tmp31 := checkDerefVar(var_glojure_DOT_core_deref)
											tmp32 := lang.Apply(tmp31, []any{v27})
											tmp28 = tmp32
										} else {
											var tmp33 any = v7
											tmp35 := checkDerefVar(var_glojure_DOT_core_next)
											tmp36 := lang.Apply(tmp35, []any{v17})
											var tmp34 any = tmp36
											var tmp37 any = v9
											var tmp38 any = v27
											v7 = tmp33
											v8 = tmp34
											v9 = tmp37
											v10 = tmp38
											continue
										}
										tmp23 = tmp28
									} // end let
									tmp18 = tmp23
								} else {
									tmp24 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_interface_DASH_or_DASH_naive_DASH_reduce)
									tmp25 := lang.Apply(tmp24, []any{v17, v9, v10})
									tmp18 = tmp25
								}
								tmp16 = tmp18
							} // end let
							tmp15 = tmp16
						} else {
							tmp15 = v10
						}
						tmp11 = tmp15
					} // end let
					tmp4 = tmp11
					break
				}
			} // end let
			return tmp4
		})
		closed15 = tmp0
	}
	var closed16 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			return nil
		})
		closed16 = tmp0
	}
	var closed17 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(188), kw_column, int(18), kw_end_DASH_line, int(188), kw_end_DASH_column, int(32))).(lang.FnFunc)
		closed17 = tmp0
	}
	var closed18 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
			tmp4 := lang.Apply(tmp3, []any{v1, v2})
			return tmp4
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(167), kw_column, int(17), kw_end_DASH_line, int(167), kw_end_DASH_column, int(56))).(lang.FnFunc)
		closed18 = tmp0
	}
	var closed19 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_writer)
			tmp4 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
			tmp5 := lang.Apply(tmp4, []any{v1, v2})
			tmp6 := lang.Apply(tmp3, []any{tmp5, v2})
			return tmp6
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(168), kw_column, int(17), kw_end_DASH_line, int(168), kw_end_DASH_column, int(76))).(lang.FnFunc)
		closed19 = tmp0
	}
	var closed2 any
	{
		closed2 = sym_multiplyP
	}
	var closed20 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(187), kw_column, int(24), kw_end_DASH_line, int(187), kw_end_DASH_column, int(38))).(lang.FnFunc)
		closed20 = tmp0
	}
	var closed21 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(226), kw_column, int(24), kw_end_DASH_line, int(226), kw_end_DASH_column, int(48))).(lang.FnFunc)
		closed21 = tmp0
	}
	var closed22 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core__EQ_)
			tmp6, ok := lang.FieldOrMethod(v1, "scheme")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "scheme")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			tmp8 := lang.Apply(tmp5, []any{"file", tmp7})
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.Apply(nil, []any{v1})
				tmp4 = tmp9
			} else {
				var tmp10 any
				{ // let
					// let binding "req"
					var tmp11 any
					{ // let
						// let binding "res__0__auto__"
						tmp12, ok := lang.FieldOrMethod(v1, "String")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "String")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						tmp14 := lang.Apply(http17.NewRequest, []any{http17.MethodGet, tmp13, nil})
						var v15 any = tmp14
						_ = v15
						// let binding "vec__295"
						var tmp16 any
						tmp17 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
						tmp18 := lang.Apply(tmp17, []any{v15})
						if lang.IsTruthy(tmp18) {
							tmp19 := checkDerefVar(var_glojure_DOT_core_pop)
							tmp20 := lang.Apply(tmp19, []any{v15})
							tmp21 := checkDerefVar(var_glojure_DOT_core_last)
							tmp22 := lang.Apply(tmp21, []any{v15})
							tmp23 := lang.NewVector(tmp20, tmp22)
							tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 = tmp25
						} else {
							tmp26 := lang.NewVector(nil, v15)
							tmp27 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 = tmp28
						}
						var v29 any = tmp16
						_ = v29
						// let binding "vec__298"
						tmp30 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp31 := lang.Apply(tmp30, []any{v29, int64(0), nil})
						var v32 any = tmp31
						_ = v32
						// let binding "seq__299"
						tmp33 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp34 := lang.Apply(tmp33, []any{v32})
						var v35 any = tmp34
						_ = v35
						// let binding "first__300"
						tmp36 := checkDerefVar(var_glojure_DOT_core_first)
						tmp37 := lang.Apply(tmp36, []any{v35})
						var v38 any = tmp37
						_ = v38
						// let binding "seq__299"
						tmp39 := checkDerefVar(var_glojure_DOT_core_next)
						tmp40 := lang.Apply(tmp39, []any{v35})
						var v41 any = tmp40
						_ = v41
						// let binding "fst__1__auto__"
						var v42 any = v38
						_ = v42
						// let binding "rst__2__auto__"
						var v43 any = v41
						_ = v43
						// let binding "res__0__auto__"
						var v44 any = v32
						_ = v44
						// let binding "err__3__auto__"
						tmp45 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp46 := lang.Apply(tmp45, []any{v29, int64(1), nil})
						var v47 any = tmp46
						_ = v47
						// let binding "res__0__auto__"
						var tmp48 any
						tmp49 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
						tmp50 := lang.Apply(tmp49, []any{v43})
						if lang.IsTruthy(tmp50) {
							tmp48 = v44
						} else {
							tmp48 = v42
						}
						var v51 any = tmp48
						_ = v51
						var tmp52 any
						if lang.IsTruthy(v47) {
							panic(v47)
						} else {
						}
						_ = tmp52
						tmp11 = v51
					} // end let
					var v12 any = tmp11
					_ = v12
					// let binding "res"
					var tmp13 any
					{ // let
						// let binding "res__0__auto__"
						tmp14, _ := lang.FieldOrMethod(http17.DefaultClient, "Do")
						if reflect.TypeOf(tmp14).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("Do is not a function")))
						}
						tmp15 := lang.Apply(tmp14, []any{v12})
						var v16 any = tmp15
						_ = v16
						// let binding "vec__301"
						var tmp17 any
						tmp18 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v16})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(var_glojure_DOT_core_pop)
							tmp21 := lang.Apply(tmp20, []any{v16})
							tmp22 := checkDerefVar(var_glojure_DOT_core_last)
							tmp23 := lang.Apply(tmp22, []any{v16})
							tmp24 := lang.NewVector(tmp21, tmp23)
							tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp26
						} else {
							tmp27 := lang.NewVector(nil, v16)
							tmp28 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp29
						}
						var v30 any = tmp17
						_ = v30
						// let binding "vec__304"
						tmp31 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp32 := lang.Apply(tmp31, []any{v30, int64(0), nil})
						var v33 any = tmp32
						_ = v33
						// let binding "seq__305"
						tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp35 := lang.Apply(tmp34, []any{v33})
						var v36 any = tmp35
						_ = v36
						// let binding "first__306"
						tmp37 := checkDerefVar(var_glojure_DOT_core_first)
						tmp38 := lang.Apply(tmp37, []any{v36})
						var v39 any = tmp38
						_ = v39
						// let binding "seq__305"
						tmp40 := checkDerefVar(var_glojure_DOT_core_next)
						tmp41 := lang.Apply(tmp40, []any{v36})
						var v42 any = tmp41
						_ = v42
						// let binding "fst__1__auto__"
						var v43 any = v39
						_ = v43
						// let binding "rst__2__auto__"
						var v44 any = v42
						_ = v44
						// let binding "res__0__auto__"
						var v45 any = v33
						_ = v45
						// let binding "err__3__auto__"
						tmp46 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp47 := lang.Apply(tmp46, []any{v30, int64(1), nil})
						var v48 any = tmp47
						_ = v48
						// let binding "res__0__auto__"
						var tmp49 any
						tmp50 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
						tmp51 := lang.Apply(tmp50, []any{v44})
						if lang.IsTruthy(tmp51) {
							tmp49 = v45
						} else {
							tmp49 = v43
						}
						var v52 any = tmp49
						_ = v52
						var tmp53 any
						if lang.IsTruthy(v48) {
							panic(v48)
						} else {
						}
						_ = tmp53
						tmp13 = v52
					} // end let
					var v14 any = tmp13
					_ = v14
					// let binding "status"
					tmp15, ok := lang.FieldOrMethod(v14, "StatusCode")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "StatusCode")))
					}
					var tmp16 any
					switch reflect.TypeOf(tmp15).Kind() {
					case reflect.Func:
						tmp16 = lang.Apply(tmp15, nil)
					default:
						tmp16 = tmp15
					}
					var v17 any = tmp16
					_ = v17
					// let binding "body"
					tmp18, ok := lang.FieldOrMethod(v14, "Body")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "Body")))
					}
					var tmp19 any
					switch reflect.TypeOf(tmp18).Kind() {
					case reflect.Func:
						tmp19 = lang.Apply(tmp18, nil)
					default:
						tmp19 = tmp18
					}
					var v20 any = tmp19
					_ = v20
					var tmp21 any
					tmp22 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
					tmp23 := lang.Apply(tmp22, []any{int64(200), v17})
					if lang.IsTruthy(tmp23) {
						tmp24, ok := lang.FieldOrMethod(v20, "Close")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v20, "Close")))
						}
						var tmp25 any
						switch reflect.TypeOf(tmp24).Kind() {
						case reflect.Func:
							tmp25 = lang.Apply(tmp24, nil)
						default:
							tmp25 = tmp24
						}
						_ = tmp25
						tmp26 := lang.Apply(fmt.Errorf, []any{"http error: %s", v17})
						panic(tmp26)
					} else {
					}
					_ = tmp21
					tmp10 = v20
				} // end let
				tmp4 = tmp10
			}
			tmp11 := lang.Apply(tmp3, []any{tmp4, v2})
			return tmp11
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(232), kw_column, int(24), kw_end_DASH_line, int(244), kw_end_DASH_column, int(32))).(lang.FnFunc)
		closed22 = tmp0
	}
	var closed23 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			{ // let
				// let binding "vec__307"
				tmp4 := lang.Apply(url5.ParseRequestURI, []any{v1})
				var v5 any = tmp4
				_ = v5
				// let binding "url"
				tmp6 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp7 := lang.Apply(tmp6, []any{v5, int64(0), nil})
				var v8 any = tmp7
				_ = v8
				// let binding "err"
				tmp9 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp10 := lang.Apply(tmp9, []any{v5, int64(1), nil})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				if lang.IsTruthy(v11) {
					tmp13 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
					var tmp14 any
					{ // let
						// let binding "res__0__auto__"
						tmp15 := lang.Apply(os6.Open, []any{v1})
						var v16 any = tmp15
						_ = v16
						// let binding "vec__310"
						var tmp17 any
						tmp18 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v16})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(var_glojure_DOT_core_pop)
							tmp21 := lang.Apply(tmp20, []any{v16})
							tmp22 := checkDerefVar(var_glojure_DOT_core_last)
							tmp23 := lang.Apply(tmp22, []any{v16})
							tmp24 := lang.NewVector(tmp21, tmp23)
							tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp26
						} else {
							tmp27 := lang.NewVector(nil, v16)
							tmp28 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
							tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 = tmp29
						}
						var v30 any = tmp17
						_ = v30
						// let binding "vec__313"
						tmp31 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp32 := lang.Apply(tmp31, []any{v30, int64(0), nil})
						var v33 any = tmp32
						_ = v33
						// let binding "seq__314"
						tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp35 := lang.Apply(tmp34, []any{v33})
						var v36 any = tmp35
						_ = v36
						// let binding "first__315"
						tmp37 := checkDerefVar(var_glojure_DOT_core_first)
						tmp38 := lang.Apply(tmp37, []any{v36})
						var v39 any = tmp38
						_ = v39
						// let binding "seq__314"
						tmp40 := checkDerefVar(var_glojure_DOT_core_next)
						tmp41 := lang.Apply(tmp40, []any{v36})
						var v42 any = tmp41
						_ = v42
						// let binding "fst__1__auto__"
						var v43 any = v39
						_ = v43
						// let binding "rst__2__auto__"
						var v44 any = v42
						_ = v44
						// let binding "res__0__auto__"
						var v45 any = v33
						_ = v45
						// let binding "err__3__auto__"
						tmp46 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp47 := lang.Apply(tmp46, []any{v30, int64(1), nil})
						var v48 any = tmp47
						_ = v48
						// let binding "res__0__auto__"
						var tmp49 any
						tmp50 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
						tmp51 := lang.Apply(tmp50, []any{v44})
						if lang.IsTruthy(tmp51) {
							tmp49 = v45
						} else {
							tmp49 = v43
						}
						var v52 any = tmp49
						_ = v52
						var tmp53 any
						if lang.IsTruthy(v48) {
							panic(v48)
						} else {
						}
						_ = tmp53
						tmp14 = v52
					} // end let
					tmp15 := lang.Apply(tmp13, []any{tmp14, v2})
					tmp12 = tmp15
				} else {
					tmp16 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_input_DASH_stream)
					tmp17 := lang.Apply(tmp16, []any{v8, v2})
					tmp12 = tmp17
				}
				tmp3 = tmp12
			} // end let
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(259), kw_column, int(24), kw_end_DASH_line, int(263), kw_end_DASH_column, int(60))).(lang.FnFunc)
		closed23 = tmp0
	}
	var closed24 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			tmp3 := checkDerefVar(var_glojure_DOT_core_str)
			tmp4 := checkDerefVar(var_glojure_DOT_core_pr_DASH_str)
			tmp5 := lang.Apply(tmp4, []any{v1})
			tmp6 := lang.Apply(tmp3, []any{"Cannot open <", tmp5, "> as an OutputStream."})
			tmp7 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp6})
			panic(tmp7)
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(172), kw_column, int(24), kw_end_DASH_line, int(174), kw_end_DASH_column, int(92))).(lang.FnFunc)
		closed24 = tmp0
	}
	var closed25 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			return v1
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(227), kw_column, int(25), kw_end_DASH_line, int(227), kw_end_DASH_column, int(49))).(lang.FnFunc)
		closed25 = tmp0
	}
	var closed26 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core__EQ_)
			tmp5, ok := lang.FieldOrMethod(v1, "scheme")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v1, "scheme")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{"file", tmp6})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
				tmp9 := lang.Apply(nil, []any{v1})
				tmp10 := lang.Apply(tmp8, []any{tmp9, v2})
				tmp3 = tmp10
			} else {
				tmp11 := checkDerefVar(var_glojure_DOT_core_str)
				tmp12 := lang.Apply(tmp11, []any{"Can not write to non-file URL <", v1, ">"})
				tmp13 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp12})
				panic(tmp13)
			}
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(245), kw_column, int(25), kw_end_DASH_line, int(248), kw_end_DASH_column, int(149))).(lang.FnFunc)
		closed26 = tmp0
	}
	var closed27 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
			var tmp3 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						if lang.CatchMatches(r, lang.Builtins["any"]) {
							v4 := r
							_ = v4
							tmp5 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
							var tmp6 any
							{ // let
								// let binding "res__0__auto__"
								tmp7 := lang.Apply(os6.Open, []any{v1})
								tmp8 := lang.Apply(tmp7, nil)
								var v9 any = tmp8
								_ = v9
								// let binding "vec__322"
								var tmp10 any
								tmp11 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
								tmp12 := lang.Apply(tmp11, []any{v9})
								if lang.IsTruthy(tmp12) {
									tmp13 := checkDerefVar(var_glojure_DOT_core_pop)
									tmp14 := lang.Apply(tmp13, []any{v9})
									tmp15 := checkDerefVar(var_glojure_DOT_core_last)
									tmp16 := lang.Apply(tmp15, []any{v9})
									tmp17 := lang.NewVector(tmp14, tmp16)
									tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
									tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp10 = tmp19
								} else {
									tmp20 := lang.NewVector(nil, v9)
									tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
									tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp10 = tmp22
								}
								var v23 any = tmp10
								_ = v23
								// let binding "vec__325"
								tmp24 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp25 := lang.Apply(tmp24, []any{v23, int64(0), nil})
								var v26 any = tmp25
								_ = v26
								// let binding "seq__326"
								tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp28 := lang.Apply(tmp27, []any{v26})
								var v29 any = tmp28
								_ = v29
								// let binding "first__327"
								tmp30 := checkDerefVar(var_glojure_DOT_core_first)
								tmp31 := lang.Apply(tmp30, []any{v29})
								var v32 any = tmp31
								_ = v32
								// let binding "seq__326"
								tmp33 := checkDerefVar(var_glojure_DOT_core_next)
								tmp34 := lang.Apply(tmp33, []any{v29})
								var v35 any = tmp34
								_ = v35
								// let binding "fst__1__auto__"
								var v36 any = v32
								_ = v36
								// let binding "rst__2__auto__"
								var v37 any = v35
								_ = v37
								// let binding "res__0__auto__"
								var v38 any = v26
								_ = v38
								// let binding "err__3__auto__"
								tmp39 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp40 := lang.Apply(tmp39, []any{v23, int64(1), nil})
								var v41 any = tmp40
								_ = v41
								// let binding "res__0__auto__"
								var tmp42 any
								tmp43 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
								tmp44 := lang.Apply(tmp43, []any{v37})
								if lang.IsTruthy(tmp44) {
									tmp42 = v38
								} else {
									tmp42 = v36
								}
								var v45 any = tmp42
								_ = v45
								var tmp46 any
								if lang.IsTruthy(v41) {
									panic(v41)
								} else {
								}
								_ = tmp46
								tmp6 = v45
							} // end let
							tmp7 := lang.Apply(tmp5, []any{tmp6, v2})
							tmp3 = tmp7
						} else {
							panic(r)
						}
					}
				}()
				tmp4 := checkDerefVar(var_glojure_DOT_go_DOT_io_make_DASH_output_DASH_stream)
				var tmp5 any
				{ // let
					// let binding "res__0__auto__"
					tmp6 := lang.Apply(url5.Parse, []any{v1})
					tmp7 := lang.Apply(tmp6, nil)
					var v8 any = tmp7
					_ = v8
					// let binding "vec__316"
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
					tmp11 := lang.Apply(tmp10, []any{v8})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_pop)
						tmp13 := lang.Apply(tmp12, []any{v8})
						tmp14 := checkDerefVar(var_glojure_DOT_core_last)
						tmp15 := lang.Apply(tmp14, []any{v8})
						tmp16 := lang.NewVector(tmp13, tmp15)
						tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
						tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp18
					} else {
						tmp19 := lang.NewVector(nil, v8)
						tmp20 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
						tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp21
					}
					var v22 any = tmp9
					_ = v22
					// let binding "vec__319"
					tmp23 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp24 := lang.Apply(tmp23, []any{v22, int64(0), nil})
					var v25 any = tmp24
					_ = v25
					// let binding "seq__320"
					tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp27 := lang.Apply(tmp26, []any{v25})
					var v28 any = tmp27
					_ = v28
					// let binding "first__321"
					tmp29 := checkDerefVar(var_glojure_DOT_core_first)
					tmp30 := lang.Apply(tmp29, []any{v28})
					var v31 any = tmp30
					_ = v31
					// let binding "seq__320"
					tmp32 := checkDerefVar(var_glojure_DOT_core_next)
					tmp33 := lang.Apply(tmp32, []any{v28})
					var v34 any = tmp33
					_ = v34
					// let binding "fst__1__auto__"
					var v35 any = v31
					_ = v35
					// let binding "rst__2__auto__"
					var v36 any = v34
					_ = v36
					// let binding "res__0__auto__"
					var v37 any = v25
					_ = v37
					// let binding "err__3__auto__"
					tmp38 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp39 := lang.Apply(tmp38, []any{v22, int64(1), nil})
					var v40 any = tmp39
					_ = v40
					// let binding "res__0__auto__"
					var tmp41 any
					tmp42 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
					tmp43 := lang.Apply(tmp42, []any{v36})
					if lang.IsTruthy(tmp43) {
						tmp41 = v37
					} else {
						tmp41 = v35
					}
					var v44 any = tmp41
					_ = v44
					var tmp45 any
					if lang.IsTruthy(v40) {
						panic(v40)
					} else {
					}
					_ = tmp45
					tmp5 = v44
				} // end let
				tmp6 := lang.Apply(tmp4, []any{tmp5, v2})
				tmp3 = tmp6
			}()
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_file, "glojure/go/io.glj", kw_line, int(264), kw_column, int(25), kw_end_DASH_line, int(268), kw_end_DASH_column, int(79))).(lang.FnFunc)
		closed27 = tmp0
	}
	var closed28 any
	{
		closed28 = sym_divide
	}
	var closed29 any
	{
		closed29 = sym_and
	}
	var closed3 any
	{
		closed3 = sym_unchecked_add
	}
	var closed30 any
	{
		closed30 = sym_andNot
	}
	var closed31 any
	{
		closed31 = sym_or
	}
	var closed32 any
	{
		closed32 = sym_xor
	}
	var closed33 any
	{
		closed33 = sym_max
	}
	var closed34 any
	{
		closed34 = sym_min
	}
	var closed35 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v1 := args[0]
			_ = v1
			var tmp2 any
			if lang.IsTruthy(v1) {
				tmp2 = false
			} else {
				tmp2 = true
			}
			return tmp2
		})
		tmp1 := reflect.TypeOf(false)
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, tmp1)).(lang.FnFunc)
		closed35 = tmp0
	}
	var closed36 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
		recur_loop_481:
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := lang.Apply(tmp4, []any{v2})
				var v6 any = tmp5
				_ = v6
				var tmp7 any
				if lang.IsTruthy(v6) {
					var tmp8 any
					{ // let
						// let binding "s"
						var v9 any = v6
						_ = v9
						var tmp10 any
						{ // let
							// let binding "or__0__auto__"
							tmp11 := checkDerefVar(var_glojure_DOT_core_first)
							tmp12 := lang.Apply(tmp11, []any{v9})
							tmp13 := lang.Apply(v1, []any{tmp12})
							var v14 any = tmp13
							_ = v14
							var tmp15 any
							if lang.IsTruthy(v14) {
								tmp15 = v14
							} else {
								var tmp16 any = v1
								tmp18 := checkDerefVar(var_glojure_DOT_core_next)
								tmp19 := lang.Apply(tmp18, []any{v9})
								var tmp17 any = tmp19
								v1 = tmp16
								v2 = tmp17
								goto recur_loop_481
							}
							tmp10 = tmp15
						} // end let
						tmp8 = tmp10
					} // end let
					tmp7 = tmp8
				} else {
				}
				tmp3 = tmp7
			} // end let
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		closed36 = tmp0
	}
	var closed37 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
		recur_loop_480:
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp6 := lang.Apply(tmp5, []any{v2})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			if lang.IsTruthy(tmp7) {
				tmp3 = true
			} else {
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core_first)
				tmp10 := lang.Apply(tmp9, []any{v2})
				tmp11 := lang.Apply(v1, []any{tmp10})
				if lang.IsTruthy(tmp11) {
					var tmp12 any = v1
					tmp14 := checkDerefVar(var_glojure_DOT_core_next)
					tmp15 := lang.Apply(tmp14, []any{v2})
					var tmp13 any = tmp15
					v1 = tmp12
					v2 = tmp13
					goto recur_loop_480
				} else {
					var tmp16 any
					if lang.IsTruthy(kw_else) {
						tmp16 = false
					} else {
					}
					tmp8 = tmp16
				}
				tmp3 = tmp8
			}
			return tmp3
		})
		tmp1 := reflect.TypeOf(false)
		tmp0 = tmp0.WithMeta(lang.NewMap(kw_rettag, tmp1)).(lang.FnFunc)
		closed37 = tmp0
	}
	var closed4 any
	{
		closed4 = sym_add
	}
	var closed5 any
	{
		closed5 = sym_addP
	}
	var closed6 any
	{
		closed6 = sym_unchecked_minus
	}
	var closed7 any
	{
		closed7 = sym_minus
	}
	var closed8 any
	{
		closed8 = sym_minusP
	}
	var closed9 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				tmp3 := lang.Apply(v2, nil)
				return tmp3
			case 3:
				v1 := args[0]
				_ = v1
				v2 := args[1]
				_ = v2
				v3 := args[2]
				_ = v3
				return v3
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		closed9 = tmp0
	}

	// reference fmt to avoid unused import error
	_ = fmt.Printf
	ns := lang.FindOrCreateNamespace(sym_glojure_DOT_core)
	_ = ns
	// *
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed0
					} else {
						tmp4 = closed1
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed0
					} else {
						tmp5 = closed1
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed0
					} else {
						tmp6 = closed1
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__STAR_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the product of nums. (*) returns 1. Does not auto-promote\n  longs, will throw on overflow. See also: *'", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(1001), kw_end_DASH_line, int(1001))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(1)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Multiply")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Multiply is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core__STAR_)
				tmp10 := checkDerefVar(var_glojure_DOT_core__STAR_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed2
					} else {
						tmp4 = closed2
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed2
					} else {
						tmp5 = closed2
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed2
					} else {
						tmp6 = closed2
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__STAR__TICK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the product of nums. (*') returns 1. Supports arbitrary precision.\n  See also: *", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(989), kw_end_DASH_line, int(989))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(1)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "MultiplyP")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("MultiplyP is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core__STAR__TICK_)
				tmp10 := checkDerefVar(var_glojure_DOT_core__STAR__TICK_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *1
	{
		tmp0 := sym__STAR_1.WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *2
	{
		tmp0 := sym__STAR_2.WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *3
	{
		tmp0 := sym__STAR_3.WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *agent*
	{
		tmp0 := sym__STAR_agent_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *assert*
	{
		tmp0 := sym__STAR_assert_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "When set to logical false, 'assert' will omit assertion checks in\n  compiled code. Defaults to true.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *command-line-args*
	{
		tmp0 := sym__STAR_command_DASH_line_DASH_args_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "A sequence of the supplied command line arguments, or nil if\n  none were supplied", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compile-files*
	{
		tmp0 := sym__STAR_compile_DASH_files_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "Set to true when compiling files, false otherwise.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compile-path*
	{
		tmp0 := sym__STAR_compile_DASH_path_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "Specifies the directory where 'compile' will write out .class\n  files. This directory must be in the classpath for 'compile' to\n  work.\n\n  Defaults to \"classes\"", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compiler-options*
	{
		tmp0 := sym__STAR_compiler_DASH_options_STAR_.WithMeta(lang.NewMap(kw_added, "1.4", kw_doc, "A map of keys to options.\n  Note, when binding dynamically make sure to merge with previous value.\n  Supported options:\n  :elide-meta - a collection of metadata keys to elide during compilation.\n  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger\n  :direct-linking - set to true to use direct static invocation of functions, rather than vars\n    Note that call sites compiled with direct linking will not be affected by var redefinition.\n    Use ^:redef (or ^:dynamic) on a var to prevent direct linking and allow redefinition.\n  See https://glojure.org/reference/compilation for more information.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *data-readers*
	{
		tmp0 := sym__STAR_data_DASH_readers_STAR_.WithMeta(lang.NewMap(kw_doc, "Map from reader tag symbols to data reader Vars.\n\n  When Clojure starts, it searches for files named 'data_readers.clj'\n  and 'data_readers.cljc' at the root of the classpath. Each such file\n  must contain a literal map of symbols, like this:\n\n      {foo/bar my.project.foo/bar\n       foo/baz my.project/baz}\n\n  The first symbol in each pair is a tag that will be recognized by\n  the Clojure reader. The second symbol in the pair is the\n  fully-qualified name of a Var which will be invoked by the reader to\n  parse the form following the tag. For example, given the\n  data_readers.clj file above, the Clojure reader would parse this\n  form:\n\n      #foo/bar [1 2 3]\n\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\n  data reader function is invoked on the form AFTER it has been read\n  as a normal Clojure data structure by the reader.\n\n  Reader tags without namespace qualifiers are reserved for\n  Clojure. Default reader tags are defined in\n  glojure.core/default-data-readers but may be overridden in\n  data_readers.clj, data_readers.cljc, or by rebinding this Var.", kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(49), kw_column, int(6), kw_line, int(7794), kw_end_DASH_line, int(7794), kw_dynamic, true)).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.NewMap(), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *default-data-reader-fn*
	{
		tmp0 := sym__STAR_default_DASH_data_DASH_reader_DASH_fn_STAR_.WithMeta(lang.NewMap(kw_doc, "When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments,\n  the tag and the value.  If *default-data-reader-fn* is nil (the\n  default), an exception will be thrown for the unknown tag.", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(59), kw_column, int(6), kw_line, int(7823), kw_end_DASH_line, int(7823), kw_dynamic, true)).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *e
	{
		tmp0 := sym__STAR_e.WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *err*
	{
		tmp0 := sym__STAR_err_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "A java.io.Writer object representing standard error for print operations.\n\n  Defaults to System/err, wrapped in a PrintWriter", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *file*
	{
		tmp0 := sym__STAR_file_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "The path of the file being evaluated, as a String.\n\n  When there is no file, e.g. in the REPL, the value is not defined.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, "NO_SOURCE_FILE", true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *flush-on-newline*
	{
		tmp0 := sym__STAR_flush_DASH_on_DASH_newline_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *loaded-libs*
	{
		tmp0 := sym__STAR_loaded_DASH_libs_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(5817), kw_column, int(10), kw_end_DASH_line, int(5820), kw_end_DASH_column, int(15), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp2 := lang.NewRef(lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{sym_glojure_DOT_core_DOT_protocols, sym_glojure_DOT_string, sym_glojure_DOT_go_DOT_io, sym_codegen_DOT_test_DOT_const_DASH_keyword, sym_codegen_DOT_test_DOT_const_DASH_number, sym_codegen_DOT_test_DOT_const_DASH_string, sym_codegen_DOT_test_DOT_def_DASH_simple, sym_codegen_DOT_test_DOT_fn_DASH_closure, sym_codegen_DOT_test_DOT_fn_DASH_recur, sym_codegen_DOT_test_DOT_loop_DASH_simple, sym_codegen_DOT_test_DOT_maybe_DASH_class, sym_codegen_DOT_test_DOT_multifn, sym_codegen_DOT_test_DOT_ns_DASH_skip, sym_codegen_DOT_test_DOT_quote_DASH_simple, sym_codegen_DOT_test_DOT_ref, sym_codegen_DOT_test_DOT_the_DASH_var, sym_codegen_DOT_test_DOT_throw_DASH_simple, sym_codegen_DOT_test_DOT_try_DASH_advanced, sym_codegen_DOT_test_DOT_try_DASH_basic, sym_codegen_DOT_test_DOT_values, sym_codegen_DOT_test_DOT_with_DASH_meta})))
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *loading-verbosely*
	{
		tmp0 := sym__STAR_loading_DASH_verbosely_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(5827), kw_column, int(10), kw_end_DASH_line, int(5830), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *ns*
	{
		tmp0 := sym__STAR_ns_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "A glojure.lang.Namespace object representing the current namespace.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.FindOrCreateNamespace(sym_glojure_DOT_core), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *pending-paths*
	{
		tmp0 := sym__STAR_pending_DASH_paths_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(5822), kw_column, int(10), kw_end_DASH_line, int(5825), kw_end_DASH_column, int(17), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.NewList(), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-dup*
	{
		tmp0 := sym__STAR_print_DASH_dup_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-length*
	{
		tmp0 := sym__STAR_print_DASH_length_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core_print.glj", kw_line, int(14), kw_column, int(6), kw_end_DASH_line, int(23), kw_end_DASH_column, int(15), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-level*
	{
		tmp0 := sym__STAR_print_DASH_level_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core_print.glj", kw_line, int(25), kw_column, int(6), kw_end_DASH_line, int(35), kw_end_DASH_column, int(14), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-meta*
	{
		tmp0 := sym__STAR_print_DASH_meta_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-namespace-maps*
	{
		tmp0 := sym__STAR_print_DASH_namespace_DASH_maps_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core_print.glj", kw_line, int(39), kw_column, int(6), kw_end_DASH_line, int(44), kw_end_DASH_column, int(23), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-readably*
	{
		tmp0 := sym__STAR_print_DASH_readably_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, true, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *read-eval*
	{
		tmp0 := sym__STAR_read_DASH_eval_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "Defaults to true (or value specified by system property, see below)\n  ***This setting implies that the full power of the reader is in play,\n  including syntax that can cause code to execute. It should never be\n  used with untrusted sources. See also: glojure.edn/read.***\n\n  When set to logical false in the thread-local binding,\n  the eval reader (#=) and record/type literal syntax are disabled in read/load.\n  Example (will fail): (binding [*read-eval* false] (read-string \"#=(* 2 21)\"))\n\n  The default binding can be controlled by the system property\n  'glojure.read.eval' System properties can be set on the command line\n  like this:\n\n  java -Dglojure.read.eval=false ...\n\n  The system property can also be set to 'unknown' via\n  -Dglojure.read.eval=unknown, in which case the default binding\n  is :unknown and all reads will fail in contexts where *read-eval*\n  has not been explicitly bound to either true or false. This setting\n  can be a useful diagnostic tool to ensure that all of your reads\n  occur in considered contexts. You can also accomplish this in a\n  particular scope by binding *read-eval* to :unknown\n  ", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *repl*
	{
		tmp0 := sym__STAR_repl_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core.glj", kw_line, int(6288), kw_column, int(6), kw_end_DASH_line, int(6291), kw_end_DASH_column, int(8), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *unchecked-math*
	{
		tmp0 := sym__STAR_unchecked_DASH_math_STAR_.WithMeta(lang.NewMap(kw_added, "1.3", kw_doc, "While bound to true, compilations of +, -, *, inc, dec and the\n  coercions will be done without overflow checks. While bound\n  to :warn-on-boxed, same behavior as true, and a warning is emitted\n  when compilation uses boxed math. Default: false.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *verbose-defrecords*
	{
		tmp0 := sym__STAR_verbose_DASH_defrecords_STAR_.WithMeta(lang.NewMap(kw_dynamic, true, kw_file, "glojure/core_print.glj", kw_line, int(37), kw_column, int(6), kw_end_DASH_line, int(37), kw_end_DASH_column, int(35), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *warn-on-reflection*
	{
		tmp0 := sym__STAR_warn_DASH_on_DASH_reflection_STAR_.WithMeta(lang.NewMap(kw_added, "1.0", kw_doc, "When set to true, the compiler will emit warnings when reflection is\n  needed to resolve Java method calls or field accesses.\n\n  Defaults to false.", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed3
					} else {
						tmp4 = closed4
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed3
					} else {
						tmp5 = closed4
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed3
					} else {
						tmp6 = closed4
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__PLUS_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(977), kw_end_DASH_line, int(977))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(0)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Add")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Add is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core__PLUS_)
				tmp10 := checkDerefVar(var_glojure_DOT_core__PLUS_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed5
					} else {
						tmp4 = closed5
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed5
					} else {
						tmp5 = closed5
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed5
					} else {
						tmp6 = closed5
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__PLUS__TICK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the sum of nums. (+') returns 0. Supports arbitrary precision.\n  See also: +", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(965), kw_end_DASH_line, int(965))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(0)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "AddP")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddP is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core__PLUS__TICK_)
				tmp10 := checkDerefVar(var_glojure_DOT_core__PLUS__TICK_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed6
					} else {
						tmp4 = closed7
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed6
					} else {
						tmp5 = closed7
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed6
					} else {
						tmp6 = closed7
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(0)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__DASH_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Does not auto-promote\n  longs, will throw on overflow. See also: -'", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(1036), kw_end_DASH_line, int(1036))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_)
				tmp7 := lang.Apply(tmp6, []any{int64(-1), v5})
				return tmp7
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Minus")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Minus is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core__DASH_)
				tmp10 := checkDerefVar(var_glojure_DOT_core__DASH_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed8
					} else {
						tmp4 = closed8
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed8
					} else {
						tmp5 = closed8
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed8
					} else {
						tmp6 = closed8
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(0)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__DASH__TICK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Supports arbitrary precision.\n  See also: -", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(1024), kw_end_DASH_line, int(1024))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core__STAR__TICK_)
				tmp7 := lang.Apply(tmp6, []any{int64(-1), v5})
				return tmp7
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "MinusP")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("MinusP is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core__DASH__TICK_)
				tmp10 := checkDerefVar(var_glojure_DOT_core__DASH__TICK_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ->
	{
		tmp0 := sym__DASH__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_forms)), kw_doc, "Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(1675), kw_end_DASH_line, int(1675))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "x"
					var v8 any = v5
					_ = v8
					// let binding "forms"
					var v9 any = v6
					_ = v9
					for {
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "form"
								tmp12 := checkDerefVar(var_glojure_DOT_core_first)
								tmp13 := lang.Apply(tmp12, []any{v9})
								var v14 any = tmp13
								_ = v14
								// let binding "threaded"
								var tmp15 any
								tmp16 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
								tmp17 := lang.Apply(tmp16, []any{v14})
								if lang.IsTruthy(tmp17) {
									tmp18 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
									tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp21 := checkDerefVar(var_glojure_DOT_core_list)
									tmp22 := checkDerefVar(var_glojure_DOT_core_first)
									tmp23 := lang.Apply(tmp22, []any{v14})
									tmp24 := lang.Apply(tmp21, []any{tmp23})
									tmp25 := checkDerefVar(var_glojure_DOT_core_list)
									tmp26 := lang.Apply(tmp25, []any{v8})
									tmp27 := checkDerefVar(var_glojure_DOT_core_next)
									tmp28 := lang.Apply(tmp27, []any{v14})
									tmp29 := lang.Apply(tmp20, []any{tmp24, tmp26, tmp28})
									tmp30 := lang.Apply(tmp19, []any{tmp29})
									tmp31 := checkDerefVar(var_glojure_DOT_core_meta)
									tmp32 := lang.Apply(tmp31, []any{v14})
									tmp33 := lang.Apply(tmp18, []any{tmp30, tmp32})
									tmp15 = tmp33
								} else {
									tmp34 := checkDerefVar(var_glojure_DOT_core_list)
									tmp35 := lang.Apply(tmp34, []any{v14, v8})
									tmp15 = tmp35
								}
								var v36 any = tmp15
								_ = v36
								var tmp37 any = v36
								tmp39 := checkDerefVar(var_glojure_DOT_core_next)
								tmp40 := lang.Apply(tmp39, []any{v9})
								var tmp38 any = tmp40
								v8 = tmp37
								v9 = tmp38
								continue
							} // end let
							tmp10 = tmp11
						} else {
							tmp10 = v8
						}
						tmp7 = tmp10
						break
					}
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ->>
	{
		tmp0 := sym__DASH__GT__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_forms)), kw_doc, "Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc.", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(11), kw_line, int(1691), kw_end_DASH_line, int(1691))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "x"
					var v8 any = v5
					_ = v8
					// let binding "forms"
					var v9 any = v6
					_ = v9
					for {
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "form"
								tmp12 := checkDerefVar(var_glojure_DOT_core_first)
								tmp13 := lang.Apply(tmp12, []any{v9})
								var v14 any = tmp13
								_ = v14
								// let binding "threaded"
								var tmp15 any
								tmp16 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
								tmp17 := lang.Apply(tmp16, []any{v14})
								if lang.IsTruthy(tmp17) {
									tmp18 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
									tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp21 := checkDerefVar(var_glojure_DOT_core_list)
									tmp22 := checkDerefVar(var_glojure_DOT_core_first)
									tmp23 := lang.Apply(tmp22, []any{v14})
									tmp24 := lang.Apply(tmp21, []any{tmp23})
									tmp25 := checkDerefVar(var_glojure_DOT_core_next)
									tmp26 := lang.Apply(tmp25, []any{v14})
									tmp27 := checkDerefVar(var_glojure_DOT_core_list)
									tmp28 := lang.Apply(tmp27, []any{v8})
									tmp29 := lang.Apply(tmp20, []any{tmp24, tmp26, tmp28})
									tmp30 := lang.Apply(tmp19, []any{tmp29})
									tmp31 := checkDerefVar(var_glojure_DOT_core_meta)
									tmp32 := lang.Apply(tmp31, []any{v14})
									tmp33 := lang.Apply(tmp18, []any{tmp30, tmp32})
									tmp15 = tmp33
								} else {
									tmp34 := checkDerefVar(var_glojure_DOT_core_list)
									tmp35 := lang.Apply(tmp34, []any{v14, v8})
									tmp15 = tmp35
								}
								var v36 any = tmp15
								_ = v36
								var tmp37 any = v36
								tmp39 := checkDerefVar(var_glojure_DOT_core_next)
								tmp40 := lang.Apply(tmp39, []any{v9})
								var tmp38 any = tmp40
								v8 = tmp37
								v9 = tmp38
								continue
							} // end let
							tmp10 = tmp11
						} else {
							tmp10 = v8
						}
						tmp7 = tmp10
						break
					}
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -protocols
	{
		tmp0 := sym__DASH_protocols.WithMeta(lang.NewMap(kw_private, true, kw_doc, "Private store of protocols. Go's reflection capabilities\n    don't yet support a native interface-based implementation, so\n    protocols are implemented in Glojure as maps from type to protocol\n    method implementations.", kw_file, "glojure/core_deftype.glj", kw_line, int(21), kw_column, int(3), kw_end_DASH_line, int(26), kw_end_DASH_column, int(12), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp5 lang.FnFunc
		tmp5 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v6 := args[0]
				_ = v6
				var v7 any = lang.NewList(args[1:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_class)
				tmp9 := lang.Apply(tmp8, []any{v6})
				return tmp9
			}
		})
		tmp4 := lang.NewMultiFn("coll-reduce", tmp5, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v7 := args[0]
				_ = v7
				var v8 any = lang.NewList(args[1:]...)
				_ = v8
				tmp9 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp10 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp11 := lang.Apply(tmp10, []any{v7, v8})
				tmp12 := lang.Apply(tmp9, []any{closed9, tmp11})
				return tmp12
			}
		})
		tmp4.AddMethod(nil, tmp6)
		tmp7 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v9 := args[0]
				_ = v9
				var v10 any = lang.NewList(args[1:]...)
				_ = v10
				tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp13 := lang.Apply(tmp12, []any{v9, v10})
				tmp14 := lang.Apply(tmp11, []any{closed10, tmp13})
				return tmp14
			}
		})
		tmp4.AddMethod(tmp7, tmp8)
		tmp9 := reflect.TypeOf((*lang.LazySeq)(nil))
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v11 := args[0]
				_ = v11
				var v12 any = lang.NewList(args[1:]...)
				_ = v12
				tmp13 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp14 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp15 := lang.Apply(tmp14, []any{v11, v12})
				tmp16 := lang.Apply(tmp13, []any{closed11, tmp15})
				return tmp16
			}
		})
		tmp4.AddMethod(tmp9, tmp10)
		tmp11 := reflect.TypeOf((*lang.Vector)(nil))
		var tmp12 lang.FnFunc
		tmp12 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v13 := args[0]
				_ = v13
				var v14 any = lang.NewList(args[1:]...)
				_ = v14
				tmp15 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp16 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp17 := lang.Apply(tmp16, []any{v13, v14})
				tmp18 := lang.Apply(tmp15, []any{closed12, tmp17})
				return tmp18
			}
		})
		tmp4.AddMethod(tmp11, tmp12)
		tmp3 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_coll_DASH_reduce, tmp4), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_coll_DASH_reduce, lang.NewVector(sym_coll, sym_f), lang.NewVector(sym_coll, sym_f, sym_val)))))
		var tmp15 lang.FnFunc
		tmp15 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v16 := args[0]
				_ = v16
				var v17 any = lang.NewList(args[1:]...)
				_ = v17
				tmp18 := checkDerefVar(var_glojure_DOT_core_class)
				tmp19 := lang.Apply(tmp18, []any{v16})
				return tmp19
			}
		})
		tmp14 := lang.NewMultiFn("internal-reduce", tmp15, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp16 lang.FnFunc
		tmp16 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v17 := args[0]
				_ = v17
				var v18 any = lang.NewList(args[1:]...)
				_ = v18
				tmp19 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp20 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp21 := lang.Apply(tmp20, []any{v17, v18})
				tmp22 := lang.Apply(tmp19, []any{closed13, tmp21})
				return tmp22
			}
		})
		tmp14.AddMethod(nil, tmp16)
		tmp17 := reflect.TypeOf((*lang.IChunkedSeq)(nil)).Elem()
		var tmp18 lang.FnFunc
		tmp18 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v19 := args[0]
				_ = v19
				var v20 any = lang.NewList(args[1:]...)
				_ = v20
				tmp21 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp22 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp23 := lang.Apply(tmp22, []any{v19, v20})
				tmp24 := lang.Apply(tmp21, []any{closed14, tmp23})
				return tmp24
			}
		})
		tmp14.AddMethod(tmp17, tmp18)
		tmp19 := reflect.TypeOf((*lang.Object)(nil)).Elem()
		var tmp20 lang.FnFunc
		tmp20 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v21 := args[0]
				_ = v21
				var v22 any = lang.NewList(args[1:]...)
				_ = v22
				tmp23 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp24 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp25 := lang.Apply(tmp24, []any{v21, v22})
				tmp26 := lang.Apply(tmp23, []any{closed15, tmp25})
				return tmp26
			}
		})
		tmp14.AddMethod(tmp19, tmp20)
		tmp13 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_internal_DASH_reduce, tmp14), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_internal_DASH_reduce, lang.NewVector(sym_seq, sym_f, sym_start)))))
		var tmp23 lang.FnFunc
		tmp23 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v24 := args[0]
				_ = v24
				var v25 any = lang.NewList(args[1:]...)
				_ = v25
				tmp26 := checkDerefVar(var_glojure_DOT_core_class)
				tmp27 := lang.Apply(tmp26, []any{v24})
				return tmp27
			}
		})
		tmp22 := lang.NewMultiFn("kv-reduce", tmp23, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp21 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_kv_DASH_reduce, tmp22), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_kv_DASH_reduce, lang.NewVector(sym_amap, sym_f, sym_init)))))
		var tmp26 lang.FnFunc
		tmp26 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v27 := args[0]
				_ = v27
				var v28 any = lang.NewList(args[1:]...)
				_ = v28
				tmp29 := checkDerefVar(var_glojure_DOT_core_class)
				tmp30 := lang.Apply(tmp29, []any{v27})
				return tmp30
			}
		})
		tmp25 := lang.NewMultiFn("datafy", tmp26, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp27 lang.FnFunc
		tmp27 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v28 := args[0]
				_ = v28
				var v29 any = lang.NewList(args[1:]...)
				_ = v29
				tmp30 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp31 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp32 := lang.Apply(tmp31, []any{v28, v29})
				tmp33 := lang.Apply(tmp30, []any{closed16, tmp32})
				return tmp33
			}
		})
		tmp25.AddMethod(nil, tmp27)
		tmp24 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_datafy, tmp25), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_datafy, lang.NewVector(sym_o), "return a representation of o as data (default identity)"))))
		var tmp30 lang.FnFunc
		tmp30 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v31 := args[0]
				_ = v31
				var v32 any = lang.NewList(args[1:]...)
				_ = v32
				tmp33 := checkDerefVar(var_glojure_DOT_core_class)
				tmp34 := lang.Apply(tmp33, []any{v31})
				return tmp34
			}
		})
		tmp29 := lang.NewMultiFn("nav", tmp30, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp28 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_nav, tmp29), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_nav, lang.NewVector(sym_coll, sym_k, sym_v), "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v."))))
		var tmp33 lang.FnFunc
		tmp33 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v34 := args[0]
				_ = v34
				var v35 any = lang.NewList(args[1:]...)
				_ = v35
				tmp36 := checkDerefVar(var_glojure_DOT_core_class)
				tmp37 := lang.Apply(tmp36, []any{v34})
				return tmp37
			}
		})
		tmp32 := lang.NewMultiFn("make-reader", tmp33, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp34 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp35 lang.FnFunc
		tmp35 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v36 := args[0]
				_ = v36
				var v37 any = lang.NewList(args[1:]...)
				_ = v37
				tmp38 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp39 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp40 := lang.Apply(tmp39, []any{v36, v37})
				tmp41 := lang.Apply(tmp38, []any{closed17, tmp40})
				return tmp41
			}
		})
		tmp32.AddMethod(tmp34, tmp35)
		tmp36 := reflect.TypeOf((*url5.URL)(nil))
		var tmp37 lang.FnFunc
		tmp37 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v38 := args[0]
				_ = v38
				var v39 any = lang.NewList(args[1:]...)
				_ = v39
				tmp40 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp41 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp42 := lang.Apply(tmp41, []any{v38, v39})
				tmp43 := lang.Apply(tmp40, []any{closed18, tmp42})
				return tmp43
			}
		})
		tmp32.AddMethod(tmp36, tmp37)
		tmp38 := reflect.TypeOf("")
		var tmp39 lang.FnFunc
		tmp39 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v40 := args[0]
				_ = v40
				var v41 any = lang.NewList(args[1:]...)
				_ = v41
				tmp42 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp43 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp44 := lang.Apply(tmp43, []any{v40, v41})
				tmp45 := lang.Apply(tmp42, []any{closed18, tmp44})
				return tmp45
			}
		})
		tmp32.AddMethod(tmp38, tmp39)
		var tmp41 lang.FnFunc
		tmp41 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v42 := args[0]
				_ = v42
				var v43 any = lang.NewList(args[1:]...)
				_ = v43
				tmp44 := checkDerefVar(var_glojure_DOT_core_class)
				tmp45 := lang.Apply(tmp44, []any{v42})
				return tmp45
			}
		})
		tmp40 := lang.NewMultiFn("make-writer", tmp41, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp42 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp43 lang.FnFunc
		tmp43 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v44 := args[0]
				_ = v44
				var v45 any = lang.NewList(args[1:]...)
				_ = v45
				tmp46 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp47 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp48 := lang.Apply(tmp47, []any{v44, v45})
				tmp49 := lang.Apply(tmp46, []any{closed19, tmp48})
				return tmp49
			}
		})
		tmp40.AddMethod(tmp42, tmp43)
		tmp44 := reflect.TypeOf((*url5.URL)(nil))
		var tmp45 lang.FnFunc
		tmp45 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v46 := args[0]
				_ = v46
				var v47 any = lang.NewList(args[1:]...)
				_ = v47
				tmp48 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp49 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp50 := lang.Apply(tmp49, []any{v46, v47})
				tmp51 := lang.Apply(tmp48, []any{closed19, tmp50})
				return tmp51
			}
		})
		tmp40.AddMethod(tmp44, tmp45)
		tmp46 := reflect.TypeOf("")
		var tmp47 lang.FnFunc
		tmp47 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v48 := args[0]
				_ = v48
				var v49 any = lang.NewList(args[1:]...)
				_ = v49
				tmp50 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp51 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp52 := lang.Apply(tmp51, []any{v48, v49})
				tmp53 := lang.Apply(tmp50, []any{closed19, tmp52})
				return tmp53
			}
		})
		tmp40.AddMethod(tmp46, tmp47)
		var tmp49 lang.FnFunc
		tmp49 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v50 := args[0]
				_ = v50
				var v51 any = lang.NewList(args[1:]...)
				_ = v51
				tmp52 := checkDerefVar(var_glojure_DOT_core_class)
				tmp53 := lang.Apply(tmp52, []any{v50})
				return tmp53
			}
		})
		tmp48 := lang.NewMultiFn("make-input-stream", tmp49, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp50 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp51 lang.FnFunc
		tmp51 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v52 := args[0]
				_ = v52
				var v53 any = lang.NewList(args[1:]...)
				_ = v53
				tmp54 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp55 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp56 := lang.Apply(tmp55, []any{v52, v53})
				tmp57 := lang.Apply(tmp54, []any{closed20, tmp56})
				return tmp57
			}
		})
		tmp48.AddMethod(tmp50, tmp51)
		tmp52 := reflect.TypeOf((*os6.File)(nil))
		var tmp53 lang.FnFunc
		tmp53 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v54 := args[0]
				_ = v54
				var v55 any = lang.NewList(args[1:]...)
				_ = v55
				tmp56 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp57 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp58 := lang.Apply(tmp57, []any{v54, v55})
				tmp59 := lang.Apply(tmp56, []any{closed21, tmp58})
				return tmp59
			}
		})
		tmp48.AddMethod(tmp52, tmp53)
		tmp54 := reflect.TypeOf((*url5.URL)(nil))
		var tmp55 lang.FnFunc
		tmp55 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v56 := args[0]
				_ = v56
				var v57 any = lang.NewList(args[1:]...)
				_ = v57
				tmp58 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp59 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp60 := lang.Apply(tmp59, []any{v56, v57})
				tmp61 := lang.Apply(tmp58, []any{closed22, tmp60})
				return tmp61
			}
		})
		tmp48.AddMethod(tmp54, tmp55)
		tmp56 := reflect.TypeOf("")
		var tmp57 lang.FnFunc
		tmp57 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v58 := args[0]
				_ = v58
				var v59 any = lang.NewList(args[1:]...)
				_ = v59
				tmp60 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp61 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp62 := lang.Apply(tmp61, []any{v58, v59})
				tmp63 := lang.Apply(tmp60, []any{closed23, tmp62})
				return tmp63
			}
		})
		tmp48.AddMethod(tmp56, tmp57)
		var tmp59 lang.FnFunc
		tmp59 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v60 := args[0]
				_ = v60
				var v61 any = lang.NewList(args[1:]...)
				_ = v61
				tmp62 := checkDerefVar(var_glojure_DOT_core_class)
				tmp63 := lang.Apply(tmp62, []any{v60})
				return tmp63
			}
		})
		tmp58 := lang.NewMultiFn("make-output-stream", tmp59, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		tmp60 := reflect.TypeOf((*io4.Reader)(nil)).Elem()
		var tmp61 lang.FnFunc
		tmp61 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v62 := args[0]
				_ = v62
				var v63 any = lang.NewList(args[1:]...)
				_ = v63
				tmp64 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp65 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp66 := lang.Apply(tmp65, []any{v62, v63})
				tmp67 := lang.Apply(tmp64, []any{closed24, tmp66})
				return tmp67
			}
		})
		tmp58.AddMethod(tmp60, tmp61)
		tmp62 := reflect.TypeOf((*os6.File)(nil))
		var tmp63 lang.FnFunc
		tmp63 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v64 := args[0]
				_ = v64
				var v65 any = lang.NewList(args[1:]...)
				_ = v65
				tmp66 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp67 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp68 := lang.Apply(tmp67, []any{v64, v65})
				tmp69 := lang.Apply(tmp66, []any{closed25, tmp68})
				return tmp69
			}
		})
		tmp58.AddMethod(tmp62, tmp63)
		tmp64 := reflect.TypeOf((*url5.URL)(nil))
		var tmp65 lang.FnFunc
		tmp65 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v66 := args[0]
				_ = v66
				var v67 any = lang.NewList(args[1:]...)
				_ = v67
				tmp68 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp69 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp70 := lang.Apply(tmp69, []any{v66, v67})
				tmp71 := lang.Apply(tmp68, []any{closed26, tmp70})
				return tmp71
			}
		})
		tmp58.AddMethod(tmp64, tmp65)
		tmp66 := reflect.TypeOf("")
		var tmp67 lang.FnFunc
		tmp67 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v68 := args[0]
				_ = v68
				var v69 any = lang.NewList(args[1:]...)
				_ = v69
				tmp70 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp71 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp72 := lang.Apply(tmp71, []any{v68, v69})
				tmp73 := lang.Apply(tmp70, []any{closed27, tmp72})
				return tmp73
			}
		})
		tmp58.AddMethod(tmp66, tmp67)
		tmp31 := lang.NewAtom(lang.NewMap(kw_multis, lang.NewMap(kw_make_DASH_reader, tmp32, kw_make_DASH_writer, tmp40, kw_make_DASH_input_DASH_stream, tmp48, kw_make_DASH_output_DASH_stream, tmp58), kw_on_DASH_interface, true, kw_sigs, lang.NewList(lang.NewList(sym_make_DASH_reader, lang.NewVector(sym_x, sym_opts), "Creates an io.Reader. See also IOFactory docs."), lang.NewList(sym_make_DASH_writer, lang.NewVector(sym_x, sym_opts), "Creates an io.Reader. See also IOFactory docs."), lang.NewList(sym_make_DASH_input_DASH_stream, lang.NewVector(sym_x, sym_opts), "Creates a BufferedInputStream. See also IOFactory docs."), lang.NewList(sym_make_DASH_output_DASH_stream, lang.NewVector(sym_x, sym_opts), "Creates a BufferedOutputStream. See also IOFactory docs."))))
		tmp2 := lang.NewAtom(lang.NewMap(sym_CollReduce, tmp3, sym_InternalReduce, tmp13, sym_IKVReduce, tmp21, sym_Datafiable, tmp24, sym_Navigable, tmp28, sym_IOFactory, tmp31))
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ..
	{
		tmp0 := sym__DOT__DOT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_form), lang.NewVector(sym_x, sym_form, sym__AMP_, sym_more)), kw_doc, "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \"os.name\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \"os.name\"))\n\n  but is easier to write, read, and understand.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(1657), kw_end_DASH_line, int(1657))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v6})
				tmp15 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp14})
				tmp16 := lang.Apply(tmp7, []any{tmp15})
				return tmp16
			default:
				checkArity(args, 4)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym__DOT__DOT_})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v5})
				tmp19 := checkDerefVar(var_glojure_DOT_core_list)
				tmp20 := lang.Apply(tmp19, []any{v6})
				tmp21 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp20})
				tmp22 := lang.Apply(tmp13, []any{tmp21})
				tmp23 := lang.Apply(tmp12, []any{tmp22})
				tmp24 := lang.Apply(tmp9, []any{tmp11, tmp23, v7})
				tmp25 := lang.Apply(tmp8, []any{tmp24})
				return tmp25
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// /
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed28
					} else {
						tmp4 = closed28
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed28
					} else {
						tmp5 = closed28
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed28
					} else {
						tmp6 = closed28
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym__SLASH_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(1013), kw_end_DASH_line, int(1013))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core__SLASH_)
				tmp7 := lang.Apply(tmp6, []any{int64(1), v5})
				return tmp7
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Divide")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Divide is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core__SLASH_)
				tmp10 := checkDerefVar(var_glojure_DOT_core__SLASH_)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// <
	{
		var tmp1 lang.FnFunc
		{ // function <__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Lt})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__LT_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(893), kw_end_DASH_line, int(893))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Lt")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Lt is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_150:
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core__LT_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v6})
					if lang.IsTruthy(tmp12) {
						var tmp13 any = v5
						tmp15 := checkDerefVar(var_glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var tmp14 any = tmp16
						tmp18 := checkDerefVar(var_glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp17 any = tmp19
						v4 = tmp13
						v5 = tmp14
						v6 = tmp17
						goto recur_loop_150
					} else {
						tmp20 := checkDerefVar(var_glojure_DOT_core__LT_)
						tmp21 := checkDerefVar(var_glojure_DOT_core_first)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp23 := lang.Apply(tmp20, []any{v5, tmp22})
						tmp10 = tmp23
					}
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// <=
	{
		var tmp1 lang.FnFunc
		{ // function <=__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Lte})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__LT__EQ_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(1048), kw_end_DASH_line, int(1048))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Lte")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Lte is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_194:
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v6})
					if lang.IsTruthy(tmp12) {
						var tmp13 any = v5
						tmp15 := checkDerefVar(var_glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var tmp14 any = tmp16
						tmp18 := checkDerefVar(var_glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp17 any = tmp19
						v4 = tmp13
						v5 = tmp14
						v6 = tmp17
						goto recur_loop_194
					} else {
						tmp20 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
						tmp21 := checkDerefVar(var_glojure_DOT_core_first)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp23 := lang.Apply(tmp20, []any{v5, tmp22})
						tmp10 = tmp23
					}
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// =
	{
		var tmp1 lang.FnFunc
		{ // function =__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_lang_DOT_Util})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{sym_glojure_DOT_core_SLASH_equiv})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp5, []any{tmp17})
				return tmp18
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__EQ_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Equality. Returns true if x equals y, false if not. Same as\n  Java x.equals(y) except it also works for nil, and compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define equals() (and thus =) as a value, not an identity,\n  comparison.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(776), kw_end_DASH_line, int(776))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.Equiv, []any{v4, v5})
				return tmp6
			default:
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_126:
				var tmp7 any
				tmp8 := lang.Apply(lang.Equiv, []any{v4, v5})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_next)
					tmp11 := lang.Apply(tmp10, []any{v6})
					if lang.IsTruthy(tmp11) {
						var tmp12 any = v5
						tmp14 := checkDerefVar(var_glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v6})
						var tmp13 any = tmp15
						tmp17 := checkDerefVar(var_glojure_DOT_core_next)
						tmp18 := lang.Apply(tmp17, []any{v6})
						var tmp16 any = tmp18
						v4 = tmp12
						v5 = tmp13
						v6 = tmp16
						goto recur_loop_126
					} else {
						tmp19 := checkDerefVar(var_glojure_DOT_core_first)
						tmp20 := lang.Apply(tmp19, []any{v6})
						tmp21 := lang.Apply(lang.Equiv, []any{v5, tmp20})
						tmp9 = tmp21
					}
					tmp7 = tmp9
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ==
	{
		var tmp1 lang.FnFunc
		{ // function ==__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Equiv})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__EQ__EQ_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns non-nil if nums all have the equivalent\n  value (type-independent), otherwise false", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(1093), kw_end_DASH_line, int(1093))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Equiv")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Equiv is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_206:
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core__EQ__EQ_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v6})
					if lang.IsTruthy(tmp12) {
						var tmp13 any = v5
						tmp15 := checkDerefVar(var_glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var tmp14 any = tmp16
						tmp18 := checkDerefVar(var_glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp17 any = tmp19
						v4 = tmp13
						v5 = tmp14
						v6 = tmp17
						goto recur_loop_206
					} else {
						tmp20 := checkDerefVar(var_glojure_DOT_core__EQ__EQ_)
						tmp21 := checkDerefVar(var_glojure_DOT_core_first)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp23 := lang.Apply(tmp20, []any{v5, tmp22})
						tmp10 = tmp23
					}
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >
	{
		var tmp1 lang.FnFunc
		{ // function >__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Gt})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__GT_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(7), kw_line, int(1063), kw_end_DASH_line, int(1063))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_198:
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core__GT_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v6})
					if lang.IsTruthy(tmp12) {
						var tmp13 any = v5
						tmp15 := checkDerefVar(var_glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var tmp14 any = tmp16
						tmp18 := checkDerefVar(var_glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp17 any = tmp19
						v4 = tmp13
						v5 = tmp14
						v6 = tmp17
						goto recur_loop_198
					} else {
						tmp20 := checkDerefVar(var_glojure_DOT_core__GT_)
						tmp21 := checkDerefVar(var_glojure_DOT_core_first)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp23 := lang.Apply(tmp20, []any{v5, tmp22})
						tmp10 = tmp23
					}
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >0?
	{
		tmp0 := sym__GT_0_QMARK_.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(963), kw_column, int(7), kw_end_DASH_line, int(963), kw_end_DASH_column, int(19), kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(0)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >1?
	{
		tmp0 := sym__GT_1_QMARK_.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(962), kw_column, int(7), kw_end_DASH_line, int(962), kw_end_DASH_column, int(19), kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >=
	{
		var tmp1 lang.FnFunc
		{ // function >=__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Gte})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym__GT__EQ_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(1078), kw_end_DASH_line, int(1078))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Gte")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gte is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_202:
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core__GT__EQ_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v6})
					if lang.IsTruthy(tmp12) {
						var tmp13 any = v5
						tmp15 := checkDerefVar(var_glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var tmp14 any = tmp16
						tmp18 := checkDerefVar(var_glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp17 any = tmp19
						v4 = tmp13
						v5 = tmp14
						v6 = tmp17
						goto recur_loop_202
					} else {
						tmp20 := checkDerefVar(var_glojure_DOT_core__GT__EQ_)
						tmp21 := checkDerefVar(var_glojure_DOT_core_first)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp23 := lang.Apply(tmp20, []any{v5, tmp22})
						tmp10 = tmp23
					}
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// NaN?
	{
		var tmp1 lang.FnFunc
		{ // function NaN?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym_math_DOT_IsNaN})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_NaN_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_inline, tmp1, kw_doc, "Returns true if num is NaN, else false", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(7968), kw_end_DASH_line, int(7968))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(math7.IsNaN, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// StackTraceElement->vec
	{
		tmp0 := sym_StackTraceElement_DASH__GT_vec.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_o)), kw_doc, "Constructs a data representation for a StackTraceElement: [class method file line]", kw_file, "glojure/core_print.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(28), kw_column, int(7), kw_line, int(436), kw_end_DASH_line, int(436))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_symbol)
			tmp5, ok := lang.FieldOrMethod(v3, "getClassName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getClassName")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			tmp8 := checkDerefVar(var_glojure_DOT_core_symbol)
			tmp9, ok := lang.FieldOrMethod(v3, "getMethodName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMethodName")))
			}
			var tmp10 any
			switch reflect.TypeOf(tmp9).Kind() {
			case reflect.Func:
				tmp10 = lang.Apply(tmp9, nil)
			default:
				tmp10 = tmp9
			}
			tmp11 := lang.Apply(tmp8, []any{tmp10})
			tmp12, ok := lang.FieldOrMethod(v3, "getFileName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getFileName")))
			}
			var tmp13 any
			switch reflect.TypeOf(tmp12).Kind() {
			case reflect.Func:
				tmp13 = lang.Apply(tmp12, nil)
			default:
				tmp13 = tmp12
			}
			tmp14, ok := lang.FieldOrMethod(v3, "getLineNumber")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getLineNumber")))
			}
			var tmp15 any
			switch reflect.TypeOf(tmp14).Kind() {
			case reflect.Func:
				tmp15 = lang.Apply(tmp14, nil)
			default:
				tmp15 = tmp14
			}
			tmp16 := lang.NewVector(tmp7, tmp11, tmp13, tmp15)
			tmp17 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(440), kw_column, int(3), kw_end_DASH_line, int(440), kw_end_DASH_column, int(94))
			tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp18
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// Throwable->map
	{
		tmp0 := sym_Throwable_DASH__GT_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_o)), kw_doc, "Constructs a data representation for a Throwable with keys:\n    :cause - root cause message\n    :phase - error phase\n    :via - cause chain, with cause keys:\n             :type - exception class symbol\n             :message - exception message\n             :data - ex-data\n             :at - top stack element\n    :trace - root cause stack elements", kw_file, "glojure/core_print.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(442), kw_end_DASH_line, int(442))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "base"
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v6 := args[0]
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_merge)
					tmp8 := checkDerefVar(var_glojure_DOT_core_symbol)
					tmp9 := checkDerefVar(var_glojure_DOT_core_class)
					tmp10 := lang.Apply(tmp9, []any{v6})
					tmp11, ok := lang.FieldOrMethod(tmp10, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp10, "Name")))
					}
					var tmp12 any
					switch reflect.TypeOf(tmp11).Kind() {
					case reflect.Func:
						tmp12 = lang.Apply(tmp11, nil)
					default:
						tmp12 = tmp11
					}
					tmp13 := lang.Apply(tmp8, []any{tmp12})
					tmp14 := lang.NewMap(kw_type, tmp13)
					tmp15 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(455), kw_column, int(23), kw_end_DASH_line, int(455), kw_end_DASH_column, int(56))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp17 any
					{ // let
						// let binding "temp__0__auto__"
						tmp18, ok := lang.FieldOrMethod(v6, "getLocalizedMessage")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "getLocalizedMessage")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						var v20 any = tmp19
						_ = v20
						var tmp21 any
						if lang.IsTruthy(v20) {
							var tmp22 any
							{ // let
								// let binding "msg"
								var v23 any = v20
								_ = v23
								tmp24 := lang.NewMap(kw_message, v23)
								tmp25 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(457), kw_column, int(20), kw_end_DASH_line, int(457), kw_end_DASH_column, int(33))
								tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp22 = tmp26
							} // end let
							tmp21 = tmp22
						} else {
						}
						tmp17 = tmp21
					} // end let
					var tmp18 any
					{ // let
						// let binding "temp__0__auto__"
						tmp19 := checkDerefVar(var_glojure_DOT_core_ex_DASH_data)
						tmp20 := lang.Apply(tmp19, []any{v6})
						var v21 any = tmp20
						_ = v21
						var tmp22 any
						if lang.IsTruthy(v21) {
							var tmp23 any
							{ // let
								// let binding "ed"
								var v24 any = v21
								_ = v24
								tmp25 := lang.NewMap(kw_data, v24)
								tmp26 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(459), kw_column, int(20), kw_end_DASH_line, int(459), kw_end_DASH_column, int(29))
								tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp23 = tmp27
							} // end let
							tmp22 = tmp23
						} else {
						}
						tmp18 = tmp22
					} // end let
					var tmp19 any
					{ // let
						// let binding "st"
						tmp20, ok := lang.FieldOrMethod(v6, "getStackTrace")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "getStackTrace")))
						}
						var tmp21 any
						switch reflect.TypeOf(tmp20).Kind() {
						case reflect.Func:
							tmp21 = lang.Apply(tmp20, nil)
						default:
							tmp21 = tmp20
						}
						var v22 any = tmp21
						_ = v22
						var tmp23 any
						tmp24 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp25 := checkDerefVar(var_glojure_DOT_core_alength)
						tmp26 := lang.Apply(tmp25, []any{v22})
						tmp27 := lang.Apply(tmp24, []any{tmp26})
						if lang.IsTruthy(tmp27) {
							tmp28 := checkDerefVar(var_glojure_DOT_core_StackTraceElement_DASH__GT_vec)
							tmp29 := checkDerefVar(var_glojure_DOT_core_aget)
							tmp30 := lang.Apply(tmp29, []any{v22, int64(0)})
							tmp31 := lang.Apply(tmp28, []any{tmp30})
							tmp32 := lang.NewMap(kw_at, tmp31)
							tmp33 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(462), kw_column, int(22), kw_end_DASH_line, int(462), kw_end_DASH_column, int(63))
							tmp34, err := lang.WithMeta(tmp32, tmp33.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp23 = tmp34
						} else {
						}
						tmp19 = tmp23
					} // end let
					tmp20 := lang.Apply(tmp7, []any{tmp16, tmp17, tmp18, tmp19})
					return tmp20
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(454), kw_column, int(14), kw_end_DASH_line, int(462), kw_end_DASH_column, int(67))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v8 any = tmp7
				_ = v8
				// let binding "via"
				var tmp9 any
				{ // let
					// let binding "via"
					tmp10 := lang.NewVector()
					tmp11 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(463), kw_column, int(24), kw_end_DASH_line, int(463), kw_end_DASH_column, int(25))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v13 any = tmp12
					_ = v13
					// let binding "t"
					var v14 any = v3
					_ = v14
					for {
						var tmp15 any
						if lang.IsTruthy(v14) {
							tmp17 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp18 := lang.Apply(tmp17, []any{v13, v14})
							var tmp16 any = tmp18
							tmp20, ok := lang.FieldOrMethod(v14, "getCause")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "getCause")))
							}
							var tmp21 any
							switch reflect.TypeOf(tmp20).Kind() {
							case reflect.Func:
								tmp21 = lang.Apply(tmp20, nil)
							default:
								tmp21 = tmp20
							}
							var tmp19 any = tmp21
							v13 = tmp16
							v14 = tmp19
							continue
						} else {
							tmp15 = v13
						}
						tmp9 = tmp15
						break
					}
				} // end let
				var v10 any = tmp9
				_ = v10
				// let binding "root"
				tmp11 := checkDerefVar(var_glojure_DOT_core_peek)
				tmp12 := lang.Apply(tmp11, []any{v10})
				var v13 any = tmp12
				_ = v13
				tmp14 := checkDerefVar(var_glojure_DOT_core_merge)
				tmp15 := checkDerefVar(var_glojure_DOT_core_vec)
				tmp16 := checkDerefVar(var_glojure_DOT_core_map)
				tmp17 := lang.Apply(tmp16, []any{v8, v10})
				tmp18 := lang.Apply(tmp15, []any{tmp17})
				tmp19 := checkDerefVar(var_glojure_DOT_core_vec)
				tmp20 := checkDerefVar(var_glojure_DOT_core_map)
				tmp21 := checkDerefVar(var_glojure_DOT_core_StackTraceElement_DASH__GT_vec)
				var tmp22 any
				{ // let
					// let binding "or__0__auto__"
					var v23 any = v13
					_ = v23
					var tmp24 any
					if lang.IsTruthy(v23) {
						tmp24 = v23
					} else {
						tmp24 = v3
					}
					tmp22 = tmp24
				} // end let
				tmp23, ok := lang.FieldOrMethod(tmp22, "getStackTrace")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp22, "getStackTrace")))
				}
				var tmp24 any
				switch reflect.TypeOf(tmp23).Kind() {
				case reflect.Func:
					tmp24 = lang.Apply(tmp23, nil)
				default:
					tmp24 = tmp23
				}
				tmp25 := lang.Apply(tmp20, []any{tmp21, tmp24})
				tmp26 := lang.Apply(tmp19, []any{tmp25})
				tmp27 := lang.NewMap(kw_via, tmp18, kw_trace, tmp26)
				tmp28 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(468), kw_column, int(12), kw_end_DASH_line, int(470), kw_end_DASH_column, int(111))
				tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp30 any
				{ // let
					// let binding "temp__0__auto__"
					tmp31, ok := lang.FieldOrMethod(v13, "getLocalizedMessage")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v13, "getLocalizedMessage")))
					}
					var tmp32 any
					switch reflect.TypeOf(tmp31).Kind() {
					case reflect.Func:
						tmp32 = lang.Apply(tmp31, nil)
					default:
						tmp32 = tmp31
					}
					var v33 any = tmp32
					_ = v33
					var tmp34 any
					if lang.IsTruthy(v33) {
						var tmp35 any
						{ // let
							// let binding "root-msg"
							var v36 any = v33
							_ = v36
							tmp37 := lang.NewMap(kw_cause, v36)
							tmp38 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(472), kw_column, int(9), kw_end_DASH_line, int(472), kw_end_DASH_column, int(25))
							tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp35 = tmp39
						} // end let
						tmp34 = tmp35
					} else {
					}
					tmp30 = tmp34
				} // end let
				var tmp31 any
				{ // let
					// let binding "temp__0__auto__"
					tmp32 := checkDerefVar(var_glojure_DOT_core_ex_DASH_data)
					tmp33 := lang.Apply(tmp32, []any{v13})
					var v34 any = tmp33
					_ = v34
					var tmp35 any
					if lang.IsTruthy(v34) {
						var tmp36 any
						{ // let
							// let binding "data"
							var v37 any = v34
							_ = v37
							tmp38 := lang.NewMap(kw_data, v37)
							tmp39 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(474), kw_column, int(9), kw_end_DASH_line, int(474), kw_end_DASH_column, int(20))
							tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp36 = tmp40
						} // end let
						tmp35 = tmp36
					} else {
					}
					tmp31 = tmp35
				} // end let
				var tmp32 any
				{ // let
					// let binding "temp__0__auto__"
					tmp33 := checkDerefVar(var_glojure_DOT_core_ex_DASH_data)
					tmp34 := lang.Apply(tmp33, []any{v3})
					tmp35 := lang.Apply(kw_glojure_DOT_error_SLASH_phase, []any{tmp34})
					var v36 any = tmp35
					_ = v36
					var tmp37 any
					if lang.IsTruthy(v36) {
						var tmp38 any
						{ // let
							// let binding "phase"
							var v39 any = v36
							_ = v39
							tmp40 := lang.NewMap(kw_phase, v39)
							tmp41 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(476), kw_column, int(9), kw_end_DASH_line, int(476), kw_end_DASH_column, int(22))
							tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp38 = tmp42
						} // end let
						tmp37 = tmp38
					} else {
					}
					tmp32 = tmp37
				} // end let
				tmp33 := lang.Apply(tmp14, []any{tmp29, tmp30, tmp31, tmp32})
				tmp4 = tmp33
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// abs
	{
		var tmp1 lang.FnFunc
		{ // function abs__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Abs})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_abs.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_inline, tmp1, kw_doc, "Returns the absolute value of a.\n  If a is Long/MIN_VALUE => Long/MIN_VALUE\n  If a is a double and zero => +0.0\n  If a is a double and ##Inf or ##-Inf => ##Inf\n  If a is a double and ##NaN => ##NaN", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1128), kw_end_DASH_line, int(1128))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Abs, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// accessor
	{
		tmp0 := sym_accessor.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_key)), kw_doc, "Returns a fn that, given an instance of a structmap with the basis,\n  returns the value at the key.  The key must be in the basis. The\n  returned function should be (slightly) more efficient than using\n  get, but such use of accessors should be limited to known\n  performance-critical areas.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4070), kw_end_DASH_line, int(4070))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(nil, "getAccessor")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("getAccessor is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aclone
	{
		var tmp1 lang.FnFunc
		{ // function aclone__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Aclone})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_aclone.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array)), kw_inline, tmp1, kw_doc, "Returns a clone of the Java array. Works on arrays of known\n  types.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3904), kw_end_DASH_line, int(3904))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime.RT, "Aclone")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Aclone is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-classpath
	{
		tmp0 := sym_add_DASH_classpath.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_url)), kw_doc, "DEPRECATED \n\n  Adds the url (String or URL object) to the classpath per\n  URLClassLoader.addURL", kw_file, "glojure/core.glj", kw_deprecated, "1.1", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(5176), kw_end_DASH_line, int(5176))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_println)
			tmp5 := lang.Apply(tmp4, []any{"WARNING: add-classpath is deprecated"})
			_ = tmp5
			tmp6 := lang.Apply(nil, []any{v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-doc-and-meta
	{
		tmp0 := sym_add_DASH_doc_DASH_and_DASH_meta.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_docstring, sym_meta)), kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(26), kw_column, int(11), kw_line, int(6400), kw_end_DASH_line, int(6400), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 5)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp10 := checkDerefVar(var_glojure_DOT_core_list)
			tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_alter_DASH_meta_BANG_})
			tmp12 := checkDerefVar(var_glojure_DOT_core_list)
			tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp15 := checkDerefVar(var_glojure_DOT_core_list)
			tmp16 := lang.Apply(tmp15, []any{sym_var})
			tmp17 := checkDerefVar(var_glojure_DOT_core_list)
			tmp18 := lang.Apply(tmp17, []any{v5})
			tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
			tmp20 := lang.Apply(tmp13, []any{tmp19})
			tmp21 := lang.Apply(tmp12, []any{tmp20})
			tmp22 := checkDerefVar(var_glojure_DOT_core_list)
			tmp23 := lang.Apply(tmp22, []any{sym_glojure_DOT_core_SLASH_merge})
			tmp24 := checkDerefVar(var_glojure_DOT_core_list)
			tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp27 := checkDerefVar(var_glojure_DOT_core_list)
			tmp28 := lang.Apply(tmp27, []any{sym_glojure_DOT_core_SLASH_assoc})
			tmp29 := checkDerefVar(var_glojure_DOT_core_list)
			tmp30 := lang.Apply(tmp29, []any{v7})
			tmp31 := checkDerefVar(var_glojure_DOT_core_list)
			tmp32 := lang.Apply(tmp31, []any{kw_doc})
			tmp33 := checkDerefVar(var_glojure_DOT_core_list)
			tmp34 := lang.Apply(tmp33, []any{v6})
			tmp35 := lang.Apply(tmp26, []any{tmp28, tmp30, tmp32, tmp34})
			tmp36 := lang.Apply(tmp25, []any{tmp35})
			tmp37 := lang.Apply(tmp24, []any{tmp36})
			tmp38 := lang.Apply(tmp9, []any{tmp11, tmp21, tmp23, tmp37})
			tmp39 := lang.Apply(tmp8, []any{tmp38})
			return tmp39
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-watch
	{
		tmp0 := sym_add_DASH_watch.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_reference, sym_key, sym_fn)), kw_doc, "Adds a watch function to an agent/atom/var/ref reference. The watch\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch fn\n  will be called synchronously, on the agent's thread if an agent,\n  before any pending sends if agent or ref. Note that an atom's or\n  ref's state may have changed again prior to the fn call, so use\n  old/new-state rather than derefing the reference. Note also that watch\n  fns may be called from multiple threads simultaneously. Var watchers\n  are triggered only by root binding changes, not thread-local\n  set!s. Keys must be unique per reference, and can be used to remove\n  the watch with remove-watch, but are otherwise considered opaque by\n  the watch mechanism.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2142), kw_end_DASH_line, int(2142))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(v3, "addWatch")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("addWatch is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// agent
	{
		tmp0 := sym_agent.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_state, sym__AMP_, sym_options)), kw_doc, "Creates and returns an agent with an initial value of state and\n  zero or more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :error-handler handler-fn\n\n  :error-mode mode-keyword\n\n  If metadata-map is supplied, it will become the metadata on the\n  agent. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.  handler-fn is called if an\n  action throws an exception or if validate-fn rejects a new state --\n  see set-error-handler! for details.  The mode-keyword may be either\n  :continue (the default if an error-handler is given) or :fail (the\n  default if no error-handler is given) -- see set-error-mode! for\n  details.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(2052), kw_end_DASH_line, int(2052))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "a"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					// let binding "opts"
					tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp8 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
					var v10 any = tmp9
					_ = v10
					tmp11 := checkDerefVar(var_glojure_DOT_core_setup_DASH_reference)
					tmp12 := lang.Apply(tmp11, []any{v6, v4})
					_ = tmp12
					var tmp13 any
					tmp14 := lang.Apply(kw_error_DASH_handler, []any{v10})
					if lang.IsTruthy(tmp14) {
						tmp15 := lang.Apply(kw_error_DASH_handler, []any{v10})
						tmp16, _ := lang.FieldOrMethod(v6, "setErrorHandler")
						if reflect.TypeOf(tmp16).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorHandler is not a function")))
						}
						tmp17 := lang.Apply(tmp16, []any{tmp15})
						tmp13 = tmp17
					} else {
					}
					_ = tmp13
					var tmp18 any
					{ // let
						// let binding "or__0__auto__"
						tmp19 := lang.Apply(kw_error_DASH_mode, []any{v10})
						var v20 any = tmp19
						_ = v20
						var tmp21 any
						if lang.IsTruthy(v20) {
							tmp21 = v20
						} else {
							var tmp22 any
							tmp23 := lang.Apply(kw_error_DASH_handler, []any{v10})
							if lang.IsTruthy(tmp23) {
								tmp22 = kw_continue
							} else {
								tmp22 = kw_fail
							}
							tmp21 = tmp22
						}
						tmp18 = tmp21
					} // end let
					tmp19, _ := lang.FieldOrMethod(v6, "setErrorMode")
					if reflect.TypeOf(tmp19).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorMode is not a function")))
					}
					tmp20 := lang.Apply(tmp19, []any{tmp18})
					_ = tmp20
					tmp5 = v6
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// agent-error
	{
		tmp0 := sym_agent_DASH_error.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_doc, "Returns the exception thrown during an asynchronous action of the\n  agent if the agent is failed.  Returns nil if the agent is not\n  failed.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(2167), kw_end_DASH_line, int(2167))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getError")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getError")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// agent-errors
	{
		tmp0 := sym_agent_DASH_errors.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_doc, "DEPRECATED: Use 'agent-error' instead.\n  Returns a sequence of the exceptions thrown during asynchronous\n  actions of the agent.", kw_file, "glojure/core.glj", kw_deprecated, "1.2", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(2234), kw_end_DASH_line, int(2234))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_agent_DASH_error)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "e"
						var v10 any = v7
						_ = v10
						tmp11 := checkDerefVar(var_glojure_DOT_core_list)
						tmp12 := lang.Apply(tmp11, []any{v10})
						tmp9 = tmp12
					} // end let
					tmp8 = tmp9
				} else {
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aget
	{
		var tmp1 lang.FnFunc
		{ // function aget__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Aget})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp21 := checkDerefVar(var_glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{sym_glojure_DOT_core_SLASH_int})
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := lang.Apply(tmp23, []any{v4})
				tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
				tmp26 := lang.Apply(tmp19, []any{tmp25})
				tmp27 := lang.Apply(tmp18, []any{tmp26})
				tmp28 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp27})
				tmp29 := lang.Apply(tmp12, []any{tmp28})
				tmp30 := lang.Apply(tmp11, []any{tmp29})
				tmp31 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp30})
				tmp32 := lang.Apply(tmp5, []any{tmp31})
				return tmp32
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_aget.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx), lang.NewVector(sym_array, sym_idx, sym__AMP_, sym_idxs)), kw_inline, tmp1, kw_doc, "Returns the value at the index/indices. Works on Java arrays of all\n  types.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3911), kw_end_DASH_line, int(3911))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.Get, []any{v4, v5})
				return tmp6
			default:
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp9 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v6})
				return tmp11
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alength
	{
		var tmp1 lang.FnFunc
		{ // function alength__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Alength})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_alength.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array)), kw_inline, tmp1, kw_doc, "Returns the length of the Java array. Works on arrays of all\n  types.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3897), kw_end_DASH_line, int(3897))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime.RT, "Alength")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Alength is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alias
	{
		tmp0 := sym_alias.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_alias, sym_namespace_DASH_sym)), kw_doc, "Add an alias in the current namespace to another\n  namespace. Arguments are two symbols: the alias to be used, and\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\n  to calling this directly.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(4263), kw_end_DASH_line, int(4263))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
			tmp6 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp7 := lang.Apply(tmp6, []any{v4})
			tmp8, _ := lang.FieldOrMethod(tmp5, "AddAlias")
			if reflect.TypeOf(tmp8).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddAlias is not a function")))
			}
			tmp9 := lang.Apply(tmp8, []any{v3, tmp7})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// all-ns
	{
		tmp0 := sym_all_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a sequence of all namespaces.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4146), kw_end_DASH_line, int(4146))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := lang.Apply(nil, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter
	{
		tmp0 := sym_alter.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref, sym_fun, sym__AMP_, sym_args)), kw_doc, "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(2435), kw_end_DASH_line, int(2435))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "alter")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("alter is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter-meta!
	{
		tmp0 := sym_alter_DASH_meta_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_iref, sym_f, sym__AMP_, sym_args)), kw_doc, "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(2398), kw_end_DASH_line, int(2398))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "AlterMeta")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("AlterMeta is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter-var-root
	{
		tmp0 := sym_alter_DASH_var_DASH_root.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_v, sym_f, sym__AMP_, sym_args)), kw_doc, "Atomically alters the root binding of var v by applying f to its\n  current value plus any args", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(5484), kw_end_DASH_line, int(5484))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "alterRoot")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("alterRoot is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// amap
	{
		tmp0 := sym_amap.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_idx, sym_ret, sym_expr)), kw_doc, "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting \n  each element of ret to the evaluation of expr, returning the new \n  array ret.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(5273), kw_end_DASH_line, int(5273))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 6)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			v8 := args[5]
			_ = v8
			tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp10 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp11 := checkDerefVar(var_glojure_DOT_core_list)
			tmp12 := lang.Apply(tmp11, []any{sym_glojure_DOT_core_SLASH_let})
			tmp13 := checkDerefVar(var_glojure_DOT_core_list)
			tmp14 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp15 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp17 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp18 := checkDerefVar(var_glojure_DOT_core_list)
			tmp19 := lang.Apply(tmp18, []any{sym_a__0__auto__})
			tmp20 := checkDerefVar(var_glojure_DOT_core_list)
			tmp21 := lang.Apply(tmp20, []any{v5})
			tmp22 := checkDerefVar(var_glojure_DOT_core_list)
			tmp23 := lang.Apply(tmp22, []any{sym_l__1__auto__})
			tmp24 := checkDerefVar(var_glojure_DOT_core_list)
			tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp27 := checkDerefVar(var_glojure_DOT_core_list)
			tmp28 := lang.Apply(tmp27, []any{sym_glojure_DOT_core_SLASH_alength})
			tmp29 := checkDerefVar(var_glojure_DOT_core_list)
			tmp30 := lang.Apply(tmp29, []any{sym_a__0__auto__})
			tmp31 := lang.Apply(tmp26, []any{tmp28, tmp30})
			tmp32 := lang.Apply(tmp25, []any{tmp31})
			tmp33 := lang.Apply(tmp24, []any{tmp32})
			tmp34 := checkDerefVar(var_glojure_DOT_core_list)
			tmp35 := lang.Apply(tmp34, []any{v7})
			tmp36 := checkDerefVar(var_glojure_DOT_core_list)
			tmp37 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp38 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp39 := checkDerefVar(var_glojure_DOT_core_list)
			tmp40 := lang.Apply(tmp39, []any{sym_glojure_DOT_core_SLASH_aclone})
			tmp41 := checkDerefVar(var_glojure_DOT_core_list)
			tmp42 := lang.Apply(tmp41, []any{sym_a__0__auto__})
			tmp43 := lang.Apply(tmp38, []any{tmp40, tmp42})
			tmp44 := lang.Apply(tmp37, []any{tmp43})
			tmp45 := lang.Apply(tmp36, []any{tmp44})
			tmp46 := lang.Apply(tmp17, []any{tmp19, tmp21, tmp23, tmp33, tmp35, tmp45})
			tmp47 := lang.Apply(tmp16, []any{tmp46})
			tmp48 := lang.Apply(tmp14, []any{tmp15, tmp47})
			tmp49 := lang.Apply(tmp13, []any{tmp48})
			tmp50 := checkDerefVar(var_glojure_DOT_core_list)
			tmp51 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp52 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp53 := checkDerefVar(var_glojure_DOT_core_list)
			tmp54 := lang.Apply(tmp53, []any{sym_glojure_DOT_core_SLASH_loop})
			tmp55 := checkDerefVar(var_glojure_DOT_core_list)
			tmp56 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp57 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp58 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp59 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp60 := checkDerefVar(var_glojure_DOT_core_list)
			tmp61 := lang.Apply(tmp60, []any{v6})
			tmp62 := checkDerefVar(var_glojure_DOT_core_list)
			tmp63 := lang.Apply(tmp62, []any{int64(0)})
			tmp64 := lang.Apply(tmp59, []any{tmp61, tmp63})
			tmp65 := lang.Apply(tmp58, []any{tmp64})
			tmp66 := lang.Apply(tmp56, []any{tmp57, tmp65})
			tmp67 := lang.Apply(tmp55, []any{tmp66})
			tmp68 := checkDerefVar(var_glojure_DOT_core_list)
			tmp69 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp70 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp71 := checkDerefVar(var_glojure_DOT_core_list)
			tmp72 := lang.Apply(tmp71, []any{sym_if})
			tmp73 := checkDerefVar(var_glojure_DOT_core_list)
			tmp74 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp75 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp76 := checkDerefVar(var_glojure_DOT_core_list)
			tmp77 := lang.Apply(tmp76, []any{sym_glojure_DOT_core_SLASH__LT_})
			tmp78 := checkDerefVar(var_glojure_DOT_core_list)
			tmp79 := lang.Apply(tmp78, []any{v6})
			tmp80 := checkDerefVar(var_glojure_DOT_core_list)
			tmp81 := lang.Apply(tmp80, []any{sym_l__1__auto__})
			tmp82 := lang.Apply(tmp75, []any{tmp77, tmp79, tmp81})
			tmp83 := lang.Apply(tmp74, []any{tmp82})
			tmp84 := lang.Apply(tmp73, []any{tmp83})
			tmp85 := checkDerefVar(var_glojure_DOT_core_list)
			tmp86 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp87 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp88 := checkDerefVar(var_glojure_DOT_core_list)
			tmp89 := lang.Apply(tmp88, []any{sym_do})
			tmp90 := checkDerefVar(var_glojure_DOT_core_list)
			tmp91 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp92 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp93 := checkDerefVar(var_glojure_DOT_core_list)
			tmp94 := lang.Apply(tmp93, []any{sym_glojure_DOT_core_SLASH_aset})
			tmp95 := checkDerefVar(var_glojure_DOT_core_list)
			tmp96 := lang.Apply(tmp95, []any{v7})
			tmp97 := checkDerefVar(var_glojure_DOT_core_list)
			tmp98 := lang.Apply(tmp97, []any{v6})
			tmp99 := checkDerefVar(var_glojure_DOT_core_list)
			tmp100 := lang.Apply(tmp99, []any{v8})
			tmp101 := lang.Apply(tmp92, []any{tmp94, tmp96, tmp98, tmp100})
			tmp102 := lang.Apply(tmp91, []any{tmp101})
			tmp103 := lang.Apply(tmp90, []any{tmp102})
			tmp104 := checkDerefVar(var_glojure_DOT_core_list)
			tmp105 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp106 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp107 := checkDerefVar(var_glojure_DOT_core_list)
			tmp108 := lang.Apply(tmp107, []any{sym_recur})
			tmp109 := checkDerefVar(var_glojure_DOT_core_list)
			tmp110 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp111 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp112 := checkDerefVar(var_glojure_DOT_core_list)
			tmp113 := lang.Apply(tmp112, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc})
			tmp114 := checkDerefVar(var_glojure_DOT_core_list)
			tmp115 := lang.Apply(tmp114, []any{v6})
			tmp116 := lang.Apply(tmp111, []any{tmp113, tmp115})
			tmp117 := lang.Apply(tmp110, []any{tmp116})
			tmp118 := lang.Apply(tmp109, []any{tmp117})
			tmp119 := lang.Apply(tmp106, []any{tmp108, tmp118})
			tmp120 := lang.Apply(tmp105, []any{tmp119})
			tmp121 := lang.Apply(tmp104, []any{tmp120})
			tmp122 := lang.Apply(tmp87, []any{tmp89, tmp103, tmp121})
			tmp123 := lang.Apply(tmp86, []any{tmp122})
			tmp124 := lang.Apply(tmp85, []any{tmp123})
			tmp125 := checkDerefVar(var_glojure_DOT_core_list)
			tmp126 := lang.Apply(tmp125, []any{v7})
			tmp127 := lang.Apply(tmp70, []any{tmp72, tmp84, tmp124, tmp126})
			tmp128 := lang.Apply(tmp69, []any{tmp127})
			tmp129 := lang.Apply(tmp68, []any{tmp128})
			tmp130 := lang.Apply(tmp52, []any{tmp54, tmp67, tmp129})
			tmp131 := lang.Apply(tmp51, []any{tmp130})
			tmp132 := lang.Apply(tmp50, []any{tmp131})
			tmp133 := lang.Apply(tmp10, []any{tmp12, tmp49, tmp132})
			tmp134 := lang.Apply(tmp9, []any{tmp133})
			return tmp134
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ancestors
	{
		tmp0 := sym_ancestors.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag), lang.NewVector(sym_h, sym_tag)), kw_doc, "Returns the immediate and indirect parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(5577), kw_end_DASH_line, int(5577))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_ancestors)
				tmp5 := checkDerefVar(var_glojure_DOT_core_global_DASH_hierarchy)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
				var tmp6 any
				{ // let
					// let binding "ta"
					tmp7 := checkDerefVar(var_glojure_DOT_core_get)
					tmp8 := lang.Apply(kw_ancestors, []any{v3})
					tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					tmp12 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
					tmp13 := lang.Apply(tmp12, []any{v4})
					if lang.IsTruthy(tmp13) {
						var tmp14 any
						{ // let
							// let binding "superclasses"
							tmp15 := checkDerefVar(var_glojure_DOT_core_set)
							tmp16 := checkDerefVar(var_glojure_DOT_core_supers)
							tmp17 := lang.Apply(tmp16, []any{v4})
							tmp18 := lang.Apply(tmp15, []any{tmp17})
							var v19 any = tmp18
							_ = v19
							tmp20 := checkDerefVar(var_glojure_DOT_core_reduce1)
							tmp21 := checkDerefVar(var_glojure_DOT_core_into1)
							tmp22 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp23 := checkDerefVar(var_glojure_DOT_core_map)
							var tmp24 lang.FnFunc
							tmp24 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v25 := args[0]
								_ = v25
								tmp26 := checkDerefVar(var_glojure_DOT_core_get)
								tmp27 := lang.Apply(kw_ancestors, []any{v3})
								tmp28 := lang.Apply(tmp26, []any{tmp27, v25})
								return tmp28
							})
							tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5590), kw_column, int(32), kw_end_DASH_line, int(5590), kw_end_DASH_column, int(54))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp27 := lang.Apply(tmp23, []any{tmp26, v19})
							tmp28 := lang.Apply(tmp22, []any{v10, tmp27})
							tmp29 := lang.Apply(tmp20, []any{tmp21, v19, tmp28})
							tmp14 = tmp29
						} // end let
						tmp11 = tmp14
					} else {
						tmp11 = v10
					}
					tmp6 = tmp11
				} // end let
				tmp7 := lang.Apply(tmp5, []any{tmp6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// and
	{
		tmp0 := sym_and.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_next)), kw_doc, "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(11), kw_line, int(835), kw_end_DASH_line, int(835))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return true
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				return v5
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_let})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp13 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{sym_and__0__auto__})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v5})
				tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
				tmp21 := lang.Apply(tmp14, []any{tmp20})
				tmp22 := lang.Apply(tmp12, []any{tmp13, tmp21})
				tmp23 := lang.Apply(tmp11, []any{tmp22})
				tmp24 := checkDerefVar(var_glojure_DOT_core_list)
				tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp27 := checkDerefVar(var_glojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{sym_if})
				tmp29 := checkDerefVar(var_glojure_DOT_core_list)
				tmp30 := lang.Apply(tmp29, []any{sym_and__0__auto__})
				tmp31 := checkDerefVar(var_glojure_DOT_core_list)
				tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp33 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp34 := checkDerefVar(var_glojure_DOT_core_list)
				tmp35 := lang.Apply(tmp34, []any{sym_glojure_DOT_core_SLASH_and})
				tmp36 := lang.Apply(tmp33, []any{tmp35, v6})
				tmp37 := lang.Apply(tmp32, []any{tmp36})
				tmp38 := lang.Apply(tmp31, []any{tmp37})
				tmp39 := checkDerefVar(var_glojure_DOT_core_list)
				tmp40 := lang.Apply(tmp39, []any{sym_and__0__auto__})
				tmp41 := lang.Apply(tmp26, []any{tmp28, tmp30, tmp38, tmp40})
				tmp42 := lang.Apply(tmp25, []any{tmp41})
				tmp43 := lang.Apply(tmp24, []any{tmp42})
				tmp44 := lang.Apply(tmp8, []any{tmp10, tmp23, tmp43})
				tmp45 := lang.Apply(tmp7, []any{tmp44})
				return tmp45
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// any?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_any_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true given any argument.", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(537), kw_end_DASH_line, int(537))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			return true
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// apply
	{
		tmp0 := sym_apply.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_args), lang.NewVector(sym_f, sym_x, sym_args), lang.NewVector(sym_f, sym_x, sym_y, sym_args), lang.NewVector(sym_f, sym_x, sym_y, sym_z, sym_args), lang.NewVector(sym_f, sym_a, sym_b, sym_c, sym_d, sym__AMP_, sym_args)), kw_doc, "Applies fn f to the argument list formed by prepending intervening arguments to args.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(653), kw_end_DASH_line, int(653))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7 := lang.Apply(lang.Apply, []any{v3, tmp6})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				tmp8 := lang.Apply(lang.Apply, []any{v3, tmp7})
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp8 := lang.Apply(tmp7, []any{v4, v5, v6})
				tmp9 := lang.Apply(lang.Apply, []any{v3, tmp8})
				return tmp9
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5, v6, v7})
				tmp10 := lang.Apply(lang.Apply, []any{v3, tmp9})
				return tmp10
			default:
				checkArity(args, 5)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var v8 any = lang.NewList(args[5:]...)
				_ = v8
				tmp9 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp10 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp11 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp12 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp13 := checkDerefVar(var_glojure_DOT_core_spread)
				tmp14 := lang.Apply(tmp13, []any{v8})
				tmp15 := lang.Apply(tmp12, []any{v7, tmp14})
				tmp16 := lang.Apply(tmp11, []any{v6, tmp15})
				tmp17 := lang.Apply(tmp10, []any{v5, tmp16})
				tmp18 := lang.Apply(tmp9, []any{v4, tmp17})
				tmp19 := lang.Apply(lang.Apply, []any{v3, tmp18})
				return tmp19
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// areduce
	{
		tmp0 := sym_areduce.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_idx, sym_ret, sym_init, sym_expr)), kw_doc, "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the \n  evaluation of expr at each step, returning ret.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(5289), kw_end_DASH_line, int(5289))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 7)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			v8 := args[5]
			_ = v8
			v9 := args[6]
			_ = v9
			tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp11 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp12 := checkDerefVar(var_glojure_DOT_core_list)
			tmp13 := lang.Apply(tmp12, []any{sym_glojure_DOT_core_SLASH_let})
			tmp14 := checkDerefVar(var_glojure_DOT_core_list)
			tmp15 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp16 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp19 := checkDerefVar(var_glojure_DOT_core_list)
			tmp20 := lang.Apply(tmp19, []any{sym_a__0__auto__})
			tmp21 := checkDerefVar(var_glojure_DOT_core_list)
			tmp22 := lang.Apply(tmp21, []any{v5})
			tmp23 := checkDerefVar(var_glojure_DOT_core_list)
			tmp24 := lang.Apply(tmp23, []any{sym_l__1__auto__})
			tmp25 := checkDerefVar(var_glojure_DOT_core_list)
			tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp27 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp28 := checkDerefVar(var_glojure_DOT_core_list)
			tmp29 := lang.Apply(tmp28, []any{sym_glojure_DOT_core_SLASH_alength})
			tmp30 := checkDerefVar(var_glojure_DOT_core_list)
			tmp31 := lang.Apply(tmp30, []any{sym_a__0__auto__})
			tmp32 := lang.Apply(tmp27, []any{tmp29, tmp31})
			tmp33 := lang.Apply(tmp26, []any{tmp32})
			tmp34 := lang.Apply(tmp25, []any{tmp33})
			tmp35 := lang.Apply(tmp18, []any{tmp20, tmp22, tmp24, tmp34})
			tmp36 := lang.Apply(tmp17, []any{tmp35})
			tmp37 := lang.Apply(tmp15, []any{tmp16, tmp36})
			tmp38 := lang.Apply(tmp14, []any{tmp37})
			tmp39 := checkDerefVar(var_glojure_DOT_core_list)
			tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp41 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp42 := checkDerefVar(var_glojure_DOT_core_list)
			tmp43 := lang.Apply(tmp42, []any{sym_glojure_DOT_core_SLASH_loop})
			tmp44 := checkDerefVar(var_glojure_DOT_core_list)
			tmp45 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp46 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp49 := checkDerefVar(var_glojure_DOT_core_list)
			tmp50 := lang.Apply(tmp49, []any{v6})
			tmp51 := checkDerefVar(var_glojure_DOT_core_list)
			tmp52 := lang.Apply(tmp51, []any{int64(0)})
			tmp53 := checkDerefVar(var_glojure_DOT_core_list)
			tmp54 := lang.Apply(tmp53, []any{v7})
			tmp55 := checkDerefVar(var_glojure_DOT_core_list)
			tmp56 := lang.Apply(tmp55, []any{v8})
			tmp57 := lang.Apply(tmp48, []any{tmp50, tmp52, tmp54, tmp56})
			tmp58 := lang.Apply(tmp47, []any{tmp57})
			tmp59 := lang.Apply(tmp45, []any{tmp46, tmp58})
			tmp60 := lang.Apply(tmp44, []any{tmp59})
			tmp61 := checkDerefVar(var_glojure_DOT_core_list)
			tmp62 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp63 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp64 := checkDerefVar(var_glojure_DOT_core_list)
			tmp65 := lang.Apply(tmp64, []any{sym_if})
			tmp66 := checkDerefVar(var_glojure_DOT_core_list)
			tmp67 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp68 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp69 := checkDerefVar(var_glojure_DOT_core_list)
			tmp70 := lang.Apply(tmp69, []any{sym_glojure_DOT_core_SLASH__LT_})
			tmp71 := checkDerefVar(var_glojure_DOT_core_list)
			tmp72 := lang.Apply(tmp71, []any{v6})
			tmp73 := checkDerefVar(var_glojure_DOT_core_list)
			tmp74 := lang.Apply(tmp73, []any{sym_l__1__auto__})
			tmp75 := lang.Apply(tmp68, []any{tmp70, tmp72, tmp74})
			tmp76 := lang.Apply(tmp67, []any{tmp75})
			tmp77 := lang.Apply(tmp66, []any{tmp76})
			tmp78 := checkDerefVar(var_glojure_DOT_core_list)
			tmp79 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp80 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp81 := checkDerefVar(var_glojure_DOT_core_list)
			tmp82 := lang.Apply(tmp81, []any{sym_recur})
			tmp83 := checkDerefVar(var_glojure_DOT_core_list)
			tmp84 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp85 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp86 := checkDerefVar(var_glojure_DOT_core_list)
			tmp87 := lang.Apply(tmp86, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc_DASH_int})
			tmp88 := checkDerefVar(var_glojure_DOT_core_list)
			tmp89 := lang.Apply(tmp88, []any{v6})
			tmp90 := lang.Apply(tmp85, []any{tmp87, tmp89})
			tmp91 := lang.Apply(tmp84, []any{tmp90})
			tmp92 := lang.Apply(tmp83, []any{tmp91})
			tmp93 := checkDerefVar(var_glojure_DOT_core_list)
			tmp94 := lang.Apply(tmp93, []any{v9})
			tmp95 := lang.Apply(tmp80, []any{tmp82, tmp92, tmp94})
			tmp96 := lang.Apply(tmp79, []any{tmp95})
			tmp97 := lang.Apply(tmp78, []any{tmp96})
			tmp98 := checkDerefVar(var_glojure_DOT_core_list)
			tmp99 := lang.Apply(tmp98, []any{v7})
			tmp100 := lang.Apply(tmp63, []any{tmp65, tmp77, tmp97, tmp99})
			tmp101 := lang.Apply(tmp62, []any{tmp100})
			tmp102 := lang.Apply(tmp61, []any{tmp101})
			tmp103 := lang.Apply(tmp41, []any{tmp43, tmp60, tmp102})
			tmp104 := lang.Apply(tmp40, []any{tmp103})
			tmp105 := lang.Apply(tmp39, []any{tmp104})
			tmp106 := lang.Apply(tmp11, []any{tmp13, tmp38, tmp105})
			tmp107 := lang.Apply(tmp10, []any{tmp106})
			return tmp107
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// array
	{
		tmp0 := sym_array.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(3457), kw_column, int(7), kw_end_DASH_line, int(3458), kw_end_DASH_column, int(7), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_items)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_into_DASH_array)
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// array-map
	{
		tmp0 := sym_array_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym__AMP_, sym_keyvals)), kw_doc, "Constructs an array-map. If any keys are equal, they are handled as\n  if by repeated uses of assoc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4378), kw_end_DASH_line, int(4378))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3, ok := lang.FieldOrMethod(nil, "EMPTY")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "EMPTY")))
				}
				var tmp4 any
				switch reflect.TypeOf(tmp3).Kind() {
				case reflect.Func:
					tmp4 = lang.Apply(tmp3, nil)
				default:
					tmp4 = tmp3
				}
				return tmp4
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "ary"
					tmp5 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
					tmp6 := lang.Apply(tmp5, []any{v3})
					var v7 any = tmp6
					_ = v7
					var tmp8 any
					tmp9 := checkDerefVar(var_glojure_DOT_core_odd_QMARK_)
					tmp10 := checkDerefVar(var_glojure_DOT_core_alength)
					tmp11 := lang.Apply(tmp10, []any{v7})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(var_glojure_DOT_core_str)
						tmp14 := checkDerefVar(var_glojure_DOT_core_last)
						tmp15 := lang.Apply(tmp14, []any{v3})
						tmp16 := lang.Apply(tmp13, []any{"No value supplied for key: ", tmp15})
						tmp17 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp16})
						panic(tmp17)
					} else {
						tmp18 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{v7})
						tmp8 = tmp18
					}
					tmp4 = tmp8
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// as->
	{
		tmp0 := sym_as_DASH__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr, sym_name, sym__AMP_, sym_forms)), kw_doc, "Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form.", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(7598), kw_end_DASH_line, int(7598))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 4)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_let})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp14 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v6})
				tmp19 := checkDerefVar(var_glojure_DOT_core_list)
				tmp20 := lang.Apply(tmp19, []any{v5})
				tmp21 := checkDerefVar(var_glojure_DOT_core_interleave)
				tmp22 := checkDerefVar(var_glojure_DOT_core_repeat)
				tmp23 := lang.Apply(tmp22, []any{v6})
				tmp24 := checkDerefVar(var_glojure_DOT_core_butlast)
				tmp25 := lang.Apply(tmp24, []any{v7})
				tmp26 := lang.Apply(tmp21, []any{tmp23, tmp25})
				tmp27 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp26})
				tmp28 := lang.Apply(tmp15, []any{tmp27})
				tmp29 := lang.Apply(tmp13, []any{tmp14, tmp28})
				tmp30 := lang.Apply(tmp12, []any{tmp29})
				tmp31 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp32 any
				tmp33 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
				tmp34 := lang.Apply(tmp33, []any{v7})
				if lang.IsTruthy(tmp34) {
					tmp32 = v6
				} else {
					tmp35 := checkDerefVar(var_glojure_DOT_core_last)
					tmp36 := lang.Apply(tmp35, []any{v7})
					tmp32 = tmp36
				}
				tmp37 := lang.Apply(tmp31, []any{tmp32})
				tmp38 := lang.Apply(tmp9, []any{tmp11, tmp30, tmp37})
				tmp39 := lang.Apply(tmp8, []any{tmp38})
				return tmp39
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset
	{
		var tmp1 lang.FnFunc
		{ // function aset__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym__DOT_})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_Aset})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := checkDerefVar(var_glojure_DOT_core_list)
				tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp22 := checkDerefVar(var_glojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{sym_glojure_DOT_core_SLASH_int})
				tmp24 := checkDerefVar(var_glojure_DOT_core_list)
				tmp25 := lang.Apply(tmp24, []any{v4})
				tmp26 := lang.Apply(tmp21, []any{tmp23, tmp25})
				tmp27 := lang.Apply(tmp20, []any{tmp26})
				tmp28 := lang.Apply(tmp19, []any{tmp27})
				tmp29 := checkDerefVar(var_glojure_DOT_core_list)
				tmp30 := lang.Apply(tmp29, []any{v5})
				tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp28, tmp30})
				tmp32 := lang.Apply(tmp13, []any{tmp31})
				tmp33 := lang.Apply(tmp12, []any{tmp32})
				tmp34 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp33})
				tmp35 := lang.Apply(tmp6, []any{tmp34})
				return tmp35
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_aset.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_inline, tmp1, kw_doc, "Sets the value at the index/indices. Works on Java arrays of\n  reference types. Returns val.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(3)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3922), kw_end_DASH_line, int(3922))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(lang.SliceSet, []any{v4, v5, v6})
				_ = tmp7
				return v6
			default:
				checkArity(args, 3)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				var v7 any = lang.NewList(args[3:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp9 := checkDerefVar(var_glojure_DOT_core_aset)
				tmp10 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp11 := lang.Apply(tmp10, []any{v4, v5})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v6, v7})
				return tmp12
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-boolean
	{
		tmp0 := sym_aset_DASH_boolean.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of boolean. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(3), kw_line, int(3956), kw_end_DASH_line, int(3958))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_boolean)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setBoolean")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setBoolean is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aset_DASH_boolean)
				tmp9 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-byte
	{
		tmp0 := sym_aset_DASH_byte.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of byte. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(3), kw_line, int(3976), kw_end_DASH_line, int(3978))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_byte)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setByte")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setByte is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aset_DASH_byte)
				tmp9 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-char
	{
		tmp0 := sym_aset_DASH_char.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of char. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(3), kw_line, int(3981), kw_end_DASH_line, int(3983))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_char)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setChar")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setChar is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aset_DASH_char)
				tmp9 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-double
	{
		tmp0 := sym_aset_DASH_double.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of double. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(3), kw_line, int(3966), kw_end_DASH_line, int(3968))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_double)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setDouble")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setDouble is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aset_DASH_double)
				tmp9 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-float
	{
		tmp0 := sym_aset_DASH_float.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of float. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(3), kw_line, int(3961), kw_end_DASH_line, int(3963))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_float)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setFloat")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setFloat is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aset_DASH_float)
				tmp9 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-int
	{
		tmp0 := sym_aset_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of int. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(3), kw_line, int(3946), kw_end_DASH_line, int(3948))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_int)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setInt")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setInt is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aset_DASH_int)
				tmp9 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-long
	{
		tmp0 := sym_aset_DASH_long.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of long. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(3), kw_line, int(3951), kw_end_DASH_line, int(3953))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_long)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setLong")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setLong is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aset_DASH_long)
				tmp9 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-short
	{
		tmp0 := sym_aset_DASH_short.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_array, sym_idx, sym_val), lang.NewVector(sym_array, sym_idx, sym_idx2, sym__AMP_, sym_idxv)), kw_doc, "Sets the value at the index/indices. Works on arrays of short. Returns val.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(3), kw_line, int(3971), kw_end_DASH_line, int(3973))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_short)
				tmp7 := lang.Apply(tmp6, []any{v5})
				tmp8, _ := lang.FieldOrMethod(nil, "setShort")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setShort is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{v3, v4, tmp7})
				_ = tmp9
				return v5
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_aset_DASH_short)
				tmp9 := checkDerefVar(var_glojure_DOT_core_aget)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp7, []any{tmp8, tmp10, v5, v6})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert
	{
		tmp0 := sym_assert.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_message)), kw_doc, "Evaluates expression x and throws an AssertionError with optional\n  message if x does not evaluate to logical true.\n\n  Assertion checks are omitted from compiled code if '*assert*' is\n  false.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(4837), kw_end_DASH_line, int(4837))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_assert_STAR_)
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_when_DASH_not})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{v5})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_throw})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{sym_new})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{sym_glojure_DOT_core_SLASH_AssertionError})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp28 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp29 := checkDerefVar(var_glojure_DOT_core_list)
					tmp30 := lang.Apply(tmp29, []any{sym_glojure_DOT_core_SLASH_str})
					tmp31 := checkDerefVar(var_glojure_DOT_core_list)
					tmp32 := lang.Apply(tmp31, []any{"Assert failed: "})
					tmp33 := checkDerefVar(var_glojure_DOT_core_list)
					tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp35 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp36 := checkDerefVar(var_glojure_DOT_core_list)
					tmp37 := lang.Apply(tmp36, []any{sym_glojure_DOT_core_SLASH_pr_DASH_str})
					tmp38 := checkDerefVar(var_glojure_DOT_core_list)
					tmp39 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp40 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp41 := checkDerefVar(var_glojure_DOT_core_list)
					tmp42 := lang.Apply(tmp41, []any{sym_quote})
					tmp43 := checkDerefVar(var_glojure_DOT_core_list)
					tmp44 := lang.Apply(tmp43, []any{v5})
					tmp45 := lang.Apply(tmp40, []any{tmp42, tmp44})
					tmp46 := lang.Apply(tmp39, []any{tmp45})
					tmp47 := lang.Apply(tmp38, []any{tmp46})
					tmp48 := lang.Apply(tmp35, []any{tmp37, tmp47})
					tmp49 := lang.Apply(tmp34, []any{tmp48})
					tmp50 := lang.Apply(tmp33, []any{tmp49})
					tmp51 := lang.Apply(tmp28, []any{tmp30, tmp32, tmp50})
					tmp52 := lang.Apply(tmp27, []any{tmp51})
					tmp53 := lang.Apply(tmp26, []any{tmp52})
					tmp54 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp53})
					tmp55 := lang.Apply(tmp20, []any{tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp16, []any{tmp18, tmp56})
					tmp58 := lang.Apply(tmp15, []any{tmp57})
					tmp59 := lang.Apply(tmp14, []any{tmp58})
					tmp60 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp59})
					tmp61 := lang.Apply(tmp8, []any{tmp60})
					tmp6 = tmp61
				} else {
				}
				return tmp6
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core__STAR_assert_STAR_)
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp10 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_glojure_DOT_core_SLASH_when_DASH_not})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := lang.Apply(tmp13, []any{v5})
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp17 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{sym_throw})
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp22 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp23 := checkDerefVar(var_glojure_DOT_core_list)
					tmp24 := lang.Apply(tmp23, []any{sym_new})
					tmp25 := checkDerefVar(var_glojure_DOT_core_list)
					tmp26 := lang.Apply(tmp25, []any{sym_glojure_DOT_core_SLASH_AssertionError})
					tmp27 := checkDerefVar(var_glojure_DOT_core_list)
					tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp29 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp30 := checkDerefVar(var_glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{sym_glojure_DOT_core_SLASH_str})
					tmp32 := checkDerefVar(var_glojure_DOT_core_list)
					tmp33 := lang.Apply(tmp32, []any{"Assert failed: "})
					tmp34 := checkDerefVar(var_glojure_DOT_core_list)
					tmp35 := lang.Apply(tmp34, []any{v6})
					tmp36 := checkDerefVar(var_glojure_DOT_core_list)
					tmp37 := lang.Apply(tmp36, []any{"\n"})
					tmp38 := checkDerefVar(var_glojure_DOT_core_list)
					tmp39 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp40 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp41 := checkDerefVar(var_glojure_DOT_core_list)
					tmp42 := lang.Apply(tmp41, []any{sym_glojure_DOT_core_SLASH_pr_DASH_str})
					tmp43 := checkDerefVar(var_glojure_DOT_core_list)
					tmp44 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp45 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp46 := checkDerefVar(var_glojure_DOT_core_list)
					tmp47 := lang.Apply(tmp46, []any{sym_quote})
					tmp48 := checkDerefVar(var_glojure_DOT_core_list)
					tmp49 := lang.Apply(tmp48, []any{v5})
					tmp50 := lang.Apply(tmp45, []any{tmp47, tmp49})
					tmp51 := lang.Apply(tmp44, []any{tmp50})
					tmp52 := lang.Apply(tmp43, []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp42, tmp52})
					tmp54 := lang.Apply(tmp39, []any{tmp53})
					tmp55 := lang.Apply(tmp38, []any{tmp54})
					tmp56 := lang.Apply(tmp29, []any{tmp31, tmp33, tmp35, tmp37, tmp55})
					tmp57 := lang.Apply(tmp28, []any{tmp56})
					tmp58 := lang.Apply(tmp27, []any{tmp57})
					tmp59 := lang.Apply(tmp22, []any{tmp24, tmp26, tmp58})
					tmp60 := lang.Apply(tmp21, []any{tmp59})
					tmp61 := lang.Apply(tmp20, []any{tmp60})
					tmp62 := lang.Apply(tmp17, []any{tmp19, tmp61})
					tmp63 := lang.Apply(tmp16, []any{tmp62})
					tmp64 := lang.Apply(tmp15, []any{tmp63})
					tmp65 := lang.Apply(tmp10, []any{tmp12, tmp14, tmp64})
					tmp66 := lang.Apply(tmp9, []any{tmp65})
					tmp7 = tmp66
				} else {
				}
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert-args
	{
		tmp0 := sym_assert_DASH_args.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_pairs)), kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(38), kw_column, int(11), kw_line, int(1830), kw_end_DASH_line, int(1830), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_do})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_when_DASH_not})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := checkDerefVar(var_glojure_DOT_core_first)
				tmp17 := lang.Apply(tmp16, []any{v5})
				tmp18 := lang.Apply(tmp15, []any{tmp17})
				tmp19 := checkDerefVar(var_glojure_DOT_core_list)
				tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp22 := checkDerefVar(var_glojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{sym_throw})
				tmp24 := checkDerefVar(var_glojure_DOT_core_list)
				tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp27 := checkDerefVar(var_glojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewIllegalArgumentError})
				tmp29 := checkDerefVar(var_glojure_DOT_core_list)
				tmp30 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp31 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp32 := checkDerefVar(var_glojure_DOT_core_list)
				tmp33 := lang.Apply(tmp32, []any{sym_glojure_DOT_core_SLASH_str})
				tmp34 := checkDerefVar(var_glojure_DOT_core_list)
				tmp35 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp36 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp37 := checkDerefVar(var_glojure_DOT_core_list)
				tmp38 := lang.Apply(tmp37, []any{sym_glojure_DOT_core_SLASH_first})
				tmp39 := checkDerefVar(var_glojure_DOT_core_list)
				tmp40 := lang.Apply(tmp39, []any{sym__AMP_form})
				tmp41 := lang.Apply(tmp36, []any{tmp38, tmp40})
				tmp42 := lang.Apply(tmp35, []any{tmp41})
				tmp43 := lang.Apply(tmp34, []any{tmp42})
				tmp44 := checkDerefVar(var_glojure_DOT_core_list)
				tmp45 := lang.Apply(tmp44, []any{" requires "})
				tmp46 := checkDerefVar(var_glojure_DOT_core_list)
				tmp47 := checkDerefVar(var_glojure_DOT_core_second)
				tmp48 := lang.Apply(tmp47, []any{v5})
				tmp49 := lang.Apply(tmp46, []any{tmp48})
				tmp50 := checkDerefVar(var_glojure_DOT_core_list)
				tmp51 := lang.Apply(tmp50, []any{" in "})
				tmp52 := checkDerefVar(var_glojure_DOT_core_list)
				tmp53 := lang.Apply(tmp52, []any{sym__STAR_ns_STAR_})
				tmp54 := checkDerefVar(var_glojure_DOT_core_list)
				tmp55 := lang.Apply(tmp54, []any{":"})
				tmp56 := checkDerefVar(var_glojure_DOT_core_list)
				tmp57 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp58 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp59 := checkDerefVar(var_glojure_DOT_core_list)
				tmp60 := lang.Apply(tmp59, []any{kw_line})
				tmp61 := checkDerefVar(var_glojure_DOT_core_list)
				tmp62 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp63 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp64 := checkDerefVar(var_glojure_DOT_core_list)
				tmp65 := lang.Apply(tmp64, []any{sym_glojure_DOT_core_SLASH_meta})
				tmp66 := checkDerefVar(var_glojure_DOT_core_list)
				tmp67 := lang.Apply(tmp66, []any{sym__AMP_form})
				tmp68 := lang.Apply(tmp63, []any{tmp65, tmp67})
				tmp69 := lang.Apply(tmp62, []any{tmp68})
				tmp70 := lang.Apply(tmp61, []any{tmp69})
				tmp71 := lang.Apply(tmp58, []any{tmp60, tmp70})
				tmp72 := lang.Apply(tmp57, []any{tmp71})
				tmp73 := lang.Apply(tmp56, []any{tmp72})
				tmp74 := lang.Apply(tmp31, []any{tmp33, tmp43, tmp45, tmp49, tmp51, tmp53, tmp55, tmp73})
				tmp75 := lang.Apply(tmp30, []any{tmp74})
				tmp76 := lang.Apply(tmp29, []any{tmp75})
				tmp77 := lang.Apply(tmp26, []any{tmp28, tmp76})
				tmp78 := lang.Apply(tmp25, []any{tmp77})
				tmp79 := lang.Apply(tmp24, []any{tmp78})
				tmp80 := lang.Apply(tmp21, []any{tmp23, tmp79})
				tmp81 := lang.Apply(tmp20, []any{tmp80})
				tmp82 := lang.Apply(tmp19, []any{tmp81})
				tmp83 := lang.Apply(tmp12, []any{tmp14, tmp18, tmp82})
				tmp84 := lang.Apply(tmp11, []any{tmp83})
				tmp85 := lang.Apply(tmp10, []any{tmp84})
				tmp86 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp87 any
				{ // let
					// let binding "more"
					tmp88 := checkDerefVar(var_glojure_DOT_core_nnext)
					tmp89 := lang.Apply(tmp88, []any{v5})
					var v90 any = tmp89
					_ = v90
					var tmp91 any
					if lang.IsTruthy(v90) {
						tmp92 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
						tmp93 := lang.Apply(tmp92, []any{sym_glojure_DOT_core_SLASH_assert_DASH_args, v90})
						tmp91 = tmp93
					} else {
					}
					tmp87 = tmp91
				} // end let
				tmp88 := lang.Apply(tmp86, []any{tmp87})
				tmp89 := lang.Apply(tmp7, []any{tmp9, tmp85, tmp88})
				tmp90 := lang.Apply(tmp6, []any{tmp89})
				return tmp90
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert-valid-fdecl
	{
		tmp0 := sym_assert_DASH_valid_DASH_fdecl.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_fdecl)), kw_doc, "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(42), kw_column, int(8), kw_line, int(7502), kw_end_DASH_line, int(7502), kw_private, true, kw_dynamic, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := lang.Apply(lang.NewIllegalArgumentError, []any{"Parameter declaration missing"})
				panic(tmp7)
			} else {
			}
			_ = tmp4
			var tmp8 any
			{ // let
				// let binding "argdecls"
				tmp9 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v11 := args[0]
					_ = v11
					var tmp12 any
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
					tmp14 := lang.Apply(tmp13, []any{v11})
					if lang.IsTruthy(tmp14) {
						tmp15 := checkDerefVar(var_glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v11})
						tmp12 = tmp16
					} else {
						var tmp17 any
						tmp18 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp19 := checkDerefVar(var_glojure_DOT_core_first)
						tmp20 := lang.Apply(tmp19, []any{v3})
						tmp21 := lang.Apply(tmp18, []any{tmp20})
						if lang.IsTruthy(tmp21) {
							tmp22 := checkDerefVar(var_glojure_DOT_core_str)
							tmp23 := lang.Apply(tmp22, []any{"Invalid signature \"", v11, "\" should be a list"})
							tmp17 = tmp23
						} else {
							tmp24 := checkDerefVar(var_glojure_DOT_core_str)
							tmp25 := lang.Apply(tmp24, []any{"Parameter declaration \"", v11, "\" should be a vector"})
							tmp17 = tmp25
						}
						tmp26 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
						panic(tmp26)
					}
					return tmp12
				})
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7508), kw_column, int(20), kw_end_DASH_line, int(7517), kw_end_DASH_column, int(59))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := lang.Apply(tmp9, []any{tmp12, v3})
				var v14 any = tmp13
				_ = v14
				// let binding "bad-args"
				tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp16 := checkDerefVar(var_glojure_DOT_core_remove)
				var tmp17 lang.FnFunc
				tmp17 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v18 := args[0]
					_ = v18
					tmp19 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
					tmp20 := lang.Apply(tmp19, []any{v18})
					return tmp20
				})
				tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7519), kw_column, int(31), kw_end_DASH_line, int(7519), kw_end_DASH_column, int(42))
				tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp20 := lang.Apply(tmp16, []any{tmp19, v14})
				tmp21 := lang.Apply(tmp15, []any{tmp20})
				var v22 any = tmp21
				_ = v22
				var tmp23 any
				if lang.IsTruthy(v22) {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v22})
					tmp27 := lang.Apply(tmp24, []any{"Parameter declaration \"", tmp26, "\" should be a vector"})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				} else {
				}
				tmp8 = tmp23
			} // end let
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc
	{
		tmp0 := sym_assoc.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map, sym_key, sym_val), lang.NewVector(sym_map, sym_key, sym_val, sym__AMP_, sym_kvs)), kw_doc, "assoc[iate]. When applied to a map, returns a new map of the\n    same (hashed/sorted) type, that contains the mapping of key(s) to\n    val(s). When applied to a vector, returns a new vector that\n    contains val at index. Note - index must be <= (count vector).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(181), kw_end_DASH_line, int(188))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function assoc
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 3:
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					tmp7 := lang.Apply(lang.Assoc, []any{v4, v5, v6})
					return tmp7
				default:
					checkArity(args, 3)
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					var v7 any = lang.NewList(args[3:]...)
					_ = v7
				recur_loop_24:
					var tmp8 any
					{ // let
						// let binding "ret"
						tmp9 := lang.Apply(lang.Assoc, []any{v4, v5, v6})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v7) {
							var tmp12 any
							tmp13 := checkDerefVar(var_glojure_DOT_core_next)
							tmp14 := lang.Apply(tmp13, []any{v7})
							if lang.IsTruthy(tmp14) {
								var tmp15 any = v10
								tmp17 := checkDerefVar(var_glojure_DOT_core_first)
								tmp18 := lang.Apply(tmp17, []any{v7})
								var tmp16 any = tmp18
								tmp20 := checkDerefVar(var_glojure_DOT_core_second)
								tmp21 := lang.Apply(tmp20, []any{v7})
								var tmp19 any = tmp21
								tmp23 := checkDerefVar(var_glojure_DOT_core_nnext)
								tmp24 := lang.Apply(tmp23, []any{v7})
								var tmp22 any = tmp24
								v4 = tmp15
								v5 = tmp16
								v6 = tmp19
								v7 = tmp22
								goto recur_loop_24
							} else {
								tmp25 := lang.Apply(lang.NewIllegalArgumentError, []any{"assoc expects even number of arguments after map/vector, found odd number"})
								panic(tmp25)
							}
							tmp11 = tmp12
						} else {
							tmp11 = v10
						}
						tmp8 = tmp11
					} // end let
					return tmp8
				}
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(189), kw_column, int(2), kw_end_DASH_line, int(198), kw_end_DASH_column, int(15))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc!
	{
		tmp0 := sym_assoc_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_key, sym_val), lang.NewVector(sym_coll, sym_key, sym_val, sym__AMP_, sym_kvs)), kw_doc, "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3369), kw_end_DASH_line, int(3369))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "Assoc")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Assoc is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
			recur_loop_609:
				var tmp7 any
				{ // let
					// let binding "ret"
					tmp8, _ := lang.FieldOrMethod(v3, "Assoc")
					if reflect.TypeOf(tmp8).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Assoc is not a function")))
					}
					tmp9 := lang.Apply(tmp8, []any{v4, v5})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v6) {
						var tmp12 any = v10
						tmp14 := checkDerefVar(var_glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v6})
						var tmp13 any = tmp15
						tmp17 := checkDerefVar(var_glojure_DOT_core_second)
						tmp18 := lang.Apply(tmp17, []any{v6})
						var tmp16 any = tmp18
						tmp20 := checkDerefVar(var_glojure_DOT_core_nnext)
						tmp21 := lang.Apply(tmp20, []any{v6})
						var tmp19 any = tmp21
						v3 = tmp12
						v4 = tmp13
						v5 = tmp16
						v6 = tmp19
						goto recur_loop_609
					} else {
						tmp11 = v10
					}
					tmp7 = tmp11
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc-in
	{
		tmp0 := sym_assoc_DASH_in.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, lang.NewVector(sym_k, sym__AMP_, sym_ks), sym_v)), kw_doc, "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(6147), kw_end_DASH_line, int(6147))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "vec__138"
				var v7 any = v4
				_ = v7
				// let binding "seq__139"
				tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp9 := lang.Apply(tmp8, []any{v7})
				var v10 any = tmp9
				_ = v10
				// let binding "first__140"
				tmp11 := checkDerefVar(var_glojure_DOT_core_first)
				tmp12 := lang.Apply(tmp11, []any{v10})
				var v13 any = tmp12
				_ = v13
				// let binding "seq__139"
				tmp14 := checkDerefVar(var_glojure_DOT_core_next)
				tmp15 := lang.Apply(tmp14, []any{v10})
				var v16 any = tmp15
				_ = v16
				// let binding "k"
				var v17 any = v13
				_ = v17
				// let binding "ks"
				var v18 any = v16
				_ = v18
				var tmp19 any
				if lang.IsTruthy(v18) {
					tmp20 := checkDerefVar(var_glojure_DOT_core_assoc)
					tmp21 := checkDerefVar(var_glojure_DOT_core_assoc_DASH_in)
					tmp22 := checkDerefVar(var_glojure_DOT_core_get)
					tmp23 := lang.Apply(tmp22, []any{v3, v17})
					tmp24 := lang.Apply(tmp21, []any{tmp23, v18, v5})
					tmp25 := lang.Apply(tmp20, []any{v3, v17, tmp24})
					tmp19 = tmp25
				} else {
					tmp26 := checkDerefVar(var_glojure_DOT_core_assoc)
					tmp27 := lang.Apply(tmp26, []any{v3, v17, v5})
					tmp19 = tmp27
				}
				tmp6 = tmp19
			} // end let
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// associative?
	{
		tmp0 := sym_associative_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll implements Associative", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(6223), kw_end_DASH_line, int(6223))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// atom
	{
		tmp0 := sym_atom.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_options)), kw_doc, "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2325), kw_end_DASH_line, int(2325))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(lang.NewAtom, []any{v3})
				return tmp4
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_setup_DASH_reference)
				tmp6 := checkDerefVar(var_glojure_DOT_core_atom)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := lang.Apply(tmp5, []any{tmp7, v4})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await
	{
		tmp0 := sym_await.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_agents)), kw_doc, "Blocks the current thread (indefinitely!) until all actions\n  dispatched thus far, from this thread or agent, to the agent(s) have\n  occurred.  Will block on failed agents.  Will never return if\n  a failed agent is restarted with :clear-actions true or shutdown-agents was called.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3267), kw_end_DASH_line, int(3267))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				tmp5 := lang.Apply(nil, nil)
				if lang.IsTruthy(tmp5) {
					panic("unimplemented: new with non-constant class type")
				} else {
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_agent_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp8 := lang.Apply(errors8.New, []any{"Can't await in agent action"})
						panic(tmp8)
					} else {
					}
					_ = tmp6
					var tmp9 any
					{ // let
						// let binding "latch"
						var v10 any = "unimplemented: new with non-constant class type"
						_ = v10
						// let binding "count-down"
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v12 := args[0]
							_ = v12
							tmp13, _ := lang.FieldOrMethod(v10, "countDown")
							if reflect.TypeOf(tmp13).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("countDown is not a function")))
							}
							tmp14 := lang.Apply(tmp13, []any{})
							_ = tmp14
							return v12
						})
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3279), kw_column, int(22), kw_end_DASH_line, int(3279), kw_end_DASH_column, int(61))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v14 any = tmp13
						_ = v14
						var tmp15 any
						{ // let
							// let binding "seq_1"
							tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp17 := lang.Apply(tmp16, []any{v3})
							var v18 any = tmp17
							_ = v18
							// let binding "chunk_2"
							var v19 any = nil
							_ = v19
							// let binding "count_3"
							var v20 any = int64(0)
							_ = v20
							// let binding "i_4"
							var v21 any = int64(0)
							_ = v21
							for {
								var tmp22 any
								tmp23 := checkDerefVar(var_glojure_DOT_core__LT_)
								tmp24 := lang.Apply(tmp23, []any{v21, v20})
								if lang.IsTruthy(tmp24) {
									var tmp25 any
									{ // let
										// let binding "agent"
										tmp26, _ := lang.FieldOrMethod(v19, "nth")
										if reflect.TypeOf(tmp26).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
										}
										tmp27 := lang.Apply(tmp26, []any{v21})
										var v28 any = tmp27
										_ = v28
										tmp29 := checkDerefVar(var_glojure_DOT_core_send)
										tmp30 := lang.Apply(tmp29, []any{v28, v14})
										_ = tmp30
										var tmp31 any = v18
										var tmp32 any = v19
										var tmp33 any = v20
										tmp35 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
										tmp36 := lang.Apply(tmp35, []any{v21})
										var tmp34 any = tmp36
										v18 = tmp31
										v19 = tmp32
										v20 = tmp33
										v21 = tmp34
										continue
									} // end let
									tmp22 = tmp25
								} else {
									var tmp26 any
									{ // let
										// let binding "temp__0__auto__"
										tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp28 := lang.Apply(tmp27, []any{v18})
										var v29 any = tmp28
										_ = v29
										var tmp30 any
										if lang.IsTruthy(v29) {
											var tmp31 any
											{ // let
												// let binding "seq_1"
												var v32 any = v29
												_ = v32
												var tmp33 any
												tmp34 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
												tmp35 := lang.Apply(tmp34, []any{v32})
												if lang.IsTruthy(tmp35) {
													var tmp36 any
													{ // let
														// let binding "c__0__auto__"
														tmp37 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
														tmp38 := lang.Apply(tmp37, []any{v32})
														var v39 any = tmp38
														_ = v39
														tmp41 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
														tmp42 := lang.Apply(tmp41, []any{v32})
														var tmp40 any = tmp42
														var tmp43 any = v39
														tmp45 := checkDerefVar(var_glojure_DOT_core_int)
														tmp46 := checkDerefVar(var_glojure_DOT_core_count)
														tmp47 := lang.Apply(tmp46, []any{v39})
														tmp48 := lang.Apply(tmp45, []any{tmp47})
														var tmp44 any = tmp48
														tmp50 := checkDerefVar(var_glojure_DOT_core_int)
														tmp51 := lang.Apply(tmp50, []any{int64(0)})
														var tmp49 any = tmp51
														v18 = tmp40
														v19 = tmp43
														v20 = tmp44
														v21 = tmp49
														continue
													} // end let
													tmp33 = tmp36
												} else {
													var tmp37 any
													{ // let
														// let binding "agent"
														tmp38 := checkDerefVar(var_glojure_DOT_core_first)
														tmp39 := lang.Apply(tmp38, []any{v32})
														var v40 any = tmp39
														_ = v40
														tmp41 := checkDerefVar(var_glojure_DOT_core_send)
														tmp42 := lang.Apply(tmp41, []any{v40, v14})
														_ = tmp42
														tmp44 := checkDerefVar(var_glojure_DOT_core_next)
														tmp45 := lang.Apply(tmp44, []any{v32})
														var tmp43 any = tmp45
														var tmp46 any = nil
														var tmp47 any = int64(0)
														var tmp48 any = int64(0)
														v18 = tmp43
														v19 = tmp46
														v20 = tmp47
														v21 = tmp48
														continue
													} // end let
													tmp33 = tmp37
												}
												tmp31 = tmp33
											} // end let
											tmp30 = tmp31
										} else {
										}
										tmp26 = tmp30
									} // end let
									tmp22 = tmp26
								}
								tmp15 = tmp22
								break
							}
						} // end let
						_ = tmp15
						tmp16, _ := lang.FieldOrMethod(v10, "await")
						if reflect.TypeOf(tmp16).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
						}
						tmp17 := lang.Apply(tmp16, []any{})
						tmp9 = tmp17
					} // end let
					tmp4 = tmp9
				}
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await-for
	{
		tmp0 := sym_await_DASH_for.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_timeout_DASH_ms, sym__AMP_, sym_agents)), kw_doc, "Blocks the current thread until all actions dispatched thus\n  far (from this thread or agent) to the agents have occurred, or the\n  timeout (in milliseconds) has elapsed. Returns logical false if\n  returning due to timeout, logical true otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3289), kw_end_DASH_line, int(3289))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				tmp6 := lang.Apply(nil, nil)
				if lang.IsTruthy(tmp6) {
					panic("unimplemented: new with non-constant class type")
				} else {
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core__STAR_agent_STAR_)
					if lang.IsTruthy(tmp8) {
						tmp9 := lang.Apply(errors8.New, []any{"Can't await in agent action"})
						panic(tmp9)
					} else {
					}
					_ = tmp7
					var tmp10 any
					{ // let
						// let binding "latch"
						var v11 any = "unimplemented: new with non-constant class type"
						_ = v11
						// let binding "count-down"
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v13 := args[0]
							_ = v13
							tmp14, _ := lang.FieldOrMethod(v11, "countDown")
							if reflect.TypeOf(tmp14).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("countDown is not a function")))
							}
							tmp15 := lang.Apply(tmp14, []any{})
							_ = tmp15
							return v13
						})
						tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3301), kw_column, int(23), kw_end_DASH_line, int(3301), kw_end_DASH_column, int(62))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						{ // let
							// let binding "seq_5"
							tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp18 := lang.Apply(tmp17, []any{v4})
							var v19 any = tmp18
							_ = v19
							// let binding "chunk_6"
							var v20 any = nil
							_ = v20
							// let binding "count_7"
							var v21 any = int64(0)
							_ = v21
							// let binding "i_8"
							var v22 any = int64(0)
							_ = v22
							for {
								var tmp23 any
								tmp24 := checkDerefVar(var_glojure_DOT_core__LT_)
								tmp25 := lang.Apply(tmp24, []any{v22, v21})
								if lang.IsTruthy(tmp25) {
									var tmp26 any
									{ // let
										// let binding "agent"
										tmp27, _ := lang.FieldOrMethod(v20, "nth")
										if reflect.TypeOf(tmp27).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
										}
										tmp28 := lang.Apply(tmp27, []any{v22})
										var v29 any = tmp28
										_ = v29
										tmp30 := checkDerefVar(var_glojure_DOT_core_send)
										tmp31 := lang.Apply(tmp30, []any{v29, v15})
										_ = tmp31
										var tmp32 any = v19
										var tmp33 any = v20
										var tmp34 any = v21
										tmp36 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
										tmp37 := lang.Apply(tmp36, []any{v22})
										var tmp35 any = tmp37
										v19 = tmp32
										v20 = tmp33
										v21 = tmp34
										v22 = tmp35
										continue
									} // end let
									tmp23 = tmp26
								} else {
									var tmp27 any
									{ // let
										// let binding "temp__0__auto__"
										tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp29 := lang.Apply(tmp28, []any{v19})
										var v30 any = tmp29
										_ = v30
										var tmp31 any
										if lang.IsTruthy(v30) {
											var tmp32 any
											{ // let
												// let binding "seq_5"
												var v33 any = v30
												_ = v33
												var tmp34 any
												tmp35 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
												tmp36 := lang.Apply(tmp35, []any{v33})
												if lang.IsTruthy(tmp36) {
													var tmp37 any
													{ // let
														// let binding "c__0__auto__"
														tmp38 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
														tmp39 := lang.Apply(tmp38, []any{v33})
														var v40 any = tmp39
														_ = v40
														tmp42 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
														tmp43 := lang.Apply(tmp42, []any{v33})
														var tmp41 any = tmp43
														var tmp44 any = v40
														tmp46 := checkDerefVar(var_glojure_DOT_core_int)
														tmp47 := checkDerefVar(var_glojure_DOT_core_count)
														tmp48 := lang.Apply(tmp47, []any{v40})
														tmp49 := lang.Apply(tmp46, []any{tmp48})
														var tmp45 any = tmp49
														tmp51 := checkDerefVar(var_glojure_DOT_core_int)
														tmp52 := lang.Apply(tmp51, []any{int64(0)})
														var tmp50 any = tmp52
														v19 = tmp41
														v20 = tmp44
														v21 = tmp45
														v22 = tmp50
														continue
													} // end let
													tmp34 = tmp37
												} else {
													var tmp38 any
													{ // let
														// let binding "agent"
														tmp39 := checkDerefVar(var_glojure_DOT_core_first)
														tmp40 := lang.Apply(tmp39, []any{v33})
														var v41 any = tmp40
														_ = v41
														tmp42 := checkDerefVar(var_glojure_DOT_core_send)
														tmp43 := lang.Apply(tmp42, []any{v41, v15})
														_ = tmp43
														tmp45 := checkDerefVar(var_glojure_DOT_core_next)
														tmp46 := lang.Apply(tmp45, []any{v33})
														var tmp44 any = tmp46
														var tmp47 any = nil
														var tmp48 any = int64(0)
														var tmp49 any = int64(0)
														v19 = tmp44
														v20 = tmp47
														v21 = tmp48
														v22 = tmp49
														continue
													} // end let
													tmp34 = tmp38
												}
												tmp32 = tmp34
											} // end let
											tmp31 = tmp32
										} else {
										}
										tmp27 = tmp31
									} // end let
									tmp23 = tmp27
								}
								tmp16 = tmp23
								break
							}
						} // end let
						_ = tmp16
						tmp17, ok := lang.FieldOrMethod(nil, "MILLISECONDS")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "MILLISECONDS")))
						}
						var tmp18 any
						switch reflect.TypeOf(tmp17).Kind() {
						case reflect.Func:
							tmp18 = lang.Apply(tmp17, nil)
						default:
							tmp18 = tmp17
						}
						tmp19, _ := lang.FieldOrMethod(v11, "await")
						if reflect.TypeOf(tmp19).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
						}
						tmp20 := lang.Apply(tmp19, []any{v3, tmp18})
						tmp10 = tmp20
					} // end let
					tmp5 = tmp10
				}
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await1
	{
		tmp0 := sym_await1.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(3284), kw_column, int(7), kw_end_DASH_line, int(3284), kw_end_DASH_column, int(21), kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
			tmp6, ok := lang.FieldOrMethod(v3, "getQueueCount")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getQueueCount")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			tmp8 := lang.Apply(tmp5, []any{tmp7})
			if lang.IsTruthy(tmp8) {
				tmp9 := checkDerefVar(var_glojure_DOT_core_await)
				tmp10 := lang.Apply(tmp9, []any{v3})
				tmp4 = tmp10
			} else {
			}
			_ = tmp4
			return v3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bases
	{
		tmp0 := sym_bases.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_c)), kw_doc, "Returns the immediate superclass and direct interfaces of c, if any", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(5522), kw_end_DASH_line, int(5522))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			if lang.IsTruthy(v3) {
				var tmp5 any
				{ // let
					// let binding "i"
					tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp7 := lang.Apply(tmp6, []any{nil})
					var v8 any = tmp7
					_ = v8
					// let binding "s"
					var v9 any = nil
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp11 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp12 := lang.Apply(tmp11, []any{v9, v8})
						tmp10 = tmp12
					} else {
						tmp10 = v8
					}
					tmp5 = tmp10
				} // end let
				tmp4 = tmp5
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bigdec
	{
		tmp1 := reflect.TypeOf((*lang.BigDecimal)(nil))
		tmp0 := sym_bigdec.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Coerce to BigDecimal", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3648), kw_end_DASH_line, int(3648))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_decimal_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			if lang.IsTruthy(tmp7) {
				tmp5 = v4
			} else {
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core_float_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v4})
				if lang.IsTruthy(tmp10) {
					tmp11 := checkDerefVar(var_glojure_DOT_core_double)
					tmp12 := lang.Apply(tmp11, []any{v4})
					tmp13 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp12})
					tmp8 = tmp13
				} else {
					var tmp14 any
					tmp15 := checkDerefVar(var_glojure_DOT_core_ratio_QMARK_)
					tmp16 := lang.Apply(tmp15, []any{v4})
					if lang.IsTruthy(tmp16) {
						tmp17 := checkDerefVar(var_glojure_DOT_core__SLASH_)
						tmp18 := lang.Apply(lang.NewBigDecimalFromRatio, []any{v4})
						tmp19, ok := lang.FieldOrMethod(v4, "denominator")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "denominator")))
						}
						var tmp20 any
						switch reflect.TypeOf(tmp19).Kind() {
						case reflect.Func:
							tmp20 = lang.Apply(tmp19, nil)
						default:
							tmp20 = tmp19
						}
						tmp21 := lang.Apply(tmp17, []any{tmp18, tmp20})
						tmp14 = tmp21
					} else {
						var tmp22 any
						tmp23 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp24 := reflect.TypeOf((*lang.BigInt)(nil))
						tmp25 := lang.Apply(tmp23, []any{tmp24, v4})
						if lang.IsTruthy(tmp25) {
							tmp26, ok := lang.FieldOrMethod(v4, "toBigDecimal")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigDecimal")))
							}
							var tmp27 any
							switch reflect.TypeOf(tmp26).Kind() {
							case reflect.Func:
								tmp27 = lang.Apply(tmp26, nil)
							default:
								tmp27 = tmp26
							}
							tmp22 = tmp27
						} else {
							var tmp28 any
							tmp29 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
							tmp30 := reflect.TypeOf((*big9.Int)(nil))
							tmp31 := lang.Apply(tmp29, []any{tmp30, v4})
							if lang.IsTruthy(tmp31) {
								tmp32 := lang.Apply(lang.NewBigDecimal, []any{v4})
								tmp28 = tmp32
							} else {
								var tmp33 any
								tmp34 := checkDerefVar(var_glojure_DOT_core_number_QMARK_)
								tmp35 := lang.Apply(tmp34, []any{v4})
								if lang.IsTruthy(tmp35) {
									tmp36 := checkDerefVar(var_glojure_DOT_core_long)
									tmp37 := lang.Apply(tmp36, []any{v4})
									tmp38 := lang.Apply(lang.NewBigDecimalFromInt64, []any{tmp37})
									tmp33 = tmp38
								} else {
									var tmp39 any
									if lang.IsTruthy(kw_else) {
										tmp40 := lang.Apply(lang.NewBigDecimal, []any{v4})
										tmp39 = tmp40
									} else {
									}
									tmp33 = tmp39
								}
								tmp28 = tmp33
							}
							tmp22 = tmp28
						}
						tmp14 = tmp22
					}
					tmp8 = tmp14
				}
				tmp5 = tmp8
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*lang.BigDecimal)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bigint
	{
		tmp1 := reflect.TypeOf((*lang.BigInt)(nil))
		tmp0 := sym_bigint.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Coerce to BigInt", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3620), kw_end_DASH_line, int(3620))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*lang.BigInt)(nil))
			tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
			if lang.IsTruthy(tmp8) {
				tmp5 = v4
			} else {
				var tmp9 any
				tmp10 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp11 := reflect.TypeOf((*big9.Int)(nil))
				tmp12 := lang.Apply(tmp10, []any{tmp11, v4})
				if lang.IsTruthy(tmp12) {
					tmp13 := lang.Apply(lang.NewBigIntFromGoBigInt, []any{v4})
					tmp9 = tmp13
				} else {
					var tmp14 any
					tmp15 := checkDerefVar(var_glojure_DOT_core_decimal_QMARK_)
					tmp16 := lang.Apply(tmp15, []any{v4})
					if lang.IsTruthy(tmp16) {
						tmp17 := checkDerefVar(var_glojure_DOT_core_bigint)
						tmp18, ok := lang.FieldOrMethod(v4, "toBigInteger")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigInteger")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						tmp20 := lang.Apply(tmp17, []any{tmp19})
						tmp14 = tmp20
					} else {
						var tmp21 any
						tmp22 := checkDerefVar(var_glojure_DOT_core_float_QMARK_)
						tmp23 := lang.Apply(tmp22, []any{v4})
						if lang.IsTruthy(tmp23) {
							tmp24 := checkDerefVar(var_glojure_DOT_core_bigint)
							tmp25 := checkDerefVar(var_glojure_DOT_core_double)
							tmp26 := lang.Apply(tmp25, []any{v4})
							tmp27 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp26})
							tmp28 := lang.Apply(tmp24, []any{tmp27})
							tmp21 = tmp28
						} else {
							var tmp29 any
							tmp30 := checkDerefVar(var_glojure_DOT_core_ratio_QMARK_)
							tmp31 := lang.Apply(tmp30, []any{v4})
							if lang.IsTruthy(tmp31) {
								tmp32 := checkDerefVar(var_glojure_DOT_core_bigint)
								tmp33, ok := lang.FieldOrMethod(v4, "bigIntegerValue")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "bigIntegerValue")))
								}
								var tmp34 any
								switch reflect.TypeOf(tmp33).Kind() {
								case reflect.Func:
									tmp34 = lang.Apply(tmp33, nil)
								default:
									tmp34 = tmp33
								}
								tmp35 := lang.Apply(tmp32, []any{tmp34})
								tmp29 = tmp35
							} else {
								var tmp36 any
								tmp37 := checkDerefVar(var_glojure_DOT_core_number_QMARK_)
								tmp38 := lang.Apply(tmp37, []any{v4})
								if lang.IsTruthy(tmp38) {
									tmp39 := checkDerefVar(var_glojure_DOT_core_long)
									tmp40 := lang.Apply(tmp39, []any{v4})
									tmp41 := lang.Apply(lang.NewBigIntFromInt64, []any{tmp40})
									tmp36 = tmp41
								} else {
									var tmp42 any
									if lang.IsTruthy(kw_else) {
										tmp43 := checkDerefVar(var_glojure_DOT_core_bigint)
										tmp44 := lang.Apply(lang.NewBigInt, []any{v4})
										tmp45 := lang.Apply(tmp43, []any{tmp44})
										tmp42 = tmp45
									} else {
									}
									tmp36 = tmp42
								}
								tmp29 = tmp36
							}
							tmp21 = tmp29
						}
						tmp14 = tmp21
					}
					tmp9 = tmp14
				}
				tmp5 = tmp9
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*lang.BigInt)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// biginteger
	{
		tmp1 := reflect.TypeOf((*big9.Int)(nil))
		tmp0 := sym_biginteger.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Coerce to BigInteger", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(3634), kw_end_DASH_line, int(3634))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*big9.Int)(nil))
			tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
			if lang.IsTruthy(tmp8) {
				tmp5 = v4
			} else {
				var tmp9 any
				tmp10 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp11 := reflect.TypeOf((*lang.BigInt)(nil))
				tmp12 := lang.Apply(tmp10, []any{tmp11, v4})
				if lang.IsTruthy(tmp12) {
					tmp13, ok := lang.FieldOrMethod(v4, "toBigInteger")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigInteger")))
					}
					var tmp14 any
					switch reflect.TypeOf(tmp13).Kind() {
					case reflect.Func:
						tmp14 = lang.Apply(tmp13, nil)
					default:
						tmp14 = tmp13
					}
					tmp9 = tmp14
				} else {
					var tmp15 any
					tmp16 := checkDerefVar(var_glojure_DOT_core_decimal_QMARK_)
					tmp17 := lang.Apply(tmp16, []any{v4})
					if lang.IsTruthy(tmp17) {
						tmp18, ok := lang.FieldOrMethod(v4, "toBigInteger")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigInteger")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						tmp15 = tmp19
					} else {
						var tmp20 any
						tmp21 := checkDerefVar(var_glojure_DOT_core_float_QMARK_)
						tmp22 := lang.Apply(tmp21, []any{v4})
						if lang.IsTruthy(tmp22) {
							tmp23 := checkDerefVar(var_glojure_DOT_core_double)
							tmp24 := lang.Apply(tmp23, []any{v4})
							tmp25 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp24})
							tmp26, ok := lang.FieldOrMethod(tmp25, "toBigInteger")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp25, "toBigInteger")))
							}
							var tmp27 any
							switch reflect.TypeOf(tmp26).Kind() {
							case reflect.Func:
								tmp27 = lang.Apply(tmp26, nil)
							default:
								tmp27 = tmp26
							}
							tmp20 = tmp27
						} else {
							var tmp28 any
							tmp29 := checkDerefVar(var_glojure_DOT_core_ratio_QMARK_)
							tmp30 := lang.Apply(tmp29, []any{v4})
							if lang.IsTruthy(tmp30) {
								tmp31, ok := lang.FieldOrMethod(v4, "bigIntegerValue")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "bigIntegerValue")))
								}
								var tmp32 any
								switch reflect.TypeOf(tmp31).Kind() {
								case reflect.Func:
									tmp32 = lang.Apply(tmp31, nil)
								default:
									tmp32 = tmp31
								}
								tmp28 = tmp32
							} else {
								var tmp33 any
								tmp34 := checkDerefVar(var_glojure_DOT_core_number_QMARK_)
								tmp35 := lang.Apply(tmp34, []any{v4})
								if lang.IsTruthy(tmp35) {
									tmp36 := checkDerefVar(var_glojure_DOT_core_long)
									tmp37 := lang.Apply(tmp36, []any{v4})
									tmp38 := lang.Apply(big9.NewInt, []any{tmp37})
									tmp33 = tmp38
								} else {
									var tmp39 any
									if lang.IsTruthy(kw_else) {
										tmp40 := lang.Apply(lang.NewBigInt, []any{v4})
										tmp39 = tmp40
									} else {
									}
									tmp33 = tmp39
								}
								tmp28 = tmp33
							}
							tmp20 = tmp28
						}
						tmp15 = tmp20
					}
					tmp9 = tmp15
				}
				tmp5 = tmp9
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*big9.Int)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// binding
	{
		tmp0 := sym_binding.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(1945), kw_end_DASH_line, int(1945))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_str)
					tmp11 := checkDerefVar(var_glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(kw_line, []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(var_glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "var-ize"
					var tmp34 lang.FnFunc
					tmp34 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v35 := args[0]
						_ = v35
						var tmp36 any
						{ // let
							// let binding "ret"
							tmp37 := lang.NewVector()
							tmp38 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1959), kw_column, int(30), kw_end_DASH_line, int(1959), kw_end_DASH_column, int(31))
							tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v40 any = tmp39
							_ = v40
							// let binding "vvs"
							tmp41 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp42 := lang.Apply(tmp41, []any{v35})
							var v43 any = tmp42
							_ = v43
							for {
								var tmp44 any
								if lang.IsTruthy(v43) {
									tmp46 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp47 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp48 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp49 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp50 := checkDerefVar(var_glojure_DOT_core_list)
									tmp51 := lang.Apply(tmp50, []any{sym_var})
									tmp52 := checkDerefVar(var_glojure_DOT_core_list)
									tmp53 := checkDerefVar(var_glojure_DOT_core_first)
									tmp54 := lang.Apply(tmp53, []any{v43})
									tmp55 := lang.Apply(tmp52, []any{tmp54})
									tmp56 := lang.Apply(tmp49, []any{tmp51, tmp55})
									tmp57 := lang.Apply(tmp48, []any{tmp56})
									tmp58 := lang.Apply(tmp47, []any{v40, tmp57})
									tmp59 := checkDerefVar(var_glojure_DOT_core_second)
									tmp60 := lang.Apply(tmp59, []any{v43})
									tmp61 := lang.Apply(tmp46, []any{tmp58, tmp60})
									var tmp45 any = tmp61
									tmp63 := checkDerefVar(var_glojure_DOT_core_next)
									tmp64 := checkDerefVar(var_glojure_DOT_core_next)
									tmp65 := lang.Apply(tmp64, []any{v43})
									tmp66 := lang.Apply(tmp63, []any{tmp65})
									var tmp62 any = tmp66
									v40 = tmp45
									v43 = tmp62
									continue
								} else {
									tmp67 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp68 := lang.Apply(tmp67, []any{v40})
									tmp44 = tmp68
								}
								tmp36 = tmp44
								break
							}
						} // end let
						return tmp36
					})
					tmp35 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1958), kw_column, int(17), kw_end_DASH_line, int(1963), kw_end_DASH_column, int(34))
					tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v37 any = tmp36
					_ = v37
					tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp39 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{sym_glojure_DOT_core_SLASH_let})
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					tmp43 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp44 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp45 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp46 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp47 := lang.Apply(tmp46, nil)
					tmp48 := lang.Apply(tmp45, []any{tmp47})
					tmp49 := lang.Apply(tmp43, []any{tmp44, tmp48})
					tmp50 := lang.Apply(tmp42, []any{tmp49})
					tmp51 := checkDerefVar(var_glojure_DOT_core_list)
					tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp53 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp54 := checkDerefVar(var_glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{sym_glojure_DOT_core_SLASH_push_DASH_thread_DASH_bindings})
					tmp56 := checkDerefVar(var_glojure_DOT_core_list)
					tmp57 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp58 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp59 := checkDerefVar(var_glojure_DOT_core_list)
					tmp60 := lang.Apply(tmp59, []any{sym_glojure_DOT_core_SLASH_hash_DASH_map})
					tmp61 := lang.Apply(v37, []any{v5})
					tmp62 := lang.Apply(tmp58, []any{tmp60, tmp61})
					tmp63 := lang.Apply(tmp57, []any{tmp62})
					tmp64 := lang.Apply(tmp56, []any{tmp63})
					tmp65 := lang.Apply(tmp53, []any{tmp55, tmp64})
					tmp66 := lang.Apply(tmp52, []any{tmp65})
					tmp67 := lang.Apply(tmp51, []any{tmp66})
					tmp68 := checkDerefVar(var_glojure_DOT_core_list)
					tmp69 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp70 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp71 := checkDerefVar(var_glojure_DOT_core_list)
					tmp72 := lang.Apply(tmp71, []any{sym_try})
					tmp73 := checkDerefVar(var_glojure_DOT_core_list)
					tmp74 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp75 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp76 := checkDerefVar(var_glojure_DOT_core_list)
					tmp77 := lang.Apply(tmp76, []any{sym_finally})
					tmp78 := checkDerefVar(var_glojure_DOT_core_list)
					tmp79 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp80 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp81 := checkDerefVar(var_glojure_DOT_core_list)
					tmp82 := lang.Apply(tmp81, []any{sym_glojure_DOT_core_SLASH_pop_DASH_thread_DASH_bindings})
					tmp83 := lang.Apply(tmp80, []any{tmp82})
					tmp84 := lang.Apply(tmp79, []any{tmp83})
					tmp85 := lang.Apply(tmp78, []any{tmp84})
					tmp86 := lang.Apply(tmp75, []any{tmp77, tmp85})
					tmp87 := lang.Apply(tmp74, []any{tmp86})
					tmp88 := lang.Apply(tmp73, []any{tmp87})
					tmp89 := lang.Apply(tmp70, []any{tmp72, v6, tmp88})
					tmp90 := lang.Apply(tmp69, []any{tmp89})
					tmp91 := lang.Apply(tmp68, []any{tmp90})
					tmp92 := lang.Apply(tmp39, []any{tmp41, tmp50, tmp67, tmp91})
					tmp93 := lang.Apply(tmp38, []any{tmp92})
					tmp33 = tmp93
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// binding-conveyor-fn
	{
		tmp0 := sym_binding_DASH_conveyor_DASH_fn.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(2020), kw_end_DASH_line, int(2020), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "frame"
				tmp5 := lang.Apply(lang.CloneThreadBindingFrame, nil)
				var v6 any = tmp5
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp8 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp8
						tmp9 := lang.Apply(v3, nil)
						return tmp9
					case 1:
						v8 := args[0]
						_ = v8
						tmp9 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp9
						tmp10 := lang.Apply(v3, []any{v8})
						return tmp10
					case 2:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						tmp10 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp10
						tmp11 := lang.Apply(v3, []any{v8, v9})
						return tmp11
					case 3:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						tmp11 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp11
						tmp12 := lang.Apply(v3, []any{v8, v9, v10})
						return tmp12
					default:
						checkArity(args, 3)
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var v11 any = lang.NewList(args[3:]...)
						_ = v11
						tmp12 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp12
						tmp13 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp14 := lang.Apply(tmp13, []any{v3, v8, v9, v10, v11})
						return tmp14
					}
				})
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2025), kw_column, int(5), kw_end_DASH_line, int(2040), kw_end_DASH_column, int(31))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp9
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-and
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed29
					} else {
						tmp4 = closed29
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed29
					} else {
						tmp5 = closed29
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed29
					} else {
						tmp6 = closed29
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_bit_DASH_and.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Bitwise and", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1298), kw_end_DASH_line, int(1298))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "And")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("And is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and)
				tmp10 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-and-not
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed30
					} else {
						tmp4 = closed30
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed30
					} else {
						tmp5 = closed30
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed30
					} else {
						tmp6 = closed30
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_bit_DASH_and_DASH_not.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Bitwise and with complement", kw_static, true, kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(1325), kw_end_DASH_line, int(1325))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "AndNot")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("AndNot is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and_DASH_not)
				tmp10 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and_DASH_not)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-clear
	{
		tmp0 := sym_bit_DASH_clear.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_doc, "Clear bit at index n", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(1336), kw_end_DASH_line, int(1336))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "ClearBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ClearBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-flip
	{
		tmp0 := sym_bit_DASH_flip.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_doc, "Flip bit at index n", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1348), kw_end_DASH_line, int(1348))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "FlipBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("FlipBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-not
	{
		var tmp1 lang.FnFunc
		{ // function bit-not__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Not})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_bit_DASH_not.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Bitwise complement", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1291), kw_end_DASH_line, int(1291))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Not")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Not is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-or
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed31
					} else {
						tmp4 = closed31
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed31
					} else {
						tmp5 = closed31
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed31
					} else {
						tmp6 = closed31
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_bit_DASH_or.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Bitwise or", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(1307), kw_end_DASH_line, int(1307))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Or")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Or is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core_bit_DASH_or)
				tmp10 := checkDerefVar(var_glojure_DOT_core_bit_DASH_or)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-set
	{
		tmp0 := sym_bit_DASH_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_doc, "Set bit at index n", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1342), kw_end_DASH_line, int(1342))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "SetBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("SetBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-shift-left
	{
		var tmp1 lang.FnFunc
		{ // function bit-shift-left__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_ShiftLeft})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_bit_DASH_shift_DASH_left.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_inline, tmp1, kw_doc, "Bitwise shift left", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(1361), kw_end_DASH_line, int(1361))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ShiftLeft")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShiftLeft is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-shift-right
	{
		var tmp1 lang.FnFunc
		{ // function bit-shift-right__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_ShiftRight})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_bit_DASH_shift_DASH_right.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_inline, tmp1, kw_doc, "Bitwise shift right", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(1367), kw_end_DASH_line, int(1367))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ShiftRight")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShiftRight is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-test
	{
		tmp0 := sym_bit_DASH_test.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_doc, "Test bit at index n", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1354), kw_end_DASH_line, int(1354))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "TestBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("TestBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-xor
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed32
					} else {
						tmp4 = closed32
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed32
					} else {
						tmp5 = closed32
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed32
					} else {
						tmp6 = closed32
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_bit_DASH_xor.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Bitwise exclusive or", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1316), kw_end_DASH_line, int(1316))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Xor")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Xor is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core_bit_DASH_xor)
				tmp10 := checkDerefVar(var_glojure_DOT_core_bit_DASH_xor)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean
	{
		var tmp1 lang.FnFunc
		{ // function boolean__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_BooleanCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_boolean.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to boolean", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1601), kw_end_DASH_line, int(1601))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime.RT, "BooleanCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("BooleanCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean-array
	{
		var tmp1 lang.FnFunc
		{ // function boolean-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_BooleanArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_boolean_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of booleans", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(5309), kw_end_DASH_line, int(5309))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "BooleanArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("BooleanArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "BooleanArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("BooleanArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean?
	{
		tmp0 := sym_boolean_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a Boolean", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(518), kw_end_DASH_line, int(518))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{lang.Builtins["bool"], v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// booleans
	{
		var tmp1 lang.FnFunc
		{ // function booleans
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_Booleans})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_booleans.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to boolean[]", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(12), kw_line, int(5372), kw_end_DASH_line, int(5372))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Booleans")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Booleans is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound-fn
	{
		tmp0 := sym_bound_DASH_fn.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_fntail)), kw_doc, "Returns a function defined by the given fntail, which will install the\n  same bindings in effect as in the thread at the time bound-fn was called.\n  This may be used to define a helper function which runs on a different\n  thread, but needs the same bindings in place.", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(2004), kw_end_DASH_line, int(2004))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_bound_DASH_fn_STAR_})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp15 := lang.Apply(tmp12, []any{tmp14, v5})
				tmp16 := lang.Apply(tmp11, []any{tmp15})
				tmp17 := lang.Apply(tmp10, []any{tmp16})
				tmp18 := lang.Apply(tmp7, []any{tmp9, tmp17})
				tmp19 := lang.Apply(tmp6, []any{tmp18})
				return tmp19
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound-fn*
	{
		tmp0 := sym_bound_DASH_fn_STAR_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Returns a function, which will install the same bindings in effect as in\n  the thread at the time bound-fn* was called and then call f with any given\n  arguments. This may be used to define a helper function which runs on a\n  different thread, but needs the same bindings in place.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(1992), kw_end_DASH_line, int(1992))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "bindings"
				tmp5 := checkDerefVar(var_glojure_DOT_core_get_DASH_thread_DASH_bindings)
				tmp6 := lang.Apply(tmp5, nil)
				var v7 any = tmp6
				_ = v7
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						checkArity(args, 0)
						var v9 any = lang.NewList(args[0:]...)
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp11 := checkDerefVar(var_glojure_DOT_core_with_DASH_bindings_STAR_)
						tmp12 := lang.Apply(tmp10, []any{tmp11, v7, v3, v9})
						return tmp12
					}
				})
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2001), kw_column, int(5), kw_end_DASH_line, int(2002), kw_end_DASH_column, int(45))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound?
	{
		tmp0 := sym_bound_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_vars)), kw_doc, "Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5491), kw_end_DASH_line, int(5491))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v6 := args[0]
					_ = v6
					tmp7, ok := lang.FieldOrMethod(v6, "isBound")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "isBound")))
					}
					var tmp8 any
					switch reflect.TypeOf(tmp7).Kind() {
					case reflect.Func:
						tmp8 = lang.Apply(tmp7, nil)
					default:
						tmp8 = tmp7
					}
					return tmp8
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5497), kw_column, int(11), kw_end_DASH_line, int(5497), kw_end_DASH_column, int(69))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7, v3})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bounded-count
	{
		tmp0 := sym_bounded_DASH_count.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll)), kw_doc, "If coll is counted? returns its count, else will count at most the first n\n  elements of coll using its seq", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(7410), kw_end_DASH_line, int(7410))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_counted_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_glojure_DOT_core_count)
				tmp9 := lang.Apply(tmp8, []any{v4})
				tmp5 = tmp9
			} else {
				var tmp10 any
				{ // let
					// let binding "i"
					var v11 any = int64(0)
					_ = v11
					// let binding "s"
					tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp13 := lang.Apply(tmp12, []any{v4})
					var v14 any = tmp13
					_ = v14
					for {
						var tmp15 any
						var tmp16 any
						{ // let
							// let binding "and__0__auto__"
							var v17 any = v14
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								tmp19 := checkDerefVar(var_glojure_DOT_core__LT_)
								tmp20 := lang.Apply(tmp19, []any{v11, v3})
								tmp18 = tmp20
							} else {
								tmp18 = v17
							}
							tmp16 = tmp18
						} // end let
						if lang.IsTruthy(tmp16) {
							tmp18 := checkDerefVar(var_glojure_DOT_core_inc)
							tmp19 := lang.Apply(tmp18, []any{v11})
							var tmp17 any = tmp19
							tmp21 := checkDerefVar(var_glojure_DOT_core_next)
							tmp22 := lang.Apply(tmp21, []any{v14})
							var tmp20 any = tmp22
							v11 = tmp17
							v14 = tmp20
							continue
						} else {
							tmp15 = v11
						}
						tmp10 = tmp15
						break
					}
				} // end let
				tmp5 = tmp10
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// butlast
	{
		tmp0 := sym_butlast.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Return a seq of all but the last item in coll, in linear time", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(2), kw_line, int(272), kw_end_DASH_line, int(276))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function butlast
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "ret"
					tmp6 := lang.NewVector()
					tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(277), kw_column, int(23), kw_end_DASH_line, int(277), kw_end_DASH_column, int(24))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v9 any = tmp8
					_ = v9
					// let binding "s"
					var v10 any = v4
					_ = v10
					for {
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core_next)
						tmp13 := lang.Apply(tmp12, []any{v10})
						if lang.IsTruthy(tmp13) {
							tmp15 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp16 := checkDerefVar(var_glojure_DOT_core_first)
							tmp17 := lang.Apply(tmp16, []any{v10})
							tmp18 := lang.Apply(tmp15, []any{v9, tmp17})
							var tmp14 any = tmp18
							tmp20 := checkDerefVar(var_glojure_DOT_core_next)
							tmp21 := lang.Apply(tmp20, []any{v10})
							var tmp19 any = tmp21
							v9 = tmp14
							v10 = tmp19
							continue
						} else {
							tmp22 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp23 := lang.Apply(tmp22, []any{v9})
							tmp11 = tmp23
						}
						tmp5 = tmp11
						break
					}
				} // end let
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(276), kw_column, int(10), kw_end_DASH_line, int(280), kw_end_DASH_column, int(27))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// byte
	{
		var tmp1 lang.FnFunc
		{ // function byte__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_uncheckedByteCast
				} else {
					tmp14 = sym_byteCast
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_byte.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to byte", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3505), kw_end_DASH_line, int(3505))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.ByteCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// byte-array
	{
		var tmp1 lang.FnFunc
		{ // function byte-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_ByteArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_byte_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of bytes", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(5317), kw_end_DASH_line, int(5317))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "ByteArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ByteArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ByteArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ByteArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bytes
	{
		var tmp1 lang.FnFunc
		{ // function bytes
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_Bytes})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_bytes.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to bytes[]", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(12), kw_line, int(5377), kw_end_DASH_line, int(5377))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Bytes")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Bytes is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bytes?
	{
		tmp0 := sym_bytes_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a byte array", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5412), kw_end_DASH_line, int(5412))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp4 = false
			} else {
				tmp7 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp8 := checkDerefVar(var_glojure_DOT_core_class)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10, ok := lang.FieldOrMethod(tmp9, "getComponentType")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp9, "getComponentType")))
				}
				var tmp11 any
				switch reflect.TypeOf(tmp10).Kind() {
				case reflect.Func:
					tmp11 = lang.Apply(tmp10, nil)
				default:
					tmp11 = tmp10
				}
				tmp12 := lang.Apply(tmp7, []any{tmp11, nil})
				tmp4 = tmp12
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// case
	{
		tmp0 := sym_case.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_e, sym__AMP_, sym_clauses)), kw_doc, "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(6712), kw_end_DASH_line, int(6712))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ge"
					tmp8 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp9 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp10 := lang.Apply(tmp9, nil)
					tmp11 := reflect.TypeOf((*lang.Object)(nil)).Elem()
					tmp12 := lang.NewMap(kw_tag, tmp11)
					tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6738), kw_column, int(32), kw_end_DASH_line, int(6738), kw_end_DASH_column, int(84))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := lang.Apply(tmp8, []any{tmp10, tmp14})
					var v16 any = tmp15
					_ = v16
					// let binding "default"
					var tmp17 any
					tmp18 := checkDerefVar(var_glojure_DOT_core_odd_QMARK_)
					tmp19 := checkDerefVar(var_glojure_DOT_core_count)
					tmp20 := lang.Apply(tmp19, []any{v6})
					tmp21 := lang.Apply(tmp18, []any{tmp20})
					if lang.IsTruthy(tmp21) {
						tmp22 := checkDerefVar(var_glojure_DOT_core_last)
						tmp23 := lang.Apply(tmp22, []any{v6})
						tmp17 = tmp23
					} else {
						tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{sym_throw})
						tmp28 := checkDerefVar(var_glojure_DOT_core_list)
						tmp29 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp30 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp31 := checkDerefVar(var_glojure_DOT_core_list)
						tmp32 := lang.Apply(tmp31, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewIllegalArgumentError})
						tmp33 := checkDerefVar(var_glojure_DOT_core_list)
						tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp35 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp36 := checkDerefVar(var_glojure_DOT_core_list)
						tmp37 := lang.Apply(tmp36, []any{sym_glojure_DOT_core_SLASH_str})
						tmp38 := checkDerefVar(var_glojure_DOT_core_list)
						tmp39 := lang.Apply(tmp38, []any{"No matching clause: "})
						tmp40 := checkDerefVar(var_glojure_DOT_core_list)
						tmp41 := lang.Apply(tmp40, []any{v16})
						tmp42 := lang.Apply(tmp35, []any{tmp37, tmp39, tmp41})
						tmp43 := lang.Apply(tmp34, []any{tmp42})
						tmp44 := lang.Apply(tmp33, []any{tmp43})
						tmp45 := lang.Apply(tmp30, []any{tmp32, tmp44})
						tmp46 := lang.Apply(tmp29, []any{tmp45})
						tmp47 := lang.Apply(tmp28, []any{tmp46})
						tmp48 := lang.Apply(tmp25, []any{tmp27, tmp47})
						tmp49 := lang.Apply(tmp24, []any{tmp48})
						tmp17 = tmp49
					}
					var v50 any = tmp17
					_ = v50
					var tmp51 any
					tmp52 := checkDerefVar(var_glojure_DOT_core__GT_)
					tmp53 := checkDerefVar(var_glojure_DOT_core_count)
					tmp54 := lang.Apply(tmp53, []any{v6})
					tmp55 := lang.Apply(tmp52, []any{int64(2), tmp54})
					if lang.IsTruthy(tmp55) {
						tmp56 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp57 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp58 := checkDerefVar(var_glojure_DOT_core_list)
						tmp59 := lang.Apply(tmp58, []any{sym_glojure_DOT_core_SLASH_let})
						tmp60 := checkDerefVar(var_glojure_DOT_core_list)
						tmp61 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp62 := checkDerefVar(var_glojure_DOT_core_vector)
						tmp63 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp64 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp65 := checkDerefVar(var_glojure_DOT_core_list)
						tmp66 := lang.Apply(tmp65, []any{v16})
						tmp67 := checkDerefVar(var_glojure_DOT_core_list)
						tmp68 := lang.Apply(tmp67, []any{v5})
						tmp69 := lang.Apply(tmp64, []any{tmp66, tmp68})
						tmp70 := lang.Apply(tmp63, []any{tmp69})
						tmp71 := lang.Apply(tmp61, []any{tmp62, tmp70})
						tmp72 := lang.Apply(tmp60, []any{tmp71})
						tmp73 := checkDerefVar(var_glojure_DOT_core_list)
						tmp74 := lang.Apply(tmp73, []any{v50})
						tmp75 := lang.Apply(tmp57, []any{tmp59, tmp72, tmp74})
						tmp76 := lang.Apply(tmp56, []any{tmp75})
						tmp51 = tmp76
					} else {
						var tmp77 any
						{ // let
							// let binding "pairs"
							tmp78 := checkDerefVar(var_glojure_DOT_core_partition)
							tmp79 := lang.Apply(tmp78, []any{int64(2), v6})
							var v80 any = tmp79
							_ = v80
							// let binding "assoc-test"
							var tmp81 lang.FnFunc
							{ // function assoc-test
								var v82 lang.FnFunc
								tmp81 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 3)
									v83 := args[0]
									_ = v83
									v84 := args[1]
									_ = v84
									v85 := args[2]
									_ = v85
									var tmp86 any
									tmp87 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
									tmp88 := lang.Apply(tmp87, []any{v83, v84})
									if lang.IsTruthy(tmp88) {
										tmp89 := checkDerefVar(var_glojure_DOT_core_str)
										tmp90 := lang.Apply(tmp89, []any{"Duplicate case test constant: ", v84})
										tmp91 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp90})
										panic(tmp91)
									} else {
										tmp92 := checkDerefVar(var_glojure_DOT_core_assoc)
										tmp93 := lang.Apply(tmp92, []any{v83, v84, v85})
										tmp86 = tmp93
									}
									return tmp86
								})
								v82 = tmp81
								_ = v82
							}
							tmp82 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6745), kw_column, int(24), kw_end_DASH_line, int(6748), kw_end_DASH_column, int(48))
							tmp83, err := lang.WithMeta(tmp81, tmp82.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v84 any = tmp83
							_ = v84
							// let binding "pairs"
							tmp85 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp86 lang.FnFunc
							tmp86 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v87 := args[0]
								_ = v87
								v88 := args[1]
								_ = v88
								var tmp89 any
								{ // let
									// let binding "vec__177"
									var v90 any = v88
									_ = v90
									// let binding "test"
									tmp91 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp92 := lang.Apply(tmp91, []any{v90, int64(0), nil})
									var v93 any = tmp92
									_ = v93
									// let binding "expr"
									tmp94 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp95 := lang.Apply(tmp94, []any{v90, int64(1), nil})
									var v96 any = tmp95
									_ = v96
									var tmp97 any
									tmp98 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
									tmp99 := lang.Apply(tmp98, []any{v93})
									if lang.IsTruthy(tmp99) {
										tmp100 := checkDerefVar(var_glojure_DOT_core_reduce1)
										var tmp101 lang.FnFunc
										tmp101 = lang.NewFnFunc(func(args ...any) any {
											checkArity(args, 2)
											v102 := args[0]
											_ = v102
											v103 := args[1]
											_ = v103
											tmp104 := lang.Apply(v84, []any{v102, v103, v96})
											return tmp104
										})
										tmp102 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6752), kw_column, int(37), kw_end_DASH_line, int(6752), kw_end_DASH_column, int(60))
										tmp103, err := lang.WithMeta(tmp101, tmp102.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp104 := lang.Apply(tmp100, []any{tmp103, v87, v93})
										tmp97 = tmp104
									} else {
										tmp105 := lang.Apply(v84, []any{v87, v93, v96})
										tmp97 = tmp105
									}
									tmp89 = tmp97
								} // end let
								return tmp89
							})
							tmp87 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6750), kw_column, int(24), kw_end_DASH_line, int(6753), kw_end_DASH_column, int(53))
							tmp88, err := lang.WithMeta(tmp86, tmp87.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp89 := lang.NewMap()
							tmp90 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6754), kw_column, int(24), kw_end_DASH_line, int(6754), kw_end_DASH_column, int(25))
							tmp91, err := lang.WithMeta(tmp89, tmp90.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp92 := lang.Apply(tmp85, []any{tmp88, tmp91, v80})
							var v93 any = tmp92
							_ = v93
							// let binding "tests"
							tmp94 := checkDerefVar(var_glojure_DOT_core_keys)
							tmp95 := lang.Apply(tmp94, []any{v93})
							var v96 any = tmp95
							_ = v96
							// let binding "thens"
							tmp97 := checkDerefVar(var_glojure_DOT_core_vals)
							tmp98 := lang.Apply(tmp97, []any{v93})
							var v99 any = tmp98
							_ = v99
							// let binding "mode"
							var tmp100 any
							tmp101 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
							var tmp102 lang.FnFunc
							tmp102 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v103 := args[0]
								_ = v103
								var tmp104 any
								{ // let
									// let binding "and__0__auto__"
									tmp105 := checkDerefVar(var_glojure_DOT_core_integer_QMARK_)
									tmp106 := lang.Apply(tmp105, []any{v103})
									var v107 any = tmp106
									_ = v107
									var tmp108 any
									if lang.IsTruthy(v107) {
										tmp109 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
										tmp110 := lang.Apply(tmp109, []any{math7.MinInt, v103, math7.MaxInt})
										tmp108 = tmp110
									} else {
										tmp108 = v107
									}
									tmp104 = tmp108
								} // end let
								return tmp104
							})
							tmp103 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6758), kw_column, int(28), kw_end_DASH_line, int(6758), kw_end_DASH_column, int(77))
							tmp104, err := lang.WithMeta(tmp102, tmp103.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp105 := lang.Apply(tmp101, []any{tmp104, v96})
							if lang.IsTruthy(tmp105) {
								tmp100 = kw_ints
							} else {
								var tmp106 any
								tmp107 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
								tmp108 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
								tmp109 := lang.Apply(tmp107, []any{tmp108, v96})
								if lang.IsTruthy(tmp109) {
									tmp106 = kw_identity
								} else {
									var tmp110 any
									if lang.IsTruthy(kw_else) {
										tmp110 = kw_hashes
									} else {
									}
									tmp106 = tmp110
								}
								tmp100 = tmp106
							}
							var v111 any = tmp100
							_ = v111
							var tmp112 any
							{ // let
								// let binding "pred__180"
								tmp113 := checkDerefVar(var_glojure_DOT_core__EQ_)
								var v114 any = tmp113
								_ = v114
								// let binding "expr__181"
								var v115 any = v111
								_ = v115
								var tmp116 any
								tmp117 := lang.Apply(v114, []any{kw_ints, v115})
								if lang.IsTruthy(tmp117) {
									var tmp118 any
									{ // let
										// let binding "vec__182"
										tmp119 := checkDerefVar(var_glojure_DOT_core_prep_DASH_ints)
										tmp120 := lang.Apply(tmp119, []any{v96, v99})
										var v121 any = tmp120
										_ = v121
										// let binding "shift"
										tmp122 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp123 := lang.Apply(tmp122, []any{v121, int64(0), nil})
										var v124 any = tmp123
										_ = v124
										// let binding "mask"
										tmp125 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp126 := lang.Apply(tmp125, []any{v121, int64(1), nil})
										var v127 any = tmp126
										_ = v127
										// let binding "imap"
										tmp128 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp129 := lang.Apply(tmp128, []any{v121, int64(2), nil})
										var v130 any = tmp129
										_ = v130
										// let binding "switch-type"
										tmp131 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp132 := lang.Apply(tmp131, []any{v121, int64(3), nil})
										var v133 any = tmp132
										_ = v133
										tmp134 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp135 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp136 := checkDerefVar(var_glojure_DOT_core_list)
										tmp137 := lang.Apply(tmp136, []any{sym_glojure_DOT_core_SLASH_let})
										tmp138 := checkDerefVar(var_glojure_DOT_core_list)
										tmp139 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp140 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp141 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp142 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp143 := checkDerefVar(var_glojure_DOT_core_list)
										tmp144 := lang.Apply(tmp143, []any{v16})
										tmp145 := checkDerefVar(var_glojure_DOT_core_list)
										tmp146 := lang.Apply(tmp145, []any{v5})
										tmp147 := lang.Apply(tmp142, []any{tmp144, tmp146})
										tmp148 := lang.Apply(tmp141, []any{tmp147})
										tmp149 := lang.Apply(tmp139, []any{tmp140, tmp148})
										tmp150 := lang.Apply(tmp138, []any{tmp149})
										tmp151 := checkDerefVar(var_glojure_DOT_core_list)
										tmp152 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp153 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp154 := checkDerefVar(var_glojure_DOT_core_list)
										tmp155 := lang.Apply(tmp154, []any{sym_case_STAR_})
										tmp156 := checkDerefVar(var_glojure_DOT_core_list)
										tmp157 := lang.Apply(tmp156, []any{v16})
										tmp158 := checkDerefVar(var_glojure_DOT_core_list)
										tmp159 := lang.Apply(tmp158, []any{v124})
										tmp160 := checkDerefVar(var_glojure_DOT_core_list)
										tmp161 := lang.Apply(tmp160, []any{v127})
										tmp162 := checkDerefVar(var_glojure_DOT_core_list)
										tmp163 := lang.Apply(tmp162, []any{v50})
										tmp164 := checkDerefVar(var_glojure_DOT_core_list)
										tmp165 := lang.Apply(tmp164, []any{v130})
										tmp166 := checkDerefVar(var_glojure_DOT_core_list)
										tmp167 := lang.Apply(tmp166, []any{v133})
										tmp168 := checkDerefVar(var_glojure_DOT_core_list)
										tmp169 := lang.Apply(tmp168, []any{kw_int})
										tmp170 := lang.Apply(tmp153, []any{tmp155, tmp157, tmp159, tmp161, tmp163, tmp165, tmp167, tmp169})
										tmp171 := lang.Apply(tmp152, []any{tmp170})
										tmp172 := lang.Apply(tmp151, []any{tmp171})
										tmp173 := lang.Apply(tmp135, []any{tmp137, tmp150, tmp172})
										tmp174 := lang.Apply(tmp134, []any{tmp173})
										tmp118 = tmp174
									} // end let
									tmp116 = tmp118
								} else {
									var tmp119 any
									tmp120 := lang.Apply(v114, []any{kw_hashes, v115})
									if lang.IsTruthy(tmp120) {
										var tmp121 any
										{ // let
											// let binding "vec__185"
											tmp122 := checkDerefVar(var_glojure_DOT_core_prep_DASH_hashes)
											tmp123 := lang.Apply(tmp122, []any{v16, v50, v96, v99})
											var v124 any = tmp123
											_ = v124
											// let binding "shift"
											tmp125 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp126 := lang.Apply(tmp125, []any{v124, int64(0), nil})
											var v127 any = tmp126
											_ = v127
											// let binding "mask"
											tmp128 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp129 := lang.Apply(tmp128, []any{v124, int64(1), nil})
											var v130 any = tmp129
											_ = v130
											// let binding "imap"
											tmp131 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp132 := lang.Apply(tmp131, []any{v124, int64(2), nil})
											var v133 any = tmp132
											_ = v133
											// let binding "switch-type"
											tmp134 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp135 := lang.Apply(tmp134, []any{v124, int64(3), nil})
											var v136 any = tmp135
											_ = v136
											// let binding "skip-check"
											tmp137 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp138 := lang.Apply(tmp137, []any{v124, int64(4), nil})
											var v139 any = tmp138
											_ = v139
											tmp140 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp141 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp142 := checkDerefVar(var_glojure_DOT_core_list)
											tmp143 := lang.Apply(tmp142, []any{sym_glojure_DOT_core_SLASH_let})
											tmp144 := checkDerefVar(var_glojure_DOT_core_list)
											tmp145 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp146 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp147 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp148 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp149 := checkDerefVar(var_glojure_DOT_core_list)
											tmp150 := lang.Apply(tmp149, []any{v16})
											tmp151 := checkDerefVar(var_glojure_DOT_core_list)
											tmp152 := lang.Apply(tmp151, []any{v5})
											tmp153 := lang.Apply(tmp148, []any{tmp150, tmp152})
											tmp154 := lang.Apply(tmp147, []any{tmp153})
											tmp155 := lang.Apply(tmp145, []any{tmp146, tmp154})
											tmp156 := lang.Apply(tmp144, []any{tmp155})
											tmp157 := checkDerefVar(var_glojure_DOT_core_list)
											tmp158 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp159 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp160 := checkDerefVar(var_glojure_DOT_core_list)
											tmp161 := lang.Apply(tmp160, []any{sym_case_STAR_})
											tmp162 := checkDerefVar(var_glojure_DOT_core_list)
											tmp163 := lang.Apply(tmp162, []any{v16})
											tmp164 := checkDerefVar(var_glojure_DOT_core_list)
											tmp165 := lang.Apply(tmp164, []any{v127})
											tmp166 := checkDerefVar(var_glojure_DOT_core_list)
											tmp167 := lang.Apply(tmp166, []any{v130})
											tmp168 := checkDerefVar(var_glojure_DOT_core_list)
											tmp169 := lang.Apply(tmp168, []any{v50})
											tmp170 := checkDerefVar(var_glojure_DOT_core_list)
											tmp171 := lang.Apply(tmp170, []any{v133})
											tmp172 := checkDerefVar(var_glojure_DOT_core_list)
											tmp173 := lang.Apply(tmp172, []any{v136})
											tmp174 := checkDerefVar(var_glojure_DOT_core_list)
											tmp175 := lang.Apply(tmp174, []any{kw_hash_DASH_equiv})
											tmp176 := checkDerefVar(var_glojure_DOT_core_list)
											tmp177 := lang.Apply(tmp176, []any{v139})
											tmp178 := lang.Apply(tmp159, []any{tmp161, tmp163, tmp165, tmp167, tmp169, tmp171, tmp173, tmp175, tmp177})
											tmp179 := lang.Apply(tmp158, []any{tmp178})
											tmp180 := lang.Apply(tmp157, []any{tmp179})
											tmp181 := lang.Apply(tmp141, []any{tmp143, tmp156, tmp180})
											tmp182 := lang.Apply(tmp140, []any{tmp181})
											tmp121 = tmp182
										} // end let
										tmp119 = tmp121
									} else {
										var tmp122 any
										tmp123 := lang.Apply(v114, []any{kw_identity, v115})
										if lang.IsTruthy(tmp123) {
											var tmp124 any
											{ // let
												// let binding "vec__188"
												tmp125 := checkDerefVar(var_glojure_DOT_core_prep_DASH_hashes)
												tmp126 := lang.Apply(tmp125, []any{v16, v50, v96, v99})
												var v127 any = tmp126
												_ = v127
												// let binding "shift"
												tmp128 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp129 := lang.Apply(tmp128, []any{v127, int64(0), nil})
												var v130 any = tmp129
												_ = v130
												// let binding "mask"
												tmp131 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp132 := lang.Apply(tmp131, []any{v127, int64(1), nil})
												var v133 any = tmp132
												_ = v133
												// let binding "imap"
												tmp134 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp135 := lang.Apply(tmp134, []any{v127, int64(2), nil})
												var v136 any = tmp135
												_ = v136
												// let binding "switch-type"
												tmp137 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp138 := lang.Apply(tmp137, []any{v127, int64(3), nil})
												var v139 any = tmp138
												_ = v139
												// let binding "skip-check"
												tmp140 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp141 := lang.Apply(tmp140, []any{v127, int64(4), nil})
												var v142 any = tmp141
												_ = v142
												tmp143 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp144 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp145 := checkDerefVar(var_glojure_DOT_core_list)
												tmp146 := lang.Apply(tmp145, []any{sym_glojure_DOT_core_SLASH_let})
												tmp147 := checkDerefVar(var_glojure_DOT_core_list)
												tmp148 := checkDerefVar(var_glojure_DOT_core_apply)
												tmp149 := checkDerefVar(var_glojure_DOT_core_vector)
												tmp150 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp151 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp152 := checkDerefVar(var_glojure_DOT_core_list)
												tmp153 := lang.Apply(tmp152, []any{v16})
												tmp154 := checkDerefVar(var_glojure_DOT_core_list)
												tmp155 := lang.Apply(tmp154, []any{v5})
												tmp156 := lang.Apply(tmp151, []any{tmp153, tmp155})
												tmp157 := lang.Apply(tmp150, []any{tmp156})
												tmp158 := lang.Apply(tmp148, []any{tmp149, tmp157})
												tmp159 := lang.Apply(tmp147, []any{tmp158})
												tmp160 := checkDerefVar(var_glojure_DOT_core_list)
												tmp161 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp162 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp163 := checkDerefVar(var_glojure_DOT_core_list)
												tmp164 := lang.Apply(tmp163, []any{sym_case_STAR_})
												tmp165 := checkDerefVar(var_glojure_DOT_core_list)
												tmp166 := lang.Apply(tmp165, []any{v16})
												tmp167 := checkDerefVar(var_glojure_DOT_core_list)
												tmp168 := lang.Apply(tmp167, []any{v130})
												tmp169 := checkDerefVar(var_glojure_DOT_core_list)
												tmp170 := lang.Apply(tmp169, []any{v133})
												tmp171 := checkDerefVar(var_glojure_DOT_core_list)
												tmp172 := lang.Apply(tmp171, []any{v50})
												tmp173 := checkDerefVar(var_glojure_DOT_core_list)
												tmp174 := lang.Apply(tmp173, []any{v136})
												tmp175 := checkDerefVar(var_glojure_DOT_core_list)
												tmp176 := lang.Apply(tmp175, []any{v139})
												tmp177 := checkDerefVar(var_glojure_DOT_core_list)
												tmp178 := lang.Apply(tmp177, []any{kw_hash_DASH_identity})
												tmp179 := checkDerefVar(var_glojure_DOT_core_list)
												tmp180 := lang.Apply(tmp179, []any{v142})
												tmp181 := lang.Apply(tmp162, []any{tmp164, tmp166, tmp168, tmp170, tmp172, tmp174, tmp176, tmp178, tmp180})
												tmp182 := lang.Apply(tmp161, []any{tmp181})
												tmp183 := lang.Apply(tmp160, []any{tmp182})
												tmp184 := lang.Apply(tmp144, []any{tmp146, tmp159, tmp183})
												tmp185 := lang.Apply(tmp143, []any{tmp184})
												tmp124 = tmp185
											} // end let
											tmp122 = tmp124
										} else {
											tmp125 := checkDerefVar(var_glojure_DOT_core_str)
											tmp126 := lang.Apply(tmp125, []any{"No matching clause: ", v115})
											tmp127 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp126})
											panic(tmp127)
										}
										tmp119 = tmp122
									}
									tmp116 = tmp119
								}
								tmp112 = tmp116
							} // end let
							tmp77 = tmp112
						} // end let
						tmp51 = tmp77
					}
					tmp7 = tmp51
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// case-map
	{
		tmp0 := sym_case_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_case_DASH_f, sym_test_DASH_f, sym_tests, sym_thens)), kw_doc, "Transforms a sequence of test constants and a corresponding sequence of then\n  expressions into a sorted map to be consumed by case*. The form of the map\n  entries are {(case-f test) [(test-f test) then]}.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(6614), kw_end_DASH_line, int(6614), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			tmp7 := checkDerefVar(var_glojure_DOT_core_into1)
			tmp8 := checkDerefVar(var_glojure_DOT_core_sorted_DASH_map)
			tmp9 := lang.Apply(tmp8, nil)
			tmp10 := checkDerefVar(var_glojure_DOT_core_zipmap)
			tmp11 := checkDerefVar(var_glojure_DOT_core_map)
			tmp12 := lang.Apply(tmp11, []any{v3, v5})
			tmp13 := checkDerefVar(var_glojure_DOT_core_map)
			tmp14 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp15 := checkDerefVar(var_glojure_DOT_core_map)
			tmp16 := lang.Apply(tmp15, []any{v4, v5})
			tmp17 := lang.Apply(tmp13, []any{tmp14, tmp16, v6})
			tmp18 := lang.Apply(tmp10, []any{tmp12, tmp17})
			tmp19 := lang.Apply(tmp7, []any{tmp9, tmp18})
			return tmp19
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cast
	{
		tmp0 := sym_cast.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_c, sym_x)), kw_doc, "Throws a ClassCastException if x is not a c, else returns x.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(345), kw_end_DASH_line, int(345))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "cast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("cast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cat
	{
		tmp0 := sym_cat.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_rf)), kw_doc, "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(7645), kw_end_DASH_line, int(7645))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "rrf"
				tmp5 := checkDerefVar(var_glojure_DOT_core_preserving_DASH_reduced)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp9 := lang.Apply(v3, nil)
						return tmp9
					case 1:
						v9 := args[0]
						_ = v9
						tmp10 := lang.Apply(v3, []any{v9})
						return tmp10
					case 2:
						v9 := args[0]
						_ = v9
						v10 := args[1]
						_ = v10
						tmp11 := checkDerefVar(var_glojure_DOT_core_reduce)
						tmp12 := lang.Apply(tmp11, []any{v7, v9, v10})
						return tmp12
					default:
						checkArity(args, -1)
						panic("unreachable")
					}
				})
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7651), kw_column, int(5), kw_end_DASH_line, int(7655), kw_end_DASH_column, int(36))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char
	{
		var tmp1 lang.FnFunc
		{ // function char__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_uncheckedCharCast
				} else {
					tmp14 = sym_charCast
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_char.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to char", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3511), kw_end_DASH_line, int(3511))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime.RT, "CharCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("CharCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-array
	{
		var tmp1 lang.FnFunc
		{ // function char-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_CharArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_char_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of chars", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(5325), kw_end_DASH_line, int(5325))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "CharArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("CharArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "CharArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("CharArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-escape-string
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_char_DASH_escape_DASH_string.WithMeta(lang.NewMap(kw_tag, tmp1, kw_doc, "Returns escape string for char or nil if none", kw_file, "glojure/core_print.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(6), kw_line, int(214), kw_end_DASH_line, int(217))).(*lang.Symbol)
		tmp2 := ns.InternWithValue(tmp0, lang.NewMap(lang.NewChar(10), "\\n", lang.NewChar(9), "\\t", lang.NewChar(13), "\\r", lang.NewChar(34), "\\\"", lang.NewChar(92), "\\\\", lang.NewChar(12), "\\f", lang.NewChar(8), "\\b"), true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-name-string
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_char_DASH_name_DASH_string.WithMeta(lang.NewMap(kw_tag, tmp1, kw_doc, "Returns name string for char or nil if none", kw_file, "glojure/core_print.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(6), kw_line, int(335), kw_end_DASH_line, int(338))).(*lang.Symbol)
		tmp2 := ns.InternWithValue(tmp0, lang.NewMap(lang.NewChar(10), "newline", lang.NewChar(9), "tab", lang.NewChar(32), "space", lang.NewChar(8), "backspace", lang.NewChar(12), "formfeed", lang.NewChar(13), "return"), true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char?
	{
		tmp0 := sym_char_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a Character", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(153), kw_end_DASH_line, int(157))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function char?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf(int32(0))
				tmp7 := lang.Apply(tmp5, []any{tmp6, v4})
				return tmp7
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(157), kw_column, int(8), kw_end_DASH_line, int(157), kw_end_DASH_column, int(89))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chars
	{
		var tmp1 lang.FnFunc
		{ // function chars
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_Chars})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_chars.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to chars[]", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(12), kw_line, int(5382), kw_end_DASH_line, int(5382))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Chars")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Chars is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// check-cyclic-dependency
	{
		tmp0 := sym_check_DASH_cyclic_DASH_dependency.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_path)), kw_doc, "Detects and rejects non-trivial cyclic load dependencies. The\n  exception message shows the dependency chain with the cycle\n  highlighted. Ignores the trivial case of a file attempting to load\n  itself because that can occur when a gen-class'd class loads its\n  implementation.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(30), kw_column, int(8), kw_line, int(5974), kw_end_DASH_line, int(5974), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_some)
			tmp6 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{v3}))
			tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5981), kw_column, int(15), kw_end_DASH_line, int(5981), kw_end_DASH_column, int(21))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := checkDerefVar(var_glojure_DOT_core_rest)
			tmp10 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
			tmp11 := lang.Apply(tmp9, []any{tmp10})
			tmp12 := lang.Apply(tmp5, []any{tmp8, tmp11})
			if lang.IsTruthy(tmp12) {
				var tmp13 any
				{ // let
					// let binding "pending"
					tmp14 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp15 lang.FnFunc
					tmp15 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v16 := args[0]
						_ = v16
						var tmp17 any
						tmp18 := checkDerefVar(var_glojure_DOT_core__EQ_)
						tmp19 := lang.Apply(tmp18, []any{v16, v3})
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(var_glojure_DOT_core_str)
							tmp21 := lang.Apply(tmp20, []any{"[ ", v16, " ]"})
							tmp17 = tmp21
						} else {
							tmp17 = v16
						}
						return tmp17
					})
					tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5982), kw_column, int(24), kw_end_DASH_line, int(5982), kw_end_DASH_column, int(59))
					tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp18 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp19 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
					tmp20 := lang.Apply(tmp18, []any{v3, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp17, tmp20})
					var v22 any = tmp21
					_ = v22
					// let binding "chain"
					tmp23 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_interpose)
					tmp26 := lang.Apply(tmp25, []any{"->", v22})
					tmp27 := lang.Apply(tmp23, []any{tmp24, tmp26})
					var v28 any = tmp27
					_ = v28
					tmp29 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
					tmp30 := lang.Apply(tmp29, []any{true, "Cyclic load dependency: %s", v28})
					tmp13 = tmp30
				} // end let
				tmp4 = tmp13
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// check-valid-options
	{
		tmp0 := sym_check_DASH_valid_DASH_options.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_options, sym__AMP_, sym_valid_DASH_keys)), kw_doc, "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(35), kw_column, int(7), kw_line, int(1709), kw_end_DASH_line, int(1709), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_disj)
				tmp9 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp10 := checkDerefVar(var_glojure_DOT_core_hash_DASH_set)
				tmp11 := checkDerefVar(var_glojure_DOT_core_keys)
				tmp12 := lang.Apply(tmp11, []any{v3})
				tmp13 := lang.Apply(tmp9, []any{tmp10, tmp12})
				tmp14 := lang.Apply(tmp7, []any{tmp8, tmp13, v4})
				tmp15 := lang.Apply(tmp6, []any{tmp14})
				if lang.IsTruthy(tmp15) {
					tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp17 := checkDerefVar(var_glojure_DOT_core_str)
					tmp18 := checkDerefVar(var_glojure_DOT_core_first)
					tmp19 := lang.Apply(tmp18, []any{v4})
					tmp20 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp21 lang.FnFunc
					tmp21 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v22 := args[0]
						_ = v22
						tmp23 := checkDerefVar(var_glojure_DOT_core_str)
						tmp24 := lang.Apply(tmp23, []any{", ", v22})
						return tmp24
					})
					tmp22 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1718), kw_column, int(16), kw_end_DASH_line, int(1718), kw_end_DASH_column, int(28))
					tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp24 := checkDerefVar(var_glojure_DOT_core_rest)
					tmp25 := lang.Apply(tmp24, []any{v4})
					tmp26 := lang.Apply(tmp20, []any{tmp23, tmp25})
					tmp27 := lang.Apply(tmp16, []any{tmp17, "Only these options are valid: ", tmp19, tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				} else {
				}
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk
	{
		tmp0 := sym_chunk.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(691), kw_column, int(7), kw_end_DASH_line, int(691), kw_end_DASH_column, int(41), kw_arglists, lang.NewList(lang.NewVector(sym_b)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunk")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunk")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-append
	{
		tmp0 := sym_chunk_DASH_append.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(688), kw_column, int(7), kw_end_DASH_line, int(688), kw_end_DASH_column, int(27), kw_arglists, lang.NewList(lang.NewVector(sym_b, sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "add")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-buffer
	{
		tmp0 := sym_chunk_DASH_buffer.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(685), kw_column, int(7), kw_end_DASH_line, int(685), kw_end_DASH_column, int(53), kw_arglists, lang.NewList(lang.NewVector(sym_capacity)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.NewChunkBuffer, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-cons
	{
		tmp0 := sym_chunk_DASH_cons.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(703), kw_column, int(7), kw_end_DASH_line, int(703), kw_end_DASH_column, int(25), kw_arglists, lang.NewList(lang.NewVector(sym_chunk, sym_rest)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := lang.Apply(lang.Count, []any{v3})
			tmp7 := lang.Apply(lang.IsZero, []any{tmp6})
			if lang.IsTruthy(tmp7) {
				tmp5 = v4
			} else {
				tmp8 := lang.Apply(lang.NewChunkedCons, []any{v3, v4})
				tmp5 = tmp8
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-first
	{
		tmp0 := sym_chunk_DASH_first.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(694), kw_column, int(7), kw_end_DASH_line, int(694), kw_end_DASH_column, int(48), kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunkedFirst")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunkedFirst")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-next
	{
		tmp0 := sym_chunk_DASH_next.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(700), kw_column, int(7), kw_end_DASH_line, int(700), kw_end_DASH_column, int(71), kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunkedNext")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunkedNext")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-rest
	{
		tmp0 := sym_chunk_DASH_rest.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(697), kw_column, int(7), kw_end_DASH_line, int(697), kw_end_DASH_column, int(71), kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunkedMore")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunkedMore")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunked-seq?
	{
		tmp0 := sym_chunked_DASH_seq_QMARK_.WithMeta(lang.NewMap(kw_static, true, kw_file, "glojure/core.glj", kw_line, int(708), kw_column, int(7), kw_end_DASH_line, int(708), kw_end_DASH_column, int(27), kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.IChunkedSeq)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// class
	{
		tmp0 := sym_class.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns the Class of x", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3461), kw_end_DASH_line, int(3461))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp4 = v3
			} else {
				tmp7 := lang.Apply(lang.TypeOf, []any{v3})
				tmp4 = tmp7
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// class?
	{
		tmp0 := sym_class_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is an instance of Class", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5465), kw_end_DASH_line, int(5465))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// clear-agent-errors
	{
		tmp0 := sym_clear_DASH_agent_DASH_errors.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_doc, "DEPRECATED: Use 'restart-agent' instead.\n  Clears any exceptions thrown during asynchronous actions of the\n  agent, allowing subsequent actions to occur.", kw_file, "glojure/core.glj", kw_deprecated, "1.2", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(2244), kw_end_DASH_line, int(2244))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_restart_DASH_agent)
			tmp5, ok := lang.FieldOrMethod(v3, "Deref")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Deref")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{v3, tmp6})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// coll?
	{
		tmp0 := sym_coll_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x implements IPersistentCollection", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(6192), kw_end_DASH_line, int(6192))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comment
	{
		tmp0 := sym_comment.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Ignores body, yields nil", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(4733), kw_end_DASH_line, int(4733))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				return nil
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// commute
	{
		tmp0 := sym_commute.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref, sym_fun, sym__AMP_, sym_args)), kw_doc, "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(2414), kw_end_DASH_line, int(2414))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "Commute")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Commute is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comp
	{
		tmp0 := sym_comp.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_f), lang.NewVector(sym_f, sym_g), lang.NewVector(sym_f, sym_g, sym__AMP_, sym_fs)), kw_doc, "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2549), kw_end_DASH_line, int(2549))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(var_glojure_DOT_core_identity)
				return tmp3
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v4, nil)
						tmp7 := lang.Apply(v3, []any{tmp6})
						return tmp7
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v4, []any{v6})
						tmp8 := lang.Apply(v3, []any{tmp7})
						return tmp8
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v4, []any{v6, v7})
						tmp9 := lang.Apply(v3, []any{tmp8})
						return tmp9
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						tmp9 := lang.Apply(v4, []any{v6, v7, v8})
						tmp10 := lang.Apply(v3, []any{tmp9})
						return tmp10
					default:
						checkArity(args, 3)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp11 := lang.Apply(tmp10, []any{v4, v6, v7, v8, v9})
						tmp12 := lang.Apply(v3, []any{tmp11})
						return tmp12
					}
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2559), kw_column, int(6), kw_end_DASH_line, int(2564), kw_end_DASH_column, int(49))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp7 := checkDerefVar(var_glojure_DOT_core_comp)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp9 := lang.Apply(tmp8, []any{v3, v4, v5})
				tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comparator
	{
		tmp0 := sym_comparator.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred)), kw_doc, "Returns an implementation of java.util.Comparator based upon pred.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(3077), kw_end_DASH_line, int(3077))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var tmp7 any
				tmp8 := lang.Apply(v3, []any{v5, v6})
				if lang.IsTruthy(tmp8) {
					tmp7 = int64(-1)
				} else {
					var tmp9 any
					tmp10 := lang.Apply(v3, []any{v6, v5})
					if lang.IsTruthy(tmp10) {
						tmp9 = int64(1)
					} else {
						var tmp11 any
						if lang.IsTruthy(kw_else) {
							tmp11 = int64(0)
						} else {
						}
						tmp9 = tmp11
					}
					tmp7 = tmp9
				}
				return tmp7
			})
			tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3082), kw_column, int(5), kw_end_DASH_line, int(3083), kw_end_DASH_column, int(48))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compare
	{
		var tmp1 lang.FnFunc
		{ // function compare__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_lang_DOT_Util})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{sym_glojure_DOT_core_SLASH_compare})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp5, []any{tmp17})
				return tmp18
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_compare.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Same as Java x.compareTo(y) except it also works for nil, and\n  compares numbers and collections in a type-independent manner. x\n  must implement Comparable", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(824), kw_end_DASH_line, int(824))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := lang.Apply(lang.Compare, []any{v4, v5})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compare-and-set!
	{
		tmp0 := sym_compare_DASH_and_DASH_set_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atom, sym_oldval, sym_newval)), kw_doc, "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(2360), kw_end_DASH_line, int(2360))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(v3, "compareAndSet")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("compareAndSet is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compile
	{
		tmp0 := sym_compile.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_lib)), kw_doc, "Compiles the namespace named by the symbol lib into a set of\n  classfiles. The source for the lib must be in a proper\n  classpath-relative directory. The output files will go into the\n  directory specified by *compile-path*, and that directory too must\n  be in the classpath.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6114), kw_end_DASH_line, int(6114))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				tmp5 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp6 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
				tmp7 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_compile_DASH_files_STAR_)
				tmp8 := lang.Apply(tmp6, []any{tmp7, true})
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				_ = tmp9
				var tmp10 any
				func() {
					defer func() {
						tmp11 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp12 := lang.Apply(tmp11, nil)
						_ = tmp12
					}()
					tmp13 := checkDerefVar(var_glojure_DOT_core_load_DASH_one)
					tmp14 := lang.Apply(tmp13, []any{v3, true, true})
					tmp10 = tmp14
				}()
				tmp4 = tmp10
			} // end let
			_ = tmp4
			return v3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// complement
	{
		tmp0 := sym_complement.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(1428), kw_end_DASH_line, int(1428))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 0:
					tmp5 := checkDerefVar(var_glojure_DOT_core_not)
					tmp6 := lang.Apply(v3, nil)
					tmp7 := lang.Apply(tmp5, []any{tmp6})
					return tmp7
				case 1:
					v5 := args[0]
					_ = v5
					tmp6 := checkDerefVar(var_glojure_DOT_core_not)
					tmp7 := lang.Apply(v3, []any{v5})
					tmp8 := lang.Apply(tmp6, []any{tmp7})
					return tmp8
				case 2:
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_not)
					tmp8 := lang.Apply(v3, []any{v5, v6})
					tmp9 := lang.Apply(tmp7, []any{tmp8})
					return tmp9
				default:
					checkArity(args, 2)
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					var v7 any = lang.NewList(args[2:]...)
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_not)
					tmp9 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp10 := lang.Apply(tmp9, []any{v3, v5, v6, v7})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					return tmp11
				}
			})
			tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1434), kw_column, int(3), kw_end_DASH_line, int(1438), kw_end_DASH_column, int(40))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// completing
	{
		tmp0 := sym_completing.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_cf)), kw_doc, "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(6893), kw_end_DASH_line, int(6893))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_completing)
				tmp5 := checkDerefVar(var_glojure_DOT_core_identity)
				tmp6 := lang.Apply(tmp4, []any{v3, tmp5})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v3, nil)
						return tmp6
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v4, []any{v6})
						return tmp7
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v6, v7})
						return tmp8
					default:
						checkArity(args, -1)
						panic("unreachable")
					}
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6900), kw_column, int(6), kw_end_DASH_line, int(6903), kw_end_DASH_column, int(23))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// concat
	{
		tmp0 := sym_concat.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_zs)), kw_doc, "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(711), kw_end_DASH_line, int(711))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					return nil
				})
				tmp4 := lang.Apply(lang.NewLazySeq, []any{tmp3})
				return tmp4
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					return v3
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "s"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v3})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							tmp12 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
							tmp13 := lang.Apply(tmp12, []any{v9})
							if lang.IsTruthy(tmp13) {
								tmp14 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
								tmp15 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
								tmp16 := lang.Apply(tmp15, []any{v9})
								tmp17 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp18 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
								tmp19 := lang.Apply(tmp18, []any{v9})
								tmp20 := lang.Apply(tmp17, []any{tmp19, v4})
								tmp21 := lang.Apply(tmp14, []any{tmp16, tmp20})
								tmp11 = tmp21
							} else {
								tmp22 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp23 := checkDerefVar(var_glojure_DOT_core_first)
								tmp24 := lang.Apply(tmp23, []any{v9})
								tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp26 := checkDerefVar(var_glojure_DOT_core_rest)
								tmp27 := lang.Apply(tmp26, []any{v9})
								tmp28 := lang.Apply(tmp25, []any{tmp27, v4})
								tmp29 := lang.Apply(tmp22, []any{tmp24, tmp28})
								tmp11 = tmp29
							}
							tmp10 = tmp11
						} else {
							tmp10 = v4
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "cat"
					var tmp7 lang.FnFunc
					{ // function cat
						var v8 lang.FnFunc
						tmp7 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v9 := args[0]
							_ = v9
							v10 := args[1]
							_ = v10
							var tmp11 lang.FnFunc
							tmp11 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								var tmp12 any
								{ // let
									// let binding "xys"
									tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp14 := lang.Apply(tmp13, []any{v9})
									var v15 any = tmp14
									_ = v15
									var tmp16 any
									if lang.IsTruthy(v15) {
										var tmp17 any
										tmp18 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
										tmp19 := lang.Apply(tmp18, []any{v15})
										if lang.IsTruthy(tmp19) {
											tmp20 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
											tmp21 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
											tmp22 := lang.Apply(tmp21, []any{v15})
											tmp23 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
											tmp24 := lang.Apply(tmp23, []any{v15})
											tmp25 := lang.Apply(v8, []any{tmp24, v10})
											tmp26 := lang.Apply(tmp20, []any{tmp22, tmp25})
											tmp17 = tmp26
										} else {
											tmp27 := checkDerefVar(var_glojure_DOT_core_cons)
											tmp28 := checkDerefVar(var_glojure_DOT_core_first)
											tmp29 := lang.Apply(tmp28, []any{v15})
											tmp30 := checkDerefVar(var_glojure_DOT_core_rest)
											tmp31 := lang.Apply(tmp30, []any{v15})
											tmp32 := lang.Apply(v8, []any{tmp31, v10})
											tmp33 := lang.Apply(tmp27, []any{tmp29, tmp32})
											tmp17 = tmp33
										}
										tmp16 = tmp17
									} else {
										var tmp34 any
										if lang.IsTruthy(v10) {
											tmp35 := checkDerefVar(var_glojure_DOT_core_first)
											tmp36 := lang.Apply(tmp35, []any{v10})
											tmp37 := checkDerefVar(var_glojure_DOT_core_next)
											tmp38 := lang.Apply(tmp37, []any{v10})
											tmp39 := lang.Apply(v8, []any{tmp36, tmp38})
											tmp34 = tmp39
										} else {
										}
										tmp16 = tmp34
									}
									tmp12 = tmp16
								} // end let
								return tmp12
							})
							tmp12 := lang.Apply(lang.NewLazySeq, []any{tmp11})
							return tmp12
						})
						v8 = tmp7
						_ = v8
					}
					tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(726), kw_column, int(16), kw_end_DASH_line, int(735), kw_end_DASH_column, int(56))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v10 any = tmp9
					_ = v10
					tmp11 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp12 := lang.Apply(tmp11, []any{v3, v4})
					tmp13 := lang.Apply(v10, []any{tmp12, v5})
					tmp6 = tmp13
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond
	{
		tmp0 := sym_cond.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_clauses)), kw_doc, "Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(569), kw_end_DASH_line, int(569))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v5) {
					tmp7 := checkDerefVar(var_glojure_DOT_core_list)
					tmp8 := checkDerefVar(var_glojure_DOT_core_first)
					tmp9 := lang.Apply(tmp8, []any{v5})
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v5})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(var_glojure_DOT_core_second)
						tmp14 := lang.Apply(tmp13, []any{v5})
						tmp10 = tmp14
					} else {
						tmp15 := lang.Apply(lang.NewIllegalArgumentError, []any{"cond requires an even number of forms"})
						panic(tmp15)
					}
					tmp16 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp17 := checkDerefVar(var_glojure_DOT_core_next)
					tmp18 := checkDerefVar(var_glojure_DOT_core_next)
					tmp19 := lang.Apply(tmp18, []any{v5})
					tmp20 := lang.Apply(tmp17, []any{tmp19})
					tmp21 := lang.Apply(tmp16, []any{sym_glojure_DOT_core_SLASH_cond, tmp20})
					tmp22 := lang.Apply(tmp7, []any{sym_if, tmp9, tmp10, tmp21})
					tmp6 = tmp22
				} else {
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond->
	{
		tmp0 := sym_cond_DASH__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr, sym__AMP_, sym_clauses)), kw_doc, "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression.", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(7564), kw_end_DASH_line, int(7564))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, nil)
					var v10 any = tmp9
					_ = v10
					// let binding "steps"
					tmp11 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp12 lang.FnFunc
					tmp12 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v13 := args[0]
						_ = v13
						var tmp14 any
						{ // let
							// let binding "vec__349"
							var v15 any = v13
							_ = v15
							// let binding "test"
							tmp16 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp17 := lang.Apply(tmp16, []any{v15, int64(0), nil})
							var v18 any = tmp17
							_ = v18
							// let binding "step"
							tmp19 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp20 := lang.Apply(tmp19, []any{v15, int64(1), nil})
							var v21 any = tmp20
							_ = v21
							tmp22 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp23 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp24 := checkDerefVar(var_glojure_DOT_core_list)
							tmp25 := lang.Apply(tmp24, []any{sym_if})
							tmp26 := checkDerefVar(var_glojure_DOT_core_list)
							tmp27 := lang.Apply(tmp26, []any{v18})
							tmp28 := checkDerefVar(var_glojure_DOT_core_list)
							tmp29 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp30 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp31 := checkDerefVar(var_glojure_DOT_core_list)
							tmp32 := lang.Apply(tmp31, []any{sym_glojure_DOT_core_SLASH__DASH__GT_})
							tmp33 := checkDerefVar(var_glojure_DOT_core_list)
							tmp34 := lang.Apply(tmp33, []any{v10})
							tmp35 := checkDerefVar(var_glojure_DOT_core_list)
							tmp36 := lang.Apply(tmp35, []any{v21})
							tmp37 := lang.Apply(tmp30, []any{tmp32, tmp34, tmp36})
							tmp38 := lang.Apply(tmp29, []any{tmp37})
							tmp39 := lang.Apply(tmp28, []any{tmp38})
							tmp40 := checkDerefVar(var_glojure_DOT_core_list)
							tmp41 := lang.Apply(tmp40, []any{v10})
							tmp42 := lang.Apply(tmp23, []any{tmp25, tmp27, tmp39, tmp41})
							tmp43 := lang.Apply(tmp22, []any{tmp42})
							tmp14 = tmp43
						} // end let
						return tmp14
					})
					tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7573), kw_column, int(20), kw_end_DASH_line, int(7573), kw_end_DASH_column, int(66))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := checkDerefVar(var_glojure_DOT_core_partition)
					tmp16 := lang.Apply(tmp15, []any{int64(2), v6})
					tmp17 := lang.Apply(tmp11, []any{tmp14, tmp16})
					var v18 any = tmp17
					_ = v18
					tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{sym_glojure_DOT_core_SLASH_let})
					tmp23 := checkDerefVar(var_glojure_DOT_core_list)
					tmp24 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp25 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp27 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp28 := checkDerefVar(var_glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{v10})
					tmp30 := checkDerefVar(var_glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{v5})
					tmp32 := checkDerefVar(var_glojure_DOT_core_interleave)
					tmp33 := checkDerefVar(var_glojure_DOT_core_repeat)
					tmp34 := lang.Apply(tmp33, []any{v10})
					tmp35 := checkDerefVar(var_glojure_DOT_core_butlast)
					tmp36 := lang.Apply(tmp35, []any{v18})
					tmp37 := lang.Apply(tmp32, []any{tmp34, tmp36})
					tmp38 := lang.Apply(tmp27, []any{tmp29, tmp31, tmp37})
					tmp39 := lang.Apply(tmp26, []any{tmp38})
					tmp40 := lang.Apply(tmp24, []any{tmp25, tmp39})
					tmp41 := lang.Apply(tmp23, []any{tmp40})
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					var tmp43 any
					tmp44 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
					tmp45 := lang.Apply(tmp44, []any{v18})
					if lang.IsTruthy(tmp45) {
						tmp43 = v10
					} else {
						tmp46 := checkDerefVar(var_glojure_DOT_core_last)
						tmp47 := lang.Apply(tmp46, []any{v18})
						tmp43 = tmp47
					}
					tmp48 := lang.Apply(tmp42, []any{tmp43})
					tmp49 := lang.Apply(tmp20, []any{tmp22, tmp41, tmp48})
					tmp50 := lang.Apply(tmp19, []any{tmp49})
					tmp7 = tmp50
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond->>
	{
		tmp0 := sym_cond_DASH__GT__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr, sym__AMP_, sym_clauses)), kw_doc, "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression.", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(7581), kw_end_DASH_line, int(7581))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, nil)
					var v10 any = tmp9
					_ = v10
					// let binding "steps"
					tmp11 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp12 lang.FnFunc
					tmp12 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v13 := args[0]
						_ = v13
						var tmp14 any
						{ // let
							// let binding "vec__353"
							var v15 any = v13
							_ = v15
							// let binding "test"
							tmp16 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp17 := lang.Apply(tmp16, []any{v15, int64(0), nil})
							var v18 any = tmp17
							_ = v18
							// let binding "step"
							tmp19 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp20 := lang.Apply(tmp19, []any{v15, int64(1), nil})
							var v21 any = tmp20
							_ = v21
							tmp22 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp23 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp24 := checkDerefVar(var_glojure_DOT_core_list)
							tmp25 := lang.Apply(tmp24, []any{sym_if})
							tmp26 := checkDerefVar(var_glojure_DOT_core_list)
							tmp27 := lang.Apply(tmp26, []any{v18})
							tmp28 := checkDerefVar(var_glojure_DOT_core_list)
							tmp29 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp30 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp31 := checkDerefVar(var_glojure_DOT_core_list)
							tmp32 := lang.Apply(tmp31, []any{sym_glojure_DOT_core_SLASH__DASH__GT__GT_})
							tmp33 := checkDerefVar(var_glojure_DOT_core_list)
							tmp34 := lang.Apply(tmp33, []any{v10})
							tmp35 := checkDerefVar(var_glojure_DOT_core_list)
							tmp36 := lang.Apply(tmp35, []any{v21})
							tmp37 := lang.Apply(tmp30, []any{tmp32, tmp34, tmp36})
							tmp38 := lang.Apply(tmp29, []any{tmp37})
							tmp39 := lang.Apply(tmp28, []any{tmp38})
							tmp40 := checkDerefVar(var_glojure_DOT_core_list)
							tmp41 := lang.Apply(tmp40, []any{v10})
							tmp42 := lang.Apply(tmp23, []any{tmp25, tmp27, tmp39, tmp41})
							tmp43 := lang.Apply(tmp22, []any{tmp42})
							tmp14 = tmp43
						} // end let
						return tmp14
					})
					tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7590), kw_column, int(20), kw_end_DASH_line, int(7590), kw_end_DASH_column, int(67))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := checkDerefVar(var_glojure_DOT_core_partition)
					tmp16 := lang.Apply(tmp15, []any{int64(2), v6})
					tmp17 := lang.Apply(tmp11, []any{tmp14, tmp16})
					var v18 any = tmp17
					_ = v18
					tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{sym_glojure_DOT_core_SLASH_let})
					tmp23 := checkDerefVar(var_glojure_DOT_core_list)
					tmp24 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp25 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp27 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp28 := checkDerefVar(var_glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{v10})
					tmp30 := checkDerefVar(var_glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{v5})
					tmp32 := checkDerefVar(var_glojure_DOT_core_interleave)
					tmp33 := checkDerefVar(var_glojure_DOT_core_repeat)
					tmp34 := lang.Apply(tmp33, []any{v10})
					tmp35 := checkDerefVar(var_glojure_DOT_core_butlast)
					tmp36 := lang.Apply(tmp35, []any{v18})
					tmp37 := lang.Apply(tmp32, []any{tmp34, tmp36})
					tmp38 := lang.Apply(tmp27, []any{tmp29, tmp31, tmp37})
					tmp39 := lang.Apply(tmp26, []any{tmp38})
					tmp40 := lang.Apply(tmp24, []any{tmp25, tmp39})
					tmp41 := lang.Apply(tmp23, []any{tmp40})
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					var tmp43 any
					tmp44 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
					tmp45 := lang.Apply(tmp44, []any{v18})
					if lang.IsTruthy(tmp45) {
						tmp43 = v10
					} else {
						tmp46 := checkDerefVar(var_glojure_DOT_core_last)
						tmp47 := lang.Apply(tmp46, []any{v18})
						tmp43 = tmp47
					}
					tmp48 := lang.Apply(tmp42, []any{tmp43})
					tmp49 := lang.Apply(tmp20, []any{tmp22, tmp41, tmp48})
					tmp50 := lang.Apply(tmp19, []any{tmp49})
					tmp7 = tmp50
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// condp
	{
		tmp0 := sym_condp.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_expr, sym__AMP_, sym_clauses)), kw_doc, "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(6353), kw_end_DASH_line, int(6353))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 4)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 any
				{ // let
					// let binding "gpred"
					tmp9 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp10 := lang.Apply(tmp9, []any{"pred__"})
					var v11 any = tmp10
					_ = v11
					// let binding "gexpr"
					tmp12 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp13 := lang.Apply(tmp12, []any{"expr__"})
					var v14 any = tmp13
					_ = v14
					// let binding "emit"
					var tmp15 lang.FnFunc
					{ // function emit
						var v16 lang.FnFunc
						tmp15 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 3)
							v17 := args[0]
							_ = v17
							v18 := args[1]
							_ = v18
							v19 := args[2]
							_ = v19
							var tmp20 any
							{ // let
								// let binding "vec__144"
								tmp21 := checkDerefVar(var_glojure_DOT_core_split_DASH_at)
								var tmp22 any
								tmp23 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp24 := checkDerefVar(var_glojure_DOT_core_second)
								tmp25 := lang.Apply(tmp24, []any{v19})
								tmp26 := lang.Apply(tmp23, []any{kw__GT__GT_, tmp25})
								if lang.IsTruthy(tmp26) {
									tmp22 = int64(3)
								} else {
									tmp22 = int64(2)
								}
								tmp27 := lang.Apply(tmp21, []any{tmp22, v19})
								var v28 any = tmp27
								_ = v28
								// let binding "vec__147"
								tmp29 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp30 := lang.Apply(tmp29, []any{v28, int64(0), nil})
								var v31 any = tmp30
								_ = v31
								// let binding "a"
								tmp32 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp33 := lang.Apply(tmp32, []any{v31, int64(0), nil})
								var v34 any = tmp33
								_ = v34
								// let binding "b"
								tmp35 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp36 := lang.Apply(tmp35, []any{v31, int64(1), nil})
								var v37 any = tmp36
								_ = v37
								// let binding "c"
								tmp38 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp39 := lang.Apply(tmp38, []any{v31, int64(2), nil})
								var v40 any = tmp39
								_ = v40
								// let binding "clause"
								var v41 any = v31
								_ = v41
								// let binding "more"
								tmp42 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp43 := lang.Apply(tmp42, []any{v28, int64(1), nil})
								var v44 any = tmp43
								_ = v44
								// let binding "n"
								tmp45 := checkDerefVar(var_glojure_DOT_core_count)
								tmp46 := lang.Apply(tmp45, []any{v41})
								var v47 any = tmp46
								_ = v47
								var tmp48 any
								tmp49 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp50 := lang.Apply(tmp49, []any{int64(0), v47})
								if lang.IsTruthy(tmp50) {
									tmp51 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp52 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp53 := checkDerefVar(var_glojure_DOT_core_list)
									tmp54 := lang.Apply(tmp53, []any{sym_throw})
									tmp55 := checkDerefVar(var_glojure_DOT_core_list)
									tmp56 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp57 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp58 := checkDerefVar(var_glojure_DOT_core_list)
									tmp59 := lang.Apply(tmp58, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewIllegalArgumentError})
									tmp60 := checkDerefVar(var_glojure_DOT_core_list)
									tmp61 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp62 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp63 := checkDerefVar(var_glojure_DOT_core_list)
									tmp64 := lang.Apply(tmp63, []any{sym_glojure_DOT_core_SLASH_str})
									tmp65 := checkDerefVar(var_glojure_DOT_core_list)
									tmp66 := lang.Apply(tmp65, []any{"No matching clause: "})
									tmp67 := checkDerefVar(var_glojure_DOT_core_list)
									tmp68 := lang.Apply(tmp67, []any{v18})
									tmp69 := lang.Apply(tmp62, []any{tmp64, tmp66, tmp68})
									tmp70 := lang.Apply(tmp61, []any{tmp69})
									tmp71 := lang.Apply(tmp60, []any{tmp70})
									tmp72 := lang.Apply(tmp57, []any{tmp59, tmp71})
									tmp73 := lang.Apply(tmp56, []any{tmp72})
									tmp74 := lang.Apply(tmp55, []any{tmp73})
									tmp75 := lang.Apply(tmp52, []any{tmp54, tmp74})
									tmp76 := lang.Apply(tmp51, []any{tmp75})
									tmp48 = tmp76
								} else {
									var tmp77 any
									tmp78 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp79 := lang.Apply(tmp78, []any{int64(1), v47})
									if lang.IsTruthy(tmp79) {
										tmp77 = v34
									} else {
										var tmp80 any
										tmp81 := checkDerefVar(var_glojure_DOT_core__EQ_)
										tmp82 := lang.Apply(tmp81, []any{int64(2), v47})
										if lang.IsTruthy(tmp82) {
											tmp83 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp84 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp85 := checkDerefVar(var_glojure_DOT_core_list)
											tmp86 := lang.Apply(tmp85, []any{sym_if})
											tmp87 := checkDerefVar(var_glojure_DOT_core_list)
											tmp88 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp89 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp90 := checkDerefVar(var_glojure_DOT_core_list)
											tmp91 := lang.Apply(tmp90, []any{v17})
											tmp92 := checkDerefVar(var_glojure_DOT_core_list)
											tmp93 := lang.Apply(tmp92, []any{v34})
											tmp94 := checkDerefVar(var_glojure_DOT_core_list)
											tmp95 := lang.Apply(tmp94, []any{v18})
											tmp96 := lang.Apply(tmp89, []any{tmp91, tmp93, tmp95})
											tmp97 := lang.Apply(tmp88, []any{tmp96})
											tmp98 := lang.Apply(tmp87, []any{tmp97})
											tmp99 := checkDerefVar(var_glojure_DOT_core_list)
											tmp100 := lang.Apply(tmp99, []any{v37})
											tmp101 := checkDerefVar(var_glojure_DOT_core_list)
											tmp102 := lang.Apply(v16, []any{v17, v18, v44})
											tmp103 := lang.Apply(tmp101, []any{tmp102})
											tmp104 := lang.Apply(tmp84, []any{tmp86, tmp98, tmp100, tmp103})
											tmp105 := lang.Apply(tmp83, []any{tmp104})
											tmp80 = tmp105
										} else {
											var tmp106 any
											if lang.IsTruthy(kw_else) {
												tmp107 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp108 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp109 := checkDerefVar(var_glojure_DOT_core_list)
												tmp110 := lang.Apply(tmp109, []any{sym_glojure_DOT_core_SLASH_if_DASH_let})
												tmp111 := checkDerefVar(var_glojure_DOT_core_list)
												tmp112 := checkDerefVar(var_glojure_DOT_core_apply)
												tmp113 := checkDerefVar(var_glojure_DOT_core_vector)
												tmp114 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp115 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp116 := checkDerefVar(var_glojure_DOT_core_list)
												tmp117 := lang.Apply(tmp116, []any{sym_p__0__auto__})
												tmp118 := checkDerefVar(var_glojure_DOT_core_list)
												tmp119 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp120 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp121 := checkDerefVar(var_glojure_DOT_core_list)
												tmp122 := lang.Apply(tmp121, []any{v17})
												tmp123 := checkDerefVar(var_glojure_DOT_core_list)
												tmp124 := lang.Apply(tmp123, []any{v34})
												tmp125 := checkDerefVar(var_glojure_DOT_core_list)
												tmp126 := lang.Apply(tmp125, []any{v18})
												tmp127 := lang.Apply(tmp120, []any{tmp122, tmp124, tmp126})
												tmp128 := lang.Apply(tmp119, []any{tmp127})
												tmp129 := lang.Apply(tmp118, []any{tmp128})
												tmp130 := lang.Apply(tmp115, []any{tmp117, tmp129})
												tmp131 := lang.Apply(tmp114, []any{tmp130})
												tmp132 := lang.Apply(tmp112, []any{tmp113, tmp131})
												tmp133 := lang.Apply(tmp111, []any{tmp132})
												tmp134 := checkDerefVar(var_glojure_DOT_core_list)
												tmp135 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp136 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp137 := checkDerefVar(var_glojure_DOT_core_list)
												tmp138 := lang.Apply(tmp137, []any{v40})
												tmp139 := checkDerefVar(var_glojure_DOT_core_list)
												tmp140 := lang.Apply(tmp139, []any{sym_p__0__auto__})
												tmp141 := lang.Apply(tmp136, []any{tmp138, tmp140})
												tmp142 := lang.Apply(tmp135, []any{tmp141})
												tmp143 := lang.Apply(tmp134, []any{tmp142})
												tmp144 := checkDerefVar(var_glojure_DOT_core_list)
												tmp145 := lang.Apply(v16, []any{v17, v18, v44})
												tmp146 := lang.Apply(tmp144, []any{tmp145})
												tmp147 := lang.Apply(tmp108, []any{tmp110, tmp133, tmp143, tmp146})
												tmp148 := lang.Apply(tmp107, []any{tmp147})
												tmp106 = tmp148
											} else {
											}
											tmp80 = tmp106
										}
										tmp77 = tmp80
									}
									tmp48 = tmp77
								}
								tmp20 = tmp48
							} // end let
							return tmp20
						})
						v16 = tmp15
						_ = v16
					}
					tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6377), kw_column, int(14), kw_end_DASH_line, int(6389), kw_end_DASH_column, int(53))
					tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v18 any = tmp17
					_ = v18
					tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{sym_glojure_DOT_core_SLASH_let})
					tmp23 := checkDerefVar(var_glojure_DOT_core_list)
					tmp24 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp25 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp27 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp28 := checkDerefVar(var_glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{v11})
					tmp30 := checkDerefVar(var_glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{v5})
					tmp32 := checkDerefVar(var_glojure_DOT_core_list)
					tmp33 := lang.Apply(tmp32, []any{v14})
					tmp34 := checkDerefVar(var_glojure_DOT_core_list)
					tmp35 := lang.Apply(tmp34, []any{v6})
					tmp36 := lang.Apply(tmp27, []any{tmp29, tmp31, tmp33, tmp35})
					tmp37 := lang.Apply(tmp26, []any{tmp36})
					tmp38 := lang.Apply(tmp24, []any{tmp25, tmp37})
					tmp39 := lang.Apply(tmp23, []any{tmp38})
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(v18, []any{v11, v14, v7})
					tmp42 := lang.Apply(tmp40, []any{tmp41})
					tmp43 := lang.Apply(tmp20, []any{tmp22, tmp39, tmp42})
					tmp44 := lang.Apply(tmp19, []any{tmp43})
					tmp8 = tmp44
				} // end let
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// conj
	{
		tmp0 := sym_conj.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_coll), lang.NewVector(sym_coll, sym_x), lang.NewVector(sym_coll, sym_x, sym__AMP_, sym_xs)), kw_doc, "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).\n    (conj coll) returns coll. (conj) returns [].\n    The 'addition' may happen at different 'places' depending\n    on the concrete type.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(73), kw_end_DASH_line, int(81))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function conj
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 0:
					tmp4 := lang.NewVector()
					tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(82), kw_column, int(13), kw_end_DASH_line, int(82), kw_end_DASH_column, int(14))
					tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp6
				case 1:
					v4 := args[0]
					_ = v4
					return v4
				case 2:
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					tmp6 := lang.Apply(lang.Conj, []any{v4, v5})
					return tmp6
				default:
					checkArity(args, 2)
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					var v6 any = lang.NewList(args[2:]...)
					_ = v6
				recur_loop_10:
					var tmp7 any
					if lang.IsTruthy(v6) {
						tmp9 := lang.Apply(lang.Conj, []any{v4, v5})
						var tmp8 any = tmp9
						tmp11 := checkDerefVar(var_glojure_DOT_core_first)
						tmp12 := lang.Apply(tmp11, []any{v6})
						var tmp10 any = tmp12
						tmp14 := checkDerefVar(var_glojure_DOT_core_next)
						tmp15 := lang.Apply(tmp14, []any{v6})
						var tmp13 any = tmp15
						v4 = tmp8
						v5 = tmp10
						v6 = tmp13
						goto recur_loop_10
					} else {
						tmp16 := lang.Apply(lang.Conj, []any{v4, v5})
						tmp7 = tmp16
					}
					return tmp7
				}
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(81), kw_column, int(7), kw_end_DASH_line, int(88), kw_end_DASH_column, int(67))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// conj!
	{
		tmp0 := sym_conj_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_coll), lang.NewVector(sym_coll, sym_x)), kw_doc, "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3359), kw_end_DASH_line, int(3359))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp4 := lang.NewVector()
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3364), kw_column, int(18), kw_end_DASH_line, int(3364), kw_end_DASH_column, int(19))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp7 := lang.Apply(tmp3, []any{tmp6})
				return tmp7
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "Conj")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Conj is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cons
	{
		tmp0 := sym_cons.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_seq)), kw_doc, "Returns a new seq where x is the first element and seq is\n    the rest.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(21), kw_end_DASH_line, int(27))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function cons
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.NewCons, []any{v4, v5})
				return tmp6
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(27), kw_column, int(7), kw_end_DASH_line, int(27), kw_end_DASH_column, int(89))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// constantly
	{
		tmp0 := sym_constantly.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns a function that takes any number of arguments and returns x.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(1440), kw_end_DASH_line, int(1440))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 0)
					var v5 any = lang.NewList(args[0:]...)
					_ = v5
					return v3
				}
			})
			tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1444), kw_column, int(7), kw_end_DASH_line, int(1444), kw_end_DASH_column, int(21))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// contains?
	{
		tmp0 := sym_contains_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_key)), kw_doc, "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and Java arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(1479), kw_end_DASH_line, int(1479))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime.RT, "Contains")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Contains is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// count
	{
		var tmp1 lang.FnFunc
		{ // function count__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Count})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_count.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_inline, tmp1, kw_doc, "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Java Collections and Maps", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(867), kw_end_DASH_line, int(867))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Count, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// counted?
	{
		tmp0 := sym_counted_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll implements count in constant time", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(6241), kw_end_DASH_line, int(6241))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Counted)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// create-ns
	{
		tmp0 := sym_create_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_doc, "Create a new namespace named by the symbol if one doesn't already\n  exist, returns it or the already-existing namespace of the same\n  name.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4131), kw_end_DASH_line, int(4131))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// create-struct
	{
		tmp0 := sym_create_DASH_struct.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_keys)), kw_doc, "Returns a structure basis object.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(4037), kw_end_DASH_line, int(4037))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentStructMapSlotMap, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cycle
	{
		tmp0 := sym_cycle.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(2977), kw_end_DASH_line, int(2977))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp5 := lang.Apply(tmp4, []any{v3})
			tmp6 := lang.Apply(lang.NewCycle, []any{tmp5})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// data-reader-urls
	{
		tmp0 := sym_data_DASH_reader_DASH_urls.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7830), kw_column, int(8), kw_end_DASH_line, int(7830), kw_end_DASH_column, int(23), kw_private, true, kw_arglists, lang.NewList(lang.NewVector()), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			return lang.NewList()
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// data-reader-var
	{
		tmp0 := sym_data_DASH_reader_DASH_var.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7832), kw_column, int(8), kw_end_DASH_line, int(7832), kw_end_DASH_column, int(22), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_intern)
			tmp5 := checkDerefVar(var_glojure_DOT_core_create_DASH_ns)
			tmp6 := checkDerefVar(var_glojure_DOT_core_symbol)
			tmp7 := checkDerefVar(var_glojure_DOT_core_namespace)
			tmp8 := lang.Apply(tmp7, []any{v3})
			tmp9 := lang.Apply(tmp6, []any{tmp8})
			tmp10 := lang.Apply(tmp5, []any{tmp9})
			tmp11 := checkDerefVar(var_glojure_DOT_core_symbol)
			tmp12 := checkDerefVar(var_glojure_DOT_core_name)
			tmp13 := lang.Apply(tmp12, []any{v3})
			tmp14 := lang.Apply(tmp11, []any{tmp13})
			tmp15 := lang.Apply(tmp4, []any{tmp10, tmp14})
			return tmp15
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dec
	{
		var tmp1 lang.FnFunc
		{ // function dec__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_unchecked_dec
				} else {
					tmp14 = sym_dec
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_dec.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one less than num. Does not auto-promote\n  longs, will throw on overflow. See also: dec'", kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1147), kw_end_DASH_line, int(1147))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Dec")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Dec is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dec'
	{
		var tmp1 lang.FnFunc
		{ // function dec'__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_DecP})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_dec_TICK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one less than num. Supports arbitrary precision.\n  See also: dec", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1140), kw_end_DASH_line, int(1140))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "DecP")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("DecP is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// decimal?
	{
		tmp0 := sym_decimal_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is a BigDecimal", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(3599), kw_end_DASH_line, int(3599))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.BigDecimal)(nil))
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// declare
	{
		tmp0 := sym_declare.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_names)), kw_doc, "defs the supplied var names with no bindings, useful for making forward declarations.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(2768), kw_end_DASH_line, int(2768))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_do})
				tmp10 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v12 := args[0]
					_ = v12
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_vary_DASH_meta)
					tmp15 := checkDerefVar(var_glojure_DOT_core_assoc)
					tmp16 := lang.Apply(tmp14, []any{v12, tmp15, kw_declared, true})
					tmp17 := lang.Apply(tmp13, []any{sym_def, tmp16})
					return tmp17
				})
				tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2771), kw_column, int(25), kw_end_DASH_line, int(2771), kw_end_DASH_column, int(71))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.Apply(tmp10, []any{tmp13, v5})
				tmp15 := lang.Apply(tmp7, []any{tmp9, tmp14})
				tmp16 := lang.Apply(tmp6, []any{tmp15})
				return tmp16
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dedupe
	{
		tmp0 := sym_dedupe.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_coll)), kw_doc, "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(7681), kw_end_DASH_line, int(7681))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "pv"
						tmp6 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp7 := lang.Apply(tmp6, []any{kw_glojure_DOT_core_SLASH_none})
						var v8 any = tmp7
						_ = v8
						var tmp9 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp10 := lang.Apply(v4, nil)
								return tmp10
							case 1:
								v10 := args[0]
								_ = v10
								tmp11 := lang.Apply(v4, []any{v10})
								return tmp11
							case 2:
								v10 := args[0]
								_ = v10
								v11 := args[1]
								_ = v11
								var tmp12 any
								{ // let
									// let binding "prior"
									tmp13 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp14 := lang.Apply(tmp13, []any{v8})
									var v15 any = tmp14
									_ = v15
									tmp16 := checkDerefVar(var_glojure_DOT_core_vreset_BANG_)
									tmp17 := lang.Apply(tmp16, []any{v8, v11})
									_ = tmp17
									var tmp18 any
									tmp19 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp20 := lang.Apply(tmp19, []any{v15, v11})
									if lang.IsTruthy(tmp20) {
										tmp18 = v10
									} else {
										tmp21 := lang.Apply(v4, []any{v10, v11})
										tmp18 = tmp21
									}
									tmp12 = tmp18
								} // end let
								return tmp12
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7688), kw_column, int(8), kw_end_DASH_line, int(7696), kw_end_DASH_column, int(37))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp11
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7686), kw_column, int(4), kw_end_DASH_line, int(7696), kw_end_DASH_column, int(39))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_sequence)
				tmp5 := checkDerefVar(var_glojure_DOT_core_dedupe)
				tmp6 := lang.Apply(tmp5, nil)
				tmp7 := lang.Apply(tmp4, []any{tmp6, v3})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// def-aset
	{
		tmp0 := sym_def_DASH_aset.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_method, sym_coerce)), kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(3), kw_line, int(3935), kw_end_DASH_line, int(3936), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 5)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp10 := checkDerefVar(var_glojure_DOT_core_list)
			tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_defn})
			tmp12 := checkDerefVar(var_glojure_DOT_core_list)
			tmp13 := lang.Apply(tmp12, []any{v5})
			tmp14 := checkDerefVar(var_glojure_DOT_core_list)
			tmp15 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp16 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
			tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp19 := checkDerefVar(var_glojure_DOT_core_list)
			tmp20 := lang.Apply(tmp19, []any{kw_arglists})
			tmp21 := checkDerefVar(var_glojure_DOT_core_list)
			tmp22 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp23 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp24 := checkDerefVar(var_glojure_DOT_core_list)
			tmp25 := lang.Apply(tmp24, []any{sym_quote})
			tmp26 := checkDerefVar(var_glojure_DOT_core_list)
			tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp28 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp29 := checkDerefVar(var_glojure_DOT_core_list)
			tmp30 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp31 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp33 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp34 := checkDerefVar(var_glojure_DOT_core_list)
			tmp35 := lang.Apply(tmp34, []any{sym_array})
			tmp36 := checkDerefVar(var_glojure_DOT_core_list)
			tmp37 := lang.Apply(tmp36, []any{sym_idx})
			tmp38 := checkDerefVar(var_glojure_DOT_core_list)
			tmp39 := lang.Apply(tmp38, []any{sym_val})
			tmp40 := lang.Apply(tmp33, []any{tmp35, tmp37, tmp39})
			tmp41 := lang.Apply(tmp32, []any{tmp40})
			tmp42 := lang.Apply(tmp30, []any{tmp31, tmp41})
			tmp43 := lang.Apply(tmp29, []any{tmp42})
			tmp44 := checkDerefVar(var_glojure_DOT_core_list)
			tmp45 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp46 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp49 := checkDerefVar(var_glojure_DOT_core_list)
			tmp50 := lang.Apply(tmp49, []any{sym_array})
			tmp51 := checkDerefVar(var_glojure_DOT_core_list)
			tmp52 := lang.Apply(tmp51, []any{sym_idx})
			tmp53 := checkDerefVar(var_glojure_DOT_core_list)
			tmp54 := lang.Apply(tmp53, []any{sym_idx2})
			tmp55 := checkDerefVar(var_glojure_DOT_core_list)
			tmp56 := lang.Apply(tmp55, []any{sym__AMP_})
			tmp57 := checkDerefVar(var_glojure_DOT_core_list)
			tmp58 := lang.Apply(tmp57, []any{sym_idxv})
			tmp59 := lang.Apply(tmp48, []any{tmp50, tmp52, tmp54, tmp56, tmp58})
			tmp60 := lang.Apply(tmp47, []any{tmp59})
			tmp61 := lang.Apply(tmp45, []any{tmp46, tmp60})
			tmp62 := lang.Apply(tmp44, []any{tmp61})
			tmp63 := lang.Apply(tmp28, []any{tmp43, tmp62})
			tmp64 := lang.Apply(tmp27, []any{tmp63})
			tmp65 := lang.Apply(tmp26, []any{tmp64})
			tmp66 := lang.Apply(tmp23, []any{tmp25, tmp65})
			tmp67 := lang.Apply(tmp22, []any{tmp66})
			tmp68 := lang.Apply(tmp21, []any{tmp67})
			tmp69 := lang.Apply(tmp18, []any{tmp20, tmp68})
			tmp70 := lang.Apply(tmp17, []any{tmp69})
			tmp71 := lang.Apply(tmp15, []any{tmp16, tmp70})
			tmp72 := lang.Apply(tmp14, []any{tmp71})
			tmp73 := checkDerefVar(var_glojure_DOT_core_list)
			tmp74 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp75 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp76 := checkDerefVar(var_glojure_DOT_core_list)
			tmp77 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp78 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp79 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp80 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp81 := checkDerefVar(var_glojure_DOT_core_list)
			tmp82 := lang.Apply(tmp81, []any{sym_array__0__auto__})
			tmp83 := checkDerefVar(var_glojure_DOT_core_list)
			tmp84 := lang.Apply(tmp83, []any{sym_idx__1__auto__})
			tmp85 := checkDerefVar(var_glojure_DOT_core_list)
			tmp86 := lang.Apply(tmp85, []any{sym_val__2__auto__})
			tmp87 := lang.Apply(tmp80, []any{tmp82, tmp84, tmp86})
			tmp88 := lang.Apply(tmp79, []any{tmp87})
			tmp89 := lang.Apply(tmp77, []any{tmp78, tmp88})
			tmp90 := lang.Apply(tmp76, []any{tmp89})
			tmp91 := checkDerefVar(var_glojure_DOT_core_list)
			tmp92 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp93 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp94 := checkDerefVar(var_glojure_DOT_core_list)
			tmp95 := lang.Apply(tmp94, []any{sym__DOT_})
			tmp96 := checkDerefVar(var_glojure_DOT_core_list)
			tmp97 := lang.Apply(tmp96, []any{sym_glojure_DOT_core_SLASH_Array})
			tmp98 := checkDerefVar(var_glojure_DOT_core_list)
			tmp99 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp100 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp101 := checkDerefVar(var_glojure_DOT_core_list)
			tmp102 := lang.Apply(tmp101, []any{v6})
			tmp103 := checkDerefVar(var_glojure_DOT_core_list)
			tmp104 := lang.Apply(tmp103, []any{sym_array__0__auto__})
			tmp105 := checkDerefVar(var_glojure_DOT_core_list)
			tmp106 := lang.Apply(tmp105, []any{sym_idx__1__auto__})
			tmp107 := checkDerefVar(var_glojure_DOT_core_list)
			tmp108 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp109 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp110 := checkDerefVar(var_glojure_DOT_core_list)
			tmp111 := lang.Apply(tmp110, []any{v7})
			tmp112 := checkDerefVar(var_glojure_DOT_core_list)
			tmp113 := lang.Apply(tmp112, []any{sym_val__2__auto__})
			tmp114 := lang.Apply(tmp109, []any{tmp111, tmp113})
			tmp115 := lang.Apply(tmp108, []any{tmp114})
			tmp116 := lang.Apply(tmp107, []any{tmp115})
			tmp117 := lang.Apply(tmp100, []any{tmp102, tmp104, tmp106, tmp116})
			tmp118 := lang.Apply(tmp99, []any{tmp117})
			tmp119 := lang.Apply(tmp98, []any{tmp118})
			tmp120 := lang.Apply(tmp93, []any{tmp95, tmp97, tmp119})
			tmp121 := lang.Apply(tmp92, []any{tmp120})
			tmp122 := lang.Apply(tmp91, []any{tmp121})
			tmp123 := checkDerefVar(var_glojure_DOT_core_list)
			tmp124 := lang.Apply(tmp123, []any{sym_val__2__auto__})
			tmp125 := lang.Apply(tmp75, []any{tmp90, tmp122, tmp124})
			tmp126 := lang.Apply(tmp74, []any{tmp125})
			tmp127 := lang.Apply(tmp73, []any{tmp126})
			tmp128 := checkDerefVar(var_glojure_DOT_core_list)
			tmp129 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp130 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp131 := checkDerefVar(var_glojure_DOT_core_list)
			tmp132 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp133 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp134 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp135 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp136 := checkDerefVar(var_glojure_DOT_core_list)
			tmp137 := lang.Apply(tmp136, []any{sym_array__0__auto__})
			tmp138 := checkDerefVar(var_glojure_DOT_core_list)
			tmp139 := lang.Apply(tmp138, []any{sym_idx__1__auto__})
			tmp140 := checkDerefVar(var_glojure_DOT_core_list)
			tmp141 := lang.Apply(tmp140, []any{sym_idx2__3__auto__})
			tmp142 := checkDerefVar(var_glojure_DOT_core_list)
			tmp143 := lang.Apply(tmp142, []any{sym__AMP_})
			tmp144 := checkDerefVar(var_glojure_DOT_core_list)
			tmp145 := lang.Apply(tmp144, []any{sym_idxv__4__auto__})
			tmp146 := lang.Apply(tmp135, []any{tmp137, tmp139, tmp141, tmp143, tmp145})
			tmp147 := lang.Apply(tmp134, []any{tmp146})
			tmp148 := lang.Apply(tmp132, []any{tmp133, tmp147})
			tmp149 := lang.Apply(tmp131, []any{tmp148})
			tmp150 := checkDerefVar(var_glojure_DOT_core_list)
			tmp151 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp152 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp153 := checkDerefVar(var_glojure_DOT_core_list)
			tmp154 := lang.Apply(tmp153, []any{sym_glojure_DOT_core_SLASH_apply})
			tmp155 := checkDerefVar(var_glojure_DOT_core_list)
			tmp156 := lang.Apply(tmp155, []any{v5})
			tmp157 := checkDerefVar(var_glojure_DOT_core_list)
			tmp158 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp159 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp160 := checkDerefVar(var_glojure_DOT_core_list)
			tmp161 := lang.Apply(tmp160, []any{sym_glojure_DOT_core_SLASH_aget})
			tmp162 := checkDerefVar(var_glojure_DOT_core_list)
			tmp163 := lang.Apply(tmp162, []any{sym_array__0__auto__})
			tmp164 := checkDerefVar(var_glojure_DOT_core_list)
			tmp165 := lang.Apply(tmp164, []any{sym_idx__1__auto__})
			tmp166 := lang.Apply(tmp159, []any{tmp161, tmp163, tmp165})
			tmp167 := lang.Apply(tmp158, []any{tmp166})
			tmp168 := lang.Apply(tmp157, []any{tmp167})
			tmp169 := checkDerefVar(var_glojure_DOT_core_list)
			tmp170 := lang.Apply(tmp169, []any{sym_idx2__3__auto__})
			tmp171 := checkDerefVar(var_glojure_DOT_core_list)
			tmp172 := lang.Apply(tmp171, []any{sym_idxv__4__auto__})
			tmp173 := lang.Apply(tmp152, []any{tmp154, tmp156, tmp168, tmp170, tmp172})
			tmp174 := lang.Apply(tmp151, []any{tmp173})
			tmp175 := lang.Apply(tmp150, []any{tmp174})
			tmp176 := lang.Apply(tmp130, []any{tmp149, tmp175})
			tmp177 := lang.Apply(tmp129, []any{tmp176})
			tmp178 := lang.Apply(tmp128, []any{tmp177})
			tmp179 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp72, tmp127, tmp178})
			tmp180 := lang.Apply(tmp8, []any{tmp179})
			return tmp180
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// definline
	{
		tmp0 := sym_definline.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_decl)), kw_doc, "Experimental - like defmacro, except defines a named function whose\n  body is the expansion, calls to which may be expanded inline as if\n  it were a macro. Cannot be used with variadic (&) args.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(5253), kw_end_DASH_line, int(5253))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "vec__80"
					tmp8 := checkDerefVar(var_glojure_DOT_core_split_DASH_with)
					tmp9 := checkDerefVar(var_glojure_DOT_core_comp)
					tmp10 := checkDerefVar(var_glojure_DOT_core_not)
					tmp11 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
					tmp12 := lang.Apply(tmp9, []any{tmp10, tmp11})
					tmp13 := lang.Apply(tmp8, []any{tmp12, v6})
					var v14 any = tmp13
					_ = v14
					// let binding "pre-args"
					tmp15 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
					var v17 any = tmp16
					_ = v17
					// let binding "vec__83"
					tmp18 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp19 := lang.Apply(tmp18, []any{v14, int64(1), nil})
					var v20 any = tmp19
					_ = v20
					// let binding "args"
					tmp21 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp22 := lang.Apply(tmp21, []any{v20, int64(0), nil})
					var v23 any = tmp22
					_ = v23
					// let binding "expr"
					tmp24 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp25 := lang.Apply(tmp24, []any{v20, int64(1), nil})
					var v26 any = tmp25
					_ = v26
					tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp28 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp29 := checkDerefVar(var_glojure_DOT_core_list)
					tmp30 := lang.Apply(tmp29, []any{sym_do})
					tmp31 := checkDerefVar(var_glojure_DOT_core_list)
					tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp33 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp34 := checkDerefVar(var_glojure_DOT_core_list)
					tmp35 := lang.Apply(tmp34, []any{sym_glojure_DOT_core_SLASH_defn})
					tmp36 := checkDerefVar(var_glojure_DOT_core_list)
					tmp37 := lang.Apply(tmp36, []any{v5})
					tmp38 := checkDerefVar(var_glojure_DOT_core_list)
					tmp39 := lang.Apply(tmp38, []any{v23})
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp42 := checkDerefVar(var_glojure_DOT_core_eval)
					tmp43 := checkDerefVar(var_glojure_DOT_core_list)
					tmp44 := lang.Apply(tmp43, []any{sym_glojure_DOT_core_SLASH_fn, v23, v26})
					tmp45 := lang.Apply(tmp42, []any{tmp44})
					tmp46 := lang.Apply(tmp41, []any{tmp45, v23})
					tmp47 := lang.Apply(tmp40, []any{tmp46})
					tmp48 := lang.Apply(tmp33, []any{tmp35, tmp37, v17, tmp39, tmp47})
					tmp49 := lang.Apply(tmp32, []any{tmp48})
					tmp50 := lang.Apply(tmp31, []any{tmp49})
					tmp51 := checkDerefVar(var_glojure_DOT_core_list)
					tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp53 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp54 := checkDerefVar(var_glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{sym_glojure_DOT_core_SLASH_alter_DASH_meta_BANG_})
					tmp56 := checkDerefVar(var_glojure_DOT_core_list)
					tmp57 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp58 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp59 := checkDerefVar(var_glojure_DOT_core_list)
					tmp60 := lang.Apply(tmp59, []any{sym_var})
					tmp61 := checkDerefVar(var_glojure_DOT_core_list)
					tmp62 := lang.Apply(tmp61, []any{v5})
					tmp63 := lang.Apply(tmp58, []any{tmp60, tmp62})
					tmp64 := lang.Apply(tmp57, []any{tmp63})
					tmp65 := lang.Apply(tmp56, []any{tmp64})
					tmp66 := checkDerefVar(var_glojure_DOT_core_list)
					tmp67 := lang.Apply(tmp66, []any{sym_glojure_DOT_core_SLASH_assoc})
					tmp68 := checkDerefVar(var_glojure_DOT_core_list)
					tmp69 := lang.Apply(tmp68, []any{kw_inline})
					tmp70 := checkDerefVar(var_glojure_DOT_core_list)
					tmp71 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp72 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp73 := checkDerefVar(var_glojure_DOT_core_list)
					tmp74 := lang.Apply(tmp73, []any{sym_glojure_DOT_core_SLASH_fn})
					tmp75 := checkDerefVar(var_glojure_DOT_core_list)
					tmp76 := lang.Apply(tmp75, []any{v5})
					tmp77 := checkDerefVar(var_glojure_DOT_core_list)
					tmp78 := lang.Apply(tmp77, []any{v23})
					tmp79 := checkDerefVar(var_glojure_DOT_core_list)
					tmp80 := lang.Apply(tmp79, []any{v26})
					tmp81 := lang.Apply(tmp72, []any{tmp74, tmp76, tmp78, tmp80})
					tmp82 := lang.Apply(tmp71, []any{tmp81})
					tmp83 := lang.Apply(tmp70, []any{tmp82})
					tmp84 := lang.Apply(tmp53, []any{tmp55, tmp65, tmp67, tmp69, tmp83})
					tmp85 := lang.Apply(tmp52, []any{tmp84})
					tmp86 := lang.Apply(tmp51, []any{tmp85})
					tmp87 := checkDerefVar(var_glojure_DOT_core_list)
					tmp88 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp89 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp90 := checkDerefVar(var_glojure_DOT_core_list)
					tmp91 := lang.Apply(tmp90, []any{sym_var})
					tmp92 := checkDerefVar(var_glojure_DOT_core_list)
					tmp93 := lang.Apply(tmp92, []any{v5})
					tmp94 := lang.Apply(tmp89, []any{tmp91, tmp93})
					tmp95 := lang.Apply(tmp88, []any{tmp94})
					tmp96 := lang.Apply(tmp87, []any{tmp95})
					tmp97 := lang.Apply(tmp28, []any{tmp30, tmp50, tmp86, tmp96})
					tmp98 := lang.Apply(tmp27, []any{tmp97})
					tmp7 = tmp98
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmacro
	{
		tmp0 := sym_defmacro.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_doc_DASH_string_QMARK_, sym_attr_DASH_map_QMARK_, lang.NewVector(sym_params_STAR_), sym_body), lang.NewVector(sym_name, sym_doc_DASH_string_QMARK_, sym_attr_DASH_map_QMARK_, lang.NewList(lang.NewVector(sym_params_STAR_), sym_body), sym__PLUS_, sym_attr_DASH_map_QMARK_)), kw_doc, "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(2), kw_line, int(445), kw_end_DASH_line, int(451))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "prefix"
					var tmp8 any
					{ // let
						// let binding "p"
						tmp9 := checkDerefVar(var_glojure_DOT_core_list)
						tmp10 := lang.Apply(tmp9, []any{v5})
						var v11 any = tmp10
						_ = v11
						// let binding "args"
						var v12 any = v6
						_ = v12
						for {
							var tmp13 any
							{ // let
								// let binding "f"
								tmp14 := checkDerefVar(var_glojure_DOT_core_first)
								tmp15 := lang.Apply(tmp14, []any{v12})
								var v16 any = tmp15
								_ = v16
								var tmp17 any
								tmp18 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
								tmp19 := lang.Apply(tmp18, []any{v16})
								if lang.IsTruthy(tmp19) {
									tmp21 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp22 := lang.Apply(tmp21, []any{v16, v11})
									var tmp20 any = tmp22
									tmp24 := checkDerefVar(var_glojure_DOT_core_next)
									tmp25 := lang.Apply(tmp24, []any{v12})
									var tmp23 any = tmp25
									v11 = tmp20
									v12 = tmp23
									continue
								} else {
									var tmp26 any
									tmp27 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
									tmp28 := lang.Apply(tmp27, []any{v16})
									if lang.IsTruthy(tmp28) {
										tmp30 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp31 := lang.Apply(tmp30, []any{v16, v11})
										var tmp29 any = tmp31
										tmp33 := checkDerefVar(var_glojure_DOT_core_next)
										tmp34 := lang.Apply(tmp33, []any{v12})
										var tmp32 any = tmp34
										v11 = tmp29
										v12 = tmp32
										continue
									} else {
										tmp26 = v11
									}
									tmp17 = tmp26
								}
								tmp13 = tmp17
							} // end let
							tmp8 = tmp13
							break
						}
					} // end let
					var v9 any = tmp8
					_ = v9
					// let binding "fdecl"
					var tmp10 any
					{ // let
						// let binding "fd"
						var v11 any = v6
						_ = v11
						for {
							var tmp12 any
							tmp13 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
							tmp14 := checkDerefVar(var_glojure_DOT_core_first)
							tmp15 := lang.Apply(tmp14, []any{v11})
							tmp16 := lang.Apply(tmp13, []any{tmp15})
							if lang.IsTruthy(tmp16) {
								tmp18 := checkDerefVar(var_glojure_DOT_core_next)
								tmp19 := lang.Apply(tmp18, []any{v11})
								var tmp17 any = tmp19
								v11 = tmp17
								continue
							} else {
								var tmp20 any
								tmp21 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
								tmp22 := checkDerefVar(var_glojure_DOT_core_first)
								tmp23 := lang.Apply(tmp22, []any{v11})
								tmp24 := lang.Apply(tmp21, []any{tmp23})
								if lang.IsTruthy(tmp24) {
									tmp26 := checkDerefVar(var_glojure_DOT_core_next)
									tmp27 := lang.Apply(tmp26, []any{v11})
									var tmp25 any = tmp27
									v11 = tmp25
									continue
								} else {
									tmp20 = v11
								}
								tmp12 = tmp20
							}
							tmp10 = tmp12
							break
						}
					} // end let
					var v11 any = tmp10
					_ = v11
					// let binding "fdecl"
					var tmp12 any
					tmp13 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_first)
					tmp15 := lang.Apply(tmp14, []any{v11})
					tmp16 := lang.Apply(tmp13, []any{tmp15})
					if lang.IsTruthy(tmp16) {
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{v11})
						tmp12 = tmp18
					} else {
						tmp12 = v11
					}
					var v19 any = tmp12
					_ = v19
					// let binding "add-implicit-args"
					var tmp20 lang.FnFunc
					tmp20 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v21 := args[0]
						_ = v21
						var tmp22 any
						{ // let
							// let binding "args"
							tmp23 := checkDerefVar(var_glojure_DOT_core_first)
							tmp24 := lang.Apply(tmp23, []any{v21})
							var v25 any = tmp24
							_ = v25
							tmp26 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp27 := checkDerefVar(var_glojure_DOT_core_vec)
							tmp28 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp29 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp30 := lang.Apply(tmp29, []any{sym__AMP_env, v25})
							tmp31 := lang.Apply(tmp28, []any{sym__AMP_form, tmp30})
							tmp32 := lang.Apply(tmp27, []any{tmp31})
							tmp33 := checkDerefVar(var_glojure_DOT_core_next)
							tmp34 := lang.Apply(tmp33, []any{v21})
							tmp35 := lang.Apply(tmp26, []any{tmp32, tmp34})
							tmp22 = tmp35
						} // end let
						return tmp22
					})
					tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(469), kw_column, int(38), kw_end_DASH_line, int(471), kw_end_DASH_column, int(87))
					tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v23 any = tmp22
					_ = v23
					// let binding "add-args"
					var tmp24 lang.FnFunc
					tmp24 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v25 := args[0]
						_ = v25
						v26 := args[1]
						_ = v26
					recur_loop_61:
						var tmp27 any
						tmp28 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp29 := lang.Apply(tmp28, []any{v26})
						if lang.IsTruthy(tmp29) {
							tmp27 = v25
						} else {
							var tmp30 any
							{ // let
								// let binding "d"
								tmp31 := checkDerefVar(var_glojure_DOT_core_first)
								tmp32 := lang.Apply(tmp31, []any{v26})
								var v33 any = tmp32
								_ = v33
								var tmp34 any
								tmp35 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
								tmp36 := lang.Apply(tmp35, []any{v33})
								if lang.IsTruthy(tmp36) {
									tmp37 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp38 := lang.Apply(tmp37, []any{v25, v33})
									tmp34 = tmp38
								} else {
									tmp40 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp41 := lang.Apply(v23, []any{v33})
									tmp42 := lang.Apply(tmp40, []any{v25, tmp41})
									var tmp39 any = tmp42
									tmp44 := checkDerefVar(var_glojure_DOT_core_next)
									tmp45 := lang.Apply(tmp44, []any{v26})
									var tmp43 any = tmp45
									v25 = tmp39
									v26 = tmp43
									goto recur_loop_61
								}
								tmp30 = tmp34
							} // end let
							tmp27 = tmp30
						}
						return tmp27
					})
					tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(472), kw_column, int(29), kw_end_DASH_line, int(478), kw_end_DASH_column, int(90))
					tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v27 any = tmp26
					_ = v27
					// let binding "fdecl"
					tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp29 := lang.NewVector()
					tmp30 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(479), kw_column, int(41), kw_end_DASH_line, int(479), kw_end_DASH_column, int(42))
					tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp32 := lang.Apply(v27, []any{tmp31, v19})
					tmp33 := lang.Apply(tmp28, []any{tmp32})
					var v34 any = tmp33
					_ = v34
					// let binding "decl"
					var tmp35 any
					{ // let
						// let binding "p"
						var v36 any = v9
						_ = v36
						// let binding "d"
						var v37 any = v34
						_ = v37
						for {
							var tmp38 any
							if lang.IsTruthy(v36) {
								tmp40 := checkDerefVar(var_glojure_DOT_core_next)
								tmp41 := lang.Apply(tmp40, []any{v36})
								var tmp39 any = tmp41
								tmp43 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp44 := checkDerefVar(var_glojure_DOT_core_first)
								tmp45 := lang.Apply(tmp44, []any{v36})
								tmp46 := lang.Apply(tmp43, []any{tmp45, v37})
								var tmp42 any = tmp46
								v36 = tmp39
								v37 = tmp42
								continue
							} else {
								tmp38 = v37
							}
							tmp35 = tmp38
							break
						}
					} // end let
					var v36 any = tmp35
					_ = v36
					tmp37 := checkDerefVar(var_glojure_DOT_core_list)
					tmp38 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp39 := lang.Apply(tmp38, []any{sym_glojure_DOT_core_SLASH_defn, v36})
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := checkDerefVar(var_glojure_DOT_core_list)
					tmp42 := lang.Apply(tmp41, []any{sym_var, v5})
					tmp43 := lang.Apply(tmp40, []any{sym__DOT_, tmp42, lang.NewList(sym_SetMacro)})
					tmp44 := checkDerefVar(var_glojure_DOT_core_list)
					tmp45 := lang.Apply(tmp44, []any{sym_var, v5})
					tmp46 := lang.Apply(tmp37, []any{sym_do, tmp39, tmp43, tmp45})
					tmp7 = tmp46
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(451), kw_column, int(11), kw_end_DASH_line, int(487), kw_end_DASH_column, int(40))).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmethod
	{
		tmp0 := sym_defmethod.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_multifn, sym_dispatch_DASH_val, sym__AMP_, sym_fn_DASH_tail)), kw_doc, "Creates and installs a new method of multimethod associated with dispatch-value. ", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(1781), kw_end_DASH_line, int(1781))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 4)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
				tmp14 := lang.NewMap(kw_tag, sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT__STAR_MultiFn)
				tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1785), kw_column, int(27), kw_end_DASH_line, int(1785), kw_end_DASH_column, int(82))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp17 := lang.Apply(tmp13, []any{v5, tmp16})
				tmp18 := lang.Apply(tmp12, []any{tmp17})
				tmp19 := checkDerefVar(var_glojure_DOT_core_list)
				tmp20 := lang.Apply(tmp19, []any{sym_glojure_DOT_core_SLASH_AddMethod})
				tmp21 := checkDerefVar(var_glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{v6})
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp26 := checkDerefVar(var_glojure_DOT_core_list)
				tmp27 := lang.Apply(tmp26, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp28 := lang.Apply(tmp25, []any{tmp27, v7})
				tmp29 := lang.Apply(tmp24, []any{tmp28})
				tmp30 := lang.Apply(tmp23, []any{tmp29})
				tmp31 := lang.Apply(tmp9, []any{tmp11, tmp18, tmp20, tmp22, tmp30})
				tmp32 := lang.Apply(tmp8, []any{tmp31})
				return tmp32
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmulti
	{
		tmp0 := sym_defmulti.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_docstring_QMARK_, sym_attr_DASH_map_QMARK_, sym_dispatch_DASH_fn, sym__AMP_, sym_options)), kw_doc, "Creates a new multimethod with the associated dispatch function.\n  The docstring and attr-map are optional.\n\n  Options are key-value pairs and may be one of:\n\n  :default\n\n  The default dispatch value, defaults to :default\n\n  :hierarchy\n\n  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)\n\n  Hierarchies are type-like relationships that do not depend upon type\n  inheritance. By default Clojure's multimethods dispatch off of a\n  global hierarchy map.  However, a hierarchy relationship can be\n  created with the derive function used to augment the root ancestor\n  created with make-hierarchy.\n\n  Multimethods expect the value of the hierarchy option to be supplied as\n  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'\n  or the var special form).", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(1723), kw_end_DASH_line, int(1723))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "docstring"
					var tmp8 any
					tmp9 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v6})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(var_glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v6})
						tmp8 = tmp14
					} else {
					}
					var v15 any = tmp8
					_ = v15
					// let binding "options"
					var tmp16 any
					tmp17 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
					tmp18 := checkDerefVar(var_glojure_DOT_core_first)
					tmp19 := lang.Apply(tmp18, []any{v6})
					tmp20 := lang.Apply(tmp17, []any{tmp19})
					if lang.IsTruthy(tmp20) {
						tmp21 := checkDerefVar(var_glojure_DOT_core_next)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp16 = tmp22
					} else {
						tmp16 = v6
					}
					var v23 any = tmp16
					_ = v23
					// let binding "m"
					var tmp24 any
					tmp25 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
					tmp26 := checkDerefVar(var_glojure_DOT_core_first)
					tmp27 := lang.Apply(tmp26, []any{v23})
					tmp28 := lang.Apply(tmp25, []any{tmp27})
					if lang.IsTruthy(tmp28) {
						tmp29 := checkDerefVar(var_glojure_DOT_core_first)
						tmp30 := lang.Apply(tmp29, []any{v23})
						tmp24 = tmp30
					} else {
						tmp31 := lang.NewMap()
						tmp32 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1757), kw_column, int(23), kw_end_DASH_line, int(1757), kw_end_DASH_column, int(24))
						tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp24 = tmp33
					}
					var v34 any = tmp24
					_ = v34
					// let binding "options"
					var tmp35 any
					tmp36 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
					tmp37 := checkDerefVar(var_glojure_DOT_core_first)
					tmp38 := lang.Apply(tmp37, []any{v23})
					tmp39 := lang.Apply(tmp36, []any{tmp38})
					if lang.IsTruthy(tmp39) {
						tmp40 := checkDerefVar(var_glojure_DOT_core_next)
						tmp41 := lang.Apply(tmp40, []any{v23})
						tmp35 = tmp41
					} else {
						tmp35 = v23
					}
					var v42 any = tmp35
					_ = v42
					// let binding "dispatch-fn"
					tmp43 := checkDerefVar(var_glojure_DOT_core_first)
					tmp44 := lang.Apply(tmp43, []any{v42})
					var v45 any = tmp44
					_ = v45
					// let binding "options"
					tmp46 := checkDerefVar(var_glojure_DOT_core_next)
					tmp47 := lang.Apply(tmp46, []any{v42})
					var v48 any = tmp47
					_ = v48
					// let binding "m"
					var tmp49 any
					if lang.IsTruthy(v15) {
						tmp50 := checkDerefVar(var_glojure_DOT_core_assoc)
						tmp51 := lang.Apply(tmp50, []any{v34, kw_doc, v15})
						tmp49 = tmp51
					} else {
						tmp49 = v34
					}
					var v52 any = tmp49
					_ = v52
					// let binding "m"
					var tmp53 any
					tmp54 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp55 := lang.Apply(tmp54, []any{v5})
					if lang.IsTruthy(tmp55) {
						tmp56 := checkDerefVar(var_glojure_DOT_core_conj)
						tmp57 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp58 := lang.Apply(tmp57, []any{v5})
						tmp59 := lang.Apply(tmp56, []any{tmp58, v52})
						tmp53 = tmp59
					} else {
						tmp53 = v52
					}
					var v60 any = tmp53
					_ = v60
					// let binding "mm-name"
					tmp61 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp62 := lang.Apply(tmp61, []any{v5, v60})
					var v63 any = tmp62
					_ = v63
					var tmp64 any
					tmp65 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp66 := checkDerefVar(var_glojure_DOT_core_count)
					tmp67 := lang.Apply(tmp66, []any{v48})
					tmp68 := lang.Apply(tmp65, []any{tmp67, int64(1)})
					if lang.IsTruthy(tmp68) {
						tmp69 := lang.Apply(lang.NewError, []any{"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)"})
						panic(tmp69)
					} else {
					}
					_ = tmp64
					var tmp70 any
					{ // let
						// let binding "options"
						tmp71 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp72 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp73 := lang.Apply(tmp71, []any{tmp72, v48})
						var v74 any = tmp73
						_ = v74
						// let binding "default"
						tmp75 := checkDerefVar(var_glojure_DOT_core_get)
						tmp76 := lang.Apply(tmp75, []any{v74, kw_default, kw_default})
						var v77 any = tmp76
						_ = v77
						// let binding "hierarchy"
						tmp78 := checkDerefVar(var_glojure_DOT_core_get)
						tmp79 := lang.InternVarName(sym_glojure_DOT_core, sym_global_DASH_hierarchy)
						tmp80 := lang.Apply(tmp78, []any{v74, kw_hierarchy, tmp79})
						var v81 any = tmp80
						_ = v81
						tmp82 := checkDerefVar(var_glojure_DOT_core_check_DASH_valid_DASH_options)
						tmp83 := lang.Apply(tmp82, []any{v74, kw_default, kw_hierarchy})
						_ = tmp83
						tmp84 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp85 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp86 := checkDerefVar(var_glojure_DOT_core_list)
						tmp87 := lang.Apply(tmp86, []any{sym_glojure_DOT_core_SLASH_let})
						tmp88 := checkDerefVar(var_glojure_DOT_core_list)
						tmp89 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp90 := checkDerefVar(var_glojure_DOT_core_vector)
						tmp91 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp92 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp93 := checkDerefVar(var_glojure_DOT_core_list)
						tmp94 := lang.Apply(tmp93, []any{sym_v__0__auto__})
						tmp95 := checkDerefVar(var_glojure_DOT_core_list)
						tmp96 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp97 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp98 := checkDerefVar(var_glojure_DOT_core_list)
						tmp99 := lang.Apply(tmp98, []any{sym_def})
						tmp100 := checkDerefVar(var_glojure_DOT_core_list)
						tmp101 := lang.Apply(tmp100, []any{v63})
						tmp102 := lang.Apply(tmp97, []any{tmp99, tmp101})
						tmp103 := lang.Apply(tmp96, []any{tmp102})
						tmp104 := lang.Apply(tmp95, []any{tmp103})
						tmp105 := lang.Apply(tmp92, []any{tmp94, tmp104})
						tmp106 := lang.Apply(tmp91, []any{tmp105})
						tmp107 := lang.Apply(tmp89, []any{tmp90, tmp106})
						tmp108 := lang.Apply(tmp88, []any{tmp107})
						tmp109 := checkDerefVar(var_glojure_DOT_core_list)
						tmp110 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp111 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp112 := checkDerefVar(var_glojure_DOT_core_list)
						tmp113 := lang.Apply(tmp112, []any{sym_glojure_DOT_core_SLASH_when_DASH_not})
						tmp114 := checkDerefVar(var_glojure_DOT_core_list)
						tmp115 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp116 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp117 := checkDerefVar(var_glojure_DOT_core_list)
						tmp118 := lang.Apply(tmp117, []any{sym_glojure_DOT_core_SLASH_and})
						tmp119 := checkDerefVar(var_glojure_DOT_core_list)
						tmp120 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp121 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp122 := checkDerefVar(var_glojure_DOT_core_list)
						tmp123 := lang.Apply(tmp122, []any{sym__DOT_HasRoot})
						tmp124 := checkDerefVar(var_glojure_DOT_core_list)
						tmp125 := lang.Apply(tmp124, []any{sym_v__0__auto__})
						tmp126 := lang.Apply(tmp121, []any{tmp123, tmp125})
						tmp127 := lang.Apply(tmp120, []any{tmp126})
						tmp128 := lang.Apply(tmp119, []any{tmp127})
						tmp129 := checkDerefVar(var_glojure_DOT_core_list)
						tmp130 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp131 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp132 := checkDerefVar(var_glojure_DOT_core_list)
						tmp133 := lang.Apply(tmp132, []any{sym_glojure_DOT_core_SLASH_instance_QMARK_})
						tmp134 := checkDerefVar(var_glojure_DOT_core_list)
						tmp135 := lang.Apply(tmp134, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT__STAR_MultiFn})
						tmp136 := checkDerefVar(var_glojure_DOT_core_list)
						tmp137 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp138 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp139 := checkDerefVar(var_glojure_DOT_core_list)
						tmp140 := lang.Apply(tmp139, []any{sym_glojure_DOT_core_SLASH_deref})
						tmp141 := checkDerefVar(var_glojure_DOT_core_list)
						tmp142 := lang.Apply(tmp141, []any{sym_v__0__auto__})
						tmp143 := lang.Apply(tmp138, []any{tmp140, tmp142})
						tmp144 := lang.Apply(tmp137, []any{tmp143})
						tmp145 := lang.Apply(tmp136, []any{tmp144})
						tmp146 := lang.Apply(tmp131, []any{tmp133, tmp135, tmp145})
						tmp147 := lang.Apply(tmp130, []any{tmp146})
						tmp148 := lang.Apply(tmp129, []any{tmp147})
						tmp149 := lang.Apply(tmp116, []any{tmp118, tmp128, tmp148})
						tmp150 := lang.Apply(tmp115, []any{tmp149})
						tmp151 := lang.Apply(tmp114, []any{tmp150})
						tmp152 := checkDerefVar(var_glojure_DOT_core_list)
						tmp153 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp154 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp155 := checkDerefVar(var_glojure_DOT_core_list)
						tmp156 := lang.Apply(tmp155, []any{sym_def})
						tmp157 := checkDerefVar(var_glojure_DOT_core_list)
						tmp158 := lang.Apply(tmp157, []any{v63})
						tmp159 := checkDerefVar(var_glojure_DOT_core_list)
						tmp160 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp161 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp162 := checkDerefVar(var_glojure_DOT_core_list)
						tmp163 := lang.Apply(tmp162, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewMultiFn})
						tmp164 := checkDerefVar(var_glojure_DOT_core_list)
						tmp165 := checkDerefVar(var_glojure_DOT_core_name)
						tmp166 := lang.Apply(tmp165, []any{v63})
						tmp167 := lang.Apply(tmp164, []any{tmp166})
						tmp168 := checkDerefVar(var_glojure_DOT_core_list)
						tmp169 := lang.Apply(tmp168, []any{v45})
						tmp170 := checkDerefVar(var_glojure_DOT_core_list)
						tmp171 := lang.Apply(tmp170, []any{v77})
						tmp172 := checkDerefVar(var_glojure_DOT_core_list)
						tmp173 := lang.Apply(tmp172, []any{v81})
						tmp174 := lang.Apply(tmp161, []any{tmp163, tmp167, tmp169, tmp171, tmp173})
						tmp175 := lang.Apply(tmp160, []any{tmp174})
						tmp176 := lang.Apply(tmp159, []any{tmp175})
						tmp177 := lang.Apply(tmp154, []any{tmp156, tmp158, tmp176})
						tmp178 := lang.Apply(tmp153, []any{tmp177})
						tmp179 := lang.Apply(tmp152, []any{tmp178})
						tmp180 := lang.Apply(tmp111, []any{tmp113, tmp151, tmp179})
						tmp181 := lang.Apply(tmp110, []any{tmp180})
						tmp182 := lang.Apply(tmp109, []any{tmp181})
						tmp183 := lang.Apply(tmp85, []any{tmp87, tmp108, tmp182})
						tmp184 := lang.Apply(tmp84, []any{tmp183})
						tmp70 = tmp184
					} // end let
					tmp7 = tmp70
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defn
	{
		tmp0 := sym_defn.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_doc_DASH_string_QMARK_, sym_attr_DASH_map_QMARK_, lang.NewVector(sym_params_STAR_), sym_prepost_DASH_map_QMARK_, sym_body), lang.NewVector(sym_name, sym_doc_DASH_string_QMARK_, sym_attr_DASH_map_QMARK_, lang.NewList(lang.NewVector(sym_params_STAR_), sym_prepost_DASH_map_QMARK_, sym_body), sym__PLUS_, sym_attr_DASH_map_QMARK_)), kw_doc, "Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(284), kw_end_DASH_line, int(291))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function defn
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 3)
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					var v7 any = lang.NewList(args[3:]...)
					_ = v7
					var tmp8 any
					tmp9 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp10 := reflect.TypeOf((*lang.Symbol)(nil))
					tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
					if lang.IsTruthy(tmp11) {
					} else {
						tmp12 := lang.Apply(lang.NewIllegalArgumentError, []any{"First argument to defn must be a symbol"})
						panic(tmp12)
					}
					_ = tmp8
					var tmp13 any
					{ // let
						// let binding "m"
						var tmp14 any
						tmp15 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
						tmp16 := checkDerefVar(var_glojure_DOT_core_first)
						tmp17 := lang.Apply(tmp16, []any{v7})
						tmp18 := lang.Apply(tmp15, []any{tmp17})
						if lang.IsTruthy(tmp18) {
							tmp19 := checkDerefVar(var_glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v7})
							tmp21 := lang.NewMap(kw_doc, tmp20)
							tmp22 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(297), kw_column, int(19), kw_end_DASH_line, int(297), kw_end_DASH_column, int(38))
							tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp14 = tmp23
						} else {
							tmp24 := lang.NewMap()
							tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(298), kw_column, int(19), kw_end_DASH_line, int(298), kw_end_DASH_column, int(20))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp14 = tmp26
						}
						var v27 any = tmp14
						_ = v27
						// let binding "fdecl"
						var tmp28 any
						tmp29 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
						tmp30 := checkDerefVar(var_glojure_DOT_core_first)
						tmp31 := lang.Apply(tmp30, []any{v7})
						tmp32 := lang.Apply(tmp29, []any{tmp31})
						if lang.IsTruthy(tmp32) {
							tmp33 := checkDerefVar(var_glojure_DOT_core_next)
							tmp34 := lang.Apply(tmp33, []any{v7})
							tmp28 = tmp34
						} else {
							tmp28 = v7
						}
						var v35 any = tmp28
						_ = v35
						// let binding "m"
						var tmp36 any
						tmp37 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
						tmp38 := checkDerefVar(var_glojure_DOT_core_first)
						tmp39 := lang.Apply(tmp38, []any{v35})
						tmp40 := lang.Apply(tmp37, []any{tmp39})
						if lang.IsTruthy(tmp40) {
							tmp41 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp42 := checkDerefVar(var_glojure_DOT_core_first)
							tmp43 := lang.Apply(tmp42, []any{v35})
							tmp44 := lang.Apply(tmp41, []any{v27, tmp43})
							tmp36 = tmp44
						} else {
							tmp36 = v27
						}
						var v45 any = tmp36
						_ = v45
						// let binding "fdecl"
						var tmp46 any
						tmp47 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
						tmp48 := checkDerefVar(var_glojure_DOT_core_first)
						tmp49 := lang.Apply(tmp48, []any{v35})
						tmp50 := lang.Apply(tmp47, []any{tmp49})
						if lang.IsTruthy(tmp50) {
							tmp51 := checkDerefVar(var_glojure_DOT_core_next)
							tmp52 := lang.Apply(tmp51, []any{v35})
							tmp46 = tmp52
						} else {
							tmp46 = v35
						}
						var v53 any = tmp46
						_ = v53
						// let binding "fdecl"
						var tmp54 any
						tmp55 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
						tmp56 := checkDerefVar(var_glojure_DOT_core_first)
						tmp57 := lang.Apply(tmp56, []any{v53})
						tmp58 := lang.Apply(tmp55, []any{tmp57})
						if lang.IsTruthy(tmp58) {
							tmp59 := checkDerefVar(var_glojure_DOT_core_list)
							tmp60 := lang.Apply(tmp59, []any{v53})
							tmp54 = tmp60
						} else {
							tmp54 = v53
						}
						var v61 any = tmp54
						_ = v61
						// let binding "m"
						var tmp62 any
						tmp63 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
						tmp64 := checkDerefVar(var_glojure_DOT_core_last)
						tmp65 := lang.Apply(tmp64, []any{v61})
						tmp66 := lang.Apply(tmp63, []any{tmp65})
						if lang.IsTruthy(tmp66) {
							tmp67 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp68 := checkDerefVar(var_glojure_DOT_core_last)
							tmp69 := lang.Apply(tmp68, []any{v61})
							tmp70 := lang.Apply(tmp67, []any{v45, tmp69})
							tmp62 = tmp70
						} else {
							tmp62 = v45
						}
						var v71 any = tmp62
						_ = v71
						// let binding "fdecl"
						var tmp72 any
						tmp73 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
						tmp74 := checkDerefVar(var_glojure_DOT_core_last)
						tmp75 := lang.Apply(tmp74, []any{v61})
						tmp76 := lang.Apply(tmp73, []any{tmp75})
						if lang.IsTruthy(tmp76) {
							tmp77 := checkDerefVar(var_glojure_DOT_core_butlast)
							tmp78 := lang.Apply(tmp77, []any{v61})
							tmp72 = tmp78
						} else {
							tmp72 = v61
						}
						var v79 any = tmp72
						_ = v79
						// let binding "m"
						tmp80 := checkDerefVar(var_glojure_DOT_core_conj)
						tmp81 := checkDerefVar(var_glojure_DOT_core_list)
						tmp82 := checkDerefVar(var_glojure_DOT_core_sigs)
						tmp83 := lang.Apply(tmp82, []any{v79})
						tmp84 := lang.Apply(tmp81, []any{sym_quote, tmp83})
						tmp85 := lang.NewMap(kw_arglists, tmp84)
						tmp86 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(317), kw_column, int(23), kw_end_DASH_line, int(317), kw_end_DASH_column, int(60))
						tmp87, err := lang.WithMeta(tmp85, tmp86.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp88 := lang.Apply(tmp80, []any{tmp87, v71})
						var v89 any = tmp88
						_ = v89
						// let binding "m"
						var tmp90 any
						{ // let
							// let binding "inline"
							tmp91 := lang.Apply(kw_inline, []any{v89})
							var v92 any = tmp91
							_ = v92
							// let binding "ifn"
							tmp93 := checkDerefVar(var_glojure_DOT_core_first)
							tmp94 := lang.Apply(tmp93, []any{v92})
							var v95 any = tmp94
							_ = v95
							// let binding "iname"
							tmp96 := checkDerefVar(var_glojure_DOT_core_second)
							tmp97 := lang.Apply(tmp96, []any{v92})
							var v98 any = tmp97
							_ = v98
							var tmp99 any
							var tmp100 any
							tmp101 := lang.Apply(lang.Equiv, []any{sym_fn, v95})
							if lang.IsTruthy(tmp101) {
								var tmp102 any
								tmp103 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
								tmp104 := reflect.TypeOf((*lang.Symbol)(nil))
								tmp105 := lang.Apply(tmp103, []any{tmp104, v98})
								if lang.IsTruthy(tmp105) {
									tmp102 = false
								} else {
									tmp102 = true
								}
								tmp100 = tmp102
							} else {
							}
							if lang.IsTruthy(tmp100) {
								tmp106 := checkDerefVar(var_glojure_DOT_core_assoc)
								tmp107 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp108 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp109, ok := lang.FieldOrMethod(v6, "Name")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "Name")))
								}
								var tmp110 any
								switch reflect.TypeOf(tmp109).Kind() {
								case reflect.Func:
									tmp110 = lang.Apply(tmp109, nil)
								default:
									tmp110 = tmp109
								}
								tmp111 := lang.Apply(lang.ConcatStrings, []any{tmp110, "__inliner"})
								tmp112 := lang.Apply(lang.NewSymbol, []any{tmp111})
								tmp113 := checkDerefVar(var_glojure_DOT_core_next)
								tmp114 := lang.Apply(tmp113, []any{v92})
								tmp115 := lang.Apply(tmp108, []any{tmp112, tmp114})
								tmp116 := lang.Apply(tmp107, []any{v95, tmp115})
								tmp117 := lang.Apply(tmp106, []any{v89, kw_inline, tmp116})
								tmp99 = tmp117
							} else {
								tmp99 = v89
							}
							tmp90 = tmp99
						} // end let
						var v91 any = tmp90
						_ = v91
						// let binding "m"
						tmp92 := checkDerefVar(var_glojure_DOT_core_conj)
						var tmp93 any
						tmp94 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp95 := lang.Apply(tmp94, []any{v6})
						if lang.IsTruthy(tmp95) {
							tmp96 := checkDerefVar(var_glojure_DOT_core_meta)
							tmp97 := lang.Apply(tmp96, []any{v6})
							tmp93 = tmp97
						} else {
							tmp98 := lang.NewMap()
							tmp99 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(328), kw_column, int(51), kw_end_DASH_line, int(328), kw_end_DASH_column, int(52))
							tmp100, err := lang.WithMeta(tmp98, tmp99.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp93 = tmp100
						}
						tmp101 := lang.Apply(tmp92, []any{tmp93, v91})
						var v102 any = tmp101
						_ = v102
						tmp103 := checkDerefVar(var_glojure_DOT_core_list)
						tmp104 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
						tmp105 := lang.Apply(tmp104, []any{v6, v102})
						tmp106 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
						tmp107 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp108 := lang.Apply(tmp107, []any{sym_glojure_DOT_core_SLASH_fn, v79})
						tmp109 := lang.Apply(kw_tag, []any{v102})
						tmp110 := lang.NewMap(kw_rettag, tmp109)
						tmp111 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(333), kw_column, int(37), kw_end_DASH_line, int(333), kw_end_DASH_column, int(54))
						tmp112, err := lang.WithMeta(tmp110, tmp111.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp113 := lang.Apply(tmp106, []any{tmp108, tmp112})
						tmp114 := lang.Apply(tmp103, []any{sym_def, tmp105, tmp113})
						tmp13 = tmp114
					} // end let
					return tmp13
				}
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(291), kw_column, int(7), kw_end_DASH_line, int(333), kw_end_DASH_column, int(58))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defn-
	{
		tmp0 := sym_defn_DASH_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_decls)), kw_doc, "same as defn, yielding non-public def", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(4949), kw_end_DASH_line, int(4949))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp8 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
				tmp9 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp10 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp11 := lang.Apply(tmp10, []any{v5})
				tmp12 := lang.Apply(tmp9, []any{tmp11, kw_private, true})
				tmp13 := lang.Apply(tmp8, []any{v5, tmp12})
				tmp14 := lang.Apply(tmp7, []any{sym_glojure_DOT_core_SLASH_defn, tmp13, v6})
				return tmp14
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defonce
	{
		tmp0 := sym_defonce.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_expr)), kw_doc, "defs name to have the root value of the expr iff the named var has no root value,\n  else expr is unevaluated", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(5806), kw_end_DASH_line, int(5806))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp9 := checkDerefVar(var_glojure_DOT_core_list)
			tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_let})
			tmp11 := checkDerefVar(var_glojure_DOT_core_list)
			tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp13 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp16 := checkDerefVar(var_glojure_DOT_core_list)
			tmp17 := lang.Apply(tmp16, []any{sym_v__0__auto__})
			tmp18 := checkDerefVar(var_glojure_DOT_core_list)
			tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp21 := checkDerefVar(var_glojure_DOT_core_list)
			tmp22 := lang.Apply(tmp21, []any{sym_def})
			tmp23 := checkDerefVar(var_glojure_DOT_core_list)
			tmp24 := lang.Apply(tmp23, []any{v5})
			tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
			tmp26 := lang.Apply(tmp19, []any{tmp25})
			tmp27 := lang.Apply(tmp18, []any{tmp26})
			tmp28 := lang.Apply(tmp15, []any{tmp17, tmp27})
			tmp29 := lang.Apply(tmp14, []any{tmp28})
			tmp30 := lang.Apply(tmp12, []any{tmp13, tmp29})
			tmp31 := lang.Apply(tmp11, []any{tmp30})
			tmp32 := checkDerefVar(var_glojure_DOT_core_list)
			tmp33 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp34 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp35 := checkDerefVar(var_glojure_DOT_core_list)
			tmp36 := lang.Apply(tmp35, []any{sym_glojure_DOT_core_SLASH_when_DASH_not})
			tmp37 := checkDerefVar(var_glojure_DOT_core_list)
			tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp39 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp40 := checkDerefVar(var_glojure_DOT_core_list)
			tmp41 := lang.Apply(tmp40, []any{sym__DOT_HasRoot})
			tmp42 := checkDerefVar(var_glojure_DOT_core_list)
			tmp43 := lang.Apply(tmp42, []any{sym_v__0__auto__})
			tmp44 := lang.Apply(tmp39, []any{tmp41, tmp43})
			tmp45 := lang.Apply(tmp38, []any{tmp44})
			tmp46 := lang.Apply(tmp37, []any{tmp45})
			tmp47 := checkDerefVar(var_glojure_DOT_core_list)
			tmp48 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp49 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp50 := checkDerefVar(var_glojure_DOT_core_list)
			tmp51 := lang.Apply(tmp50, []any{sym_def})
			tmp52 := checkDerefVar(var_glojure_DOT_core_list)
			tmp53 := lang.Apply(tmp52, []any{v5})
			tmp54 := checkDerefVar(var_glojure_DOT_core_list)
			tmp55 := lang.Apply(tmp54, []any{v6})
			tmp56 := lang.Apply(tmp49, []any{tmp51, tmp53, tmp55})
			tmp57 := lang.Apply(tmp48, []any{tmp56})
			tmp58 := lang.Apply(tmp47, []any{tmp57})
			tmp59 := lang.Apply(tmp34, []any{tmp36, tmp46, tmp58})
			tmp60 := lang.Apply(tmp33, []any{tmp59})
			tmp61 := lang.Apply(tmp32, []any{tmp60})
			tmp62 := lang.Apply(tmp8, []any{tmp10, tmp31, tmp61})
			tmp63 := lang.Apply(tmp7, []any{tmp62})
			return tmp63
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defprotocol
	{
		tmp0 := sym_defprotocol.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_opts_PLUS_sigs)), kw_doc, "A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n   ;options\n   :extend-via-metadata true\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in \n  Java parlance). defprotocol is dynamic, has no special compile-time \n  effect, and defines no new types or classes. Implementations of \n  the protocol methods can be provided using extend.\n\n  When :extend-via-metadata is true, values can extend protocols by\n  adding metadata where keys are fully-qualified protocol function\n  symbols and values are function implementations. Protocol\n  implementations are checked first for direct definitions (defrecord,\n  deftype, reify), then metadata definitions, then external\n  extensions (extend, extend-type, extend-protocol)\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P \n    (foo [this]) \n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c] \n   P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n  \n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo \n    (let [x 42]\n      (reify P \n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", kw_file, "glojure/core_deftype.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(11), kw_line, int(28), kw_end_DASH_line, int(28))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "doc"
					var tmp8 any
					tmp9 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v6})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(var_glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v6})
						tmp8 = tmp14
					} else {
					}
					var v15 any = tmp8
					_ = v15
					// let binding "opts+sigs"
					var tmp16 any
					if lang.IsTruthy(v15) {
						tmp17 := checkDerefVar(var_glojure_DOT_core_rest)
						tmp18 := lang.Apply(tmp17, []any{v6})
						tmp16 = tmp18
					} else {
						tmp16 = v6
					}
					var v19 any = tmp16
					_ = v19
					// let binding "opts"
					tmp20 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
					var tmp21 lang.FnFunc
					tmp21 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v22 := args[0]
						_ = v22
						tmp23 := checkDerefVar(var_glojure_DOT_core_not)
						tmp24 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp25 := lang.Apply(tmp24, []any{v22})
						tmp26 := lang.Apply(tmp23, []any{tmp25})
						return tmp26
					})
					tmp22 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(92), kw_column, int(26), kw_end_DASH_line, int(92), kw_end_DASH_column, int(40))
					tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp24 := lang.Apply(tmp20, []any{tmp23, v19})
					var v25 any = tmp24
					_ = v25
					// let binding "sigs"
					tmp26 := checkDerefVar(var_glojure_DOT_core_drop_DASH_while)
					var tmp27 lang.FnFunc
					tmp27 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v28 := args[0]
						_ = v28
						tmp29 := checkDerefVar(var_glojure_DOT_core_not)
						tmp30 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp31 := lang.Apply(tmp30, []any{v28})
						tmp32 := lang.Apply(tmp29, []any{tmp31})
						return tmp32
					})
					tmp28 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(93), kw_column, int(26), kw_end_DASH_line, int(93), kw_end_DASH_column, int(40))
					tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp30 := lang.Apply(tmp26, []any{tmp29, v19})
					var v31 any = tmp30
					_ = v31
					// let binding "opts"
					var tmp32 any
					tmp33 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp34 := lang.Apply(tmp33, []any{v31, v25})
					if lang.IsTruthy(tmp34) {
					} else {
						tmp32 = v25
					}
					var v35 any = tmp32
					_ = v35
					tmp36 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp37 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp38 := checkDerefVar(var_glojure_DOT_core_list)
					tmp39 := lang.Apply(tmp38, []any{sym_do})
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp42 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp43 := checkDerefVar(var_glojure_DOT_core_list)
					tmp44 := lang.Apply(tmp43, []any{sym_def})
					tmp45 := checkDerefVar(var_glojure_DOT_core_list)
					tmp46 := lang.Apply(tmp45, []any{v5})
					tmp47 := checkDerefVar(var_glojure_DOT_core_list)
					tmp48 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp49 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp50 := checkDerefVar(var_glojure_DOT_core_list)
					tmp51 := lang.Apply(tmp50, []any{sym_glojure_DOT_core_SLASH_atom})
					tmp52 := checkDerefVar(var_glojure_DOT_core_list)
					tmp53 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp54 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp55 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp56 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp57 := checkDerefVar(var_glojure_DOT_core_list)
					tmp58 := lang.Apply(tmp57, []any{kw_on_DASH_interface})
					tmp59 := checkDerefVar(var_glojure_DOT_core_list)
					tmp60 := lang.Apply(tmp59, []any{true})
					tmp61 := checkDerefVar(var_glojure_DOT_core_list)
					tmp62 := lang.Apply(tmp61, []any{kw_sigs})
					tmp63 := checkDerefVar(var_glojure_DOT_core_list)
					tmp64 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp65 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp66 := checkDerefVar(var_glojure_DOT_core_list)
					tmp67 := lang.Apply(tmp66, []any{sym_quote})
					tmp68 := checkDerefVar(var_glojure_DOT_core_list)
					tmp69 := lang.Apply(tmp68, []any{v31})
					tmp70 := lang.Apply(tmp65, []any{tmp67, tmp69})
					tmp71 := lang.Apply(tmp64, []any{tmp70})
					tmp72 := lang.Apply(tmp63, []any{tmp71})
					tmp73 := checkDerefVar(var_glojure_DOT_core_list)
					tmp74 := lang.Apply(tmp73, []any{kw_multis})
					tmp75 := checkDerefVar(var_glojure_DOT_core_list)
					tmp76 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp77 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp78 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp79 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp80 := lang.Apply(tmp79, nil)
					tmp81 := lang.Apply(tmp78, []any{tmp80})
					tmp82 := lang.Apply(tmp76, []any{tmp77, tmp81})
					tmp83 := lang.Apply(tmp75, []any{tmp82})
					tmp84 := lang.Apply(tmp56, []any{tmp58, tmp60, tmp62, tmp72, tmp74, tmp83})
					tmp85 := lang.Apply(tmp55, []any{tmp84})
					tmp86 := lang.Apply(tmp53, []any{tmp54, tmp85})
					tmp87 := lang.Apply(tmp52, []any{tmp86})
					tmp88 := lang.Apply(tmp49, []any{tmp51, tmp87})
					tmp89 := lang.Apply(tmp48, []any{tmp88})
					tmp90 := lang.Apply(tmp47, []any{tmp89})
					tmp91 := lang.Apply(tmp42, []any{tmp44, tmp46, tmp90})
					tmp92 := lang.Apply(tmp41, []any{tmp91})
					tmp93 := lang.Apply(tmp40, []any{tmp92})
					tmp94 := checkDerefVar(var_glojure_DOT_core_list)
					tmp95 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp96 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp97 := checkDerefVar(var_glojure_DOT_core_list)
					tmp98 := lang.Apply(tmp97, []any{sym_glojure_DOT_core_SLASH_swap_BANG_})
					tmp99 := checkDerefVar(var_glojure_DOT_core_list)
					tmp100 := lang.Apply(tmp99, []any{sym_glojure_DOT_core_SLASH__DASH_protocols})
					tmp101 := checkDerefVar(var_glojure_DOT_core_list)
					tmp102 := lang.Apply(tmp101, []any{sym_glojure_DOT_core_SLASH_assoc})
					tmp103 := checkDerefVar(var_glojure_DOT_core_list)
					tmp104 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp105 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp106 := checkDerefVar(var_glojure_DOT_core_list)
					tmp107 := lang.Apply(tmp106, []any{sym_quote})
					tmp108 := checkDerefVar(var_glojure_DOT_core_list)
					tmp109 := lang.Apply(tmp108, []any{v5})
					tmp110 := lang.Apply(tmp105, []any{tmp107, tmp109})
					tmp111 := lang.Apply(tmp104, []any{tmp110})
					tmp112 := lang.Apply(tmp103, []any{tmp111})
					tmp113 := checkDerefVar(var_glojure_DOT_core_list)
					tmp114 := lang.Apply(tmp113, []any{v5})
					tmp115 := lang.Apply(tmp96, []any{tmp98, tmp100, tmp102, tmp112, tmp114})
					tmp116 := lang.Apply(tmp95, []any{tmp115})
					tmp117 := lang.Apply(tmp94, []any{tmp116})
					tmp118 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp119 lang.FnFunc
					tmp119 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v120 := args[0]
						_ = v120
						tmp121 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp122 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp123 := checkDerefVar(var_glojure_DOT_core_list)
						tmp124 := lang.Apply(tmp123, []any{sym_do})
						tmp125 := checkDerefVar(var_glojure_DOT_core_list)
						tmp126 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp127 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp128 := checkDerefVar(var_glojure_DOT_core_list)
						tmp129 := lang.Apply(tmp128, []any{sym_glojure_DOT_core_SLASH_defmulti})
						tmp130 := checkDerefVar(var_glojure_DOT_core_list)
						tmp131 := checkDerefVar(var_glojure_DOT_core_first)
						tmp132 := lang.Apply(tmp131, []any{v120})
						tmp133 := lang.Apply(tmp130, []any{tmp132})
						tmp134 := checkDerefVar(var_glojure_DOT_core_list)
						tmp135 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp136 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp137 := checkDerefVar(var_glojure_DOT_core_list)
						tmp138 := lang.Apply(tmp137, []any{sym_glojure_DOT_core_SLASH_fn})
						tmp139 := checkDerefVar(var_glojure_DOT_core_list)
						tmp140 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp141 := checkDerefVar(var_glojure_DOT_core_vector)
						tmp142 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp143 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp144 := checkDerefVar(var_glojure_DOT_core_list)
						tmp145 := lang.Apply(tmp144, []any{sym_this})
						tmp146 := checkDerefVar(var_glojure_DOT_core_list)
						tmp147 := lang.Apply(tmp146, []any{sym__AMP_})
						tmp148 := checkDerefVar(var_glojure_DOT_core_list)
						tmp149 := lang.Apply(tmp148, []any{sym_args})
						tmp150 := lang.Apply(tmp143, []any{tmp145, tmp147, tmp149})
						tmp151 := lang.Apply(tmp142, []any{tmp150})
						tmp152 := lang.Apply(tmp140, []any{tmp141, tmp151})
						tmp153 := lang.Apply(tmp139, []any{tmp152})
						tmp154 := checkDerefVar(var_glojure_DOT_core_list)
						tmp155 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp156 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp157 := checkDerefVar(var_glojure_DOT_core_list)
						tmp158 := lang.Apply(tmp157, []any{sym_glojure_DOT_core_SLASH_class})
						tmp159 := checkDerefVar(var_glojure_DOT_core_list)
						tmp160 := lang.Apply(tmp159, []any{sym_this})
						tmp161 := lang.Apply(tmp156, []any{tmp158, tmp160})
						tmp162 := lang.Apply(tmp155, []any{tmp161})
						tmp163 := lang.Apply(tmp154, []any{tmp162})
						tmp164 := lang.Apply(tmp136, []any{tmp138, tmp153, tmp163})
						tmp165 := lang.Apply(tmp135, []any{tmp164})
						tmp166 := lang.Apply(tmp134, []any{tmp165})
						tmp167 := lang.Apply(tmp127, []any{tmp129, tmp133, tmp166})
						tmp168 := lang.Apply(tmp126, []any{tmp167})
						tmp169 := lang.Apply(tmp125, []any{tmp168})
						tmp170 := checkDerefVar(var_glojure_DOT_core_list)
						tmp171 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp172 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp173 := checkDerefVar(var_glojure_DOT_core_list)
						tmp174 := lang.Apply(tmp173, []any{sym_glojure_DOT_core_SLASH_swap_BANG_})
						tmp175 := checkDerefVar(var_glojure_DOT_core_list)
						tmp176 := lang.Apply(tmp175, []any{v5})
						tmp177 := checkDerefVar(var_glojure_DOT_core_list)
						tmp178 := lang.Apply(tmp177, []any{sym_glojure_DOT_core_SLASH_assoc_DASH_in})
						tmp179 := checkDerefVar(var_glojure_DOT_core_list)
						tmp180 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp181 := checkDerefVar(var_glojure_DOT_core_vector)
						tmp182 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp183 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp184 := checkDerefVar(var_glojure_DOT_core_list)
						tmp185 := lang.Apply(tmp184, []any{kw_multis})
						tmp186 := checkDerefVar(var_glojure_DOT_core_list)
						tmp187 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp188 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp189 := checkDerefVar(var_glojure_DOT_core_list)
						tmp190 := lang.Apply(tmp189, []any{sym_glojure_DOT_core_SLASH_keyword})
						tmp191 := checkDerefVar(var_glojure_DOT_core_list)
						tmp192 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp193 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp194 := checkDerefVar(var_glojure_DOT_core_list)
						tmp195 := lang.Apply(tmp194, []any{sym_quote})
						tmp196 := checkDerefVar(var_glojure_DOT_core_list)
						tmp197 := checkDerefVar(var_glojure_DOT_core_first)
						tmp198 := lang.Apply(tmp197, []any{v120})
						tmp199 := lang.Apply(tmp196, []any{tmp198})
						tmp200 := lang.Apply(tmp193, []any{tmp195, tmp199})
						tmp201 := lang.Apply(tmp192, []any{tmp200})
						tmp202 := lang.Apply(tmp191, []any{tmp201})
						tmp203 := lang.Apply(tmp188, []any{tmp190, tmp202})
						tmp204 := lang.Apply(tmp187, []any{tmp203})
						tmp205 := lang.Apply(tmp186, []any{tmp204})
						tmp206 := lang.Apply(tmp183, []any{tmp185, tmp205})
						tmp207 := lang.Apply(tmp182, []any{tmp206})
						tmp208 := lang.Apply(tmp180, []any{tmp181, tmp207})
						tmp209 := lang.Apply(tmp179, []any{tmp208})
						tmp210 := checkDerefVar(var_glojure_DOT_core_list)
						tmp211 := checkDerefVar(var_glojure_DOT_core_first)
						tmp212 := lang.Apply(tmp211, []any{v120})
						tmp213 := lang.Apply(tmp210, []any{tmp212})
						tmp214 := lang.Apply(tmp172, []any{tmp174, tmp176, tmp178, tmp209, tmp213})
						tmp215 := lang.Apply(tmp171, []any{tmp214})
						tmp216 := lang.Apply(tmp170, []any{tmp215})
						tmp217 := lang.Apply(tmp122, []any{tmp124, tmp169, tmp216})
						tmp218 := lang.Apply(tmp121, []any{tmp217})
						return tmp218
					})
					tmp120 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(102), kw_column, int(13), kw_end_DASH_line, int(104), kw_end_DASH_column, int(90))
					tmp121, err := lang.WithMeta(tmp119, tmp120.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp122 := lang.Apply(tmp118, []any{tmp121, v31})
					tmp123 := checkDerefVar(var_glojure_DOT_core_list)
					tmp124 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp125 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp126 := checkDerefVar(var_glojure_DOT_core_list)
					tmp127 := lang.Apply(tmp126, []any{sym_var})
					tmp128 := checkDerefVar(var_glojure_DOT_core_list)
					tmp129 := lang.Apply(tmp128, []any{v5})
					tmp130 := lang.Apply(tmp125, []any{tmp127, tmp129})
					tmp131 := lang.Apply(tmp124, []any{tmp130})
					tmp132 := lang.Apply(tmp123, []any{tmp131})
					tmp133 := lang.Apply(tmp37, []any{tmp39, tmp93, tmp117, tmp122, tmp132})
					tmp134 := lang.Apply(tmp36, []any{tmp133})
					tmp7 = tmp134
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defstruct
	{
		tmp0 := sym_defstruct.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_keys)), kw_doc, "Same as (def name (create-struct keys...))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(4044), kw_end_DASH_line, int(4044))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_def})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{sym_glojure_DOT_core_SLASH_create_DASH_struct})
				tmp18 := lang.Apply(tmp15, []any{tmp17, v6})
				tmp19 := lang.Apply(tmp14, []any{tmp18})
				tmp20 := lang.Apply(tmp13, []any{tmp19})
				tmp21 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp20})
				tmp22 := lang.Apply(tmp7, []any{tmp21})
				return tmp22
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// delay
	{
		tmp0 := sym_delay.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls. See also - realized?", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(739), kw_end_DASH_line, int(739))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp8 := lang.NewVector()
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(746), kw_column, int(62), kw_end_DASH_line, int(746), kw_end_DASH_column, int(63))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := lang.Apply(tmp7, []any{sym_fn_STAR_, tmp10, v5})
				tmp12 := lang.Apply(tmp6, []any{sym_new, sym_glojure_DOT_lang_DOT_Delay, tmp11})
				return tmp12
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// delay?
	{
		tmp0 := sym_delay_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "returns true if x is a Delay created with delay", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(748), kw_end_DASH_line, int(748))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deliver
	{
		tmp0 := sym_deliver.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_promise, sym_val)), kw_doc, "Delivers the supplied value to the promise, releasing any pending\n  derefs. A subsequent call to deliver on a promise will have no effect.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(7109), kw_end_DASH_line, int(7109))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(v3, []any{v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// denominator
	{
		tmp1 := reflect.TypeOf((*big9.Int)(nil))
		tmp0 := sym_denominator.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_r)), kw_doc, "Returns the denominator part of a Ratio.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(3591), kw_end_DASH_line, int(3591))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, ok := lang.FieldOrMethod(v4, "denominator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "denominator")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			return tmp6
		})
		tmp4 := reflect.TypeOf((*big9.Int)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref
	{
		tmp0 := sym_deref.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref), lang.NewVector(sym_ref, sym_timeout_DASH_ms, sym_timeout_DASH_val)), kw_doc, "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(2304), kw_end_DASH_line, int(2304))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.IDeref)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
				if lang.IsTruthy(tmp7) {
					tmp8, ok := lang.FieldOrMethod(v3, "Deref")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Deref")))
					}
					var tmp9 any
					switch reflect.TypeOf(tmp8).Kind() {
					case reflect.Func:
						tmp9 = lang.Apply(tmp8, nil)
					default:
						tmp9 = tmp8
					}
					tmp4 = tmp9
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_deref_DASH_future)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp4 = tmp11
				}
				return tmp4
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp8 := reflect.TypeOf((*lang.IBlockingDeref)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
				if lang.IsTruthy(tmp9) {
					tmp10, _ := lang.FieldOrMethod(v3, "DerefWithTimeout")
					if reflect.TypeOf(tmp10).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("DerefWithTimeout is not a function")))
					}
					tmp11 := lang.Apply(tmp10, []any{v4, v5})
					tmp6 = tmp11
				} else {
					tmp12 := checkDerefVar(var_glojure_DOT_core_deref_DASH_future)
					tmp13 := lang.Apply(tmp12, []any{v3, v4, v5})
					tmp6 = tmp13
				}
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref-as-map
	{
		tmp0 := sym_deref_DASH_as_DASH_map.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(408), kw_column, int(8), kw_end_DASH_line, int(408), kw_end_DASH_column, int(19), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_o)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "pending"
				var tmp5 any
				{ // let
					// let binding "and__0__auto__"
					tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp7 := reflect.TypeOf((*lang.IPending)(nil)).Elem()
					tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp11 := checkDerefVar(var_glojure_DOT_core_not)
						tmp12, ok := lang.FieldOrMethod(v3, "isRealized")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isRealized")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						tmp14 := lang.Apply(tmp11, []any{tmp13})
						tmp10 = tmp14
					} else {
						tmp10 = v9
					}
					tmp5 = tmp10
				} // end let
				var v6 any = tmp5
				_ = v6
				// let binding "vec__250"
				var tmp7 any
				if lang.IsTruthy(v6) {
				} else {
					var tmp8 any
					func() {
						defer func() {
							if r := recover(); r != nil {
								if lang.CatchMatches(r, lang.Throwable) {
									v9 := r
									_ = v9
									tmp10 := lang.NewVector(true, v9)
									tmp11 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(415), kw_column, int(18), kw_end_DASH_line, int(415), kw_end_DASH_column, int(25))
									tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp8 = tmp12
								} else {
									panic(r)
								}
							}
						}()
						tmp9 := checkDerefVar(var_glojure_DOT_core_deref)
						tmp10 := lang.Apply(tmp9, []any{v3})
						tmp11 := lang.NewVector(false, tmp10)
						tmp12 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(413), kw_column, int(16), kw_end_DASH_line, int(413), kw_end_DASH_column, int(32))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp13
					}()
					tmp7 = tmp8
				}
				var v14 any = tmp7
				_ = v14
				// let binding "ex"
				tmp15 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
				var v17 any = tmp16
				_ = v17
				// let binding "val"
				tmp18 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp19 := lang.Apply(tmp18, []any{v14, int64(1), nil})
				var v20 any = tmp19
				_ = v20
				var tmp21 any
				var tmp22 any
				{ // let
					// let binding "or__0__auto__"
					var v23 any = v17
					_ = v23
					var tmp24 any
					if lang.IsTruthy(v23) {
						tmp24 = v23
					} else {
						var tmp25 any
						{ // let
							// let binding "and__0__auto__"
							tmp26 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
							tmp27 := reflect.TypeOf((*lang.Agent)(nil))
							tmp28 := lang.Apply(tmp26, []any{tmp27, v3})
							var v29 any = tmp28
							_ = v29
							var tmp30 any
							if lang.IsTruthy(v29) {
								tmp31 := checkDerefVar(var_glojure_DOT_core_agent_DASH_error)
								tmp32 := lang.Apply(tmp31, []any{v3})
								tmp30 = tmp32
							} else {
								tmp30 = v29
							}
							tmp25 = tmp30
						} // end let
						tmp24 = tmp25
					}
					tmp22 = tmp24
				} // end let
				if lang.IsTruthy(tmp22) {
					tmp21 = kw_failed
				} else {
					var tmp23 any
					if lang.IsTruthy(v6) {
						tmp23 = kw_pending
					} else {
						var tmp24 any
						if lang.IsTruthy(kw_else) {
							tmp24 = kw_ready
						} else {
						}
						tmp23 = tmp24
					}
					tmp21 = tmp23
				}
				tmp25 := lang.NewMap(kw_status, tmp21, kw_val, v20)
				tmp26 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(416), kw_column, int(5), kw_end_DASH_line, int(429), kw_end_DASH_column, int(14))
				tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp27
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref-future
	{
		tmp0 := sym_deref_DASH_future.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(2296), kw_column, int(7), kw_end_DASH_line, int(2296), kw_end_DASH_column, int(28), kw_arglists, lang.NewList(lang.NewVector(sym_fut), lang.NewVector(sym_fut, sym_timeout_DASH_ms, sym_timeout_DASH_val)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, ok := lang.FieldOrMethod(v3, "Get")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Get")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							tmp7 := reflect.TypeOf((*lang.TimeoutError)(nil)).Elem()
							if lang.CatchMatches(r, tmp7) {
								v8 := r
								_ = v8
								tmp6 = v5
							} else {
								panic(r)
							}
						}
					}()
					tmp8, _ := lang.FieldOrMethod(v3, "Get")
					if reflect.TypeOf(tmp8).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Get is not a function")))
					}
					tmp9 := lang.Apply(tmp8, []any{v4, time10.Millisecond})
					tmp6 = tmp9
				}()
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// derive
	{
		tmp0 := sym_derive.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag, sym_parent), lang.NewVector(sym_h, sym_tag, sym_parent)), kw_doc, "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5605), kw_end_DASH_line, int(5605))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_alter_DASH_var_DASH_root)
				tmp6 := lang.InternVarName(sym_glojure_DOT_core, sym_global_DASH_hierarchy)
				tmp7 := checkDerefVar(var_glojure_DOT_core_derive)
				tmp8 := lang.Apply(tmp5, []any{tmp6, tmp7, v3, v4})
				_ = tmp8
				return nil
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "tp"
					tmp7 := lang.Apply(kw_parents, []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "td"
					tmp9 := lang.Apply(kw_descendants, []any{v3})
					var v10 any = tmp9
					_ = v10
					// let binding "ta"
					tmp11 := lang.Apply(kw_ancestors, []any{v3})
					var v12 any = tmp11
					_ = v12
					// let binding "tf"
					var tmp13 lang.FnFunc
					tmp13 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 5)
						v14 := args[0]
						_ = v14
						v15 := args[1]
						_ = v15
						v16 := args[2]
						_ = v16
						v17 := args[3]
						_ = v17
						v18 := args[4]
						_ = v18
						tmp19 := checkDerefVar(var_glojure_DOT_core_reduce1)
						var tmp20 lang.FnFunc
						tmp20 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v21 := args[0]
							_ = v21
							v22 := args[1]
							_ = v22
							tmp23 := checkDerefVar(var_glojure_DOT_core_assoc)
							tmp24 := checkDerefVar(var_glojure_DOT_core_reduce1)
							tmp25 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp26 := checkDerefVar(var_glojure_DOT_core_get)
							tmp27 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp28 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5628), kw_column, int(61), kw_end_DASH_line, int(5628), kw_end_DASH_column, int(63))
							tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp30 := lang.Apply(tmp26, []any{v18, v22, tmp29})
							tmp31 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp32 := lang.Apply(v18, []any{v17})
							tmp33 := lang.Apply(tmp31, []any{v17, tmp32})
							tmp34 := lang.Apply(tmp24, []any{tmp25, tmp30, tmp33})
							tmp35 := lang.Apply(tmp23, []any{v21, v22, tmp34})
							return tmp35
						})
						tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5626), kw_column, int(24), kw_end_DASH_line, int(5628), kw_end_DASH_column, int(98))
						tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp23 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp24 := lang.Apply(v16, []any{v15})
						tmp25 := lang.Apply(tmp23, []any{v15, tmp24})
						tmp26 := lang.Apply(tmp19, []any{tmp22, v14, tmp25})
						return tmp26
					})
					tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5625), kw_column, int(13), kw_end_DASH_line, int(5629), kw_end_DASH_column, int(56))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v16 any = tmp15
					_ = v16
					var tmp17 any
					{ // let
						// let binding "or__0__auto__"
						var tmp18 any
						tmp19 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
						tmp20 := lang.Apply(v8, []any{v4})
						tmp21 := lang.Apply(tmp19, []any{tmp20, v5})
						if lang.IsTruthy(tmp21) {
						} else {
							var tmp22 any
							tmp23 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
							tmp24 := lang.Apply(v12, []any{v4})
							tmp25 := lang.Apply(tmp23, []any{tmp24, v5})
							if lang.IsTruthy(tmp25) {
								tmp26 := checkDerefVar(var_glojure_DOT_core_print_DASH_str)
								tmp27 := lang.Apply(tmp26, []any{v4, "already has", v5, "as ancestor"})
								tmp28 := lang.Apply(lang.NewError, []any{tmp27})
								panic(tmp28)
							} else {
							}
							_ = tmp22
							var tmp29 any
							tmp30 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
							tmp31 := lang.Apply(v12, []any{v5})
							tmp32 := lang.Apply(tmp30, []any{tmp31, v4})
							if lang.IsTruthy(tmp32) {
								tmp33 := checkDerefVar(var_glojure_DOT_core_print_DASH_str)
								tmp34 := lang.Apply(tmp33, []any{"Cyclic derivation:", v5, "has", v4, "as ancestor"})
								tmp35 := lang.Apply(lang.NewError, []any{tmp34})
								panic(tmp35)
							} else {
							}
							_ = tmp29
							tmp36 := checkDerefVar(var_glojure_DOT_core_assoc)
							tmp37 := lang.Apply(kw_parents, []any{v3})
							tmp38 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp39 := checkDerefVar(var_glojure_DOT_core_get)
							tmp40 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp41 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5636), kw_column, int(61), kw_end_DASH_line, int(5636), kw_end_DASH_column, int(63))
							tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp43 := lang.Apply(tmp39, []any{v8, v4, tmp42})
							tmp44 := lang.Apply(tmp38, []any{tmp43, v5})
							tmp45 := lang.Apply(tmp36, []any{tmp37, v4, tmp44})
							tmp46 := lang.Apply(kw_ancestors, []any{v3})
							tmp47 := lang.Apply(v16, []any{tmp46, v4, v10, v5, v12})
							tmp48 := lang.Apply(kw_descendants, []any{v3})
							tmp49 := lang.Apply(v16, []any{tmp48, v5, v12, v4, v10})
							tmp50 := lang.NewMap(kw_parents, tmp45, kw_ancestors, tmp47, kw_descendants, tmp49)
							tmp51 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5636), kw_column, int(9), kw_end_DASH_line, int(5638), kw_end_DASH_column, int(61))
							tmp52, err := lang.WithMeta(tmp50, tmp51.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp18 = tmp52
						}
						var v53 any = tmp18
						_ = v53
						var tmp54 any
						if lang.IsTruthy(v53) {
							tmp54 = v53
						} else {
							tmp54 = v3
						}
						tmp17 = tmp54
					} // end let
					tmp6 = tmp17
				} // end let
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// descendants
	{
		tmp0 := sym_descendants.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag), lang.NewVector(sym_h, sym_tag)), kw_doc, "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on Java type inheritance\n  relationships.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(5593), kw_end_DASH_line, int(5593))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_descendants)
				tmp5 := checkDerefVar(var_glojure_DOT_core_global_DASH_hierarchy)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp8 := lang.Apply(lang.NewUnsupportedOperationError, []any{"Can't get descendants of classes"})
					panic(tmp8)
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
					tmp10 := checkDerefVar(var_glojure_DOT_core_get)
					tmp11 := lang.Apply(kw_descendants, []any{v3})
					tmp12 := lang.Apply(tmp10, []any{tmp11, v4})
					tmp13 := lang.Apply(tmp9, []any{tmp12})
					tmp5 = tmp13
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// destructure
	{
		tmp0 := sym_destructure.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4400), kw_column, int(7), kw_end_DASH_line, int(4400), kw_end_DASH_column, int(17), kw_arglists, lang.NewList(lang.NewVector(sym_bindings)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "bents"
				tmp5 := checkDerefVar(var_glojure_DOT_core_partition)
				tmp6 := lang.Apply(tmp5, []any{int64(2), v3})
				var v7 any = tmp6
				_ = v7
				// let binding "pb"
				var tmp8 lang.FnFunc
				{ // function pb
					var v9 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 3)
						v10 := args[0]
						_ = v10
						v11 := args[1]
						_ = v11
						v12 := args[2]
						_ = v12
						var tmp13 any
						{ // let
							// let binding "pvec"
							var tmp14 lang.FnFunc
							tmp14 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 3)
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								v17 := args[2]
								_ = v17
								var tmp18 any
								{ // let
									// let binding "gvec"
									tmp19 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp20 := lang.Apply(tmp19, []any{"vec__"})
									var v21 any = tmp20
									_ = v21
									// let binding "gseq"
									tmp22 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp23 := lang.Apply(tmp22, []any{"seq__"})
									var v24 any = tmp23
									_ = v24
									// let binding "gfirst"
									tmp25 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp26 := lang.Apply(tmp25, []any{"first__"})
									var v27 any = tmp26
									_ = v27
									// let binding "has-rest"
									tmp28 := checkDerefVar(var_glojure_DOT_core_some)
									tmp29 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{sym__AMP_}))
									tmp30 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4408), kw_column, int(43), kw_end_DASH_line, int(4408), kw_end_DASH_column, int(47))
									tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp32 := lang.Apply(tmp28, []any{tmp31, v16})
									var v33 any = tmp32
									_ = v33
									var tmp34 any
									{ // let
										// let binding "ret"
										var tmp35 any
										{ // let
											// let binding "ret"
											tmp36 := checkDerefVar(var_glojure_DOT_core_conj)
											tmp37 := lang.Apply(tmp36, []any{v15, v21, v17})
											var v38 any = tmp37
											_ = v38
											var tmp39 any
											if lang.IsTruthy(v33) {
												tmp40 := checkDerefVar(var_glojure_DOT_core_conj)
												tmp41 := checkDerefVar(var_glojure_DOT_core_list)
												tmp42 := lang.Apply(tmp41, []any{sym_glojure_DOT_core_SLASH_seq, v21})
												tmp43 := lang.Apply(tmp40, []any{v38, v24, tmp42})
												tmp39 = tmp43
											} else {
												tmp39 = v38
											}
											tmp35 = tmp39
										} // end let
										var v36 any = tmp35
										_ = v36
										// let binding "n"
										var v37 any = int64(0)
										_ = v37
										// let binding "bs"
										var v38 any = v16
										_ = v38
										// let binding "seen-rest?"
										var v39 any = false
										_ = v39
										for {
											var tmp40 any
											tmp41 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp42 := lang.Apply(tmp41, []any{v38})
											if lang.IsTruthy(tmp42) {
												var tmp43 any
												{ // let
													// let binding "firstb"
													tmp44 := checkDerefVar(var_glojure_DOT_core_first)
													tmp45 := lang.Apply(tmp44, []any{v38})
													var v46 any = tmp45
													_ = v46
													var tmp47 any
													tmp48 := checkDerefVar(var_glojure_DOT_core__EQ_)
													tmp49 := lang.Apply(tmp48, []any{v46, sym__AMP_})
													if lang.IsTruthy(tmp49) {
														tmp51 := checkDerefVar(var_glojure_DOT_core_second)
														tmp52 := lang.Apply(tmp51, []any{v38})
														tmp53 := lang.Apply(v9, []any{v36, tmp52, v24})
														var tmp50 any = tmp53
														var tmp54 any = v37
														tmp56 := checkDerefVar(var_glojure_DOT_core_nnext)
														tmp57 := lang.Apply(tmp56, []any{v38})
														var tmp55 any = tmp57
														var tmp58 any = true
														v36 = tmp50
														v37 = tmp54
														v38 = tmp55
														v39 = tmp58
														continue
													} else {
														var tmp59 any
														tmp60 := checkDerefVar(var_glojure_DOT_core__EQ_)
														tmp61 := lang.Apply(tmp60, []any{v46, kw_as})
														if lang.IsTruthy(tmp61) {
															tmp62 := checkDerefVar(var_glojure_DOT_core_second)
															tmp63 := lang.Apply(tmp62, []any{v38})
															tmp64 := lang.Apply(v9, []any{v36, tmp63, v21})
															tmp59 = tmp64
														} else {
															var tmp65 any
															if lang.IsTruthy(kw_else) {
																var tmp66 any
																if lang.IsTruthy(v39) {
																	tmp67 := lang.Apply(errors8.New, []any{"Unsupported binding form, only :as can follow & parameter"})
																	panic(tmp67)
																} else {
																	var tmp69 any
																	if lang.IsTruthy(v33) {
																		tmp70 := checkDerefVar(var_glojure_DOT_core_conj)
																		tmp71 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp72 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp73 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp74 := lang.Apply(tmp73, []any{sym_glojure_DOT_core_SLASH_first})
																		tmp75 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp76 := lang.Apply(tmp75, []any{v24})
																		tmp77 := lang.Apply(tmp72, []any{tmp74, tmp76})
																		tmp78 := lang.Apply(tmp71, []any{tmp77})
																		tmp79 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp80 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp81 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp82 := lang.Apply(tmp81, []any{sym_glojure_DOT_core_SLASH_next})
																		tmp83 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp84 := lang.Apply(tmp83, []any{v24})
																		tmp85 := lang.Apply(tmp80, []any{tmp82, tmp84})
																		tmp86 := lang.Apply(tmp79, []any{tmp85})
																		tmp87 := lang.Apply(tmp70, []any{v36, v27, tmp78, v24, tmp86})
																		tmp69 = tmp87
																	} else {
																		tmp69 = v36
																	}
																	var tmp88 any
																	if lang.IsTruthy(v33) {
																		tmp88 = v27
																	} else {
																		tmp89 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp90 := lang.Apply(tmp89, []any{sym_glojure_DOT_core_SLASH_nth, v21, v37, nil})
																		tmp88 = tmp90
																	}
																	tmp91 := lang.Apply(v9, []any{tmp69, v46, tmp88})
																	var tmp68 any = tmp91
																	tmp93 := checkDerefVar(var_glojure_DOT_core_inc)
																	tmp94 := lang.Apply(tmp93, []any{v37})
																	var tmp92 any = tmp94
																	tmp96 := checkDerefVar(var_glojure_DOT_core_next)
																	tmp97 := lang.Apply(tmp96, []any{v38})
																	var tmp95 any = tmp97
																	var tmp98 any = v39
																	v36 = tmp68
																	v37 = tmp92
																	v38 = tmp95
																	v39 = tmp98
																	continue
																}
																tmp65 = tmp66
															} else {
															}
															tmp59 = tmp65
														}
														tmp47 = tmp59
													}
													tmp43 = tmp47
												} // end let
												tmp40 = tmp43
											} else {
												tmp40 = v36
											}
											tmp34 = tmp40
											break
										}
									} // end let
									tmp18 = tmp34
								} // end let
								return tmp18
							})
							tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4404), kw_column, int(20), kw_end_DASH_line, int(4438), kw_end_DASH_column, int(34))
							tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v17 any = tmp16
							_ = v17
							// let binding "pmap"
							var tmp18 lang.FnFunc
							tmp18 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 3)
								v19 := args[0]
								_ = v19
								v20 := args[1]
								_ = v20
								v21 := args[2]
								_ = v21
								var tmp22 any
								{ // let
									// let binding "gmap"
									tmp23 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp24 := lang.Apply(tmp23, []any{"map__"})
									var v25 any = tmp24
									_ = v25
									// let binding "gmapseq"
									tmp26 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
									tmp27 := lang.NewMap(kw_tag, sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_ISeq)
									tmp28 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4442), kw_column, int(52), kw_end_DASH_line, int(4442), kw_end_DASH_column, int(103))
									tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp30 := lang.Apply(tmp26, []any{v25, tmp29})
									var v31 any = tmp30
									_ = v31
									// let binding "defaults"
									tmp32 := lang.Apply(kw_or, []any{v20})
									var v33 any = tmp32
									_ = v33
									var tmp34 any
									{ // let
										// let binding "ret"
										var tmp35 lang.FnFunc
										tmp35 = lang.NewFnFunc(func(args ...any) any {
											checkArity(args, 1)
											v36 := args[0]
											_ = v36
											var tmp37 any
											tmp38 := lang.Apply(kw_as, []any{v20})
											if lang.IsTruthy(tmp38) {
												tmp39 := checkDerefVar(var_glojure_DOT_core_conj)
												tmp40 := lang.Apply(kw_as, []any{v20})
												tmp41 := lang.Apply(tmp39, []any{v36, tmp40, v25})
												tmp37 = tmp41
											} else {
												tmp37 = v36
											}
											return tmp37
										})
										tmp36 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4450), kw_column, int(40), kw_end_DASH_line, int(4453), kw_end_DASH_column, int(48))
										tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp38 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp39 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp40 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp41 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp42 := lang.Apply(tmp41, []any{v19, v25})
										tmp43 := lang.Apply(tmp40, []any{tmp42, v21})
										tmp44 := lang.Apply(tmp39, []any{tmp43, v25})
										tmp45 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp46 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp47 := checkDerefVar(var_glojure_DOT_core_list)
										tmp48 := lang.Apply(tmp47, []any{sym_if})
										tmp49 := checkDerefVar(var_glojure_DOT_core_list)
										tmp50 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp51 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp52 := checkDerefVar(var_glojure_DOT_core_list)
										tmp53 := lang.Apply(tmp52, []any{sym_glojure_DOT_core_SLASH_seq_QMARK_})
										tmp54 := checkDerefVar(var_glojure_DOT_core_list)
										tmp55 := lang.Apply(tmp54, []any{v25})
										tmp56 := lang.Apply(tmp51, []any{tmp53, tmp55})
										tmp57 := lang.Apply(tmp50, []any{tmp56})
										tmp58 := lang.Apply(tmp49, []any{tmp57})
										tmp59 := checkDerefVar(var_glojure_DOT_core_list)
										tmp60 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp61 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp62 := checkDerefVar(var_glojure_DOT_core_list)
										tmp63 := lang.Apply(tmp62, []any{sym_if})
										tmp64 := checkDerefVar(var_glojure_DOT_core_list)
										tmp65 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp66 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp67 := checkDerefVar(var_glojure_DOT_core_list)
										tmp68 := lang.Apply(tmp67, []any{sym_glojure_DOT_core_SLASH_next})
										tmp69 := checkDerefVar(var_glojure_DOT_core_list)
										tmp70 := lang.Apply(tmp69, []any{v31})
										tmp71 := lang.Apply(tmp66, []any{tmp68, tmp70})
										tmp72 := lang.Apply(tmp65, []any{tmp71})
										tmp73 := lang.Apply(tmp64, []any{tmp72})
										tmp74 := checkDerefVar(var_glojure_DOT_core_list)
										tmp75 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp76 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp77 := checkDerefVar(var_glojure_DOT_core_list)
										tmp78 := lang.Apply(tmp77, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewPersistentArrayMapAsIfByAssoc})
										tmp79 := checkDerefVar(var_glojure_DOT_core_list)
										tmp80 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp81 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp82 := checkDerefVar(var_glojure_DOT_core_list)
										tmp83 := lang.Apply(tmp82, []any{sym_glojure_DOT_core_SLASH_to_DASH_array})
										tmp84 := checkDerefVar(var_glojure_DOT_core_list)
										tmp85 := lang.Apply(tmp84, []any{v31})
										tmp86 := lang.Apply(tmp81, []any{tmp83, tmp85})
										tmp87 := lang.Apply(tmp80, []any{tmp86})
										tmp88 := lang.Apply(tmp79, []any{tmp87})
										tmp89 := lang.Apply(tmp76, []any{tmp78, tmp88})
										tmp90 := lang.Apply(tmp75, []any{tmp89})
										tmp91 := lang.Apply(tmp74, []any{tmp90})
										tmp92 := checkDerefVar(var_glojure_DOT_core_list)
										tmp93 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp94 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp95 := checkDerefVar(var_glojure_DOT_core_list)
										tmp96 := lang.Apply(tmp95, []any{sym_if})
										tmp97 := checkDerefVar(var_glojure_DOT_core_list)
										tmp98 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp99 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp100 := checkDerefVar(var_glojure_DOT_core_list)
										tmp101 := lang.Apply(tmp100, []any{sym_glojure_DOT_core_SLASH_seq})
										tmp102 := checkDerefVar(var_glojure_DOT_core_list)
										tmp103 := lang.Apply(tmp102, []any{v31})
										tmp104 := lang.Apply(tmp99, []any{tmp101, tmp103})
										tmp105 := lang.Apply(tmp98, []any{tmp104})
										tmp106 := lang.Apply(tmp97, []any{tmp105})
										tmp107 := checkDerefVar(var_glojure_DOT_core_list)
										tmp108 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp109 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp110 := checkDerefVar(var_glojure_DOT_core_list)
										tmp111 := lang.Apply(tmp110, []any{sym_glojure_DOT_core_SLASH_first})
										tmp112 := checkDerefVar(var_glojure_DOT_core_list)
										tmp113 := lang.Apply(tmp112, []any{v31})
										tmp114 := lang.Apply(tmp109, []any{tmp111, tmp113})
										tmp115 := lang.Apply(tmp108, []any{tmp114})
										tmp116 := lang.Apply(tmp107, []any{tmp115})
										tmp117 := checkDerefVar(var_glojure_DOT_core_list)
										tmp118 := lang.Apply(tmp117, []any{sym_glojure_DOT_lang_DOT_PersistentArrayMap_SLASH_EMPTY})
										tmp119 := lang.Apply(tmp94, []any{tmp96, tmp106, tmp116, tmp118})
										tmp120 := lang.Apply(tmp93, []any{tmp119})
										tmp121 := lang.Apply(tmp92, []any{tmp120})
										tmp122 := lang.Apply(tmp61, []any{tmp63, tmp73, tmp91, tmp121})
										tmp123 := lang.Apply(tmp60, []any{tmp122})
										tmp124 := lang.Apply(tmp59, []any{tmp123})
										tmp125 := checkDerefVar(var_glojure_DOT_core_list)
										tmp126 := lang.Apply(tmp125, []any{v25})
										tmp127 := lang.Apply(tmp46, []any{tmp48, tmp58, tmp124, tmp126})
										tmp128 := lang.Apply(tmp45, []any{tmp127})
										tmp129 := lang.Apply(tmp38, []any{tmp44, tmp128})
										tmp130 := lang.Apply(tmp37, []any{tmp129})
										var v131 any = tmp130
										_ = v131
										// let binding "bes"
										var tmp132 any
										{ // let
											// let binding "transforms"
											tmp133 := checkDerefVar(var_glojure_DOT_core_reduce1)
											var tmp134 lang.FnFunc
											tmp134 = lang.NewFnFunc(func(args ...any) any {
												checkArity(args, 2)
												v135 := args[0]
												_ = v135
												v136 := args[1]
												_ = v136
												var tmp137 any
												tmp138 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
												tmp139 := lang.Apply(tmp138, []any{v136})
												if lang.IsTruthy(tmp139) {
													var tmp140 any
													{ // let
														// let binding "mkns"
														tmp141 := checkDerefVar(var_glojure_DOT_core_namespace)
														tmp142 := lang.Apply(tmp141, []any{v136})
														var v143 any = tmp142
														_ = v143
														// let binding "mkn"
														tmp144 := checkDerefVar(var_glojure_DOT_core_name)
														tmp145 := lang.Apply(tmp144, []any{v136})
														var v146 any = tmp145
														_ = v146
														var tmp147 any
														tmp148 := checkDerefVar(var_glojure_DOT_core__EQ_)
														tmp149 := lang.Apply(tmp148, []any{v146, "keys"})
														if lang.IsTruthy(tmp149) {
															tmp150 := checkDerefVar(var_glojure_DOT_core_assoc)
															var tmp151 lang.FnFunc
															tmp151 = lang.NewFnFunc(func(args ...any) any {
																checkArity(args, 1)
																v152 := args[0]
																_ = v152
																tmp153 := checkDerefVar(var_glojure_DOT_core_keyword)
																var tmp154 any
																{ // let
																	// let binding "or__0__auto__"
																	var v155 any = v143
																	_ = v155
																	var tmp156 any
																	if lang.IsTruthy(v155) {
																		tmp156 = v155
																	} else {
																		tmp157 := checkDerefVar(var_glojure_DOT_core_namespace)
																		tmp158 := lang.Apply(tmp157, []any{v152})
																		tmp156 = tmp158
																	}
																	tmp154 = tmp156
																} // end let
																tmp155 := checkDerefVar(var_glojure_DOT_core_name)
																tmp156 := lang.Apply(tmp155, []any{v152})
																tmp157 := lang.Apply(tmp153, []any{tmp154, tmp156})
																return tmp157
															})
															tmp152 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4460), kw_column, int(93), kw_end_DASH_line, int(4460), kw_end_DASH_column, int(135))
															tmp153, err := lang.WithMeta(tmp151, tmp152.(lang.IPersistentMap))
															if err != nil {
																panic(err)
															}
															tmp154 := lang.Apply(tmp150, []any{v135, v136, tmp153})
															tmp147 = tmp154
														} else {
															var tmp155 any
															tmp156 := checkDerefVar(var_glojure_DOT_core__EQ_)
															tmp157 := lang.Apply(tmp156, []any{v146, "syms"})
															if lang.IsTruthy(tmp157) {
																tmp158 := checkDerefVar(var_glojure_DOT_core_assoc)
																var tmp159 lang.FnFunc
																tmp159 = lang.NewFnFunc(func(args ...any) any {
																	checkArity(args, 1)
																	v160 := args[0]
																	_ = v160
																	tmp161 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp162 := checkDerefVar(var_glojure_DOT_core_symbol)
																	var tmp163 any
																	{ // let
																		// let binding "or__0__auto__"
																		var v164 any = v143
																		_ = v164
																		var tmp165 any
																		if lang.IsTruthy(v164) {
																			tmp165 = v164
																		} else {
																			tmp166 := checkDerefVar(var_glojure_DOT_core_namespace)
																			tmp167 := lang.Apply(tmp166, []any{v160})
																			tmp165 = tmp167
																		}
																		tmp163 = tmp165
																	} // end let
																	tmp164 := checkDerefVar(var_glojure_DOT_core_name)
																	tmp165 := lang.Apply(tmp164, []any{v160})
																	tmp166 := lang.Apply(tmp162, []any{tmp163, tmp165})
																	tmp167 := lang.Apply(tmp161, []any{sym_quote, tmp166})
																	return tmp167
																})
																tmp160 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4461), kw_column, int(93), kw_end_DASH_line, int(4461), kw_end_DASH_column, int(148))
																tmp161, err := lang.WithMeta(tmp159, tmp160.(lang.IPersistentMap))
																if err != nil {
																	panic(err)
																}
																tmp162 := lang.Apply(tmp158, []any{v135, v136, tmp161})
																tmp155 = tmp162
															} else {
																var tmp163 any
																tmp164 := checkDerefVar(var_glojure_DOT_core__EQ_)
																tmp165 := lang.Apply(tmp164, []any{v146, "strs"})
																if lang.IsTruthy(tmp165) {
																	tmp166 := checkDerefVar(var_glojure_DOT_core_assoc)
																	tmp167 := checkDerefVar(var_glojure_DOT_core_str)
																	tmp168 := lang.Apply(tmp166, []any{v135, v136, tmp167})
																	tmp163 = tmp168
																} else {
																	var tmp169 any
																	if lang.IsTruthy(kw_else) {
																		tmp169 = v135
																	} else {
																	}
																	tmp163 = tmp169
																}
																tmp155 = tmp163
															}
															tmp147 = tmp155
														}
														tmp140 = tmp147
													} // end let
													tmp137 = tmp140
												} else {
													tmp137 = v135
												}
												return tmp137
											})
											tmp135 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4456), kw_column, int(45), kw_end_DASH_line, int(4464), kw_end_DASH_column, int(60))
											tmp136, err := lang.WithMeta(tmp134, tmp135.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp137 := lang.NewMap()
											tmp138 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4465), kw_column, int(45), kw_end_DASH_line, int(4465), kw_end_DASH_column, int(46))
											tmp139, err := lang.WithMeta(tmp137, tmp138.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp140 := checkDerefVar(var_glojure_DOT_core_keys)
											tmp141 := lang.Apply(tmp140, []any{v20})
											tmp142 := lang.Apply(tmp133, []any{tmp136, tmp139, tmp141})
											var v143 any = tmp142
											_ = v143
											tmp144 := checkDerefVar(var_glojure_DOT_core_reduce1)
											var tmp145 lang.FnFunc
											tmp145 = lang.NewFnFunc(func(args ...any) any {
												checkArity(args, 2)
												v146 := args[0]
												_ = v146
												v147 := args[1]
												_ = v147
												tmp148 := checkDerefVar(var_glojure_DOT_core_reduce1)
												var tmp149 lang.FnFunc
												tmp149 = lang.NewFnFunc(func(args ...any) any {
													checkArity(args, 2)
													v150 := args[0]
													_ = v150
													v151 := args[1]
													_ = v151
													tmp152 := checkDerefVar(var_glojure_DOT_core_assoc)
													tmp153 := checkDerefVar(var_glojure_DOT_core_val)
													tmp154 := lang.Apply(tmp153, []any{v147})
													tmp155 := lang.Apply(tmp154, []any{v151})
													tmp156 := lang.Apply(tmp152, []any{v150, v151, tmp155})
													return tmp156
												})
												tmp150 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4469), kw_column, int(52), kw_end_DASH_line, int(4469), kw_end_DASH_column, int(82))
												tmp151, err := lang.WithMeta(tmp149, tmp150.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp152 := checkDerefVar(var_glojure_DOT_core_dissoc)
												tmp153 := checkDerefVar(var_glojure_DOT_core_key)
												tmp154 := lang.Apply(tmp153, []any{v147})
												tmp155 := lang.Apply(tmp152, []any{v146, tmp154})
												tmp156 := checkDerefVar(var_glojure_DOT_core_key)
												tmp157 := lang.Apply(tmp156, []any{v147})
												tmp158 := lang.Apply(tmp157, []any{v146})
												tmp159 := lang.Apply(tmp148, []any{tmp151, tmp155, tmp158})
												return tmp159
											})
											tmp146 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4468), kw_column, int(41), kw_end_DASH_line, int(4471), kw_end_DASH_column, int(70))
											tmp147, err := lang.WithMeta(tmp145, tmp146.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp148 := checkDerefVar(var_glojure_DOT_core_dissoc)
											tmp149 := lang.Apply(tmp148, []any{v20, kw_as, kw_or})
											tmp150 := lang.Apply(tmp144, []any{tmp147, tmp149, v143})
											tmp132 = tmp150
										} // end let
										var v133 any = tmp132
										_ = v133
										for {
											var tmp134 any
											tmp135 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp136 := lang.Apply(tmp135, []any{v133})
											if lang.IsTruthy(tmp136) {
												var tmp137 any
												{ // let
													// let binding "bb"
													tmp138 := checkDerefVar(var_glojure_DOT_core_key)
													tmp139 := checkDerefVar(var_glojure_DOT_core_first)
													tmp140 := lang.Apply(tmp139, []any{v133})
													tmp141 := lang.Apply(tmp138, []any{tmp140})
													var v142 any = tmp141
													_ = v142
													// let binding "bk"
													tmp143 := checkDerefVar(var_glojure_DOT_core_val)
													tmp144 := checkDerefVar(var_glojure_DOT_core_first)
													tmp145 := lang.Apply(tmp144, []any{v133})
													tmp146 := lang.Apply(tmp143, []any{tmp145})
													var v147 any = tmp146
													_ = v147
													// let binding "local"
													var tmp148 any
													tmp149 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
													tmp150 := reflect.TypeOf((*lang.Named)(nil)).Elem()
													tmp151 := lang.Apply(tmp149, []any{tmp150, v142})
													if lang.IsTruthy(tmp151) {
														tmp152 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
														tmp153 := checkDerefVar(var_glojure_DOT_core_symbol)
														tmp154 := checkDerefVar(var_glojure_DOT_core_name)
														tmp155 := lang.Apply(tmp154, []any{v142})
														tmp156 := lang.Apply(tmp153, []any{nil, tmp155})
														tmp157 := checkDerefVar(var_glojure_DOT_core_meta)
														tmp158 := lang.Apply(tmp157, []any{v142})
														tmp159 := lang.Apply(tmp152, []any{tmp156, tmp158})
														tmp148 = tmp159
													} else {
														tmp148 = v142
													}
													var v160 any = tmp148
													_ = v160
													// let binding "bv"
													var tmp161 any
													tmp162 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
													tmp163 := lang.Apply(tmp162, []any{v33, v160})
													if lang.IsTruthy(tmp163) {
														tmp164 := checkDerefVar(var_glojure_DOT_core_list)
														tmp165 := lang.Apply(v33, []any{v160})
														tmp166 := lang.Apply(tmp164, []any{sym_glojure_DOT_core_SLASH_get, v25, v147, tmp165})
														tmp161 = tmp166
													} else {
														tmp167 := checkDerefVar(var_glojure_DOT_core_list)
														tmp168 := lang.Apply(tmp167, []any{sym_glojure_DOT_core_SLASH_get, v25, v147})
														tmp161 = tmp168
													}
													var v169 any = tmp161
													_ = v169
													var tmp171 any
													tmp172 := checkDerefVar(var_glojure_DOT_core_ident_QMARK_)
													tmp173 := lang.Apply(tmp172, []any{v142})
													if lang.IsTruthy(tmp173) {
														tmp174 := checkDerefVar(var_glojure_DOT_core_conj)
														tmp175 := lang.Apply(tmp174, []any{v131, v160, v169})
														tmp171 = tmp175
													} else {
														tmp176 := lang.Apply(v9, []any{v131, v142, v169})
														tmp171 = tmp176
													}
													var tmp170 any = tmp171
													tmp178 := checkDerefVar(var_glojure_DOT_core_next)
													tmp179 := lang.Apply(tmp178, []any{v133})
													var tmp177 any = tmp179
													v131 = tmp170
													v133 = tmp177
													continue
												} // end let
												tmp134 = tmp137
											} else {
												tmp134 = v131
											}
											tmp34 = tmp134
											break
										}
									} // end let
									tmp22 = tmp34
								} // end let
								return tmp22
							})
							tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4440), kw_column, int(20), kw_end_DASH_line, int(4485), kw_end_DASH_column, int(34))
							tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v21 any = tmp20
							_ = v21
							var tmp22 any
							tmp23 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
							tmp24 := lang.Apply(tmp23, []any{v11})
							if lang.IsTruthy(tmp24) {
								tmp25 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp26 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp27 := lang.Apply(tmp26, []any{v10, v11})
								tmp28 := lang.Apply(tmp25, []any{tmp27, v12})
								tmp22 = tmp28
							} else {
								var tmp29 any
								tmp30 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
								tmp31 := lang.Apply(tmp30, []any{v11})
								if lang.IsTruthy(tmp31) {
									tmp32 := lang.Apply(v17, []any{v10, v11, v12})
									tmp29 = tmp32
								} else {
									var tmp33 any
									tmp34 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
									tmp35 := lang.Apply(tmp34, []any{v11})
									if lang.IsTruthy(tmp35) {
										tmp36 := lang.Apply(v21, []any{v10, v11, v12})
										tmp33 = tmp36
									} else {
										var tmp37 any
										if lang.IsTruthy(kw_else) {
											tmp38 := checkDerefVar(var_glojure_DOT_core_str)
											tmp39 := lang.Apply(tmp38, []any{"Unsupported binding form: ", v11})
											tmp40 := lang.Apply(errors8.New, []any{tmp39})
											panic(tmp40)
										} else {
										}
										tmp33 = tmp37
									}
									tmp29 = tmp33
								}
								tmp22 = tmp29
							}
							tmp13 = tmp22
						} // end let
						return tmp13
					})
					v9 = tmp8
					_ = v9
				}
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4402), kw_column, int(12), kw_end_DASH_line, int(4490), kw_end_DASH_column, int(82))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v11 any = tmp10
				_ = v11
				// let binding "process-entry"
				var tmp12 lang.FnFunc
				tmp12 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v13 := args[0]
					_ = v13
					v14 := args[1]
					_ = v14
					tmp15 := checkDerefVar(var_glojure_DOT_core_first)
					tmp16 := lang.Apply(tmp15, []any{v14})
					tmp17 := checkDerefVar(var_glojure_DOT_core_second)
					tmp18 := lang.Apply(tmp17, []any{v14})
					tmp19 := lang.Apply(v11, []any{v13, tmp16, tmp18})
					return tmp19
				})
				tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4491), kw_column, int(23), kw_end_DASH_line, int(4491), kw_end_DASH_column, int(66))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v15 any = tmp14
				_ = v15
				var tmp16 any
				tmp17 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
				tmp18 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
				tmp19 := checkDerefVar(var_glojure_DOT_core_map)
				tmp20 := checkDerefVar(var_glojure_DOT_core_first)
				tmp21 := lang.Apply(tmp19, []any{tmp20, v7})
				tmp22 := lang.Apply(tmp17, []any{tmp18, tmp21})
				if lang.IsTruthy(tmp22) {
					tmp16 = v3
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_reduce1)
					tmp24 := lang.NewVector()
					tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4494), kw_column, int(30), kw_end_DASH_line, int(4494), kw_end_DASH_column, int(31))
					tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp27 := lang.Apply(tmp23, []any{v15, tmp26, v7})
					tmp16 = tmp27
				}
				tmp4 = tmp16
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// disj
	{
		tmp0 := sym_disj.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_set), lang.NewVector(sym_set, sym_key), lang.NewVector(sym_set, sym_key, sym__AMP_, sym_ks)), kw_doc, "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1514), kw_end_DASH_line, int(1514))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				if lang.IsTruthy(v3) {
					tmp6, _ := lang.FieldOrMethod(v3, "Disjoin")
					if reflect.TypeOf(tmp6).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
					}
					tmp7 := lang.Apply(tmp6, []any{v4})
					tmp5 = tmp7
				} else {
				}
				return tmp5
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_304:
				var tmp6 any
				if lang.IsTruthy(v3) {
					var tmp7 any
					{ // let
						// let binding "ret"
						tmp8 := checkDerefVar(var_glojure_DOT_core_disj)
						tmp9 := lang.Apply(tmp8, []any{v3, v4})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v5) {
							var tmp12 any = v10
							tmp14 := checkDerefVar(var_glojure_DOT_core_first)
							tmp15 := lang.Apply(tmp14, []any{v5})
							var tmp13 any = tmp15
							tmp17 := checkDerefVar(var_glojure_DOT_core_next)
							tmp18 := lang.Apply(tmp17, []any{v5})
							var tmp16 any = tmp18
							v3 = tmp12
							v4 = tmp13
							v5 = tmp16
							goto recur_loop_304
						} else {
							tmp11 = v10
						}
						tmp7 = tmp11
					} // end let
					tmp6 = tmp7
				} else {
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// disj!
	{
		tmp0 := sym_disj_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_set), lang.NewVector(sym_set, sym_key), lang.NewVector(sym_set, sym_key, sym__AMP_, sym_ks)), kw_doc, "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3401), kw_end_DASH_line, int(3401))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "Disjoin")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_615:
				var tmp6 any
				{ // let
					// let binding "ret"
					tmp7, _ := lang.FieldOrMethod(v3, "Disjoin")
					if reflect.TypeOf(tmp7).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
					}
					tmp8 := lang.Apply(tmp7, []any{v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v5) {
						var tmp11 any = v9
						tmp13 := checkDerefVar(var_glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v5})
						var tmp12 any = tmp14
						tmp16 := checkDerefVar(var_glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v5})
						var tmp15 any = tmp17
						v3 = tmp11
						v4 = tmp12
						v5 = tmp15
						goto recur_loop_615
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dissoc
	{
		tmp0 := sym_dissoc.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map), lang.NewVector(sym_map, sym_key), lang.NewVector(sym_map, sym_key, sym__AMP_, sym_ks)), kw_doc, "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(1500), kw_end_DASH_line, int(1500))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(runtime.RT, "Dissoc")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Dissoc is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_301:
				var tmp6 any
				{ // let
					// let binding "ret"
					tmp7 := checkDerefVar(var_glojure_DOT_core_dissoc)
					tmp8 := lang.Apply(tmp7, []any{v3, v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v5) {
						var tmp11 any = v9
						tmp13 := checkDerefVar(var_glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v5})
						var tmp12 any = tmp14
						tmp16 := checkDerefVar(var_glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v5})
						var tmp15 any = tmp17
						v3 = tmp11
						v4 = tmp12
						v5 = tmp15
						goto recur_loop_301
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dissoc!
	{
		tmp0 := sym_dissoc_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map, sym_key), lang.NewVector(sym_map, sym_key, sym__AMP_, sym_ks)), kw_doc, "Returns a transient map that doesn't contain a mapping for key(s).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3382), kw_end_DASH_line, int(3382))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "without")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("without is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_611:
				var tmp6 any
				{ // let
					// let binding "ret"
					tmp7, _ := lang.FieldOrMethod(v3, "without")
					if reflect.TypeOf(tmp7).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("without is not a function")))
					}
					tmp8 := lang.Apply(tmp7, []any{v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v5) {
						var tmp11 any = v9
						tmp13 := checkDerefVar(var_glojure_DOT_core_first)
						tmp14 := lang.Apply(tmp13, []any{v5})
						var tmp12 any = tmp14
						tmp16 := checkDerefVar(var_glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v5})
						var tmp15 any = tmp17
						v3 = tmp11
						v4 = tmp12
						v5 = tmp15
						goto recur_loop_611
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// distinct
	{
		tmp0 := sym_distinct.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_coll)), kw_doc, "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(5053), kw_end_DASH_line, int(5053))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "seen"
						tmp6 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp7 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
						tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5060), kw_column, int(28), kw_end_DASH_line, int(5060), kw_end_DASH_column, int(30))
						tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp10 := lang.Apply(tmp6, []any{tmp9})
						var v11 any = tmp10
						_ = v11
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp13 := lang.Apply(v4, nil)
								return tmp13
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := lang.Apply(v4, []any{v13})
								return tmp14
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								var tmp15 any
								tmp16 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
								tmp17 := checkDerefVar(var_glojure_DOT_core_deref)
								tmp18 := lang.Apply(tmp17, []any{v11})
								tmp19 := lang.Apply(tmp16, []any{tmp18, v14})
								if lang.IsTruthy(tmp19) {
									tmp15 = v13
								} else {
									tmp20 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp21, ok := lang.FieldOrMethod(v11, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Deref")))
									}
									var tmp22 any
									switch reflect.TypeOf(tmp21).Kind() {
									case reflect.Func:
										tmp22 = lang.Apply(tmp21, nil)
									default:
										tmp22 = tmp21
									}
									tmp23 := lang.Apply(tmp20, []any{tmp22, v14})
									tmp24, _ := lang.FieldOrMethod(v11, "reset")
									if reflect.TypeOf(tmp24).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp25 := lang.Apply(tmp24, []any{tmp23})
									_ = tmp25
									tmp26 := lang.Apply(v4, []any{v13, v14})
									tmp15 = tmp26
								}
								return tmp15
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5061), kw_column, int(8), kw_end_DASH_line, int(5068), kw_end_DASH_column, int(37))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp14
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5059), kw_column, int(4), kw_end_DASH_line, int(5068), kw_end_DASH_column, int(39))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "step"
					var tmp5 lang.FnFunc
					{ // function step
						var v6 lang.FnFunc
						tmp5 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 lang.FnFunc
							tmp9 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								var tmp10 lang.FnFunc
								tmp10 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 2)
									v11 := args[0]
									_ = v11
									v12 := args[1]
									_ = v12
								recur_loop_877:
									var tmp13 any
									{ // let
										// let binding "vec__62"
										var v14 any = v11
										_ = v14
										// let binding "f"
										tmp15 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
										var v17 any = tmp16
										_ = v17
										// let binding "xs"
										var v18 any = v14
										_ = v18
										var tmp19 any
										{ // let
											// let binding "temp__0__auto__"
											tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp21 := lang.Apply(tmp20, []any{v18})
											var v22 any = tmp21
											_ = v22
											var tmp23 any
											if lang.IsTruthy(v22) {
												var tmp24 any
												{ // let
													// let binding "s"
													var v25 any = v22
													_ = v25
													var tmp26 any
													tmp27 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
													tmp28 := lang.Apply(tmp27, []any{v12, v17})
													if lang.IsTruthy(tmp28) {
														tmp30 := checkDerefVar(var_glojure_DOT_core_rest)
														tmp31 := lang.Apply(tmp30, []any{v25})
														var tmp29 any = tmp31
														var tmp32 any = v12
														v11 = tmp29
														v12 = tmp32
														goto recur_loop_877
													} else {
														tmp33 := checkDerefVar(var_glojure_DOT_core_cons)
														tmp34 := checkDerefVar(var_glojure_DOT_core_rest)
														tmp35 := lang.Apply(tmp34, []any{v25})
														tmp36 := checkDerefVar(var_glojure_DOT_core_conj)
														tmp37 := lang.Apply(tmp36, []any{v12, v17})
														tmp38 := lang.Apply(v6, []any{tmp35, tmp37})
														tmp39 := lang.Apply(tmp33, []any{v17, tmp38})
														tmp26 = tmp39
													}
													tmp24 = tmp26
												} // end let
												tmp23 = tmp24
											} else {
											}
											tmp19 = tmp23
										} // end let
										tmp13 = tmp19
									} // end let
									return tmp13
								})
								tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5072), kw_column, int(20), kw_end_DASH_line, int(5076), kw_end_DASH_column, int(66))
								tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp13 := lang.Apply(tmp12, []any{v7, v8})
								return tmp13
							})
							tmp10 := lang.Apply(lang.NewLazySeq, []any{tmp9})
							return tmp10
						})
						v6 = tmp5
						_ = v6
					}
					tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5070), kw_column, int(15), kw_end_DASH_line, int(5077), kw_end_DASH_column, int(29))
					tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v8 any = tmp7
					_ = v8
					tmp9 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5078), kw_column, int(17), kw_end_DASH_line, int(5078), kw_end_DASH_column, int(19))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 := lang.Apply(v8, []any{v3, tmp11})
					tmp4 = tmp12
				} // end let
				return tmp4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// distinct?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_distinct_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_doc, "Returns true if no two of the arguments are =", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(5664), kw_end_DASH_line, int(5664))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_not)
				tmp7 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp8 := lang.Apply(tmp7, []any{v4, v5})
				tmp9 := lang.Apply(tmp6, []any{tmp8})
				return tmp9
			default:
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					{ // let
						// let binding "s"
						tmp11 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{v4, v5}))
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5673), kw_column, int(15), kw_end_DASH_line, int(5673), kw_end_DASH_column, int(20))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v14 any = tmp13
						_ = v14
						// let binding "G__99"
						var v15 any = v6
						_ = v15
						// let binding "vec__100"
						var v16 any = v15
						_ = v16
						// let binding "seq__101"
						tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp18 := lang.Apply(tmp17, []any{v16})
						var v19 any = tmp18
						_ = v19
						// let binding "first__102"
						tmp20 := checkDerefVar(var_glojure_DOT_core_first)
						tmp21 := lang.Apply(tmp20, []any{v19})
						var v22 any = tmp21
						_ = v22
						// let binding "seq__101"
						tmp23 := checkDerefVar(var_glojure_DOT_core_next)
						tmp24 := lang.Apply(tmp23, []any{v19})
						var v25 any = tmp24
						_ = v25
						// let binding "x"
						var v26 any = v22
						_ = v26
						// let binding "etc"
						var v27 any = v25
						_ = v27
						// let binding "xs"
						var v28 any = v16
						_ = v28
						var tmp29 any
						{ // let
							// let binding "s"
							var v30 any = v14
							_ = v30
							// let binding "G__99"
							var v31 any = v15
							_ = v31
							for {
								var tmp32 any
								{ // let
									// let binding "s"
									var v33 any = v30
									_ = v33
									// let binding "vec__103"
									var v34 any = v31
									_ = v34
									// let binding "seq__104"
									tmp35 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp36 := lang.Apply(tmp35, []any{v34})
									var v37 any = tmp36
									_ = v37
									// let binding "first__105"
									tmp38 := checkDerefVar(var_glojure_DOT_core_first)
									tmp39 := lang.Apply(tmp38, []any{v37})
									var v40 any = tmp39
									_ = v40
									// let binding "seq__104"
									tmp41 := checkDerefVar(var_glojure_DOT_core_next)
									tmp42 := lang.Apply(tmp41, []any{v37})
									var v43 any = tmp42
									_ = v43
									// let binding "x"
									var v44 any = v40
									_ = v44
									// let binding "etc"
									var v45 any = v43
									_ = v45
									// let binding "xs"
									var v46 any = v34
									_ = v46
									var tmp47 any
									if lang.IsTruthy(v46) {
										var tmp48 any
										tmp49 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
										tmp50 := lang.Apply(tmp49, []any{v33, v44})
										if lang.IsTruthy(tmp50) {
											tmp48 = false
										} else {
											tmp52 := checkDerefVar(var_glojure_DOT_core_conj)
											tmp53 := lang.Apply(tmp52, []any{v33, v44})
											var tmp51 any = tmp53
											var tmp54 any = v45
											v30 = tmp51
											v31 = tmp54
											continue
										}
										tmp47 = tmp48
									} else {
										tmp47 = true
									}
									tmp32 = tmp47
								} // end let
								tmp29 = tmp32
								break
							}
						} // end let
						tmp10 = tmp29
					} // end let
					tmp7 = tmp10
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doall
	{
		tmp0 := sym_doall.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll), lang.NewVector(sym_n, sym_coll)), kw_doc, "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3131), kw_end_DASH_line, int(3131))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_dorun)
				tmp5 := lang.Apply(tmp4, []any{v3})
				_ = tmp5
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_dorun)
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				_ = tmp6
				return v4
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dorun
	{
		tmp0 := sym_dorun.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll), lang.NewVector(sym_n, sym_coll)), kw_doc, "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3116), kw_end_DASH_line, int(3116))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
			recur_loop_579:
				var tmp4 any
				{ // let
					// let binding "temp__0__auto__"
					tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp6 := lang.Apply(tmp5, []any{v3})
					var v7 any = tmp6
					_ = v7
					var tmp8 any
					if lang.IsTruthy(v7) {
						var tmp9 any
						{ // let
							// let binding "s"
							var v10 any = v7
							_ = v10
							tmp12 := checkDerefVar(var_glojure_DOT_core_next)
							tmp13 := lang.Apply(tmp12, []any{v10})
							var tmp11 any = tmp13
							v3 = tmp11
							goto recur_loop_579
						} // end let
						tmp8 = tmp9
					} else {
					}
					tmp4 = tmp8
				} // end let
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
			recur_loop_580:
				var tmp5 any
				var tmp6 any
				{ // let
					// let binding "and__0__auto__"
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := lang.Apply(tmp7, []any{v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp11 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v3})
						tmp10 = tmp12
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				if lang.IsTruthy(tmp6) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_dec)
					tmp9 := lang.Apply(tmp8, []any{v3})
					var tmp7 any = tmp9
					tmp11 := checkDerefVar(var_glojure_DOT_core_next)
					tmp12 := lang.Apply(tmp11, []any{v4})
					var tmp10 any = tmp12
					v3 = tmp7
					v4 = tmp10
					goto recur_loop_580
				} else {
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doseq
	{
		tmp0 := sym_doseq.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_seq_DASH_exprs, sym__AMP_, sym_body)), kw_doc, "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(3209), kw_end_DASH_line, int(3209))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_str)
					tmp11 := checkDerefVar(var_glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(kw_line, []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(var_glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "step"
					var tmp34 lang.FnFunc
					{ // function step
						var v35 lang.FnFunc
						tmp34 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v36 := args[0]
							_ = v36
							v37 := args[1]
							_ = v37
							var tmp38 any
							tmp39 := checkDerefVar(var_glojure_DOT_core_not)
							tmp40 := lang.Apply(tmp39, []any{v37})
							if lang.IsTruthy(tmp40) {
								tmp41 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp42 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp43 := checkDerefVar(var_glojure_DOT_core_list)
								tmp44 := lang.Apply(tmp43, []any{sym_do})
								tmp45 := lang.Apply(tmp42, []any{tmp44, v6})
								tmp46 := lang.Apply(tmp41, []any{tmp45})
								tmp47 := lang.NewVector(true, tmp46)
								tmp48 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3220), kw_column, int(18), kw_end_DASH_line, int(3220), kw_end_DASH_column, int(36))
								tmp49, err := lang.WithMeta(tmp47, tmp48.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp38 = tmp49
							} else {
								var tmp50 any
								{ // let
									// let binding "k"
									tmp51 := checkDerefVar(var_glojure_DOT_core_first)
									tmp52 := lang.Apply(tmp51, []any{v37})
									var v53 any = tmp52
									_ = v53
									// let binding "v"
									tmp54 := checkDerefVar(var_glojure_DOT_core_second)
									tmp55 := lang.Apply(tmp54, []any{v37})
									var v56 any = tmp55
									_ = v56
									var tmp57 any
									tmp58 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
									tmp59 := lang.Apply(tmp58, []any{v53})
									if lang.IsTruthy(tmp59) {
										var tmp60 any
										{ // let
											// let binding "steppair"
											tmp61 := checkDerefVar(var_glojure_DOT_core_nnext)
											tmp62 := lang.Apply(tmp61, []any{v37})
											tmp63 := lang.Apply(v35, []any{v36, tmp62})
											var v64 any = tmp63
											_ = v64
											// let binding "needrec"
											tmp65 := lang.Apply(v64, []any{int64(0)})
											var v66 any = tmp65
											_ = v66
											// let binding "subform"
											tmp67 := lang.Apply(v64, []any{int64(1)})
											var v68 any = tmp67
											_ = v68
											var tmp69 any
											tmp70 := checkDerefVar(var_glojure_DOT_core__EQ_)
											tmp71 := lang.Apply(tmp70, []any{v53, kw_let})
											if lang.IsTruthy(tmp71) {
												tmp72 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp73 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp74 := checkDerefVar(var_glojure_DOT_core_list)
												tmp75 := lang.Apply(tmp74, []any{sym_glojure_DOT_core_SLASH_let})
												tmp76 := checkDerefVar(var_glojure_DOT_core_list)
												tmp77 := lang.Apply(tmp76, []any{v56})
												tmp78 := checkDerefVar(var_glojure_DOT_core_list)
												tmp79 := lang.Apply(tmp78, []any{v68})
												tmp80 := lang.Apply(tmp73, []any{tmp75, tmp77, tmp79})
												tmp81 := lang.Apply(tmp72, []any{tmp80})
												tmp82 := lang.NewVector(v66, tmp81)
												tmp83 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3228), kw_column, int(37), kw_end_DASH_line, int(3228), kw_end_DASH_column, int(64))
												tmp84, err := lang.WithMeta(tmp82, tmp83.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp69 = tmp84
											} else {
												var tmp85 any
												tmp86 := checkDerefVar(var_glojure_DOT_core__EQ_)
												tmp87 := lang.Apply(tmp86, []any{v53, kw_while})
												if lang.IsTruthy(tmp87) {
													tmp88 := checkDerefVar(var_glojure_DOT_core_seq)
													tmp89 := checkDerefVar(var_glojure_DOT_core_concat)
													tmp90 := checkDerefVar(var_glojure_DOT_core_list)
													tmp91 := lang.Apply(tmp90, []any{sym_glojure_DOT_core_SLASH_when})
													tmp92 := checkDerefVar(var_glojure_DOT_core_list)
													tmp93 := lang.Apply(tmp92, []any{v56})
													tmp94 := checkDerefVar(var_glojure_DOT_core_list)
													tmp95 := lang.Apply(tmp94, []any{v68})
													var tmp96 any
													if lang.IsTruthy(v66) {
														tmp97 := lang.NewVector(v36)
														tmp98 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3231), kw_column, int(65), kw_end_DASH_line, int(3231), kw_end_DASH_column, int(73))
														tmp99, err := lang.WithMeta(tmp97, tmp98.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp96 = tmp99
													} else {
													}
													tmp100 := lang.Apply(tmp89, []any{tmp91, tmp93, tmp95, tmp96})
													tmp101 := lang.Apply(tmp88, []any{tmp100})
													tmp102 := lang.NewVector(false, tmp101)
													tmp103 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3229), kw_column, int(39), kw_end_DASH_line, int(3231), kw_end_DASH_column, int(76))
													tmp104, err := lang.WithMeta(tmp102, tmp103.(lang.IPersistentMap))
													if err != nil {
														panic(err)
													}
													tmp85 = tmp104
												} else {
													var tmp105 any
													tmp106 := checkDerefVar(var_glojure_DOT_core__EQ_)
													tmp107 := lang.Apply(tmp106, []any{v53, kw_when})
													if lang.IsTruthy(tmp107) {
														tmp108 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp109 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp110 := checkDerefVar(var_glojure_DOT_core_list)
														tmp111 := lang.Apply(tmp110, []any{sym_if})
														tmp112 := checkDerefVar(var_glojure_DOT_core_list)
														tmp113 := lang.Apply(tmp112, []any{v56})
														tmp114 := checkDerefVar(var_glojure_DOT_core_list)
														tmp115 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp116 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp117 := checkDerefVar(var_glojure_DOT_core_list)
														tmp118 := lang.Apply(tmp117, []any{sym_do})
														tmp119 := checkDerefVar(var_glojure_DOT_core_list)
														tmp120 := lang.Apply(tmp119, []any{v68})
														var tmp121 any
														if lang.IsTruthy(v66) {
															tmp122 := lang.NewVector(v36)
															tmp123 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3235), kw_column, int(66), kw_end_DASH_line, int(3235), kw_end_DASH_column, int(74))
															tmp124, err := lang.WithMeta(tmp122, tmp123.(lang.IPersistentMap))
															if err != nil {
																panic(err)
															}
															tmp121 = tmp124
														} else {
														}
														tmp125 := lang.Apply(tmp116, []any{tmp118, tmp120, tmp121})
														tmp126 := lang.Apply(tmp115, []any{tmp125})
														tmp127 := lang.Apply(tmp114, []any{tmp126})
														tmp128 := checkDerefVar(var_glojure_DOT_core_list)
														tmp129 := lang.Apply(tmp128, []any{v36})
														tmp130 := lang.Apply(tmp109, []any{tmp111, tmp113, tmp127, tmp129})
														tmp131 := lang.Apply(tmp108, []any{tmp130})
														tmp132 := lang.NewVector(false, tmp131)
														tmp133 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3232), kw_column, int(38), kw_end_DASH_line, int(3236), kw_end_DASH_column, int(57))
														tmp134, err := lang.WithMeta(tmp132, tmp133.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp105 = tmp134
													} else {
													}
													tmp85 = tmp105
												}
												tmp69 = tmp85
											}
											tmp60 = tmp69
										} // end let
										tmp57 = tmp60
									} else {
										var tmp61 any
										{ // let
											// let binding "seq-"
											tmp62 := checkDerefVar(var_glojure_DOT_core_gensym)
											tmp63 := lang.Apply(tmp62, []any{"seq_"})
											var v64 any = tmp63
											_ = v64
											// let binding "chunk-"
											tmp65 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
											tmp66 := checkDerefVar(var_glojure_DOT_core_gensym)
											tmp67 := lang.Apply(tmp66, []any{"chunk_"})
											tmp68 := lang.NewMap(kw_tag, sym_glojure_DOT_lang_DOT_IChunk)
											tmp69 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3239), kw_column, int(46), kw_end_DASH_line, int(3239), kw_end_DASH_column, int(72))
											tmp70, err := lang.WithMeta(tmp68, tmp69.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp71 := lang.Apply(tmp65, []any{tmp67, tmp70})
											var v72 any = tmp71
											_ = v72
											// let binding "count-"
											tmp73 := checkDerefVar(var_glojure_DOT_core_gensym)
											tmp74 := lang.Apply(tmp73, []any{"count_"})
											var v75 any = tmp74
											_ = v75
											// let binding "i-"
											tmp76 := checkDerefVar(var_glojure_DOT_core_gensym)
											tmp77 := lang.Apply(tmp76, []any{"i_"})
											var v78 any = tmp77
											_ = v78
											// let binding "recform"
											tmp79 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp80 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp81 := checkDerefVar(var_glojure_DOT_core_list)
											tmp82 := lang.Apply(tmp81, []any{sym_recur})
											tmp83 := checkDerefVar(var_glojure_DOT_core_list)
											tmp84 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp85 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp86 := checkDerefVar(var_glojure_DOT_core_list)
											tmp87 := lang.Apply(tmp86, []any{sym_glojure_DOT_core_SLASH_next})
											tmp88 := checkDerefVar(var_glojure_DOT_core_list)
											tmp89 := lang.Apply(tmp88, []any{v64})
											tmp90 := lang.Apply(tmp85, []any{tmp87, tmp89})
											tmp91 := lang.Apply(tmp84, []any{tmp90})
											tmp92 := lang.Apply(tmp83, []any{tmp91})
											tmp93 := checkDerefVar(var_glojure_DOT_core_list)
											tmp94 := lang.Apply(tmp93, []any{nil})
											tmp95 := checkDerefVar(var_glojure_DOT_core_list)
											tmp96 := lang.Apply(tmp95, []any{int64(0)})
											tmp97 := checkDerefVar(var_glojure_DOT_core_list)
											tmp98 := lang.Apply(tmp97, []any{int64(0)})
											tmp99 := lang.Apply(tmp80, []any{tmp82, tmp92, tmp94, tmp96, tmp98})
											tmp100 := lang.Apply(tmp79, []any{tmp99})
											var v101 any = tmp100
											_ = v101
											// let binding "steppair"
											tmp102 := checkDerefVar(var_glojure_DOT_core_nnext)
											tmp103 := lang.Apply(tmp102, []any{v37})
											tmp104 := lang.Apply(v35, []any{v101, tmp103})
											var v105 any = tmp104
											_ = v105
											// let binding "needrec"
											tmp106 := lang.Apply(v105, []any{int64(0)})
											var v107 any = tmp106
											_ = v107
											// let binding "subform"
											tmp108 := lang.Apply(v105, []any{int64(1)})
											var v109 any = tmp108
											_ = v109
											// let binding "recform-chunk"
											tmp110 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp111 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp112 := checkDerefVar(var_glojure_DOT_core_list)
											tmp113 := lang.Apply(tmp112, []any{sym_recur})
											tmp114 := checkDerefVar(var_glojure_DOT_core_list)
											tmp115 := lang.Apply(tmp114, []any{v64})
											tmp116 := checkDerefVar(var_glojure_DOT_core_list)
											tmp117 := lang.Apply(tmp116, []any{v72})
											tmp118 := checkDerefVar(var_glojure_DOT_core_list)
											tmp119 := lang.Apply(tmp118, []any{v75})
											tmp120 := checkDerefVar(var_glojure_DOT_core_list)
											tmp121 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp122 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp123 := checkDerefVar(var_glojure_DOT_core_list)
											tmp124 := lang.Apply(tmp123, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc})
											tmp125 := checkDerefVar(var_glojure_DOT_core_list)
											tmp126 := lang.Apply(tmp125, []any{v78})
											tmp127 := lang.Apply(tmp122, []any{tmp124, tmp126})
											tmp128 := lang.Apply(tmp121, []any{tmp127})
											tmp129 := lang.Apply(tmp120, []any{tmp128})
											tmp130 := lang.Apply(tmp111, []any{tmp113, tmp115, tmp117, tmp119, tmp129})
											tmp131 := lang.Apply(tmp110, []any{tmp130})
											var v132 any = tmp131
											_ = v132
											// let binding "steppair-chunk"
											tmp133 := checkDerefVar(var_glojure_DOT_core_nnext)
											tmp134 := lang.Apply(tmp133, []any{v37})
											tmp135 := lang.Apply(v35, []any{v132, tmp134})
											var v136 any = tmp135
											_ = v136
											// let binding "subform-chunk"
											tmp137 := lang.Apply(v136, []any{int64(1)})
											var v138 any = tmp137
											_ = v138
											tmp139 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp140 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp141 := checkDerefVar(var_glojure_DOT_core_list)
											tmp142 := lang.Apply(tmp141, []any{sym_glojure_DOT_core_SLASH_loop})
											tmp143 := checkDerefVar(var_glojure_DOT_core_list)
											tmp144 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp145 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp146 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp147 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp148 := checkDerefVar(var_glojure_DOT_core_list)
											tmp149 := lang.Apply(tmp148, []any{v64})
											tmp150 := checkDerefVar(var_glojure_DOT_core_list)
											tmp151 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp152 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp153 := checkDerefVar(var_glojure_DOT_core_list)
											tmp154 := lang.Apply(tmp153, []any{sym_glojure_DOT_core_SLASH_seq})
											tmp155 := checkDerefVar(var_glojure_DOT_core_list)
											tmp156 := lang.Apply(tmp155, []any{v56})
											tmp157 := lang.Apply(tmp152, []any{tmp154, tmp156})
											tmp158 := lang.Apply(tmp151, []any{tmp157})
											tmp159 := lang.Apply(tmp150, []any{tmp158})
											tmp160 := checkDerefVar(var_glojure_DOT_core_list)
											tmp161 := lang.Apply(tmp160, []any{v72})
											tmp162 := checkDerefVar(var_glojure_DOT_core_list)
											tmp163 := lang.Apply(tmp162, []any{nil})
											tmp164 := checkDerefVar(var_glojure_DOT_core_list)
											tmp165 := lang.Apply(tmp164, []any{v75})
											tmp166 := checkDerefVar(var_glojure_DOT_core_list)
											tmp167 := lang.Apply(tmp166, []any{int64(0)})
											tmp168 := checkDerefVar(var_glojure_DOT_core_list)
											tmp169 := lang.Apply(tmp168, []any{v78})
											tmp170 := checkDerefVar(var_glojure_DOT_core_list)
											tmp171 := lang.Apply(tmp170, []any{int64(0)})
											tmp172 := lang.Apply(tmp147, []any{tmp149, tmp159, tmp161, tmp163, tmp165, tmp167, tmp169, tmp171})
											tmp173 := lang.Apply(tmp146, []any{tmp172})
											tmp174 := lang.Apply(tmp144, []any{tmp145, tmp173})
											tmp175 := lang.Apply(tmp143, []any{tmp174})
											tmp176 := checkDerefVar(var_glojure_DOT_core_list)
											tmp177 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp178 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp179 := checkDerefVar(var_glojure_DOT_core_list)
											tmp180 := lang.Apply(tmp179, []any{sym_if})
											tmp181 := checkDerefVar(var_glojure_DOT_core_list)
											tmp182 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp183 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp184 := checkDerefVar(var_glojure_DOT_core_list)
											tmp185 := lang.Apply(tmp184, []any{sym_glojure_DOT_core_SLASH__LT_})
											tmp186 := checkDerefVar(var_glojure_DOT_core_list)
											tmp187 := lang.Apply(tmp186, []any{v78})
											tmp188 := checkDerefVar(var_glojure_DOT_core_list)
											tmp189 := lang.Apply(tmp188, []any{v75})
											tmp190 := lang.Apply(tmp183, []any{tmp185, tmp187, tmp189})
											tmp191 := lang.Apply(tmp182, []any{tmp190})
											tmp192 := lang.Apply(tmp181, []any{tmp191})
											tmp193 := checkDerefVar(var_glojure_DOT_core_list)
											tmp194 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp195 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp196 := checkDerefVar(var_glojure_DOT_core_list)
											tmp197 := lang.Apply(tmp196, []any{sym_glojure_DOT_core_SLASH_let})
											tmp198 := checkDerefVar(var_glojure_DOT_core_list)
											tmp199 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp200 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp201 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp202 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp203 := checkDerefVar(var_glojure_DOT_core_list)
											tmp204 := lang.Apply(tmp203, []any{v53})
											tmp205 := checkDerefVar(var_glojure_DOT_core_list)
											tmp206 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp207 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp208 := checkDerefVar(var_glojure_DOT_core_list)
											tmp209 := lang.Apply(tmp208, []any{sym__DOT_nth})
											tmp210 := checkDerefVar(var_glojure_DOT_core_list)
											tmp211 := lang.Apply(tmp210, []any{v72})
											tmp212 := checkDerefVar(var_glojure_DOT_core_list)
											tmp213 := lang.Apply(tmp212, []any{v78})
											tmp214 := lang.Apply(tmp207, []any{tmp209, tmp211, tmp213})
											tmp215 := lang.Apply(tmp206, []any{tmp214})
											tmp216 := lang.Apply(tmp205, []any{tmp215})
											tmp217 := lang.Apply(tmp202, []any{tmp204, tmp216})
											tmp218 := lang.Apply(tmp201, []any{tmp217})
											tmp219 := lang.Apply(tmp199, []any{tmp200, tmp218})
											tmp220 := lang.Apply(tmp198, []any{tmp219})
											tmp221 := checkDerefVar(var_glojure_DOT_core_list)
											tmp222 := lang.Apply(tmp221, []any{v138})
											var tmp223 any
											if lang.IsTruthy(v107) {
												tmp224 := lang.NewVector(v132)
												tmp225 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3256), kw_column, int(48), kw_end_DASH_line, int(3256), kw_end_DASH_column, int(62))
												tmp226, err := lang.WithMeta(tmp224, tmp225.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp223 = tmp226
											} else {
											}
											tmp227 := lang.Apply(tmp195, []any{tmp197, tmp220, tmp222, tmp223})
											tmp228 := lang.Apply(tmp194, []any{tmp227})
											tmp229 := lang.Apply(tmp193, []any{tmp228})
											tmp230 := checkDerefVar(var_glojure_DOT_core_list)
											tmp231 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp232 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp233 := checkDerefVar(var_glojure_DOT_core_list)
											tmp234 := lang.Apply(tmp233, []any{sym_glojure_DOT_core_SLASH_when_DASH_let})
											tmp235 := checkDerefVar(var_glojure_DOT_core_list)
											tmp236 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp237 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp238 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp239 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp240 := checkDerefVar(var_glojure_DOT_core_list)
											tmp241 := lang.Apply(tmp240, []any{v64})
											tmp242 := checkDerefVar(var_glojure_DOT_core_list)
											tmp243 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp244 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp245 := checkDerefVar(var_glojure_DOT_core_list)
											tmp246 := lang.Apply(tmp245, []any{sym_glojure_DOT_core_SLASH_seq})
											tmp247 := checkDerefVar(var_glojure_DOT_core_list)
											tmp248 := lang.Apply(tmp247, []any{v64})
											tmp249 := lang.Apply(tmp244, []any{tmp246, tmp248})
											tmp250 := lang.Apply(tmp243, []any{tmp249})
											tmp251 := lang.Apply(tmp242, []any{tmp250})
											tmp252 := lang.Apply(tmp239, []any{tmp241, tmp251})
											tmp253 := lang.Apply(tmp238, []any{tmp252})
											tmp254 := lang.Apply(tmp236, []any{tmp237, tmp253})
											tmp255 := lang.Apply(tmp235, []any{tmp254})
											tmp256 := checkDerefVar(var_glojure_DOT_core_list)
											tmp257 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp258 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp259 := checkDerefVar(var_glojure_DOT_core_list)
											tmp260 := lang.Apply(tmp259, []any{sym_if})
											tmp261 := checkDerefVar(var_glojure_DOT_core_list)
											tmp262 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp263 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp264 := checkDerefVar(var_glojure_DOT_core_list)
											tmp265 := lang.Apply(tmp264, []any{sym_glojure_DOT_core_SLASH_chunked_DASH_seq_QMARK_})
											tmp266 := checkDerefVar(var_glojure_DOT_core_list)
											tmp267 := lang.Apply(tmp266, []any{v64})
											tmp268 := lang.Apply(tmp263, []any{tmp265, tmp267})
											tmp269 := lang.Apply(tmp262, []any{tmp268})
											tmp270 := lang.Apply(tmp261, []any{tmp269})
											tmp271 := checkDerefVar(var_glojure_DOT_core_list)
											tmp272 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp273 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp274 := checkDerefVar(var_glojure_DOT_core_list)
											tmp275 := lang.Apply(tmp274, []any{sym_glojure_DOT_core_SLASH_let})
											tmp276 := checkDerefVar(var_glojure_DOT_core_list)
											tmp277 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp278 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp279 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp280 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp281 := checkDerefVar(var_glojure_DOT_core_list)
											tmp282 := lang.Apply(tmp281, []any{sym_c__0__auto__})
											tmp283 := checkDerefVar(var_glojure_DOT_core_list)
											tmp284 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp285 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp286 := checkDerefVar(var_glojure_DOT_core_list)
											tmp287 := lang.Apply(tmp286, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_first})
											tmp288 := checkDerefVar(var_glojure_DOT_core_list)
											tmp289 := lang.Apply(tmp288, []any{v64})
											tmp290 := lang.Apply(tmp285, []any{tmp287, tmp289})
											tmp291 := lang.Apply(tmp284, []any{tmp290})
											tmp292 := lang.Apply(tmp283, []any{tmp291})
											tmp293 := lang.Apply(tmp280, []any{tmp282, tmp292})
											tmp294 := lang.Apply(tmp279, []any{tmp293})
											tmp295 := lang.Apply(tmp277, []any{tmp278, tmp294})
											tmp296 := lang.Apply(tmp276, []any{tmp295})
											tmp297 := checkDerefVar(var_glojure_DOT_core_list)
											tmp298 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp299 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp300 := checkDerefVar(var_glojure_DOT_core_list)
											tmp301 := lang.Apply(tmp300, []any{sym_recur})
											tmp302 := checkDerefVar(var_glojure_DOT_core_list)
											tmp303 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp304 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp305 := checkDerefVar(var_glojure_DOT_core_list)
											tmp306 := lang.Apply(tmp305, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_rest})
											tmp307 := checkDerefVar(var_glojure_DOT_core_list)
											tmp308 := lang.Apply(tmp307, []any{v64})
											tmp309 := lang.Apply(tmp304, []any{tmp306, tmp308})
											tmp310 := lang.Apply(tmp303, []any{tmp309})
											tmp311 := lang.Apply(tmp302, []any{tmp310})
											tmp312 := checkDerefVar(var_glojure_DOT_core_list)
											tmp313 := lang.Apply(tmp312, []any{sym_c__0__auto__})
											tmp314 := checkDerefVar(var_glojure_DOT_core_list)
											tmp315 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp316 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp317 := checkDerefVar(var_glojure_DOT_core_list)
											tmp318 := lang.Apply(tmp317, []any{sym_glojure_DOT_core_SLASH_int})
											tmp319 := checkDerefVar(var_glojure_DOT_core_list)
											tmp320 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp321 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp322 := checkDerefVar(var_glojure_DOT_core_list)
											tmp323 := lang.Apply(tmp322, []any{sym_glojure_DOT_core_SLASH_count})
											tmp324 := checkDerefVar(var_glojure_DOT_core_list)
											tmp325 := lang.Apply(tmp324, []any{sym_c__0__auto__})
											tmp326 := lang.Apply(tmp321, []any{tmp323, tmp325})
											tmp327 := lang.Apply(tmp320, []any{tmp326})
											tmp328 := lang.Apply(tmp319, []any{tmp327})
											tmp329 := lang.Apply(tmp316, []any{tmp318, tmp328})
											tmp330 := lang.Apply(tmp315, []any{tmp329})
											tmp331 := lang.Apply(tmp314, []any{tmp330})
											tmp332 := checkDerefVar(var_glojure_DOT_core_list)
											tmp333 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp334 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp335 := checkDerefVar(var_glojure_DOT_core_list)
											tmp336 := lang.Apply(tmp335, []any{sym_glojure_DOT_core_SLASH_int})
											tmp337 := checkDerefVar(var_glojure_DOT_core_list)
											tmp338 := lang.Apply(tmp337, []any{int64(0)})
											tmp339 := lang.Apply(tmp334, []any{tmp336, tmp338})
											tmp340 := lang.Apply(tmp333, []any{tmp339})
											tmp341 := lang.Apply(tmp332, []any{tmp340})
											tmp342 := lang.Apply(tmp299, []any{tmp301, tmp311, tmp313, tmp331, tmp341})
											tmp343 := lang.Apply(tmp298, []any{tmp342})
											tmp344 := lang.Apply(tmp297, []any{tmp343})
											tmp345 := lang.Apply(tmp273, []any{tmp275, tmp296, tmp344})
											tmp346 := lang.Apply(tmp272, []any{tmp345})
											tmp347 := lang.Apply(tmp271, []any{tmp346})
											tmp348 := checkDerefVar(var_glojure_DOT_core_list)
											tmp349 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp350 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp351 := checkDerefVar(var_glojure_DOT_core_list)
											tmp352 := lang.Apply(tmp351, []any{sym_glojure_DOT_core_SLASH_let})
											tmp353 := checkDerefVar(var_glojure_DOT_core_list)
											tmp354 := checkDerefVar(var_glojure_DOT_core_apply)
											tmp355 := checkDerefVar(var_glojure_DOT_core_vector)
											tmp356 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp357 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp358 := checkDerefVar(var_glojure_DOT_core_list)
											tmp359 := lang.Apply(tmp358, []any{v53})
											tmp360 := checkDerefVar(var_glojure_DOT_core_list)
											tmp361 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp362 := checkDerefVar(var_glojure_DOT_core_concat)
											tmp363 := checkDerefVar(var_glojure_DOT_core_list)
											tmp364 := lang.Apply(tmp363, []any{sym_glojure_DOT_core_SLASH_first})
											tmp365 := checkDerefVar(var_glojure_DOT_core_list)
											tmp366 := lang.Apply(tmp365, []any{v64})
											tmp367 := lang.Apply(tmp362, []any{tmp364, tmp366})
											tmp368 := lang.Apply(tmp361, []any{tmp367})
											tmp369 := lang.Apply(tmp360, []any{tmp368})
											tmp370 := lang.Apply(tmp357, []any{tmp359, tmp369})
											tmp371 := lang.Apply(tmp356, []any{tmp370})
											tmp372 := lang.Apply(tmp354, []any{tmp355, tmp371})
											tmp373 := lang.Apply(tmp353, []any{tmp372})
											tmp374 := checkDerefVar(var_glojure_DOT_core_list)
											tmp375 := lang.Apply(tmp374, []any{v109})
											var tmp376 any
											if lang.IsTruthy(v107) {
												tmp377 := lang.NewVector(v101)
												tmp378 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3264), kw_column, int(52), kw_end_DASH_line, int(3264), kw_end_DASH_column, int(60))
												tmp379, err := lang.WithMeta(tmp377, tmp378.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp376 = tmp379
											} else {
											}
											tmp380 := lang.Apply(tmp350, []any{tmp352, tmp373, tmp375, tmp376})
											tmp381 := lang.Apply(tmp349, []any{tmp380})
											tmp382 := lang.Apply(tmp348, []any{tmp381})
											tmp383 := lang.Apply(tmp258, []any{tmp260, tmp270, tmp347, tmp382})
											tmp384 := lang.Apply(tmp257, []any{tmp383})
											tmp385 := lang.Apply(tmp256, []any{tmp384})
											tmp386 := lang.Apply(tmp232, []any{tmp234, tmp255, tmp385})
											tmp387 := lang.Apply(tmp231, []any{tmp386})
											tmp388 := lang.Apply(tmp230, []any{tmp387})
											tmp389 := lang.Apply(tmp178, []any{tmp180, tmp192, tmp229, tmp388})
											tmp390 := lang.Apply(tmp177, []any{tmp389})
											tmp391 := lang.Apply(tmp176, []any{tmp390})
											tmp392 := lang.Apply(tmp140, []any{tmp142, tmp175, tmp391})
											tmp393 := lang.Apply(tmp139, []any{tmp392})
											tmp394 := lang.NewVector(true, tmp393)
											tmp395 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3250), kw_column, int(24), kw_end_DASH_line, int(3264), kw_end_DASH_column, int(67))
											tmp396, err := lang.WithMeta(tmp394, tmp395.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp61 = tmp396
										} // end let
										tmp57 = tmp61
									}
									tmp50 = tmp57
								} // end let
								tmp38 = tmp50
							}
							return tmp38
						})
						v35 = tmp34
						_ = v35
					}
					tmp35 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3218), kw_column, int(14), kw_end_DASH_line, int(3264), kw_end_DASH_column, int(72))
					tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v37 any = tmp36
					_ = v37
					tmp38 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp39 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp40 := lang.Apply(tmp39, []any{v5})
					tmp41 := lang.Apply(v37, []any{nil, tmp40})
					tmp42 := lang.Apply(tmp38, []any{tmp41, int64(1)})
					tmp33 = tmp42
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dosync
	{
		tmp0 := sym_dosync.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_exprs)), kw_doc, "Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of dosync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(5100), kw_end_DASH_line, int(5100))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_sync})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{nil})
				tmp12 := lang.Apply(tmp7, []any{tmp9, tmp11, v5})
				tmp13 := lang.Apply(tmp6, []any{tmp12})
				return tmp13
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dotimes
	{
		tmp0 := sym_dotimes.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(3306), kw_end_DASH_line, int(3306))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_str)
					tmp11 := checkDerefVar(var_glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(kw_line, []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp21 := checkDerefVar(var_glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{int64(2), tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "exactly 2 forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "i"
					tmp34 := checkDerefVar(var_glojure_DOT_core_first)
					tmp35 := lang.Apply(tmp34, []any{v5})
					var v36 any = tmp35
					_ = v36
					// let binding "n"
					tmp37 := checkDerefVar(var_glojure_DOT_core_second)
					tmp38 := lang.Apply(tmp37, []any{v5})
					var v39 any = tmp38
					_ = v39
					tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp41 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					tmp43 := lang.Apply(tmp42, []any{sym_glojure_DOT_core_SLASH_let})
					tmp44 := checkDerefVar(var_glojure_DOT_core_list)
					tmp45 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp46 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp49 := checkDerefVar(var_glojure_DOT_core_list)
					tmp50 := lang.Apply(tmp49, []any{sym_n__0__auto__})
					tmp51 := checkDerefVar(var_glojure_DOT_core_list)
					tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp53 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp54 := checkDerefVar(var_glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{sym_glojure_DOT_core_SLASH_long})
					tmp56 := checkDerefVar(var_glojure_DOT_core_list)
					tmp57 := lang.Apply(tmp56, []any{v39})
					tmp58 := lang.Apply(tmp53, []any{tmp55, tmp57})
					tmp59 := lang.Apply(tmp52, []any{tmp58})
					tmp60 := lang.Apply(tmp51, []any{tmp59})
					tmp61 := lang.Apply(tmp48, []any{tmp50, tmp60})
					tmp62 := lang.Apply(tmp47, []any{tmp61})
					tmp63 := lang.Apply(tmp45, []any{tmp46, tmp62})
					tmp64 := lang.Apply(tmp44, []any{tmp63})
					tmp65 := checkDerefVar(var_glojure_DOT_core_list)
					tmp66 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp67 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp68 := checkDerefVar(var_glojure_DOT_core_list)
					tmp69 := lang.Apply(tmp68, []any{sym_glojure_DOT_core_SLASH_loop})
					tmp70 := checkDerefVar(var_glojure_DOT_core_list)
					tmp71 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp72 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp73 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp74 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp75 := checkDerefVar(var_glojure_DOT_core_list)
					tmp76 := lang.Apply(tmp75, []any{v36})
					tmp77 := checkDerefVar(var_glojure_DOT_core_list)
					tmp78 := lang.Apply(tmp77, []any{int64(0)})
					tmp79 := lang.Apply(tmp74, []any{tmp76, tmp78})
					tmp80 := lang.Apply(tmp73, []any{tmp79})
					tmp81 := lang.Apply(tmp71, []any{tmp72, tmp80})
					tmp82 := lang.Apply(tmp70, []any{tmp81})
					tmp83 := checkDerefVar(var_glojure_DOT_core_list)
					tmp84 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp85 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp86 := checkDerefVar(var_glojure_DOT_core_list)
					tmp87 := lang.Apply(tmp86, []any{sym_glojure_DOT_core_SLASH_when})
					tmp88 := checkDerefVar(var_glojure_DOT_core_list)
					tmp89 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp90 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp91 := checkDerefVar(var_glojure_DOT_core_list)
					tmp92 := lang.Apply(tmp91, []any{sym_glojure_DOT_core_SLASH__LT_})
					tmp93 := checkDerefVar(var_glojure_DOT_core_list)
					tmp94 := lang.Apply(tmp93, []any{v36})
					tmp95 := checkDerefVar(var_glojure_DOT_core_list)
					tmp96 := lang.Apply(tmp95, []any{sym_n__0__auto__})
					tmp97 := lang.Apply(tmp90, []any{tmp92, tmp94, tmp96})
					tmp98 := lang.Apply(tmp89, []any{tmp97})
					tmp99 := lang.Apply(tmp88, []any{tmp98})
					tmp100 := checkDerefVar(var_glojure_DOT_core_list)
					tmp101 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp102 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp103 := checkDerefVar(var_glojure_DOT_core_list)
					tmp104 := lang.Apply(tmp103, []any{sym_recur})
					tmp105 := checkDerefVar(var_glojure_DOT_core_list)
					tmp106 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp107 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp108 := checkDerefVar(var_glojure_DOT_core_list)
					tmp109 := lang.Apply(tmp108, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc})
					tmp110 := checkDerefVar(var_glojure_DOT_core_list)
					tmp111 := lang.Apply(tmp110, []any{v36})
					tmp112 := lang.Apply(tmp107, []any{tmp109, tmp111})
					tmp113 := lang.Apply(tmp106, []any{tmp112})
					tmp114 := lang.Apply(tmp105, []any{tmp113})
					tmp115 := lang.Apply(tmp102, []any{tmp104, tmp114})
					tmp116 := lang.Apply(tmp101, []any{tmp115})
					tmp117 := lang.Apply(tmp100, []any{tmp116})
					tmp118 := lang.Apply(tmp85, []any{tmp87, tmp99, v6, tmp117})
					tmp119 := lang.Apply(tmp84, []any{tmp118})
					tmp120 := lang.Apply(tmp83, []any{tmp119})
					tmp121 := lang.Apply(tmp67, []any{tmp69, tmp82, tmp120})
					tmp122 := lang.Apply(tmp66, []any{tmp121})
					tmp123 := lang.Apply(tmp65, []any{tmp122})
					tmp124 := lang.Apply(tmp41, []any{tmp43, tmp64, tmp123})
					tmp125 := lang.Apply(tmp40, []any{tmp124})
					tmp33 = tmp125
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doto
	{
		tmp0 := sym_doto.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_forms)), kw_doc, "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(3853), kw_end_DASH_line, int(3853))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "gx"
					tmp8 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, nil)
					var v10 any = tmp9
					_ = v10
					tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_let})
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp17 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := lang.Apply(tmp20, []any{v10})
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v5})
					tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
					tmp25 := lang.Apply(tmp18, []any{tmp24})
					tmp26 := lang.Apply(tmp16, []any{tmp17, tmp25})
					tmp27 := lang.Apply(tmp15, []any{tmp26})
					tmp28 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp29 lang.FnFunc
					tmp29 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v30 := args[0]
						_ = v30
						tmp31 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
						var tmp32 any
						tmp33 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp34 := lang.Apply(tmp33, []any{v30})
						if lang.IsTruthy(tmp34) {
							tmp35 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp36 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp37 := checkDerefVar(var_glojure_DOT_core_list)
							tmp38 := checkDerefVar(var_glojure_DOT_core_first)
							tmp39 := lang.Apply(tmp38, []any{v30})
							tmp40 := lang.Apply(tmp37, []any{tmp39})
							tmp41 := checkDerefVar(var_glojure_DOT_core_list)
							tmp42 := lang.Apply(tmp41, []any{v10})
							tmp43 := checkDerefVar(var_glojure_DOT_core_next)
							tmp44 := lang.Apply(tmp43, []any{v30})
							tmp45 := lang.Apply(tmp36, []any{tmp40, tmp42, tmp44})
							tmp46 := lang.Apply(tmp35, []any{tmp45})
							tmp32 = tmp46
						} else {
							tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp49 := checkDerefVar(var_glojure_DOT_core_list)
							tmp50 := lang.Apply(tmp49, []any{v30})
							tmp51 := checkDerefVar(var_glojure_DOT_core_list)
							tmp52 := lang.Apply(tmp51, []any{v10})
							tmp53 := lang.Apply(tmp48, []any{tmp50, tmp52})
							tmp54 := lang.Apply(tmp47, []any{tmp53})
							tmp32 = tmp54
						}
						tmp55 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp56 := lang.Apply(tmp55, []any{v30})
						tmp57 := lang.Apply(tmp31, []any{tmp32, tmp56})
						return tmp57
					})
					tmp30 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3863), kw_column, int(17), kw_end_DASH_line, int(3868), kw_end_DASH_column, int(30))
					tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp32 := lang.Apply(tmp28, []any{tmp31, v6})
					tmp33 := checkDerefVar(var_glojure_DOT_core_list)
					tmp34 := lang.Apply(tmp33, []any{v10})
					tmp35 := lang.Apply(tmp12, []any{tmp14, tmp27, tmp32, tmp34})
					tmp36 := lang.Apply(tmp11, []any{tmp35})
					tmp7 = tmp36
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double
	{
		var tmp1 lang.FnFunc
		{ // function double__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_DoubleCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_double.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to double", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3493), kw_end_DASH_line, int(3493))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.AsFloat64, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double-array
	{
		var tmp1 lang.FnFunc
		{ // function double-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_DoubleArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_double_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of doubles", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(5341), kw_end_DASH_line, int(5341))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "DoubleArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("DoubleArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "DoubleArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("DoubleArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double?
	{
		tmp0 := sym_double_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a Double", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1421), kw_end_DASH_line, int(1421))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{lang.Builtins["float64"], v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doubles
	{
		var tmp1 lang.FnFunc
		{ // function doubles
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_Doubles})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_doubles.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to double[]", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(12), kw_line, int(5402), kw_end_DASH_line, int(5402))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Doubles")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Doubles is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop
	{
		tmp0 := sym_drop.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n), lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a laziness-preserving sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2901), kw_end_DASH_line, int(2901))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "nv"
						tmp7 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{v3})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "n"
									tmp14 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp15 := lang.Apply(tmp14, []any{v9})
									var v16 any = tmp15
									_ = v16
									tmp17 := checkDerefVar(var_glojure_DOT_core_dec)
									tmp18, ok := lang.FieldOrMethod(v9, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Deref")))
									}
									var tmp19 any
									switch reflect.TypeOf(tmp18).Kind() {
									case reflect.Func:
										tmp19 = lang.Apply(tmp18, nil)
									default:
										tmp19 = tmp18
									}
									tmp20 := lang.Apply(tmp17, []any{tmp19})
									tmp21, _ := lang.FieldOrMethod(v9, "reset")
									if reflect.TypeOf(tmp21).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp22 := lang.Apply(tmp21, []any{tmp20})
									_ = tmp22
									var tmp23 any
									tmp24 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
									tmp25 := lang.Apply(tmp24, []any{v16})
									if lang.IsTruthy(tmp25) {
										tmp23 = v11
									} else {
										tmp26 := lang.Apply(v5, []any{v11, v12})
										tmp23 = tmp26
									}
									tmp13 = tmp23
								} // end let
								return tmp13
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2909), kw_column, int(10), kw_end_DASH_line, int(2917), kw_end_DASH_column, int(39))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2907), kw_column, int(6), kw_end_DASH_line, int(2917), kw_end_DASH_column, int(41))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					{ // let
						// let binding "or__0__auto__"
						var tmp10 any
						tmp11 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v3})
						if lang.IsTruthy(tmp12) {
							var tmp13 any
							tmp14 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
							tmp15 := lang.Apply(tmp14, []any{v3})
							if lang.IsTruthy(tmp15) {
								tmp13 = v3
							} else {
								tmp16 := lang.Apply(nil, []any{v3})
								tmp13 = tmp16
							}
							tmp17, _ := lang.FieldOrMethod(v4, "drop")
							if reflect.TypeOf(tmp17).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
							}
							tmp18 := lang.Apply(tmp17, []any{tmp13})
							tmp10 = tmp18
						} else {
							tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp20 := lang.Apply(tmp19, []any{v4})
							tmp10 = tmp20
						}
						var v21 any = tmp10
						_ = v21
						var tmp22 any
						if lang.IsTruthy(v21) {
							tmp22 = v21
						} else {
							tmp22 = lang.NewList()
						}
						tmp9 = tmp22
					} // end let
					tmp5 = tmp9
				} else {
					var tmp10 any
					{ // let
						// let binding "step"
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v12 := args[0]
							_ = v12
							v13 := args[1]
							_ = v13
						recur_loop_539:
							var tmp14 any
							{ // let
								// let binding "s"
								tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp16 := lang.Apply(tmp15, []any{v13})
								var v17 any = tmp16
								_ = v17
								var tmp18 any
								var tmp19 any
								{ // let
									// let binding "and__0__auto__"
									tmp20 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
									tmp21 := lang.Apply(tmp20, []any{v12})
									var v22 any = tmp21
									_ = v22
									var tmp23 any
									if lang.IsTruthy(v22) {
										tmp23 = v17
									} else {
										tmp23 = v22
									}
									tmp19 = tmp23
								} // end let
								if lang.IsTruthy(tmp19) {
									tmp21 := checkDerefVar(var_glojure_DOT_core_dec)
									tmp22 := lang.Apply(tmp21, []any{v12})
									var tmp20 any = tmp22
									tmp24 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp25 := lang.Apply(tmp24, []any{v17})
									var tmp23 any = tmp25
									v12 = tmp20
									v13 = tmp23
									goto recur_loop_539
								} else {
									tmp18 = v17
								}
								tmp14 = tmp18
							} // end let
							return tmp14
						})
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2925), kw_column, int(19), kw_end_DASH_line, int(2929), kw_end_DASH_column, int(28))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v14 any = tmp13
						_ = v14
						var tmp15 lang.FnFunc
						tmp15 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							tmp16 := lang.Apply(v14, []any{v3, v4})
							return tmp16
						})
						tmp16 := lang.Apply(lang.NewLazySeq, []any{tmp15})
						tmp10 = tmp16
					} // end let
					tmp5 = tmp10
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop-last
	{
		tmp0 := sym_drop_DASH_last.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll), lang.NewVector(sym_n, sym_coll)), kw_doc, "Return a lazy sequence of all but the last n (default 1) items in coll", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2932), kw_end_DASH_line, int(2932))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_drop_DASH_last)
				tmp5 := lang.Apply(tmp4, []any{int64(1), v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v7 := args[0]
					_ = v7
					v8 := args[1]
					_ = v8
					return v7
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2937), kw_column, int(18), kw_end_DASH_line, int(2937), kw_end_DASH_column, int(29))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := checkDerefVar(var_glojure_DOT_core_drop)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(tmp5, []any{tmp8, v4, tmp10})
				return tmp11
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop-while
	{
		tmp0 := sym_drop_DASH_while.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred), lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(2950), kw_end_DASH_line, int(2950))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "dv"
						tmp7 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{true})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "drop?"
									tmp14 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp15 := lang.Apply(tmp14, []any{v9})
									var v16 any = tmp15
									_ = v16
									var tmp17 any
									var tmp18 any
									{ // let
										// let binding "and__0__auto__"
										var v19 any = v16
										_ = v19
										var tmp20 any
										if lang.IsTruthy(v19) {
											tmp21 := lang.Apply(v3, []any{v12})
											tmp20 = tmp21
										} else {
											tmp20 = v19
										}
										tmp18 = tmp20
									} // end let
									if lang.IsTruthy(tmp18) {
										tmp17 = v11
									} else {
										tmp19 := checkDerefVar(var_glojure_DOT_core_vreset_BANG_)
										tmp20 := lang.Apply(tmp19, []any{v9, nil})
										_ = tmp20
										tmp21 := lang.Apply(v5, []any{v11, v12})
										tmp17 = tmp21
									}
									tmp13 = tmp17
								} // end let
								return tmp13
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2959), kw_column, int(10), kw_end_DASH_line, int(2968), kw_end_DASH_column, int(42))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2957), kw_column, int(6), kw_end_DASH_line, int(2968), kw_end_DASH_column, int(44))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "step"
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
					recur_loop_552:
						var tmp9 any
						{ // let
							// let binding "s"
							tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp11 := lang.Apply(tmp10, []any{v8})
							var v12 any = tmp11
							_ = v12
							var tmp13 any
							var tmp14 any
							{ // let
								// let binding "and__0__auto__"
								var v15 any = v12
								_ = v15
								var tmp16 any
								if lang.IsTruthy(v15) {
									tmp17 := checkDerefVar(var_glojure_DOT_core_first)
									tmp18 := lang.Apply(tmp17, []any{v12})
									tmp19 := lang.Apply(v7, []any{tmp18})
									tmp16 = tmp19
								} else {
									tmp16 = v15
								}
								tmp14 = tmp16
							} // end let
							if lang.IsTruthy(tmp14) {
								var tmp15 any = v7
								tmp17 := checkDerefVar(var_glojure_DOT_core_rest)
								tmp18 := lang.Apply(tmp17, []any{v12})
								var tmp16 any = tmp18
								v7 = tmp15
								v8 = tmp16
								goto recur_loop_552
							} else {
								tmp13 = v12
							}
							tmp9 = tmp13
						} // end let
						return tmp9
					})
					tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2970), kw_column, int(17), kw_end_DASH_line, int(2974), kw_end_DASH_column, int(26))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v9 any = tmp8
					_ = v9
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						tmp11 := lang.Apply(v9, []any{v3, v4})
						return tmp11
					})
					tmp11 := lang.Apply(lang.NewLazySeq, []any{tmp10})
					tmp5 = tmp11
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// elide-top-frames
	{
		tmp0 := sym_elide_DASH_top_DASH_frames.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(4794), kw_column, int(7), kw_end_DASH_line, int(4794), kw_end_DASH_column, int(32), kw_arglists, lang.NewList(lang.NewVector(sym_ex, sym_class_DASH_name)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "tr"
				tmp6, ok := lang.FieldOrMethod(v3, "getStackTrace")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getStackTrace")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				{ // let
					// let binding "G__54"
					var v10 any = v3
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v8) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_into_DASH_array)
						tmp13 := checkDerefVar(var_glojure_DOT_core_drop_DASH_while)
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v15 := args[0]
							_ = v15
							tmp16 := checkDerefVar(var_glojure_DOT_core__EQ_)
							tmp17, ok := lang.FieldOrMethod(v15, "getClassName")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v15, "getClassName")))
							}
							var tmp18 any
							switch reflect.TypeOf(tmp17).Kind() {
							case reflect.Func:
								tmp18 = lang.Apply(tmp17, nil)
							default:
								tmp18 = tmp17
							}
							tmp19 := lang.Apply(tmp16, []any{v4, tmp18})
							return tmp19
						})
						tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4801), kw_column, int(25), kw_end_DASH_line, int(4801), kw_end_DASH_column, int(77))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp17 := lang.Apply(tmp13, []any{tmp16, v8})
						tmp18 := lang.Apply(tmp12, []any{nil, tmp17})
						tmp11 = tmp18
					} else {
					}
					tmp19, _ := lang.FieldOrMethod(v10, "setStackTrace")
					if reflect.TypeOf(tmp19).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setStackTrace is not a function")))
					}
					tmp20 := lang.Apply(tmp19, []any{tmp11})
					_ = tmp20
					tmp9 = v10
				} // end let
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-extend-protocol
	{
		tmp0 := sym_emit_DASH_extend_DASH_protocol.WithMeta(lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(205), kw_column, int(8), kw_end_DASH_line, int(205), kw_end_DASH_column, int(27), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_p, sym_specs)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "impls"
				tmp6 := checkDerefVar(var_glojure_DOT_core_parse_DASH_impls)
				tmp7 := lang.Apply(tmp6, []any{v4})
				var v8 any = tmp7
				_ = v8
				tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp10 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{sym_do})
				tmp13 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp14 lang.FnFunc
				tmp14 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v15 := args[0]
					_ = v15
					var tmp16 any
					{ // let
						// let binding "vec__292"
						var v17 any = v15
						_ = v17
						// let binding "t"
						tmp18 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp19 := lang.Apply(tmp18, []any{v17, int64(0), nil})
						var v20 any = tmp19
						_ = v20
						// let binding "fs"
						tmp21 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp22 := lang.Apply(tmp21, []any{v17, int64(1), nil})
						var v23 any = tmp22
						_ = v23
						tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{sym_glojure_DOT_core_SLASH_extend_DASH_type})
						tmp28 := checkDerefVar(var_glojure_DOT_core_list)
						tmp29 := lang.Apply(tmp28, []any{v20})
						tmp30 := checkDerefVar(var_glojure_DOT_core_list)
						tmp31 := lang.Apply(tmp30, []any{v3})
						tmp32 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp31, v23})
						tmp33 := lang.Apply(tmp24, []any{tmp32})
						tmp16 = tmp33
					} // end let
					return tmp16
				})
				tmp15 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(208), kw_column, int(15), kw_end_DASH_line, int(209), kw_end_DASH_column, int(42))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp17 := lang.Apply(tmp13, []any{tmp16, v8})
				tmp18 := lang.Apply(tmp10, []any{tmp12, tmp17})
				tmp19 := lang.Apply(tmp9, []any{tmp18})
				tmp5 = tmp19
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-extend-type
	{
		tmp0 := sym_emit_DASH_extend_DASH_type.WithMeta(lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(175), kw_column, int(8), kw_end_DASH_line, int(175), kw_end_DASH_column, int(23), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_c, sym_specs)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "impls"
				tmp6 := checkDerefVar(var_glojure_DOT_core_parse_DASH_impls)
				tmp7 := lang.Apply(tmp6, []any{v4})
				var v8 any = tmp7
				_ = v8
				tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp10 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{sym_glojure_DOT_core_SLASH_extend})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := checkDerefVar(var_glojure_DOT_core_mapcat)
				tmp16 := checkDerefVar(var_glojure_DOT_core_partial)
				tmp17 := checkDerefVar(var_glojure_DOT_core_emit_DASH_hinted_DASH_impl)
				tmp18 := lang.Apply(tmp16, []any{tmp17, v3})
				tmp19 := lang.Apply(tmp15, []any{tmp18, v8})
				tmp20 := lang.Apply(tmp10, []any{tmp12, tmp14, tmp19})
				tmp21 := lang.Apply(tmp9, []any{tmp20})
				tmp5 = tmp21
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-hinted-impl
	{
		tmp0 := sym_emit_DASH_hinted_DASH_impl.WithMeta(lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(163), kw_column, int(8), kw_end_DASH_line, int(163), kw_end_DASH_column, int(23), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_c, lang.NewVector(sym_p, sym_fs))), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "vec__281"
				var v6 any = v4
				_ = v6
				// let binding "p"
				tmp7 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp8 := lang.Apply(tmp7, []any{v6, int64(0), nil})
				var v9 any = tmp8
				_ = v9
				// let binding "fs"
				tmp10 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp11 := lang.Apply(tmp10, []any{v6, int64(1), nil})
				var v12 any = tmp11
				_ = v12
				var tmp13 any
				{ // let
					// let binding "hint"
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v15 := args[0]
						_ = v15
						var tmp16 any
						{ // let
							// let binding "specs"
							var tmp17 any
							tmp18 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
							tmp19 := checkDerefVar(var_glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v15})
							tmp21 := lang.Apply(tmp18, []any{tmp20})
							if lang.IsTruthy(tmp21) {
								tmp22 := checkDerefVar(var_glojure_DOT_core_list)
								tmp23 := lang.Apply(tmp22, []any{v15})
								tmp17 = tmp23
							} else {
								tmp17 = v15
							}
							var v24 any = tmp17
							_ = v24
							tmp25 := checkDerefVar(var_glojure_DOT_core_map)
							var tmp26 lang.FnFunc
							tmp26 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v27 := args[0]
								_ = v27
								var tmp28 any
								{ // let
									// let binding "vec__285"
									var v29 any = v27
									_ = v29
									// let binding "seq__286"
									tmp30 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp31 := lang.Apply(tmp30, []any{v29})
									var v32 any = tmp31
									_ = v32
									// let binding "first__287"
									tmp33 := checkDerefVar(var_glojure_DOT_core_first)
									tmp34 := lang.Apply(tmp33, []any{v32})
									var v35 any = tmp34
									_ = v35
									// let binding "seq__286"
									tmp36 := checkDerefVar(var_glojure_DOT_core_next)
									tmp37 := lang.Apply(tmp36, []any{v32})
									var v38 any = tmp37
									_ = v38
									// let binding "vec__288"
									var v39 any = v35
									_ = v39
									// let binding "seq__289"
									tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp41 := lang.Apply(tmp40, []any{v39})
									var v42 any = tmp41
									_ = v42
									// let binding "first__290"
									tmp43 := checkDerefVar(var_glojure_DOT_core_first)
									tmp44 := lang.Apply(tmp43, []any{v42})
									var v45 any = tmp44
									_ = v45
									// let binding "seq__289"
									tmp46 := checkDerefVar(var_glojure_DOT_core_next)
									tmp47 := lang.Apply(tmp46, []any{v42})
									var v48 any = tmp47
									_ = v48
									// let binding "target"
									var v49 any = v45
									_ = v49
									// let binding "args"
									var v50 any = v48
									_ = v50
									// let binding "body"
									var v51 any = v38
									_ = v51
									tmp52 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp53 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp54 := checkDerefVar(var_glojure_DOT_core_vector)
									tmp55 := checkDerefVar(var_glojure_DOT_core_vary_DASH_meta)
									tmp56 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp57 := lang.Apply(tmp55, []any{v49, tmp56, kw_tag, v3})
									tmp58 := lang.Apply(tmp53, []any{tmp54, tmp57, v50})
									tmp59 := lang.Apply(tmp52, []any{tmp58, v51})
									tmp28 = tmp59
								} // end let
								return tmp28
							})
							tmp27 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(168), kw_column, int(23), kw_end_DASH_line, int(170), kw_end_DASH_column, int(36))
							tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp29 := lang.Apply(tmp25, []any{tmp28, v24})
							tmp16 = tmp29
						} // end let
						return tmp16
					})
					tmp15 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(164), kw_column, int(14), kw_end_DASH_line, int(171), kw_end_DASH_column, int(30))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v17 any = tmp16
					_ = v17
					tmp18 := checkDerefVar(var_glojure_DOT_core_zipmap)
					tmp19 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp20 lang.FnFunc
					tmp20 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v21 := args[0]
						_ = v21
						tmp22 := checkDerefVar(var_glojure_DOT_core_keyword)
						tmp23 := checkDerefVar(var_glojure_DOT_core_name)
						tmp24 := checkDerefVar(var_glojure_DOT_core_first)
						tmp25 := lang.Apply(tmp24, []any{v21})
						tmp26 := lang.Apply(tmp23, []any{tmp25})
						tmp27 := lang.Apply(tmp22, []any{tmp26})
						return tmp27
					})
					tmp21 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(172), kw_column, int(21), kw_end_DASH_line, int(172), kw_end_DASH_column, int(46))
					tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp23 := lang.Apply(tmp19, []any{tmp22, v12})
					tmp24 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp25 lang.FnFunc
					tmp25 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v26 := args[0]
						_ = v26
						tmp27 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp28 := checkDerefVar(var_glojure_DOT_core_drop)
						tmp29 := lang.Apply(tmp28, []any{int64(1), v26})
						tmp30 := lang.Apply(v17, []any{tmp29})
						tmp31 := lang.Apply(tmp27, []any{sym_glojure_DOT_core_SLASH_fn, tmp30})
						return tmp31
					})
					tmp26 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(173), kw_column, int(21), kw_end_DASH_line, int(173), kw_end_DASH_column, int(49))
					tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp28 := lang.Apply(tmp24, []any{tmp27, v12})
					tmp29 := lang.Apply(tmp18, []any{tmp23, tmp28})
					tmp30 := lang.NewVector(v9, tmp29)
					tmp31 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(172), kw_column, int(5), kw_end_DASH_line, int(173), kw_end_DASH_column, int(55))
					tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 = tmp32
				} // end let
				tmp5 = tmp13
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// empty
	{
		tmp0 := sym_empty.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns an empty collection of the same category as coll, or nil", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(5265), kw_end_DASH_line, int(5265))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp6 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
			tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
			if lang.IsTruthy(tmp7) {
				tmp8, ok := lang.FieldOrMethod(v3, "empty")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "empty")))
				}
				var tmp9 any
				switch reflect.TypeOf(tmp8).Kind() {
				case reflect.Func:
					tmp9 = lang.Apply(tmp8, nil)
				default:
					tmp9 = tmp8
				}
				tmp4 = tmp9
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// empty?
	{
		tmp0 := sym_empty_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll has no items. To check the emptiness of a seq,\n  please use the idiom (seq x) rather than (not (empty? x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6247), kw_end_DASH_line, int(6247))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_counted_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
				tmp8 := checkDerefVar(var_glojure_DOT_core_count)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp7, []any{tmp9})
				tmp4 = tmp10
			} else {
				tmp11 := checkDerefVar(var_glojure_DOT_core_not)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp11, []any{tmp13})
				tmp4 = tmp14
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ensure
	{
		tmp0 := sym_ensure.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref)), kw_doc, "Must be called in a transaction. Protects the ref from modification\n  by other transactions.  Returns the in-transaction-value of\n  ref. Allows for more concurrency than (ref-set ref @ref)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2480), kw_end_DASH_line, int(2480))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "touch")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("touch is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			_ = tmp5
			tmp6, _ := lang.FieldOrMethod(v3, "deref")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("deref is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ensure-reduced
	{
		tmp0 := sym_ensure_DASH_reduced.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "If x is already reduced?, returns it, else returns (reduced x)", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(2841), kw_end_DASH_line, int(2841))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp4 = v3
			} else {
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduced)
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp4 = tmp8
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// enumeration-seq
	{
		tmp0 := sym_enumeration_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_e)), kw_doc, "Returns a seq on a java.util.Enumeration", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(5710), kw_end_DASH_line, int(5710))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// error-handler
	{
		tmp0 := sym_error_DASH_handler.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_doc, "Returns the error-handler of agent a, or nil if there is none.\n  See set-error-handler!", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(2202), kw_end_DASH_line, int(2202))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getErrorHandler")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getErrorHandler")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// error-mode
	{
		tmp0 := sym_error_DASH_mode.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a)), kw_doc, "Returns the error-mode of agent a.  See set-error-mode!", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(2227), kw_end_DASH_line, int(2227))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getErrorMode")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getErrorMode")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// eval
	{
		tmp0 := sym_eval.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_form)), kw_doc, "Evaluates the form data structure (not text!) and returns the result.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3203), kw_end_DASH_line, int(3203))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.Compiler, "Eval")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Eval is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// even?
	{
		tmp0 := sym_even_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is even, throws an exception if n is not an integer", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(1381), kw_end_DASH_line, int(1381))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_integer_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
				tmp8 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and)
				tmp9 := lang.Apply(lang.UncheckedLongCast, []any{v3})
				tmp10 := lang.Apply(tmp8, []any{tmp9, int64(1)})
				tmp11 := lang.Apply(tmp7, []any{tmp10})
				tmp4 = tmp11
			} else {
				tmp12 := checkDerefVar(var_glojure_DOT_core_str)
				tmp13 := lang.Apply(tmp12, []any{"Argument must be an integer: ", v3})
				tmp14 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp13})
				panic(tmp14)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// every-pred
	{
		tmp0 := sym_every_DASH_pred.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_p), lang.NewVector(sym_p1, sym_p2), lang.NewVector(sym_p1, sym_p2, sym_p3), lang.NewVector(sym_p1, sym_p2, sym_p3, sym__AMP_, sym_ps)), kw_doc, "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7422), kw_end_DASH_line, int(7422))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				{ // function ep1
					var v5 lang.FnFunc
					tmp4 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v6 := args[0]
							_ = v6
							tmp7 := checkDerefVar(var_glojure_DOT_core_boolean)
							tmp8 := lang.Apply(v3, []any{v6})
							tmp9 := lang.Apply(tmp7, []any{tmp8})
							return tmp9
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							tmp8 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp9 any
							{ // let
								// let binding "and__0__auto__"
								tmp10 := lang.Apply(v3, []any{v6})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp13 := lang.Apply(v3, []any{v7})
									tmp12 = tmp13
								} else {
									tmp12 = v11
								}
								tmp9 = tmp12
							} // end let
							tmp10 := lang.Apply(tmp8, []any{tmp9})
							return tmp10
						case 3:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							tmp9 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := lang.Apply(v3, []any{v6})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									var tmp14 any
									{ // let
										// let binding "and__0__auto__"
										tmp15 := lang.Apply(v3, []any{v7})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											tmp18 := lang.Apply(v3, []any{v8})
											tmp17 = tmp18
										} else {
											tmp17 = v16
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								} else {
									tmp13 = v12
								}
								tmp10 = tmp13
							} // end let
							tmp11 := lang.Apply(tmp9, []any{tmp10})
							return tmp11
						default:
							checkArity(args, 3)
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var v9 any = lang.NewList(args[3:]...)
							_ = v9
							tmp10 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp11 any
							{ // let
								// let binding "and__0__auto__"
								tmp12 := lang.Apply(v5, []any{v6, v7, v8})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp15 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
									tmp16 := lang.Apply(tmp15, []any{v3, v9})
									tmp14 = tmp16
								} else {
									tmp14 = v13
								}
								tmp11 = tmp14
							} // end let
							tmp12 := lang.Apply(tmp10, []any{tmp11})
							return tmp12
						}
					})
					v5 = tmp4
					_ = v5
				}
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7429), kw_column, int(6), kw_end_DASH_line, int(7435), kw_end_DASH_column, int(56))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				{ // function ep2
					var v6 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp9 any
							{ // let
								// let binding "and__0__auto__"
								tmp10 := lang.Apply(v3, []any{v7})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp13 := lang.Apply(v4, []any{v7})
									tmp12 = tmp13
								} else {
									tmp12 = v11
								}
								tmp9 = tmp12
							} // end let
							tmp10 := lang.Apply(tmp8, []any{tmp9})
							return tmp10
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							tmp9 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := lang.Apply(v3, []any{v7})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									var tmp14 any
									{ // let
										// let binding "and__0__auto__"
										tmp15 := lang.Apply(v3, []any{v8})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											var tmp18 any
											{ // let
												// let binding "and__0__auto__"
												tmp19 := lang.Apply(v4, []any{v7})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													tmp22 := lang.Apply(v4, []any{v8})
													tmp21 = tmp22
												} else {
													tmp21 = v20
												}
												tmp18 = tmp21
											} // end let
											tmp17 = tmp18
										} else {
											tmp17 = v16
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								} else {
									tmp13 = v12
								}
								tmp10 = tmp13
							} // end let
							tmp11 := lang.Apply(tmp9, []any{tmp10})
							return tmp11
						case 3:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							tmp10 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp11 any
							{ // let
								// let binding "and__0__auto__"
								tmp12 := lang.Apply(v3, []any{v7})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									var tmp15 any
									{ // let
										// let binding "and__0__auto__"
										tmp16 := lang.Apply(v3, []any{v8})
										var v17 any = tmp16
										_ = v17
										var tmp18 any
										if lang.IsTruthy(v17) {
											var tmp19 any
											{ // let
												// let binding "and__0__auto__"
												tmp20 := lang.Apply(v3, []any{v9})
												var v21 any = tmp20
												_ = v21
												var tmp22 any
												if lang.IsTruthy(v21) {
													var tmp23 any
													{ // let
														// let binding "and__0__auto__"
														tmp24 := lang.Apply(v4, []any{v7})
														var v25 any = tmp24
														_ = v25
														var tmp26 any
														if lang.IsTruthy(v25) {
															var tmp27 any
															{ // let
																// let binding "and__0__auto__"
																tmp28 := lang.Apply(v4, []any{v8})
																var v29 any = tmp28
																_ = v29
																var tmp30 any
																if lang.IsTruthy(v29) {
																	tmp31 := lang.Apply(v4, []any{v9})
																	tmp30 = tmp31
																} else {
																	tmp30 = v29
																}
																tmp27 = tmp30
															} // end let
															tmp26 = tmp27
														} else {
															tmp26 = v25
														}
														tmp23 = tmp26
													} // end let
													tmp22 = tmp23
												} else {
													tmp22 = v21
												}
												tmp19 = tmp22
											} // end let
											tmp18 = tmp19
										} else {
											tmp18 = v17
										}
										tmp15 = tmp18
									} // end let
									tmp14 = tmp15
								} else {
									tmp14 = v13
								}
								tmp11 = tmp14
							} // end let
							tmp12 := lang.Apply(tmp10, []any{tmp11})
							return tmp12
						default:
							checkArity(args, 3)
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var v10 any = lang.NewList(args[3:]...)
							_ = v10
							tmp11 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp12 any
							{ // let
								// let binding "and__0__auto__"
								tmp13 := lang.Apply(v6, []any{v7, v8, v9})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									tmp16 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
									var tmp17 lang.FnFunc
									tmp17 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v18 := args[0]
										_ = v18
										var tmp19 any
										{ // let
											// let binding "and__0__auto__"
											tmp20 := lang.Apply(v3, []any{v18})
											var v21 any = tmp20
											_ = v21
											var tmp22 any
											if lang.IsTruthy(v21) {
												tmp23 := lang.Apply(v4, []any{v18})
												tmp22 = tmp23
											} else {
												tmp22 = v21
											}
											tmp19 = tmp22
										} // end let
										return tmp19
									})
									tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7443), kw_column, int(46), kw_end_DASH_line, int(7443), kw_end_DASH_column, int(65))
									tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp20 := lang.Apply(tmp16, []any{tmp19, v10})
									tmp15 = tmp20
								} else {
									tmp15 = v14
								}
								tmp12 = tmp15
							} // end let
							tmp13 := lang.Apply(tmp11, []any{tmp12})
							return tmp13
						}
					})
					v6 = tmp5
					_ = v6
				}
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7437), kw_column, int(6), kw_end_DASH_line, int(7443), kw_end_DASH_column, int(75))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				{ // function ep3
					var v7 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v8 := args[0]
							_ = v8
							tmp9 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := lang.Apply(v3, []any{v8})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									var tmp14 any
									{ // let
										// let binding "and__0__auto__"
										tmp15 := lang.Apply(v4, []any{v8})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											tmp18 := lang.Apply(v5, []any{v8})
											tmp17 = tmp18
										} else {
											tmp17 = v16
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								} else {
									tmp13 = v12
								}
								tmp10 = tmp13
							} // end let
							tmp11 := lang.Apply(tmp9, []any{tmp10})
							return tmp11
						case 2:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							tmp10 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp11 any
							{ // let
								// let binding "and__0__auto__"
								tmp12 := lang.Apply(v3, []any{v8})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									var tmp15 any
									{ // let
										// let binding "and__0__auto__"
										tmp16 := lang.Apply(v3, []any{v9})
										var v17 any = tmp16
										_ = v17
										var tmp18 any
										if lang.IsTruthy(v17) {
											var tmp19 any
											{ // let
												// let binding "and__0__auto__"
												tmp20 := lang.Apply(v4, []any{v8})
												var v21 any = tmp20
												_ = v21
												var tmp22 any
												if lang.IsTruthy(v21) {
													var tmp23 any
													{ // let
														// let binding "and__0__auto__"
														tmp24 := lang.Apply(v4, []any{v9})
														var v25 any = tmp24
														_ = v25
														var tmp26 any
														if lang.IsTruthy(v25) {
															var tmp27 any
															{ // let
																// let binding "and__0__auto__"
																tmp28 := lang.Apply(v5, []any{v8})
																var v29 any = tmp28
																_ = v29
																var tmp30 any
																if lang.IsTruthy(v29) {
																	tmp31 := lang.Apply(v5, []any{v9})
																	tmp30 = tmp31
																} else {
																	tmp30 = v29
																}
																tmp27 = tmp30
															} // end let
															tmp26 = tmp27
														} else {
															tmp26 = v25
														}
														tmp23 = tmp26
													} // end let
													tmp22 = tmp23
												} else {
													tmp22 = v21
												}
												tmp19 = tmp22
											} // end let
											tmp18 = tmp19
										} else {
											tmp18 = v17
										}
										tmp15 = tmp18
									} // end let
									tmp14 = tmp15
								} else {
									tmp14 = v13
								}
								tmp11 = tmp14
							} // end let
							tmp12 := lang.Apply(tmp10, []any{tmp11})
							return tmp12
						case 3:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							tmp11 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp12 any
							{ // let
								// let binding "and__0__auto__"
								tmp13 := lang.Apply(v3, []any{v8})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									var tmp16 any
									{ // let
										// let binding "and__0__auto__"
										tmp17 := lang.Apply(v3, []any{v9})
										var v18 any = tmp17
										_ = v18
										var tmp19 any
										if lang.IsTruthy(v18) {
											var tmp20 any
											{ // let
												// let binding "and__0__auto__"
												tmp21 := lang.Apply(v3, []any{v10})
												var v22 any = tmp21
												_ = v22
												var tmp23 any
												if lang.IsTruthy(v22) {
													var tmp24 any
													{ // let
														// let binding "and__0__auto__"
														tmp25 := lang.Apply(v4, []any{v8})
														var v26 any = tmp25
														_ = v26
														var tmp27 any
														if lang.IsTruthy(v26) {
															var tmp28 any
															{ // let
																// let binding "and__0__auto__"
																tmp29 := lang.Apply(v4, []any{v9})
																var v30 any = tmp29
																_ = v30
																var tmp31 any
																if lang.IsTruthy(v30) {
																	var tmp32 any
																	{ // let
																		// let binding "and__0__auto__"
																		tmp33 := lang.Apply(v4, []any{v10})
																		var v34 any = tmp33
																		_ = v34
																		var tmp35 any
																		if lang.IsTruthy(v34) {
																			var tmp36 any
																			{ // let
																				// let binding "and__0__auto__"
																				tmp37 := lang.Apply(v5, []any{v8})
																				var v38 any = tmp37
																				_ = v38
																				var tmp39 any
																				if lang.IsTruthy(v38) {
																					var tmp40 any
																					{ // let
																						// let binding "and__0__auto__"
																						tmp41 := lang.Apply(v5, []any{v9})
																						var v42 any = tmp41
																						_ = v42
																						var tmp43 any
																						if lang.IsTruthy(v42) {
																							tmp44 := lang.Apply(v5, []any{v10})
																							tmp43 = tmp44
																						} else {
																							tmp43 = v42
																						}
																						tmp40 = tmp43
																					} // end let
																					tmp39 = tmp40
																				} else {
																					tmp39 = v38
																				}
																				tmp36 = tmp39
																			} // end let
																			tmp35 = tmp36
																		} else {
																			tmp35 = v34
																		}
																		tmp32 = tmp35
																	} // end let
																	tmp31 = tmp32
																} else {
																	tmp31 = v30
																}
																tmp28 = tmp31
															} // end let
															tmp27 = tmp28
														} else {
															tmp27 = v26
														}
														tmp24 = tmp27
													} // end let
													tmp23 = tmp24
												} else {
													tmp23 = v22
												}
												tmp20 = tmp23
											} // end let
											tmp19 = tmp20
										} else {
											tmp19 = v18
										}
										tmp16 = tmp19
									} // end let
									tmp15 = tmp16
								} else {
									tmp15 = v14
								}
								tmp12 = tmp15
							} // end let
							tmp13 := lang.Apply(tmp11, []any{tmp12})
							return tmp13
						default:
							checkArity(args, 3)
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							var v11 any = lang.NewList(args[3:]...)
							_ = v11
							tmp12 := checkDerefVar(var_glojure_DOT_core_boolean)
							var tmp13 any
							{ // let
								// let binding "and__0__auto__"
								tmp14 := lang.Apply(v7, []any{v8, v9, v10})
								var v15 any = tmp14
								_ = v15
								var tmp16 any
								if lang.IsTruthy(v15) {
									tmp17 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
									var tmp18 lang.FnFunc
									tmp18 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v19 := args[0]
										_ = v19
										var tmp20 any
										{ // let
											// let binding "and__0__auto__"
											tmp21 := lang.Apply(v3, []any{v19})
											var v22 any = tmp21
											_ = v22
											var tmp23 any
											if lang.IsTruthy(v22) {
												var tmp24 any
												{ // let
													// let binding "and__0__auto__"
													tmp25 := lang.Apply(v4, []any{v19})
													var v26 any = tmp25
													_ = v26
													var tmp27 any
													if lang.IsTruthy(v26) {
														tmp28 := lang.Apply(v5, []any{v19})
														tmp27 = tmp28
													} else {
														tmp27 = v26
													}
													tmp24 = tmp27
												} // end let
												tmp23 = tmp24
											} else {
												tmp23 = v22
											}
											tmp20 = tmp23
										} // end let
										return tmp20
									})
									tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7451), kw_column, int(46), kw_end_DASH_line, int(7451), kw_end_DASH_column, int(72))
									tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp21 := lang.Apply(tmp17, []any{tmp20, v11})
									tmp16 = tmp21
								} else {
									tmp16 = v15
								}
								tmp13 = tmp16
							} // end let
							tmp14 := lang.Apply(tmp12, []any{tmp13})
							return tmp14
						}
					})
					v7 = tmp6
					_ = v7
				}
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7445), kw_column, int(6), kw_end_DASH_line, int(7451), kw_end_DASH_column, int(82))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ps"
					tmp8 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
					tmp9 := lang.Apply(tmp8, []any{v3, v4, v5, v6})
					var v10 any = tmp9
					_ = v10
					var tmp11 lang.FnFunc
					{ // function epn
						var v12 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								return true
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
								var tmp15 lang.FnFunc
								tmp15 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v16 := args[0]
									_ = v16
									tmp17 := lang.Apply(v16, []any{v13})
									return tmp17
								})
								tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7456), kw_column, int(23), kw_end_DASH_line, int(7456), kw_end_DASH_column, int(28))
								tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp18 := lang.Apply(tmp14, []any{tmp17, v10})
								return tmp18
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								tmp15 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
								var tmp16 lang.FnFunc
								tmp16 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v17 := args[0]
									_ = v17
									var tmp18 any
									{ // let
										// let binding "and__0__auto__"
										tmp19 := lang.Apply(v17, []any{v13})
										var v20 any = tmp19
										_ = v20
										var tmp21 any
										if lang.IsTruthy(v20) {
											tmp22 := lang.Apply(v17, []any{v14})
											tmp21 = tmp22
										} else {
											tmp21 = v20
										}
										tmp18 = tmp21
									} // end let
									return tmp18
								})
								tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7457), kw_column, int(25), kw_end_DASH_line, int(7457), kw_end_DASH_column, int(42))
								tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp19 := lang.Apply(tmp15, []any{tmp18, v10})
								return tmp19
							case 3:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								v15 := args[2]
								_ = v15
								tmp16 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
								var tmp17 lang.FnFunc
								tmp17 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v18 := args[0]
									_ = v18
									var tmp19 any
									{ // let
										// let binding "and__0__auto__"
										tmp20 := lang.Apply(v18, []any{v13})
										var v21 any = tmp20
										_ = v21
										var tmp22 any
										if lang.IsTruthy(v21) {
											var tmp23 any
											{ // let
												// let binding "and__0__auto__"
												tmp24 := lang.Apply(v18, []any{v14})
												var v25 any = tmp24
												_ = v25
												var tmp26 any
												if lang.IsTruthy(v25) {
													tmp27 := lang.Apply(v18, []any{v15})
													tmp26 = tmp27
												} else {
													tmp26 = v25
												}
												tmp23 = tmp26
											} // end let
											tmp22 = tmp23
										} else {
											tmp22 = v21
										}
										tmp19 = tmp22
									} // end let
									return tmp19
								})
								tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7458), kw_column, int(27), kw_end_DASH_line, int(7458), kw_end_DASH_column, int(50))
								tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp20 := lang.Apply(tmp16, []any{tmp19, v10})
								return tmp20
							default:
								checkArity(args, 3)
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								v15 := args[2]
								_ = v15
								var v16 any = lang.NewList(args[3:]...)
								_ = v16
								tmp17 := checkDerefVar(var_glojure_DOT_core_boolean)
								var tmp18 any
								{ // let
									// let binding "and__0__auto__"
									tmp19 := lang.Apply(v12, []any{v13, v14, v15})
									var v20 any = tmp19
									_ = v20
									var tmp21 any
									if lang.IsTruthy(v20) {
										tmp22 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
										var tmp23 lang.FnFunc
										tmp23 = lang.NewFnFunc(func(args ...any) any {
											checkArity(args, 1)
											v24 := args[0]
											_ = v24
											tmp25 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
											tmp26 := lang.Apply(tmp25, []any{v24, v16})
											return tmp26
										})
										tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7460), kw_column, int(48), kw_end_DASH_line, int(7460), kw_end_DASH_column, int(63))
										tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp26 := lang.Apply(tmp22, []any{tmp25, v10})
										tmp21 = tmp26
									} else {
										tmp21 = v20
									}
									tmp18 = tmp21
								} // end let
								tmp19 := lang.Apply(tmp17, []any{tmp18})
								return tmp19
							}
						})
						v12 = tmp11
						_ = v12
					}
					tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7454), kw_column, int(8), kw_end_DASH_line, int(7460), kw_end_DASH_column, int(71))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp7 = tmp13
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// every?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_every_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns true if (pred x) is logical true for every x in coll, else\n  false.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2664), kw_end_DASH_line, int(2664))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
		recur_loop_480:
			var tmp6 any
			tmp7 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp9 := lang.Apply(tmp8, []any{v5})
			tmp10 := lang.Apply(tmp7, []any{tmp9})
			if lang.IsTruthy(tmp10) {
				tmp6 = true
			} else {
				var tmp11 any
				tmp12 := checkDerefVar(var_glojure_DOT_core_first)
				tmp13 := lang.Apply(tmp12, []any{v5})
				tmp14 := lang.Apply(v4, []any{tmp13})
				if lang.IsTruthy(tmp14) {
					var tmp15 any = v4
					tmp17 := checkDerefVar(var_glojure_DOT_core_next)
					tmp18 := lang.Apply(tmp17, []any{v5})
					var tmp16 any = tmp18
					v4 = tmp15
					v5 = tmp16
					goto recur_loop_480
				} else {
					var tmp19 any
					if lang.IsTruthy(kw_else) {
						tmp19 = false
					} else {
					}
					tmp11 = tmp19
				}
				tmp6 = tmp11
			}
			return tmp6
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-cause
	{
		tmp0 := sym_ex_DASH_cause.WithMeta(lang.NewMap(kw_tag, nil, kw_arglists, lang.NewList(lang.NewVector(sym_ex)), kw_doc, "Returns the cause of ex if ex is a Throwable.\n  Otherwise returns nil.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4828), kw_end_DASH_line, int(4828))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{lang.Throwable, v3})
			if lang.IsTruthy(tmp6) {
				tmp7, ok := lang.FieldOrMethod(v3, "getCause")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getCause")))
				}
				var tmp8 any
				switch reflect.TypeOf(tmp7).Kind() {
				case reflect.Func:
					tmp8 = lang.Apply(tmp7, nil)
				default:
					tmp8 = tmp7
				}
				tmp4 = tmp8
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-data
	{
		tmp0 := sym_ex_DASH_data.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ex)), kw_doc, "Returns exception data (a map) if ex is an IExceptionInfo.\n   Otherwise returns nil.", kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4812), kw_end_DASH_line, int(4812))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{nil, v3})
			if lang.IsTruthy(tmp6) {
				tmp7, ok := lang.FieldOrMethod(v3, "getData")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getData")))
				}
				var tmp8 any
				switch reflect.TypeOf(tmp7).Kind() {
				case reflect.Func:
					tmp8 = lang.Apply(tmp7, nil)
				default:
					tmp8 = tmp7
				}
				tmp4 = tmp8
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-info
	{
		tmp0 := sym_ex_DASH_info.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_msg, sym_map), lang.NewVector(sym_msg, sym_map, sym_cause)), kw_doc, "Create an instance of ExceptionInfo, a RuntimeException subclass\n   that carries a map of additional data.", kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4803), kw_end_DASH_line, int(4803))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_elide_DASH_top_DASH_frames)
				tmp6 := lang.Apply(nil, []any{v3, v4})
				tmp7 := lang.Apply(tmp5, []any{tmp6, "glojure.core$ex_info"})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_elide_DASH_top_DASH_frames)
				tmp7 := lang.Apply(nil, []any{v3, v4, v5})
				tmp8 := lang.Apply(tmp6, []any{tmp7, "glojure.core$ex_info"})
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-message
	{
		tmp0 := sym_ex_DASH_message.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ex)), kw_doc, "Returns the message attached to ex if ex is a Throwable.\n  Otherwise returns nil.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4820), kw_end_DASH_line, int(4820))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{lang.Throwable, v3})
			if lang.IsTruthy(tmp6) {
				tmp7, ok := lang.FieldOrMethod(v3, "getMessage")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMessage")))
				}
				var tmp8 any
				switch reflect.TypeOf(tmp7).Kind() {
				case reflect.Func:
					tmp8 = lang.Apply(tmp7, nil)
				default:
					tmp8 = tmp7
				}
				tmp4 = tmp8
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend
	{
		tmp0 := sym_extend.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atype, sym__AMP_, sym_proto_PLUS_mmaps)), kw_doc, "Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n    AProtocol\n     {:foo an-existing-fn\n      :bar (fn [a b] ...)\n      :baz (fn ([a]...) ([a b] ...)...)}\n    BProtocol \n      {...} \n    ...)\n \n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument. \n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders", kw_file, "glojure/core_deftype.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(116), kw_end_DASH_line, int(116))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "seq_262"
					tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp7 := checkDerefVar(var_glojure_DOT_core_partition)
					tmp8 := lang.Apply(tmp7, []any{int64(2), v4})
					tmp9 := lang.Apply(tmp6, []any{tmp8})
					var v10 any = tmp9
					_ = v10
					// let binding "chunk_263"
					var v11 any = nil
					_ = v11
					// let binding "count_264"
					var v12 any = int64(0)
					_ = v12
					// let binding "i_265"
					var v13 any = int64(0)
					_ = v13
					for {
						var tmp14 any
						tmp15 := checkDerefVar(var_glojure_DOT_core__LT_)
						tmp16 := lang.Apply(tmp15, []any{v13, v12})
						if lang.IsTruthy(tmp16) {
							var tmp17 any
							{ // let
								// let binding "vec__266"
								tmp18, _ := lang.FieldOrMethod(v11, "nth")
								if reflect.TypeOf(tmp18).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
								}
								tmp19 := lang.Apply(tmp18, []any{v13})
								var v20 any = tmp19
								_ = v20
								// let binding "proto"
								tmp21 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp22 := lang.Apply(tmp21, []any{v20, int64(0), nil})
								var v23 any = tmp22
								_ = v23
								// let binding "mmap"
								tmp24 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp25 := lang.Apply(tmp24, []any{v20, int64(1), nil})
								var v26 any = tmp25
								_ = v26
								var tmp27 any
								tmp28 := checkDerefVar(var_glojure_DOT_core_protocol_QMARK_)
								tmp29 := lang.Apply(tmp28, []any{v23})
								if lang.IsTruthy(tmp29) {
								} else {
									tmp30 := checkDerefVar(var_glojure_DOT_core_str)
									tmp31 := lang.Apply(tmp30, []any{v23, " is not a protocol"})
									tmp32 := lang.Apply(errors8.New, []any{tmp31})
									panic(tmp32)
								}
								_ = tmp27
								tmp33 := checkDerefVar(var_glojure_DOT_core_reduce1)
								var tmp34 lang.FnFunc
								tmp34 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 2)
									v35 := args[0]
									_ = v35
									v36 := args[1]
									_ = v36
									var tmp37 any
									{ // let
										// let binding "vec__270"
										var v38 any = v36
										_ = v38
										// let binding "k"
										tmp39 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp40 := lang.Apply(tmp39, []any{v38, int64(0), nil})
										var v41 any = tmp40
										_ = v41
										// let binding "v"
										tmp42 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp43 := lang.Apply(tmp42, []any{v38, int64(1), nil})
										var v44 any = tmp43
										_ = v44
										tmp45 := checkDerefVar(var_glojure_DOT_core_get_DASH_in)
										tmp46 := checkDerefVar(var_glojure_DOT_core_deref)
										tmp47 := lang.Apply(tmp46, []any{v23})
										tmp48 := lang.NewVector(kw_multis, v41)
										tmp49 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(158), kw_column, int(33), kw_end_DASH_line, int(158), kw_end_DASH_column, int(43))
										tmp50, err := lang.WithMeta(tmp48, tmp49.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp51 := lang.Apply(tmp45, []any{tmp47, tmp50})
										var tmp52 lang.FnFunc
										tmp52 = lang.NewFnFunc(func(args ...any) any {
											switch len(args) {
											default:
												checkArity(args, 1)
												v53 := args[0]
												_ = v53
												var v54 any = lang.NewList(args[1:]...)
												_ = v54
												tmp55 := checkDerefVar(var_glojure_DOT_core_apply)
												tmp56 := checkDerefVar(var_glojure_DOT_core_cons)
												tmp57 := lang.Apply(tmp56, []any{v53, v54})
												tmp58 := lang.Apply(tmp55, []any{v44, tmp57})
												return tmp58
											}
										})
										tmp53, _ := lang.FieldOrMethod(tmp51, "AddMethod")
										if reflect.TypeOf(tmp53).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddMethod is not a function")))
										}
										tmp54 := lang.Apply(tmp53, []any{v3, tmp52})
										tmp37 = tmp54
									} // end let
									return tmp37
								})
								tmp35 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(156), kw_column, int(14), kw_end_DASH_line, int(160), kw_end_DASH_column, int(45))
								tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp37 := lang.Apply(tmp33, []any{tmp36, nil, v26})
								_ = tmp37
								var tmp38 any = v10
								var tmp39 any = v11
								var tmp40 any = v12
								tmp42 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
								tmp43 := lang.Apply(tmp42, []any{v13})
								var tmp41 any = tmp43
								v10 = tmp38
								v11 = tmp39
								v12 = tmp40
								v13 = tmp41
								continue
							} // end let
							tmp14 = tmp17
						} else {
							var tmp18 any
							{ // let
								// let binding "temp__0__auto__"
								tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp20 := lang.Apply(tmp19, []any{v10})
								var v21 any = tmp20
								_ = v21
								var tmp22 any
								if lang.IsTruthy(v21) {
									var tmp23 any
									{ // let
										// let binding "seq_262"
										var v24 any = v21
										_ = v24
										var tmp25 any
										tmp26 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
										tmp27 := lang.Apply(tmp26, []any{v24})
										if lang.IsTruthy(tmp27) {
											var tmp28 any
											{ // let
												// let binding "c__0__auto__"
												tmp29 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
												tmp30 := lang.Apply(tmp29, []any{v24})
												var v31 any = tmp30
												_ = v31
												tmp33 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
												tmp34 := lang.Apply(tmp33, []any{v24})
												var tmp32 any = tmp34
												var tmp35 any = v31
												tmp37 := checkDerefVar(var_glojure_DOT_core_int)
												tmp38 := checkDerefVar(var_glojure_DOT_core_count)
												tmp39 := lang.Apply(tmp38, []any{v31})
												tmp40 := lang.Apply(tmp37, []any{tmp39})
												var tmp36 any = tmp40
												tmp42 := checkDerefVar(var_glojure_DOT_core_int)
												tmp43 := lang.Apply(tmp42, []any{int64(0)})
												var tmp41 any = tmp43
												v10 = tmp32
												v11 = tmp35
												v12 = tmp36
												v13 = tmp41
												continue
											} // end let
											tmp25 = tmp28
										} else {
											var tmp29 any
											{ // let
												// let binding "vec__273"
												tmp30 := checkDerefVar(var_glojure_DOT_core_first)
												tmp31 := lang.Apply(tmp30, []any{v24})
												var v32 any = tmp31
												_ = v32
												// let binding "proto"
												tmp33 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp34 := lang.Apply(tmp33, []any{v32, int64(0), nil})
												var v35 any = tmp34
												_ = v35
												// let binding "mmap"
												tmp36 := checkDerefVar(var_glojure_DOT_core_nth)
												tmp37 := lang.Apply(tmp36, []any{v32, int64(1), nil})
												var v38 any = tmp37
												_ = v38
												var tmp39 any
												tmp40 := checkDerefVar(var_glojure_DOT_core_protocol_QMARK_)
												tmp41 := lang.Apply(tmp40, []any{v35})
												if lang.IsTruthy(tmp41) {
												} else {
													tmp42 := checkDerefVar(var_glojure_DOT_core_str)
													tmp43 := lang.Apply(tmp42, []any{v35, " is not a protocol"})
													tmp44 := lang.Apply(errors8.New, []any{tmp43})
													panic(tmp44)
												}
												_ = tmp39
												tmp45 := checkDerefVar(var_glojure_DOT_core_reduce1)
												var tmp46 lang.FnFunc
												tmp46 = lang.NewFnFunc(func(args ...any) any {
													checkArity(args, 2)
													v47 := args[0]
													_ = v47
													v48 := args[1]
													_ = v48
													var tmp49 any
													{ // let
														// let binding "vec__277"
														var v50 any = v48
														_ = v50
														// let binding "k"
														tmp51 := checkDerefVar(var_glojure_DOT_core_nth)
														tmp52 := lang.Apply(tmp51, []any{v50, int64(0), nil})
														var v53 any = tmp52
														_ = v53
														// let binding "v"
														tmp54 := checkDerefVar(var_glojure_DOT_core_nth)
														tmp55 := lang.Apply(tmp54, []any{v50, int64(1), nil})
														var v56 any = tmp55
														_ = v56
														tmp57 := checkDerefVar(var_glojure_DOT_core_get_DASH_in)
														tmp58 := checkDerefVar(var_glojure_DOT_core_deref)
														tmp59 := lang.Apply(tmp58, []any{v35})
														tmp60 := lang.NewVector(kw_multis, v53)
														tmp61 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(158), kw_column, int(33), kw_end_DASH_line, int(158), kw_end_DASH_column, int(43))
														tmp62, err := lang.WithMeta(tmp60, tmp61.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp63 := lang.Apply(tmp57, []any{tmp59, tmp62})
														var tmp64 lang.FnFunc
														tmp64 = lang.NewFnFunc(func(args ...any) any {
															switch len(args) {
															default:
																checkArity(args, 1)
																v65 := args[0]
																_ = v65
																var v66 any = lang.NewList(args[1:]...)
																_ = v66
																tmp67 := checkDerefVar(var_glojure_DOT_core_apply)
																tmp68 := checkDerefVar(var_glojure_DOT_core_cons)
																tmp69 := lang.Apply(tmp68, []any{v65, v66})
																tmp70 := lang.Apply(tmp67, []any{v56, tmp69})
																return tmp70
															}
														})
														tmp65, _ := lang.FieldOrMethod(tmp63, "AddMethod")
														if reflect.TypeOf(tmp65).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddMethod is not a function")))
														}
														tmp66 := lang.Apply(tmp65, []any{v3, tmp64})
														tmp49 = tmp66
													} // end let
													return tmp49
												})
												tmp47 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(156), kw_column, int(14), kw_end_DASH_line, int(160), kw_end_DASH_column, int(45))
												tmp48, err := lang.WithMeta(tmp46, tmp47.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp49 := lang.Apply(tmp45, []any{tmp48, nil, v38})
												_ = tmp49
												tmp51 := checkDerefVar(var_glojure_DOT_core_next)
												tmp52 := lang.Apply(tmp51, []any{v24})
												var tmp50 any = tmp52
												var tmp53 any = nil
												var tmp54 any = int64(0)
												var tmp55 any = int64(0)
												v10 = tmp50
												v11 = tmp53
												v12 = tmp54
												v13 = tmp55
												continue
											} // end let
											tmp25 = tmp29
										}
										tmp23 = tmp25
									} // end let
									tmp22 = tmp23
								} else {
								}
								tmp18 = tmp22
							} // end let
							tmp14 = tmp18
						}
						tmp5 = tmp14
						break
					}
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend-protocol
	{
		tmp0 := sym_extend_DASH_protocol.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_p, sym__AMP_, sym_specs)), kw_doc, "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types.\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))", kw_file, "glojure/core_deftype.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(11), kw_line, int(212), kw_end_DASH_line, int(212))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_emit_DASH_extend_DASH_protocol)
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend-type
	{
		tmp0 := sym_extend_DASH_type.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_t, sym__AMP_, sym_specs)), kw_doc, "A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType \n    Countable\n      (cnt [c] ...)\n    Foo\n      (bar [x y] ...)\n      (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n   Countable\n     {:cnt (fn [c] ...)}\n   Foo\n     {:baz (fn ([x] ...) ([x y & zs] ...))\n      :bar (fn [x y] ...)})", kw_file, "glojure/core_deftype.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(11), kw_line, int(180), kw_end_DASH_line, int(180))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_emit_DASH_extend_DASH_type)
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// false?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_false_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is the value false, false otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(504), kw_end_DASH_line, int(504))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Identical, []any{v4, false})
			return tmp5
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ffirst
	{
		tmp0 := sym_ffirst.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Same as (first (first x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(2), kw_line, int(98), kw_end_DASH_line, int(102))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function ffirst
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_first)
				tmp6 := checkDerefVar(var_glojure_DOT_core_first)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(102), kw_column, int(9), kw_end_DASH_line, int(102), kw_end_DASH_column, int(50))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// file-seq
	{
		tmp0 := sym_file_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_dir)), kw_doc, "A tree seq on java.io.Files", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4972), kw_end_DASH_line, int(4972))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_tree_DASH_seq)
			var tmp5 lang.FnFunc
			tmp5 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v6 := args[0]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(v6, "isDirectory")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("isDirectory is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{})
				return tmp8
			})
			tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4978), kw_column, int(6), kw_end_DASH_line, int(4978), kw_end_DASH_column, int(47))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp8 lang.FnFunc
			tmp8 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v9 := args[0]
				_ = v9
				tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp11, _ := lang.FieldOrMethod(v9, "listFiles")
				if reflect.TypeOf(tmp11).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("listFiles is not a function")))
				}
				tmp12 := lang.Apply(tmp11, []any{})
				tmp13 := lang.Apply(tmp10, []any{tmp12})
				return tmp13
			})
			tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4979), kw_column, int(6), kw_end_DASH_line, int(4979), kw_end_DASH_column, int(51))
			tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp11 := lang.Apply(tmp4, []any{tmp7, tmp10, v3})
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filter
	{
		tmp0 := sym_filter.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred), lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2785), kw_end_DASH_line, int(2785))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							tmp10 := lang.Apply(v3, []any{v8})
							if lang.IsTruthy(tmp10) {
								tmp11 := lang.Apply(v5, []any{v7, v8})
								tmp9 = tmp11
							} else {
								tmp9 = v7
							}
							return tmp9
						default:
							checkArity(args, -1)
							panic("unreachable")
						}
					})
					tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2793), kw_column, int(7), kw_end_DASH_line, int(2799), kw_end_DASH_column, int(22))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2792), kw_column, int(5), kw_end_DASH_line, int(2799), kw_end_DASH_column, int(23))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								tmp14 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
								tmp15 := lang.Apply(tmp14, []any{v12})
								if lang.IsTruthy(tmp15) {
									var tmp16 any
									{ // let
										// let binding "c"
										tmp17 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
										tmp18 := lang.Apply(tmp17, []any{v12})
										var v19 any = tmp18
										_ = v19
										// let binding "size"
										tmp20 := checkDerefVar(var_glojure_DOT_core_count)
										tmp21 := lang.Apply(tmp20, []any{v19})
										var v22 any = tmp21
										_ = v22
										// let binding "b"
										tmp23 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_buffer)
										tmp24 := lang.Apply(tmp23, []any{v22})
										var v25 any = tmp24
										_ = v25
										var tmp26 any
										{ // let
											// let binding "n__0__auto__"
											tmp27 := lang.Apply(lang.LongCast, []any{v22})
											var v28 any = tmp27
											_ = v28
											var tmp29 any
											{ // let
												// let binding "i"
												var v30 any = int64(0)
												_ = v30
												for {
													var tmp31 any
													tmp32 := checkDerefVar(var_glojure_DOT_core__LT_)
													tmp33 := lang.Apply(tmp32, []any{v30, v28})
													if lang.IsTruthy(tmp33) {
														var tmp34 any
														{ // let
															// let binding "v"
															tmp35, _ := lang.FieldOrMethod(v19, "nth")
															if reflect.TypeOf(tmp35).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp36 := lang.Apply(tmp35, []any{v30})
															var v37 any = tmp36
															_ = v37
															var tmp38 any
															tmp39 := lang.Apply(v3, []any{v37})
															if lang.IsTruthy(tmp39) {
																tmp40 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_append)
																tmp41 := lang.Apply(tmp40, []any{v25, v37})
																tmp38 = tmp41
															} else {
															}
															tmp34 = tmp38
														} // end let
														_ = tmp34
														tmp36 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
														tmp37 := lang.Apply(tmp36, []any{v30})
														var tmp35 any = tmp37
														v30 = tmp35
														continue
													} else {
													}
													tmp29 = tmp31
													break
												}
											} // end let
											tmp26 = tmp29
										} // end let
										_ = tmp26
										tmp27 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
										tmp28 := checkDerefVar(var_glojure_DOT_core_chunk)
										tmp29 := lang.Apply(tmp28, []any{v25})
										tmp30 := checkDerefVar(var_glojure_DOT_core_filter)
										tmp31 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
										tmp32 := lang.Apply(tmp31, []any{v12})
										tmp33 := lang.Apply(tmp30, []any{v3, tmp32})
										tmp34 := lang.Apply(tmp27, []any{tmp29, tmp33})
										tmp16 = tmp34
									} // end let
									tmp13 = tmp16
								} else {
									var tmp17 any
									{ // let
										// let binding "f"
										tmp18 := checkDerefVar(var_glojure_DOT_core_first)
										tmp19 := lang.Apply(tmp18, []any{v12})
										var v20 any = tmp19
										_ = v20
										// let binding "r"
										tmp21 := checkDerefVar(var_glojure_DOT_core_rest)
										tmp22 := lang.Apply(tmp21, []any{v12})
										var v23 any = tmp22
										_ = v23
										var tmp24 any
										tmp25 := lang.Apply(v3, []any{v20})
										if lang.IsTruthy(tmp25) {
											tmp26 := checkDerefVar(var_glojure_DOT_core_cons)
											tmp27 := checkDerefVar(var_glojure_DOT_core_filter)
											tmp28 := lang.Apply(tmp27, []any{v3, v23})
											tmp29 := lang.Apply(tmp26, []any{v20, tmp28})
											tmp24 = tmp29
										} else {
											tmp30 := checkDerefVar(var_glojure_DOT_core_filter)
											tmp31 := lang.Apply(tmp30, []any{v3, v23})
											tmp24 = tmp31
										}
										tmp17 = tmp24
									} // end let
									tmp13 = tmp17
								}
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filter-key
	{
		tmp0 := sym_filter_DASH_key.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_keyfn, sym_pred, sym_amap)), kw_static, true, kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4115), kw_end_DASH_line, int(4117), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "ret"
				tmp7 := lang.NewMap()
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4118), kw_column, int(16), kw_end_DASH_line, int(4118), kw_end_DASH_column, int(17))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v10 any = tmp9
				_ = v10
				// let binding "es"
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := lang.Apply(tmp11, []any{v5})
				var v13 any = tmp12
				_ = v13
				for {
					var tmp14 any
					if lang.IsTruthy(v13) {
						var tmp15 any
						tmp16 := checkDerefVar(var_glojure_DOT_core_first)
						tmp17 := lang.Apply(tmp16, []any{v13})
						tmp18 := lang.Apply(v3, []any{tmp17})
						tmp19 := lang.Apply(v4, []any{tmp18})
						if lang.IsTruthy(tmp19) {
							tmp21 := checkDerefVar(var_glojure_DOT_core_assoc)
							tmp22 := checkDerefVar(var_glojure_DOT_core_key)
							tmp23 := checkDerefVar(var_glojure_DOT_core_first)
							tmp24 := lang.Apply(tmp23, []any{v13})
							tmp25 := lang.Apply(tmp22, []any{tmp24})
							tmp26 := checkDerefVar(var_glojure_DOT_core_val)
							tmp27 := checkDerefVar(var_glojure_DOT_core_first)
							tmp28 := lang.Apply(tmp27, []any{v13})
							tmp29 := lang.Apply(tmp26, []any{tmp28})
							tmp30 := lang.Apply(tmp21, []any{v10, tmp25, tmp29})
							var tmp20 any = tmp30
							tmp32 := checkDerefVar(var_glojure_DOT_core_next)
							tmp33 := lang.Apply(tmp32, []any{v13})
							var tmp31 any = tmp33
							v10 = tmp20
							v13 = tmp31
							continue
						} else {
							var tmp34 any = v10
							tmp36 := checkDerefVar(var_glojure_DOT_core_next)
							tmp37 := lang.Apply(tmp36, []any{v13})
							var tmp35 any = tmp37
							v10 = tmp34
							v13 = tmp35
							continue
						}
						tmp14 = tmp15
					} else {
						tmp14 = v10
					}
					tmp6 = tmp14
					break
				}
			} // end let
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filterv
	{
		tmp0 := sym_filterv.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6961), kw_end_DASH_line, int(6961))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
			tmp6 := checkDerefVar(var_glojure_DOT_core_reduce)
			var tmp7 lang.FnFunc
			tmp7 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v8 := args[0]
				_ = v8
				v9 := args[1]
				_ = v9
				var tmp10 any
				tmp11 := lang.Apply(v3, []any{v9})
				if lang.IsTruthy(tmp11) {
					tmp12 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp13 := lang.Apply(tmp12, []any{v8, v9})
					tmp10 = tmp13
				} else {
					tmp10 = v8
				}
				return tmp10
			})
			tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6967), kw_column, int(15), kw_end_DASH_line, int(6967), kw_end_DASH_column, int(52))
			tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp10 := checkDerefVar(var_glojure_DOT_core_transient)
			tmp11 := lang.NewVector()
			tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6968), kw_column, int(26), kw_end_DASH_line, int(6968), kw_end_DASH_column, int(27))
			tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp14 := lang.Apply(tmp10, []any{tmp13})
			tmp15 := lang.Apply(tmp6, []any{tmp9, tmp14, v4})
			tmp16 := lang.Apply(tmp5, []any{tmp15})
			return tmp16
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find
	{
		tmp0 := sym_find.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map, sym_key)), kw_doc, "Returns the map entry for key, or nil if key not present.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1530), kw_end_DASH_line, int(1530))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime.RT, "Find")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Find is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-keyword
	{
		tmp1 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp0 := sym_find_DASH_keyword.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_name), lang.NewVector(sym_ns, sym_name)), kw_doc, "Returns a Keyword with the given namespace and name if one already\n  exists.  This function will not intern a new keyword. If the keyword\n  has not already been interned, it will return nil.  Do not use :\n  in the keyword strings, it will be added automatically.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(618), kw_end_DASH_line, int(618))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp5 = v4
				} else {
					var tmp8 any
					tmp9 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v4})
					if lang.IsTruthy(tmp10) {
						tmp11 := lang.Apply(nil, []any{v4})
						tmp8 = tmp11
					} else {
						var tmp12 any
						tmp13 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v4})
						if lang.IsTruthy(tmp14) {
							tmp15 := lang.Apply(nil, []any{v4})
							tmp12 = tmp15
						} else {
						}
						tmp8 = tmp12
					}
					tmp5 = tmp8
				}
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(nil, []any{v4, v5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp4 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-ns
	{
		tmp0 := sym_find_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_doc, "Returns the namespace named by the symbol or nil if it doesn't exist.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4125), kw_end_DASH_line, int(4125))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.FindNamespace, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-var
	{
		tmp0 := sym_find_DASH_var.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_doc, "Returns the global var named by the namespace-qualified symbol, or\n  nil if no var with that name.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2013), kw_end_DASH_line, int(2013))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "FindVar")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("FindVar is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// first
	{
		tmp0 := sym_first.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns the first item in the collection. Calls seq on its\n    argument. If coll is nil, returns nil.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(47), kw_end_DASH_line, int(52))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function first
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(lang.First, []any{v4})
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(52), kw_column, int(8), kw_end_DASH_line, int(52), kw_end_DASH_column, int(86))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fits-table?
	{
		tmp0 := sym_fits_DASH_table_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ints)), kw_doc, "Returns true if the collection of ints can fit within the\n  max-table-switch-size, false otherwise.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(8), kw_line, int(6625), kw_end_DASH_line, int(6625), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core__LT_)
			tmp5 := checkDerefVar(var_glojure_DOT_core__DASH_)
			tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp7 := checkDerefVar(var_glojure_DOT_core_max)
			tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp9 := lang.Apply(tmp8, []any{v3})
			tmp10 := lang.Apply(tmp6, []any{tmp7, tmp9})
			tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp12 := checkDerefVar(var_glojure_DOT_core_min)
			tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp14 := lang.Apply(tmp13, []any{v3})
			tmp15 := lang.Apply(tmp11, []any{tmp12, tmp14})
			tmp16 := lang.Apply(tmp5, []any{tmp10, tmp15})
			tmp17 := checkDerefVar(var_glojure_DOT_core_max_DASH_switch_DASH_table_DASH_size)
			tmp18 := lang.Apply(tmp4, []any{tmp16, tmp17})
			return tmp18
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// flatten
	{
		tmp0 := sym_flatten.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat lazy sequence.\n  (flatten nil) returns an empty sequence.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(7118), kw_end_DASH_line, int(7118))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_filter)
			tmp5 := checkDerefVar(var_glojure_DOT_core_complement)
			tmp6 := checkDerefVar(var_glojure_DOT_core_sequential_QMARK_)
			tmp7 := lang.Apply(tmp5, []any{tmp6})
			tmp8 := checkDerefVar(var_glojure_DOT_core_rest)
			tmp9 := checkDerefVar(var_glojure_DOT_core_tree_DASH_seq)
			tmp10 := checkDerefVar(var_glojure_DOT_core_sequential_QMARK_)
			tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp12 := lang.Apply(tmp9, []any{tmp10, tmp11, v3})
			tmp13 := lang.Apply(tmp8, []any{tmp12})
			tmp14 := lang.Apply(tmp4, []any{tmp7, tmp13})
			return tmp14
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float
	{
		var tmp1 lang.FnFunc
		{ // function float__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_uncheckedFloatCast
				} else {
					tmp14 = sym_floatCast
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_float.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to float", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3487), kw_end_DASH_line, int(3487))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.FloatCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float-array
	{
		var tmp1 lang.FnFunc
		{ // function float-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_FloatArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_float_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of floats", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(5301), kw_end_DASH_line, int(5301))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "FloatArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("FloatArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "FloatArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("FloatArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float?
	{
		tmp0 := sym_float_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is a floating point number", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3605), kw_end_DASH_line, int(3605))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{lang.Builtins["float64"], v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp8 = v7
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{lang.Builtins["float32"], v3})
					tmp8 = tmp10
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// floats
	{
		var tmp1 lang.FnFunc
		{ // function floats
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_Floats})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_floats.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to float[]", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(12), kw_line, int(5392), kw_end_DASH_line, int(5392))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Floats")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Floats is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// flush
	{
		tmp0 := sym_flush.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Flushes the output stream that is the current value of\n  *out*", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3706), kw_end_DASH_line, int(3706))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := checkDerefVar(var_glojure_DOT_core__STAR_out_STAR_)
			tmp4, _ := lang.FieldOrMethod(tmp3, "Sync")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Sync is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			_ = tmp5
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fn
	{
		tmp0 := sym_fn.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_sigs)), kw_doc, "params => positional-params*, or positional-params* & rest-param\n  positional-param => binding-form\n  rest-param => binding-form\n  binding-form => name, or destructuring-form\n\n  Defines a function.\n\n  See https://glojure.org/reference/special_forms#fn for more information", kw_forms, lang.NewVector(lang.NewList(sym_fn, sym_name_QMARK_, lang.NewVector(sym_params_STAR_), sym_exprs_STAR_), lang.NewList(sym_fn, sym_name_QMARK_, lang.NewList(lang.NewVector(sym_params_STAR_), sym_exprs_STAR_), sym__PLUS_)), kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(4533), kw_end_DASH_line, int(4533), kw_special_DASH_form, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "name"
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
					tmp9 := checkDerefVar(var_glojure_DOT_core_first)
					tmp10 := lang.Apply(tmp9, []any{v5})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_first)
						tmp13 := lang.Apply(tmp12, []any{v5})
						tmp7 = tmp13
					} else {
					}
					var v14 any = tmp7
					_ = v14
					// let binding "sigs"
					var tmp15 any
					if lang.IsTruthy(v14) {
						tmp16 := checkDerefVar(var_glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v5})
						tmp15 = tmp17
					} else {
						tmp15 = v5
					}
					var v18 any = tmp15
					_ = v18
					// let binding "sigs"
					var tmp19 any
					tmp20 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
					tmp21 := checkDerefVar(var_glojure_DOT_core_first)
					tmp22 := lang.Apply(tmp21, []any{v18})
					tmp23 := lang.Apply(tmp20, []any{tmp22})
					if lang.IsTruthy(tmp23) {
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v18})
						tmp19 = tmp25
					} else {
						var tmp26 any
						tmp27 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp28 := checkDerefVar(var_glojure_DOT_core_first)
						tmp29 := lang.Apply(tmp28, []any{v18})
						tmp30 := lang.Apply(tmp27, []any{tmp29})
						if lang.IsTruthy(tmp30) {
							tmp26 = v18
						} else {
							var tmp31 any
							tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp33 := lang.Apply(tmp32, []any{v18})
							if lang.IsTruthy(tmp33) {
								tmp34 := checkDerefVar(var_glojure_DOT_core_str)
								tmp35 := checkDerefVar(var_glojure_DOT_core_first)
								tmp36 := lang.Apply(tmp35, []any{v18})
								tmp37 := lang.Apply(tmp34, []any{"Parameter declaration ", tmp36, " should be a vector"})
								tmp31 = tmp37
							} else {
								tmp38 := checkDerefVar(var_glojure_DOT_core_str)
								tmp39 := lang.Apply(tmp38, []any{"Parameter declaration missing"})
								tmp31 = tmp39
							}
							tmp40 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
							panic(tmp40)
						}
						tmp19 = tmp26
					}
					var v41 any = tmp19
					_ = v41
					// let binding "psig"
					var tmp42 lang.FnFunc
					tmp42 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v43 := args[0]
						_ = v43
						var tmp44 any
						tmp45 := checkDerefVar(var_glojure_DOT_core_not)
						tmp46 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp47 := lang.Apply(tmp46, []any{v43})
						tmp48 := lang.Apply(tmp45, []any{tmp47})
						if lang.IsTruthy(tmp48) {
							tmp49 := checkDerefVar(var_glojure_DOT_core_str)
							tmp50 := lang.Apply(tmp49, []any{"Invalid signature ", v43, " should be a list"})
							tmp51 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp50})
							panic(tmp51)
						} else {
						}
						_ = tmp44
						var tmp52 any
						{ // let
							// let binding "vec__13"
							var v53 any = v43
							_ = v53
							// let binding "seq__14"
							tmp54 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp55 := lang.Apply(tmp54, []any{v53})
							var v56 any = tmp55
							_ = v56
							// let binding "first__15"
							tmp57 := checkDerefVar(var_glojure_DOT_core_first)
							tmp58 := lang.Apply(tmp57, []any{v56})
							var v59 any = tmp58
							_ = v59
							// let binding "seq__14"
							tmp60 := checkDerefVar(var_glojure_DOT_core_next)
							tmp61 := lang.Apply(tmp60, []any{v56})
							var v62 any = tmp61
							_ = v62
							// let binding "params"
							var v63 any = v59
							_ = v63
							// let binding "body"
							var v64 any = v62
							_ = v64
							// let binding "_"
							var tmp65 any
							tmp66 := checkDerefVar(var_glojure_DOT_core_not)
							tmp67 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
							tmp68 := lang.Apply(tmp67, []any{v63})
							tmp69 := lang.Apply(tmp66, []any{tmp68})
							if lang.IsTruthy(tmp69) {
								var tmp70 any
								tmp71 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
								tmp72 := checkDerefVar(var_glojure_DOT_core_first)
								tmp73 := lang.Apply(tmp72, []any{v41})
								tmp74 := lang.Apply(tmp71, []any{tmp73})
								if lang.IsTruthy(tmp74) {
									tmp75 := checkDerefVar(var_glojure_DOT_core_str)
									tmp76 := lang.Apply(tmp75, []any{"Parameter declaration ", v63, " should be a vector"})
									tmp70 = tmp76
								} else {
									tmp77 := checkDerefVar(var_glojure_DOT_core_str)
									tmp78 := lang.Apply(tmp77, []any{"Invalid signature ", v43, " should be a list"})
									tmp70 = tmp78
								}
								tmp79 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp70})
								panic(tmp79)
							} else {
							}
							var v80 any = tmp65
							_ = v80
							// let binding "conds"
							var tmp81 any
							var tmp82 any
							{ // let
								// let binding "and__0__auto__"
								tmp83 := checkDerefVar(var_glojure_DOT_core_next)
								tmp84 := lang.Apply(tmp83, []any{v64})
								var v85 any = tmp84
								_ = v85
								var tmp86 any
								if lang.IsTruthy(v85) {
									tmp87 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
									tmp88 := checkDerefVar(var_glojure_DOT_core_first)
									tmp89 := lang.Apply(tmp88, []any{v64})
									tmp90 := lang.Apply(tmp87, []any{tmp89})
									tmp86 = tmp90
								} else {
									tmp86 = v85
								}
								tmp82 = tmp86
							} // end let
							if lang.IsTruthy(tmp82) {
								tmp83 := checkDerefVar(var_glojure_DOT_core_first)
								tmp84 := lang.Apply(tmp83, []any{v64})
								tmp81 = tmp84
							} else {
							}
							var v85 any = tmp81
							_ = v85
							// let binding "body"
							var tmp86 any
							if lang.IsTruthy(v85) {
								tmp87 := checkDerefVar(var_glojure_DOT_core_next)
								tmp88 := lang.Apply(tmp87, []any{v64})
								tmp86 = tmp88
							} else {
								tmp86 = v64
							}
							var v89 any = tmp86
							_ = v89
							// let binding "conds"
							var tmp90 any
							{ // let
								// let binding "or__0__auto__"
								var v91 any = v85
								_ = v91
								var tmp92 any
								if lang.IsTruthy(v91) {
									tmp92 = v91
								} else {
									tmp93 := checkDerefVar(var_glojure_DOT_core_meta)
									tmp94 := lang.Apply(tmp93, []any{v63})
									tmp92 = tmp94
								}
								tmp90 = tmp92
							} // end let
							var v91 any = tmp90
							_ = v91
							// let binding "pre"
							tmp92 := lang.Apply(kw_pre, []any{v91})
							var v93 any = tmp92
							_ = v93
							// let binding "post"
							tmp94 := lang.Apply(kw_post, []any{v91})
							var v95 any = tmp94
							_ = v95
							// let binding "body"
							var tmp96 any
							if lang.IsTruthy(v95) {
								tmp97 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp98 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp99 := checkDerefVar(var_glojure_DOT_core_list)
								tmp100 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp101 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp102 := checkDerefVar(var_glojure_DOT_core_list)
								tmp103 := lang.Apply(tmp102, []any{sym_glojure_DOT_core_SLASH_let})
								tmp104 := checkDerefVar(var_glojure_DOT_core_list)
								tmp105 := checkDerefVar(var_glojure_DOT_core_apply)
								tmp106 := checkDerefVar(var_glojure_DOT_core_vector)
								tmp107 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp108 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp109 := checkDerefVar(var_glojure_DOT_core_list)
								tmp110 := lang.Apply(tmp109, []any{sym__PCT_})
								tmp111 := checkDerefVar(var_glojure_DOT_core_list)
								var tmp112 any
								tmp113 := checkDerefVar(var_glojure_DOT_core__LT_)
								tmp114 := checkDerefVar(var_glojure_DOT_core_count)
								tmp115 := lang.Apply(tmp114, []any{v89})
								tmp116 := lang.Apply(tmp113, []any{int64(1), tmp115})
								if lang.IsTruthy(tmp116) {
									tmp117 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp118 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp119 := checkDerefVar(var_glojure_DOT_core_list)
									tmp120 := lang.Apply(tmp119, []any{sym_do})
									tmp121 := lang.Apply(tmp118, []any{tmp120, v89})
									tmp122 := lang.Apply(tmp117, []any{tmp121})
									tmp112 = tmp122
								} else {
									tmp123 := checkDerefVar(var_glojure_DOT_core_first)
									tmp124 := lang.Apply(tmp123, []any{v89})
									tmp112 = tmp124
								}
								tmp125 := lang.Apply(tmp111, []any{tmp112})
								tmp126 := lang.Apply(tmp108, []any{tmp110, tmp125})
								tmp127 := lang.Apply(tmp107, []any{tmp126})
								tmp128 := lang.Apply(tmp105, []any{tmp106, tmp127})
								tmp129 := lang.Apply(tmp104, []any{tmp128})
								tmp130 := checkDerefVar(var_glojure_DOT_core_map)
								var tmp131 lang.FnFunc
								tmp131 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v132 := args[0]
									_ = v132
									tmp133 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp134 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp135 := checkDerefVar(var_glojure_DOT_core_list)
									tmp136 := lang.Apply(tmp135, []any{sym_glojure_DOT_core_SLASH_assert})
									tmp137 := checkDerefVar(var_glojure_DOT_core_list)
									tmp138 := lang.Apply(tmp137, []any{v132})
									tmp139 := lang.Apply(tmp134, []any{tmp136, tmp138})
									tmp140 := lang.Apply(tmp133, []any{tmp139})
									return tmp140
								})
								tmp132 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4582), kw_column, int(41), kw_end_DASH_line, int(4582), kw_end_DASH_column, int(62))
								tmp133, err := lang.WithMeta(tmp131, tmp132.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp134 := lang.Apply(tmp130, []any{tmp133, v95})
								tmp135 := checkDerefVar(var_glojure_DOT_core_list)
								tmp136 := lang.Apply(tmp135, []any{sym__PCT_})
								tmp137 := lang.Apply(tmp101, []any{tmp103, tmp129, tmp134, tmp136})
								tmp138 := lang.Apply(tmp100, []any{tmp137})
								tmp139 := lang.Apply(tmp99, []any{tmp138})
								tmp140 := lang.Apply(tmp98, []any{tmp139})
								tmp141 := lang.Apply(tmp97, []any{tmp140})
								tmp96 = tmp141
							} else {
								tmp96 = v89
							}
							var v142 any = tmp96
							_ = v142
							// let binding "body"
							var tmp143 any
							if lang.IsTruthy(v93) {
								tmp144 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp145 := checkDerefVar(var_glojure_DOT_core_map)
								var tmp146 lang.FnFunc
								tmp146 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v147 := args[0]
									_ = v147
									tmp148 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp149 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp150 := checkDerefVar(var_glojure_DOT_core_list)
									tmp151 := lang.Apply(tmp150, []any{sym_glojure_DOT_core_SLASH_assert})
									tmp152 := checkDerefVar(var_glojure_DOT_core_list)
									tmp153 := lang.Apply(tmp152, []any{v147})
									tmp154 := lang.Apply(tmp149, []any{tmp151, tmp153})
									tmp155 := lang.Apply(tmp148, []any{tmp154})
									return tmp155
								})
								tmp147 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4586), kw_column, int(44), kw_end_DASH_line, int(4586), kw_end_DASH_column, int(65))
								tmp148, err := lang.WithMeta(tmp146, tmp147.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp149 := lang.Apply(tmp145, []any{tmp148, v93})
								tmp150 := lang.Apply(tmp144, []any{tmp149, v142})
								tmp143 = tmp150
							} else {
								tmp143 = v142
							}
							var v151 any = tmp143
							_ = v151
							tmp152 := checkDerefVar(var_glojure_DOT_core_maybe_DASH_destructured)
							tmp153 := lang.Apply(tmp152, []any{v63, v151})
							tmp52 = tmp153
						} // end let
						return tmp52
					})
					tmp43 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4558), kw_column, int(16), kw_end_DASH_line, int(4589), kw_end_DASH_column, int(53))
					tmp44, err := lang.WithMeta(tmp42, tmp43.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v45 any = tmp44
					_ = v45
					// let binding "new-sigs"
					tmp46 := checkDerefVar(var_glojure_DOT_core_map)
					tmp47 := lang.Apply(tmp46, []any{v45, v41})
					var v48 any = tmp47
					_ = v48
					tmp49 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					var tmp50 any
					if lang.IsTruthy(v14) {
						tmp51 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
						tmp52 := lang.Apply(tmp51, []any{sym_fn_STAR_, v14, v48})
						tmp50 = tmp52
					} else {
						tmp53 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp54 := lang.Apply(tmp53, []any{sym_fn_STAR_, v48})
						tmp50 = tmp54
					}
					tmp55 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp56 := lang.Apply(tmp55, []any{v3})
					tmp57 := lang.Apply(tmp49, []any{tmp50, tmp56})
					tmp6 = tmp57
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fn?
	{
		tmp0 := sym_fn_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x implements Fn, i.e. is an object created via fn.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(6216), kw_end_DASH_line, int(6216))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*runtime.Fn)(nil))
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fnext
	{
		tmp0 := sym_fnext.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Same as (first (next x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(112), kw_end_DASH_line, int(116))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function fnext
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_first)
				tmp6 := checkDerefVar(var_glojure_DOT_core_next)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(116), kw_column, int(8), kw_end_DASH_line, int(116), kw_end_DASH_column, int(47))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fnil
	{
		tmp0 := sym_fnil.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_x), lang.NewVector(sym_f, sym_x, sym_y), lang.NewVector(sym_f, sym_x, sym_y, sym_z)), kw_doc, "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6558), kw_end_DASH_line, int(6558))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 1:
						v6 := args[0]
						_ = v6
						var tmp7 any
						tmp8 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp9 := lang.Apply(tmp8, []any{v6})
						if lang.IsTruthy(tmp9) {
							tmp7 = v4
						} else {
							tmp7 = v6
						}
						tmp10 := lang.Apply(v3, []any{tmp7})
						return tmp10
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						var tmp8 any
						tmp9 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp10 := lang.Apply(tmp9, []any{v6})
						if lang.IsTruthy(tmp10) {
							tmp8 = v4
						} else {
							tmp8 = v6
						}
						tmp11 := lang.Apply(v3, []any{tmp8, v7})
						return tmp11
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var tmp9 any
						tmp10 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v6})
						if lang.IsTruthy(tmp11) {
							tmp9 = v4
						} else {
							tmp9 = v6
						}
						tmp12 := lang.Apply(v3, []any{tmp9, v7, v8})
						return tmp12
					default:
						checkArity(args, 3)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v6})
						if lang.IsTruthy(tmp13) {
							tmp11 = v4
						} else {
							tmp11 = v6
						}
						tmp14 := lang.Apply(tmp10, []any{v3, tmp11, v7, v8, v9})
						return tmp14
					}
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6567), kw_column, int(4), kw_end_DASH_line, int(6571), kw_end_DASH_column, int(55))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						var tmp9 any
						tmp10 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v7})
						if lang.IsTruthy(tmp11) {
							tmp9 = v4
						} else {
							tmp9 = v7
						}
						var tmp12 any
						tmp13 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v8})
						if lang.IsTruthy(tmp14) {
							tmp12 = v5
						} else {
							tmp12 = v8
						}
						tmp15 := lang.Apply(v3, []any{tmp9, tmp12})
						return tmp15
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var tmp10 any
						tmp11 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v7})
						if lang.IsTruthy(tmp12) {
							tmp10 = v4
						} else {
							tmp10 = v7
						}
						var tmp13 any
						tmp14 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp15 := lang.Apply(tmp14, []any{v8})
						if lang.IsTruthy(tmp15) {
							tmp13 = v5
						} else {
							tmp13 = v8
						}
						tmp16 := lang.Apply(v3, []any{tmp10, tmp13, v9})
						return tmp16
					default:
						checkArity(args, 3)
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
						var tmp12 any
						tmp13 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v7})
						if lang.IsTruthy(tmp14) {
							tmp12 = v4
						} else {
							tmp12 = v7
						}
						var tmp15 any
						tmp16 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp17 := lang.Apply(tmp16, []any{v8})
						if lang.IsTruthy(tmp17) {
							tmp15 = v5
						} else {
							tmp15 = v8
						}
						tmp18 := lang.Apply(tmp11, []any{v3, tmp12, tmp15, v9, v10})
						return tmp18
					}
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6573), kw_column, int(4), kw_end_DASH_line, int(6576), kw_end_DASH_column, int(71))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 2:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						var tmp10 any
						tmp11 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v8})
						if lang.IsTruthy(tmp12) {
							tmp10 = v4
						} else {
							tmp10 = v8
						}
						var tmp13 any
						tmp14 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp15 := lang.Apply(tmp14, []any{v9})
						if lang.IsTruthy(tmp15) {
							tmp13 = v5
						} else {
							tmp13 = v9
						}
						tmp16 := lang.Apply(v3, []any{tmp10, tmp13})
						return tmp16
					case 3:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v8})
						if lang.IsTruthy(tmp13) {
							tmp11 = v4
						} else {
							tmp11 = v8
						}
						var tmp14 any
						tmp15 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp16 := lang.Apply(tmp15, []any{v9})
						if lang.IsTruthy(tmp16) {
							tmp14 = v5
						} else {
							tmp14 = v9
						}
						var tmp17 any
						tmp18 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v10})
						if lang.IsTruthy(tmp19) {
							tmp17 = v6
						} else {
							tmp17 = v10
						}
						tmp20 := lang.Apply(v3, []any{tmp11, tmp14, tmp17})
						return tmp20
					default:
						checkArity(args, 3)
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var v11 any = lang.NewList(args[3:]...)
						_ = v11
						tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
						var tmp13 any
						tmp14 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp15 := lang.Apply(tmp14, []any{v8})
						if lang.IsTruthy(tmp15) {
							tmp13 = v4
						} else {
							tmp13 = v8
						}
						var tmp16 any
						tmp17 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp18 := lang.Apply(tmp17, []any{v9})
						if lang.IsTruthy(tmp18) {
							tmp16 = v5
						} else {
							tmp16 = v9
						}
						var tmp19 any
						tmp20 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
						tmp21 := lang.Apply(tmp20, []any{v10})
						if lang.IsTruthy(tmp21) {
							tmp19 = v6
						} else {
							tmp19 = v10
						}
						tmp22 := lang.Apply(tmp12, []any{v3, tmp13, tmp16, tmp19, v11})
						return tmp22
					}
				})
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6578), kw_column, int(4), kw_end_DASH_line, int(6581), kw_end_DASH_column, int(87))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp9
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// for
	{
		tmp0 := sym_for.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_seq_DASH_exprs, sym_body_DASH_expr)), kw_doc, "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(11), kw_line, int(4646), kw_end_DASH_line, int(4646))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			var tmp7 any
			tmp8 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
			tmp9 := lang.Apply(tmp8, []any{v5})
			if lang.IsTruthy(tmp9) {
			} else {
				tmp10 := checkDerefVar(var_glojure_DOT_core_str)
				tmp11 := checkDerefVar(var_glojure_DOT_core_first)
				tmp12 := lang.Apply(tmp11, []any{v3})
				tmp13 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
				tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp15 := lang.Apply(tmp14, []any{v3})
				tmp16 := lang.Apply(kw_line, []any{tmp15})
				tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
				tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
				panic(tmp18)
			}
			_ = tmp7
			var tmp19 any
			tmp20 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
			tmp21 := checkDerefVar(var_glojure_DOT_core_count)
			tmp22 := lang.Apply(tmp21, []any{v5})
			tmp23 := lang.Apply(tmp20, []any{tmp22})
			if lang.IsTruthy(tmp23) {
			} else {
				tmp24 := checkDerefVar(var_glojure_DOT_core_str)
				tmp25 := checkDerefVar(var_glojure_DOT_core_first)
				tmp26 := lang.Apply(tmp25, []any{v3})
				tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
				tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp29 := lang.Apply(tmp28, []any{v3})
				tmp30 := lang.Apply(kw_line, []any{tmp29})
				tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
				tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
				panic(tmp32)
			}
			_ = tmp19
			var tmp33 any
			{ // let
				// let binding "to-groups"
				var tmp34 lang.FnFunc
				tmp34 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v35 := args[0]
					_ = v35
					tmp36 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp37 lang.FnFunc
					tmp37 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v38 := args[0]
						_ = v38
						v39 := args[1]
						_ = v39
						var tmp40 any
						{ // let
							// let binding "vec__24"
							var v41 any = v39
							_ = v41
							// let binding "k"
							tmp42 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp43 := lang.Apply(tmp42, []any{v41, int64(0), nil})
							var v44 any = tmp43
							_ = v44
							// let binding "v"
							tmp45 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp46 := lang.Apply(tmp45, []any{v41, int64(1), nil})
							var v47 any = tmp46
							_ = v47
							var tmp48 any
							tmp49 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
							tmp50 := lang.Apply(tmp49, []any{v44})
							if lang.IsTruthy(tmp50) {
								tmp51 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp52 := checkDerefVar(var_glojure_DOT_core_pop)
								tmp53 := lang.Apply(tmp52, []any{v38})
								tmp54 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp55 := checkDerefVar(var_glojure_DOT_core_peek)
								tmp56 := lang.Apply(tmp55, []any{v38})
								tmp57 := lang.NewVector(v44, v47)
								tmp58 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4664), kw_column, int(72), kw_end_DASH_line, int(4664), kw_end_DASH_column, int(76))
								tmp59, err := lang.WithMeta(tmp57, tmp58.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp60 := lang.Apply(tmp54, []any{tmp56, tmp59})
								tmp61 := lang.Apply(tmp51, []any{tmp53, tmp60})
								tmp48 = tmp61
							} else {
								tmp62 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp63 := lang.NewVector(v44, v47)
								tmp64 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4665), kw_column, int(46), kw_end_DASH_line, int(4665), kw_end_DASH_column, int(50))
								tmp65, err := lang.WithMeta(tmp63, tmp64.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp66 := lang.Apply(tmp62, []any{v38, tmp65})
								tmp48 = tmp66
							}
							tmp40 = tmp48
						} // end let
						return tmp40
					})
					tmp38 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4662), kw_column, int(30), kw_end_DASH_line, int(4665), kw_end_DASH_column, int(53))
					tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp40 := lang.NewVector()
					tmp41 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4666), kw_column, int(29), kw_end_DASH_line, int(4666), kw_end_DASH_column, int(30))
					tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp43 := checkDerefVar(var_glojure_DOT_core_partition)
					tmp44 := lang.Apply(tmp43, []any{int64(2), v35})
					tmp45 := lang.Apply(tmp36, []any{tmp39, tmp42, tmp44})
					return tmp45
				})
				tmp35 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4661), kw_column, int(19), kw_end_DASH_line, int(4666), kw_end_DASH_column, int(56))
				tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v37 any = tmp36
				_ = v37
				// let binding "err"
				var tmp38 lang.FnFunc
				tmp38 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						checkArity(args, 0)
						var v39 any = lang.NewList(args[0:]...)
						_ = v39
						tmp40 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp41 := checkDerefVar(var_glojure_DOT_core_str)
						tmp42 := lang.Apply(tmp40, []any{tmp41, v39})
						tmp43 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp42})
						panic(tmp43)
					}
				})
				tmp39 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4667), kw_column, int(13), kw_end_DASH_line, int(4667), kw_end_DASH_column, int(125))
				tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v41 any = tmp40
				_ = v41
				// let binding "emit-bind"
				var tmp42 lang.FnFunc
				{ // function emit-bind
					var v43 lang.FnFunc
					tmp42 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v44 := args[0]
						_ = v44
						var tmp45 any
						{ // let
							// let binding "vec__28"
							var v46 any = v44
							_ = v46
							// let binding "seq__29"
							tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp48 := lang.Apply(tmp47, []any{v46})
							var v49 any = tmp48
							_ = v49
							// let binding "first__30"
							tmp50 := checkDerefVar(var_glojure_DOT_core_first)
							tmp51 := lang.Apply(tmp50, []any{v49})
							var v52 any = tmp51
							_ = v52
							// let binding "seq__29"
							tmp53 := checkDerefVar(var_glojure_DOT_core_next)
							tmp54 := lang.Apply(tmp53, []any{v49})
							var v55 any = tmp54
							_ = v55
							// let binding "vec__31"
							var v56 any = v52
							_ = v56
							// let binding "seq__32"
							tmp57 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp58 := lang.Apply(tmp57, []any{v56})
							var v59 any = tmp58
							_ = v59
							// let binding "first__33"
							tmp60 := checkDerefVar(var_glojure_DOT_core_first)
							tmp61 := lang.Apply(tmp60, []any{v59})
							var v62 any = tmp61
							_ = v62
							// let binding "seq__32"
							tmp63 := checkDerefVar(var_glojure_DOT_core_next)
							tmp64 := lang.Apply(tmp63, []any{v59})
							var v65 any = tmp64
							_ = v65
							// let binding "bind"
							var v66 any = v62
							_ = v66
							// let binding "first__33"
							tmp67 := checkDerefVar(var_glojure_DOT_core_first)
							tmp68 := lang.Apply(tmp67, []any{v65})
							var v69 any = tmp68
							_ = v69
							// let binding "seq__32"
							tmp70 := checkDerefVar(var_glojure_DOT_core_next)
							tmp71 := lang.Apply(tmp70, []any{v65})
							var v72 any = tmp71
							_ = v72
							// let binding "expr"
							var v73 any = v69
							_ = v73
							// let binding "mod-pairs"
							var v74 any = v72
							_ = v74
							// let binding "vec__34"
							var v75 any = v55
							_ = v75
							// let binding "vec__37"
							tmp76 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp77 := lang.Apply(tmp76, []any{v75, int64(0), nil})
							var v78 any = tmp77
							_ = v78
							// let binding "_"
							tmp79 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp80 := lang.Apply(tmp79, []any{v78, int64(0), nil})
							var v81 any = tmp80
							_ = v81
							// let binding "next-expr"
							tmp82 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp83 := lang.Apply(tmp82, []any{v78, int64(1), nil})
							var v84 any = tmp83
							_ = v84
							// let binding "next-groups"
							var v85 any = v75
							_ = v85
							var tmp86 any
							{ // let
								// let binding "giter"
								tmp87 := checkDerefVar(var_glojure_DOT_core_gensym)
								tmp88 := lang.Apply(tmp87, []any{"iter__"})
								var v89 any = tmp88
								_ = v89
								// let binding "gxs"
								tmp90 := checkDerefVar(var_glojure_DOT_core_gensym)
								tmp91 := lang.Apply(tmp90, []any{"s__"})
								var v92 any = tmp91
								_ = v92
								// let binding "do-mod"
								var tmp93 lang.FnFunc
								{ // function do-mod
									var v94 lang.FnFunc
									tmp93 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v95 := args[0]
										_ = v95
										var tmp96 any
										{ // let
											// let binding "vec__41"
											var v97 any = v95
											_ = v97
											// let binding "seq__42"
											tmp98 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp99 := lang.Apply(tmp98, []any{v97})
											var v100 any = tmp99
											_ = v100
											// let binding "first__43"
											tmp101 := checkDerefVar(var_glojure_DOT_core_first)
											tmp102 := lang.Apply(tmp101, []any{v100})
											var v103 any = tmp102
											_ = v103
											// let binding "seq__42"
											tmp104 := checkDerefVar(var_glojure_DOT_core_next)
											tmp105 := lang.Apply(tmp104, []any{v100})
											var v106 any = tmp105
											_ = v106
											// let binding "vec__44"
											var v107 any = v103
											_ = v107
											// let binding "k"
											tmp108 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp109 := lang.Apply(tmp108, []any{v107, int64(0), nil})
											var v110 any = tmp109
											_ = v110
											// let binding "v"
											tmp111 := checkDerefVar(var_glojure_DOT_core_nth)
											tmp112 := lang.Apply(tmp111, []any{v107, int64(1), nil})
											var v113 any = tmp112
											_ = v113
											// let binding "pair"
											var v114 any = v107
											_ = v114
											// let binding "etc"
											var v115 any = v106
											_ = v115
											var tmp116 any
											tmp117 := checkDerefVar(var_glojure_DOT_core__EQ_)
											tmp118 := lang.Apply(tmp117, []any{v110, kw_let})
											if lang.IsTruthy(tmp118) {
												tmp119 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp120 := checkDerefVar(var_glojure_DOT_core_concat)
												tmp121 := checkDerefVar(var_glojure_DOT_core_list)
												tmp122 := lang.Apply(tmp121, []any{sym_glojure_DOT_core_SLASH_let})
												tmp123 := checkDerefVar(var_glojure_DOT_core_list)
												tmp124 := lang.Apply(tmp123, []any{v113})
												tmp125 := checkDerefVar(var_glojure_DOT_core_list)
												tmp126 := lang.Apply(v94, []any{v115})
												tmp127 := lang.Apply(tmp125, []any{tmp126})
												tmp128 := lang.Apply(tmp120, []any{tmp122, tmp124, tmp127})
												tmp129 := lang.Apply(tmp119, []any{tmp128})
												tmp116 = tmp129
											} else {
												var tmp130 any
												tmp131 := checkDerefVar(var_glojure_DOT_core__EQ_)
												tmp132 := lang.Apply(tmp131, []any{v110, kw_while})
												if lang.IsTruthy(tmp132) {
													tmp133 := checkDerefVar(var_glojure_DOT_core_seq)
													tmp134 := checkDerefVar(var_glojure_DOT_core_concat)
													tmp135 := checkDerefVar(var_glojure_DOT_core_list)
													tmp136 := lang.Apply(tmp135, []any{sym_glojure_DOT_core_SLASH_when})
													tmp137 := checkDerefVar(var_glojure_DOT_core_list)
													tmp138 := lang.Apply(tmp137, []any{v113})
													tmp139 := checkDerefVar(var_glojure_DOT_core_list)
													tmp140 := lang.Apply(v94, []any{v115})
													tmp141 := lang.Apply(tmp139, []any{tmp140})
													tmp142 := lang.Apply(tmp134, []any{tmp136, tmp138, tmp141})
													tmp143 := lang.Apply(tmp133, []any{tmp142})
													tmp130 = tmp143
												} else {
													var tmp144 any
													tmp145 := checkDerefVar(var_glojure_DOT_core__EQ_)
													tmp146 := lang.Apply(tmp145, []any{v110, kw_when})
													if lang.IsTruthy(tmp146) {
														tmp147 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp148 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp149 := checkDerefVar(var_glojure_DOT_core_list)
														tmp150 := lang.Apply(tmp149, []any{sym_if})
														tmp151 := checkDerefVar(var_glojure_DOT_core_list)
														tmp152 := lang.Apply(tmp151, []any{v113})
														tmp153 := checkDerefVar(var_glojure_DOT_core_list)
														tmp154 := lang.Apply(v94, []any{v115})
														tmp155 := lang.Apply(tmp153, []any{tmp154})
														tmp156 := checkDerefVar(var_glojure_DOT_core_list)
														tmp157 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp158 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp159 := checkDerefVar(var_glojure_DOT_core_list)
														tmp160 := lang.Apply(tmp159, []any{sym_recur})
														tmp161 := checkDerefVar(var_glojure_DOT_core_list)
														tmp162 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp163 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp164 := checkDerefVar(var_glojure_DOT_core_list)
														tmp165 := lang.Apply(tmp164, []any{sym_glojure_DOT_core_SLASH_rest})
														tmp166 := checkDerefVar(var_glojure_DOT_core_list)
														tmp167 := lang.Apply(tmp166, []any{v92})
														tmp168 := lang.Apply(tmp163, []any{tmp165, tmp167})
														tmp169 := lang.Apply(tmp162, []any{tmp168})
														tmp170 := lang.Apply(tmp161, []any{tmp169})
														tmp171 := lang.Apply(tmp158, []any{tmp160, tmp170})
														tmp172 := lang.Apply(tmp157, []any{tmp171})
														tmp173 := lang.Apply(tmp156, []any{tmp172})
														tmp174 := lang.Apply(tmp148, []any{tmp150, tmp152, tmp155, tmp173})
														tmp175 := lang.Apply(tmp147, []any{tmp174})
														tmp144 = tmp175
													} else {
														var tmp176 any
														tmp177 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
														tmp178 := lang.Apply(tmp177, []any{v110})
														if lang.IsTruthy(tmp178) {
															tmp179 := lang.Apply(v41, []any{"Invalid 'for' keyword ", v110})
															tmp176 = tmp179
														} else {
															var tmp180 any
															if lang.IsTruthy(v85) {
																tmp181 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp182 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp183 := checkDerefVar(var_glojure_DOT_core_list)
																tmp184 := lang.Apply(tmp183, []any{sym_glojure_DOT_core_SLASH_let})
																tmp185 := checkDerefVar(var_glojure_DOT_core_list)
																tmp186 := checkDerefVar(var_glojure_DOT_core_apply)
																tmp187 := checkDerefVar(var_glojure_DOT_core_vector)
																tmp188 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp189 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp190 := checkDerefVar(var_glojure_DOT_core_list)
																tmp191 := lang.Apply(tmp190, []any{sym_iterys__0__auto__})
																tmp192 := checkDerefVar(var_glojure_DOT_core_list)
																tmp193 := lang.Apply(v43, []any{v85})
																tmp194 := lang.Apply(tmp192, []any{tmp193})
																tmp195 := checkDerefVar(var_glojure_DOT_core_list)
																tmp196 := lang.Apply(tmp195, []any{sym_fs__1__auto__})
																tmp197 := checkDerefVar(var_glojure_DOT_core_list)
																tmp198 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp199 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp200 := checkDerefVar(var_glojure_DOT_core_list)
																tmp201 := lang.Apply(tmp200, []any{sym_glojure_DOT_core_SLASH_seq})
																tmp202 := checkDerefVar(var_glojure_DOT_core_list)
																tmp203 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp204 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp205 := checkDerefVar(var_glojure_DOT_core_list)
																tmp206 := lang.Apply(tmp205, []any{sym_iterys__0__auto__})
																tmp207 := checkDerefVar(var_glojure_DOT_core_list)
																tmp208 := lang.Apply(tmp207, []any{v84})
																tmp209 := lang.Apply(tmp204, []any{tmp206, tmp208})
																tmp210 := lang.Apply(tmp203, []any{tmp209})
																tmp211 := lang.Apply(tmp202, []any{tmp210})
																tmp212 := lang.Apply(tmp199, []any{tmp201, tmp211})
																tmp213 := lang.Apply(tmp198, []any{tmp212})
																tmp214 := lang.Apply(tmp197, []any{tmp213})
																tmp215 := lang.Apply(tmp189, []any{tmp191, tmp194, tmp196, tmp214})
																tmp216 := lang.Apply(tmp188, []any{tmp215})
																tmp217 := lang.Apply(tmp186, []any{tmp187, tmp216})
																tmp218 := lang.Apply(tmp185, []any{tmp217})
																tmp219 := checkDerefVar(var_glojure_DOT_core_list)
																tmp220 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp221 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp222 := checkDerefVar(var_glojure_DOT_core_list)
																tmp223 := lang.Apply(tmp222, []any{sym_if})
																tmp224 := checkDerefVar(var_glojure_DOT_core_list)
																tmp225 := lang.Apply(tmp224, []any{sym_fs__1__auto__})
																tmp226 := checkDerefVar(var_glojure_DOT_core_list)
																tmp227 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp228 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp229 := checkDerefVar(var_glojure_DOT_core_list)
																tmp230 := lang.Apply(tmp229, []any{sym_glojure_DOT_core_SLASH_concat})
																tmp231 := checkDerefVar(var_glojure_DOT_core_list)
																tmp232 := lang.Apply(tmp231, []any{sym_fs__1__auto__})
																tmp233 := checkDerefVar(var_glojure_DOT_core_list)
																tmp234 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp235 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp236 := checkDerefVar(var_glojure_DOT_core_list)
																tmp237 := lang.Apply(tmp236, []any{v89})
																tmp238 := checkDerefVar(var_glojure_DOT_core_list)
																tmp239 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp240 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp241 := checkDerefVar(var_glojure_DOT_core_list)
																tmp242 := lang.Apply(tmp241, []any{sym_glojure_DOT_core_SLASH_rest})
																tmp243 := checkDerefVar(var_glojure_DOT_core_list)
																tmp244 := lang.Apply(tmp243, []any{v92})
																tmp245 := lang.Apply(tmp240, []any{tmp242, tmp244})
																tmp246 := lang.Apply(tmp239, []any{tmp245})
																tmp247 := lang.Apply(tmp238, []any{tmp246})
																tmp248 := lang.Apply(tmp235, []any{tmp237, tmp247})
																tmp249 := lang.Apply(tmp234, []any{tmp248})
																tmp250 := lang.Apply(tmp233, []any{tmp249})
																tmp251 := lang.Apply(tmp228, []any{tmp230, tmp232, tmp250})
																tmp252 := lang.Apply(tmp227, []any{tmp251})
																tmp253 := lang.Apply(tmp226, []any{tmp252})
																tmp254 := checkDerefVar(var_glojure_DOT_core_list)
																tmp255 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp256 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp257 := checkDerefVar(var_glojure_DOT_core_list)
																tmp258 := lang.Apply(tmp257, []any{sym_recur})
																tmp259 := checkDerefVar(var_glojure_DOT_core_list)
																tmp260 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp261 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp262 := checkDerefVar(var_glojure_DOT_core_list)
																tmp263 := lang.Apply(tmp262, []any{sym_glojure_DOT_core_SLASH_rest})
																tmp264 := checkDerefVar(var_glojure_DOT_core_list)
																tmp265 := lang.Apply(tmp264, []any{v92})
																tmp266 := lang.Apply(tmp261, []any{tmp263, tmp265})
																tmp267 := lang.Apply(tmp260, []any{tmp266})
																tmp268 := lang.Apply(tmp259, []any{tmp267})
																tmp269 := lang.Apply(tmp256, []any{tmp258, tmp268})
																tmp270 := lang.Apply(tmp255, []any{tmp269})
																tmp271 := lang.Apply(tmp254, []any{tmp270})
																tmp272 := lang.Apply(tmp221, []any{tmp223, tmp225, tmp253, tmp271})
																tmp273 := lang.Apply(tmp220, []any{tmp272})
																tmp274 := lang.Apply(tmp219, []any{tmp273})
																tmp275 := lang.Apply(tmp182, []any{tmp184, tmp218, tmp274})
																tmp276 := lang.Apply(tmp181, []any{tmp275})
																tmp180 = tmp276
															} else {
																var tmp277 any
																if lang.IsTruthy(kw_else) {
																	tmp278 := checkDerefVar(var_glojure_DOT_core_seq)
																	tmp279 := checkDerefVar(var_glojure_DOT_core_concat)
																	tmp280 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp281 := lang.Apply(tmp280, []any{sym_glojure_DOT_core_SLASH_cons})
																	tmp282 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp283 := lang.Apply(tmp282, []any{v6})
																	tmp284 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp285 := checkDerefVar(var_glojure_DOT_core_seq)
																	tmp286 := checkDerefVar(var_glojure_DOT_core_concat)
																	tmp287 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp288 := lang.Apply(tmp287, []any{v89})
																	tmp289 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp290 := checkDerefVar(var_glojure_DOT_core_seq)
																	tmp291 := checkDerefVar(var_glojure_DOT_core_concat)
																	tmp292 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp293 := lang.Apply(tmp292, []any{sym_glojure_DOT_core_SLASH_rest})
																	tmp294 := checkDerefVar(var_glojure_DOT_core_list)
																	tmp295 := lang.Apply(tmp294, []any{v92})
																	tmp296 := lang.Apply(tmp291, []any{tmp293, tmp295})
																	tmp297 := lang.Apply(tmp290, []any{tmp296})
																	tmp298 := lang.Apply(tmp289, []any{tmp297})
																	tmp299 := lang.Apply(tmp286, []any{tmp288, tmp298})
																	tmp300 := lang.Apply(tmp285, []any{tmp299})
																	tmp301 := lang.Apply(tmp284, []any{tmp300})
																	tmp302 := lang.Apply(tmp279, []any{tmp281, tmp283, tmp301})
																	tmp303 := lang.Apply(tmp278, []any{tmp302})
																	tmp277 = tmp303
																} else {
																}
																tmp180 = tmp277
															}
															tmp176 = tmp180
														}
														tmp144 = tmp176
													}
													tmp130 = tmp144
												}
												tmp116 = tmp130
											}
											tmp96 = tmp116
										} // end let
										return tmp96
									})
									v94 = tmp93
									_ = v94
								}
								tmp94 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4672), kw_column, int(34), kw_end_DASH_line, int(4687), kw_end_DASH_column, int(73))
								tmp95, err := lang.WithMeta(tmp93, tmp94.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								var v96 any = tmp95
								_ = v96
								var tmp97 any
								if lang.IsTruthy(v85) {
									tmp98 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp99 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp100 := checkDerefVar(var_glojure_DOT_core_list)
									tmp101 := lang.Apply(tmp100, []any{sym_glojure_DOT_core_SLASH_fn})
									tmp102 := checkDerefVar(var_glojure_DOT_core_list)
									tmp103 := lang.Apply(tmp102, []any{v89})
									tmp104 := checkDerefVar(var_glojure_DOT_core_list)
									tmp105 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp106 := checkDerefVar(var_glojure_DOT_core_vector)
									tmp107 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp108 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp109 := checkDerefVar(var_glojure_DOT_core_list)
									tmp110 := lang.Apply(tmp109, []any{v92})
									tmp111 := lang.Apply(tmp108, []any{tmp110})
									tmp112 := lang.Apply(tmp107, []any{tmp111})
									tmp113 := lang.Apply(tmp105, []any{tmp106, tmp112})
									tmp114 := lang.Apply(tmp104, []any{tmp113})
									tmp115 := checkDerefVar(var_glojure_DOT_core_list)
									tmp116 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp117 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp118 := checkDerefVar(var_glojure_DOT_core_list)
									tmp119 := lang.Apply(tmp118, []any{sym_glojure_DOT_core_SLASH_lazy_DASH_seq})
									tmp120 := checkDerefVar(var_glojure_DOT_core_list)
									tmp121 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp122 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp123 := checkDerefVar(var_glojure_DOT_core_list)
									tmp124 := lang.Apply(tmp123, []any{sym_glojure_DOT_core_SLASH_loop})
									tmp125 := checkDerefVar(var_glojure_DOT_core_list)
									tmp126 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp127 := checkDerefVar(var_glojure_DOT_core_vector)
									tmp128 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp129 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp130 := checkDerefVar(var_glojure_DOT_core_list)
									tmp131 := lang.Apply(tmp130, []any{v92})
									tmp132 := checkDerefVar(var_glojure_DOT_core_list)
									tmp133 := lang.Apply(tmp132, []any{v92})
									tmp134 := lang.Apply(tmp129, []any{tmp131, tmp133})
									tmp135 := lang.Apply(tmp128, []any{tmp134})
									tmp136 := lang.Apply(tmp126, []any{tmp127, tmp135})
									tmp137 := lang.Apply(tmp125, []any{tmp136})
									tmp138 := checkDerefVar(var_glojure_DOT_core_list)
									tmp139 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp140 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp141 := checkDerefVar(var_glojure_DOT_core_list)
									tmp142 := lang.Apply(tmp141, []any{sym_glojure_DOT_core_SLASH_when_DASH_first})
									tmp143 := checkDerefVar(var_glojure_DOT_core_list)
									tmp144 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp145 := checkDerefVar(var_glojure_DOT_core_vector)
									tmp146 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp147 := checkDerefVar(var_glojure_DOT_core_concat)
									tmp148 := checkDerefVar(var_glojure_DOT_core_list)
									tmp149 := lang.Apply(tmp148, []any{v66})
									tmp150 := checkDerefVar(var_glojure_DOT_core_list)
									tmp151 := lang.Apply(tmp150, []any{v92})
									tmp152 := lang.Apply(tmp147, []any{tmp149, tmp151})
									tmp153 := lang.Apply(tmp146, []any{tmp152})
									tmp154 := lang.Apply(tmp144, []any{tmp145, tmp153})
									tmp155 := lang.Apply(tmp143, []any{tmp154})
									tmp156 := checkDerefVar(var_glojure_DOT_core_list)
									tmp157 := lang.Apply(v96, []any{v74})
									tmp158 := lang.Apply(tmp156, []any{tmp157})
									tmp159 := lang.Apply(tmp140, []any{tmp142, tmp155, tmp158})
									tmp160 := lang.Apply(tmp139, []any{tmp159})
									tmp161 := lang.Apply(tmp138, []any{tmp160})
									tmp162 := lang.Apply(tmp122, []any{tmp124, tmp137, tmp161})
									tmp163 := lang.Apply(tmp121, []any{tmp162})
									tmp164 := lang.Apply(tmp120, []any{tmp163})
									tmp165 := lang.Apply(tmp117, []any{tmp119, tmp164})
									tmp166 := lang.Apply(tmp116, []any{tmp165})
									tmp167 := lang.Apply(tmp115, []any{tmp166})
									tmp168 := lang.Apply(tmp99, []any{tmp101, tmp103, tmp114, tmp167})
									tmp169 := lang.Apply(tmp98, []any{tmp168})
									tmp97 = tmp169
								} else {
									var tmp170 any
									{ // let
										// let binding "gi"
										tmp171 := checkDerefVar(var_glojure_DOT_core_gensym)
										tmp172 := lang.Apply(tmp171, []any{"i__"})
										var v173 any = tmp172
										_ = v173
										// let binding "gb"
										tmp174 := checkDerefVar(var_glojure_DOT_core_gensym)
										tmp175 := lang.Apply(tmp174, []any{"b__"})
										var v176 any = tmp175
										_ = v176
										// let binding "do-cmod"
										var tmp177 lang.FnFunc
										{ // function do-cmod
											var v178 lang.FnFunc
											tmp177 = lang.NewFnFunc(func(args ...any) any {
												checkArity(args, 1)
												v179 := args[0]
												_ = v179
												var tmp180 any
												{ // let
													// let binding "vec__48"
													var v181 any = v179
													_ = v181
													// let binding "seq__49"
													tmp182 := checkDerefVar(var_glojure_DOT_core_seq)
													tmp183 := lang.Apply(tmp182, []any{v181})
													var v184 any = tmp183
													_ = v184
													// let binding "first__50"
													tmp185 := checkDerefVar(var_glojure_DOT_core_first)
													tmp186 := lang.Apply(tmp185, []any{v184})
													var v187 any = tmp186
													_ = v187
													// let binding "seq__49"
													tmp188 := checkDerefVar(var_glojure_DOT_core_next)
													tmp189 := lang.Apply(tmp188, []any{v184})
													var v190 any = tmp189
													_ = v190
													// let binding "vec__51"
													var v191 any = v187
													_ = v191
													// let binding "k"
													tmp192 := checkDerefVar(var_glojure_DOT_core_nth)
													tmp193 := lang.Apply(tmp192, []any{v191, int64(0), nil})
													var v194 any = tmp193
													_ = v194
													// let binding "v"
													tmp195 := checkDerefVar(var_glojure_DOT_core_nth)
													tmp196 := lang.Apply(tmp195, []any{v191, int64(1), nil})
													var v197 any = tmp196
													_ = v197
													// let binding "pair"
													var v198 any = v191
													_ = v198
													// let binding "etc"
													var v199 any = v190
													_ = v199
													var tmp200 any
													tmp201 := checkDerefVar(var_glojure_DOT_core__EQ_)
													tmp202 := lang.Apply(tmp201, []any{v194, kw_let})
													if lang.IsTruthy(tmp202) {
														tmp203 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp204 := checkDerefVar(var_glojure_DOT_core_concat)
														tmp205 := checkDerefVar(var_glojure_DOT_core_list)
														tmp206 := lang.Apply(tmp205, []any{sym_glojure_DOT_core_SLASH_let})
														tmp207 := checkDerefVar(var_glojure_DOT_core_list)
														tmp208 := lang.Apply(tmp207, []any{v197})
														tmp209 := checkDerefVar(var_glojure_DOT_core_list)
														tmp210 := lang.Apply(v178, []any{v199})
														tmp211 := lang.Apply(tmp209, []any{tmp210})
														tmp212 := lang.Apply(tmp204, []any{tmp206, tmp208, tmp211})
														tmp213 := lang.Apply(tmp203, []any{tmp212})
														tmp200 = tmp213
													} else {
														var tmp214 any
														tmp215 := checkDerefVar(var_glojure_DOT_core__EQ_)
														tmp216 := lang.Apply(tmp215, []any{v194, kw_while})
														if lang.IsTruthy(tmp216) {
															tmp217 := checkDerefVar(var_glojure_DOT_core_seq)
															tmp218 := checkDerefVar(var_glojure_DOT_core_concat)
															tmp219 := checkDerefVar(var_glojure_DOT_core_list)
															tmp220 := lang.Apply(tmp219, []any{sym_glojure_DOT_core_SLASH_when})
															tmp221 := checkDerefVar(var_glojure_DOT_core_list)
															tmp222 := lang.Apply(tmp221, []any{v197})
															tmp223 := checkDerefVar(var_glojure_DOT_core_list)
															tmp224 := lang.Apply(v178, []any{v199})
															tmp225 := lang.Apply(tmp223, []any{tmp224})
															tmp226 := lang.Apply(tmp218, []any{tmp220, tmp222, tmp225})
															tmp227 := lang.Apply(tmp217, []any{tmp226})
															tmp214 = tmp227
														} else {
															var tmp228 any
															tmp229 := checkDerefVar(var_glojure_DOT_core__EQ_)
															tmp230 := lang.Apply(tmp229, []any{v194, kw_when})
															if lang.IsTruthy(tmp230) {
																tmp231 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp232 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp233 := checkDerefVar(var_glojure_DOT_core_list)
																tmp234 := lang.Apply(tmp233, []any{sym_if})
																tmp235 := checkDerefVar(var_glojure_DOT_core_list)
																tmp236 := lang.Apply(tmp235, []any{v197})
																tmp237 := checkDerefVar(var_glojure_DOT_core_list)
																tmp238 := lang.Apply(v178, []any{v199})
																tmp239 := lang.Apply(tmp237, []any{tmp238})
																tmp240 := checkDerefVar(var_glojure_DOT_core_list)
																tmp241 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp242 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp243 := checkDerefVar(var_glojure_DOT_core_list)
																tmp244 := lang.Apply(tmp243, []any{sym_recur})
																tmp245 := checkDerefVar(var_glojure_DOT_core_list)
																tmp246 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp247 := checkDerefVar(var_glojure_DOT_core_concat)
																tmp248 := checkDerefVar(var_glojure_DOT_core_list)
																tmp249 := lang.Apply(tmp248, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc})
																tmp250 := checkDerefVar(var_glojure_DOT_core_list)
																tmp251 := lang.Apply(tmp250, []any{v173})
																tmp252 := lang.Apply(tmp247, []any{tmp249, tmp251})
																tmp253 := lang.Apply(tmp246, []any{tmp252})
																tmp254 := lang.Apply(tmp245, []any{tmp253})
																tmp255 := lang.Apply(tmp242, []any{tmp244, tmp254})
																tmp256 := lang.Apply(tmp241, []any{tmp255})
																tmp257 := lang.Apply(tmp240, []any{tmp256})
																tmp258 := lang.Apply(tmp232, []any{tmp234, tmp236, tmp239, tmp257})
																tmp259 := lang.Apply(tmp231, []any{tmp258})
																tmp228 = tmp259
															} else {
																var tmp260 any
																tmp261 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
																tmp262 := lang.Apply(tmp261, []any{v194})
																if lang.IsTruthy(tmp262) {
																	tmp263 := lang.Apply(v41, []any{"Invalid 'for' keyword ", v194})
																	tmp260 = tmp263
																} else {
																	var tmp264 any
																	if lang.IsTruthy(kw_else) {
																		tmp265 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp266 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp267 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp268 := lang.Apply(tmp267, []any{sym_do})
																		tmp269 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp270 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp271 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp272 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp273 := lang.Apply(tmp272, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_append})
																		tmp274 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp275 := lang.Apply(tmp274, []any{v176})
																		tmp276 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp277 := lang.Apply(tmp276, []any{v6})
																		tmp278 := lang.Apply(tmp271, []any{tmp273, tmp275, tmp277})
																		tmp279 := lang.Apply(tmp270, []any{tmp278})
																		tmp280 := lang.Apply(tmp269, []any{tmp279})
																		tmp281 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp282 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp283 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp284 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp285 := lang.Apply(tmp284, []any{sym_recur})
																		tmp286 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp287 := checkDerefVar(var_glojure_DOT_core_seq)
																		tmp288 := checkDerefVar(var_glojure_DOT_core_concat)
																		tmp289 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp290 := lang.Apply(tmp289, []any{sym_glojure_DOT_core_SLASH_unchecked_DASH_inc})
																		tmp291 := checkDerefVar(var_glojure_DOT_core_list)
																		tmp292 := lang.Apply(tmp291, []any{v173})
																		tmp293 := lang.Apply(tmp288, []any{tmp290, tmp292})
																		tmp294 := lang.Apply(tmp287, []any{tmp293})
																		tmp295 := lang.Apply(tmp286, []any{tmp294})
																		tmp296 := lang.Apply(tmp283, []any{tmp285, tmp295})
																		tmp297 := lang.Apply(tmp282, []any{tmp296})
																		tmp298 := lang.Apply(tmp281, []any{tmp297})
																		tmp299 := lang.Apply(tmp266, []any{tmp268, tmp280, tmp298})
																		tmp300 := lang.Apply(tmp265, []any{tmp299})
																		tmp264 = tmp300
																	} else {
																	}
																	tmp260 = tmp264
																}
																tmp228 = tmp260
															}
															tmp214 = tmp228
														}
														tmp200 = tmp214
													}
													tmp180 = tmp200
												} // end let
												return tmp180
											})
											v178 = tmp177
											_ = v178
										}
										tmp178 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4698), kw_column, int(39), kw_end_DASH_line, int(4710), kw_end_DASH_column, int(79))
										tmp179, err := lang.WithMeta(tmp177, tmp178.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										var v180 any = tmp179
										_ = v180
										tmp181 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp182 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp183 := checkDerefVar(var_glojure_DOT_core_list)
										tmp184 := lang.Apply(tmp183, []any{sym_glojure_DOT_core_SLASH_fn})
										tmp185 := checkDerefVar(var_glojure_DOT_core_list)
										tmp186 := lang.Apply(tmp185, []any{v89})
										tmp187 := checkDerefVar(var_glojure_DOT_core_list)
										tmp188 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp189 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp190 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp191 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp192 := checkDerefVar(var_glojure_DOT_core_list)
										tmp193 := lang.Apply(tmp192, []any{v92})
										tmp194 := lang.Apply(tmp191, []any{tmp193})
										tmp195 := lang.Apply(tmp190, []any{tmp194})
										tmp196 := lang.Apply(tmp188, []any{tmp189, tmp195})
										tmp197 := lang.Apply(tmp187, []any{tmp196})
										tmp198 := checkDerefVar(var_glojure_DOT_core_list)
										tmp199 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp200 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp201 := checkDerefVar(var_glojure_DOT_core_list)
										tmp202 := lang.Apply(tmp201, []any{sym_glojure_DOT_core_SLASH_lazy_DASH_seq})
										tmp203 := checkDerefVar(var_glojure_DOT_core_list)
										tmp204 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp205 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp206 := checkDerefVar(var_glojure_DOT_core_list)
										tmp207 := lang.Apply(tmp206, []any{sym_glojure_DOT_core_SLASH_loop})
										tmp208 := checkDerefVar(var_glojure_DOT_core_list)
										tmp209 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp210 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp211 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp212 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp213 := checkDerefVar(var_glojure_DOT_core_list)
										tmp214 := lang.Apply(tmp213, []any{v92})
										tmp215 := checkDerefVar(var_glojure_DOT_core_list)
										tmp216 := lang.Apply(tmp215, []any{v92})
										tmp217 := lang.Apply(tmp212, []any{tmp214, tmp216})
										tmp218 := lang.Apply(tmp211, []any{tmp217})
										tmp219 := lang.Apply(tmp209, []any{tmp210, tmp218})
										tmp220 := lang.Apply(tmp208, []any{tmp219})
										tmp221 := checkDerefVar(var_glojure_DOT_core_list)
										tmp222 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp223 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp224 := checkDerefVar(var_glojure_DOT_core_list)
										tmp225 := lang.Apply(tmp224, []any{sym_glojure_DOT_core_SLASH_when_DASH_let})
										tmp226 := checkDerefVar(var_glojure_DOT_core_list)
										tmp227 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp228 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp229 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp230 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp231 := checkDerefVar(var_glojure_DOT_core_list)
										tmp232 := lang.Apply(tmp231, []any{v92})
										tmp233 := checkDerefVar(var_glojure_DOT_core_list)
										tmp234 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp235 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp236 := checkDerefVar(var_glojure_DOT_core_list)
										tmp237 := lang.Apply(tmp236, []any{sym_glojure_DOT_core_SLASH_seq})
										tmp238 := checkDerefVar(var_glojure_DOT_core_list)
										tmp239 := lang.Apply(tmp238, []any{v92})
										tmp240 := lang.Apply(tmp235, []any{tmp237, tmp239})
										tmp241 := lang.Apply(tmp234, []any{tmp240})
										tmp242 := lang.Apply(tmp233, []any{tmp241})
										tmp243 := lang.Apply(tmp230, []any{tmp232, tmp242})
										tmp244 := lang.Apply(tmp229, []any{tmp243})
										tmp245 := lang.Apply(tmp227, []any{tmp228, tmp244})
										tmp246 := lang.Apply(tmp226, []any{tmp245})
										tmp247 := checkDerefVar(var_glojure_DOT_core_list)
										tmp248 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp249 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp250 := checkDerefVar(var_glojure_DOT_core_list)
										tmp251 := lang.Apply(tmp250, []any{sym_if})
										tmp252 := checkDerefVar(var_glojure_DOT_core_list)
										tmp253 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp254 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp255 := checkDerefVar(var_glojure_DOT_core_list)
										tmp256 := lang.Apply(tmp255, []any{sym_glojure_DOT_core_SLASH_chunked_DASH_seq_QMARK_})
										tmp257 := checkDerefVar(var_glojure_DOT_core_list)
										tmp258 := lang.Apply(tmp257, []any{v92})
										tmp259 := lang.Apply(tmp254, []any{tmp256, tmp258})
										tmp260 := lang.Apply(tmp253, []any{tmp259})
										tmp261 := lang.Apply(tmp252, []any{tmp260})
										tmp262 := checkDerefVar(var_glojure_DOT_core_list)
										tmp263 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp264 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp265 := checkDerefVar(var_glojure_DOT_core_list)
										tmp266 := lang.Apply(tmp265, []any{sym_glojure_DOT_core_SLASH_let})
										tmp267 := checkDerefVar(var_glojure_DOT_core_list)
										tmp268 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp269 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp270 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp271 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp272 := checkDerefVar(var_glojure_DOT_core_list)
										tmp273 := lang.Apply(tmp272, []any{sym_c__0__auto__})
										tmp274 := checkDerefVar(var_glojure_DOT_core_list)
										tmp275 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp276 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp277 := checkDerefVar(var_glojure_DOT_core_list)
										tmp278 := lang.Apply(tmp277, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_first})
										tmp279 := checkDerefVar(var_glojure_DOT_core_list)
										tmp280 := lang.Apply(tmp279, []any{v92})
										tmp281 := lang.Apply(tmp276, []any{tmp278, tmp280})
										tmp282 := lang.Apply(tmp275, []any{tmp281})
										tmp283 := lang.Apply(tmp274, []any{tmp282})
										tmp284 := checkDerefVar(var_glojure_DOT_core_list)
										tmp285 := lang.Apply(tmp284, []any{sym_size__1__auto__})
										tmp286 := checkDerefVar(var_glojure_DOT_core_list)
										tmp287 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp288 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp289 := checkDerefVar(var_glojure_DOT_core_list)
										tmp290 := lang.Apply(tmp289, []any{sym_glojure_DOT_core_SLASH_int})
										tmp291 := checkDerefVar(var_glojure_DOT_core_list)
										tmp292 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp293 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp294 := checkDerefVar(var_glojure_DOT_core_list)
										tmp295 := lang.Apply(tmp294, []any{sym_glojure_DOT_core_SLASH_count})
										tmp296 := checkDerefVar(var_glojure_DOT_core_list)
										tmp297 := lang.Apply(tmp296, []any{sym_c__0__auto__})
										tmp298 := lang.Apply(tmp293, []any{tmp295, tmp297})
										tmp299 := lang.Apply(tmp292, []any{tmp298})
										tmp300 := lang.Apply(tmp291, []any{tmp299})
										tmp301 := lang.Apply(tmp288, []any{tmp290, tmp300})
										tmp302 := lang.Apply(tmp287, []any{tmp301})
										tmp303 := lang.Apply(tmp286, []any{tmp302})
										tmp304 := checkDerefVar(var_glojure_DOT_core_list)
										tmp305 := lang.Apply(tmp304, []any{v176})
										tmp306 := checkDerefVar(var_glojure_DOT_core_list)
										tmp307 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp308 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp309 := checkDerefVar(var_glojure_DOT_core_list)
										tmp310 := lang.Apply(tmp309, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_buffer})
										tmp311 := checkDerefVar(var_glojure_DOT_core_list)
										tmp312 := lang.Apply(tmp311, []any{sym_size__1__auto__})
										tmp313 := lang.Apply(tmp308, []any{tmp310, tmp312})
										tmp314 := lang.Apply(tmp307, []any{tmp313})
										tmp315 := lang.Apply(tmp306, []any{tmp314})
										tmp316 := lang.Apply(tmp271, []any{tmp273, tmp283, tmp285, tmp303, tmp305, tmp315})
										tmp317 := lang.Apply(tmp270, []any{tmp316})
										tmp318 := lang.Apply(tmp268, []any{tmp269, tmp317})
										tmp319 := lang.Apply(tmp267, []any{tmp318})
										tmp320 := checkDerefVar(var_glojure_DOT_core_list)
										tmp321 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp322 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp323 := checkDerefVar(var_glojure_DOT_core_list)
										tmp324 := lang.Apply(tmp323, []any{sym_if})
										tmp325 := checkDerefVar(var_glojure_DOT_core_list)
										tmp326 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp327 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp328 := checkDerefVar(var_glojure_DOT_core_list)
										tmp329 := lang.Apply(tmp328, []any{sym_glojure_DOT_core_SLASH_loop})
										tmp330 := checkDerefVar(var_glojure_DOT_core_list)
										tmp331 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp332 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp333 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp334 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp335 := checkDerefVar(var_glojure_DOT_core_list)
										tmp336 := lang.Apply(tmp335, []any{v173})
										tmp337 := checkDerefVar(var_glojure_DOT_core_list)
										tmp338 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp339 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp340 := checkDerefVar(var_glojure_DOT_core_list)
										tmp341 := lang.Apply(tmp340, []any{sym_glojure_DOT_core_SLASH_int})
										tmp342 := checkDerefVar(var_glojure_DOT_core_list)
										tmp343 := lang.Apply(tmp342, []any{int64(0)})
										tmp344 := lang.Apply(tmp339, []any{tmp341, tmp343})
										tmp345 := lang.Apply(tmp338, []any{tmp344})
										tmp346 := lang.Apply(tmp337, []any{tmp345})
										tmp347 := lang.Apply(tmp334, []any{tmp336, tmp346})
										tmp348 := lang.Apply(tmp333, []any{tmp347})
										tmp349 := lang.Apply(tmp331, []any{tmp332, tmp348})
										tmp350 := lang.Apply(tmp330, []any{tmp349})
										tmp351 := checkDerefVar(var_glojure_DOT_core_list)
										tmp352 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp353 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp354 := checkDerefVar(var_glojure_DOT_core_list)
										tmp355 := lang.Apply(tmp354, []any{sym_if})
										tmp356 := checkDerefVar(var_glojure_DOT_core_list)
										tmp357 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp358 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp359 := checkDerefVar(var_glojure_DOT_core_list)
										tmp360 := lang.Apply(tmp359, []any{sym_glojure_DOT_core_SLASH__LT_})
										tmp361 := checkDerefVar(var_glojure_DOT_core_list)
										tmp362 := lang.Apply(tmp361, []any{v173})
										tmp363 := checkDerefVar(var_glojure_DOT_core_list)
										tmp364 := lang.Apply(tmp363, []any{sym_size__1__auto__})
										tmp365 := lang.Apply(tmp358, []any{tmp360, tmp362, tmp364})
										tmp366 := lang.Apply(tmp357, []any{tmp365})
										tmp367 := lang.Apply(tmp356, []any{tmp366})
										tmp368 := checkDerefVar(var_glojure_DOT_core_list)
										tmp369 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp370 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp371 := checkDerefVar(var_glojure_DOT_core_list)
										tmp372 := lang.Apply(tmp371, []any{sym_glojure_DOT_core_SLASH_let})
										tmp373 := checkDerefVar(var_glojure_DOT_core_list)
										tmp374 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp375 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp376 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp377 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp378 := checkDerefVar(var_glojure_DOT_core_list)
										tmp379 := lang.Apply(tmp378, []any{v66})
										tmp380 := checkDerefVar(var_glojure_DOT_core_list)
										tmp381 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp382 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp383 := checkDerefVar(var_glojure_DOT_core_list)
										tmp384 := lang.Apply(tmp383, []any{sym__DOT_nth})
										tmp385 := checkDerefVar(var_glojure_DOT_core_list)
										tmp386 := lang.Apply(tmp385, []any{sym_c__0__auto__})
										tmp387 := checkDerefVar(var_glojure_DOT_core_list)
										tmp388 := lang.Apply(tmp387, []any{v173})
										tmp389 := lang.Apply(tmp382, []any{tmp384, tmp386, tmp388})
										tmp390 := lang.Apply(tmp381, []any{tmp389})
										tmp391 := lang.Apply(tmp380, []any{tmp390})
										tmp392 := lang.Apply(tmp377, []any{tmp379, tmp391})
										tmp393 := lang.Apply(tmp376, []any{tmp392})
										tmp394 := lang.Apply(tmp374, []any{tmp375, tmp393})
										tmp395 := lang.Apply(tmp373, []any{tmp394})
										tmp396 := checkDerefVar(var_glojure_DOT_core_list)
										tmp397 := lang.Apply(v180, []any{v74})
										tmp398 := lang.Apply(tmp396, []any{tmp397})
										tmp399 := lang.Apply(tmp370, []any{tmp372, tmp395, tmp398})
										tmp400 := lang.Apply(tmp369, []any{tmp399})
										tmp401 := lang.Apply(tmp368, []any{tmp400})
										tmp402 := checkDerefVar(var_glojure_DOT_core_list)
										tmp403 := lang.Apply(tmp402, []any{true})
										tmp404 := lang.Apply(tmp353, []any{tmp355, tmp367, tmp401, tmp403})
										tmp405 := lang.Apply(tmp352, []any{tmp404})
										tmp406 := lang.Apply(tmp351, []any{tmp405})
										tmp407 := lang.Apply(tmp327, []any{tmp329, tmp350, tmp406})
										tmp408 := lang.Apply(tmp326, []any{tmp407})
										tmp409 := lang.Apply(tmp325, []any{tmp408})
										tmp410 := checkDerefVar(var_glojure_DOT_core_list)
										tmp411 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp412 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp413 := checkDerefVar(var_glojure_DOT_core_list)
										tmp414 := lang.Apply(tmp413, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_cons})
										tmp415 := checkDerefVar(var_glojure_DOT_core_list)
										tmp416 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp417 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp418 := checkDerefVar(var_glojure_DOT_core_list)
										tmp419 := lang.Apply(tmp418, []any{sym_glojure_DOT_core_SLASH_chunk})
										tmp420 := checkDerefVar(var_glojure_DOT_core_list)
										tmp421 := lang.Apply(tmp420, []any{v176})
										tmp422 := lang.Apply(tmp417, []any{tmp419, tmp421})
										tmp423 := lang.Apply(tmp416, []any{tmp422})
										tmp424 := lang.Apply(tmp415, []any{tmp423})
										tmp425 := checkDerefVar(var_glojure_DOT_core_list)
										tmp426 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp427 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp428 := checkDerefVar(var_glojure_DOT_core_list)
										tmp429 := lang.Apply(tmp428, []any{v89})
										tmp430 := checkDerefVar(var_glojure_DOT_core_list)
										tmp431 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp432 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp433 := checkDerefVar(var_glojure_DOT_core_list)
										tmp434 := lang.Apply(tmp433, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_rest})
										tmp435 := checkDerefVar(var_glojure_DOT_core_list)
										tmp436 := lang.Apply(tmp435, []any{v92})
										tmp437 := lang.Apply(tmp432, []any{tmp434, tmp436})
										tmp438 := lang.Apply(tmp431, []any{tmp437})
										tmp439 := lang.Apply(tmp430, []any{tmp438})
										tmp440 := lang.Apply(tmp427, []any{tmp429, tmp439})
										tmp441 := lang.Apply(tmp426, []any{tmp440})
										tmp442 := lang.Apply(tmp425, []any{tmp441})
										tmp443 := lang.Apply(tmp412, []any{tmp414, tmp424, tmp442})
										tmp444 := lang.Apply(tmp411, []any{tmp443})
										tmp445 := lang.Apply(tmp410, []any{tmp444})
										tmp446 := checkDerefVar(var_glojure_DOT_core_list)
										tmp447 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp448 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp449 := checkDerefVar(var_glojure_DOT_core_list)
										tmp450 := lang.Apply(tmp449, []any{sym_glojure_DOT_core_SLASH_chunk_DASH_cons})
										tmp451 := checkDerefVar(var_glojure_DOT_core_list)
										tmp452 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp453 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp454 := checkDerefVar(var_glojure_DOT_core_list)
										tmp455 := lang.Apply(tmp454, []any{sym_glojure_DOT_core_SLASH_chunk})
										tmp456 := checkDerefVar(var_glojure_DOT_core_list)
										tmp457 := lang.Apply(tmp456, []any{v176})
										tmp458 := lang.Apply(tmp453, []any{tmp455, tmp457})
										tmp459 := lang.Apply(tmp452, []any{tmp458})
										tmp460 := lang.Apply(tmp451, []any{tmp459})
										tmp461 := checkDerefVar(var_glojure_DOT_core_list)
										tmp462 := lang.Apply(tmp461, []any{nil})
										tmp463 := lang.Apply(tmp448, []any{tmp450, tmp460, tmp462})
										tmp464 := lang.Apply(tmp447, []any{tmp463})
										tmp465 := lang.Apply(tmp446, []any{tmp464})
										tmp466 := lang.Apply(tmp322, []any{tmp324, tmp409, tmp445, tmp465})
										tmp467 := lang.Apply(tmp321, []any{tmp466})
										tmp468 := lang.Apply(tmp320, []any{tmp467})
										tmp469 := lang.Apply(tmp264, []any{tmp266, tmp319, tmp468})
										tmp470 := lang.Apply(tmp263, []any{tmp469})
										tmp471 := lang.Apply(tmp262, []any{tmp470})
										tmp472 := checkDerefVar(var_glojure_DOT_core_list)
										tmp473 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp474 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp475 := checkDerefVar(var_glojure_DOT_core_list)
										tmp476 := lang.Apply(tmp475, []any{sym_glojure_DOT_core_SLASH_let})
										tmp477 := checkDerefVar(var_glojure_DOT_core_list)
										tmp478 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp479 := checkDerefVar(var_glojure_DOT_core_vector)
										tmp480 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp481 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp482 := checkDerefVar(var_glojure_DOT_core_list)
										tmp483 := lang.Apply(tmp482, []any{v66})
										tmp484 := checkDerefVar(var_glojure_DOT_core_list)
										tmp485 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp486 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp487 := checkDerefVar(var_glojure_DOT_core_list)
										tmp488 := lang.Apply(tmp487, []any{sym_glojure_DOT_core_SLASH_first})
										tmp489 := checkDerefVar(var_glojure_DOT_core_list)
										tmp490 := lang.Apply(tmp489, []any{v92})
										tmp491 := lang.Apply(tmp486, []any{tmp488, tmp490})
										tmp492 := lang.Apply(tmp485, []any{tmp491})
										tmp493 := lang.Apply(tmp484, []any{tmp492})
										tmp494 := lang.Apply(tmp481, []any{tmp483, tmp493})
										tmp495 := lang.Apply(tmp480, []any{tmp494})
										tmp496 := lang.Apply(tmp478, []any{tmp479, tmp495})
										tmp497 := lang.Apply(tmp477, []any{tmp496})
										tmp498 := checkDerefVar(var_glojure_DOT_core_list)
										tmp499 := lang.Apply(v96, []any{v74})
										tmp500 := lang.Apply(tmp498, []any{tmp499})
										tmp501 := lang.Apply(tmp474, []any{tmp476, tmp497, tmp500})
										tmp502 := lang.Apply(tmp473, []any{tmp501})
										tmp503 := lang.Apply(tmp472, []any{tmp502})
										tmp504 := lang.Apply(tmp249, []any{tmp251, tmp261, tmp471, tmp503})
										tmp505 := lang.Apply(tmp248, []any{tmp504})
										tmp506 := lang.Apply(tmp247, []any{tmp505})
										tmp507 := lang.Apply(tmp223, []any{tmp225, tmp246, tmp506})
										tmp508 := lang.Apply(tmp222, []any{tmp507})
										tmp509 := lang.Apply(tmp221, []any{tmp508})
										tmp510 := lang.Apply(tmp205, []any{tmp207, tmp220, tmp509})
										tmp511 := lang.Apply(tmp204, []any{tmp510})
										tmp512 := lang.Apply(tmp203, []any{tmp511})
										tmp513 := lang.Apply(tmp200, []any{tmp202, tmp512})
										tmp514 := lang.Apply(tmp199, []any{tmp513})
										tmp515 := lang.Apply(tmp198, []any{tmp514})
										tmp516 := lang.Apply(tmp182, []any{tmp184, tmp186, tmp197, tmp515})
										tmp517 := lang.Apply(tmp181, []any{tmp516})
										tmp170 = tmp517
									} // end let
									tmp97 = tmp170
								}
								tmp86 = tmp97
							} // end let
							tmp45 = tmp86
						} // end let
						return tmp45
					})
					v43 = tmp42
					_ = v43
				}
				tmp43 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4668), kw_column, int(19), kw_end_DASH_line, int(4729), kw_end_DASH_column, int(68))
				tmp44, err := lang.WithMeta(tmp42, tmp43.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v45 any = tmp44
				_ = v45
				tmp46 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp47 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp48 := checkDerefVar(var_glojure_DOT_core_list)
				tmp49 := lang.Apply(tmp48, []any{sym_glojure_DOT_core_SLASH_let})
				tmp50 := checkDerefVar(var_glojure_DOT_core_list)
				tmp51 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp52 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp53 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp54 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp55 := checkDerefVar(var_glojure_DOT_core_list)
				tmp56 := lang.Apply(tmp55, []any{sym_iter__0__auto__})
				tmp57 := checkDerefVar(var_glojure_DOT_core_list)
				tmp58 := lang.Apply(v37, []any{v5})
				tmp59 := lang.Apply(v45, []any{tmp58})
				tmp60 := lang.Apply(tmp57, []any{tmp59})
				tmp61 := lang.Apply(tmp54, []any{tmp56, tmp60})
				tmp62 := lang.Apply(tmp53, []any{tmp61})
				tmp63 := lang.Apply(tmp51, []any{tmp52, tmp62})
				tmp64 := lang.Apply(tmp50, []any{tmp63})
				tmp65 := checkDerefVar(var_glojure_DOT_core_list)
				tmp66 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp67 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp68 := checkDerefVar(var_glojure_DOT_core_list)
				tmp69 := lang.Apply(tmp68, []any{sym_iter__0__auto__})
				tmp70 := checkDerefVar(var_glojure_DOT_core_list)
				tmp71 := checkDerefVar(var_glojure_DOT_core_second)
				tmp72 := lang.Apply(tmp71, []any{v5})
				tmp73 := lang.Apply(tmp70, []any{tmp72})
				tmp74 := lang.Apply(tmp67, []any{tmp69, tmp73})
				tmp75 := lang.Apply(tmp66, []any{tmp74})
				tmp76 := lang.Apply(tmp65, []any{tmp75})
				tmp77 := lang.Apply(tmp47, []any{tmp49, tmp64, tmp76})
				tmp78 := lang.Apply(tmp46, []any{tmp77})
				tmp33 = tmp78
			} // end let
			return tmp33
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// force
	{
		tmp0 := sym_force.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(754), kw_end_DASH_line, int(754))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(nil, "force")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("force is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// format
	{
		tmp0 := sym_format.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_fmt, sym__AMP_, sym_args)), kw_doc, "Formats a string using java.lang.String.format, see java.util.Formatter for format\n  string syntax", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5717), kw_end_DASH_line, int(5717))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp6 := lang.Apply(tmp5, []any{fmt.Sprintf, v3, v4})
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// frequencies
	{
		tmp0 := sym_frequencies.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a map from distinct items in coll to the number of times\n  they appear.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(7185), kw_end_DASH_line, int(7185))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
			tmp5 := checkDerefVar(var_glojure_DOT_core_reduce)
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v7 := args[0]
				_ = v7
				v8 := args[1]
				_ = v8
				tmp9 := checkDerefVar(var_glojure_DOT_core_assoc_BANG_)
				tmp10 := checkDerefVar(var_glojure_DOT_core_inc)
				tmp11 := checkDerefVar(var_glojure_DOT_core_get)
				tmp12 := lang.Apply(tmp11, []any{v7, v8, int64(0)})
				tmp13 := lang.Apply(tmp10, []any{tmp12})
				tmp14 := lang.Apply(tmp9, []any{v7, v8, tmp13})
				return tmp14
			})
			tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7192), kw_column, int(12), kw_end_DASH_line, int(7193), kw_end_DASH_column, int(54))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := checkDerefVar(var_glojure_DOT_core_transient)
			tmp10 := lang.NewMap()
			tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7194), kw_column, int(23), kw_end_DASH_line, int(7194), kw_end_DASH_column, int(24))
			tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp13 := lang.Apply(tmp9, []any{tmp12})
			tmp14 := lang.Apply(tmp5, []any{tmp8, tmp13, v3})
			tmp15 := lang.Apply(tmp4, []any{tmp14})
			return tmp15
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future
	{
		tmp0 := sym_future.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Takes a body of expressions and yields a future object that will\n  invoke the body in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant of\n  deref with timeout is used. See also - realized?.", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(7009), kw_end_DASH_line, int(7009))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_future_DASH_call})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_fn_STAR_})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp17 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp20 := lang.Apply(tmp19, nil)
				tmp21 := lang.Apply(tmp18, []any{tmp20})
				tmp22 := lang.Apply(tmp16, []any{tmp17, tmp21})
				tmp23 := lang.Apply(tmp15, []any{tmp22})
				tmp24 := lang.Apply(tmp12, []any{tmp14, tmp23, v5})
				tmp25 := lang.Apply(tmp11, []any{tmp24})
				tmp26 := lang.Apply(tmp10, []any{tmp25})
				tmp27 := lang.Apply(tmp7, []any{tmp9, tmp26})
				tmp28 := lang.Apply(tmp6, []any{tmp27})
				return tmp28
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-call
	{
		tmp0 := sym_future_DASH_call.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Takes a function of no args and yields a future object that will\n  invoke the function in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant\n  of deref with timeout is used. See also - realized?.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(7003), kw_end_DASH_line, int(7003))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "f"
				tmp5 := checkDerefVar(var_glojure_DOT_core_binding_DASH_conveyor_DASH_fn)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				// let binding "fut"
				tmp8 := lang.Apply(lang.AgentSubmit, []any{v7})
				var v9 any = tmp8
				_ = v9
				tmp4 = v9
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-cancel
	{
		tmp0 := sym_future_DASH_cancel.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Cancels the future, if possible.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(7019), kw_end_DASH_line, int(7019))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "cancel")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("cancel is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{true})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-cancelled?
	{
		tmp0 := sym_future_DASH_cancelled_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Returns true if future f is cancelled", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(7025), kw_end_DASH_line, int(7025))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "isCancelled")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isCancelled")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-done?
	{
		tmp0 := sym_future_DASH_done_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Returns true if future f is done", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(6538), kw_end_DASH_line, int(6538))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "isDone")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isDone")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future?
	{
		tmp0 := sym_future_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is a future", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6532), kw_end_DASH_line, int(6532))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// gen-class
	{
		tmp0 := sym_gen_DASH_class.WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// gensym
	{
		tmp0 := sym_gensym.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_prefix_DASH_string)), kw_doc, "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(599), kw_end_DASH_line, int(599))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(var_glojure_DOT_core_gensym)
				tmp4 := lang.Apply(tmp3, []any{"G__"})
				return tmp4
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_str)
				tmp5 := checkDerefVar(var_glojure_DOT_core_str)
				tmp6, _ := lang.FieldOrMethod(runtime.RT, "NextID")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("NextID is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				tmp9 := lang.Apply(tmp4, []any{v3, tmp8})
				tmp10 := lang.Apply(lang.NewSymbol, []any{tmp9})
				return tmp10
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get
	{
		var tmp1 lang.FnFunc
		{ // function get__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 2)
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					var v5 any = lang.NewList(args[2:]...)
					_ = v5
					tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym__DOT_})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_Get})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v4})
					tmp21 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp20, v5})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp12, []any{tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp23})
					tmp25 := lang.Apply(tmp6, []any{tmp24})
					return tmp25
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_get.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map, sym_key), lang.NewVector(sym_map, sym_key, sym_not_DASH_found)), kw_inline, tmp1, kw_doc, "Returns the value mapped to key, not-found or nil if key not present\n  in associative collection, set, string, array, or ILookup instance.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2), int64(3)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1489), kw_end_DASH_line, int(1489))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.Get, []any{v4, v5})
				return tmp6
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(lang.GetDefault, []any{v4, v5, v6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-in
	{
		tmp0 := sym_get_DASH_in.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_ks), lang.NewVector(sym_m, sym_ks, sym_not_DASH_found)), kw_doc, "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key\n  is not present, or the not-found value if supplied.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6128), kw_end_DASH_line, int(6128))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp6 := checkDerefVar(var_glojure_DOT_core_get)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3, v4})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "sentinel"
					tmp7 := lang.Apply(reflect.StructOf, []any{nil})
					tmp8 := lang.Apply(reflect.New, []any{tmp7})
					tmp9, ok := lang.FieldOrMethod(tmp8, "Interface")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp8, "Interface")))
					}
					var tmp10 any
					switch reflect.TypeOf(tmp9).Kind() {
					case reflect.Func:
						tmp10 = lang.Apply(tmp9, nil)
					default:
						tmp10 = tmp9
					}
					var v11 any = tmp10
					_ = v11
					// let binding "m"
					var v12 any = v3
					_ = v12
					// let binding "ks"
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := lang.Apply(tmp13, []any{v4})
					var v15 any = tmp14
					_ = v15
					for {
						var tmp16 any
						if lang.IsTruthy(v15) {
							var tmp17 any
							{ // let
								// let binding "m"
								tmp18 := checkDerefVar(var_glojure_DOT_core_get)
								tmp19 := checkDerefVar(var_glojure_DOT_core_first)
								tmp20 := lang.Apply(tmp19, []any{v15})
								tmp21 := lang.Apply(tmp18, []any{v12, tmp20, v11})
								var v22 any = tmp21
								_ = v22
								var tmp23 any
								tmp24 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
								tmp25 := lang.Apply(tmp24, []any{v11, v22})
								if lang.IsTruthy(tmp25) {
									tmp23 = v5
								} else {
									var tmp26 any = v11
									var tmp27 any = v22
									tmp29 := checkDerefVar(var_glojure_DOT_core_next)
									tmp30 := lang.Apply(tmp29, []any{v15})
									var tmp28 any = tmp30
									v11 = tmp26
									v12 = tmp27
									v15 = tmp28
									continue
								}
								tmp17 = tmp23
							} // end let
							tmp16 = tmp17
						} else {
							tmp16 = v12
						}
						tmp6 = tmp16
						break
					}
				} // end let
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-method
	{
		tmp0 := sym_get_DASH_method.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn, sym_dispatch_DASH_val)), kw_doc, "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(1815), kw_end_DASH_line, int(1815))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "getMethod")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("getMethod is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-thread-bindings
	{
		tmp0 := sym_get_DASH_thread_DASH_bindings.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Get a map with the Var/value pairs which is currently in effect for the\n  current thread.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(1937), kw_end_DASH_line, int(1937))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := lang.Apply(nil, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-validator
	{
		tmp0 := sym_get_DASH_validator.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_iref)), kw_doc, "Gets the validator-fn for a var/ref/agent/atom.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(2392), kw_end_DASH_line, int(2392))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "getValidator")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("getValidator is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// global-hierarchy
	{
		tmp0 := sym_global_DASH_hierarchy.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(5513), kw_column, int(6), kw_end_DASH_line, int(5514), kw_end_DASH_column, int(21), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.NewMap(kw_parents, lang.NewMap(), kw_descendants, lang.NewMap(), kw_ancestors, lang.NewMap()), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// group-by
	{
		tmp0 := sym_group_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll)), kw_doc, "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(7128), kw_end_DASH_line, int(7128))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
			tmp6 := checkDerefVar(var_glojure_DOT_core_reduce)
			var tmp7 lang.FnFunc
			tmp7 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v8 := args[0]
				_ = v8
				v9 := args[1]
				_ = v9
				var tmp10 any
				{ // let
					// let binding "k"
					tmp11 := lang.Apply(v3, []any{v9})
					var v12 any = tmp11
					_ = v12
					tmp13 := checkDerefVar(var_glojure_DOT_core_assoc_BANG_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp15 := checkDerefVar(var_glojure_DOT_core_get)
					tmp16 := lang.NewVector()
					tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7139), kw_column, int(40), kw_end_DASH_line, int(7139), kw_end_DASH_column, int(41))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp19 := lang.Apply(tmp15, []any{v8, v12, tmp18})
					tmp20 := lang.Apply(tmp14, []any{tmp19, v9})
					tmp21 := lang.Apply(tmp13, []any{v8, v12, tmp20})
					tmp10 = tmp21
				} // end let
				return tmp10
			})
			tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7137), kw_column, int(5), kw_end_DASH_line, int(7139), kw_end_DASH_column, int(48))
			tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp10 := checkDerefVar(var_glojure_DOT_core_transient)
			tmp11 := lang.NewMap()
			tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7140), kw_column, int(16), kw_end_DASH_line, int(7140), kw_end_DASH_column, int(17))
			tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp14 := lang.Apply(tmp10, []any{tmp13})
			tmp15 := lang.Apply(tmp6, []any{tmp9, tmp14, v4})
			tmp16 := lang.Apply(tmp5, []any{tmp15})
			return tmp16
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// halt-when
	{
		tmp0 := sym_halt_DASH_when.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred), lang.NewVector(sym_pred, sym_retf)), kw_doc, "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(7657), kw_end_DASH_line, int(7657))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_halt_DASH_when)
				tmp5 := lang.Apply(tmp4, []any{v3, nil})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v6 := args[0]
					_ = v6
					var tmp7 lang.FnFunc
					tmp7 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp8 := lang.Apply(v6, nil)
							return tmp8
						case 1:
							v8 := args[0]
							_ = v8
							var tmp9 any
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
								tmp12 := lang.Apply(tmp11, []any{v8})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp15 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
									tmp16 := lang.Apply(tmp15, []any{v8, kw_glojure_DOT_core_SLASH_halt})
									tmp14 = tmp16
								} else {
									tmp14 = v13
								}
								tmp10 = tmp14
							} // end let
							if lang.IsTruthy(tmp10) {
								tmp11 := lang.Apply(kw_glojure_DOT_core_SLASH_halt, []any{v8})
								tmp9 = tmp11
							} else {
								tmp12 := lang.Apply(v6, []any{v8})
								tmp9 = tmp12
							}
							return tmp9
						case 2:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							var tmp10 any
							tmp11 := lang.Apply(v3, []any{v9})
							if lang.IsTruthy(tmp11) {
								tmp12 := checkDerefVar(var_glojure_DOT_core_reduced)
								var tmp13 any
								if lang.IsTruthy(v4) {
									tmp14 := lang.Apply(v6, []any{v8})
									tmp15 := lang.Apply(v4, []any{tmp14, v9})
									tmp13 = tmp15
								} else {
									tmp13 = v9
								}
								tmp16 := lang.NewMap(kw_glojure_DOT_core_SLASH_halt, tmp13)
								tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7678), kw_column, int(24), kw_end_DASH_line, int(7678), kw_end_DASH_column, int(72))
								tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp19 := lang.Apply(tmp12, []any{tmp18})
								tmp10 = tmp19
							} else {
								tmp20 := lang.Apply(v6, []any{v8, v9})
								tmp10 = tmp20
							}
							return tmp10
						default:
							checkArity(args, -1)
							panic("unreachable")
						}
					})
					tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7670), kw_column, int(8), kw_end_DASH_line, int(7679), kw_end_DASH_column, int(34))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp9
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7669), kw_column, int(6), kw_end_DASH_line, int(7679), kw_end_DASH_column, int(35))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash
	{
		tmp0 := sym_hash.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns the hash code of its argument. Note this is the hash code\n  consistent with =, and thus is different than .hashCode for Integer,\n  Short, Byte and Clojure collections.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(5189), kw_end_DASH_line, int(5189))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.HashEq, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-map
	{
		tmp0 := sym_hash_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym__AMP_, sym_keyvals)), kw_doc, "keyval => key val\n  Returns a new hash map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(378), kw_end_DASH_line, int(378))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.NewMap()
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(384), kw_column, int(7), kw_end_DASH_line, int(384), kw_end_DASH_column, int(8))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentHashMap, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-ordered-coll
	{
		tmp0 := sym_hash_DASH_ordered_DASH_coll.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://glojure.org/data_structures#hash for full algorithms.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(5210), kw_end_DASH_line, int(5210))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-set
	{
		tmp0 := sym_hash_DASH_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym__AMP_, sym_keys)), kw_doc, "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(388), kw_end_DASH_line, int(388))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(393), kw_column, int(7), kw_end_DASH_line, int(393), kw_end_DASH_column, int(9))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(nil, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-unordered-coll
	{
		tmp0 := sym_hash_DASH_unordered_DASH_coll.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://glojure.org/data_structures#hash for full algorithms.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(5219), kw_end_DASH_line, int(5219))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ident?
	{
		tmp0 := sym_ident_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a symbol or keyword", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(1608), kw_end_DASH_line, int(1608))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp8 = v7
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp8 = tmp10
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// identical?
	{
		var tmp1 lang.FnFunc
		{ // function identical?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_lang_DOT_Util})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{sym_glojure_DOT_core_SLASH_identical})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v4})
				tmp17 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp5, []any{tmp17})
				return tmp18
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_identical_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Tests if 2 arguments are the same object", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(768), kw_end_DASH_line, int(768))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := lang.Apply(lang.Identical, []any{v4, v5})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// identity
	{
		tmp0 := sym_identity.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns its argument.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1446), kw_end_DASH_line, int(1446))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			return v3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-let
	{
		tmp0 := sym_if_DASH_let.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym_then), lang.NewVector(sym_bindings, sym_then, sym_else, sym__AMP_, sym_oldform)), kw_doc, "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(1839), kw_end_DASH_line, int(1839))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_if_DASH_let})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v6})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{nil})
				tmp17 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp7, []any{tmp17})
				return tmp18
			default:
				checkArity(args, 5)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var v8 any = lang.NewList(args[5:]...)
				_ = v8
				var tmp9 any
				tmp10 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := checkDerefVar(var_glojure_DOT_core_str)
					tmp13 := checkDerefVar(var_glojure_DOT_core_first)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp16 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp17 := lang.Apply(tmp16, []any{v3})
					tmp18 := lang.Apply(kw_line, []any{tmp17})
					tmp19 := lang.Apply(tmp12, []any{tmp14, " requires ", "a vector for its binding", " in ", tmp15, ":", tmp18})
					tmp20 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp19})
					panic(tmp20)
				}
				_ = tmp9
				var tmp21 any
				tmp22 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
				tmp23 := lang.Apply(tmp22, []any{v8})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "1 or 2 forms after binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp21
				var tmp33 any
				tmp34 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp35 := checkDerefVar(var_glojure_DOT_core_count)
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp34, []any{int64(2), tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := checkDerefVar(var_glojure_DOT_core_str)
					tmp39 := checkDerefVar(var_glojure_DOT_core_first)
					tmp40 := lang.Apply(tmp39, []any{v3})
					tmp41 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp42 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp43 := lang.Apply(tmp42, []any{v3})
					tmp44 := lang.Apply(kw_line, []any{tmp43})
					tmp45 := lang.Apply(tmp38, []any{tmp40, " requires ", "exactly 2 forms in binding vector", " in ", tmp41, ":", tmp44})
					tmp46 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp45})
					panic(tmp46)
				}
				_ = tmp33
				var tmp47 any
				{ // let
					// let binding "form"
					tmp48 := lang.Apply(v5, []any{int64(0)})
					var v49 any = tmp48
					_ = v49
					// let binding "tst"
					tmp50 := lang.Apply(v5, []any{int64(1)})
					var v51 any = tmp50
					_ = v51
					tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp53 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp54 := checkDerefVar(var_glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{sym_glojure_DOT_core_SLASH_let})
					tmp56 := checkDerefVar(var_glojure_DOT_core_list)
					tmp57 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp58 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp59 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp60 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp61 := checkDerefVar(var_glojure_DOT_core_list)
					tmp62 := lang.Apply(tmp61, []any{sym_temp__0__auto__})
					tmp63 := checkDerefVar(var_glojure_DOT_core_list)
					tmp64 := lang.Apply(tmp63, []any{v51})
					tmp65 := lang.Apply(tmp60, []any{tmp62, tmp64})
					tmp66 := lang.Apply(tmp59, []any{tmp65})
					tmp67 := lang.Apply(tmp57, []any{tmp58, tmp66})
					tmp68 := lang.Apply(tmp56, []any{tmp67})
					tmp69 := checkDerefVar(var_glojure_DOT_core_list)
					tmp70 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp71 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp72 := checkDerefVar(var_glojure_DOT_core_list)
					tmp73 := lang.Apply(tmp72, []any{sym_if})
					tmp74 := checkDerefVar(var_glojure_DOT_core_list)
					tmp75 := lang.Apply(tmp74, []any{sym_temp__0__auto__})
					tmp76 := checkDerefVar(var_glojure_DOT_core_list)
					tmp77 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp78 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp79 := checkDerefVar(var_glojure_DOT_core_list)
					tmp80 := lang.Apply(tmp79, []any{sym_glojure_DOT_core_SLASH_let})
					tmp81 := checkDerefVar(var_glojure_DOT_core_list)
					tmp82 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp83 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp84 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp85 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp86 := checkDerefVar(var_glojure_DOT_core_list)
					tmp87 := lang.Apply(tmp86, []any{v49})
					tmp88 := checkDerefVar(var_glojure_DOT_core_list)
					tmp89 := lang.Apply(tmp88, []any{sym_temp__0__auto__})
					tmp90 := lang.Apply(tmp85, []any{tmp87, tmp89})
					tmp91 := lang.Apply(tmp84, []any{tmp90})
					tmp92 := lang.Apply(tmp82, []any{tmp83, tmp91})
					tmp93 := lang.Apply(tmp81, []any{tmp92})
					tmp94 := checkDerefVar(var_glojure_DOT_core_list)
					tmp95 := lang.Apply(tmp94, []any{v6})
					tmp96 := lang.Apply(tmp78, []any{tmp80, tmp93, tmp95})
					tmp97 := lang.Apply(tmp77, []any{tmp96})
					tmp98 := lang.Apply(tmp76, []any{tmp97})
					tmp99 := checkDerefVar(var_glojure_DOT_core_list)
					tmp100 := lang.Apply(tmp99, []any{v7})
					tmp101 := lang.Apply(tmp71, []any{tmp73, tmp75, tmp98, tmp100})
					tmp102 := lang.Apply(tmp70, []any{tmp101})
					tmp103 := lang.Apply(tmp69, []any{tmp102})
					tmp104 := lang.Apply(tmp53, []any{tmp55, tmp68, tmp103})
					tmp105 := lang.Apply(tmp52, []any{tmp104})
					tmp47 = tmp105
				} // end let
				return tmp47
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-not
	{
		tmp0 := sym_if_DASH_not.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_test, sym_then), lang.NewVector(sym_test, sym_then, sym_else)), kw_doc, "Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(760), kw_end_DASH_line, int(760))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_if_DASH_not})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v6})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{nil})
				tmp17 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp7, []any{tmp17})
				return tmp18
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_if})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_not})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v5})
				tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp13, []any{tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := checkDerefVar(var_glojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{v6})
				tmp24 := checkDerefVar(var_glojure_DOT_core_list)
				tmp25 := lang.Apply(tmp24, []any{v7})
				tmp26 := lang.Apply(tmp9, []any{tmp11, tmp21, tmp23, tmp25})
				tmp27 := lang.Apply(tmp8, []any{tmp26})
				return tmp27
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-some
	{
		tmp0 := sym_if_DASH_some.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym_then), lang.NewVector(sym_bindings, sym_then, sym_else, sym__AMP_, sym_oldform)), kw_doc, "bindings => binding-form test\n\n   If test is not nil, evaluates then with binding-form bound to the\n   value of test, if not, yields else", kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(1874), kw_end_DASH_line, int(1874))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_if_DASH_some})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{v6})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{nil})
				tmp17 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp14, tmp16})
				tmp18 := lang.Apply(tmp7, []any{tmp17})
				return tmp18
			default:
				checkArity(args, 5)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var v8 any = lang.NewList(args[5:]...)
				_ = v8
				var tmp9 any
				tmp10 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := checkDerefVar(var_glojure_DOT_core_str)
					tmp13 := checkDerefVar(var_glojure_DOT_core_first)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp16 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp17 := lang.Apply(tmp16, []any{v3})
					tmp18 := lang.Apply(kw_line, []any{tmp17})
					tmp19 := lang.Apply(tmp12, []any{tmp14, " requires ", "a vector for its binding", " in ", tmp15, ":", tmp18})
					tmp20 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp19})
					panic(tmp20)
				}
				_ = tmp9
				var tmp21 any
				tmp22 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
				tmp23 := lang.Apply(tmp22, []any{v8})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "1 or 2 forms after binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp21
				var tmp33 any
				tmp34 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp35 := checkDerefVar(var_glojure_DOT_core_count)
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp34, []any{int64(2), tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := checkDerefVar(var_glojure_DOT_core_str)
					tmp39 := checkDerefVar(var_glojure_DOT_core_first)
					tmp40 := lang.Apply(tmp39, []any{v3})
					tmp41 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp42 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp43 := lang.Apply(tmp42, []any{v3})
					tmp44 := lang.Apply(kw_line, []any{tmp43})
					tmp45 := lang.Apply(tmp38, []any{tmp40, " requires ", "exactly 2 forms in binding vector", " in ", tmp41, ":", tmp44})
					tmp46 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp45})
					panic(tmp46)
				}
				_ = tmp33
				var tmp47 any
				{ // let
					// let binding "form"
					tmp48 := lang.Apply(v5, []any{int64(0)})
					var v49 any = tmp48
					_ = v49
					// let binding "tst"
					tmp50 := lang.Apply(v5, []any{int64(1)})
					var v51 any = tmp50
					_ = v51
					tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp53 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp54 := checkDerefVar(var_glojure_DOT_core_list)
					tmp55 := lang.Apply(tmp54, []any{sym_glojure_DOT_core_SLASH_let})
					tmp56 := checkDerefVar(var_glojure_DOT_core_list)
					tmp57 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp58 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp59 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp60 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp61 := checkDerefVar(var_glojure_DOT_core_list)
					tmp62 := lang.Apply(tmp61, []any{sym_temp__0__auto__})
					tmp63 := checkDerefVar(var_glojure_DOT_core_list)
					tmp64 := lang.Apply(tmp63, []any{v51})
					tmp65 := lang.Apply(tmp60, []any{tmp62, tmp64})
					tmp66 := lang.Apply(tmp59, []any{tmp65})
					tmp67 := lang.Apply(tmp57, []any{tmp58, tmp66})
					tmp68 := lang.Apply(tmp56, []any{tmp67})
					tmp69 := checkDerefVar(var_glojure_DOT_core_list)
					tmp70 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp71 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp72 := checkDerefVar(var_glojure_DOT_core_list)
					tmp73 := lang.Apply(tmp72, []any{sym_if})
					tmp74 := checkDerefVar(var_glojure_DOT_core_list)
					tmp75 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp76 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp77 := checkDerefVar(var_glojure_DOT_core_list)
					tmp78 := lang.Apply(tmp77, []any{sym_glojure_DOT_core_SLASH_nil_QMARK_})
					tmp79 := checkDerefVar(var_glojure_DOT_core_list)
					tmp80 := lang.Apply(tmp79, []any{sym_temp__0__auto__})
					tmp81 := lang.Apply(tmp76, []any{tmp78, tmp80})
					tmp82 := lang.Apply(tmp75, []any{tmp81})
					tmp83 := lang.Apply(tmp74, []any{tmp82})
					tmp84 := checkDerefVar(var_glojure_DOT_core_list)
					tmp85 := lang.Apply(tmp84, []any{v7})
					tmp86 := checkDerefVar(var_glojure_DOT_core_list)
					tmp87 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp88 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp89 := checkDerefVar(var_glojure_DOT_core_list)
					tmp90 := lang.Apply(tmp89, []any{sym_glojure_DOT_core_SLASH_let})
					tmp91 := checkDerefVar(var_glojure_DOT_core_list)
					tmp92 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp93 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp94 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp95 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp96 := checkDerefVar(var_glojure_DOT_core_list)
					tmp97 := lang.Apply(tmp96, []any{v49})
					tmp98 := checkDerefVar(var_glojure_DOT_core_list)
					tmp99 := lang.Apply(tmp98, []any{sym_temp__0__auto__})
					tmp100 := lang.Apply(tmp95, []any{tmp97, tmp99})
					tmp101 := lang.Apply(tmp94, []any{tmp100})
					tmp102 := lang.Apply(tmp92, []any{tmp93, tmp101})
					tmp103 := lang.Apply(tmp91, []any{tmp102})
					tmp104 := checkDerefVar(var_glojure_DOT_core_list)
					tmp105 := lang.Apply(tmp104, []any{v6})
					tmp106 := lang.Apply(tmp88, []any{tmp90, tmp103, tmp105})
					tmp107 := lang.Apply(tmp87, []any{tmp106})
					tmp108 := lang.Apply(tmp86, []any{tmp107})
					tmp109 := lang.Apply(tmp71, []any{tmp73, tmp83, tmp85, tmp108})
					tmp110 := lang.Apply(tmp70, []any{tmp109})
					tmp111 := lang.Apply(tmp69, []any{tmp110})
					tmp112 := lang.Apply(tmp53, []any{tmp55, tmp68, tmp111})
					tmp113 := lang.Apply(tmp52, []any{tmp112})
					tmp47 = tmp113
				} // end let
				return tmp47
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ifn?
	{
		tmp0 := sym_ifn_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6209), kw_end_DASH_line, int(6209))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// import
	{
		tmp0 := sym_import.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_import_DASH_symbols_DASH_or_DASH_lists)), kw_doc, "import-list => (package-symbol class-name-symbols*)\n\n  For each name in class-name-symbols, adds a mapping from name to the\n  class named by package.name to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(3426), kw_end_DASH_line, int(3426))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "specs"
					tmp7 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp8 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v9 := args[0]
						_ = v9
						var tmp10 any
						var tmp11 any
						{ // let
							// let binding "and__0__auto__"
							tmp12 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
							tmp13 := lang.Apply(tmp12, []any{v9})
							var v14 any = tmp13
							_ = v14
							var tmp15 any
							if lang.IsTruthy(v14) {
								tmp16 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp17 := checkDerefVar(var_glojure_DOT_core_first)
								tmp18 := lang.Apply(tmp17, []any{v9})
								tmp19 := lang.Apply(tmp16, []any{sym_quote, tmp18})
								tmp15 = tmp19
							} else {
								tmp15 = v14
							}
							tmp11 = tmp15
						} // end let
						if lang.IsTruthy(tmp11) {
							tmp12 := checkDerefVar(var_glojure_DOT_core_second)
							tmp13 := lang.Apply(tmp12, []any{v9})
							tmp10 = tmp13
						} else {
							tmp10 = v9
						}
						return tmp10
					})
					tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3434), kw_column, int(20), kw_end_DASH_line, int(3434), kw_end_DASH_column, int(73))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp11 := lang.Apply(tmp7, []any{tmp10, v5})
					var v12 any = tmp11
					_ = v12
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_do})
					tmp17 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp18 lang.FnFunc
					tmp18 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v19 := args[0]
						_ = v19
						tmp20 := checkDerefVar(var_glojure_DOT_core_list)
						tmp21 := lang.Apply(tmp20, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Import, v19})
						return tmp21
					})
					tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3436), kw_column, int(17), kw_end_DASH_line, int(3436), kw_end_DASH_column, int(73))
					tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp21 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp22 lang.FnFunc
					tmp22 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v23 := args[0]
						_ = v23
						v24 := args[1]
						_ = v24
						var tmp25 any
						tmp26 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
						tmp27 := lang.Apply(tmp26, []any{v24})
						if lang.IsTruthy(tmp27) {
							tmp28 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp29 := checkDerefVar(var_glojure_DOT_core_name)
							tmp30 := lang.Apply(tmp29, []any{v24})
							tmp31 := lang.Apply(tmp28, []any{v23, tmp30})
							tmp25 = tmp31
						} else {
							var tmp32 any
							{ // let
								// let binding "p"
								tmp33 := checkDerefVar(var_glojure_DOT_core_first)
								tmp34 := lang.Apply(tmp33, []any{v24})
								var v35 any = tmp34
								_ = v35
								// let binding "cs"
								tmp36 := checkDerefVar(var_glojure_DOT_core_rest)
								tmp37 := lang.Apply(tmp36, []any{v24})
								var v38 any = tmp37
								_ = v38
								tmp39 := checkDerefVar(var_glojure_DOT_core_into1)
								tmp40 := checkDerefVar(var_glojure_DOT_core_map)
								var tmp41 lang.FnFunc
								tmp41 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v42 := args[0]
									_ = v42
									tmp43 := checkDerefVar(var_glojure_DOT_core_str)
									tmp44 := lang.Apply(tmp43, []any{v35, ".", v42})
									return tmp44
								})
								tmp42 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3441), kw_column, int(45), kw_end_DASH_line, int(3441), kw_end_DASH_column, int(58))
								tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp44 := lang.Apply(tmp40, []any{tmp43, v38})
								tmp45 := lang.Apply(tmp39, []any{v23, tmp44})
								tmp32 = tmp45
							} // end let
							tmp25 = tmp32
						}
						return tmp25
					})
					tmp23 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3437), kw_column, int(26), kw_end_DASH_line, int(3441), kw_end_DASH_column, int(66))
					tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp25 := lang.NewVector()
					tmp26 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3442), kw_column, int(25), kw_end_DASH_line, int(3442), kw_end_DASH_column, int(26))
					tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp28 := lang.Apply(tmp21, []any{tmp24, tmp27, v12})
					tmp29 := lang.Apply(tmp17, []any{tmp20, tmp28})
					tmp30 := lang.Apply(tmp14, []any{tmp16, tmp29})
					tmp31 := lang.Apply(tmp13, []any{tmp30})
					tmp6 = tmp31
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inc
	{
		var tmp1 lang.FnFunc
		{ // function inc__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_unchecked_inc
				} else {
					tmp14 = sym_inc
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_inc.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one greater than num. Does not auto-promote\n  longs, will throw on overflow. See also: inc'", kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(915), kw_end_DASH_line, int(915))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Inc")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Inc is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inc'
	{
		var tmp1 lang.FnFunc
		{ // function inc'__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_IncP})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_inc_TICK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one greater than num. Supports arbitrary precision.\n  See also: inc", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(908), kw_end_DASH_line, int(908))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IncP")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IncP is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// indexed?
	{
		tmp0 := sym_indexed_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Return true if coll implements Indexed, indicating efficient lookup by index", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(6263), kw_end_DASH_line, int(6263))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// infinite?
	{
		var tmp1 lang.FnFunc
		{ // function infinite?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym_Double_SLASH_isInfinite})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_infinite_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_inline, tmp1, kw_doc, "Returns true if num is negative or positive infinity, else false", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(7977), kw_end_DASH_line, int(7977))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inst-ms
	{
		tmp0 := sym_inst_DASH_ms.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_inst)), kw_doc, "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6831), kw_end_DASH_line, int(6831))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inst?
	{
		tmp0 := sym_inst_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x satisfies Inst", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(6837), kw_end_DASH_line, int(6837))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// instance?
	{
		tmp0 := sym_instance_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_c, sym_x)), kw_doc, "Evaluates x and tests if it is an instance of the type\n    t. Returns true or false", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(2), kw_line, int(139), kw_end_DASH_line, int(143))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function instance?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.HasType, []any{v4, v5})
				return tmp6
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(143), kw_column, int(12), kw_end_DASH_line, int(143), kw_end_DASH_column, int(85))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int
	{
		var tmp1 lang.FnFunc
		{ // function int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_uncheckedIntCast
				} else {
					tmp14 = sym_intCast
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to int", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(875), kw_end_DASH_line, int(875))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime.RT, "IntCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IntCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int-array
	{
		var tmp1 lang.FnFunc
		{ // function int-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_IntArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_int_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of ints", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(5356), kw_end_DASH_line, int(5356))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IntArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("IntArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "IntArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("IntArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int?
	{
		tmp0 := sym_int_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a fixed precision integer", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1395), kw_end_DASH_line, int(1395))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{lang.Builtins["int64"], v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp8 = v7
				} else {
					var tmp9 any
					{ // let
						// let binding "or__0__auto__"
						tmp10 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{nil, v3})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							tmp13 = v12
						} else {
							var tmp14 any
							{ // let
								// let binding "or__0__auto__"
								tmp15 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
								tmp16 := lang.Apply(tmp15, []any{nil, v3})
								var v17 any = tmp16
								_ = v17
								var tmp18 any
								if lang.IsTruthy(v17) {
									tmp18 = v17
								} else {
									tmp19 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
									tmp20 := lang.Apply(tmp19, []any{nil, v3})
									tmp18 = tmp20
								}
								tmp14 = tmp18
							} // end let
							tmp13 = tmp14
						}
						tmp9 = tmp13
					} // end let
					tmp8 = tmp9
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// integer?
	{
		tmp0 := sym_integer_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is an integer", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1379), kw_end_DASH_line, int(1379))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.IsInteger, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// interleave
	{
		tmp0 := sym_interleave.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_c1), lang.NewVector(sym_c1, sym_c2), lang.NewVector(sym_c1, sym_c2, sym__AMP_, sym_colls)), kw_doc, "Returns a lazy seq of the first item in each coll, then the second etc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4308), kw_end_DASH_line, int(4308))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return lang.NewList()
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					return v3
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "s1"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v3})
						var v9 any = tmp8
						_ = v9
						// let binding "s2"
						tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp11 := lang.Apply(tmp10, []any{v4})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						var tmp14 any
						{ // let
							// let binding "and__0__auto__"
							var v15 any = v9
							_ = v15
							var tmp16 any
							if lang.IsTruthy(v15) {
								tmp16 = v12
							} else {
								tmp16 = v15
							}
							tmp14 = tmp16
						} // end let
						if lang.IsTruthy(tmp14) {
							tmp15 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp16 := checkDerefVar(var_glojure_DOT_core_first)
							tmp17 := lang.Apply(tmp16, []any{v9})
							tmp18 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp19 := checkDerefVar(var_glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v12})
							tmp21 := checkDerefVar(var_glojure_DOT_core_interleave)
							tmp22 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp23 := lang.Apply(tmp22, []any{v9})
							tmp24 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp25 := lang.Apply(tmp24, []any{v12})
							tmp26 := lang.Apply(tmp21, []any{tmp23, tmp25})
							tmp27 := lang.Apply(tmp18, []any{tmp20, tmp26})
							tmp28 := lang.Apply(tmp15, []any{tmp17, tmp27})
							tmp13 = tmp28
						} else {
						}
						tmp6 = tmp13
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp7 any
					{ // let
						// let binding "ss"
						tmp8 := checkDerefVar(var_glojure_DOT_core_map)
						tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp10 := checkDerefVar(var_glojure_DOT_core_conj)
						tmp11 := lang.Apply(tmp10, []any{v5, v4, v3})
						tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						tmp15 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
						tmp16 := checkDerefVar(var_glojure_DOT_core_identity)
						tmp17 := lang.Apply(tmp15, []any{tmp16, v13})
						if lang.IsTruthy(tmp17) {
							tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp19 := checkDerefVar(var_glojure_DOT_core_map)
							tmp20 := checkDerefVar(var_glojure_DOT_core_first)
							tmp21 := lang.Apply(tmp19, []any{tmp20, v13})
							tmp22 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp23 := checkDerefVar(var_glojure_DOT_core_interleave)
							tmp24 := checkDerefVar(var_glojure_DOT_core_map)
							tmp25 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp26 := lang.Apply(tmp24, []any{tmp25, v13})
							tmp27 := lang.Apply(tmp22, []any{tmp23, tmp26})
							tmp28 := lang.Apply(tmp18, []any{tmp21, tmp27})
							tmp14 = tmp28
						} else {
						}
						tmp7 = tmp14
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// intern
	{
		tmp0 := sym_intern.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns, sym_name), lang.NewVector(sym_ns, sym_name, sym_val)), kw_doc, "Finds or creates a var named by the symbol name in the namespace\n  ns (which can be a symbol or a namespace), setting its root binding\n  to val if supplied. The namespace must exist. The var will adopt any\n  metadata from the name symbol.  Returns the var.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6311), kw_end_DASH_line, int(6311))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "v"
					tmp6 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
					tmp7 := lang.Apply(tmp6, []any{v3})
					tmp8 := lang.Apply(nil, []any{tmp7, v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp12 := lang.Apply(tmp11, []any{v4})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp14 := lang.Apply(tmp13, []any{v4})
						tmp15, _ := lang.FieldOrMethod(v9, "setMeta")
						if reflect.TypeOf(tmp15).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMeta is not a function")))
						}
						tmp16 := lang.Apply(tmp15, []any{tmp14})
						tmp10 = tmp16
					} else {
					}
					_ = tmp10
					tmp5 = v9
				} // end let
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "v"
					tmp7 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
					tmp8 := lang.Apply(tmp7, []any{v3})
					tmp9 := lang.Apply(nil, []any{tmp8, v4, v5})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					tmp12 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp13 := lang.Apply(tmp12, []any{v4})
					if lang.IsTruthy(tmp13) {
						tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp15 := lang.Apply(tmp14, []any{v4})
						tmp16, _ := lang.FieldOrMethod(v10, "setMeta")
						if reflect.TypeOf(tmp16).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMeta is not a function")))
						}
						tmp17 := lang.Apply(tmp16, []any{tmp15})
						tmp11 = tmp17
					} else {
					}
					_ = tmp11
					tmp6 = v10
				} // end let
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// interpose
	{
		tmp0 := sym_interpose.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sep), lang.NewVector(sym_sep, sym_coll)), kw_doc, "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(5230), kw_end_DASH_line, int(5230))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "started"
						tmp7 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{false})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								tmp14 := checkDerefVar(var_glojure_DOT_core_deref)
								tmp15 := lang.Apply(tmp14, []any{v9})
								if lang.IsTruthy(tmp15) {
									var tmp16 any
									{ // let
										// let binding "sepr"
										tmp17 := lang.Apply(v5, []any{v11, v3})
										var v18 any = tmp17
										_ = v18
										var tmp19 any
										tmp20 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
										tmp21 := lang.Apply(tmp20, []any{v18})
										if lang.IsTruthy(tmp21) {
											tmp19 = v18
										} else {
											tmp22 := lang.Apply(v5, []any{v18, v12})
											tmp19 = tmp22
										}
										tmp16 = tmp19
									} // end let
									tmp13 = tmp16
								} else {
									tmp17 := checkDerefVar(var_glojure_DOT_core_vreset_BANG_)
									tmp18 := lang.Apply(tmp17, []any{v9, true})
									_ = tmp18
									tmp19 := lang.Apply(v5, []any{v11, v12})
									tmp13 = tmp19
								}
								return tmp13
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5238), kw_column, int(8), kw_end_DASH_line, int(5249), kw_end_DASH_column, int(35))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5236), kw_column, int(4), kw_end_DASH_line, int(5249), kw_end_DASH_column, int(37))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_drop)
				tmp6 := checkDerefVar(var_glojure_DOT_core_interleave)
				tmp7 := checkDerefVar(var_glojure_DOT_core_repeat)
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp9 := lang.Apply(tmp6, []any{tmp8, v4})
				tmp10 := lang.Apply(tmp5, []any{int64(1), tmp9})
				return tmp10
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into
	{
		tmp0 := sym_into.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_to), lang.NewVector(sym_to, sym_from), lang.NewVector(sym_to, sym_xform, sym_from)), kw_doc, "Returns a new coll consisting of to with all of the items of\n  from conjoined. A transducer may be supplied.\n  (into x) returns x. (into) returns [].", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6922), kw_end_DASH_line, int(6922))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.NewVector()
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6928), kw_column, int(7), kw_end_DASH_line, int(6928), kw_end_DASH_column, int(8))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp10 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
					tmp11 := checkDerefVar(var_glojure_DOT_core_reduce)
					tmp12 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_transient)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp15 := lang.Apply(tmp11, []any{tmp12, tmp14, v4})
					tmp16 := lang.Apply(tmp10, []any{tmp15})
					tmp17 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.Apply(tmp9, []any{tmp16, tmp18})
					tmp5 = tmp19
				} else {
					tmp20 := checkDerefVar(var_glojure_DOT_core_reduce)
					tmp21 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp22 := lang.Apply(tmp20, []any{tmp21, v3, v4})
					tmp5 = tmp22
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp8 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					{ // let
						// let binding "tm"
						tmp11 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp12 := lang.Apply(tmp11, []any{v3})
						var v13 any = tmp12
						_ = v13
						// let binding "rf"
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 1:
								v15 := args[0]
								_ = v15
								tmp16 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
								tmp17 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
								tmp18 := lang.Apply(tmp17, []any{v15})
								tmp19 := lang.Apply(tmp16, []any{tmp18, v13})
								return tmp19
							case 2:
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								tmp17 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
								tmp18 := lang.Apply(tmp17, []any{v15, v16})
								return tmp18
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6937), kw_column, int(17), kw_end_DASH_line, int(6939), kw_end_DASH_column, int(44))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v17 any = tmp16
						_ = v17
						tmp18 := checkDerefVar(var_glojure_DOT_core_transduce)
						tmp19 := checkDerefVar(var_glojure_DOT_core_transient)
						tmp20 := lang.Apply(tmp19, []any{v3})
						tmp21 := lang.Apply(tmp18, []any{v4, v17, tmp20, v5})
						tmp10 = tmp21
					} // end let
					tmp6 = tmp10
				} else {
					tmp11 := checkDerefVar(var_glojure_DOT_core_transduce)
					tmp12 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp13 := lang.Apply(tmp11, []any{v4, tmp12, v3, v5})
					tmp6 = tmp13
				}
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into-array
	{
		tmp0 := sym_into_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_aseq), lang.NewVector(sym_type, sym_aseq)), kw_doc, "Returns an array with components set to the values in aseq. The array's\n  component type is type if provided, or the type of the first value in\n  aseq if present, or Object. All values in aseq must be compatible with\n  the component type. Class objects for the primitive types can be obtained\n  using, e.g., Integer/TYPE.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(3444), kw_end_DASH_line, int(3444))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := lang.Apply(tmp4, []any{v3})
				tmp6 := lang.Apply(nil, []any{tmp5})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7 := lang.Apply(nil, []any{v3, tmp6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into1
	{
		tmp0 := sym_into1.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_to, sym_from)), kw_doc, "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(3416), kw_end_DASH_line, int(3416), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			if lang.IsTruthy(tmp8) {
				tmp9 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
				tmp10 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp11 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
				tmp12 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp10, []any{tmp11, tmp13, v4})
				tmp15 := lang.Apply(tmp9, []any{tmp14})
				tmp5 = tmp15
			} else {
				tmp16 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp17 := checkDerefVar(var_glojure_DOT_core_conj)
				tmp18 := lang.Apply(tmp16, []any{tmp17, v3, v4})
				tmp5 = tmp18
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ints
	{
		var tmp1 lang.FnFunc
		{ // function ints
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_Ints})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_ints.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to int[]", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(12), kw_line, int(5397), kw_end_DASH_line, int(5397))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Ints")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Ints is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// io!
	{
		tmp0 := sym_io_BANG_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "If an io! block occurs in a transaction, throws an\n  IllegalStateException, else runs body in an implicit do. If the\n  first expression in body is a literal string, will use that as the\n  exception message.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(11), kw_line, int(2504), kw_end_DASH_line, int(2504))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "message"
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
					tmp9 := checkDerefVar(var_glojure_DOT_core_first)
					tmp10 := lang.Apply(tmp9, []any{v5})
					tmp11 := lang.Apply(tmp8, []any{tmp10})
					if lang.IsTruthy(tmp11) {
						tmp12 := checkDerefVar(var_glojure_DOT_core_first)
						tmp13 := lang.Apply(tmp12, []any{v5})
						tmp7 = tmp13
					} else {
					}
					var v14 any = tmp7
					_ = v14
					// let binding "body"
					var tmp15 any
					if lang.IsTruthy(v14) {
						tmp16 := checkDerefVar(var_glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v5})
						tmp15 = tmp17
					} else {
						tmp15 = v5
					}
					var v18 any = tmp15
					_ = v18
					tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{sym_if})
					tmp23 := checkDerefVar(var_glojure_DOT_core_list)
					tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{sym_glojure_DOT_lang_DOT_LockingTransaction_SLASH_isRunning})
					tmp28 := lang.Apply(tmp25, []any{tmp27})
					tmp29 := lang.Apply(tmp24, []any{tmp28})
					tmp30 := lang.Apply(tmp23, []any{tmp29})
					tmp31 := checkDerefVar(var_glojure_DOT_core_list)
					tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp33 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp34 := checkDerefVar(var_glojure_DOT_core_list)
					tmp35 := lang.Apply(tmp34, []any{sym_throw})
					tmp36 := checkDerefVar(var_glojure_DOT_core_list)
					tmp37 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp38 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp39 := checkDerefVar(var_glojure_DOT_core_list)
					tmp40 := lang.Apply(tmp39, []any{sym_new})
					tmp41 := checkDerefVar(var_glojure_DOT_core_list)
					tmp42 := lang.Apply(tmp41, []any{sym_glojure_DOT_core_SLASH_IllegalStateException})
					tmp43 := checkDerefVar(var_glojure_DOT_core_list)
					var tmp44 any
					{ // let
						// let binding "or__0__auto__"
						var v45 any = v14
						_ = v45
						var tmp46 any
						if lang.IsTruthy(v45) {
							tmp46 = v45
						} else {
							tmp46 = "I/O in transaction"
						}
						tmp44 = tmp46
					} // end let
					tmp45 := lang.Apply(tmp43, []any{tmp44})
					tmp46 := lang.Apply(tmp38, []any{tmp40, tmp42, tmp45})
					tmp47 := lang.Apply(tmp37, []any{tmp46})
					tmp48 := lang.Apply(tmp36, []any{tmp47})
					tmp49 := lang.Apply(tmp33, []any{tmp35, tmp48})
					tmp50 := lang.Apply(tmp32, []any{tmp49})
					tmp51 := lang.Apply(tmp31, []any{tmp50})
					tmp52 := checkDerefVar(var_glojure_DOT_core_list)
					tmp53 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp54 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp55 := checkDerefVar(var_glojure_DOT_core_list)
					tmp56 := lang.Apply(tmp55, []any{sym_do})
					tmp57 := lang.Apply(tmp54, []any{tmp56, v18})
					tmp58 := lang.Apply(tmp53, []any{tmp57})
					tmp59 := lang.Apply(tmp52, []any{tmp58})
					tmp60 := lang.Apply(tmp20, []any{tmp22, tmp30, tmp51, tmp59})
					tmp61 := lang.Apply(tmp19, []any{tmp60})
					tmp6 = tmp61
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// isa?
	{
		tmp0 := sym_isa_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_child, sym_parent), lang.NewVector(sym_h, sym_child, sym_parent)), kw_doc, "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a Java type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(5543), kw_end_DASH_line, int(5543))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_isa_QMARK_)
				tmp6 := checkDerefVar(var_glojure_DOT_core_global_DASH_hierarchy)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3, v4})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "or__0__auto__"
					tmp7 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp8 := lang.Apply(tmp7, []any{v4, v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp10 = v9
					} else {
						var tmp11 any
						{ // let
							// let binding "or__0__auto__"
							var tmp12 any
							{ // let
								// let binding "and__0__auto__"
								tmp13 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
								tmp14 := lang.Apply(tmp13, []any{v5})
								var v15 any = tmp14
								_ = v15
								var tmp16 any
								if lang.IsTruthy(v15) {
									var tmp17 any
									{ // let
										// let binding "and__0__auto__"
										tmp18 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
										tmp19 := lang.Apply(tmp18, []any{v4})
										var v20 any = tmp19
										_ = v20
										var tmp21 any
										if lang.IsTruthy(v20) {
											tmp22, _ := lang.FieldOrMethod(v4, "AssignableTo")
											if reflect.TypeOf(tmp22).Kind() != reflect.Func {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("AssignableTo is not a function")))
											}
											tmp23 := lang.Apply(tmp22, []any{v5})
											tmp21 = tmp23
										} else {
											tmp21 = v20
										}
										tmp17 = tmp21
									} // end let
									tmp16 = tmp17
								} else {
									tmp16 = v15
								}
								tmp12 = tmp16
							} // end let
							var v13 any = tmp12
							_ = v13
							var tmp14 any
							if lang.IsTruthy(v13) {
								tmp14 = v13
							} else {
								var tmp15 any
								{ // let
									// let binding "or__0__auto__"
									tmp16 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
									tmp17 := lang.Apply(kw_ancestors, []any{v3})
									tmp18 := lang.Apply(tmp17, []any{v4})
									tmp19 := lang.Apply(tmp16, []any{tmp18, v5})
									var v20 any = tmp19
									_ = v20
									var tmp21 any
									if lang.IsTruthy(v20) {
										tmp21 = v20
									} else {
										var tmp22 any
										{ // let
											// let binding "or__0__auto__"
											var tmp23 any
											{ // let
												// let binding "and__0__auto__"
												tmp24 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
												tmp25 := lang.Apply(tmp24, []any{v4})
												var v26 any = tmp25
												_ = v26
												var tmp27 any
												if lang.IsTruthy(v26) {
													tmp28 := checkDerefVar(var_glojure_DOT_core_some)
													var tmp29 lang.FnFunc
													tmp29 = lang.NewFnFunc(func(args ...any) any {
														checkArity(args, 1)
														v30 := args[0]
														_ = v30
														tmp31 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
														tmp32 := lang.Apply(kw_ancestors, []any{v3})
														tmp33 := lang.Apply(tmp32, []any{v30})
														tmp34 := lang.Apply(tmp31, []any{tmp33, v5})
														return tmp34
													})
													tmp30 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5556), kw_column, int(34), kw_end_DASH_line, int(5556), kw_end_DASH_column, int(71))
													tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
													if err != nil {
														panic(err)
													}
													tmp32 := checkDerefVar(var_glojure_DOT_core_supers)
													tmp33 := lang.Apply(tmp32, []any{v4})
													tmp34 := lang.Apply(tmp28, []any{tmp31, tmp33})
													tmp27 = tmp34
												} else {
													tmp27 = v26
												}
												tmp23 = tmp27
											} // end let
											var v24 any = tmp23
											_ = v24
											var tmp25 any
											if lang.IsTruthy(v24) {
												tmp25 = v24
											} else {
												var tmp26 any
												{ // let
													// let binding "and__0__auto__"
													tmp27 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
													tmp28 := lang.Apply(tmp27, []any{v5})
													var v29 any = tmp28
													_ = v29
													var tmp30 any
													if lang.IsTruthy(v29) {
														var tmp31 any
														{ // let
															// let binding "and__0__auto__"
															tmp32 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
															tmp33 := lang.Apply(tmp32, []any{v4})
															var v34 any = tmp33
															_ = v34
															var tmp35 any
															if lang.IsTruthy(v34) {
																var tmp36 any
																{ // let
																	// let binding "and__0__auto__"
																	tmp37 := checkDerefVar(var_glojure_DOT_core__EQ_)
																	tmp38 := checkDerefVar(var_glojure_DOT_core_count)
																	tmp39 := lang.Apply(tmp38, []any{v5})
																	tmp40 := checkDerefVar(var_glojure_DOT_core_count)
																	tmp41 := lang.Apply(tmp40, []any{v4})
																	tmp42 := lang.Apply(tmp37, []any{tmp39, tmp41})
																	var v43 any = tmp42
																	_ = v43
																	var tmp44 any
																	if lang.IsTruthy(v43) {
																		var tmp45 any
																		{ // let
																			// let binding "ret"
																			var v46 any = true
																			_ = v46
																			// let binding "i"
																			var v47 any = int64(0)
																			_ = v47
																			for {
																				var tmp48 any
																				var tmp49 any
																				{ // let
																					// let binding "or__0__auto__"
																					tmp50 := checkDerefVar(var_glojure_DOT_core_not)
																					tmp51 := lang.Apply(tmp50, []any{v46})
																					var v52 any = tmp51
																					_ = v52
																					var tmp53 any
																					if lang.IsTruthy(v52) {
																						tmp53 = v52
																					} else {
																						tmp54 := checkDerefVar(var_glojure_DOT_core__EQ_)
																						tmp55 := checkDerefVar(var_glojure_DOT_core_count)
																						tmp56 := lang.Apply(tmp55, []any{v5})
																						tmp57 := lang.Apply(tmp54, []any{v47, tmp56})
																						tmp53 = tmp57
																					}
																					tmp49 = tmp53
																				} // end let
																				if lang.IsTruthy(tmp49) {
																					tmp48 = v46
																				} else {
																					tmp51 := checkDerefVar(var_glojure_DOT_core_isa_QMARK_)
																					tmp52 := lang.Apply(v4, []any{v47})
																					tmp53 := lang.Apply(v5, []any{v47})
																					tmp54 := lang.Apply(tmp51, []any{v3, tmp52, tmp53})
																					var tmp50 any = tmp54
																					tmp56 := checkDerefVar(var_glojure_DOT_core_inc)
																					tmp57 := lang.Apply(tmp56, []any{v47})
																					var tmp55 any = tmp57
																					v46 = tmp50
																					v47 = tmp55
																					continue
																				}
																				tmp45 = tmp48
																				break
																			}
																		} // end let
																		tmp44 = tmp45
																	} else {
																		tmp44 = v43
																	}
																	tmp36 = tmp44
																} // end let
																tmp35 = tmp36
															} else {
																tmp35 = v34
															}
															tmp31 = tmp35
														} // end let
														tmp30 = tmp31
													} else {
														tmp30 = v29
													}
													tmp26 = tmp30
												} // end let
												tmp25 = tmp26
											}
											tmp22 = tmp25
										} // end let
										tmp21 = tmp22
									}
									tmp15 = tmp21
								} // end let
								tmp14 = tmp15
							}
							tmp11 = tmp14
						} // end let
						tmp10 = tmp11
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iterate
	{
		tmp0 := sym_iterate.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_x)), kw_doc, "Returns a lazy (infinite!) sequence of x, (f x), (f (f x)) etc.\n  f must be free of side-effects", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3011), kw_end_DASH_line, int(3011))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iteration
	{
		tmp0 := sym_iteration.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_step, sym__AMP_, lang.NewMap(kw_keys, lang.NewVector(sym_somef, sym_vf, sym_kf, sym_initk), kw_or, lang.NewMap(sym_vf, sym_identity, sym_kf, sym_identity, sym_somef, sym_some_QMARK_, sym_initk, nil)))), kw_doc, "Creates a seqable/reducible via repeated calls to step,\n  a function of some (continuation token) 'k'. The first call to step\n  will be passed initk, returning 'ret'. Iff (somef ret) is true,\n  (vf ret) will be included in the iteration, else iteration will\n  terminate and vf/kf will not be called. If (kf ret) is non-nil it\n  will be passed to the next step call, else iteration will terminate.\n\n  This can be used e.g. to consume APIs that return paginated or batched data.\n\n   step - (possibly impure) fn of 'k' -> 'ret'\n\n   :somef - fn of 'ret' -> logical true/false, default 'some?'\n   :vf - fn of 'ret' -> 'v', a value produced by the iteration, default 'identity'\n   :kf - fn of 'ret' -> 'next-k' or nil (signaling 'do not continue'), default 'identity'\n   :initk - the first value passed to step, default 'nil'\n\n  It is presumed that step with non-initk is unreproducible/non-idempotent.\n  If step with initk is unreproducible it is on the consumer to not consume twice.", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(7716), kw_end_DASH_line, int(7716))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "map__357"
					var v6 any = v4
					_ = v6
					// let binding "map__357"
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v6})
					if lang.IsTruthy(tmp9) {
						var tmp10 any
						tmp11 := checkDerefVar(var_glojure_DOT_core_next)
						tmp12 := lang.Apply(tmp11, []any{v6})
						if lang.IsTruthy(tmp12) {
							tmp13 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
							tmp14 := lang.Apply(tmp13, []any{v6})
							tmp15 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp14})
							tmp10 = tmp15
						} else {
							var tmp16 any
							tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp18 := lang.Apply(tmp17, []any{v6})
							if lang.IsTruthy(tmp18) {
								tmp19 := checkDerefVar(var_glojure_DOT_core_first)
								tmp20 := lang.Apply(tmp19, []any{v6})
								tmp16 = tmp20
							} else {
							}
							tmp10 = tmp16
						}
						tmp7 = tmp10
					} else {
						tmp7 = v6
					}
					var v21 any = tmp7
					_ = v21
					// let binding "somef"
					tmp22 := checkDerefVar(var_glojure_DOT_core_get)
					tmp23 := checkDerefVar(var_glojure_DOT_core_some_QMARK_)
					tmp24 := lang.Apply(tmp22, []any{v21, kw_somef, tmp23})
					var v25 any = tmp24
					_ = v25
					// let binding "vf"
					tmp26 := checkDerefVar(var_glojure_DOT_core_get)
					tmp27 := checkDerefVar(var_glojure_DOT_core_identity)
					tmp28 := lang.Apply(tmp26, []any{v21, kw_vf, tmp27})
					var v29 any = tmp28
					_ = v29
					// let binding "kf"
					tmp30 := checkDerefVar(var_glojure_DOT_core_get)
					tmp31 := checkDerefVar(var_glojure_DOT_core_identity)
					tmp32 := lang.Apply(tmp30, []any{v21, kw_kf, tmp31})
					var v33 any = tmp32
					_ = v33
					// let binding "initk"
					tmp34 := checkDerefVar(var_glojure_DOT_core_get)
					tmp35 := lang.Apply(tmp34, []any{v21, kw_initk, nil})
					var v36 any = tmp35
					_ = v36
					tmp37 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp38 := lang.NewVector(nil)
					tmp39 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7743), kw_column, int(9), kw_end_DASH_line, int(7743), kw_end_DASH_column, int(11))
					tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp41 lang.FnFunc
					{ // function next
						var v42 lang.FnFunc
						tmp41 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v43 := args[0]
							_ = v43
							var tmp44 any
							tmp45 := lang.Apply(v25, []any{v43})
							if lang.IsTruthy(tmp45) {
								tmp46 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp47 := lang.Apply(v29, []any{v43})
								var tmp48 any
								{ // let
									// let binding "temp__0__auto__"
									tmp49 := lang.Apply(v33, []any{v43})
									var v50 any = tmp49
									_ = v50
									var tmp51 any
									tmp52 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
									tmp53 := lang.Apply(tmp52, []any{v50})
									if lang.IsTruthy(tmp53) {
									} else {
										var tmp54 any
										{ // let
											// let binding "k"
											var v55 any = v50
											_ = v55
											var tmp56 lang.FnFunc
											tmp56 = lang.NewFnFunc(func(args ...any) any {
												checkArity(args, 0)
												tmp57 := lang.Apply(v3, []any{v55})
												tmp58 := lang.Apply(v42, []any{tmp57})
												return tmp58
											})
											tmp57 := lang.Apply(lang.NewLazySeq, []any{tmp56})
											tmp54 = tmp57
										} // end let
										tmp51 = tmp54
									}
									tmp48 = tmp51
								} // end let
								tmp49 := lang.Apply(tmp46, []any{tmp47, tmp48})
								tmp44 = tmp49
							} else {
							}
							return tmp44
						})
						v42 = tmp41
						_ = v42
					}
					tmp42 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7744), kw_column, int(10), kw_end_DASH_line, int(7748), kw_end_DASH_column, int(51))
					tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp44 := lang.Apply(v3, []any{v36})
					tmp45 := lang.Apply(tmp43, []any{tmp44})
					tmp46 := lang.Apply(tmp37, []any{tmp40, tmp45})
					tmp47 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
					tmp48 := checkDerefVar(var_glojure_DOT_core_reduce)
					tmp49 := lang.NewVector(nil, nil, nil)
					tmp50 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7751), kw_column, int(12), kw_end_DASH_line, int(7751), kw_end_DASH_column, int(22))
					tmp51, err := lang.WithMeta(tmp49, tmp50.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp52 any
					{ // let
						// let binding "acc"
						var v53 any = nil
						_ = v53
						// let binding "ret"
						tmp54 := lang.Apply(v3, []any{v36})
						var v55 any = tmp54
						_ = v55
						for {
							var tmp56 any
							tmp57 := lang.Apply(v25, []any{v55})
							if lang.IsTruthy(tmp57) {
								var tmp58 any
								{ // let
									// let binding "acc"
									tmp59 := lang.Apply(v29, []any{v55})
									tmp60 := lang.Apply(nil, []any{v53, tmp59})
									var v61 any = tmp60
									_ = v61
									var tmp62 any
									tmp63 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
									tmp64 := lang.Apply(tmp63, []any{v61})
									if lang.IsTruthy(tmp64) {
										tmp65 := checkDerefVar(var_glojure_DOT_core_deref)
										tmp66 := lang.Apply(tmp65, []any{v61})
										tmp62 = tmp66
									} else {
										var tmp67 any
										{ // let
											// let binding "temp__0__auto__"
											tmp68 := lang.Apply(v33, []any{v55})
											var v69 any = tmp68
											_ = v69
											var tmp70 any
											tmp71 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
											tmp72 := lang.Apply(tmp71, []any{v69})
											if lang.IsTruthy(tmp72) {
												tmp70 = v61
											} else {
												var tmp73 any
												{ // let
													// let binding "k"
													var v74 any = v69
													_ = v74
													var tmp75 any = v61
													tmp77 := lang.Apply(v3, []any{v74})
													var tmp76 any = tmp77
													v53 = tmp75
													v55 = tmp76
													continue
												} // end let
												tmp70 = tmp73
											}
											tmp67 = tmp70
										} // end let
										tmp62 = tmp67
									}
									tmp58 = tmp62
								} // end let
								tmp56 = tmp58
							} else {
								tmp56 = v53
							}
							tmp52 = tmp56
							break
						}
					} // end let
					tmp53 := lang.Apply(tmp48, []any{tmp51, tmp52})
					tmp54 := lang.Apply(nil, []any{nil, tmp46, tmp47, tmp53})
					tmp5 = tmp54
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iterator-seq
	{
		tmp0 := sym_iterator_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_iter)), kw_doc, "Returns a seq on a java.util.Iterator. Note that most collections\n  providing iterators implement Iterable and thus support seq directly.\n  Seqs cache values, thus iterator-seq should not be used on any\n  iterator that repeatedly returns the same mutable object.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(5700), kw_end_DASH_line, int(5700))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// juxt
	{
		tmp0 := sym_juxt.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_g), lang.NewVector(sym_f, sym_g, sym_h), lang.NewVector(sym_f, sym_g, sym_h, sym__AMP_, sym_fs)), kw_doc, "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2568), kw_end_DASH_line, int(2568))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp5 := lang.Apply(v3, nil)
						tmp6 := lang.NewVector(tmp5)
						tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2578), kw_column, int(12), kw_end_DASH_line, int(2578), kw_end_DASH_column, int(16))
						tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp8
					case 1:
						v5 := args[0]
						_ = v5
						tmp6 := lang.Apply(v3, []any{v5})
						tmp7 := lang.NewVector(tmp6)
						tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2579), kw_column, int(13), kw_end_DASH_line, int(2579), kw_end_DASH_column, int(19))
						tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp9
					case 2:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						tmp7 := lang.Apply(v3, []any{v5, v6})
						tmp8 := lang.NewVector(tmp7)
						tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2580), kw_column, int(15), kw_end_DASH_line, int(2580), kw_end_DASH_column, int(23))
						tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp10
					case 3:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v5, v6, v7})
						tmp9 := lang.NewVector(tmp8)
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2581), kw_column, int(17), kw_end_DASH_line, int(2581), kw_end_DASH_column, int(27))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp11
					default:
						checkArity(args, 3)
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						var v8 any = lang.NewList(args[3:]...)
						_ = v8
						tmp9 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp10 := lang.Apply(tmp9, []any{v3, v5, v6, v7, v8})
						tmp11 := lang.NewVector(tmp10)
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2582), kw_column, int(24), kw_end_DASH_line, int(2582), kw_end_DASH_column, int(45))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp13
					}
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2577), kw_column, int(6), kw_end_DASH_line, int(2582), kw_end_DASH_column, int(47))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v3, nil)
						tmp7 := lang.Apply(v4, nil)
						tmp8 := lang.NewVector(tmp6, tmp7)
						tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2585), kw_column, int(12), kw_end_DASH_line, int(2585), kw_end_DASH_column, int(20))
						tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp10
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v3, []any{v6})
						tmp8 := lang.Apply(v4, []any{v6})
						tmp9 := lang.NewVector(tmp7, tmp8)
						tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2586), kw_column, int(13), kw_end_DASH_line, int(2586), kw_end_DASH_column, int(25))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp11
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v6, v7})
						tmp9 := lang.Apply(v4, []any{v6, v7})
						tmp10 := lang.NewVector(tmp8, tmp9)
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2587), kw_column, int(15), kw_end_DASH_line, int(2587), kw_end_DASH_column, int(31))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp12
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v6, v7, v8})
						tmp10 := lang.Apply(v4, []any{v6, v7, v8})
						tmp11 := lang.NewVector(tmp9, tmp10)
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2588), kw_column, int(17), kw_end_DASH_line, int(2588), kw_end_DASH_column, int(37))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp13
					default:
						checkArity(args, 3)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp11 := lang.Apply(tmp10, []any{v3, v6, v7, v8, v9})
						tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp13 := lang.Apply(tmp12, []any{v4, v6, v7, v8, v9})
						tmp14 := lang.NewVector(tmp11, tmp13)
						tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2589), kw_column, int(24), kw_end_DASH_line, int(2589), kw_end_DASH_column, int(66))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp16
					}
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2584), kw_column, int(6), kw_end_DASH_line, int(2589), kw_end_DASH_column, int(68))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp7 := lang.Apply(v3, nil)
						tmp8 := lang.Apply(v4, nil)
						tmp9 := lang.Apply(v5, nil)
						tmp10 := lang.NewVector(tmp7, tmp8, tmp9)
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2592), kw_column, int(12), kw_end_DASH_line, int(2592), kw_end_DASH_column, int(24))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp12
					case 1:
						v7 := args[0]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v7})
						tmp9 := lang.Apply(v4, []any{v7})
						tmp10 := lang.Apply(v5, []any{v7})
						tmp11 := lang.NewVector(tmp8, tmp9, tmp10)
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2593), kw_column, int(13), kw_end_DASH_line, int(2593), kw_end_DASH_column, int(31))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp13
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v7, v8})
						tmp10 := lang.Apply(v4, []any{v7, v8})
						tmp11 := lang.Apply(v5, []any{v7, v8})
						tmp12 := lang.NewVector(tmp9, tmp10, tmp11)
						tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2594), kw_column, int(15), kw_end_DASH_line, int(2594), kw_end_DASH_column, int(39))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp14
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						tmp10 := lang.Apply(v3, []any{v7, v8, v9})
						tmp11 := lang.Apply(v4, []any{v7, v8, v9})
						tmp12 := lang.Apply(v5, []any{v7, v8, v9})
						tmp13 := lang.NewVector(tmp10, tmp11, tmp12)
						tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2595), kw_column, int(17), kw_end_DASH_line, int(2595), kw_end_DASH_column, int(47))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp15
					default:
						checkArity(args, 3)
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp12 := lang.Apply(tmp11, []any{v3, v7, v8, v9, v10})
						tmp13 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp14 := lang.Apply(tmp13, []any{v4, v7, v8, v9, v10})
						tmp15 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp16 := lang.Apply(tmp15, []any{v5, v7, v8, v9, v10})
						tmp17 := lang.NewVector(tmp12, tmp14, tmp16)
						tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2596), kw_column, int(24), kw_end_DASH_line, int(2596), kw_end_DASH_column, int(87))
						tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp19
					}
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2591), kw_column, int(6), kw_end_DASH_line, int(2596), kw_end_DASH_column, int(89))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "fs"
					tmp8 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
					tmp9 := lang.Apply(tmp8, []any{v3, v4, v5, v6})
					var v10 any = tmp9
					_ = v10
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp12 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp13 lang.FnFunc
							tmp13 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v14 := args[0]
								_ = v14
								v15 := args[1]
								_ = v15
								tmp16 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp17 := lang.Apply(v15, nil)
								tmp18 := lang.Apply(tmp16, []any{v14, tmp17})
								return tmp18
							})
							tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2600), kw_column, int(23), kw_end_DASH_line, int(2600), kw_end_DASH_column, int(37))
							tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 := lang.NewVector()
							tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2600), kw_column, int(39), kw_end_DASH_line, int(2600), kw_end_DASH_column, int(40))
							tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp19 := lang.Apply(tmp12, []any{tmp15, tmp18, v10})
							return tmp19
						case 1:
							v12 := args[0]
							_ = v12
							tmp13 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp14 lang.FnFunc
							tmp14 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								tmp17 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp18 := lang.Apply(v16, []any{v12})
								tmp19 := lang.Apply(tmp17, []any{v15, tmp18})
								return tmp19
							})
							tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2601), kw_column, int(24), kw_end_DASH_line, int(2601), kw_end_DASH_column, int(40))
							tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 := lang.NewVector()
							tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2601), kw_column, int(42), kw_end_DASH_line, int(2601), kw_end_DASH_column, int(43))
							tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp20 := lang.Apply(tmp13, []any{tmp16, tmp19, v10})
							return tmp20
						case 2:
							v12 := args[0]
							_ = v12
							v13 := args[1]
							_ = v13
							tmp14 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp15 lang.FnFunc
							tmp15 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v16 := args[0]
								_ = v16
								v17 := args[1]
								_ = v17
								tmp18 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp19 := lang.Apply(v17, []any{v12, v13})
								tmp20 := lang.Apply(tmp18, []any{v16, tmp19})
								return tmp20
							})
							tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2602), kw_column, int(26), kw_end_DASH_line, int(2602), kw_end_DASH_column, int(44))
							tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp18 := lang.NewVector()
							tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2602), kw_column, int(46), kw_end_DASH_line, int(2602), kw_end_DASH_column, int(47))
							tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp21 := lang.Apply(tmp14, []any{tmp17, tmp20, v10})
							return tmp21
						case 3:
							v12 := args[0]
							_ = v12
							v13 := args[1]
							_ = v13
							v14 := args[2]
							_ = v14
							tmp15 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp16 lang.FnFunc
							tmp16 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v17 := args[0]
								_ = v17
								v18 := args[1]
								_ = v18
								tmp19 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp20 := lang.Apply(v18, []any{v12, v13, v14})
								tmp21 := lang.Apply(tmp19, []any{v17, tmp20})
								return tmp21
							})
							tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2603), kw_column, int(28), kw_end_DASH_line, int(2603), kw_end_DASH_column, int(48))
							tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp19 := lang.NewVector()
							tmp20 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2603), kw_column, int(50), kw_end_DASH_line, int(2603), kw_end_DASH_column, int(51))
							tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp22 := lang.Apply(tmp15, []any{tmp18, tmp21, v10})
							return tmp22
						default:
							checkArity(args, 3)
							v12 := args[0]
							_ = v12
							v13 := args[1]
							_ = v13
							v14 := args[2]
							_ = v14
							var v15 any = lang.NewList(args[3:]...)
							_ = v15
							tmp16 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp17 lang.FnFunc
							tmp17 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v18 := args[0]
								_ = v18
								v19 := args[1]
								_ = v19
								tmp20 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp21 := checkDerefVar(var_glojure_DOT_core_apply)
								tmp22 := lang.Apply(tmp21, []any{v19, v12, v13, v14, v15})
								tmp23 := lang.Apply(tmp20, []any{v18, tmp22})
								return tmp23
							})
							tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2604), kw_column, int(35), kw_end_DASH_line, int(2604), kw_end_DASH_column, int(66))
							tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp20 := lang.NewVector()
							tmp21 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2604), kw_column, int(68), kw_end_DASH_line, int(2604), kw_end_DASH_column, int(69))
							tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp23 := lang.Apply(tmp16, []any{tmp19, tmp22, v10})
							return tmp23
						}
					})
					tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2599), kw_column, int(8), kw_end_DASH_line, int(2604), kw_end_DASH_column, int(75))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp7 = tmp13
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keep
	{
		tmp0 := sym_keep.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_coll)), kw_doc, "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(7339), kw_end_DASH_line, int(7339))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "v"
								tmp10 := lang.Apply(v3, []any{v8})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								tmp13 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
								tmp14 := lang.Apply(tmp13, []any{v11})
								if lang.IsTruthy(tmp14) {
									tmp12 = v7
								} else {
									tmp15 := lang.Apply(v5, []any{v7, v11})
									tmp12 = tmp15
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						default:
							checkArity(args, -1)
							panic("unreachable")
						}
					})
					tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7347), kw_column, int(6), kw_end_DASH_line, int(7354), kw_end_DASH_column, int(31))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7346), kw_column, int(4), kw_end_DASH_line, int(7354), kw_end_DASH_column, int(32))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								tmp14 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
								tmp15 := lang.Apply(tmp14, []any{v12})
								if lang.IsTruthy(tmp15) {
									var tmp16 any
									{ // let
										// let binding "c"
										tmp17 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
										tmp18 := lang.Apply(tmp17, []any{v12})
										var v19 any = tmp18
										_ = v19
										// let binding "size"
										tmp20 := checkDerefVar(var_glojure_DOT_core_count)
										tmp21 := lang.Apply(tmp20, []any{v19})
										var v22 any = tmp21
										_ = v22
										// let binding "b"
										tmp23 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_buffer)
										tmp24 := lang.Apply(tmp23, []any{v22})
										var v25 any = tmp24
										_ = v25
										var tmp26 any
										{ // let
											// let binding "n__0__auto__"
											tmp27 := checkDerefVar(var_glojure_DOT_core_long)
											tmp28 := lang.Apply(tmp27, []any{v22})
											var v29 any = tmp28
											_ = v29
											var tmp30 any
											{ // let
												// let binding "i"
												var v31 any = int64(0)
												_ = v31
												for {
													var tmp32 any
													tmp33 := checkDerefVar(var_glojure_DOT_core__LT_)
													tmp34 := lang.Apply(tmp33, []any{v31, v29})
													if lang.IsTruthy(tmp34) {
														var tmp35 any
														{ // let
															// let binding "x"
															tmp36, _ := lang.FieldOrMethod(v19, "nth")
															if reflect.TypeOf(tmp36).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp37 := lang.Apply(tmp36, []any{v31})
															tmp38 := lang.Apply(v3, []any{tmp37})
															var v39 any = tmp38
															_ = v39
															var tmp40 any
															tmp41 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
															tmp42 := lang.Apply(tmp41, []any{v39})
															if lang.IsTruthy(tmp42) {
															} else {
																tmp43 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_append)
																tmp44 := lang.Apply(tmp43, []any{v25, v39})
																tmp40 = tmp44
															}
															tmp35 = tmp40
														} // end let
														_ = tmp35
														tmp37 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
														tmp38 := lang.Apply(tmp37, []any{v31})
														var tmp36 any = tmp38
														v31 = tmp36
														continue
													} else {
													}
													tmp30 = tmp32
													break
												}
											} // end let
											tmp26 = tmp30
										} // end let
										_ = tmp26
										tmp27 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
										tmp28 := checkDerefVar(var_glojure_DOT_core_chunk)
										tmp29 := lang.Apply(tmp28, []any{v25})
										tmp30 := checkDerefVar(var_glojure_DOT_core_keep)
										tmp31 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
										tmp32 := lang.Apply(tmp31, []any{v12})
										tmp33 := lang.Apply(tmp30, []any{v3, tmp32})
										tmp34 := lang.Apply(tmp27, []any{tmp29, tmp33})
										tmp16 = tmp34
									} // end let
									tmp13 = tmp16
								} else {
									var tmp17 any
									{ // let
										// let binding "x"
										tmp18 := checkDerefVar(var_glojure_DOT_core_first)
										tmp19 := lang.Apply(tmp18, []any{v12})
										tmp20 := lang.Apply(v3, []any{tmp19})
										var v21 any = tmp20
										_ = v21
										var tmp22 any
										tmp23 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
										tmp24 := lang.Apply(tmp23, []any{v21})
										if lang.IsTruthy(tmp24) {
											tmp25 := checkDerefVar(var_glojure_DOT_core_keep)
											tmp26 := checkDerefVar(var_glojure_DOT_core_rest)
											tmp27 := lang.Apply(tmp26, []any{v12})
											tmp28 := lang.Apply(tmp25, []any{v3, tmp27})
											tmp22 = tmp28
										} else {
											tmp29 := checkDerefVar(var_glojure_DOT_core_cons)
											tmp30 := checkDerefVar(var_glojure_DOT_core_keep)
											tmp31 := checkDerefVar(var_glojure_DOT_core_rest)
											tmp32 := lang.Apply(tmp31, []any{v12})
											tmp33 := lang.Apply(tmp30, []any{v3, tmp32})
											tmp34 := lang.Apply(tmp29, []any{v21, tmp33})
											tmp22 = tmp34
										}
										tmp17 = tmp22
									} // end let
									tmp13 = tmp17
								}
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keep-indexed
	{
		tmp0 := sym_keep_DASH_indexed.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_coll)), kw_doc, "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(7372), kw_end_DASH_line, int(7372))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "iv"
						tmp7 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{int64(-1)})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "i"
									tmp14 := checkDerefVar(var_glojure_DOT_core_inc)
									tmp15, ok := lang.FieldOrMethod(v9, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Deref")))
									}
									var tmp16 any
									switch reflect.TypeOf(tmp15).Kind() {
									case reflect.Func:
										tmp16 = lang.Apply(tmp15, nil)
									default:
										tmp16 = tmp15
									}
									tmp17 := lang.Apply(tmp14, []any{tmp16})
									tmp18, _ := lang.FieldOrMethod(v9, "reset")
									if reflect.TypeOf(tmp18).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp19 := lang.Apply(tmp18, []any{tmp17})
									var v20 any = tmp19
									_ = v20
									// let binding "v"
									tmp21 := lang.Apply(v3, []any{v20, v12})
									var v22 any = tmp21
									_ = v22
									var tmp23 any
									tmp24 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
									tmp25 := lang.Apply(tmp24, []any{v22})
									if lang.IsTruthy(tmp25) {
										tmp23 = v11
									} else {
										tmp26 := lang.Apply(v5, []any{v11, v22})
										tmp23 = tmp26
									}
									tmp13 = tmp23
								} // end let
								return tmp13
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7382), kw_column, int(8), kw_end_DASH_line, int(7390), kw_end_DASH_column, int(33))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7380), kw_column, int(4), kw_end_DASH_line, int(7390), kw_end_DASH_column, int(35))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return nil
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// key
	{
		tmp0 := sym_key.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_e)), kw_doc, "Returns the key of the map entry.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1563), kw_end_DASH_line, int(1563))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "GetKey")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("GetKey is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keys
	{
		tmp0 := sym_keys.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map)), kw_doc, "Returns a sequence of the map's keys, in the same order as (seq map).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1551), kw_end_DASH_line, int(1551))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.Keys, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keyword
	{
		tmp1 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp0 := sym_keyword.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_name), lang.NewVector(sym_ns, sym_name)), kw_doc, "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(609), kw_end_DASH_line, int(609))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp5 = v4
				} else {
					var tmp8 any
					tmp9 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v4})
					if lang.IsTruthy(tmp10) {
						tmp11 := lang.Apply(lang.InternKeywordSymbol, []any{v4})
						tmp8 = tmp11
					} else {
						var tmp12 any
						tmp13 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
						tmp14 := lang.Apply(tmp13, []any{v4})
						if lang.IsTruthy(tmp14) {
							tmp15 := lang.Apply(lang.InternKeywordString, []any{v4})
							tmp12 = tmp15
						} else {
						}
						tmp8 = tmp12
					}
					tmp5 = tmp8
				}
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.InternKeyword, []any{v4, v5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp4 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keyword?
	{
		tmp0 := sym_keyword_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a Keyword", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(563), kw_end_DASH_line, int(563))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// last
	{
		tmp0 := sym_last.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Return the last item in coll, in linear time", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(262), kw_end_DASH_line, int(266))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function last
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
			recur_loop_32:
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_next)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_next)
					tmp10 := lang.Apply(tmp9, []any{v4})
					var tmp8 any = tmp10
					v4 = tmp8
					goto recur_loop_32
				} else {
					tmp11 := checkDerefVar(var_glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v4})
					tmp5 = tmp12
				}
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(266), kw_column, int(7), kw_end_DASH_line, int(269), kw_end_DASH_column, int(21))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lazy-cat
	{
		tmp0 := sym_lazy_DASH_cat.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_colls)), kw_doc, "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(4636), kw_end_DASH_line, int(4636))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_concat})
				tmp10 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v12 := args[0]
					_ = v12
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_lazy_DASH_seq, v12})
					return tmp14
				})
				tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4644), kw_column, int(19), kw_end_DASH_line, int(4644), kw_end_DASH_column, int(37))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.Apply(tmp10, []any{tmp13, v5})
				tmp15 := lang.Apply(tmp7, []any{tmp9, tmp14})
				tmp16 := lang.Apply(tmp6, []any{tmp15})
				return tmp16
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lazy-seq
	{
		tmp0 := sym_lazy_DASH_seq.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Takes a body of expressions that returns an ISeq or nil, and yields\n  a Seqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls. See also - realized?", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(676), kw_end_DASH_line, int(676))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
				tmp8 := lang.NewVector()
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(683), kw_column, int(101), kw_end_DASH_line, int(683), kw_end_DASH_column, int(102))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := lang.Apply(tmp7, []any{sym_fn_STAR_, tmp10, v5})
				tmp12 := lang.Apply(tmp6, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_NewLazySeq, tmp11})
				return tmp12
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// let
	{
		tmp0 := sym_let.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "binding => binding-form init-expr\n  binding-form => name, or destructuring-form\n  destructuring-form => map-destructure-form, or seq-destructure-form\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\n\n  See https://glojure.org/reference/special_forms#binding-forms for\n  more information about destructuring.", kw_forms, lang.NewVector(lang.NewList(sym_let, lang.NewVector(sym_bindings_STAR_), sym_exprs_STAR_)), kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(11), kw_line, int(4496), kw_end_DASH_line, int(4496), kw_special_DASH_form, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_str)
					tmp11 := checkDerefVar(var_glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(kw_line, []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(var_glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				tmp33 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp34 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp35 := checkDerefVar(var_glojure_DOT_core_list)
				tmp36 := lang.Apply(tmp35, []any{sym_let_STAR_})
				tmp37 := checkDerefVar(var_glojure_DOT_core_list)
				tmp38 := checkDerefVar(var_glojure_DOT_core_destructure)
				tmp39 := lang.Apply(tmp38, []any{v5})
				tmp40 := lang.Apply(tmp37, []any{tmp39})
				tmp41 := lang.Apply(tmp34, []any{tmp36, tmp40, v6})
				tmp42 := lang.Apply(tmp33, []any{tmp41})
				return tmp42
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// letfn
	{
		tmp0 := sym_letfn.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_fnspecs, sym__AMP_, sym_body)), kw_doc, "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body.", kw_forms, lang.NewVector(lang.NewList(sym_letfn, lang.NewVector(sym_fnspecs_STAR_), sym_exprs_STAR_)), kw_url, nil, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(6545), kw_end_DASH_line, int(6545), kw_special_DASH_form, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_letfn_STAR_})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_vec)
				tmp13 := checkDerefVar(var_glojure_DOT_core_interleave)
				tmp14 := checkDerefVar(var_glojure_DOT_core_map)
				tmp15 := checkDerefVar(var_glojure_DOT_core_first)
				tmp16 := lang.Apply(tmp14, []any{tmp15, v5})
				tmp17 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp18 lang.FnFunc
				tmp18 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v19 := args[0]
					_ = v19
					tmp20 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp21 := lang.Apply(tmp20, []any{sym_glojure_DOT_core_SLASH_fn, v19})
					return tmp21
				})
				tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6555), kw_column, int(35), kw_end_DASH_line, int(6555), kw_end_DASH_column, int(47))
				tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp21 := lang.Apply(tmp17, []any{tmp20, v5})
				tmp22 := lang.Apply(tmp13, []any{tmp16, tmp21})
				tmp23 := lang.Apply(tmp12, []any{tmp22})
				tmp24 := lang.Apply(tmp11, []any{tmp23})
				tmp25 := lang.Apply(tmp8, []any{tmp10, tmp24, v6})
				tmp26 := lang.Apply(tmp7, []any{tmp25})
				return tmp26
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// libspec?
	{
		tmp0 := sym_libspec_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is a libspec", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(5848), kw_end_DASH_line, int(5848), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp8 = v7
				} else {
					var tmp9 any
					{ // let
						// let binding "and__0__auto__"
						tmp10 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v3})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							var tmp14 any
							{ // let
								// let binding "or__0__auto__"
								tmp15 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
								tmp16 := checkDerefVar(var_glojure_DOT_core_second)
								tmp17 := lang.Apply(tmp16, []any{v3})
								tmp18 := lang.Apply(tmp15, []any{tmp17})
								var v19 any = tmp18
								_ = v19
								var tmp20 any
								if lang.IsTruthy(v19) {
									tmp20 = v19
								} else {
									tmp21 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
									tmp22 := checkDerefVar(var_glojure_DOT_core_second)
									tmp23 := lang.Apply(tmp22, []any{v3})
									tmp24 := lang.Apply(tmp21, []any{tmp23})
									tmp20 = tmp24
								}
								tmp14 = tmp20
							} // end let
							tmp13 = tmp14
						} else {
							tmp13 = v12
						}
						tmp9 = tmp13
					} // end let
					tmp8 = tmp9
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lift-ns
	{
		tmp0 := sym_lift_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m)), kw_doc, "Returns [lifted-ns lifted-kvs] or nil if m can't be lifted.", kw_file, "glojure/core_print.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(8), kw_line, int(261), kw_end_DASH_line, int(261), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_namespace_DASH_maps_STAR_)
			if lang.IsTruthy(tmp5) {
				var tmp6 any
				{ // let
					// let binding "ns"
					var v7 any = nil
					_ = v7
					// let binding "G__221"
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := lang.Apply(tmp8, []any{v3})
					var v10 any = tmp9
					_ = v10
					// let binding "vec__222"
					var v11 any = v10
					_ = v11
					// let binding "seq__223"
					tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp13 := lang.Apply(tmp12, []any{v11})
					var v14 any = tmp13
					_ = v14
					// let binding "first__224"
					tmp15 := checkDerefVar(var_glojure_DOT_core_first)
					tmp16 := lang.Apply(tmp15, []any{v14})
					var v17 any = tmp16
					_ = v17
					// let binding "seq__223"
					tmp18 := checkDerefVar(var_glojure_DOT_core_next)
					tmp19 := lang.Apply(tmp18, []any{v14})
					var v20 any = tmp19
					_ = v20
					// let binding "vec__225"
					var v21 any = v17
					_ = v21
					// let binding "k"
					tmp22 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp23 := lang.Apply(tmp22, []any{v21, int64(0), nil})
					var v24 any = tmp23
					_ = v24
					// let binding "v"
					tmp25 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp26 := lang.Apply(tmp25, []any{v21, int64(1), nil})
					var v27 any = tmp26
					_ = v27
					// let binding "entry"
					var v28 any = v21
					_ = v28
					// let binding "entries"
					var v29 any = v20
					_ = v29
					// let binding "kvs"
					tmp30 := lang.NewVector()
					tmp31 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(267), kw_column, int(16), kw_end_DASH_line, int(267), kw_end_DASH_column, int(17))
					tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v33 any = tmp32
					_ = v33
					var tmp34 any
					{ // let
						// let binding "ns"
						var v35 any = v7
						_ = v35
						// let binding "G__221"
						var v36 any = v10
						_ = v36
						// let binding "kvs"
						var v37 any = v33
						_ = v37
						for {
							var tmp38 any
							{ // let
								// let binding "ns"
								var v39 any = v35
								_ = v39
								// let binding "vec__228"
								var v40 any = v36
								_ = v40
								// let binding "seq__229"
								tmp41 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp42 := lang.Apply(tmp41, []any{v40})
								var v43 any = tmp42
								_ = v43
								// let binding "first__230"
								tmp44 := checkDerefVar(var_glojure_DOT_core_first)
								tmp45 := lang.Apply(tmp44, []any{v43})
								var v46 any = tmp45
								_ = v46
								// let binding "seq__229"
								tmp47 := checkDerefVar(var_glojure_DOT_core_next)
								tmp48 := lang.Apply(tmp47, []any{v43})
								var v49 any = tmp48
								_ = v49
								// let binding "vec__231"
								var v50 any = v46
								_ = v50
								// let binding "k"
								tmp51 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp52 := lang.Apply(tmp51, []any{v50, int64(0), nil})
								var v53 any = tmp52
								_ = v53
								// let binding "v"
								tmp54 := checkDerefVar(var_glojure_DOT_core_nth)
								tmp55 := lang.Apply(tmp54, []any{v50, int64(1), nil})
								var v56 any = tmp55
								_ = v56
								// let binding "entry"
								var v57 any = v50
								_ = v57
								// let binding "entries"
								var v58 any = v49
								_ = v58
								// let binding "kvs"
								var v59 any = v37
								_ = v59
								var tmp60 any
								if lang.IsTruthy(v57) {
									var tmp61 any
									tmp62 := checkDerefVar(var_glojure_DOT_core_qualified_DASH_ident_QMARK_)
									tmp63 := lang.Apply(tmp62, []any{v53})
									if lang.IsTruthy(tmp63) {
										var tmp64 any
										if lang.IsTruthy(v39) {
											var tmp65 any
											tmp66 := checkDerefVar(var_glojure_DOT_core__EQ_)
											tmp67 := checkDerefVar(var_glojure_DOT_core_namespace)
											tmp68 := lang.Apply(tmp67, []any{v53})
											tmp69 := lang.Apply(tmp66, []any{v39, tmp68})
											if lang.IsTruthy(tmp69) {
												var tmp70 any = v39
												var tmp71 any = v58
												tmp73 := checkDerefVar(var_glojure_DOT_core_conj)
												tmp74 := checkDerefVar(var_glojure_DOT_core_strip_DASH_ns)
												tmp75 := lang.Apply(tmp74, []any{v53})
												tmp76 := lang.NewVector(tmp75, v56)
												tmp77 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(272), kw_column, int(43), kw_end_DASH_line, int(272), kw_end_DASH_column, int(58))
												tmp78, err := lang.WithMeta(tmp76, tmp77.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp79 := lang.Apply(tmp73, []any{v59, tmp78})
												var tmp72 any = tmp79
												v35 = tmp70
												v36 = tmp71
												v37 = tmp72
												continue
											} else {
											}
											tmp64 = tmp65
										} else {
											var tmp80 any
											{ // let
												// let binding "temp__0__auto__"
												tmp81 := checkDerefVar(var_glojure_DOT_core_namespace)
												tmp82 := lang.Apply(tmp81, []any{v53})
												var v83 any = tmp82
												_ = v83
												var tmp84 any
												if lang.IsTruthy(v83) {
													var tmp85 any
													{ // let
														// let binding "new-ns"
														var v86 any = v83
														_ = v86
														var tmp87 any = v86
														var tmp88 any = v58
														tmp90 := checkDerefVar(var_glojure_DOT_core_conj)
														tmp91 := checkDerefVar(var_glojure_DOT_core_strip_DASH_ns)
														tmp92 := lang.Apply(tmp91, []any{v53})
														tmp93 := lang.NewVector(tmp92, v56)
														tmp94 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(274), kw_column, int(47), kw_end_DASH_line, int(274), kw_end_DASH_column, int(62))
														tmp95, err := lang.WithMeta(tmp93, tmp94.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp96 := lang.Apply(tmp90, []any{v59, tmp95})
														var tmp89 any = tmp96
														v35 = tmp87
														v36 = tmp88
														v37 = tmp89
														continue
													} // end let
													tmp84 = tmp85
												} else {
												}
												tmp80 = tmp84
											} // end let
											tmp64 = tmp80
										}
										tmp61 = tmp64
									} else {
									}
									tmp60 = tmp61
								} else {
									tmp81 := lang.NewVector(v39, v59)
									tmp82 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(275), kw_column, int(9), kw_end_DASH_line, int(275), kw_end_DASH_column, int(16))
									tmp83, err := lang.WithMeta(tmp81, tmp82.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp60 = tmp83
								}
								tmp38 = tmp60
							} // end let
							tmp34 = tmp38
							break
						}
					} // end let
					tmp6 = tmp34
				} // end let
				tmp4 = tmp6
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// line-seq
	{
		tmp0 := sym_line_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_rdr)), kw_doc, "Returns the lines of text from rdr as a lazy sequence of strings.\n  rdr must implement java.io.BufferedReader.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(3068), kw_end_DASH_line, int(3068))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5, ok := lang.FieldOrMethod(v3, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "readLine")))
				}
				var tmp6 any
				switch reflect.TypeOf(tmp5).Kind() {
				case reflect.Func:
					tmp6 = lang.Apply(tmp5, nil)
				default:
					tmp6 = tmp5
				}
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "line"
						var v10 any = v7
						_ = v10
						tmp11 := checkDerefVar(var_glojure_DOT_core_cons)
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							tmp13 := checkDerefVar(var_glojure_DOT_core_line_DASH_seq)
							tmp14 := lang.Apply(tmp13, []any{v3})
							return tmp14
						})
						tmp13 := lang.Apply(lang.NewLazySeq, []any{tmp12})
						tmp14 := lang.Apply(tmp11, []any{v10, tmp13})
						tmp9 = tmp14
					} // end let
					tmp8 = tmp9
				} else {
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list
	{
		tmp0 := sym_list.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_items)), kw_doc, "Creates a new list containing the items.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(15), kw_end_DASH_line, int(18))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.NewList, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list*
	{
		tmp0 := sym_list_STAR_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_args), lang.NewVector(sym_a, sym_args), lang.NewVector(sym_a, sym_b, sym_args), lang.NewVector(sym_a, sym_b, sym_c, sym_args), lang.NewVector(sym_a, sym_b, sym_c, sym_d, sym__AMP_, sym_more)), kw_doc, "Creates a new seq containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(641), kw_end_DASH_line, int(641))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp7 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp8 := lang.Apply(tmp7, []any{v4, v5})
				tmp9 := lang.Apply(tmp6, []any{v3, tmp8})
				return tmp9
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp8 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp9 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v5, v6})
				tmp11 := lang.Apply(tmp8, []any{v4, tmp10})
				tmp12 := lang.Apply(tmp7, []any{v3, tmp11})
				return tmp12
			default:
				checkArity(args, 4)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp9 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp10 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp11 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp12 := checkDerefVar(var_glojure_DOT_core_spread)
				tmp13 := lang.Apply(tmp12, []any{v7})
				tmp14 := lang.Apply(tmp11, []any{v6, tmp13})
				tmp15 := lang.Apply(tmp10, []any{v5, tmp14})
				tmp16 := lang.Apply(tmp9, []any{v4, tmp15})
				tmp17 := lang.Apply(tmp8, []any{v3, tmp16})
				return tmp17
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list?
	{
		tmp0 := sym_list_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x implements IPersistentList", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(6198), kw_end_DASH_line, int(6198))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.IPersistentList)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load
	{
		tmp0 := sym_load.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_paths)), kw_doc, "Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_redef, true, kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6095), kw_end_DASH_line, int(6095))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "seq_133"
					tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp6 := lang.Apply(tmp5, []any{v3})
					var v7 any = tmp6
					_ = v7
					// let binding "chunk_134"
					var v8 any = nil
					_ = v8
					// let binding "count_135"
					var v9 any = int64(0)
					_ = v9
					// let binding "i_136"
					var v10 any = int64(0)
					_ = v10
					for {
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core__LT_)
						tmp13 := lang.Apply(tmp12, []any{v10, v9})
						if lang.IsTruthy(tmp13) {
							var tmp14 any
							{ // let
								// let binding "path"
								tmp15, _ := lang.FieldOrMethod(v8, "nth")
								if reflect.TypeOf(tmp15).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
								}
								tmp16 := lang.Apply(tmp15, []any{v10})
								var v17 any = tmp16
								_ = v17
								var tmp18 any
								{ // let
									// let binding "path"
									var tmp19 any
									tmp20 := lang.Apply(strings11.HasPrefix, []any{v17, "/"})
									if lang.IsTruthy(tmp20) {
										tmp19 = v17
									} else {
										tmp21 := checkDerefVar(var_glojure_DOT_core_str)
										tmp22 := checkDerefVar(var_glojure_DOT_core_root_DASH_directory)
										tmp23 := checkDerefVar(var_glojure_DOT_core_ns_DASH_name)
										tmp24 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
										tmp25 := lang.Apply(tmp23, []any{tmp24})
										tmp26 := lang.Apply(tmp22, []any{tmp25})
										tmp27 := lang.Apply(tmp21, []any{tmp26, lang.NewChar(47), v17})
										tmp19 = tmp27
									}
									var v28 any = tmp19
									_ = v28
									var tmp29 any
									tmp30 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
									if lang.IsTruthy(tmp30) {
										tmp31 := checkDerefVar(var_glojure_DOT_core_printf)
										tmp32 := lang.Apply(tmp31, []any{"(glojure.core/load \"%s\")\n", v28})
										_ = tmp32
										tmp33 := checkDerefVar(var_glojure_DOT_core_flush)
										tmp34 := lang.Apply(tmp33, nil)
										tmp29 = tmp34
									} else {
									}
									_ = tmp29
									tmp35 := checkDerefVar(var_glojure_DOT_core_check_DASH_cyclic_DASH_dependency)
									tmp36 := lang.Apply(tmp35, []any{v28})
									_ = tmp36
									var tmp37 any
									tmp38 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp39 := checkDerefVar(var_glojure_DOT_core_first)
									tmp40 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
									tmp41 := lang.Apply(tmp39, []any{tmp40})
									tmp42 := lang.Apply(tmp38, []any{v28, tmp41})
									if lang.IsTruthy(tmp42) {
									} else {
										var tmp43 any
										{ // let
											tmp44 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
											tmp45 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
											tmp46 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_pending_DASH_paths_STAR_)
											tmp47 := checkDerefVar(var_glojure_DOT_core_conj)
											tmp48 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
											tmp49 := lang.Apply(tmp47, []any{tmp48, v28})
											tmp50 := lang.Apply(tmp45, []any{tmp46, tmp49})
											tmp51 := lang.Apply(tmp44, []any{tmp50})
											_ = tmp51
											var tmp52 any
											func() {
												defer func() {
													tmp53 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
													tmp54 := lang.Apply(tmp53, nil)
													_ = tmp54
												}()
												tmp55 := lang.Apply(strings11.TrimPrefix, []any{v28, "/"})
												tmp56, _ := lang.FieldOrMethod(runtime.RT, "Load")
												if reflect.TypeOf(tmp56).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("Load is not a function")))
												}
												tmp57 := lang.Apply(tmp56, []any{tmp55})
												tmp52 = tmp57
											}()
											tmp43 = tmp52
										} // end let
										tmp37 = tmp43
									}
									tmp18 = tmp37
								} // end let
								_ = tmp18
								var tmp19 any = v7
								var tmp20 any = v8
								var tmp21 any = v9
								tmp23 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
								tmp24 := lang.Apply(tmp23, []any{v10})
								var tmp22 any = tmp24
								v7 = tmp19
								v8 = tmp20
								v9 = tmp21
								v10 = tmp22
								continue
							} // end let
							tmp11 = tmp14
						} else {
							var tmp15 any
							{ // let
								// let binding "temp__0__auto__"
								tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp17 := lang.Apply(tmp16, []any{v7})
								var v18 any = tmp17
								_ = v18
								var tmp19 any
								if lang.IsTruthy(v18) {
									var tmp20 any
									{ // let
										// let binding "seq_133"
										var v21 any = v18
										_ = v21
										var tmp22 any
										tmp23 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
										tmp24 := lang.Apply(tmp23, []any{v21})
										if lang.IsTruthy(tmp24) {
											var tmp25 any
											{ // let
												// let binding "c__0__auto__"
												tmp26 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
												tmp27 := lang.Apply(tmp26, []any{v21})
												var v28 any = tmp27
												_ = v28
												tmp30 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
												tmp31 := lang.Apply(tmp30, []any{v21})
												var tmp29 any = tmp31
												var tmp32 any = v28
												tmp34 := checkDerefVar(var_glojure_DOT_core_int)
												tmp35 := checkDerefVar(var_glojure_DOT_core_count)
												tmp36 := lang.Apply(tmp35, []any{v28})
												tmp37 := lang.Apply(tmp34, []any{tmp36})
												var tmp33 any = tmp37
												tmp39 := checkDerefVar(var_glojure_DOT_core_int)
												tmp40 := lang.Apply(tmp39, []any{int64(0)})
												var tmp38 any = tmp40
												v7 = tmp29
												v8 = tmp32
												v9 = tmp33
												v10 = tmp38
												continue
											} // end let
											tmp22 = tmp25
										} else {
											var tmp26 any
											{ // let
												// let binding "path"
												tmp27 := checkDerefVar(var_glojure_DOT_core_first)
												tmp28 := lang.Apply(tmp27, []any{v21})
												var v29 any = tmp28
												_ = v29
												var tmp30 any
												{ // let
													// let binding "path"
													var tmp31 any
													tmp32 := lang.Apply(strings11.HasPrefix, []any{v29, "/"})
													if lang.IsTruthy(tmp32) {
														tmp31 = v29
													} else {
														tmp33 := checkDerefVar(var_glojure_DOT_core_str)
														tmp34 := checkDerefVar(var_glojure_DOT_core_root_DASH_directory)
														tmp35 := checkDerefVar(var_glojure_DOT_core_ns_DASH_name)
														tmp36 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
														tmp37 := lang.Apply(tmp35, []any{tmp36})
														tmp38 := lang.Apply(tmp34, []any{tmp37})
														tmp39 := lang.Apply(tmp33, []any{tmp38, lang.NewChar(47), v29})
														tmp31 = tmp39
													}
													var v40 any = tmp31
													_ = v40
													var tmp41 any
													tmp42 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
													if lang.IsTruthy(tmp42) {
														tmp43 := checkDerefVar(var_glojure_DOT_core_printf)
														tmp44 := lang.Apply(tmp43, []any{"(glojure.core/load \"%s\")\n", v40})
														_ = tmp44
														tmp45 := checkDerefVar(var_glojure_DOT_core_flush)
														tmp46 := lang.Apply(tmp45, nil)
														tmp41 = tmp46
													} else {
													}
													_ = tmp41
													tmp47 := checkDerefVar(var_glojure_DOT_core_check_DASH_cyclic_DASH_dependency)
													tmp48 := lang.Apply(tmp47, []any{v40})
													_ = tmp48
													var tmp49 any
													tmp50 := checkDerefVar(var_glojure_DOT_core__EQ_)
													tmp51 := checkDerefVar(var_glojure_DOT_core_first)
													tmp52 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
													tmp53 := lang.Apply(tmp51, []any{tmp52})
													tmp54 := lang.Apply(tmp50, []any{v40, tmp53})
													if lang.IsTruthy(tmp54) {
													} else {
														var tmp55 any
														{ // let
															tmp56 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
															tmp57 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
															tmp58 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_pending_DASH_paths_STAR_)
															tmp59 := checkDerefVar(var_glojure_DOT_core_conj)
															tmp60 := checkDerefVar(var_glojure_DOT_core__STAR_pending_DASH_paths_STAR_)
															tmp61 := lang.Apply(tmp59, []any{tmp60, v40})
															tmp62 := lang.Apply(tmp57, []any{tmp58, tmp61})
															tmp63 := lang.Apply(tmp56, []any{tmp62})
															_ = tmp63
															var tmp64 any
															func() {
																defer func() {
																	tmp65 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
																	tmp66 := lang.Apply(tmp65, nil)
																	_ = tmp66
																}()
																tmp67 := lang.Apply(strings11.TrimPrefix, []any{v40, "/"})
																tmp68, _ := lang.FieldOrMethod(runtime.RT, "Load")
																if reflect.TypeOf(tmp68).Kind() != reflect.Func {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("Load is not a function")))
																}
																tmp69 := lang.Apply(tmp68, []any{tmp67})
																tmp64 = tmp69
															}()
															tmp55 = tmp64
														} // end let
														tmp49 = tmp55
													}
													tmp30 = tmp49
												} // end let
												_ = tmp30
												tmp32 := checkDerefVar(var_glojure_DOT_core_next)
												tmp33 := lang.Apply(tmp32, []any{v21})
												var tmp31 any = tmp33
												var tmp34 any = nil
												var tmp35 any = int64(0)
												var tmp36 any = int64(0)
												v7 = tmp31
												v8 = tmp34
												v9 = tmp35
												v10 = tmp36
												continue
											} // end let
											tmp22 = tmp26
										}
										tmp20 = tmp22
									} // end let
									tmp19 = tmp20
								} else {
								}
								tmp15 = tmp19
							} // end let
							tmp11 = tmp15
						}
						tmp4 = tmp11
						break
					}
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-all
	{
		tmp0 := sym_load_DASH_all.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_lib, sym_need_DASH_ns, sym_require)), kw_doc, "Loads a lib given its name and forces a load of any libs it directly or\n  indirectly loads. If need-ns, ensures that the associated namespace\n  exists after loading. If require, records the load so any duplicate loads\n  can be skipped.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(5892), kw_end_DASH_line, int(5892), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 0)
				tmp7 := checkDerefVar(var_glojure_DOT_core_commute)
				tmp8 := checkDerefVar(var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_)
				var tmp9 lang.FnFunc
				tmp9 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v10 := args[0]
					_ = v10
					v11 := args[1]
					_ = v11
					tmp12 := checkDerefVar(var_glojure_DOT_core_reduce1)
					tmp13 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp14 := lang.Apply(tmp12, []any{tmp13, v10, v11})
					return tmp14
				})
				tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5899), kw_column, int(27), kw_end_DASH_line, int(5899), kw_end_DASH_column, int(47))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp12 any
				{ // let
					tmp13 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
					tmp14 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp15 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_loaded_DASH_libs_STAR_)
					tmp16 := checkDerefVar(var_glojure_DOT_core_ref)
					tmp17 := checkDerefVar(var_glojure_DOT_core_sorted_DASH_set)
					tmp18 := lang.Apply(tmp17, nil)
					tmp19 := lang.Apply(tmp16, []any{tmp18})
					tmp20 := lang.Apply(tmp14, []any{tmp15, tmp19})
					tmp21 := lang.Apply(tmp13, []any{tmp20})
					_ = tmp21
					var tmp22 any
					func() {
						defer func() {
							tmp23 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
							tmp24 := lang.Apply(tmp23, nil)
							_ = tmp24
						}()
						tmp25 := checkDerefVar(var_glojure_DOT_core_load_DASH_one)
						tmp26 := lang.Apply(tmp25, []any{v3, v4, v5})
						_ = tmp26
						tmp27 := checkDerefVar(var_glojure_DOT_core_deref)
						tmp28 := checkDerefVar(var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_)
						tmp29 := lang.Apply(tmp27, []any{tmp28})
						tmp22 = tmp29
					}()
					tmp12 = tmp22
				} // end let
				tmp13 := lang.Apply(tmp7, []any{tmp8, tmp11, tmp12})
				return tmp13
			})
			tmp7, _ := lang.FieldOrMethod(lang.LockingTransaction, "RunInTransaction")
			if reflect.TypeOf(tmp7).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("RunInTransaction is not a function")))
			}
			tmp8 := lang.Apply(tmp7, []any{tmp6})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-data-reader-file
	{
		tmp0 := sym_load_DASH_data_DASH_reader_DASH_file.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7836), kw_column, int(8), kw_end_DASH_line, int(7836), kw_end_DASH_column, int(28), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_mappings, sym_url)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "rdr"
				tmp6, ok := lang.FieldOrMethod(v4, "openStream")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "openStream")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				tmp8 := lang.Apply(nil, []any{tmp7, "UTF-8"})
				tmp9 := lang.Apply(nil, []any{tmp8})
				var v10 any = tmp9
				_ = v10
				var tmp11 any
				func() {
					defer func() {
						tmp12, ok := lang.FieldOrMethod(v10, "close")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "close")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						_ = tmp13
					}()
					var tmp14 any
					{ // let
						tmp15 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp16 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp17 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_file_STAR_)
						tmp18, ok := lang.FieldOrMethod(v4, "getFile")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getFile")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						tmp20 := lang.Apply(tmp16, []any{tmp17, tmp19})
						tmp21 := lang.Apply(tmp15, []any{tmp20})
						_ = tmp21
						var tmp22 any
						func() {
							defer func() {
								tmp23 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp24 := lang.Apply(tmp23, nil)
								_ = tmp24
							}()
							var tmp25 any
							{ // let
								// let binding "read-opts"
								var tmp26 any
								tmp27, ok := lang.FieldOrMethod(v4, "getPath")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getPath")))
								}
								var tmp28 any
								switch reflect.TypeOf(tmp27).Kind() {
								case reflect.Func:
									tmp28 = lang.Apply(tmp27, nil)
								default:
									tmp28 = tmp27
								}
								tmp29, _ := lang.FieldOrMethod(tmp28, "endsWith")
								if reflect.TypeOf(tmp29).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("endsWith is not a function")))
								}
								tmp30 := lang.Apply(tmp29, []any{"cljc"})
								if lang.IsTruthy(tmp30) {
									tmp31 := lang.NewMap(kw_eof, nil, kw_read_DASH_cond, kw_allow)
									tmp32 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7842), kw_column, int(25), kw_end_DASH_line, int(7842), kw_end_DASH_column, int(52))
									tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp26 = tmp33
								} else {
									tmp34 := lang.NewMap(kw_eof, nil)
									tmp35 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7843), kw_column, int(25), kw_end_DASH_line, int(7843), kw_end_DASH_column, int(34))
									tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp26 = tmp36
								}
								var v37 any = tmp26
								_ = v37
								// let binding "new-mappings"
								tmp38 := checkDerefVar(var_glojure_DOT_core_read)
								tmp39 := lang.Apply(tmp38, []any{v37, v10})
								var v40 any = tmp39
								_ = v40
								var tmp41 any
								tmp42 := checkDerefVar(var_glojure_DOT_core_not)
								tmp43 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
								tmp44 := lang.Apply(tmp43, []any{v40})
								tmp45 := lang.Apply(tmp42, []any{tmp44})
								if lang.IsTruthy(tmp45) {
									tmp46 := checkDerefVar(var_glojure_DOT_core_ex_DASH_info)
									tmp47 := checkDerefVar(var_glojure_DOT_core_str)
									tmp48 := lang.Apply(tmp47, []any{"Not a valid data-reader map"})
									tmp49 := lang.NewMap(kw_url, v4)
									tmp50 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7847), kw_column, int(27), kw_end_DASH_line, int(7847), kw_end_DASH_column, int(36))
									tmp51, err := lang.WithMeta(tmp49, tmp50.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp52 := lang.Apply(tmp46, []any{tmp48, tmp51})
									panic(tmp52)
								} else {
								}
								_ = tmp41
								tmp53 := checkDerefVar(var_glojure_DOT_core_reduce)
								var tmp54 lang.FnFunc
								tmp54 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 2)
									v55 := args[0]
									_ = v55
									v56 := args[1]
									_ = v56
									var tmp57 any
									{ // let
										// let binding "vec__359"
										var v58 any = v56
										_ = v58
										// let binding "k"
										tmp59 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp60 := lang.Apply(tmp59, []any{v58, int64(0), nil})
										var v61 any = tmp60
										_ = v61
										// let binding "v"
										tmp62 := checkDerefVar(var_glojure_DOT_core_nth)
										tmp63 := lang.Apply(tmp62, []any{v58, int64(1), nil})
										var v64 any = tmp63
										_ = v64
										var tmp65 any
										tmp66 := checkDerefVar(var_glojure_DOT_core_not)
										tmp67 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
										tmp68 := lang.Apply(tmp67, []any{v61})
										tmp69 := lang.Apply(tmp66, []any{tmp68})
										if lang.IsTruthy(tmp69) {
											tmp70 := checkDerefVar(var_glojure_DOT_core_ex_DASH_info)
											tmp71 := checkDerefVar(var_glojure_DOT_core_str)
											tmp72 := lang.Apply(tmp71, []any{"Invalid form in data-reader file"})
											tmp73 := lang.NewMap(kw_url, v4, kw_form, v61)
											tmp74 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7852), kw_column, int(30), kw_end_DASH_line, int(7853), kw_end_DASH_column, int(38))
											tmp75, err := lang.WithMeta(tmp73, tmp74.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp76 := lang.Apply(tmp70, []any{tmp72, tmp75})
											panic(tmp76)
										} else {
										}
										_ = tmp65
										var tmp77 any
										{ // let
											// let binding "v-var"
											tmp78 := checkDerefVar(var_glojure_DOT_core_data_DASH_reader_DASH_var)
											tmp79 := lang.Apply(tmp78, []any{v64})
											var v80 any = tmp79
											_ = v80
											var tmp81 any
											var tmp82 any
											{ // let
												// let binding "and__0__auto__"
												tmp83 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
												tmp84 := lang.Apply(tmp83, []any{v3, v61})
												var v85 any = tmp84
												_ = v85
												var tmp86 any
												if lang.IsTruthy(v85) {
													tmp87 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
													tmp88 := lang.Apply(v3, []any{v61})
													tmp89 := lang.Apply(tmp87, []any{tmp88, v80})
													tmp86 = tmp89
												} else {
													tmp86 = v85
												}
												tmp82 = tmp86
											} // end let
											if lang.IsTruthy(tmp82) {
												tmp83 := checkDerefVar(var_glojure_DOT_core_ex_DASH_info)
												tmp84 := lang.NewMap(kw_url, v4, kw_conflict, v61, kw_mappings, v55)
												tmp85 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7858), kw_column, int(32), kw_end_DASH_line, int(7860), kw_end_DASH_column, int(44))
												tmp86, err := lang.WithMeta(tmp84, tmp85.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp87 := lang.Apply(tmp83, []any{"Conflicting data-reader mapping", tmp86})
												panic(tmp87)
											} else {
											}
											_ = tmp81
											tmp88 := checkDerefVar(var_glojure_DOT_core_assoc)
											tmp89 := lang.Apply(tmp88, []any{v55, v61, v80})
											tmp77 = tmp89
										} // end let
										tmp57 = tmp77
									} // end let
									return tmp57
								})
								tmp55 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7849), kw_column, int(10), kw_end_DASH_line, int(7861), kw_end_DASH_column, int(32))
								tmp56, err := lang.WithMeta(tmp54, tmp55.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp57 := lang.Apply(tmp53, []any{tmp56, v3, v40})
								tmp25 = tmp57
							} // end let
							tmp22 = tmp25
						}()
						tmp14 = tmp22
					} // end let
					tmp11 = tmp14
				}()
				tmp5 = tmp11
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-data-readers
	{
		tmp0 := sym_load_DASH_data_DASH_readers.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7865), kw_column, int(8), kw_end_DASH_line, int(7865), kw_end_DASH_column, int(24), kw_private, true, kw_arglists, lang.NewList(lang.NewVector()), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := checkDerefVar(var_glojure_DOT_core_alter_DASH_var_DASH_root)
			tmp4 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_data_DASH_readers_STAR_)
			var tmp5 lang.FnFunc
			tmp5 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v6 := args[0]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce)
				tmp8 := checkDerefVar(var_glojure_DOT_core_load_DASH_data_DASH_reader_DASH_file)
				tmp9 := checkDerefVar(var_glojure_DOT_core_data_DASH_reader_DASH_urls)
				tmp10 := lang.Apply(tmp9, nil)
				tmp11 := lang.Apply(tmp7, []any{tmp8, v6, tmp10})
				return tmp11
			})
			tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7867), kw_column, int(19), kw_end_DASH_line, int(7869), kw_end_DASH_column, int(57))
			tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp8 := lang.Apply(tmp3, []any{tmp4, tmp7})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-file
	{
		tmp0 := sym_load_DASH_file.WithMeta(lang.NewMap(kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-lib
	{
		tmp0 := sym_load_DASH_lib.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_prefix, sym_lib, sym__AMP_, sym_options)), kw_doc, "Loads a lib with options", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(5904), kw_end_DASH_line, int(5904), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
				var tmp7 any
				{ // let
					// let binding "and__0__auto__"
					var v8 any = v3
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp10 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp11 := checkDerefVar(var_glojure_DOT_core_name)
						tmp12 := lang.Apply(tmp11, []any{v4})
						tmp13 := checkDerefVar(var_glojure_DOT_core_int)
						tmp14 := lang.Apply(tmp13, []any{lang.NewChar(46)})
						tmp15 := lang.Apply(strings11.Index, []any{tmp12, tmp14})
						tmp16 := lang.Apply(tmp10, []any{tmp15})
						tmp9 = tmp16
					} else {
						tmp9 = v8
					}
					tmp7 = tmp9
				} // end let
				tmp8 := checkDerefVar(var_glojure_DOT_core_name)
				tmp9 := lang.Apply(tmp8, []any{v4})
				tmp10 := lang.Apply(tmp6, []any{tmp7, "Found lib name '%s' containing period with prefix '%s'.  lib names inside prefix lists must not contain periods", tmp9, v3})
				_ = tmp10
				var tmp11 any
				{ // let
					// let binding "lib"
					var tmp12 any
					if lang.IsTruthy(v3) {
						tmp13 := checkDerefVar(var_glojure_DOT_core_symbol)
						tmp14 := checkDerefVar(var_glojure_DOT_core_str)
						tmp15 := lang.Apply(tmp14, []any{v3, lang.NewChar(46), v4})
						tmp16 := lang.Apply(tmp13, []any{tmp15})
						tmp12 = tmp16
					} else {
						tmp12 = v4
					}
					var v17 any = tmp12
					_ = v17
					// let binding "opts"
					tmp18 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp19 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp20 := lang.Apply(tmp18, []any{tmp19, v5})
					var v21 any = tmp20
					_ = v21
					// let binding "map__110"
					var v22 any = v21
					_ = v22
					// let binding "map__110"
					var tmp23 any
					tmp24 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
					tmp25 := lang.Apply(tmp24, []any{v22})
					if lang.IsTruthy(tmp25) {
						var tmp26 any
						tmp27 := checkDerefVar(var_glojure_DOT_core_next)
						tmp28 := lang.Apply(tmp27, []any{v22})
						if lang.IsTruthy(tmp28) {
							tmp29 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
							tmp30 := lang.Apply(tmp29, []any{v22})
							tmp31 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp30})
							tmp26 = tmp31
						} else {
							var tmp32 any
							tmp33 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp34 := lang.Apply(tmp33, []any{v22})
							if lang.IsTruthy(tmp34) {
								tmp35 := checkDerefVar(var_glojure_DOT_core_first)
								tmp36 := lang.Apply(tmp35, []any{v22})
								tmp32 = tmp36
							} else {
							}
							tmp26 = tmp32
						}
						tmp23 = tmp26
					} else {
						tmp23 = v22
					}
					var v37 any = tmp23
					_ = v37
					// let binding "as"
					tmp38 := checkDerefVar(var_glojure_DOT_core_get)
					tmp39 := lang.Apply(tmp38, []any{v37, kw_as})
					var v40 any = tmp39
					_ = v40
					// let binding "reload"
					tmp41 := checkDerefVar(var_glojure_DOT_core_get)
					tmp42 := lang.Apply(tmp41, []any{v37, kw_reload})
					var v43 any = tmp42
					_ = v43
					// let binding "reload-all"
					tmp44 := checkDerefVar(var_glojure_DOT_core_get)
					tmp45 := lang.Apply(tmp44, []any{v37, kw_reload_DASH_all})
					var v46 any = tmp45
					_ = v46
					// let binding "require"
					tmp47 := checkDerefVar(var_glojure_DOT_core_get)
					tmp48 := lang.Apply(tmp47, []any{v37, kw_require})
					var v49 any = tmp48
					_ = v49
					// let binding "use"
					tmp50 := checkDerefVar(var_glojure_DOT_core_get)
					tmp51 := lang.Apply(tmp50, []any{v37, kw_use})
					var v52 any = tmp51
					_ = v52
					// let binding "verbose"
					tmp53 := checkDerefVar(var_glojure_DOT_core_get)
					tmp54 := lang.Apply(tmp53, []any{v37, kw_verbose})
					var v55 any = tmp54
					_ = v55
					// let binding "as-alias"
					tmp56 := checkDerefVar(var_glojure_DOT_core_get)
					tmp57 := lang.Apply(tmp56, []any{v37, kw_as_DASH_alias})
					var v58 any = tmp57
					_ = v58
					// let binding "loaded"
					tmp59 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
					tmp60 := checkDerefVar(var_glojure_DOT_core_deref)
					tmp61 := checkDerefVar(var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_)
					tmp62 := lang.Apply(tmp60, []any{tmp61})
					tmp63 := lang.Apply(tmp59, []any{tmp62, v17})
					var v64 any = tmp63
					_ = v64
					// let binding "need-ns"
					var tmp65 any
					{ // let
						// let binding "or__0__auto__"
						var v66 any = v40
						_ = v66
						var tmp67 any
						if lang.IsTruthy(v66) {
							tmp67 = v66
						} else {
							tmp67 = v52
						}
						tmp65 = tmp67
					} // end let
					var v66 any = tmp65
					_ = v66
					// let binding "load"
					var tmp67 any
					if lang.IsTruthy(v46) {
						tmp68 := checkDerefVar(var_glojure_DOT_core_load_DASH_all)
						tmp67 = tmp68
					} else {
						var tmp69 any
						if lang.IsTruthy(v43) {
							tmp70 := checkDerefVar(var_glojure_DOT_core_load_DASH_one)
							tmp69 = tmp70
						} else {
							var tmp71 any
							tmp72 := checkDerefVar(var_glojure_DOT_core_not)
							tmp73 := lang.Apply(tmp72, []any{v64})
							if lang.IsTruthy(tmp73) {
								var tmp74 any
								if lang.IsTruthy(v66) {
									tmp75 := checkDerefVar(var_glojure_DOT_core_load_DASH_one)
									tmp74 = tmp75
								} else {
									var tmp76 any
									if lang.IsTruthy(v58) {
										var tmp77 lang.FnFunc
										tmp77 = lang.NewFnFunc(func(args ...any) any {
											checkArity(args, 3)
											v78 := args[0]
											_ = v78
											v79 := args[1]
											_ = v79
											v80 := args[2]
											_ = v80
											tmp81 := checkDerefVar(var_glojure_DOT_core_create_DASH_ns)
											tmp82 := lang.Apply(tmp81, []any{v78})
											return tmp82
										})
										tmp78 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5918), kw_column, int(48), kw_end_DASH_line, int(5918), kw_end_DASH_column, int(88))
										tmp79, err := lang.WithMeta(tmp77, tmp78.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp76 = tmp79
									} else {
										var tmp80 any
										if lang.IsTruthy(kw_else) {
											tmp81 := checkDerefVar(var_glojure_DOT_core_load_DASH_one)
											tmp80 = tmp81
										} else {
										}
										tmp76 = tmp80
									}
									tmp74 = tmp76
								}
								tmp71 = tmp74
							} else {
							}
							tmp69 = tmp71
						}
						tmp67 = tmp69
					}
					var v82 any = tmp67
					_ = v82
					// let binding "filter-opts"
					tmp83 := checkDerefVar(var_glojure_DOT_core_select_DASH_keys)
					tmp84 := lang.Apply(tmp83, []any{v21, lang.NewList(kw_exclude, kw_only, kw_rename, kw_refer)})
					var v85 any = tmp84
					_ = v85
					// let binding "undefined-on-entry"
					tmp86 := checkDerefVar(var_glojure_DOT_core_not)
					tmp87 := checkDerefVar(var_glojure_DOT_core_find_DASH_ns)
					tmp88 := lang.Apply(tmp87, []any{v17})
					tmp89 := lang.Apply(tmp86, []any{tmp88})
					var v90 any = tmp89
					_ = v90
					var tmp91 any
					{ // let
						tmp92 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp93 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp94 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_loading_DASH_verbosely_STAR_)
						var tmp95 any
						{ // let
							// let binding "or__0__auto__"
							tmp96 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
							var v97 any = tmp96
							_ = v97
							var tmp98 any
							if lang.IsTruthy(v97) {
								tmp98 = v97
							} else {
								tmp98 = v55
							}
							tmp95 = tmp98
						} // end let
						tmp96 := lang.Apply(tmp93, []any{tmp94, tmp95})
						tmp97 := lang.Apply(tmp92, []any{tmp96})
						_ = tmp97
						var tmp98 any
						func() {
							defer func() {
								tmp99 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp100 := lang.Apply(tmp99, nil)
								_ = tmp100
							}()
							var tmp101 any
							if lang.IsTruthy(v82) {
								var tmp102 any
								func() {
									defer func() {
										if r := recover(); r != nil {
											if lang.CatchMatches(r, lang.Builtins["any"]) {
												v103 := r
												_ = v103
												var tmp104 any
												if lang.IsTruthy(v90) {
													tmp105 := checkDerefVar(var_glojure_DOT_core_remove_DASH_ns)
													tmp106 := lang.Apply(tmp105, []any{v17})
													tmp104 = tmp106
												} else {
												}
												_ = tmp104
												panic(v103)
											} else {
												panic(r)
											}
										}
									}()
									tmp103 := lang.Apply(v82, []any{v17, v66, v49})
									tmp102 = tmp103
								}()
								tmp101 = tmp102
							} else {
								tmp104 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
								var tmp105 any
								{ // let
									// let binding "and__0__auto__"
									var v106 any = v66
									_ = v106
									var tmp107 any
									if lang.IsTruthy(v106) {
										tmp108 := checkDerefVar(var_glojure_DOT_core_not)
										tmp109 := checkDerefVar(var_glojure_DOT_core_find_DASH_ns)
										tmp110 := lang.Apply(tmp109, []any{v17})
										tmp111 := lang.Apply(tmp108, []any{tmp110})
										tmp107 = tmp111
									} else {
										tmp107 = v106
									}
									tmp105 = tmp107
								} // end let
								tmp106 := lang.Apply(tmp104, []any{tmp105, "namespace '%s' not found", v17})
								tmp101 = tmp106
							}
							_ = tmp101
							var tmp107 any
							var tmp108 any
							{ // let
								// let binding "and__0__auto__"
								var v109 any = v66
								_ = v109
								var tmp110 any
								if lang.IsTruthy(v109) {
									tmp111 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
									tmp110 = tmp111
								} else {
									tmp110 = v109
								}
								tmp108 = tmp110
							} // end let
							if lang.IsTruthy(tmp108) {
								tmp109 := checkDerefVar(var_glojure_DOT_core_printf)
								tmp110 := checkDerefVar(var_glojure_DOT_core_ns_DASH_name)
								tmp111 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
								tmp112 := lang.Apply(tmp110, []any{tmp111})
								tmp113 := lang.Apply(tmp109, []any{"(glojure.core/in-ns '%s)\n", tmp112})
								tmp107 = tmp113
							} else {
							}
							_ = tmp107
							var tmp114 any
							if lang.IsTruthy(v40) {
								var tmp115 any
								tmp116 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
								if lang.IsTruthy(tmp116) {
									tmp117 := checkDerefVar(var_glojure_DOT_core_printf)
									tmp118 := lang.Apply(tmp117, []any{"(glojure.core/alias '%s '%s)\n", v40, v17})
									tmp115 = tmp118
								} else {
								}
								_ = tmp115
								tmp119 := checkDerefVar(var_glojure_DOT_core_alias)
								tmp120 := lang.Apply(tmp119, []any{v40, v17})
								tmp114 = tmp120
							} else {
							}
							_ = tmp114
							var tmp121 any
							if lang.IsTruthy(v58) {
								var tmp122 any
								tmp123 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
								if lang.IsTruthy(tmp123) {
									tmp124 := checkDerefVar(var_glojure_DOT_core_printf)
									tmp125 := lang.Apply(tmp124, []any{"(glojure.core/alias '%s '%s)\n", v58, v17})
									tmp122 = tmp125
								} else {
								}
								_ = tmp122
								tmp126 := checkDerefVar(var_glojure_DOT_core_alias)
								tmp127 := lang.Apply(tmp126, []any{v58, v17})
								tmp121 = tmp127
							} else {
							}
							_ = tmp121
							var tmp128 any
							var tmp129 any
							{ // let
								// let binding "or__0__auto__"
								var v130 any = v52
								_ = v130
								var tmp131 any
								if lang.IsTruthy(v130) {
									tmp131 = v130
								} else {
									tmp132 := lang.Apply(kw_refer, []any{v85})
									tmp131 = tmp132
								}
								tmp129 = tmp131
							} // end let
							if lang.IsTruthy(tmp129) {
								var tmp130 any
								tmp131 := checkDerefVar(var_glojure_DOT_core__STAR_loading_DASH_verbosely_STAR_)
								if lang.IsTruthy(tmp131) {
									tmp132 := checkDerefVar(var_glojure_DOT_core_printf)
									tmp133 := lang.Apply(tmp132, []any{"(glojure.core/refer '%s", v17})
									_ = tmp133
									var tmp134 any
									{ // let
										// let binding "seq_111"
										tmp135 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp136 := lang.Apply(tmp135, []any{v85})
										var v137 any = tmp136
										_ = v137
										// let binding "chunk_112"
										var v138 any = nil
										_ = v138
										// let binding "count_113"
										var v139 any = int64(0)
										_ = v139
										// let binding "i_114"
										var v140 any = int64(0)
										_ = v140
										for {
											var tmp141 any
											tmp142 := checkDerefVar(var_glojure_DOT_core__LT_)
											tmp143 := lang.Apply(tmp142, []any{v140, v139})
											if lang.IsTruthy(tmp143) {
												var tmp144 any
												{ // let
													// let binding "opt"
													tmp145, _ := lang.FieldOrMethod(v138, "nth")
													if reflect.TypeOf(tmp145).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
													}
													tmp146 := lang.Apply(tmp145, []any{v140})
													var v147 any = tmp146
													_ = v147
													tmp148 := checkDerefVar(var_glojure_DOT_core_printf)
													tmp149 := checkDerefVar(var_glojure_DOT_core_key)
													tmp150 := lang.Apply(tmp149, []any{v147})
													tmp151 := checkDerefVar(var_glojure_DOT_core_print_DASH_str)
													tmp152 := checkDerefVar(var_glojure_DOT_core_val)
													tmp153 := lang.Apply(tmp152, []any{v147})
													tmp154 := lang.Apply(tmp151, []any{tmp153})
													tmp155 := lang.Apply(tmp148, []any{" %s '%s", tmp150, tmp154})
													_ = tmp155
													var tmp156 any = v137
													var tmp157 any = v138
													var tmp158 any = v139
													tmp160 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
													tmp161 := lang.Apply(tmp160, []any{v140})
													var tmp159 any = tmp161
													v137 = tmp156
													v138 = tmp157
													v139 = tmp158
													v140 = tmp159
													continue
												} // end let
												tmp141 = tmp144
											} else {
												var tmp145 any
												{ // let
													// let binding "temp__0__auto__"
													tmp146 := checkDerefVar(var_glojure_DOT_core_seq)
													tmp147 := lang.Apply(tmp146, []any{v137})
													var v148 any = tmp147
													_ = v148
													var tmp149 any
													if lang.IsTruthy(v148) {
														var tmp150 any
														{ // let
															// let binding "seq_111"
															var v151 any = v148
															_ = v151
															var tmp152 any
															tmp153 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
															tmp154 := lang.Apply(tmp153, []any{v151})
															if lang.IsTruthy(tmp154) {
																var tmp155 any
																{ // let
																	// let binding "c__0__auto__"
																	tmp156 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																	tmp157 := lang.Apply(tmp156, []any{v151})
																	var v158 any = tmp157
																	_ = v158
																	tmp160 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																	tmp161 := lang.Apply(tmp160, []any{v151})
																	var tmp159 any = tmp161
																	var tmp162 any = v158
																	tmp164 := checkDerefVar(var_glojure_DOT_core_int)
																	tmp165 := checkDerefVar(var_glojure_DOT_core_count)
																	tmp166 := lang.Apply(tmp165, []any{v158})
																	tmp167 := lang.Apply(tmp164, []any{tmp166})
																	var tmp163 any = tmp167
																	tmp169 := checkDerefVar(var_glojure_DOT_core_int)
																	tmp170 := lang.Apply(tmp169, []any{int64(0)})
																	var tmp168 any = tmp170
																	v137 = tmp159
																	v138 = tmp162
																	v139 = tmp163
																	v140 = tmp168
																	continue
																} // end let
																tmp152 = tmp155
															} else {
																var tmp156 any
																{ // let
																	// let binding "opt"
																	tmp157 := checkDerefVar(var_glojure_DOT_core_first)
																	tmp158 := lang.Apply(tmp157, []any{v151})
																	var v159 any = tmp158
																	_ = v159
																	tmp160 := checkDerefVar(var_glojure_DOT_core_printf)
																	tmp161 := checkDerefVar(var_glojure_DOT_core_key)
																	tmp162 := lang.Apply(tmp161, []any{v159})
																	tmp163 := checkDerefVar(var_glojure_DOT_core_print_DASH_str)
																	tmp164 := checkDerefVar(var_glojure_DOT_core_val)
																	tmp165 := lang.Apply(tmp164, []any{v159})
																	tmp166 := lang.Apply(tmp163, []any{tmp165})
																	tmp167 := lang.Apply(tmp160, []any{" %s '%s", tmp162, tmp166})
																	_ = tmp167
																	tmp169 := checkDerefVar(var_glojure_DOT_core_next)
																	tmp170 := lang.Apply(tmp169, []any{v151})
																	var tmp168 any = tmp170
																	var tmp171 any = nil
																	var tmp172 any = int64(0)
																	var tmp173 any = int64(0)
																	v137 = tmp168
																	v138 = tmp171
																	v139 = tmp172
																	v140 = tmp173
																	continue
																} // end let
																tmp152 = tmp156
															}
															tmp150 = tmp152
														} // end let
														tmp149 = tmp150
													} else {
													}
													tmp145 = tmp149
												} // end let
												tmp141 = tmp145
											}
											tmp134 = tmp141
											break
										}
									} // end let
									_ = tmp134
									tmp135 := checkDerefVar(var_glojure_DOT_core_printf)
									tmp136 := lang.Apply(tmp135, []any{")\n"})
									tmp130 = tmp136
								} else {
								}
								_ = tmp130
								tmp137 := checkDerefVar(var_glojure_DOT_core_apply)
								tmp138 := checkDerefVar(var_glojure_DOT_core_refer)
								tmp139 := checkDerefVar(var_glojure_DOT_core_mapcat)
								tmp140 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp141 := lang.Apply(tmp139, []any{tmp140, v85})
								tmp142 := lang.Apply(tmp137, []any{tmp138, v17, tmp141})
								tmp128 = tmp142
							} else {
							}
							tmp98 = tmp128
						}()
						tmp91 = tmp98
					} // end let
					tmp11 = tmp91
				} // end let
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-libs
	{
		tmp0 := sym_load_DASH_libs.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_args)), kw_doc, "Loads libs, interpreting libspecs, prefix lists, and flags for\n  forwarding to load-lib", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(8), kw_line, int(5951), kw_end_DASH_line, int(5951), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "flags"
					tmp5 := checkDerefVar(var_glojure_DOT_core_filter)
					tmp6 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
					tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
					var v8 any = tmp7
					_ = v8
					// let binding "opts"
					tmp9 := checkDerefVar(var_glojure_DOT_core_interleave)
					tmp10 := checkDerefVar(var_glojure_DOT_core_repeat)
					tmp11 := lang.Apply(tmp10, []any{true})
					tmp12 := lang.Apply(tmp9, []any{v8, tmp11})
					var v13 any = tmp12
					_ = v13
					// let binding "args"
					tmp14 := checkDerefVar(var_glojure_DOT_core_filter)
					tmp15 := checkDerefVar(var_glojure_DOT_core_complement)
					tmp16 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
					tmp17 := lang.Apply(tmp15, []any{tmp16})
					tmp18 := lang.Apply(tmp14, []any{tmp17, v3})
					var v19 any = tmp18
					_ = v19
					var tmp20 any
					{ // let
						// let binding "supported"
						tmp21 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{kw_as, kw_reload, kw_reload_DASH_all, kw_require, kw_use, kw_verbose, kw_refer, kw_as_DASH_alias}))
						tmp22 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5959), kw_column, int(21), kw_end_DASH_line, int(5959), kw_end_DASH_column, int(86))
						tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v24 any = tmp23
						_ = v24
						// let binding "unsupported"
						tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp26 := checkDerefVar(var_glojure_DOT_core_remove)
						tmp27 := lang.Apply(tmp26, []any{v24, v8})
						tmp28 := lang.Apply(tmp25, []any{tmp27})
						var v29 any = tmp28
						_ = v29
						tmp30 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
						tmp31 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp32 := checkDerefVar(var_glojure_DOT_core_str)
						tmp33 := checkDerefVar(var_glojure_DOT_core_interpose)
						tmp34 := lang.Apply(tmp33, []any{lang.NewChar(44), v29})
						tmp35 := lang.Apply(tmp31, []any{tmp32, "Unsupported option(s) supplied: ", tmp34})
						tmp36 := lang.Apply(tmp30, []any{v29, tmp35})
						tmp20 = tmp36
					} // end let
					_ = tmp20
					tmp21 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
					tmp22 := checkDerefVar(var_glojure_DOT_core_not)
					tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp24 := lang.Apply(tmp23, []any{v19})
					tmp25 := lang.Apply(tmp22, []any{tmp24})
					tmp26 := lang.Apply(tmp21, []any{tmp25, "Nothing specified to load"})
					_ = tmp26
					var tmp27 any
					{ // let
						// let binding "seq_115"
						tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp29 := lang.Apply(tmp28, []any{v19})
						var v30 any = tmp29
						_ = v30
						// let binding "chunk_116"
						var v31 any = nil
						_ = v31
						// let binding "count_117"
						var v32 any = int64(0)
						_ = v32
						// let binding "i_118"
						var v33 any = int64(0)
						_ = v33
						for {
							var tmp34 any
							tmp35 := checkDerefVar(var_glojure_DOT_core__LT_)
							tmp36 := lang.Apply(tmp35, []any{v33, v32})
							if lang.IsTruthy(tmp36) {
								var tmp37 any
								{ // let
									// let binding "arg"
									tmp38, _ := lang.FieldOrMethod(v31, "nth")
									if reflect.TypeOf(tmp38).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp39 := lang.Apply(tmp38, []any{v33})
									var v40 any = tmp39
									_ = v40
									var tmp41 any
									tmp42 := checkDerefVar(var_glojure_DOT_core_libspec_QMARK_)
									tmp43 := lang.Apply(tmp42, []any{v40})
									if lang.IsTruthy(tmp43) {
										tmp44 := checkDerefVar(var_glojure_DOT_core_apply)
										tmp45 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
										tmp46 := checkDerefVar(var_glojure_DOT_core_prependss)
										tmp47 := lang.Apply(tmp46, []any{v40, v13})
										tmp48 := lang.Apply(tmp44, []any{tmp45, nil, tmp47})
										tmp41 = tmp48
									} else {
										var tmp49 any
										{ // let
											// let binding "vec__119"
											var v50 any = v40
											_ = v50
											// let binding "seq__120"
											tmp51 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp52 := lang.Apply(tmp51, []any{v50})
											var v53 any = tmp52
											_ = v53
											// let binding "first__121"
											tmp54 := checkDerefVar(var_glojure_DOT_core_first)
											tmp55 := lang.Apply(tmp54, []any{v53})
											var v56 any = tmp55
											_ = v56
											// let binding "seq__120"
											tmp57 := checkDerefVar(var_glojure_DOT_core_next)
											tmp58 := lang.Apply(tmp57, []any{v53})
											var v59 any = tmp58
											_ = v59
											// let binding "prefix"
											var v60 any = v56
											_ = v60
											// let binding "args"
											var v61 any = v59
											_ = v61
											tmp62 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
											tmp63 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
											tmp64 := lang.Apply(tmp63, []any{v60})
											tmp65 := lang.Apply(tmp62, []any{tmp64, "prefix cannot be nil"})
											_ = tmp65
											var tmp66 any
											{ // let
												// let binding "seq_122"
												tmp67 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp68 := lang.Apply(tmp67, []any{v61})
												var v69 any = tmp68
												_ = v69
												// let binding "chunk_123"
												var v70 any = nil
												_ = v70
												// let binding "count_124"
												var v71 any = int64(0)
												_ = v71
												// let binding "i_125"
												var v72 any = int64(0)
												_ = v72
												for {
													var tmp73 any
													tmp74 := checkDerefVar(var_glojure_DOT_core__LT_)
													tmp75 := lang.Apply(tmp74, []any{v72, v71})
													if lang.IsTruthy(tmp75) {
														var tmp76 any
														{ // let
															// let binding "arg"
															tmp77, _ := lang.FieldOrMethod(v70, "nth")
															if reflect.TypeOf(tmp77).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp78 := lang.Apply(tmp77, []any{v72})
															var v79 any = tmp78
															_ = v79
															tmp80 := checkDerefVar(var_glojure_DOT_core_apply)
															tmp81 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
															tmp82 := checkDerefVar(var_glojure_DOT_core_prependss)
															tmp83 := lang.Apply(tmp82, []any{v79, v13})
															tmp84 := lang.Apply(tmp80, []any{tmp81, v60, tmp83})
															_ = tmp84
															var tmp85 any = v69
															var tmp86 any = v70
															var tmp87 any = v71
															tmp89 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
															tmp90 := lang.Apply(tmp89, []any{v72})
															var tmp88 any = tmp90
															v69 = tmp85
															v70 = tmp86
															v71 = tmp87
															v72 = tmp88
															continue
														} // end let
														tmp73 = tmp76
													} else {
														var tmp77 any
														{ // let
															// let binding "temp__0__auto__"
															tmp78 := checkDerefVar(var_glojure_DOT_core_seq)
															tmp79 := lang.Apply(tmp78, []any{v69})
															var v80 any = tmp79
															_ = v80
															var tmp81 any
															if lang.IsTruthy(v80) {
																var tmp82 any
																{ // let
																	// let binding "seq_122"
																	var v83 any = v80
																	_ = v83
																	var tmp84 any
																	tmp85 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
																	tmp86 := lang.Apply(tmp85, []any{v83})
																	if lang.IsTruthy(tmp86) {
																		var tmp87 any
																		{ // let
																			// let binding "c__0__auto__"
																			tmp88 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																			tmp89 := lang.Apply(tmp88, []any{v83})
																			var v90 any = tmp89
																			_ = v90
																			tmp92 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																			tmp93 := lang.Apply(tmp92, []any{v83})
																			var tmp91 any = tmp93
																			var tmp94 any = v90
																			tmp96 := checkDerefVar(var_glojure_DOT_core_int)
																			tmp97 := checkDerefVar(var_glojure_DOT_core_count)
																			tmp98 := lang.Apply(tmp97, []any{v90})
																			tmp99 := lang.Apply(tmp96, []any{tmp98})
																			var tmp95 any = tmp99
																			tmp101 := checkDerefVar(var_glojure_DOT_core_int)
																			tmp102 := lang.Apply(tmp101, []any{int64(0)})
																			var tmp100 any = tmp102
																			v69 = tmp91
																			v70 = tmp94
																			v71 = tmp95
																			v72 = tmp100
																			continue
																		} // end let
																		tmp84 = tmp87
																	} else {
																		var tmp88 any
																		{ // let
																			// let binding "arg"
																			tmp89 := checkDerefVar(var_glojure_DOT_core_first)
																			tmp90 := lang.Apply(tmp89, []any{v83})
																			var v91 any = tmp90
																			_ = v91
																			tmp92 := checkDerefVar(var_glojure_DOT_core_apply)
																			tmp93 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
																			tmp94 := checkDerefVar(var_glojure_DOT_core_prependss)
																			tmp95 := lang.Apply(tmp94, []any{v91, v13})
																			tmp96 := lang.Apply(tmp92, []any{tmp93, v60, tmp95})
																			_ = tmp96
																			tmp98 := checkDerefVar(var_glojure_DOT_core_next)
																			tmp99 := lang.Apply(tmp98, []any{v83})
																			var tmp97 any = tmp99
																			var tmp100 any = nil
																			var tmp101 any = int64(0)
																			var tmp102 any = int64(0)
																			v69 = tmp97
																			v70 = tmp100
																			v71 = tmp101
																			v72 = tmp102
																			continue
																		} // end let
																		tmp84 = tmp88
																	}
																	tmp82 = tmp84
																} // end let
																tmp81 = tmp82
															} else {
															}
															tmp77 = tmp81
														} // end let
														tmp73 = tmp77
													}
													tmp66 = tmp73
													break
												}
											} // end let
											tmp49 = tmp66
										} // end let
										tmp41 = tmp49
									}
									_ = tmp41
									var tmp50 any = v30
									var tmp51 any = v31
									var tmp52 any = v32
									tmp54 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
									tmp55 := lang.Apply(tmp54, []any{v33})
									var tmp53 any = tmp55
									v30 = tmp50
									v31 = tmp51
									v32 = tmp52
									v33 = tmp53
									continue
								} // end let
								tmp34 = tmp37
							} else {
								var tmp38 any
								{ // let
									// let binding "temp__0__auto__"
									tmp39 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp40 := lang.Apply(tmp39, []any{v30})
									var v41 any = tmp40
									_ = v41
									var tmp42 any
									if lang.IsTruthy(v41) {
										var tmp43 any
										{ // let
											// let binding "seq_115"
											var v44 any = v41
											_ = v44
											var tmp45 any
											tmp46 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
											tmp47 := lang.Apply(tmp46, []any{v44})
											if lang.IsTruthy(tmp47) {
												var tmp48 any
												{ // let
													// let binding "c__0__auto__"
													tmp49 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
													tmp50 := lang.Apply(tmp49, []any{v44})
													var v51 any = tmp50
													_ = v51
													tmp53 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
													tmp54 := lang.Apply(tmp53, []any{v44})
													var tmp52 any = tmp54
													var tmp55 any = v51
													tmp57 := checkDerefVar(var_glojure_DOT_core_int)
													tmp58 := checkDerefVar(var_glojure_DOT_core_count)
													tmp59 := lang.Apply(tmp58, []any{v51})
													tmp60 := lang.Apply(tmp57, []any{tmp59})
													var tmp56 any = tmp60
													tmp62 := checkDerefVar(var_glojure_DOT_core_int)
													tmp63 := lang.Apply(tmp62, []any{int64(0)})
													var tmp61 any = tmp63
													v30 = tmp52
													v31 = tmp55
													v32 = tmp56
													v33 = tmp61
													continue
												} // end let
												tmp45 = tmp48
											} else {
												var tmp49 any
												{ // let
													// let binding "arg"
													tmp50 := checkDerefVar(var_glojure_DOT_core_first)
													tmp51 := lang.Apply(tmp50, []any{v44})
													var v52 any = tmp51
													_ = v52
													var tmp53 any
													tmp54 := checkDerefVar(var_glojure_DOT_core_libspec_QMARK_)
													tmp55 := lang.Apply(tmp54, []any{v52})
													if lang.IsTruthy(tmp55) {
														tmp56 := checkDerefVar(var_glojure_DOT_core_apply)
														tmp57 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
														tmp58 := checkDerefVar(var_glojure_DOT_core_prependss)
														tmp59 := lang.Apply(tmp58, []any{v52, v13})
														tmp60 := lang.Apply(tmp56, []any{tmp57, nil, tmp59})
														tmp53 = tmp60
													} else {
														var tmp61 any
														{ // let
															// let binding "vec__126"
															var v62 any = v52
															_ = v62
															// let binding "seq__127"
															tmp63 := checkDerefVar(var_glojure_DOT_core_seq)
															tmp64 := lang.Apply(tmp63, []any{v62})
															var v65 any = tmp64
															_ = v65
															// let binding "first__128"
															tmp66 := checkDerefVar(var_glojure_DOT_core_first)
															tmp67 := lang.Apply(tmp66, []any{v65})
															var v68 any = tmp67
															_ = v68
															// let binding "seq__127"
															tmp69 := checkDerefVar(var_glojure_DOT_core_next)
															tmp70 := lang.Apply(tmp69, []any{v65})
															var v71 any = tmp70
															_ = v71
															// let binding "prefix"
															var v72 any = v68
															_ = v72
															// let binding "args"
															var v73 any = v71
															_ = v73
															tmp74 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
															tmp75 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
															tmp76 := lang.Apply(tmp75, []any{v72})
															tmp77 := lang.Apply(tmp74, []any{tmp76, "prefix cannot be nil"})
															_ = tmp77
															var tmp78 any
															{ // let
																// let binding "seq_129"
																tmp79 := checkDerefVar(var_glojure_DOT_core_seq)
																tmp80 := lang.Apply(tmp79, []any{v73})
																var v81 any = tmp80
																_ = v81
																// let binding "chunk_130"
																var v82 any = nil
																_ = v82
																// let binding "count_131"
																var v83 any = int64(0)
																_ = v83
																// let binding "i_132"
																var v84 any = int64(0)
																_ = v84
																for {
																	var tmp85 any
																	tmp86 := checkDerefVar(var_glojure_DOT_core__LT_)
																	tmp87 := lang.Apply(tmp86, []any{v84, v83})
																	if lang.IsTruthy(tmp87) {
																		var tmp88 any
																		{ // let
																			// let binding "arg"
																			tmp89, _ := lang.FieldOrMethod(v82, "nth")
																			if reflect.TypeOf(tmp89).Kind() != reflect.Func {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
																			}
																			tmp90 := lang.Apply(tmp89, []any{v84})
																			var v91 any = tmp90
																			_ = v91
																			tmp92 := checkDerefVar(var_glojure_DOT_core_apply)
																			tmp93 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
																			tmp94 := checkDerefVar(var_glojure_DOT_core_prependss)
																			tmp95 := lang.Apply(tmp94, []any{v91, v13})
																			tmp96 := lang.Apply(tmp92, []any{tmp93, v72, tmp95})
																			_ = tmp96
																			var tmp97 any = v81
																			var tmp98 any = v82
																			var tmp99 any = v83
																			tmp101 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
																			tmp102 := lang.Apply(tmp101, []any{v84})
																			var tmp100 any = tmp102
																			v81 = tmp97
																			v82 = tmp98
																			v83 = tmp99
																			v84 = tmp100
																			continue
																		} // end let
																		tmp85 = tmp88
																	} else {
																		var tmp89 any
																		{ // let
																			// let binding "temp__0__auto__"
																			tmp90 := checkDerefVar(var_glojure_DOT_core_seq)
																			tmp91 := lang.Apply(tmp90, []any{v81})
																			var v92 any = tmp91
																			_ = v92
																			var tmp93 any
																			if lang.IsTruthy(v92) {
																				var tmp94 any
																				{ // let
																					// let binding "seq_129"
																					var v95 any = v92
																					_ = v95
																					var tmp96 any
																					tmp97 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
																					tmp98 := lang.Apply(tmp97, []any{v95})
																					if lang.IsTruthy(tmp98) {
																						var tmp99 any
																						{ // let
																							// let binding "c__0__auto__"
																							tmp100 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																							tmp101 := lang.Apply(tmp100, []any{v95})
																							var v102 any = tmp101
																							_ = v102
																							tmp104 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																							tmp105 := lang.Apply(tmp104, []any{v95})
																							var tmp103 any = tmp105
																							var tmp106 any = v102
																							tmp108 := checkDerefVar(var_glojure_DOT_core_int)
																							tmp109 := checkDerefVar(var_glojure_DOT_core_count)
																							tmp110 := lang.Apply(tmp109, []any{v102})
																							tmp111 := lang.Apply(tmp108, []any{tmp110})
																							var tmp107 any = tmp111
																							tmp113 := checkDerefVar(var_glojure_DOT_core_int)
																							tmp114 := lang.Apply(tmp113, []any{int64(0)})
																							var tmp112 any = tmp114
																							v81 = tmp103
																							v82 = tmp106
																							v83 = tmp107
																							v84 = tmp112
																							continue
																						} // end let
																						tmp96 = tmp99
																					} else {
																						var tmp100 any
																						{ // let
																							// let binding "arg"
																							tmp101 := checkDerefVar(var_glojure_DOT_core_first)
																							tmp102 := lang.Apply(tmp101, []any{v95})
																							var v103 any = tmp102
																							_ = v103
																							tmp104 := checkDerefVar(var_glojure_DOT_core_apply)
																							tmp105 := checkDerefVar(var_glojure_DOT_core_load_DASH_lib)
																							tmp106 := checkDerefVar(var_glojure_DOT_core_prependss)
																							tmp107 := lang.Apply(tmp106, []any{v103, v13})
																							tmp108 := lang.Apply(tmp104, []any{tmp105, v72, tmp107})
																							_ = tmp108
																							tmp110 := checkDerefVar(var_glojure_DOT_core_next)
																							tmp111 := lang.Apply(tmp110, []any{v95})
																							var tmp109 any = tmp111
																							var tmp112 any = nil
																							var tmp113 any = int64(0)
																							var tmp114 any = int64(0)
																							v81 = tmp109
																							v82 = tmp112
																							v83 = tmp113
																							v84 = tmp114
																							continue
																						} // end let
																						tmp96 = tmp100
																					}
																					tmp94 = tmp96
																				} // end let
																				tmp93 = tmp94
																			} else {
																			}
																			tmp89 = tmp93
																		} // end let
																		tmp85 = tmp89
																	}
																	tmp78 = tmp85
																	break
																}
															} // end let
															tmp61 = tmp78
														} // end let
														tmp53 = tmp61
													}
													_ = tmp53
													tmp63 := checkDerefVar(var_glojure_DOT_core_next)
													tmp64 := lang.Apply(tmp63, []any{v44})
													var tmp62 any = tmp64
													var tmp65 any = nil
													var tmp66 any = int64(0)
													var tmp67 any = int64(0)
													v30 = tmp62
													v31 = tmp65
													v32 = tmp66
													v33 = tmp67
													continue
												} // end let
												tmp45 = tmp49
											}
											tmp43 = tmp45
										} // end let
										tmp42 = tmp43
									} else {
									}
									tmp38 = tmp42
								} // end let
								tmp34 = tmp38
							}
							tmp27 = tmp34
							break
						}
					} // end let
					tmp4 = tmp27
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-one
	{
		tmp0 := sym_load_DASH_one.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_lib, sym_need_DASH_ns, sym_require)), kw_doc, "Loads a lib given its name. If need-ns, ensures that the associated\n  namespace exists after loading. If require, records the load so any\n  duplicate loads can be skipped.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(5879), kw_end_DASH_line, int(5879), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := checkDerefVar(var_glojure_DOT_core_load)
			tmp7 := checkDerefVar(var_glojure_DOT_core_root_DASH_resource)
			tmp8 := lang.Apply(tmp7, []any{v3})
			tmp9 := lang.Apply(tmp6, []any{tmp8})
			_ = tmp9
			tmp10 := checkDerefVar(var_glojure_DOT_core_throw_DASH_if)
			var tmp11 any
			{ // let
				// let binding "and__0__auto__"
				var v12 any = v4
				_ = v12
				var tmp13 any
				if lang.IsTruthy(v12) {
					tmp14 := checkDerefVar(var_glojure_DOT_core_not)
					tmp15 := checkDerefVar(var_glojure_DOT_core_find_DASH_ns)
					tmp16 := lang.Apply(tmp15, []any{v3})
					tmp17 := lang.Apply(tmp14, []any{tmp16})
					tmp13 = tmp17
				} else {
					tmp13 = v12
				}
				tmp11 = tmp13
			} // end let
			tmp12 := checkDerefVar(var_glojure_DOT_core_root_DASH_resource)
			tmp13 := lang.Apply(tmp12, []any{v3})
			tmp14 := lang.Apply(tmp10, []any{tmp11, "namespace '%s' not found after loading '%s'", v3, tmp13})
			_ = tmp14
			var tmp15 any
			if lang.IsTruthy(v5) {
				var tmp16 lang.FnFunc
				tmp16 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					tmp17 := checkDerefVar(var_glojure_DOT_core_commute)
					tmp18 := checkDerefVar(var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_)
					tmp19 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp20 := lang.Apply(tmp17, []any{tmp18, tmp19, v3})
					return tmp20
				})
				tmp17, _ := lang.FieldOrMethod(lang.LockingTransaction, "RunInTransaction")
				if reflect.TypeOf(tmp17).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("RunInTransaction is not a function")))
				}
				tmp18 := lang.Apply(tmp17, []any{tmp16})
				tmp15 = tmp18
			} else {
			}
			return tmp15
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-reader
	{
		tmp0 := sym_load_DASH_reader.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_rdr)), kw_doc, "Sequentially read and evaluate the set of forms contained in the\n  stream/file", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(4081), kw_end_DASH_line, int(4081))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.Compiler, "load")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("load is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-string
	{
		tmp0 := sym_load_DASH_string.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Sequentially read and evaluate the set of forms contained in the\n  string", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(4088), kw_end_DASH_line, int(4088))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "rdr"
				tmp5 := lang.Apply(nil, []any{v3})
				tmp6 := lang.Apply(nil, []any{tmp5})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_load_DASH_reader)
				tmp9 := lang.Apply(tmp8, []any{v7})
				tmp4 = tmp9
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// loaded-libs
	{
		tmp0 := sym_loaded_DASH_libs.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a sorted set of symbols naming the currently loaded libs", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(6090), kw_end_DASH_line, int(6090))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := checkDerefVar(var_glojure_DOT_core_deref)
			tmp4 := checkDerefVar(var_glojure_DOT_core__STAR_loaded_DASH_libs_STAR_)
			tmp5 := lang.Apply(tmp3, []any{tmp4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// locking
	{
		tmp0 := sym_locking.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_x, sym__AMP_, sym_body)), kw_doc, "Executes exprs in an implicit do, while holding the monitor of x.\n  Will release the monitor of x in all circumstances.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(1643), kw_end_DASH_line, int(1643))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_let})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp13 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{sym_lockee__0__auto__})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v5})
				tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
				tmp21 := lang.Apply(tmp14, []any{tmp20})
				tmp22 := lang.Apply(tmp12, []any{tmp13, tmp21})
				tmp23 := lang.Apply(tmp11, []any{tmp22})
				tmp24 := checkDerefVar(var_glojure_DOT_core_list)
				tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp27 := checkDerefVar(var_glojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{sym_try})
				tmp29 := checkDerefVar(var_glojure_DOT_core_list)
				tmp30 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp31 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp32 := checkDerefVar(var_glojure_DOT_core_list)
				tmp33 := lang.Apply(tmp32, []any{sym_glojure_DOT_core_SLASH_let})
				tmp34 := checkDerefVar(var_glojure_DOT_core_list)
				tmp35 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp36 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp37 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp38 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp39 := checkDerefVar(var_glojure_DOT_core_list)
				tmp40 := lang.Apply(tmp39, []any{sym_locklocal__1__auto__})
				tmp41 := checkDerefVar(var_glojure_DOT_core_list)
				tmp42 := lang.Apply(tmp41, []any{sym_lockee__0__auto__})
				tmp43 := lang.Apply(tmp38, []any{tmp40, tmp42})
				tmp44 := lang.Apply(tmp37, []any{tmp43})
				tmp45 := lang.Apply(tmp35, []any{tmp36, tmp44})
				tmp46 := lang.Apply(tmp34, []any{tmp45})
				tmp47 := checkDerefVar(var_glojure_DOT_core_list)
				tmp48 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp49 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp50 := checkDerefVar(var_glojure_DOT_core_list)
				tmp51 := lang.Apply(tmp50, []any{sym_monitor_DASH_enter})
				tmp52 := checkDerefVar(var_glojure_DOT_core_list)
				tmp53 := lang.Apply(tmp52, []any{sym_locklocal__1__auto__})
				tmp54 := lang.Apply(tmp49, []any{tmp51, tmp53})
				tmp55 := lang.Apply(tmp48, []any{tmp54})
				tmp56 := lang.Apply(tmp47, []any{tmp55})
				tmp57 := checkDerefVar(var_glojure_DOT_core_list)
				tmp58 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp59 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp60 := checkDerefVar(var_glojure_DOT_core_list)
				tmp61 := lang.Apply(tmp60, []any{sym_try})
				tmp62 := checkDerefVar(var_glojure_DOT_core_list)
				tmp63 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp64 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp65 := checkDerefVar(var_glojure_DOT_core_list)
				tmp66 := lang.Apply(tmp65, []any{sym_finally})
				tmp67 := checkDerefVar(var_glojure_DOT_core_list)
				tmp68 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp69 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp70 := checkDerefVar(var_glojure_DOT_core_list)
				tmp71 := lang.Apply(tmp70, []any{sym_monitor_DASH_exit})
				tmp72 := checkDerefVar(var_glojure_DOT_core_list)
				tmp73 := lang.Apply(tmp72, []any{sym_locklocal__1__auto__})
				tmp74 := lang.Apply(tmp69, []any{tmp71, tmp73})
				tmp75 := lang.Apply(tmp68, []any{tmp74})
				tmp76 := lang.Apply(tmp67, []any{tmp75})
				tmp77 := lang.Apply(tmp64, []any{tmp66, tmp76})
				tmp78 := lang.Apply(tmp63, []any{tmp77})
				tmp79 := lang.Apply(tmp62, []any{tmp78})
				tmp80 := lang.Apply(tmp59, []any{tmp61, v6, tmp79})
				tmp81 := lang.Apply(tmp58, []any{tmp80})
				tmp82 := lang.Apply(tmp57, []any{tmp81})
				tmp83 := lang.Apply(tmp31, []any{tmp33, tmp46, tmp56, tmp82})
				tmp84 := lang.Apply(tmp30, []any{tmp83})
				tmp85 := lang.Apply(tmp29, []any{tmp84})
				tmp86 := lang.Apply(tmp26, []any{tmp28, tmp85})
				tmp87 := lang.Apply(tmp25, []any{tmp86})
				tmp88 := lang.Apply(tmp24, []any{tmp87})
				tmp89 := lang.Apply(tmp8, []any{tmp10, tmp23, tmp88})
				tmp90 := lang.Apply(tmp7, []any{tmp89})
				return tmp90
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// long
	{
		var tmp1 lang.FnFunc
		{ // function long__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_LongCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_long.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to long", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3481), kw_end_DASH_line, int(3481))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.LongCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// long-array
	{
		var tmp1 lang.FnFunc
		{ // function long-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_LongArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_long_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of longs", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(5364), kw_end_DASH_line, int(5364))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "LongArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("LongArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "LongArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("LongArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// longs
	{
		var tmp1 lang.FnFunc
		{ // function longs
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_Longs})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_longs.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to long[]", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(12), kw_line, int(5407), kw_end_DASH_line, int(5407))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Longs")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Longs is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// loop
	{
		tmp0 := sym_loop.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", kw_forms, lang.NewVector(lang.NewList(sym_loop, lang.NewVector(sym_bindings_STAR_), sym_exprs_STAR_)), kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(4597), kw_end_DASH_line, int(4597), kw_special_DASH_form, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_str)
					tmp11 := checkDerefVar(var_glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(kw_line, []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(var_glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "db"
					tmp34 := checkDerefVar(var_glojure_DOT_core_destructure)
					tmp35 := lang.Apply(tmp34, []any{v5})
					var v36 any = tmp35
					_ = v36
					var tmp37 any
					tmp38 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp39 := lang.Apply(tmp38, []any{v36, v5})
					if lang.IsTruthy(tmp39) {
						tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp41 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp42 := checkDerefVar(var_glojure_DOT_core_list)
						tmp43 := lang.Apply(tmp42, []any{sym_loop_STAR_})
						tmp44 := checkDerefVar(var_glojure_DOT_core_list)
						tmp45 := lang.Apply(tmp44, []any{v5})
						tmp46 := lang.Apply(tmp41, []any{tmp43, tmp45, v6})
						tmp47 := lang.Apply(tmp40, []any{tmp46})
						tmp37 = tmp47
					} else {
						var tmp48 any
						{ // let
							// let binding "vs"
							tmp49 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
							tmp50 := checkDerefVar(var_glojure_DOT_core_drop)
							tmp51 := lang.Apply(tmp50, []any{int64(1), v5})
							tmp52 := lang.Apply(tmp49, []any{int64(2), tmp51})
							var v53 any = tmp52
							_ = v53
							// let binding "bs"
							tmp54 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
							tmp55 := lang.Apply(tmp54, []any{int64(2), v5})
							var v56 any = tmp55
							_ = v56
							// let binding "gs"
							tmp57 := checkDerefVar(var_glojure_DOT_core_map)
							var tmp58 lang.FnFunc
							tmp58 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v59 := args[0]
								_ = v59
								var tmp60 any
								tmp61 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
								tmp62 := lang.Apply(tmp61, []any{v59})
								if lang.IsTruthy(tmp62) {
									tmp60 = v59
								} else {
									tmp63 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp64 := lang.Apply(tmp63, nil)
									tmp60 = tmp64
								}
								return tmp60
							})
							tmp59 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4611), kw_column, int(23), kw_end_DASH_line, int(4611), kw_end_DASH_column, int(58))
							tmp60, err := lang.WithMeta(tmp58, tmp59.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp61 := lang.Apply(tmp57, []any{tmp60, v56})
							var v62 any = tmp61
							_ = v62
							// let binding "bfs"
							tmp63 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp64 lang.FnFunc
							tmp64 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v65 := args[0]
								_ = v65
								v66 := args[1]
								_ = v66
								var tmp67 any
								{ // let
									// let binding "vec__17"
									var v68 any = v66
									_ = v68
									// let binding "b"
									tmp69 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp70 := lang.Apply(tmp69, []any{v68, int64(0), nil})
									var v71 any = tmp70
									_ = v71
									// let binding "v"
									tmp72 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp73 := lang.Apply(tmp72, []any{v68, int64(1), nil})
									var v74 any = tmp73
									_ = v74
									// let binding "g"
									tmp75 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp76 := lang.Apply(tmp75, []any{v68, int64(2), nil})
									var v77 any = tmp76
									_ = v77
									var tmp78 any
									tmp79 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
									tmp80 := lang.Apply(tmp79, []any{v71})
									if lang.IsTruthy(tmp80) {
										tmp81 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp82 := lang.Apply(tmp81, []any{v65, v77, v74})
										tmp78 = tmp82
									} else {
										tmp83 := checkDerefVar(var_glojure_DOT_core_conj)
										tmp84 := lang.Apply(tmp83, []any{v65, v77, v74, v71, v77})
										tmp78 = tmp84
									}
									tmp67 = tmp78
								} // end let
								return tmp67
							})
							tmp65 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4612), kw_column, int(28), kw_end_DASH_line, int(4615), kw_end_DASH_column, int(50))
							tmp66, err := lang.WithMeta(tmp64, tmp65.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp67 := lang.NewVector()
							tmp68 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4616), kw_column, int(27), kw_end_DASH_line, int(4616), kw_end_DASH_column, int(28))
							tmp69, err := lang.WithMeta(tmp67, tmp68.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp70 := checkDerefVar(var_glojure_DOT_core_map)
							tmp71 := checkDerefVar(var_glojure_DOT_core_vector)
							tmp72 := lang.Apply(tmp70, []any{tmp71, v56, v53, v62})
							tmp73 := lang.Apply(tmp63, []any{tmp66, tmp69, tmp72})
							var v74 any = tmp73
							_ = v74
							tmp75 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp76 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp77 := checkDerefVar(var_glojure_DOT_core_list)
							tmp78 := lang.Apply(tmp77, []any{sym_glojure_DOT_core_SLASH_let})
							tmp79 := checkDerefVar(var_glojure_DOT_core_list)
							tmp80 := lang.Apply(tmp79, []any{v74})
							tmp81 := checkDerefVar(var_glojure_DOT_core_list)
							tmp82 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp83 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp84 := checkDerefVar(var_glojure_DOT_core_list)
							tmp85 := lang.Apply(tmp84, []any{sym_loop_STAR_})
							tmp86 := checkDerefVar(var_glojure_DOT_core_list)
							tmp87 := checkDerefVar(var_glojure_DOT_core_vec)
							tmp88 := checkDerefVar(var_glojure_DOT_core_interleave)
							tmp89 := lang.Apply(tmp88, []any{v62, v62})
							tmp90 := lang.Apply(tmp87, []any{tmp89})
							tmp91 := lang.Apply(tmp86, []any{tmp90})
							tmp92 := checkDerefVar(var_glojure_DOT_core_list)
							tmp93 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp94 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp95 := checkDerefVar(var_glojure_DOT_core_list)
							tmp96 := lang.Apply(tmp95, []any{sym_glojure_DOT_core_SLASH_let})
							tmp97 := checkDerefVar(var_glojure_DOT_core_list)
							tmp98 := checkDerefVar(var_glojure_DOT_core_vec)
							tmp99 := checkDerefVar(var_glojure_DOT_core_interleave)
							tmp100 := lang.Apply(tmp99, []any{v56, v62})
							tmp101 := lang.Apply(tmp98, []any{tmp100})
							tmp102 := lang.Apply(tmp97, []any{tmp101})
							tmp103 := lang.Apply(tmp94, []any{tmp96, tmp102, v6})
							tmp104 := lang.Apply(tmp93, []any{tmp103})
							tmp105 := lang.Apply(tmp92, []any{tmp104})
							tmp106 := lang.Apply(tmp83, []any{tmp85, tmp91, tmp105})
							tmp107 := lang.Apply(tmp82, []any{tmp106})
							tmp108 := lang.Apply(tmp81, []any{tmp107})
							tmp109 := lang.Apply(tmp76, []any{tmp78, tmp80, tmp108})
							tmp110 := lang.Apply(tmp75, []any{tmp109})
							tmp48 = tmp110
						} // end let
						tmp37 = tmp48
					}
					tmp33 = tmp37
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// macroexpand
	{
		tmp0 := sym_macroexpand.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_form)), kw_doc, "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(4025), kw_end_DASH_line, int(4025))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ex"
				tmp5 := checkDerefVar(var_glojure_DOT_core_macroexpand_DASH_1)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v7, v3})
				if lang.IsTruthy(tmp10) {
					tmp8 = v3
				} else {
					tmp11 := checkDerefVar(var_glojure_DOT_core_macroexpand)
					tmp12 := lang.Apply(tmp11, []any{v7})
					tmp8 = tmp12
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// macroexpand-1
	{
		tmp0 := sym_macroexpand_DASH_1.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_form)), kw_doc, "If form represents a macro form, returns its expansion,\n  else returns form.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(4017), kw_end_DASH_line, int(4017))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.Compiler, "macroexpand1")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("macroexpand1 is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-array
	{
		tmp0 := sym_make_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_type, sym_len), lang.NewVector(sym_type, sym_dim, sym__AMP_, sym_more_DASH_dims)), kw_doc, "Creates and returns an array of instances of the specified class of\n  the specified dimension(s).  Note that a class object is required.\n  Class objects can be obtained by using their imported or\n  fully-qualified name.  Class objects for the primitive types can be\n  obtained using, e.g., Integer/TYPE.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(3985), kw_end_DASH_line, int(3985))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_int)
				tmp6 := lang.Apply(tmp5, []any{v4})
				tmp7, _ := lang.FieldOrMethod(nil, "newInstance")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("newInstance is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v3, tmp6})
				return tmp8
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "dims"
					tmp7 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp8 := lang.Apply(tmp7, []any{v4, v5})
					var v9 any = tmp8
					_ = v9
					// let binding "dimarray"
					tmp10 := checkDerefVar(var_glojure_DOT_core_make_DASH_array)
					tmp11, ok := lang.FieldOrMethod(nil, "TYPE")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "TYPE")))
					}
					var tmp12 any
					switch reflect.TypeOf(tmp11).Kind() {
					case reflect.Func:
						tmp12 = lang.Apply(tmp11, nil)
					default:
						tmp12 = tmp11
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_count)
					tmp14 := lang.Apply(tmp13, []any{v9})
					tmp15 := lang.Apply(tmp10, []any{tmp12, tmp14})
					var v16 any = tmp15
					_ = v16
					var tmp17 any
					{ // let
						// let binding "n__0__auto__"
						tmp18 := checkDerefVar(var_glojure_DOT_core_long)
						tmp19 := checkDerefVar(var_glojure_DOT_core_alength)
						tmp20 := lang.Apply(tmp19, []any{v16})
						tmp21 := lang.Apply(tmp18, []any{tmp20})
						var v22 any = tmp21
						_ = v22
						var tmp23 any
						{ // let
							// let binding "i"
							var v24 any = int64(0)
							_ = v24
							for {
								var tmp25 any
								tmp26 := checkDerefVar(var_glojure_DOT_core__LT_)
								tmp27 := lang.Apply(tmp26, []any{v24, v22})
								if lang.IsTruthy(tmp27) {
									tmp28 := checkDerefVar(var_glojure_DOT_core_aset_DASH_int)
									tmp29 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp30 := lang.Apply(tmp29, []any{v9, v24})
									tmp31 := lang.Apply(tmp28, []any{v16, v24, tmp30})
									_ = tmp31
									tmp33 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
									tmp34 := lang.Apply(tmp33, []any{v24})
									var tmp32 any = tmp34
									v24 = tmp32
									continue
								} else {
								}
								tmp23 = tmp25
								break
							}
						} // end let
						tmp17 = tmp23
					} // end let
					_ = tmp17
					tmp18, _ := lang.FieldOrMethod(nil, "newInstance")
					if reflect.TypeOf(tmp18).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("newInstance is not a function")))
					}
					tmp19 := lang.Apply(tmp18, []any{v3, v16})
					tmp6 = tmp19
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-hierarchy
	{
		tmp0 := sym_make_DASH_hierarchy.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Creates a hierarchy object for use with derive, isa? etc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(5507), kw_end_DASH_line, int(5507))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := lang.NewMap()
			tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5511), kw_column, int(16), kw_end_DASH_line, int(5511), kw_end_DASH_column, int(17))
			tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp6 := lang.NewMap()
			tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5511), kw_column, int(32), kw_end_DASH_line, int(5511), kw_end_DASH_column, int(33))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := lang.NewMap()
			tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5511), kw_column, int(46), kw_end_DASH_line, int(5511), kw_end_DASH_column, int(47))
			tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp12 := lang.NewMap(kw_parents, tmp5, kw_descendants, tmp8, kw_ancestors, tmp11)
			tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5511), kw_column, int(6), kw_end_DASH_line, int(5511), kw_end_DASH_column, int(48))
			tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp14
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map
	{
		tmp0 := sym_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_c1, sym_c2), lang.NewVector(sym_f, sym_c1, sym_c2, sym_c3), lang.NewVector(sym_f, sym_c1, sym_c2, sym_c3, sym__AMP_, sym_colls)), kw_doc, "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(2719), kw_end_DASH_line, int(2719))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							tmp9 := lang.Apply(v3, []any{v8})
							tmp10 := lang.Apply(v5, []any{v7, tmp9})
							return tmp10
						default:
							checkArity(args, 2)
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var v9 any = lang.NewList(args[2:]...)
							_ = v9
							tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp11 := lang.Apply(tmp10, []any{v3, v8, v9})
							tmp12 := lang.Apply(v5, []any{v7, tmp11})
							return tmp12
						}
					})
					tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2730), kw_column, int(7), kw_end_DASH_line, int(2736), kw_end_DASH_column, int(47))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2729), kw_column, int(5), kw_end_DASH_line, int(2736), kw_end_DASH_column, int(48))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								tmp14 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
								tmp15 := lang.Apply(tmp14, []any{v12})
								if lang.IsTruthy(tmp15) {
									var tmp16 any
									{ // let
										// let binding "c"
										tmp17 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
										tmp18 := lang.Apply(tmp17, []any{v12})
										var v19 any = tmp18
										_ = v19
										// let binding "size"
										tmp20 := checkDerefVar(var_glojure_DOT_core_int)
										tmp21 := checkDerefVar(var_glojure_DOT_core_count)
										tmp22 := lang.Apply(tmp21, []any{v19})
										tmp23 := lang.Apply(tmp20, []any{tmp22})
										var v24 any = tmp23
										_ = v24
										// let binding "b"
										tmp25 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_buffer)
										tmp26 := lang.Apply(tmp25, []any{v24})
										var v27 any = tmp26
										_ = v27
										var tmp28 any
										{ // let
											// let binding "n__0__auto__"
											tmp29 := lang.Apply(lang.LongCast, []any{v24})
											var v30 any = tmp29
											_ = v30
											var tmp31 any
											{ // let
												// let binding "i"
												var v32 any = int64(0)
												_ = v32
												for {
													var tmp33 any
													tmp34 := checkDerefVar(var_glojure_DOT_core__LT_)
													tmp35 := lang.Apply(tmp34, []any{v32, v30})
													if lang.IsTruthy(tmp35) {
														tmp36 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_append)
														tmp37, _ := lang.FieldOrMethod(v19, "nth")
														if reflect.TypeOf(tmp37).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
														}
														tmp38 := lang.Apply(tmp37, []any{v32})
														tmp39 := lang.Apply(v3, []any{tmp38})
														tmp40 := lang.Apply(tmp36, []any{v27, tmp39})
														_ = tmp40
														tmp42 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
														tmp43 := lang.Apply(tmp42, []any{v32})
														var tmp41 any = tmp43
														v32 = tmp41
														continue
													} else {
													}
													tmp31 = tmp33
													break
												}
											} // end let
											tmp28 = tmp31
										} // end let
										_ = tmp28
										tmp29 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
										tmp30 := checkDerefVar(var_glojure_DOT_core_chunk)
										tmp31 := lang.Apply(tmp30, []any{v27})
										tmp32 := checkDerefVar(var_glojure_DOT_core_map)
										tmp33 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
										tmp34 := lang.Apply(tmp33, []any{v12})
										tmp35 := lang.Apply(tmp32, []any{v3, tmp34})
										tmp36 := lang.Apply(tmp29, []any{tmp31, tmp35})
										tmp16 = tmp36
									} // end let
									tmp13 = tmp16
								} else {
									tmp17 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp18 := checkDerefVar(var_glojure_DOT_core_first)
									tmp19 := lang.Apply(tmp18, []any{v12})
									tmp20 := lang.Apply(v3, []any{tmp19})
									tmp21 := checkDerefVar(var_glojure_DOT_core_map)
									tmp22 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp23 := lang.Apply(tmp22, []any{v12})
									tmp24 := lang.Apply(tmp21, []any{v3, tmp23})
									tmp25 := lang.Apply(tmp17, []any{tmp20, tmp24})
									tmp13 = tmp25
								}
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp7 any
					{ // let
						// let binding "s1"
						tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v4})
						var v10 any = tmp9
						_ = v10
						// let binding "s2"
						tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp12 := lang.Apply(tmp11, []any{v5})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						var tmp15 any
						{ // let
							// let binding "and__0__auto__"
							var v16 any = v10
							_ = v16
							var tmp17 any
							if lang.IsTruthy(v16) {
								tmp17 = v13
							} else {
								tmp17 = v16
							}
							tmp15 = tmp17
						} // end let
						if lang.IsTruthy(tmp15) {
							tmp16 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp17 := checkDerefVar(var_glojure_DOT_core_first)
							tmp18 := lang.Apply(tmp17, []any{v10})
							tmp19 := checkDerefVar(var_glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v13})
							tmp21 := lang.Apply(v3, []any{tmp18, tmp20})
							tmp22 := checkDerefVar(var_glojure_DOT_core_map)
							tmp23 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp24 := lang.Apply(tmp23, []any{v10})
							tmp25 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp26 := lang.Apply(tmp25, []any{v13})
							tmp27 := lang.Apply(tmp22, []any{v3, tmp24, tmp26})
							tmp28 := lang.Apply(tmp16, []any{tmp21, tmp27})
							tmp14 = tmp28
						} else {
						}
						tmp7 = tmp14
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp8 any
					{ // let
						// let binding "s1"
						tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp10 := lang.Apply(tmp9, []any{v4})
						var v11 any = tmp10
						_ = v11
						// let binding "s2"
						tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp13 := lang.Apply(tmp12, []any{v5})
						var v14 any = tmp13
						_ = v14
						// let binding "s3"
						tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp16 := lang.Apply(tmp15, []any{v6})
						var v17 any = tmp16
						_ = v17
						var tmp18 any
						var tmp19 any
						{ // let
							// let binding "and__0__auto__"
							var v20 any = v11
							_ = v20
							var tmp21 any
							if lang.IsTruthy(v20) {
								var tmp22 any
								{ // let
									// let binding "and__0__auto__"
									var v23 any = v14
									_ = v23
									var tmp24 any
									if lang.IsTruthy(v23) {
										tmp24 = v17
									} else {
										tmp24 = v23
									}
									tmp22 = tmp24
								} // end let
								tmp21 = tmp22
							} else {
								tmp21 = v20
							}
							tmp19 = tmp21
						} // end let
						if lang.IsTruthy(tmp19) {
							tmp20 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp21 := checkDerefVar(var_glojure_DOT_core_first)
							tmp22 := lang.Apply(tmp21, []any{v11})
							tmp23 := checkDerefVar(var_glojure_DOT_core_first)
							tmp24 := lang.Apply(tmp23, []any{v14})
							tmp25 := checkDerefVar(var_glojure_DOT_core_first)
							tmp26 := lang.Apply(tmp25, []any{v17})
							tmp27 := lang.Apply(v3, []any{tmp22, tmp24, tmp26})
							tmp28 := checkDerefVar(var_glojure_DOT_core_map)
							tmp29 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp30 := lang.Apply(tmp29, []any{v11})
							tmp31 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp32 := lang.Apply(tmp31, []any{v14})
							tmp33 := checkDerefVar(var_glojure_DOT_core_rest)
							tmp34 := lang.Apply(tmp33, []any{v17})
							tmp35 := lang.Apply(tmp28, []any{v3, tmp30, tmp32, tmp34})
							tmp36 := lang.Apply(tmp20, []any{tmp27, tmp35})
							tmp18 = tmp36
						} else {
						}
						tmp8 = tmp18
					} // end let
					return tmp8
				})
				tmp8 := lang.Apply(lang.NewLazySeq, []any{tmp7})
				return tmp8
			default:
				checkArity(args, 4)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 any
				{ // let
					// let binding "step"
					var tmp9 lang.FnFunc
					{ // function step
						var v10 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v11 := args[0]
							_ = v11
							var tmp12 lang.FnFunc
							tmp12 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								var tmp13 any
								{ // let
									// let binding "ss"
									tmp14 := checkDerefVar(var_glojure_DOT_core_map)
									tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp16 := lang.Apply(tmp14, []any{tmp15, v11})
									var v17 any = tmp16
									_ = v17
									var tmp18 any
									tmp19 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
									tmp20 := checkDerefVar(var_glojure_DOT_core_identity)
									tmp21 := lang.Apply(tmp19, []any{tmp20, v17})
									if lang.IsTruthy(tmp21) {
										tmp22 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp23 := checkDerefVar(var_glojure_DOT_core_map)
										tmp24 := checkDerefVar(var_glojure_DOT_core_first)
										tmp25 := lang.Apply(tmp23, []any{tmp24, v17})
										tmp26 := checkDerefVar(var_glojure_DOT_core_map)
										tmp27 := checkDerefVar(var_glojure_DOT_core_rest)
										tmp28 := lang.Apply(tmp26, []any{tmp27, v17})
										tmp29 := lang.Apply(v10, []any{tmp28})
										tmp30 := lang.Apply(tmp22, []any{tmp25, tmp29})
										tmp18 = tmp30
									} else {
									}
									tmp13 = tmp18
								} // end let
								return tmp13
							})
							tmp13 := lang.Apply(lang.NewLazySeq, []any{tmp12})
							return tmp13
						})
						v10 = tmp9
						_ = v10
					}
					tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2761), kw_column, int(15), kw_end_DASH_line, int(2765), kw_end_DASH_column, int(68))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v12 any = tmp11
					_ = v12
					tmp13 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v15 := args[0]
						_ = v15
						tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp17 := lang.Apply(tmp16, []any{v3, v15})
						return tmp17
					})
					tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2766), kw_column, int(11), kw_end_DASH_line, int(2766), kw_end_DASH_column, int(22))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp18 := lang.Apply(tmp17, []any{v7, v6, v5, v4})
					tmp19 := lang.Apply(v12, []any{tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp16, tmp19})
					tmp8 = tmp20
				} // end let
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map-entry?
	{
		tmp0 := sym_map_DASH_entry_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a map entry", kw_file, "glojure/core.glj", kw_added, "1.8", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(1473), kw_end_DASH_line, int(1473))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.MapEntry)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map-indexed
	{
		tmp0 := sym_map_DASH_indexed.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_coll)), kw_doc, "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(7309), kw_end_DASH_line, int(7309))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "i"
						tmp7 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{int64(-1)})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								tmp13 := checkDerefVar(var_glojure_DOT_core_inc)
								tmp14, ok := lang.FieldOrMethod(v9, "Deref")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Deref")))
								}
								var tmp15 any
								switch reflect.TypeOf(tmp14).Kind() {
								case reflect.Func:
									tmp15 = lang.Apply(tmp14, nil)
								default:
									tmp15 = tmp14
								}
								tmp16 := lang.Apply(tmp13, []any{tmp15})
								tmp17, _ := lang.FieldOrMethod(v9, "reset")
								if reflect.TypeOf(tmp17).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
								}
								tmp18 := lang.Apply(tmp17, []any{tmp16})
								tmp19 := lang.Apply(v3, []any{tmp18, v12})
								tmp20 := lang.Apply(v5, []any{v11, tmp19})
								return tmp20
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7320), kw_column, int(8), kw_end_DASH_line, int(7324), kw_end_DASH_column, int(48))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7318), kw_column, int(4), kw_end_DASH_line, int(7324), kw_end_DASH_column, int(50))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return nil
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map?
	{
		tmp0 := sym_map_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x implements IPersistentMap", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(167), kw_end_DASH_line, int(171))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function map?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v4})
				return tmp7
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(171), kw_column, int(7), kw_end_DASH_line, int(171), kw_end_DASH_column, int(97))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mapcat
	{
		tmp0 := sym_mapcat.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym__AMP_, sym_colls)), kw_doc, "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2775), kw_end_DASH_line, int(2775))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_comp)
				tmp5 := checkDerefVar(var_glojure_DOT_core_map)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := checkDerefVar(var_glojure_DOT_core_cat)
				tmp8 := lang.Apply(tmp4, []any{tmp6, tmp7})
				return tmp8
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_map)
				tmp9 := lang.Apply(tmp7, []any{tmp8, v3, v4})
				tmp10 := lang.Apply(tmp5, []any{tmp6, tmp9})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mapv
	{
		tmp0 := sym_mapv.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_c1, sym_c2), lang.NewVector(sym_f, sym_c1, sym_c2, sym_c3), lang.NewVector(sym_f, sym_c1, sym_c2, sym_c3, sym__AMP_, sym_colls)), kw_doc, "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6943), kw_end_DASH_line, int(6943))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
				tmp6 := checkDerefVar(var_glojure_DOT_core_reduce)
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v8 := args[0]
					_ = v8
					v9 := args[1]
					_ = v9
					tmp10 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp11 := lang.Apply(v3, []any{v9})
					tmp12 := lang.Apply(tmp10, []any{v8, tmp11})
					return tmp12
				})
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6952), kw_column, int(18), kw_end_DASH_line, int(6952), kw_end_DASH_column, int(43))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp11 := lang.NewVector()
				tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6952), kw_column, int(56), kw_end_DASH_line, int(6952), kw_end_DASH_column, int(57))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.Apply(tmp10, []any{tmp13})
				tmp15 := lang.Apply(tmp6, []any{tmp9, tmp14, v4})
				tmp16 := lang.Apply(tmp5, []any{tmp15})
				return tmp16
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_into)
				tmp7 := lang.NewVector()
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6955), kw_column, int(12), kw_end_DASH_line, int(6955), kw_end_DASH_column, int(13))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := checkDerefVar(var_glojure_DOT_core_map)
				tmp11 := lang.Apply(tmp10, []any{v3, v4, v5})
				tmp12 := lang.Apply(tmp6, []any{tmp9, tmp11})
				return tmp12
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_into)
				tmp8 := lang.NewVector()
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6957), kw_column, int(12), kw_end_DASH_line, int(6957), kw_end_DASH_column, int(13))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := checkDerefVar(var_glojure_DOT_core_map)
				tmp12 := lang.Apply(tmp11, []any{v3, v4, v5, v6})
				tmp13 := lang.Apply(tmp7, []any{tmp10, tmp12})
				return tmp13
			default:
				checkArity(args, 4)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_into)
				tmp9 := lang.NewVector()
				tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6959), kw_column, int(12), kw_end_DASH_line, int(6959), kw_end_DASH_column, int(13))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp13 := checkDerefVar(var_glojure_DOT_core_map)
				tmp14 := lang.Apply(tmp12, []any{tmp13, v3, v4, v5, v6, v7})
				tmp15 := lang.Apply(tmp8, []any{tmp11, tmp14})
				return tmp15
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed33
					} else {
						tmp4 = closed33
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed33
					} else {
						tmp5 = closed33
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed33
					} else {
						tmp6 = closed33
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_max.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the greatest of the nums.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1108), kw_end_DASH_line, int(1108))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				return v5
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Max")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Max is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core_max)
				tmp10 := checkDerefVar(var_glojure_DOT_core_max)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-key
	{
		tmp0 := sym_max_DASH_key.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_k, sym_x), lang.NewVector(sym_k, sym_x, sym_y), lang.NewVector(sym_k, sym_x, sym_y, sym__AMP_, sym_more)), kw_doc, "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5013), kw_end_DASH_line, int(5013))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return v4
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core__GT_)
				tmp8 := lang.Apply(v3, []any{v4})
				tmp9 := lang.Apply(v3, []any{v5})
				tmp10 := lang.Apply(tmp7, []any{tmp8, tmp9})
				if lang.IsTruthy(tmp10) {
					tmp6 = v4
				} else {
					tmp6 = v5
				}
				return tmp6
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "kx"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ky"
					tmp10 := lang.Apply(v3, []any{v5})
					var v11 any = tmp10
					_ = v11
					// let binding "vec__55"
					var tmp12 any
					tmp13 := checkDerefVar(var_glojure_DOT_core__GT_)
					tmp14 := lang.Apply(tmp13, []any{v9, v11})
					if lang.IsTruthy(tmp14) {
						tmp15 := lang.NewVector(v4, v9)
						tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5023), kw_column, int(31), kw_end_DASH_line, int(5023), kw_end_DASH_column, int(36))
						tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp17
					} else {
						tmp18 := lang.NewVector(v5, v11)
						tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5023), kw_column, int(38), kw_end_DASH_line, int(5023), kw_end_DASH_column, int(43))
						tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp20
					}
					var v21 any = tmp12
					_ = v21
					// let binding "v"
					tmp22 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp23 := lang.Apply(tmp22, []any{v21, int64(0), nil})
					var v24 any = tmp23
					_ = v24
					// let binding "kv"
					tmp25 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp26 := lang.Apply(tmp25, []any{v21, int64(1), nil})
					var v27 any = tmp26
					_ = v27
					var tmp28 any
					{ // let
						// let binding "v"
						var v29 any = v24
						_ = v29
						// let binding "kv"
						var v30 any = v27
						_ = v30
						// let binding "more"
						var v31 any = v6
						_ = v31
						for {
							var tmp32 any
							if lang.IsTruthy(v31) {
								var tmp33 any
								{ // let
									// let binding "w"
									tmp34 := checkDerefVar(var_glojure_DOT_core_first)
									tmp35 := lang.Apply(tmp34, []any{v31})
									var v36 any = tmp35
									_ = v36
									// let binding "kw"
									tmp37 := lang.Apply(v3, []any{v36})
									var v38 any = tmp37
									_ = v38
									var tmp39 any
									tmp40 := checkDerefVar(var_glojure_DOT_core__GT__EQ_)
									tmp41 := lang.Apply(tmp40, []any{v38, v30})
									if lang.IsTruthy(tmp41) {
										var tmp42 any = v36
										var tmp43 any = v38
										tmp45 := checkDerefVar(var_glojure_DOT_core_next)
										tmp46 := lang.Apply(tmp45, []any{v31})
										var tmp44 any = tmp46
										v29 = tmp42
										v30 = tmp43
										v31 = tmp44
										continue
									} else {
										var tmp47 any = v29
										var tmp48 any = v30
										tmp50 := checkDerefVar(var_glojure_DOT_core_next)
										tmp51 := lang.Apply(tmp50, []any{v31})
										var tmp49 any = tmp51
										v29 = tmp47
										v30 = tmp48
										v31 = tmp49
										continue
									}
									tmp33 = tmp39
								} // end let
								tmp32 = tmp33
							} else {
								tmp32 = v29
							}
							tmp28 = tmp32
							break
						}
					} // end let
					tmp7 = tmp28
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-mask-bits
	{
		tmp0 := sym_max_DASH_mask_DASH_bits.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(6601), kw_column, int(6), kw_end_DASH_line, int(6601), kw_end_DASH_column, int(28), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, int64(13), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-switch-table-size
	{
		tmp0 := sym_max_DASH_switch_DASH_table_DASH_size.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(6602), kw_column, int(6), kw_end_DASH_line, int(6602), kw_end_DASH_column, int(36), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, int64(8192), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// maybe-destructured
	{
		tmp0 := sym_maybe_DASH_destructured.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(4514), kw_column, int(7), kw_end_DASH_line, int(4515), kw_end_DASH_column, int(20), kw_arglists, lang.NewList(lang.NewVector(sym_params, sym_body)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
			tmp7 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			if lang.IsTruthy(tmp8) {
				tmp9 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp5 = tmp10
			} else {
				var tmp11 any
				{ // let
					// let binding "params"
					var v12 any = v3
					_ = v12
					// let binding "new-params"
					tmp13 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp14 := lang.NewVector()
					tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4520), kw_column, int(34), kw_end_DASH_line, int(4520), kw_end_DASH_column, int(35))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp18 := lang.Apply(tmp17, []any{v12})
					tmp19 := lang.Apply(tmp13, []any{tmp16, tmp18})
					var v20 any = tmp19
					_ = v20
					// let binding "lets"
					tmp21 := lang.NewVector()
					tmp22 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4521), kw_column, int(17), kw_end_DASH_line, int(4521), kw_end_DASH_column, int(18))
					tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v24 any = tmp23
					_ = v24
					for {
						var tmp25 any
						if lang.IsTruthy(v12) {
							var tmp26 any
							tmp27 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
							tmp28 := checkDerefVar(var_glojure_DOT_core_first)
							tmp29 := lang.Apply(tmp28, []any{v12})
							tmp30 := lang.Apply(tmp27, []any{tmp29})
							if lang.IsTruthy(tmp30) {
								tmp32 := checkDerefVar(var_glojure_DOT_core_next)
								tmp33 := lang.Apply(tmp32, []any{v12})
								var tmp31 any = tmp33
								tmp35 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp36 := checkDerefVar(var_glojure_DOT_core_first)
								tmp37 := lang.Apply(tmp36, []any{v12})
								tmp38 := lang.Apply(tmp35, []any{v20, tmp37})
								var tmp34 any = tmp38
								var tmp39 any = v24
								v12 = tmp31
								v20 = tmp34
								v24 = tmp39
								continue
							} else {
								var tmp40 any
								{ // let
									// let binding "gparam"
									tmp41 := checkDerefVar(var_glojure_DOT_core_gensym)
									tmp42 := lang.Apply(tmp41, []any{"p__"})
									var v43 any = tmp42
									_ = v43
									tmp45 := checkDerefVar(var_glojure_DOT_core_next)
									tmp46 := lang.Apply(tmp45, []any{v12})
									var tmp44 any = tmp46
									tmp48 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp49 := lang.Apply(tmp48, []any{v20, v43})
									var tmp47 any = tmp49
									tmp51 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp52 := checkDerefVar(var_glojure_DOT_core_conj)
									tmp53 := checkDerefVar(var_glojure_DOT_core_first)
									tmp54 := lang.Apply(tmp53, []any{v12})
									tmp55 := lang.Apply(tmp52, []any{v24, tmp54})
									tmp56 := lang.Apply(tmp51, []any{tmp55, v43})
									var tmp50 any = tmp56
									v12 = tmp44
									v20 = tmp47
									v24 = tmp50
									continue
								} // end let
								tmp26 = tmp40
							}
							tmp25 = tmp26
						} else {
							tmp41 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp42 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp43 := checkDerefVar(var_glojure_DOT_core_list)
							tmp44 := lang.Apply(tmp43, []any{v20})
							tmp45 := checkDerefVar(var_glojure_DOT_core_list)
							tmp46 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp47 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp48 := checkDerefVar(var_glojure_DOT_core_list)
							tmp49 := lang.Apply(tmp48, []any{sym_glojure_DOT_core_SLASH_let})
							tmp50 := checkDerefVar(var_glojure_DOT_core_list)
							tmp51 := lang.Apply(tmp50, []any{v24})
							tmp52 := lang.Apply(tmp47, []any{tmp49, tmp51, v4})
							tmp53 := lang.Apply(tmp46, []any{tmp52})
							tmp54 := lang.Apply(tmp45, []any{tmp53})
							tmp55 := lang.Apply(tmp42, []any{tmp44, tmp54})
							tmp56 := lang.Apply(tmp41, []any{tmp55})
							tmp25 = tmp56
						}
						tmp11 = tmp25
						break
					}
				} // end let
				tmp5 = tmp11
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// maybe-min-hash
	{
		tmp0 := sym_maybe_DASH_min_DASH_hash.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_hashes)), kw_doc, "takes a collection of hashes and returns [shift mask] or nil if none found", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(8), kw_line, int(6604), kw_end_DASH_line, int(6604), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_first)
			tmp5 := checkDerefVar(var_glojure_DOT_core_filter)
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v7 := args[0]
				_ = v7
				var tmp8 any
				{ // let
					// let binding "vec__151"
					var v9 any = v7
					_ = v9
					// let binding "s"
					tmp10 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp11 := lang.Apply(tmp10, []any{v9, int64(0), nil})
					var v12 any = tmp11
					_ = v12
					// let binding "m"
					tmp13 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp14 := lang.Apply(tmp13, []any{v9, int64(1), nil})
					var v15 any = tmp14
					_ = v15
					tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp17 := checkDerefVar(var_glojure_DOT_core_distinct_QMARK_)
					tmp18 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp19 lang.FnFunc
					tmp19 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v20 := args[0]
						_ = v20
						tmp21 := checkDerefVar(var_glojure_DOT_core_shift_DASH_mask)
						tmp22 := lang.Apply(tmp21, []any{v12, v15, v20})
						return tmp22
					})
					tmp20 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6609), kw_column, int(37), kw_end_DASH_line, int(6609), kw_end_DASH_column, int(55))
					tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp22 := lang.Apply(tmp18, []any{tmp21, v3})
					tmp23 := lang.Apply(tmp16, []any{tmp17, tmp22})
					tmp8 = tmp23
				} // end let
				return tmp8
			})
			tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6608), kw_column, int(13), kw_end_DASH_line, int(6609), kw_end_DASH_column, int(65))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp9 any
			{ // let
				// let binding "iter__0__auto__"
				var tmp10 lang.FnFunc
				{ // function iter__154
					var v11 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v12 := args[0]
						_ = v12
						var tmp13 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							var tmp14 any
							{ // let
								// let binding "s__155"
								var v15 any = v12
								_ = v15
								for {
									var tmp16 any
									{ // let
										// let binding "temp__0__auto__"
										tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp18 := lang.Apply(tmp17, []any{v15})
										var v19 any = tmp18
										_ = v19
										var tmp20 any
										if lang.IsTruthy(v19) {
											var tmp21 any
											{ // let
												// let binding "xs__0__auto__"
												var v22 any = v19
												_ = v22
												var tmp23 any
												{ // let
													// let binding "mask"
													tmp24 := checkDerefVar(var_glojure_DOT_core_first)
													tmp25 := lang.Apply(tmp24, []any{v22})
													var v26 any = tmp25
													_ = v26
													var tmp27 any
													{ // let
														// let binding "iterys__0__auto__"
														var tmp28 lang.FnFunc
														{ // function iter__156
															var v29 lang.FnFunc
															tmp28 = lang.NewFnFunc(func(args ...any) any {
																checkArity(args, 1)
																v30 := args[0]
																_ = v30
																var tmp31 lang.FnFunc
																tmp31 = lang.NewFnFunc(func(args ...any) any {
																	checkArity(args, 0)
																	var tmp32 any
																	{ // let
																		// let binding "s__157"
																		var v33 any = v30
																		_ = v33
																		for {
																			var tmp34 any
																			{ // let
																				// let binding "temp__0__auto__"
																				tmp35 := checkDerefVar(var_glojure_DOT_core_seq)
																				tmp36 := lang.Apply(tmp35, []any{v33})
																				var v37 any = tmp36
																				_ = v37
																				var tmp38 any
																				if lang.IsTruthy(v37) {
																					var tmp39 any
																					{ // let
																						// let binding "s__157"
																						var v40 any = v37
																						_ = v40
																						var tmp41 any
																						tmp42 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
																						tmp43 := lang.Apply(tmp42, []any{v40})
																						if lang.IsTruthy(tmp43) {
																							var tmp44 any
																							{ // let
																								// let binding "c__0__auto__"
																								tmp45 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																								tmp46 := lang.Apply(tmp45, []any{v40})
																								var v47 any = tmp46
																								_ = v47
																								// let binding "size__1__auto__"
																								tmp48 := checkDerefVar(var_glojure_DOT_core_int)
																								tmp49 := checkDerefVar(var_glojure_DOT_core_count)
																								tmp50 := lang.Apply(tmp49, []any{v47})
																								tmp51 := lang.Apply(tmp48, []any{tmp50})
																								var v52 any = tmp51
																								_ = v52
																								// let binding "b__159"
																								tmp53 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_buffer)
																								tmp54 := lang.Apply(tmp53, []any{v52})
																								var v55 any = tmp54
																								_ = v55
																								var tmp56 any
																								var tmp57 any
																								{ // let
																									// let binding "i__158"
																									tmp58 := checkDerefVar(var_glojure_DOT_core_int)
																									tmp59 := lang.Apply(tmp58, []any{int64(0)})
																									var v60 any = tmp59
																									_ = v60
																									for {
																										var tmp61 any
																										tmp62 := checkDerefVar(var_glojure_DOT_core__LT_)
																										tmp63 := lang.Apply(tmp62, []any{v60, v52})
																										if lang.IsTruthy(tmp63) {
																											var tmp64 any
																											{ // let
																												// let binding "shift"
																												tmp65, _ := lang.FieldOrMethod(v47, "nth")
																												if reflect.TypeOf(tmp65).Kind() != reflect.Func {
																													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
																												}
																												tmp66 := lang.Apply(tmp65, []any{v60})
																												var v67 any = tmp66
																												_ = v67
																												tmp68 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_append)
																												tmp69 := lang.NewVector(v67, v26)
																												tmp70 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6612), kw_column, int(15), kw_end_DASH_line, int(6612), kw_end_DASH_column, int(26))
																												tmp71, err := lang.WithMeta(tmp69, tmp70.(lang.IPersistentMap))
																												if err != nil {
																													panic(err)
																												}
																												tmp72 := lang.Apply(tmp68, []any{v55, tmp71})
																												_ = tmp72
																												tmp74 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
																												tmp75 := lang.Apply(tmp74, []any{v60})
																												var tmp73 any = tmp75
																												v60 = tmp73
																												continue
																											} // end let
																											tmp61 = tmp64
																										} else {
																											tmp61 = true
																										}
																										tmp57 = tmp61
																										break
																									}
																								} // end let
																								if lang.IsTruthy(tmp57) {
																									tmp58 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
																									tmp59 := checkDerefVar(var_glojure_DOT_core_chunk)
																									tmp60 := lang.Apply(tmp59, []any{v55})
																									tmp61 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																									tmp62 := lang.Apply(tmp61, []any{v40})
																									tmp63 := lang.Apply(v29, []any{tmp62})
																									tmp64 := lang.Apply(tmp58, []any{tmp60, tmp63})
																									tmp56 = tmp64
																								} else {
																									tmp65 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_cons)
																									tmp66 := checkDerefVar(var_glojure_DOT_core_chunk)
																									tmp67 := lang.Apply(tmp66, []any{v55})
																									tmp68 := lang.Apply(tmp65, []any{tmp67, nil})
																									tmp56 = tmp68
																								}
																								tmp44 = tmp56
																							} // end let
																							tmp41 = tmp44
																						} else {
																							var tmp45 any
																							{ // let
																								// let binding "shift"
																								tmp46 := checkDerefVar(var_glojure_DOT_core_first)
																								tmp47 := lang.Apply(tmp46, []any{v40})
																								var v48 any = tmp47
																								_ = v48
																								tmp49 := checkDerefVar(var_glojure_DOT_core_cons)
																								tmp50 := lang.NewVector(v48, v26)
																								tmp51 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6612), kw_column, int(15), kw_end_DASH_line, int(6612), kw_end_DASH_column, int(26))
																								tmp52, err := lang.WithMeta(tmp50, tmp51.(lang.IPersistentMap))
																								if err != nil {
																									panic(err)
																								}
																								tmp53 := checkDerefVar(var_glojure_DOT_core_rest)
																								tmp54 := lang.Apply(tmp53, []any{v40})
																								tmp55 := lang.Apply(v29, []any{tmp54})
																								tmp56 := lang.Apply(tmp49, []any{tmp52, tmp55})
																								tmp45 = tmp56
																							} // end let
																							tmp41 = tmp45
																						}
																						tmp39 = tmp41
																					} // end let
																					tmp38 = tmp39
																				} else {
																				}
																				tmp34 = tmp38
																			} // end let
																			tmp32 = tmp34
																			break
																		}
																	} // end let
																	return tmp32
																})
																tmp32 := lang.Apply(lang.NewLazySeq, []any{tmp31})
																return tmp32
															})
															v29 = tmp28
															_ = v29
														}
														var v29 any = tmp28
														_ = v29
														// let binding "fs__1__auto__"
														tmp30 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp31 := checkDerefVar(var_glojure_DOT_core_range)
														tmp32 := lang.Apply(tmp31, []any{int64(0), int64(31)})
														tmp33 := lang.Apply(v29, []any{tmp32})
														tmp34 := lang.Apply(tmp30, []any{tmp33})
														var v35 any = tmp34
														_ = v35
														var tmp36 any
														if lang.IsTruthy(v35) {
															tmp37 := checkDerefVar(var_glojure_DOT_core_concat)
															tmp38 := checkDerefVar(var_glojure_DOT_core_rest)
															tmp39 := lang.Apply(tmp38, []any{v15})
															tmp40 := lang.Apply(v11, []any{tmp39})
															tmp41 := lang.Apply(tmp37, []any{v35, tmp40})
															tmp36 = tmp41
														} else {
															tmp43 := checkDerefVar(var_glojure_DOT_core_rest)
															tmp44 := lang.Apply(tmp43, []any{v15})
															var tmp42 any = tmp44
															v15 = tmp42
															continue
														}
														tmp27 = tmp36
													} // end let
													tmp23 = tmp27
												} // end let
												tmp21 = tmp23
											} // end let
											tmp20 = tmp21
										} else {
										}
										tmp16 = tmp20
									} // end let
									tmp14 = tmp16
									break
								}
							} // end let
							return tmp14
						})
						tmp14 := lang.Apply(lang.NewLazySeq, []any{tmp13})
						return tmp14
					})
					v11 = tmp10
					_ = v11
				}
				var v11 any = tmp10
				_ = v11
				tmp12 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp13 lang.FnFunc
				tmp13 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v14 := args[0]
					_ = v14
					tmp15 := checkDerefVar(var_glojure_DOT_core_dec)
					tmp16 := checkDerefVar(var_glojure_DOT_core_bit_DASH_shift_DASH_left)
					tmp17 := lang.Apply(tmp16, []any{int64(1), v14})
					tmp18 := lang.Apply(tmp15, []any{tmp17})
					return tmp18
				})
				tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6610), kw_column, int(29), kw_end_DASH_line, int(6610), kw_end_DASH_column, int(55))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp16 := checkDerefVar(var_glojure_DOT_core_range)
				tmp17 := checkDerefVar(var_glojure_DOT_core_inc)
				tmp18 := checkDerefVar(var_glojure_DOT_core_max_DASH_mask_DASH_bits)
				tmp19 := lang.Apply(tmp17, []any{tmp18})
				tmp20 := lang.Apply(tmp16, []any{int64(1), tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp15, tmp20})
				tmp22 := lang.Apply(v11, []any{tmp21})
				tmp9 = tmp22
			} // end let
			tmp10 := lang.Apply(tmp5, []any{tmp8, tmp9})
			tmp11 := lang.Apply(tmp4, []any{tmp10})
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// memfn
	{
		tmp0 := sym_memfn.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym__AMP_, sym_args)), kw_doc, "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(3872), kw_end_DASH_line, int(3872))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "t"
					tmp8 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp9 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp10 := lang.Apply(tmp9, []any{"target"})
					tmp11 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp12 := lang.Apply(tmp11, []any{v5})
					tmp13 := lang.Apply(tmp8, []any{tmp10, tmp12})
					var v14 any = tmp13
					_ = v14
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_fn})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp21 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp22 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp23 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v14})
					tmp26 := lang.Apply(tmp23, []any{tmp25, v6})
					tmp27 := lang.Apply(tmp22, []any{tmp26})
					tmp28 := lang.Apply(tmp20, []any{tmp21, tmp27})
					tmp29 := lang.Apply(tmp19, []any{tmp28})
					tmp30 := checkDerefVar(var_glojure_DOT_core_list)
					tmp31 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp32 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp33 := checkDerefVar(var_glojure_DOT_core_list)
					tmp34 := lang.Apply(tmp33, []any{sym__DOT_})
					tmp35 := checkDerefVar(var_glojure_DOT_core_list)
					tmp36 := lang.Apply(tmp35, []any{v14})
					tmp37 := checkDerefVar(var_glojure_DOT_core_list)
					tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp39 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{v5})
					tmp42 := lang.Apply(tmp39, []any{tmp41, v6})
					tmp43 := lang.Apply(tmp38, []any{tmp42})
					tmp44 := lang.Apply(tmp37, []any{tmp43})
					tmp45 := lang.Apply(tmp32, []any{tmp34, tmp36, tmp44})
					tmp46 := lang.Apply(tmp31, []any{tmp45})
					tmp47 := lang.Apply(tmp30, []any{tmp46})
					tmp48 := lang.Apply(tmp16, []any{tmp18, tmp29, tmp47})
					tmp49 := lang.Apply(tmp15, []any{tmp48})
					tmp7 = tmp49
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// memoize
	{
		tmp0 := sym_memoize.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6337), kw_end_DASH_line, int(6337))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "mem"
				tmp5 := checkDerefVar(var_glojure_DOT_core_atom)
				tmp6 := lang.NewMap()
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6345), kw_column, int(19), kw_end_DASH_line, int(6345), kw_end_DASH_column, int(20))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				var v10 any = tmp9
				_ = v10
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						checkArity(args, 0)
						var v12 any = lang.NewList(args[0:]...)
						_ = v12
						var tmp13 any
						{ // let
							// let binding "temp__0__auto__"
							tmp14 := checkDerefVar(var_glojure_DOT_core_find)
							tmp15 := checkDerefVar(var_glojure_DOT_core_deref)
							tmp16 := lang.Apply(tmp15, []any{v10})
							tmp17 := lang.Apply(tmp14, []any{tmp16, v12})
							var v18 any = tmp17
							_ = v18
							var tmp19 any
							if lang.IsTruthy(v18) {
								var tmp20 any
								{ // let
									// let binding "e"
									var v21 any = v18
									_ = v21
									tmp22 := checkDerefVar(var_glojure_DOT_core_val)
									tmp23 := lang.Apply(tmp22, []any{v21})
									tmp20 = tmp23
								} // end let
								tmp19 = tmp20
							} else {
								var tmp21 any
								{ // let
									// let binding "ret"
									tmp22 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp23 := lang.Apply(tmp22, []any{v3, v12})
									var v24 any = tmp23
									_ = v24
									tmp25 := checkDerefVar(var_glojure_DOT_core_swap_BANG_)
									tmp26 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp27 := lang.Apply(tmp25, []any{v10, tmp26, v12, v24})
									_ = tmp27
									tmp21 = v24
								} // end let
								tmp19 = tmp21
							}
							tmp13 = tmp19
						} // end let
						return tmp13
					}
				})
				tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6346), kw_column, int(5), kw_end_DASH_line, int(6351), kw_end_DASH_column, int(16))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp13
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge
	{
		tmp0 := sym_merge.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_maps)), kw_doc, "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3040), kw_end_DASH_line, int(3040))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_some)
				tmp6 := checkDerefVar(var_glojure_DOT_core_identity)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp9 lang.FnFunc
					tmp9 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v10 := args[0]
						_ = v10
						v11 := args[1]
						_ = v11
						tmp12 := checkDerefVar(var_glojure_DOT_core_conj)
						var tmp13 any
						{ // let
							// let binding "or__0__auto__"
							var v14 any = v10
							_ = v14
							var tmp15 any
							if lang.IsTruthy(v14) {
								tmp15 = v14
							} else {
								tmp16 := lang.NewMap()
								tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3048), kw_column, int(28), kw_end_DASH_line, int(3048), kw_end_DASH_column, int(29))
								tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp15 = tmp18
							}
							tmp13 = tmp15
						} // end let
						tmp14 := lang.Apply(tmp12, []any{tmp13, v11})
						return tmp14
					})
					tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3048), kw_column, int(14), kw_end_DASH_line, int(3048), kw_end_DASH_column, int(34))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 := lang.Apply(tmp8, []any{tmp11, v3})
					tmp4 = tmp12
				} else {
				}
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge-hash-collisions
	{
		tmp0 := sym_merge_DASH_hash_DASH_collisions.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_expr_DASH_sym, sym_default, sym_tests, sym_thens)), kw_doc, "Takes a case expression, default expression, and a sequence of test constants\n  and a corresponding sequence of then expressions. Returns a tuple of\n  [tests thens skip-check-set] where no tests have the same hash. Each set of\n  input test constants with the same hash is replaced with a single test\n  constant (the case int), and their respective thens are combined into:\n  (condp = expr\n    test-1 then-1\n    ...\n    test-n then-n\n    default).\n  The skip-check is a set of case ints for which post-switch equivalence\n  checking must not be done (the cases holding the above condp thens).", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(28), kw_column, int(8), kw_line, int(6647), kw_end_DASH_line, int(6647), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			var tmp7 any
			{ // let
				// let binding "buckets"
				var tmp8 any
				{ // let
					// let binding "m"
					tmp9 := lang.NewMap()
					tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6661), kw_column, int(26), kw_end_DASH_line, int(6661), kw_end_DASH_column, int(27))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v12 any = tmp11
					_ = v12
					// let binding "ks"
					var v13 any = v5
					_ = v13
					// let binding "vs"
					var v14 any = v6
					_ = v14
					for {
						var tmp15 any
						var tmp16 any
						{ // let
							// let binding "and__0__auto__"
							var v17 any = v13
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								tmp18 = v14
							} else {
								tmp18 = v17
							}
							tmp16 = tmp18
						} // end let
						if lang.IsTruthy(tmp16) {
							tmp18 := checkDerefVar(var_glojure_DOT_core_update)
							tmp19 := checkDerefVar(var_glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v13})
							tmp21 := lang.Apply(lang.Hash, []any{tmp20})
							tmp22 := checkDerefVar(var_glojure_DOT_core_fnil)
							tmp23 := checkDerefVar(var_glojure_DOT_core_conj)
							tmp24 := lang.NewVector()
							tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6664), kw_column, int(102), kw_end_DASH_line, int(6664), kw_end_DASH_column, int(103))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp27 := lang.Apply(tmp22, []any{tmp23, tmp26})
							tmp28 := checkDerefVar(var_glojure_DOT_core_first)
							tmp29 := lang.Apply(tmp28, []any{v13})
							tmp30 := checkDerefVar(var_glojure_DOT_core_first)
							tmp31 := lang.Apply(tmp30, []any{v14})
							tmp32 := lang.NewVector(tmp29, tmp31)
							tmp33 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6664), kw_column, int(106), kw_end_DASH_line, int(6664), kw_end_DASH_column, int(128))
							tmp34, err := lang.WithMeta(tmp32, tmp33.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp35 := lang.Apply(tmp18, []any{v12, tmp21, tmp27, tmp34})
							var tmp17 any = tmp35
							tmp37 := checkDerefVar(var_glojure_DOT_core_next)
							tmp38 := lang.Apply(tmp37, []any{v13})
							var tmp36 any = tmp38
							tmp40 := checkDerefVar(var_glojure_DOT_core_next)
							tmp41 := lang.Apply(tmp40, []any{v14})
							var tmp39 any = tmp41
							v12 = tmp17
							v13 = tmp36
							v14 = tmp39
							continue
						} else {
							tmp15 = v12
						}
						tmp8 = tmp15
						break
					}
				} // end let
				var v9 any = tmp8
				_ = v9
				// let binding "assoc-multi"
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 3)
					v11 := args[0]
					_ = v11
					v12 := args[1]
					_ = v12
					v13 := args[2]
					_ = v13
					var tmp14 any
					{ // let
						// let binding "testexprs"
						tmp15 := checkDerefVar(var_glojure_DOT_core_mapcat)
						var tmp16 lang.FnFunc
						tmp16 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v17 := args[0]
							_ = v17
							tmp18 := checkDerefVar(var_glojure_DOT_core_list)
							tmp19 := checkDerefVar(var_glojure_DOT_core_first)
							tmp20 := lang.Apply(tmp19, []any{v17})
							tmp21 := lang.Apply(tmp18, []any{sym_quote, tmp20})
							tmp22 := checkDerefVar(var_glojure_DOT_core_second)
							tmp23 := lang.Apply(tmp22, []any{v17})
							tmp24 := lang.NewVector(tmp21, tmp23)
							tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6668), kw_column, int(56), kw_end_DASH_line, int(6668), kw_end_DASH_column, int(93))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							return tmp26
						})
						tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6668), kw_column, int(47), kw_end_DASH_line, int(6668), kw_end_DASH_column, int(94))
						tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp19 := lang.Apply(tmp15, []any{tmp18, v13})
						var v20 any = tmp19
						_ = v20
						// let binding "expr"
						tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp22 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp23 := checkDerefVar(var_glojure_DOT_core_list)
						tmp24 := lang.Apply(tmp23, []any{sym_glojure_DOT_core_SLASH_condp})
						tmp25 := checkDerefVar(var_glojure_DOT_core_list)
						tmp26 := lang.Apply(tmp25, []any{sym_glojure_DOT_core_SLASH__EQ_})
						tmp27 := checkDerefVar(var_glojure_DOT_core_list)
						tmp28 := lang.Apply(tmp27, []any{v3})
						tmp29 := checkDerefVar(var_glojure_DOT_core_list)
						tmp30 := lang.Apply(tmp29, []any{v4})
						tmp31 := lang.Apply(tmp22, []any{tmp24, tmp26, tmp28, v20, tmp30})
						tmp32 := lang.Apply(tmp21, []any{tmp31})
						var v33 any = tmp32
						_ = v33
						tmp34 := checkDerefVar(var_glojure_DOT_core_assoc)
						tmp35 := lang.Apply(tmp34, []any{v11, v12, v33})
						tmp14 = tmp35
					} // end let
					return tmp14
				})
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6667), kw_column, int(21), kw_end_DASH_line, int(6670), kw_end_DASH_column, int(42))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v13 any = tmp12
				_ = v13
				// let binding "hmap"
				tmp14 := checkDerefVar(var_glojure_DOT_core_reduce1)
				var tmp15 lang.FnFunc
				tmp15 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v16 := args[0]
					_ = v16
					v17 := args[1]
					_ = v17
					var tmp18 any
					{ // let
						// let binding "vec__164"
						var v19 any = v17
						_ = v19
						// let binding "h"
						tmp20 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp21 := lang.Apply(tmp20, []any{v19, int64(0), nil})
						var v22 any = tmp21
						_ = v22
						// let binding "bucket"
						tmp23 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp24 := lang.Apply(tmp23, []any{v19, int64(1), nil})
						var v25 any = tmp24
						_ = v25
						var tmp26 any
						tmp27 := checkDerefVar(var_glojure_DOT_core__EQ__EQ_)
						tmp28 := checkDerefVar(var_glojure_DOT_core_count)
						tmp29 := lang.Apply(tmp28, []any{v25})
						tmp30 := lang.Apply(tmp27, []any{int64(1), tmp29})
						if lang.IsTruthy(tmp30) {
							tmp31 := checkDerefVar(var_glojure_DOT_core_assoc)
							tmp32 := checkDerefVar(var_glojure_DOT_core_ffirst)
							tmp33 := lang.Apply(tmp32, []any{v25})
							tmp34 := checkDerefVar(var_glojure_DOT_core_second)
							tmp35 := checkDerefVar(var_glojure_DOT_core_first)
							tmp36 := lang.Apply(tmp35, []any{v25})
							tmp37 := lang.Apply(tmp34, []any{tmp36})
							tmp38 := lang.Apply(tmp31, []any{v16, tmp33, tmp37})
							tmp26 = tmp38
						} else {
							tmp39 := lang.Apply(v13, []any{v16, v22, v25})
							tmp26 = tmp39
						}
						tmp18 = tmp26
					} // end let
					return tmp18
				})
				tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6672), kw_column, int(16), kw_end_DASH_line, int(6675), kw_end_DASH_column, int(45))
				tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp18 := lang.NewMap()
				tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6676), kw_column, int(16), kw_end_DASH_line, int(6676), kw_end_DASH_column, int(17))
				tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp21 := lang.Apply(tmp14, []any{tmp17, tmp20, v9})
				var v22 any = tmp21
				_ = v22
				// let binding "skip-check"
				tmp23 := checkDerefVar(var_glojure_DOT_core_into1)
				tmp24 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6680), kw_column, int(29), kw_end_DASH_line, int(6680), kw_end_DASH_column, int(31))
				tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp27 := checkDerefVar(var_glojure_DOT_core_map)
				tmp28 := checkDerefVar(var_glojure_DOT_core_first)
				tmp29 := checkDerefVar(var_glojure_DOT_core_filter)
				var tmp30 lang.FnFunc
				tmp30 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v31 := args[0]
					_ = v31
					tmp32 := checkDerefVar(var_glojure_DOT_core__LT_)
					tmp33 := checkDerefVar(var_glojure_DOT_core_count)
					tmp34 := checkDerefVar(var_glojure_DOT_core_second)
					tmp35 := lang.Apply(tmp34, []any{v31})
					tmp36 := lang.Apply(tmp33, []any{tmp35})
					tmp37 := lang.Apply(tmp32, []any{int64(1), tmp36})
					return tmp37
				})
				tmp31 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6678), kw_column, int(30), kw_end_DASH_line, int(6678), kw_end_DASH_column, int(54))
				tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp33 := lang.Apply(tmp29, []any{tmp32, v9})
				tmp34 := lang.Apply(tmp27, []any{tmp28, tmp33})
				tmp35 := lang.Apply(tmp23, []any{tmp26, tmp34})
				var v36 any = tmp35
				_ = v36
				tmp37 := checkDerefVar(var_glojure_DOT_core_keys)
				tmp38 := lang.Apply(tmp37, []any{v22})
				tmp39 := checkDerefVar(var_glojure_DOT_core_vals)
				tmp40 := lang.Apply(tmp39, []any{v22})
				tmp41 := lang.NewVector(tmp38, tmp40, v36)
				tmp42 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6681), kw_column, int(5), kw_end_DASH_line, int(6681), kw_end_DASH_column, int(40))
				tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp7 = tmp43
			} // end let
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge-with
	{
		tmp0 := sym_merge_DASH_with.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym__AMP_, sym_maps)), kw_doc, "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(3050), kw_end_DASH_line, int(3050))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_some)
				tmp7 := checkDerefVar(var_glojure_DOT_core_identity)
				tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					{ // let
						// let binding "merge-entry"
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v11 := args[0]
							_ = v11
							v12 := args[1]
							_ = v12
							var tmp13 any
							{ // let
								// let binding "k"
								tmp14 := checkDerefVar(var_glojure_DOT_core_key)
								tmp15 := lang.Apply(tmp14, []any{v12})
								var v16 any = tmp15
								_ = v16
								// let binding "v"
								tmp17 := checkDerefVar(var_glojure_DOT_core_val)
								tmp18 := lang.Apply(tmp17, []any{v12})
								var v19 any = tmp18
								_ = v19
								var tmp20 any
								tmp21 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
								tmp22 := lang.Apply(tmp21, []any{v11, v16})
								if lang.IsTruthy(tmp22) {
									tmp23 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp24 := checkDerefVar(var_glojure_DOT_core_get)
									tmp25 := lang.Apply(tmp24, []any{v11, v16})
									tmp26 := lang.Apply(v3, []any{tmp25, v19})
									tmp27 := lang.Apply(tmp23, []any{v11, v16, tmp26})
									tmp20 = tmp27
								} else {
									tmp28 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp29 := lang.Apply(tmp28, []any{v11, v16, v19})
									tmp20 = tmp29
								}
								tmp13 = tmp20
							} // end let
							return tmp13
						})
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3059), kw_column, int(23), kw_end_DASH_line, int(3063), kw_end_DASH_column, int(23))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v13 any = tmp12
						_ = v13
						// let binding "merge2"
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v15 := args[0]
							_ = v15
							v16 := args[1]
							_ = v16
							tmp17 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp18 any
							{ // let
								// let binding "or__0__auto__"
								var v19 any = v15
								_ = v19
								var tmp20 any
								if lang.IsTruthy(v19) {
									tmp20 = v19
								} else {
									tmp21 := lang.NewMap()
									tmp22 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3065), kw_column, int(34), kw_end_DASH_line, int(3065), kw_end_DASH_column, int(35))
									tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp20 = tmp23
								}
								tmp18 = tmp20
							} // end let
							tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp20 := lang.Apply(tmp19, []any{v16})
							tmp21 := lang.Apply(tmp17, []any{v13, tmp18, tmp20})
							return tmp21
						})
						tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3064), kw_column, int(18), kw_end_DASH_line, int(3065), kw_end_DASH_column, int(47))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v17 any = tmp16
						_ = v17
						tmp18 := checkDerefVar(var_glojure_DOT_core_reduce1)
						tmp19 := lang.Apply(tmp18, []any{v17, v4})
						tmp9 = tmp19
					} // end let
					tmp5 = tmp9
				} else {
				}
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// meta
	{
		tmp0 := sym_meta.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_obj)), kw_doc, "Returns the metadata of obj, returns nil if there is no metadata.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(202), kw_end_DASH_line, int(206))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function meta
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IMeta)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
				if lang.IsTruthy(tmp8) {
					tmp9, ok := lang.FieldOrMethod(v4, "Meta")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "Meta")))
					}
					var tmp10 any
					switch reflect.TypeOf(tmp9).Kind() {
					case reflect.Func:
						tmp10 = lang.Apply(tmp9, nil)
					default:
						tmp10 = tmp9
					}
					tmp5 = tmp10
				} else {
				}
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(206), kw_column, int(7), kw_end_DASH_line, int(208), kw_end_DASH_column, int(21))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// methods
	{
		tmp0 := sym_methods.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn)), kw_doc, "Given a multimethod, returns a map of dispatch values -> dispatch fns", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1809), kw_end_DASH_line, int(1809))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getMethodTable")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMethodTable")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// min
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp5) {
						tmp4 = closed34
					} else {
						tmp4 = closed34
					}
					var v6 any = tmp4
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
					tmp11 := checkDerefVar(var_glojure_DOT_core_list)
					tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{v6})
					tmp18 := checkDerefVar(var_glojure_DOT_core_list)
					tmp19 := lang.Apply(tmp18, []any{v2})
					tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
					tmp21 := lang.Apply(tmp14, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp23 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp22})
					tmp24 := lang.Apply(tmp7, []any{tmp23})
					tmp3 = tmp24
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp6) {
						tmp5 = closed34
					} else {
						tmp5 = closed34
					}
					var v7 any = tmp5
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp9 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym__DOT_})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := lang.Apply(tmp12, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp14 := checkDerefVar(var_glojure_DOT_core_list)
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{v7})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v2})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp23 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp23})
					tmp25 := lang.Apply(tmp14, []any{tmp24})
					tmp26 := lang.Apply(tmp9, []any{tmp11, tmp13, tmp25})
					tmp27 := lang.Apply(tmp8, []any{tmp26})
					tmp4 = tmp27
				} // end let
				return tmp4
			default:
				checkArity(args, 2)
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
					if lang.IsTruthy(tmp7) {
						tmp6 = closed34
					} else {
						tmp6 = closed34
					}
					var v8 any = tmp6
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp15 := checkDerefVar(var_glojure_DOT_core_list)
						tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
						tmp17 := checkDerefVar(var_glojure_DOT_core_list)
						tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{v8})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := lang.Apply(tmp26, []any{v12})
						tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
						tmp29 := lang.Apply(tmp20, []any{tmp28})
						tmp30 := lang.Apply(tmp19, []any{tmp29})
						tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
						tmp32 := lang.Apply(tmp13, []any{tmp31})
						return tmp32
					})
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym__DOT_})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{v8})
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v2})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp27})
					tmp29 := lang.Apply(tmp20, []any{tmp28})
					tmp30 := lang.Apply(tmp19, []any{tmp29})
					tmp31 := lang.Apply(tmp14, []any{tmp16, tmp18, tmp30})
					tmp32 := lang.Apply(tmp13, []any{tmp31})
					tmp33 := lang.Apply(tmp9, []any{tmp12, tmp32, v4})
					tmp5 = tmp33
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp0 := sym_min.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_inline, tmp1, kw_doc, "Returns the least of the nums.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, tmp2, kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1118), kw_end_DASH_line, int(1118))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				return v5
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Min")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Min is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
				tmp9 := checkDerefVar(var_glojure_DOT_core_min)
				tmp10 := checkDerefVar(var_glojure_DOT_core_min)
				tmp11 := lang.Apply(tmp10, []any{v5, v6})
				tmp12 := lang.Apply(tmp8, []any{tmp9, tmp11, v7})
				return tmp12
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// min-key
	{
		tmp0 := sym_min_DASH_key.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_k, sym_x), lang.NewVector(sym_k, sym_x, sym_y), lang.NewVector(sym_k, sym_x, sym_y, sym__AMP_, sym_more)), kw_doc, "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5033), kw_end_DASH_line, int(5033))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return v4
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core__LT_)
				tmp8 := lang.Apply(v3, []any{v4})
				tmp9 := lang.Apply(v3, []any{v5})
				tmp10 := lang.Apply(tmp7, []any{tmp8, tmp9})
				if lang.IsTruthy(tmp10) {
					tmp6 = v4
				} else {
					tmp6 = v5
				}
				return tmp6
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "kx"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ky"
					tmp10 := lang.Apply(v3, []any{v5})
					var v11 any = tmp10
					_ = v11
					// let binding "vec__58"
					var tmp12 any
					tmp13 := checkDerefVar(var_glojure_DOT_core__LT_)
					tmp14 := lang.Apply(tmp13, []any{v9, v11})
					if lang.IsTruthy(tmp14) {
						tmp15 := lang.NewVector(v4, v9)
						tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5043), kw_column, int(31), kw_end_DASH_line, int(5043), kw_end_DASH_column, int(36))
						tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp17
					} else {
						tmp18 := lang.NewVector(v5, v11)
						tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5043), kw_column, int(38), kw_end_DASH_line, int(5043), kw_end_DASH_column, int(43))
						tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp20
					}
					var v21 any = tmp12
					_ = v21
					// let binding "v"
					tmp22 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp23 := lang.Apply(tmp22, []any{v21, int64(0), nil})
					var v24 any = tmp23
					_ = v24
					// let binding "kv"
					tmp25 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp26 := lang.Apply(tmp25, []any{v21, int64(1), nil})
					var v27 any = tmp26
					_ = v27
					var tmp28 any
					{ // let
						// let binding "v"
						var v29 any = v24
						_ = v29
						// let binding "kv"
						var v30 any = v27
						_ = v30
						// let binding "more"
						var v31 any = v6
						_ = v31
						for {
							var tmp32 any
							if lang.IsTruthy(v31) {
								var tmp33 any
								{ // let
									// let binding "w"
									tmp34 := checkDerefVar(var_glojure_DOT_core_first)
									tmp35 := lang.Apply(tmp34, []any{v31})
									var v36 any = tmp35
									_ = v36
									// let binding "kw"
									tmp37 := lang.Apply(v3, []any{v36})
									var v38 any = tmp37
									_ = v38
									var tmp39 any
									tmp40 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
									tmp41 := lang.Apply(tmp40, []any{v38, v30})
									if lang.IsTruthy(tmp41) {
										var tmp42 any = v36
										var tmp43 any = v38
										tmp45 := checkDerefVar(var_glojure_DOT_core_next)
										tmp46 := lang.Apply(tmp45, []any{v31})
										var tmp44 any = tmp46
										v29 = tmp42
										v30 = tmp43
										v31 = tmp44
										continue
									} else {
										var tmp47 any = v29
										var tmp48 any = v30
										tmp50 := checkDerefVar(var_glojure_DOT_core_next)
										tmp51 := lang.Apply(tmp50, []any{v31})
										var tmp49 any = tmp51
										v29 = tmp47
										v30 = tmp48
										v31 = tmp49
										continue
									}
									tmp33 = tmp39
								} // end let
								tmp32 = tmp33
							} else {
								tmp32 = v29
							}
							tmp28 = tmp32
							break
						}
					} // end let
					tmp7 = tmp28
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mix-collection-hash
	{
		tmp0 := sym_mix_DASH_collection_DASH_hash.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_hash_DASH_basis, sym_count)), kw_doc, "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://glojure.org/data_structures#hash for full algorithms.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(5199), kw_end_DASH_line, int(5199))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mk-bound-fn
	{
		tmp0 := sym_mk_DASH_bound_DASH_fn.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5127), kw_column, int(7), kw_end_DASH_line, int(5127), kw_end_DASH_column, int(17), kw_arglists, lang.NewList(lang.NewVector(sym_sc, sym_test, sym_key)), kw_private, true, kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v7 := args[0]
				_ = v7
				tmp8, ok := lang.FieldOrMethod(v3, "comparator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "comparator")))
				}
				var tmp9 any
				switch reflect.TypeOf(tmp8).Kind() {
				case reflect.Func:
					tmp9 = lang.Apply(tmp8, nil)
				default:
					tmp9 = tmp8
				}
				tmp10, _ := lang.FieldOrMethod(v3, "entryKey")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("entryKey is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{v7})
				tmp12, _ := lang.FieldOrMethod(tmp9, "compare")
				if reflect.TypeOf(tmp12).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("compare is not a function")))
				}
				tmp13 := lang.Apply(tmp12, []any{tmp11, v5})
				tmp14 := lang.Apply(v4, []any{tmp13, int64(0)})
				return tmp14
			})
			tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5130), kw_column, int(3), kw_end_DASH_line, int(5131), kw_end_DASH_column, int(64))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mod
	{
		tmp0 := sym_mod.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num, sym_div)), kw_doc, "Modulus of num and div. Truncates toward negative infinity.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(3567), kw_end_DASH_line, int(3567))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "m"
				tmp6 := checkDerefVar(var_glojure_DOT_core_rem)
				tmp7 := lang.Apply(tmp6, []any{v3, v4})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				var tmp10 any
				{ // let
					// let binding "or__0__auto__"
					tmp11 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
					tmp12 := lang.Apply(tmp11, []any{v8})
					var v13 any = tmp12
					_ = v13
					var tmp14 any
					if lang.IsTruthy(v13) {
						tmp14 = v13
					} else {
						tmp15 := checkDerefVar(var_glojure_DOT_core__EQ_)
						tmp16 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp17 := lang.Apply(tmp16, []any{v3})
						tmp18 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
						tmp19 := lang.Apply(tmp18, []any{v4})
						tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
						tmp14 = tmp20
					}
					tmp10 = tmp14
				} // end let
				if lang.IsTruthy(tmp10) {
					tmp9 = v8
				} else {
					tmp11 := checkDerefVar(var_glojure_DOT_core__PLUS_)
					tmp12 := lang.Apply(tmp11, []any{v8, v4})
					tmp9 = tmp12
				}
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// name
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_name.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns the name String of a string, symbol or keyword.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1585), kw_end_DASH_line, int(1585))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			if lang.IsTruthy(tmp7) {
				tmp5 = v4
			} else {
				tmp8, _ := lang.FieldOrMethod(v4, "Name")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Name is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{})
				tmp5 = tmp9
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// namespace
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_namespace.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns the namespace String of a symbol or keyword, or nil if not present.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(1593), kw_end_DASH_line, int(1593))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v4, "Namespace")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Namespace is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{})
			return tmp6
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nary-inline
	{
		tmp0 := sym_nary_DASH_inline.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(948), kw_column, int(7), kw_end_DASH_line, int(948), kw_end_DASH_column, int(27), kw_arglists, lang.NewList(lang.NewVector(sym_op), lang.NewVector(sym_op, sym_unchecked_DASH_op)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_nary_DASH_inline)
				tmp5 := lang.Apply(tmp4, []any{v3, v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 1:
						v6 := args[0]
						_ = v6
						var tmp7 any
						{ // let
							// let binding "op"
							var tmp8 any
							tmp9 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
							if lang.IsTruthy(tmp9) {
								tmp8 = v4
							} else {
								tmp8 = v3
							}
							var v10 any = tmp8
							_ = v10
							tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp13 := checkDerefVar(var_glojure_DOT_core_list)
							tmp14 := lang.Apply(tmp13, []any{sym__DOT_})
							tmp15 := checkDerefVar(var_glojure_DOT_core_list)
							tmp16 := lang.Apply(tmp15, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
							tmp17 := checkDerefVar(var_glojure_DOT_core_list)
							tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp20 := checkDerefVar(var_glojure_DOT_core_list)
							tmp21 := lang.Apply(tmp20, []any{v10})
							tmp22 := checkDerefVar(var_glojure_DOT_core_list)
							tmp23 := lang.Apply(tmp22, []any{v6})
							tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
							tmp25 := lang.Apply(tmp18, []any{tmp24})
							tmp26 := lang.Apply(tmp17, []any{tmp25})
							tmp27 := lang.Apply(tmp12, []any{tmp14, tmp16, tmp26})
							tmp28 := lang.Apply(tmp11, []any{tmp27})
							tmp7 = tmp28
						} // end let
						return tmp7
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						var tmp8 any
						{ // let
							// let binding "op"
							var tmp9 any
							tmp10 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
							if lang.IsTruthy(tmp10) {
								tmp9 = v4
							} else {
								tmp9 = v3
							}
							var v11 any = tmp9
							_ = v11
							tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp14 := checkDerefVar(var_glojure_DOT_core_list)
							tmp15 := lang.Apply(tmp14, []any{sym__DOT_})
							tmp16 := checkDerefVar(var_glojure_DOT_core_list)
							tmp17 := lang.Apply(tmp16, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
							tmp18 := checkDerefVar(var_glojure_DOT_core_list)
							tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp21 := checkDerefVar(var_glojure_DOT_core_list)
							tmp22 := lang.Apply(tmp21, []any{v11})
							tmp23 := checkDerefVar(var_glojure_DOT_core_list)
							tmp24 := lang.Apply(tmp23, []any{v6})
							tmp25 := checkDerefVar(var_glojure_DOT_core_list)
							tmp26 := lang.Apply(tmp25, []any{v7})
							tmp27 := lang.Apply(tmp20, []any{tmp22, tmp24, tmp26})
							tmp28 := lang.Apply(tmp19, []any{tmp27})
							tmp29 := lang.Apply(tmp18, []any{tmp28})
							tmp30 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp29})
							tmp31 := lang.Apply(tmp12, []any{tmp30})
							tmp8 = tmp31
						} // end let
						return tmp8
					default:
						checkArity(args, 2)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						var v8 any = lang.NewList(args[2:]...)
						_ = v8
						var tmp9 any
						{ // let
							// let binding "op"
							var tmp10 any
							tmp11 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
							if lang.IsTruthy(tmp11) {
								tmp10 = v4
							} else {
								tmp10 = v3
							}
							var v12 any = tmp10
							_ = v12
							tmp13 := checkDerefVar(var_glojure_DOT_core_reduce1)
							var tmp14 lang.FnFunc
							tmp14 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 2)
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp19 := checkDerefVar(var_glojure_DOT_core_list)
								tmp20 := lang.Apply(tmp19, []any{sym__DOT_})
								tmp21 := checkDerefVar(var_glojure_DOT_core_list)
								tmp22 := lang.Apply(tmp21, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
								tmp23 := checkDerefVar(var_glojure_DOT_core_list)
								tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
								tmp26 := checkDerefVar(var_glojure_DOT_core_list)
								tmp27 := lang.Apply(tmp26, []any{v12})
								tmp28 := checkDerefVar(var_glojure_DOT_core_list)
								tmp29 := lang.Apply(tmp28, []any{v15})
								tmp30 := checkDerefVar(var_glojure_DOT_core_list)
								tmp31 := lang.Apply(tmp30, []any{v16})
								tmp32 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp31})
								tmp33 := lang.Apply(tmp24, []any{tmp32})
								tmp34 := lang.Apply(tmp23, []any{tmp33})
								tmp35 := lang.Apply(tmp18, []any{tmp20, tmp22, tmp34})
								tmp36 := lang.Apply(tmp17, []any{tmp35})
								return tmp36
							})
							tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(959), kw_column, int(14), kw_end_DASH_line, int(959), kw_end_DASH_column, int(88))
							tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp19 := checkDerefVar(var_glojure_DOT_core_list)
							tmp20 := lang.Apply(tmp19, []any{sym__DOT_})
							tmp21 := checkDerefVar(var_glojure_DOT_core_list)
							tmp22 := lang.Apply(tmp21, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
							tmp23 := checkDerefVar(var_glojure_DOT_core_list)
							tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp26 := checkDerefVar(var_glojure_DOT_core_list)
							tmp27 := lang.Apply(tmp26, []any{v12})
							tmp28 := checkDerefVar(var_glojure_DOT_core_list)
							tmp29 := lang.Apply(tmp28, []any{v6})
							tmp30 := checkDerefVar(var_glojure_DOT_core_list)
							tmp31 := lang.Apply(tmp30, []any{v7})
							tmp32 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp31})
							tmp33 := lang.Apply(tmp24, []any{tmp32})
							tmp34 := lang.Apply(tmp23, []any{tmp33})
							tmp35 := lang.Apply(tmp18, []any{tmp20, tmp22, tmp34})
							tmp36 := lang.Apply(tmp17, []any{tmp35})
							tmp37 := lang.Apply(tmp13, []any{tmp16, tmp36, v8})
							tmp9 = tmp37
						} // end let
						return tmp9
					}
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(951), kw_column, int(6), kw_end_DASH_line, int(960), kw_end_DASH_column, int(86))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nat-int?
	{
		tmp0 := sym_nat_DASH_int_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a non-negative fixed precision integer", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1415), kw_end_DASH_line, int(1415))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_not)
					tmp10 := checkDerefVar(var_glojure_DOT_core_neg_QMARK_)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					tmp8 = tmp12
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// neg-int?
	{
		tmp0 := sym_neg_DASH_int_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a negative fixed precision integer", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1409), kw_end_DASH_line, int(1409))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_neg_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp8 = tmp10
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// neg?
	{
		var tmp1 lang.FnFunc
		{ // function neg?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_IsNeg})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_neg_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_inline, tmp1, kw_doc, "Returns true if num is less than zero, else false", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1259), kw_end_DASH_line, int(1259))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IsNeg")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IsNeg is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// newline
	{
		tmp0 := sym_newline.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Writes a platform-specific newline to *out*", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3698), kw_end_DASH_line, int(3698))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := checkDerefVar(var_glojure_DOT_core__STAR_out_STAR_)
			tmp4 := checkDerefVar(var_glojure_DOT_core_system_DASH_newline)
			tmp5 := lang.Apply(lang.AppendWriter, []any{tmp3, tmp4})
			_ = tmp5
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// next
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := sym_next.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(55), kw_end_DASH_line, int(61))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		{ // function next
			var v4 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.Next, []any{v5})
				return tmp6
			})
			tmp3 = tmp3.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(61), kw_column, int(7), kw_end_DASH_line, int(61), kw_end_DASH_column, int(77))).(lang.FnFunc)
			v4 = tmp3
			_ = v4
		}
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nfirst
	{
		tmp0 := sym_nfirst.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Same as (next (first x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(2), kw_line, int(105), kw_end_DASH_line, int(109))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function nfirst
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_next)
				tmp6 := checkDerefVar(var_glojure_DOT_core_first)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(109), kw_column, int(9), kw_end_DASH_line, int(109), kw_end_DASH_column, int(49))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nil?
	{
		tmp1 := reflect.TypeOf(false)
		var tmp2 lang.FnFunc
		{ // function nil?__inliner
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_list)
				tmp6 := lang.Apply(tmp5, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Identical, v4, nil})
				return tmp6
			})
			v3 = tmp2
			_ = v3
		}
		tmp0 := sym_nil_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp2, kw_doc, "Returns true if x is nil, false otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(435), kw_end_DASH_line, int(435))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v5 := args[0]
			_ = v5
			tmp6 := lang.Apply(lang.IsNil, []any{v5})
			return tmp6
		})
		tmp5 := reflect.TypeOf(false)
		tmp4 = tmp4.WithMeta(lang.NewMap(kw_rettag, tmp5)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nnext
	{
		tmp0 := sym_nnext.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Same as (next (next x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(6), kw_column, int(2), kw_line, int(119), kw_end_DASH_line, int(123))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function nnext
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_next)
				tmp6 := checkDerefVar(var_glojure_DOT_core_next)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(123), kw_column, int(8), kw_end_DASH_line, int(123), kw_end_DASH_column, int(46))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// normalize-slurp-opts
	{
		tmp0 := sym_normalize_DASH_slurp_DASH_opts.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6974), kw_column, int(8), kw_end_DASH_line, int(6974), kw_end_DASH_column, int(27), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_opts)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp6 := checkDerefVar(var_glojure_DOT_core_first)
			tmp7 := lang.Apply(tmp6, []any{v3})
			tmp8 := lang.Apply(tmp5, []any{tmp7})
			if lang.IsTruthy(tmp8) {
				tmp9 := checkDerefVar(var_glojure_DOT_core_println)
				tmp10 := lang.Apply(tmp9, []any{"WARNING: (slurp f enc) is deprecated, use (slurp f :encoding enc)."})
				_ = tmp10
				tmp11 := checkDerefVar(var_glojure_DOT_core_first)
				tmp12 := lang.Apply(tmp11, []any{v3})
				tmp13 := lang.NewVector(kw_encoding, tmp12)
				tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6979), kw_column, int(7), kw_end_DASH_line, int(6979), kw_end_DASH_column, int(30))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp15
			} else {
				tmp4 = v3
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_not.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is logical false, false otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(523), kw_end_DASH_line, int(523))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			var tmp5 any
			if lang.IsTruthy(v4) {
				tmp5 = false
			} else {
				tmp5 = true
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-any?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_not_DASH_any_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns false if (pred x) is logical true for any x in coll,\n  else true.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(2), kw_line, int(2696), kw_end_DASH_line, int(2701))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp4 := lang.Apply(closed36, nil)
				tmp5 := lang.Apply(closed35, []any{tmp4})
				return tmp5
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(closed36, []any{v4})
				tmp6 := lang.Apply(closed35, []any{tmp5})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(closed36, []any{v4, v5})
				tmp7 := lang.Apply(closed35, []any{tmp6})
				return tmp7
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(closed36, []any{v4, v5, v6})
				tmp8 := lang.Apply(closed35, []any{tmp7})
				return tmp8
			default:
				checkArity(args, 3)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				var v7 any = lang.NewList(args[3:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp9 := lang.Apply(tmp8, []any{closed36, v4, v5, v6, v7})
				tmp10 := lang.Apply(closed35, []any{tmp9})
				return tmp10
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2559), kw_column, int(6), kw_end_DASH_line, int(2564), kw_end_DASH_column, int(49))).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-empty
	{
		tmp0 := sym_not_DASH_empty.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "If coll is empty, returns nil, else coll", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(5516), kw_end_DASH_line, int(5516))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp4 = v3
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-every?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_not_DASH_every_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns false if (pred x) is logical true for every x in\n  coll, else true.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(2), kw_line, int(2677), kw_end_DASH_line, int(2682))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp4 := lang.Apply(closed37, nil)
				tmp5 := lang.Apply(closed35, []any{tmp4})
				return tmp5
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(closed37, []any{v4})
				tmp6 := lang.Apply(closed35, []any{tmp5})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(closed37, []any{v4, v5})
				tmp7 := lang.Apply(closed35, []any{tmp6})
				return tmp7
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(closed37, []any{v4, v5, v6})
				tmp8 := lang.Apply(closed35, []any{tmp7})
				return tmp8
			default:
				checkArity(args, 3)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				var v7 any = lang.NewList(args[3:]...)
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp9 := lang.Apply(tmp8, []any{closed37, v4, v5, v6, v7})
				tmp10 := lang.Apply(closed35, []any{tmp9})
				return tmp10
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2559), kw_column, int(6), kw_end_DASH_line, int(2564), kw_end_DASH_column, int(49))).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not=
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_not_EQ_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym_y), lang.NewVector(sym_x, sym_y, sym__AMP_, sym_more)), kw_doc, "Same as (not (= obj1 obj2))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(812), kw_end_DASH_line, int(812))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return false
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_not)
				tmp7 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp8 := lang.Apply(tmp7, []any{v4, v5})
				tmp9 := lang.Apply(tmp6, []any{tmp8})
				return tmp9
			default:
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_not)
				tmp8 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp9 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp10 := lang.Apply(tmp8, []any{tmp9, v4, v5, v6})
				tmp11 := lang.Apply(tmp7, []any{tmp10})
				return tmp11
			}
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns
	{
		tmp0 := sym_ns.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name, sym_docstring_QMARK_, sym_attr_DASH_map_QMARK_, sym_references_STAR_)), kw_doc, "Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-glojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-glojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-glojure is not used, a\n  default (refer 'glojure.core) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-glojure :exclude [ancestors printf])\n    (:require (glojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(5742), kw_end_DASH_line, int(5742))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "process-reference"
					var tmp8 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v9 := args[0]
						_ = v9
						var tmp10 any
						{ // let
							// let binding "vec__107"
							var v11 any = v9
							_ = v11
							// let binding "seq__108"
							tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp13 := lang.Apply(tmp12, []any{v11})
							var v14 any = tmp13
							_ = v14
							// let binding "first__109"
							tmp15 := checkDerefVar(var_glojure_DOT_core_first)
							tmp16 := lang.Apply(tmp15, []any{v14})
							var v17 any = tmp16
							_ = v17
							// let binding "seq__108"
							tmp18 := checkDerefVar(var_glojure_DOT_core_next)
							tmp19 := lang.Apply(tmp18, []any{v14})
							var v20 any = tmp19
							_ = v20
							// let binding "kname"
							var v21 any = v17
							_ = v21
							// let binding "args"
							var v22 any = v20
							_ = v22
							tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
							tmp25 := checkDerefVar(var_glojure_DOT_core_list)
							tmp26 := checkDerefVar(var_glojure_DOT_core_symbol)
							tmp27 := checkDerefVar(var_glojure_DOT_core_name)
							tmp28 := lang.Apply(tmp27, []any{v21})
							tmp29 := lang.Apply(tmp26, []any{"glojure.core", tmp28})
							tmp30 := lang.Apply(tmp25, []any{tmp29})
							tmp31 := checkDerefVar(var_glojure_DOT_core_map)
							var tmp32 lang.FnFunc
							tmp32 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v33 := args[0]
								_ = v33
								tmp34 := checkDerefVar(var_glojure_DOT_core_list)
								tmp35 := lang.Apply(tmp34, []any{sym_quote, v33})
								return tmp35
							})
							tmp33 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5769), kw_column, int(21), kw_end_DASH_line, int(5769), kw_end_DASH_column, int(36))
							tmp34, err := lang.WithMeta(tmp32, tmp33.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp35 := lang.Apply(tmp31, []any{tmp34, v22})
							tmp36 := lang.Apply(tmp24, []any{tmp30, tmp35})
							tmp37 := lang.Apply(tmp23, []any{tmp36})
							tmp10 = tmp37
						} // end let
						return tmp10
					})
					tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5767), kw_column, int(9), kw_end_DASH_line, int(5769), kw_end_DASH_column, int(44))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v11 any = tmp10
					_ = v11
					// let binding "docstring"
					var tmp12 any
					tmp13 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_first)
					tmp15 := lang.Apply(tmp14, []any{v6})
					tmp16 := lang.Apply(tmp13, []any{tmp15})
					if lang.IsTruthy(tmp16) {
						tmp17 := checkDerefVar(var_glojure_DOT_core_first)
						tmp18 := lang.Apply(tmp17, []any{v6})
						tmp12 = tmp18
					} else {
					}
					var v19 any = tmp12
					_ = v19
					// let binding "references"
					var tmp20 any
					if lang.IsTruthy(v19) {
						tmp21 := checkDerefVar(var_glojure_DOT_core_next)
						tmp22 := lang.Apply(tmp21, []any{v6})
						tmp20 = tmp22
					} else {
						tmp20 = v6
					}
					var v23 any = tmp20
					_ = v23
					// let binding "name"
					var tmp24 any
					if lang.IsTruthy(v19) {
						tmp25 := checkDerefVar(var_glojure_DOT_core_vary_DASH_meta)
						tmp26 := checkDerefVar(var_glojure_DOT_core_assoc)
						tmp27 := lang.Apply(tmp25, []any{v5, tmp26, kw_doc, v19})
						tmp24 = tmp27
					} else {
						tmp24 = v5
					}
					var v28 any = tmp24
					_ = v28
					// let binding "metadata"
					var tmp29 any
					tmp30 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
					tmp31 := checkDerefVar(var_glojure_DOT_core_first)
					tmp32 := lang.Apply(tmp31, []any{v23})
					tmp33 := lang.Apply(tmp30, []any{tmp32})
					if lang.IsTruthy(tmp33) {
						tmp34 := checkDerefVar(var_glojure_DOT_core_first)
						tmp35 := lang.Apply(tmp34, []any{v23})
						tmp29 = tmp35
					} else {
					}
					var v36 any = tmp29
					_ = v36
					// let binding "references"
					var tmp37 any
					if lang.IsTruthy(v36) {
						tmp38 := checkDerefVar(var_glojure_DOT_core_next)
						tmp39 := lang.Apply(tmp38, []any{v23})
						tmp37 = tmp39
					} else {
						tmp37 = v23
					}
					var v40 any = tmp37
					_ = v40
					// let binding "name"
					var tmp41 any
					if lang.IsTruthy(v36) {
						tmp42 := checkDerefVar(var_glojure_DOT_core_vary_DASH_meta)
						tmp43 := checkDerefVar(var_glojure_DOT_core_merge)
						tmp44 := lang.Apply(tmp42, []any{v28, tmp43, v36})
						tmp41 = tmp44
					} else {
						tmp41 = v28
					}
					var v45 any = tmp41
					_ = v45
					// let binding "gen-class-clause"
					tmp46 := checkDerefVar(var_glojure_DOT_core_first)
					tmp47 := checkDerefVar(var_glojure_DOT_core_filter)
					var tmp48 lang.FnFunc
					tmp48 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v49 := args[0]
						_ = v49
						tmp50 := checkDerefVar(var_glojure_DOT_core__EQ_)
						tmp51 := checkDerefVar(var_glojure_DOT_core_first)
						tmp52 := lang.Apply(tmp51, []any{v49})
						tmp53 := lang.Apply(tmp50, []any{kw_gen_DASH_class, tmp52})
						return tmp53
					})
					tmp49 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5780), kw_column, int(41), kw_end_DASH_line, int(5780), kw_end_DASH_column, int(65))
					tmp50, err := lang.WithMeta(tmp48, tmp49.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp51 := lang.Apply(tmp47, []any{tmp50, v40})
					tmp52 := lang.Apply(tmp46, []any{tmp51})
					var v53 any = tmp52
					_ = v53
					// let binding "gen-class-call"
					var tmp54 any
					if lang.IsTruthy(v53) {
						tmp55 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
						tmp56 := checkDerefVar(var_glojure_DOT_core_str)
						tmp57 := lang.Apply(tmp56, []any{v45})
						tmp58, _ := lang.FieldOrMethod(tmp57, "replace")
						if reflect.TypeOf(tmp58).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("replace is not a function")))
						}
						tmp59 := lang.Apply(tmp58, []any{lang.NewChar(45), lang.NewChar(95)})
						tmp60 := checkDerefVar(var_glojure_DOT_core_next)
						tmp61 := lang.Apply(tmp60, []any{v53})
						tmp62 := lang.Apply(tmp55, []any{sym_glojure_DOT_core_SLASH_gen_DASH_class, kw_name, tmp59, kw_impl_DASH_ns, v45, kw_main, true, tmp61})
						tmp54 = tmp62
					} else {
					}
					var v63 any = tmp54
					_ = v63
					// let binding "references"
					tmp64 := checkDerefVar(var_glojure_DOT_core_remove)
					var tmp65 lang.FnFunc
					tmp65 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v66 := args[0]
						_ = v66
						tmp67 := checkDerefVar(var_glojure_DOT_core__EQ_)
						tmp68 := checkDerefVar(var_glojure_DOT_core_first)
						tmp69 := lang.Apply(tmp68, []any{v66})
						tmp70 := lang.Apply(tmp67, []any{kw_gen_DASH_class, tmp69})
						return tmp70
					})
					tmp66 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5784), kw_column, int(28), kw_end_DASH_line, int(5784), kw_end_DASH_column, int(52))
					tmp67, err := lang.WithMeta(tmp65, tmp66.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp68 := lang.Apply(tmp64, []any{tmp67, v40})
					var v69 any = tmp68
					_ = v69
					// let binding "name-metadata"
					tmp70 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp71 := lang.Apply(tmp70, []any{v45})
					var v72 any = tmp71
					_ = v72
					tmp73 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp74 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp75 := checkDerefVar(var_glojure_DOT_core_list)
					tmp76 := lang.Apply(tmp75, []any{sym_do})
					tmp77 := checkDerefVar(var_glojure_DOT_core_list)
					tmp78 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp79 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp80 := checkDerefVar(var_glojure_DOT_core_list)
					tmp81 := lang.Apply(tmp80, []any{sym_glojure_DOT_core_SLASH_in_DASH_ns})
					tmp82 := checkDerefVar(var_glojure_DOT_core_list)
					tmp83 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp84 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp85 := checkDerefVar(var_glojure_DOT_core_list)
					tmp86 := lang.Apply(tmp85, []any{sym_quote})
					tmp87 := checkDerefVar(var_glojure_DOT_core_list)
					tmp88 := lang.Apply(tmp87, []any{v45})
					tmp89 := lang.Apply(tmp84, []any{tmp86, tmp88})
					tmp90 := lang.Apply(tmp83, []any{tmp89})
					tmp91 := lang.Apply(tmp82, []any{tmp90})
					tmp92 := lang.Apply(tmp79, []any{tmp81, tmp91})
					tmp93 := lang.Apply(tmp78, []any{tmp92})
					tmp94 := lang.Apply(tmp77, []any{tmp93})
					var tmp95 any
					if lang.IsTruthy(v72) {
						tmp96 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp97 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp98 := checkDerefVar(var_glojure_DOT_core_list)
						tmp99 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp100 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp101 := checkDerefVar(var_glojure_DOT_core_list)
						tmp102 := lang.Apply(tmp101, []any{sym__DOT_ResetMeta})
						tmp103 := checkDerefVar(var_glojure_DOT_core_list)
						tmp104 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp105 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp106 := checkDerefVar(var_glojure_DOT_core_list)
						tmp107 := lang.Apply(tmp106, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_FindNamespace})
						tmp108 := checkDerefVar(var_glojure_DOT_core_list)
						tmp109 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp110 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp111 := checkDerefVar(var_glojure_DOT_core_list)
						tmp112 := lang.Apply(tmp111, []any{sym_quote})
						tmp113 := checkDerefVar(var_glojure_DOT_core_list)
						tmp114 := lang.Apply(tmp113, []any{v45})
						tmp115 := lang.Apply(tmp110, []any{tmp112, tmp114})
						tmp116 := lang.Apply(tmp109, []any{tmp115})
						tmp117 := lang.Apply(tmp108, []any{tmp116})
						tmp118 := lang.Apply(tmp105, []any{tmp107, tmp117})
						tmp119 := lang.Apply(tmp104, []any{tmp118})
						tmp120 := lang.Apply(tmp103, []any{tmp119})
						tmp121 := checkDerefVar(var_glojure_DOT_core_list)
						tmp122 := lang.Apply(tmp121, []any{v72})
						tmp123 := lang.Apply(tmp100, []any{tmp102, tmp120, tmp122})
						tmp124 := lang.Apply(tmp99, []any{tmp123})
						tmp125 := lang.Apply(tmp98, []any{tmp124})
						tmp126 := lang.Apply(tmp97, []any{tmp125})
						tmp127 := lang.Apply(tmp96, []any{tmp126})
						tmp95 = tmp127
					} else {
					}
					tmp128 := checkDerefVar(var_glojure_DOT_core_list)
					tmp129 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp130 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp131 := checkDerefVar(var_glojure_DOT_core_list)
					tmp132 := lang.Apply(tmp131, []any{sym_glojure_DOT_core_SLASH_with_DASH_loading_DASH_context})
					var tmp133 any
					if lang.IsTruthy(v63) {
						tmp134 := checkDerefVar(var_glojure_DOT_core_list)
						tmp135 := lang.Apply(tmp134, []any{v63})
						tmp133 = tmp135
					} else {
					}
					var tmp136 any
					var tmp137 any
					{ // let
						// let binding "and__0__auto__"
						tmp138 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
						tmp139 := lang.Apply(tmp138, []any{v45, sym_glojure_DOT_core})
						var v140 any = tmp139
						_ = v140
						var tmp141 any
						if lang.IsTruthy(v140) {
							tmp142 := checkDerefVar(var_glojure_DOT_core_not_DASH_any_QMARK_)
							var tmp143 lang.FnFunc
							tmp143 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v144 := args[0]
								_ = v144
								tmp145 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp146 := checkDerefVar(var_glojure_DOT_core_first)
								tmp147 := lang.Apply(tmp146, []any{v144})
								tmp148 := lang.Apply(tmp145, []any{kw_refer_DASH_glojure, tmp147})
								return tmp148
							})
							tmp144 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5793), kw_column, int(58), kw_end_DASH_line, int(5793), kw_end_DASH_column, int(86))
							tmp145, err := lang.WithMeta(tmp143, tmp144.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp146 := lang.Apply(tmp142, []any{tmp145, v69})
							tmp141 = tmp146
						} else {
							tmp141 = v140
						}
						tmp137 = tmp141
					} // end let
					if lang.IsTruthy(tmp137) {
						tmp138 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp139 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp140 := checkDerefVar(var_glojure_DOT_core_list)
						tmp141 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp142 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp143 := checkDerefVar(var_glojure_DOT_core_list)
						tmp144 := lang.Apply(tmp143, []any{sym_glojure_DOT_core_SLASH_refer})
						tmp145 := checkDerefVar(var_glojure_DOT_core_list)
						tmp146 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp147 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp148 := checkDerefVar(var_glojure_DOT_core_list)
						tmp149 := lang.Apply(tmp148, []any{sym_quote})
						tmp150 := checkDerefVar(var_glojure_DOT_core_list)
						tmp151 := lang.Apply(tmp150, []any{sym_glojure_DOT_core})
						tmp152 := lang.Apply(tmp147, []any{tmp149, tmp151})
						tmp153 := lang.Apply(tmp146, []any{tmp152})
						tmp154 := lang.Apply(tmp145, []any{tmp153})
						tmp155 := lang.Apply(tmp142, []any{tmp144, tmp154})
						tmp156 := lang.Apply(tmp141, []any{tmp155})
						tmp157 := lang.Apply(tmp140, []any{tmp156})
						tmp158 := lang.Apply(tmp139, []any{tmp157})
						tmp159 := lang.Apply(tmp138, []any{tmp158})
						tmp136 = tmp159
					} else {
					}
					tmp160 := checkDerefVar(var_glojure_DOT_core_map)
					tmp161 := lang.Apply(tmp160, []any{v11, v69})
					tmp162 := lang.Apply(tmp130, []any{tmp132, tmp133, tmp136, tmp161})
					tmp163 := lang.Apply(tmp129, []any{tmp162})
					tmp164 := lang.Apply(tmp128, []any{tmp163})
					tmp165 := checkDerefVar(var_glojure_DOT_core_list)
					tmp166 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp167 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp168 := checkDerefVar(var_glojure_DOT_core_list)
					tmp169 := lang.Apply(tmp168, []any{sym_if})
					tmp170 := checkDerefVar(var_glojure_DOT_core_list)
					tmp171 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp172 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp173 := checkDerefVar(var_glojure_DOT_core_list)
					tmp174 := lang.Apply(tmp173, []any{sym__DOT_Equals})
					tmp175 := checkDerefVar(var_glojure_DOT_core_list)
					tmp176 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp177 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp178 := checkDerefVar(var_glojure_DOT_core_list)
					tmp179 := lang.Apply(tmp178, []any{sym_quote})
					tmp180 := checkDerefVar(var_glojure_DOT_core_list)
					tmp181 := lang.Apply(tmp180, []any{v45})
					tmp182 := lang.Apply(tmp177, []any{tmp179, tmp181})
					tmp183 := lang.Apply(tmp176, []any{tmp182})
					tmp184 := lang.Apply(tmp175, []any{tmp183})
					tmp185 := checkDerefVar(var_glojure_DOT_core_list)
					tmp186 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp187 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp188 := checkDerefVar(var_glojure_DOT_core_list)
					tmp189 := lang.Apply(tmp188, []any{sym_quote})
					tmp190 := checkDerefVar(var_glojure_DOT_core_list)
					tmp191 := lang.Apply(tmp190, []any{sym_glojure_DOT_core})
					tmp192 := lang.Apply(tmp187, []any{tmp189, tmp191})
					tmp193 := lang.Apply(tmp186, []any{tmp192})
					tmp194 := lang.Apply(tmp185, []any{tmp193})
					tmp195 := lang.Apply(tmp172, []any{tmp174, tmp184, tmp194})
					tmp196 := lang.Apply(tmp171, []any{tmp195})
					tmp197 := lang.Apply(tmp170, []any{tmp196})
					tmp198 := checkDerefVar(var_glojure_DOT_core_list)
					tmp199 := lang.Apply(tmp198, []any{nil})
					tmp200 := checkDerefVar(var_glojure_DOT_core_list)
					tmp201 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp202 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp203 := checkDerefVar(var_glojure_DOT_core_list)
					tmp204 := lang.Apply(tmp203, []any{sym_do})
					tmp205 := checkDerefVar(var_glojure_DOT_core_list)
					tmp206 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp207 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp208 := checkDerefVar(var_glojure_DOT_core_list)
					tmp209 := lang.Apply(tmp208, []any{sym_glojure_DOT_core_SLASH_dosync})
					tmp210 := checkDerefVar(var_glojure_DOT_core_list)
					tmp211 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp212 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp213 := checkDerefVar(var_glojure_DOT_core_list)
					tmp214 := lang.Apply(tmp213, []any{sym_glojure_DOT_core_SLASH_commute})
					tmp215 := checkDerefVar(var_glojure_DOT_core_list)
					tmp216 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp217 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp218 := checkDerefVar(var_glojure_DOT_core_list)
					tmp219 := lang.Apply(tmp218, []any{sym_glojure_DOT_core_SLASH_deref})
					tmp220 := checkDerefVar(var_glojure_DOT_core_list)
					tmp221 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp222 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp223 := checkDerefVar(var_glojure_DOT_core_list)
					tmp224 := lang.Apply(tmp223, []any{sym_var})
					tmp225 := checkDerefVar(var_glojure_DOT_core_list)
					tmp226 := lang.Apply(tmp225, []any{sym_glojure_DOT_core_SLASH__STAR_loaded_DASH_libs_STAR_})
					tmp227 := lang.Apply(tmp222, []any{tmp224, tmp226})
					tmp228 := lang.Apply(tmp221, []any{tmp227})
					tmp229 := lang.Apply(tmp220, []any{tmp228})
					tmp230 := lang.Apply(tmp217, []any{tmp219, tmp229})
					tmp231 := lang.Apply(tmp216, []any{tmp230})
					tmp232 := lang.Apply(tmp215, []any{tmp231})
					tmp233 := checkDerefVar(var_glojure_DOT_core_list)
					tmp234 := lang.Apply(tmp233, []any{sym_glojure_DOT_core_SLASH_conj})
					tmp235 := checkDerefVar(var_glojure_DOT_core_list)
					tmp236 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp237 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp238 := checkDerefVar(var_glojure_DOT_core_list)
					tmp239 := lang.Apply(tmp238, []any{sym_quote})
					tmp240 := checkDerefVar(var_glojure_DOT_core_list)
					tmp241 := lang.Apply(tmp240, []any{v45})
					tmp242 := lang.Apply(tmp237, []any{tmp239, tmp241})
					tmp243 := lang.Apply(tmp236, []any{tmp242})
					tmp244 := lang.Apply(tmp235, []any{tmp243})
					tmp245 := lang.Apply(tmp212, []any{tmp214, tmp232, tmp234, tmp244})
					tmp246 := lang.Apply(tmp211, []any{tmp245})
					tmp247 := lang.Apply(tmp210, []any{tmp246})
					tmp248 := lang.Apply(tmp207, []any{tmp209, tmp247})
					tmp249 := lang.Apply(tmp206, []any{tmp248})
					tmp250 := lang.Apply(tmp205, []any{tmp249})
					tmp251 := checkDerefVar(var_glojure_DOT_core_list)
					tmp252 := lang.Apply(tmp251, []any{nil})
					tmp253 := lang.Apply(tmp202, []any{tmp204, tmp250, tmp252})
					tmp254 := lang.Apply(tmp201, []any{tmp253})
					tmp255 := lang.Apply(tmp200, []any{tmp254})
					tmp256 := lang.Apply(tmp167, []any{tmp169, tmp197, tmp199, tmp255})
					tmp257 := lang.Apply(tmp166, []any{tmp256})
					tmp258 := lang.Apply(tmp165, []any{tmp257})
					tmp259 := lang.Apply(tmp74, []any{tmp76, tmp94, tmp95, tmp164, tmp258})
					tmp260 := lang.Apply(tmp73, []any{tmp259})
					tmp7 = tmp260
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-aliases
	{
		tmp0 := sym_ns_DASH_aliases.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of the aliases for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4273), kw_end_DASH_line, int(4273))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp5 := lang.Apply(tmp4, []any{v3})
			tmp6, ok := lang.FieldOrMethod(tmp5, "getAliases")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp5, "getAliases")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-imports
	{
		tmp0 := sym_ns_DASH_imports.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of the import mappings for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4199), kw_end_DASH_line, int(4199))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_filter_DASH_key)
			tmp5 := checkDerefVar(var_glojure_DOT_core_val)
			tmp6 := checkDerefVar(var_glojure_DOT_core_partial)
			tmp7 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp8 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
			tmp9 := lang.Apply(tmp6, []any{tmp7, tmp8})
			tmp10 := checkDerefVar(var_glojure_DOT_core_ns_DASH_map)
			tmp11 := lang.Apply(tmp10, []any{v3})
			tmp12 := lang.Apply(tmp4, []any{tmp5, tmp9, tmp11})
			return tmp12
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-interns
	{
		tmp0 := sym_ns_DASH_interns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of the intern mappings for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4206), kw_end_DASH_line, int(4206))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ns"
				tmp5 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_filter_DASH_key)
				tmp9 := checkDerefVar(var_glojure_DOT_core_val)
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v11 := args[0]
					_ = v11
					var tmp12 any
					{ // let
						// let binding "and__0__auto__"
						tmp13 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp14 := reflect.TypeOf((*lang.Var)(nil))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v11})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						if lang.IsTruthy(v16) {
							tmp18 := checkDerefVar(var_glojure_DOT_core__EQ_)
							tmp19, ok := lang.FieldOrMethod(v11, "Namespace")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Namespace")))
							}
							var tmp20 any
							switch reflect.TypeOf(tmp19).Kind() {
							case reflect.Func:
								tmp20 = lang.Apply(tmp19, nil)
							default:
								tmp20 = tmp19
							}
							tmp21 := lang.Apply(tmp18, []any{v7, tmp20})
							tmp17 = tmp21
						} else {
							tmp17 = v16
						}
						tmp12 = tmp17
					} // end let
					return tmp12
				})
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4212), kw_column, int(21), kw_end_DASH_line, int(4213), kw_end_DASH_column, int(56))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := checkDerefVar(var_glojure_DOT_core_ns_DASH_map)
				tmp14 := lang.Apply(tmp13, []any{v7})
				tmp15 := lang.Apply(tmp8, []any{tmp9, tmp12, tmp14})
				tmp4 = tmp15
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-map
	{
		tmp0 := sym_ns_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of all the mappings for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4170), kw_end_DASH_line, int(4170))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp5 := lang.Apply(tmp4, []any{v3})
			tmp6, ok := lang.FieldOrMethod(tmp5, "Mappings")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp5, "Mappings")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-name
	{
		tmp0 := sym_ns_DASH_name.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns the name of the namespace, a symbol.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4163), kw_end_DASH_line, int(4163))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp5 := lang.Apply(tmp4, []any{v3})
			tmp6, ok := lang.FieldOrMethod(tmp5, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp5, "Name")))
			}
			var tmp7 any
			switch reflect.TypeOf(tmp6).Kind() {
			case reflect.Func:
				tmp7 = lang.Apply(tmp6, nil)
			default:
				tmp7 = tmp6
			}
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-publics
	{
		tmp0 := sym_ns_DASH_publics.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of the public intern mappings for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4188), kw_end_DASH_line, int(4188))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ns"
				tmp5 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_filter_DASH_key)
				tmp9 := checkDerefVar(var_glojure_DOT_core_val)
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v11 := args[0]
					_ = v11
					var tmp12 any
					{ // let
						// let binding "and__0__auto__"
						tmp13 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp14 := reflect.TypeOf((*lang.Var)(nil))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v11})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						if lang.IsTruthy(v16) {
							var tmp18 any
							{ // let
								// let binding "and__0__auto__"
								tmp19 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp20, ok := lang.FieldOrMethod(v11, "Namespace")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Namespace")))
								}
								var tmp21 any
								switch reflect.TypeOf(tmp20).Kind() {
								case reflect.Func:
									tmp21 = lang.Apply(tmp20, nil)
								default:
									tmp21 = tmp20
								}
								tmp22 := lang.Apply(tmp19, []any{v7, tmp21})
								var v23 any = tmp22
								_ = v23
								var tmp24 any
								if lang.IsTruthy(v23) {
									tmp25, ok := lang.FieldOrMethod(v11, "IsPublic")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "IsPublic")))
									}
									var tmp26 any
									switch reflect.TypeOf(tmp25).Kind() {
									case reflect.Func:
										tmp26 = lang.Apply(tmp25, nil)
									default:
										tmp26 = tmp25
									}
									tmp24 = tmp26
								} else {
									tmp24 = v23
								}
								tmp18 = tmp24
							} // end let
							tmp17 = tmp18
						} else {
							tmp17 = v16
						}
						tmp12 = tmp17
					} // end let
					return tmp12
				})
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4194), kw_column, int(21), kw_end_DASH_line, int(4196), kw_end_DASH_column, int(48))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := checkDerefVar(var_glojure_DOT_core_ns_DASH_map)
				tmp14 := lang.Apply(tmp13, []any{v7})
				tmp15 := lang.Apply(tmp8, []any{tmp9, tmp12, tmp14})
				tmp4 = tmp15
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-refers
	{
		tmp0 := sym_ns_DASH_refers.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns)), kw_doc, "Returns a map of the refer mappings for the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4253), kw_end_DASH_line, int(4253))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ns"
				tmp5 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_filter_DASH_key)
				tmp9 := checkDerefVar(var_glojure_DOT_core_val)
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v11 := args[0]
					_ = v11
					var tmp12 any
					{ // let
						// let binding "and__0__auto__"
						tmp13 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp14 := reflect.TypeOf((*lang.Var)(nil))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v11})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						if lang.IsTruthy(v16) {
							tmp18 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
							tmp19, ok := lang.FieldOrMethod(v11, "Namespace")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Namespace")))
							}
							var tmp20 any
							switch reflect.TypeOf(tmp19).Kind() {
							case reflect.Func:
								tmp20 = lang.Apply(tmp19, nil)
							default:
								tmp20 = tmp19
							}
							tmp21 := lang.Apply(tmp18, []any{v7, tmp20})
							tmp17 = tmp21
						} else {
							tmp17 = v16
						}
						tmp12 = tmp17
					} // end let
					return tmp12
				})
				tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4259), kw_column, int(21), kw_end_DASH_line, int(4260), kw_end_DASH_column, int(59))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := checkDerefVar(var_glojure_DOT_core_ns_DASH_map)
				tmp14 := lang.Apply(tmp13, []any{v7})
				tmp15 := lang.Apply(tmp8, []any{tmp9, tmp12, tmp14})
				tmp4 = tmp15
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-resolve
	{
		tmp0 := sym_ns_DASH_resolve.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns, sym_sym), lang.NewVector(sym_ns, sym_env, sym_sym)), kw_doc, "Returns the var or Class to which a symbol will be resolved in the\n  namespace (unless found in the environment), else nil.  Note that\n  if the symbol is fully qualified, the var/Class to which it resolves\n  need not be present in the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4358), kw_end_DASH_line, int(4358))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_ns_DASH_resolve)
				tmp6 := lang.Apply(tmp5, []any{v3, nil, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4, v5})
				if lang.IsTruthy(tmp8) {
				} else {
					tmp9 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp11, _ := lang.FieldOrMethod(runtime.Compiler, "maybeResolveIn")
					if reflect.TypeOf(tmp11).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("maybeResolveIn is not a function")))
					}
					tmp12 := lang.Apply(tmp11, []any{tmp10, v5})
					tmp6 = tmp12
				}
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-unalias
	{
		tmp0 := sym_ns_DASH_unalias.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns, sym_sym)), kw_doc, "Removes the alias for the symbol from the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4280), kw_end_DASH_line, int(4280))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7, _ := lang.FieldOrMethod(tmp6, "removeAlias")
			if reflect.TypeOf(tmp7).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeAlias is not a function")))
			}
			tmp8 := lang.Apply(tmp7, []any{v4})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-unmap
	{
		tmp0 := sym_ns_DASH_unmap.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns, sym_sym)), kw_doc, "Removes the mappings for the symbol from the namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4177), kw_end_DASH_line, int(4177))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_the_DASH_ns)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7, _ := lang.FieldOrMethod(tmp6, "unmap")
			if reflect.TypeOf(tmp7).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unmap is not a function")))
			}
			tmp8 := lang.Apply(tmp7, []any{v4})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nth
	{
		var tmp1 lang.FnFunc
		{ // function nth__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 2)
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					var v5 any = lang.NewList(args[2:]...)
					_ = v5
					tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym__DOT_})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_Nth})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp20 := checkDerefVar(var_glojure_DOT_core_list)
					tmp21 := lang.Apply(tmp20, []any{sym_glojure_DOT_core_SLASH_unquote})
					tmp22 := checkDerefVar(var_glojure_DOT_core_list)
					tmp23 := lang.Apply(tmp22, []any{sym_glojure_DOT_core_SLASH_c})
					tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
					tmp25 := lang.Apply(tmp18, []any{tmp24})
					tmp26 := lang.Apply(tmp17, []any{tmp25})
					tmp27 := checkDerefVar(var_glojure_DOT_core_list)
					tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp29 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp30 := checkDerefVar(var_glojure_DOT_core_list)
					tmp31 := lang.Apply(tmp30, []any{sym_glojure_DOT_core_SLASH_unquote})
					tmp32 := checkDerefVar(var_glojure_DOT_core_list)
					tmp33 := lang.Apply(tmp32, []any{sym_glojure_DOT_core_SLASH_i})
					tmp34 := lang.Apply(tmp29, []any{tmp31, tmp33})
					tmp35 := lang.Apply(tmp28, []any{tmp34})
					tmp36 := lang.Apply(tmp27, []any{tmp35})
					tmp37 := checkDerefVar(var_glojure_DOT_core_list)
					tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp39 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					tmp43 := lang.Apply(tmp42, []any{sym_glojure_DOT_core_SLASH_nf})
					tmp44 := lang.Apply(tmp39, []any{tmp41, tmp43})
					tmp45 := lang.Apply(tmp38, []any{tmp44})
					tmp46 := lang.Apply(tmp37, []any{tmp45})
					tmp47 := lang.Apply(tmp14, []any{tmp16, tmp26, tmp36, tmp46})
					tmp48 := lang.Apply(tmp13, []any{tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp50 := lang.Apply(tmp7, []any{tmp9, tmp11, tmp49})
					tmp51 := lang.Apply(tmp6, []any{tmp50})
					return tmp51
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_nth.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_index), lang.NewVector(sym_coll, sym_index, sym_not_DASH_found)), kw_inline, tmp1, kw_doc, "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, Java arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2), int64(3)})), kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(882), kw_end_DASH_line, int(882))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(runtime.RT, "Nth")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Nth is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(runtime.RT, "NthDefault")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("NthDefault is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v4, v5, v6})
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nthnext
	{
		tmp0 := sym_nthnext.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_n)), kw_doc, "Returns the nth next of coll, (seq coll) when n is 0.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3147), kw_end_DASH_line, int(3147))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			if lang.IsTruthy(tmp8) {
				var tmp9 any
				tmp10 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
				tmp11 := lang.Apply(tmp10, []any{v4})
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					tmp13 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
					tmp14 := lang.Apply(tmp13, []any{v4})
					if lang.IsTruthy(tmp14) {
						tmp12 = v4
					} else {
						tmp15 := lang.Apply(nil, []any{v4})
						tmp12 = tmp15
					}
					tmp16, _ := lang.FieldOrMethod(v3, "drop")
					if reflect.TypeOf(tmp16).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
					}
					tmp17 := lang.Apply(tmp16, []any{tmp12})
					tmp9 = tmp17
				} else {
					tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp19 := lang.Apply(tmp18, []any{v3})
					tmp9 = tmp19
				}
				tmp5 = tmp9
			} else {
				var tmp20 any
				{ // let
					// let binding "n"
					var v21 any = v4
					_ = v21
					// let binding "xs"
					tmp22 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp23 := lang.Apply(tmp22, []any{v3})
					var v24 any = tmp23
					_ = v24
					for {
						var tmp25 any
						var tmp26 any
						{ // let
							// let binding "and__0__auto__"
							var v27 any = v24
							_ = v27
							var tmp28 any
							if lang.IsTruthy(v27) {
								tmp29 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
								tmp30 := lang.Apply(tmp29, []any{v21})
								tmp28 = tmp30
							} else {
								tmp28 = v27
							}
							tmp26 = tmp28
						} // end let
						if lang.IsTruthy(tmp26) {
							tmp28 := checkDerefVar(var_glojure_DOT_core_dec)
							tmp29 := lang.Apply(tmp28, []any{v21})
							var tmp27 any = tmp29
							tmp31 := checkDerefVar(var_glojure_DOT_core_next)
							tmp32 := lang.Apply(tmp31, []any{v24})
							var tmp30 any = tmp32
							v21 = tmp27
							v24 = tmp30
							continue
						} else {
							tmp25 = v24
						}
						tmp20 = tmp25
						break
					}
				} // end let
				tmp5 = tmp20
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nthrest
	{
		tmp0 := sym_nthrest.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll, sym_n)), kw_doc, "Returns the nth rest of coll, coll when n is 0.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3161), kw_end_DASH_line, int(3161))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			if lang.IsTruthy(tmp7) {
				var tmp8 any
				{ // let
					// let binding "or__0__auto__"
					var tmp9 any
					tmp10 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp11 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
					tmp12 := lang.Apply(tmp10, []any{tmp11, v3})
					if lang.IsTruthy(tmp12) {
						var tmp13 any
						tmp14 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
						tmp15 := lang.Apply(tmp14, []any{v4})
						if lang.IsTruthy(tmp15) {
							tmp13 = v4
						} else {
							tmp16 := lang.Apply(nil, []any{v4})
							tmp13 = tmp16
						}
						tmp17, _ := lang.FieldOrMethod(v3, "drop")
						if reflect.TypeOf(tmp17).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
						}
						tmp18 := lang.Apply(tmp17, []any{tmp13})
						tmp9 = tmp18
					} else {
						var tmp19 any
						{ // let
							// let binding "n"
							var v20 any = v4
							_ = v20
							// let binding "xs"
							var v21 any = v3
							_ = v21
							for {
								var tmp22 any
								{ // let
									// let binding "temp__0__auto__"
									var tmp23 any
									{ // let
										// let binding "and__0__auto__"
										tmp24 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
										tmp25 := lang.Apply(tmp24, []any{v20})
										var v26 any = tmp25
										_ = v26
										var tmp27 any
										if lang.IsTruthy(v26) {
											tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp29 := lang.Apply(tmp28, []any{v21})
											tmp27 = tmp29
										} else {
											tmp27 = v26
										}
										tmp23 = tmp27
									} // end let
									var v24 any = tmp23
									_ = v24
									var tmp25 any
									if lang.IsTruthy(v24) {
										var tmp26 any
										{ // let
											// let binding "xs"
											var v27 any = v24
											_ = v27
											tmp29 := checkDerefVar(var_glojure_DOT_core_dec)
											tmp30 := lang.Apply(tmp29, []any{v20})
											var tmp28 any = tmp30
											tmp32 := checkDerefVar(var_glojure_DOT_core_rest)
											tmp33 := lang.Apply(tmp32, []any{v27})
											var tmp31 any = tmp33
											v20 = tmp28
											v21 = tmp31
											continue
										} // end let
										tmp25 = tmp26
									} else {
										tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp28 := lang.Apply(tmp27, []any{v21})
										tmp25 = tmp28
									}
									tmp22 = tmp25
								} // end let
								tmp19 = tmp22
								break
							}
						} // end let
						tmp9 = tmp19
					}
					var v20 any = tmp9
					_ = v20
					var tmp21 any
					if lang.IsTruthy(v20) {
						tmp21 = v20
					} else {
						tmp21 = lang.NewList()
					}
					tmp8 = tmp21
				} // end let
				tmp5 = tmp8
			} else {
				tmp5 = v3
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// num
	{
		var tmp1 lang.FnFunc
		{ // function num__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Num})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_num.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to Number", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(3474), kw_end_DASH_line, int(3474))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Num")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Num is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// number?
	{
		tmp0 := sym_number_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is a Number", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3560), kw_end_DASH_line, int(3560))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.IsNumber, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// numerator
	{
		tmp1 := reflect.TypeOf((*big9.Int)(nil))
		tmp0 := sym_numerator.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_r)), kw_doc, "Returns the numerator part of a Ratio.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3583), kw_end_DASH_line, int(3583))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, ok := lang.FieldOrMethod(v4, "numerator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "numerator")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			return tmp6
		})
		tmp4 := reflect.TypeOf((*big9.Int)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// object-array
	{
		var tmp1 lang.FnFunc
		{ // function object-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_Object_array})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_object_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of objects", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(5349), kw_end_DASH_line, int(5349))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime.RT, "Object_array")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Object_array is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// odd?
	{
		tmp0 := sym_odd_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is odd, throws an exception if n is not an integer", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1389), kw_end_DASH_line, int(1389))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_not)
			tmp5 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// or
	{
		tmp0 := sym_or.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_next)), kw_doc, "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(11), kw_line, int(847), kw_end_DASH_line, int(847))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return nil
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				return v5
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_let})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp13 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{sym_or__0__auto__})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v5})
				tmp20 := lang.Apply(tmp15, []any{tmp17, tmp19})
				tmp21 := lang.Apply(tmp14, []any{tmp20})
				tmp22 := lang.Apply(tmp12, []any{tmp13, tmp21})
				tmp23 := lang.Apply(tmp11, []any{tmp22})
				tmp24 := checkDerefVar(var_glojure_DOT_core_list)
				tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp27 := checkDerefVar(var_glojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{sym_if})
				tmp29 := checkDerefVar(var_glojure_DOT_core_list)
				tmp30 := lang.Apply(tmp29, []any{sym_or__0__auto__})
				tmp31 := checkDerefVar(var_glojure_DOT_core_list)
				tmp32 := lang.Apply(tmp31, []any{sym_or__0__auto__})
				tmp33 := checkDerefVar(var_glojure_DOT_core_list)
				tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp35 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp36 := checkDerefVar(var_glojure_DOT_core_list)
				tmp37 := lang.Apply(tmp36, []any{sym_glojure_DOT_core_SLASH_or})
				tmp38 := lang.Apply(tmp35, []any{tmp37, v6})
				tmp39 := lang.Apply(tmp34, []any{tmp38})
				tmp40 := lang.Apply(tmp33, []any{tmp39})
				tmp41 := lang.Apply(tmp26, []any{tmp28, tmp30, tmp32, tmp40})
				tmp42 := lang.Apply(tmp25, []any{tmp41})
				tmp43 := lang.Apply(tmp24, []any{tmp42})
				tmp44 := lang.Apply(tmp8, []any{tmp10, tmp23, tmp43})
				tmp45 := lang.Apply(tmp7, []any{tmp44})
				return tmp45
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parents
	{
		tmp0 := sym_parents.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag), lang.NewVector(sym_h, sym_tag)), kw_doc, "Returns the immediate parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5564), kw_end_DASH_line, int(5564))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_parents)
				tmp5 := checkDerefVar(var_glojure_DOT_core_global_DASH_hierarchy)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
				var tmp6 any
				{ // let
					// let binding "tp"
					tmp7 := checkDerefVar(var_glojure_DOT_core_get)
					tmp8 := lang.Apply(kw_parents, []any{v3})
					tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					tmp12 := checkDerefVar(var_glojure_DOT_core_class_QMARK_)
					tmp13 := lang.Apply(tmp12, []any{v4})
					if lang.IsTruthy(tmp13) {
						tmp14 := checkDerefVar(var_glojure_DOT_core_into1)
						tmp15 := checkDerefVar(var_glojure_DOT_core_set)
						tmp16 := checkDerefVar(var_glojure_DOT_core_bases)
						tmp17 := lang.Apply(tmp16, []any{v4})
						tmp18 := lang.Apply(tmp15, []any{tmp17})
						tmp19 := lang.Apply(tmp14, []any{tmp18, v10})
						tmp11 = tmp19
					} else {
						tmp11 = v10
					}
					tmp6 = tmp11
				} // end let
				tmp7 := lang.Apply(tmp5, []any{tmp6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-boolean
	{
		tmp0 := sym_parse_DASH_boolean.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Parse strings \"true\" or \"false\" and return a boolean, or nil if invalid", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(7957), kw_end_DASH_line, int(7957))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				var tmp7 any
				{ // let
					// let binding "G__365"
					var v8 any = v3
					_ = v8
				} // end let
				tmp4 = tmp7
			} else {
				tmp8 := checkDerefVar(var_glojure_DOT_core_parsing_DASH_err)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp9})
				panic(tmp10)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-double
	{
		tmp0 := sym_parse_DASH_double.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Parse string with floating point components and return a Double value,\n  or nil if parse fails.\n\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(7935), kw_end_DASH_line, int(7935))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				var tmp7 any
				{ // let
					// let binding "result__3649__auto__"
					tmp8 := lang.Apply(strconv12.ParseFloat, []any{v3, int64(64)})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := lang.Apply(v9, []any{int64(1)})
					if lang.IsTruthy(tmp11) {
					} else {
						tmp12 := lang.Apply(v9, []any{int64(0)})
						tmp10 = tmp12
					}
					tmp7 = tmp10
				} // end let
				tmp4 = tmp7
			} else {
				tmp8 := checkDerefVar(var_glojure_DOT_core_parsing_DASH_err)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp9})
				panic(tmp10)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-impls
	{
		tmp0 := sym_parse_DASH_impls.WithMeta(lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(13), kw_column, int(8), kw_end_DASH_line, int(13), kw_end_DASH_column, int(18), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_specs)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := lang.NewMap()
				tmp6 := lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(14), kw_column, int(14), kw_end_DASH_line, int(14), kw_end_DASH_column, int(15))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v8 any = tmp7
				_ = v8
				// let binding "s"
				var v9 any = v3
				_ = v9
				for {
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp12 := lang.Apply(tmp11, []any{v9})
					if lang.IsTruthy(tmp12) {
						tmp14 := checkDerefVar(var_glojure_DOT_core_assoc)
						tmp15 := checkDerefVar(var_glojure_DOT_core_first)
						tmp16 := lang.Apply(tmp15, []any{v9})
						tmp17 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
						tmp18 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp19 := checkDerefVar(var_glojure_DOT_core_next)
						tmp20 := lang.Apply(tmp19, []any{v9})
						tmp21 := lang.Apply(tmp17, []any{tmp18, tmp20})
						tmp22 := lang.Apply(tmp14, []any{v8, tmp16, tmp21})
						var tmp13 any = tmp22
						tmp24 := checkDerefVar(var_glojure_DOT_core_drop_DASH_while)
						tmp25 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
						tmp26 := checkDerefVar(var_glojure_DOT_core_next)
						tmp27 := lang.Apply(tmp26, []any{v9})
						tmp28 := lang.Apply(tmp24, []any{tmp25, tmp27})
						var tmp23 any = tmp28
						v8 = tmp13
						v9 = tmp23
						continue
					} else {
						tmp10 = v8
					}
					tmp4 = tmp10
					break
				}
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-long
	{
		tmp0 := sym_parse_DASH_long.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Parse string of decimal digits with optional leading -/+ and return a\n  Long value, or nil if parse fails", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7926), kw_end_DASH_line, int(7926))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				var tmp7 any
				{ // let
					// let binding "result__3648__auto__"
					tmp8 := lang.Apply(strconv12.ParseInt, []any{v3, int64(10), int64(64)})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := lang.Apply(v9, []any{int64(1)})
					if lang.IsTruthy(tmp11) {
					} else {
						tmp12 := lang.Apply(v9, []any{int64(0)})
						tmp10 = tmp12
					}
					tmp7 = tmp10
				} // end let
				tmp4 = tmp7
			} else {
				tmp8 := checkDerefVar(var_glojure_DOT_core_parsing_DASH_err)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp9})
				panic(tmp10)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-uuid
	{
		tmp0 := sym_parse_DASH_uuid.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Parse a string representing a UUID and return a java.util.UUID instance,\n  or nil if parse fails.\n\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#toString--", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7946), kw_end_DASH_line, int(7946))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						tmp5 := reflect.TypeOf((*lang.IllegalArgumentError)(nil))
						if lang.CatchMatches(r, tmp5) {
							v6 := r
							_ = v6
						} else {
							panic(r)
						}
					}
				}()
				var tmp6 any
				{ // let
					// let binding "vec__362"
					tmp7 := lang.Apply(uuid13.Parse, []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "uuid"
					tmp9 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp10 := lang.Apply(tmp9, []any{v8, int64(0), nil})
					var v11 any = tmp10
					_ = v11
					// let binding "err"
					tmp12 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp13 := lang.Apply(tmp12, []any{v8, int64(1), nil})
					var v14 any = tmp13
					_ = v14
					var tmp15 any
					if lang.IsTruthy(v14) {
						tmp16 := checkDerefVar(var_glojure_DOT_core_str)
						tmp17 := lang.Apply(tmp16, []any{"Error parsing UUID: ", v14})
						tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
						panic(tmp18)
					} else {
						tmp15 = v11
					}
					tmp6 = tmp15
				} // end let
				tmp4 = tmp6
			}()
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parsing-err
	{
		tmp0 := sym_parsing_DASH_err.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_val)), kw_doc, "Construct message for parsing for non-string parsing error", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(8), kw_line, int(7921), kw_end_DASH_line, int(7921), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_str)
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v3})
			if lang.IsTruthy(tmp7) {
				tmp5 = "nil"
			} else {
				tmp8 := checkDerefVar(var_glojure_DOT_core_class)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10, ok := lang.FieldOrMethod(tmp9, "Name")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp9, "Name")))
				}
				var tmp11 any
				switch reflect.TypeOf(tmp10).Kind() {
				case reflect.Func:
					tmp11 = lang.Apply(tmp10, nil)
				default:
					tmp11 = tmp10
				}
				tmp5 = tmp11
			}
			tmp12 := lang.Apply(tmp4, []any{"Expected string, got ", tmp5})
			return tmp12
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partial
	{
		tmp0 := sym_partial.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_arg1), lang.NewVector(sym_f, sym_arg1, sym_arg2), lang.NewVector(sym_f, sym_arg1, sym_arg2, sym_arg3), lang.NewVector(sym_f, sym_arg1, sym_arg2, sym_arg3, sym__AMP_, sym_more)), kw_doc, "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(2606), kw_end_DASH_line, int(2606))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v3, []any{v4})
						return tmp6
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v3, []any{v4, v6})
						return tmp7
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v4, v6, v7})
						return tmp8
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v4, v6, v7, v8})
						return tmp9
					default:
						checkArity(args, 3)
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp11 := lang.Apply(tmp10, []any{v3, v4, v6, v7, v8, v9})
						return tmp11
					}
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2614), kw_column, int(4), kw_end_DASH_line, int(2619), kw_end_DASH_column, int(48))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp7 := lang.Apply(v3, []any{v4, v5})
						return tmp7
					case 1:
						v7 := args[0]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v4, v5, v7})
						return tmp8
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v4, v5, v7, v8})
						return tmp9
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						tmp10 := lang.Apply(v3, []any{v4, v5, v7, v8, v9})
						return tmp10
					default:
						checkArity(args, 3)
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp12 := lang.Apply(tmp11, []any{v3, v4, v5, v7, v8, v9, v10})
						return tmp12
					}
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2621), kw_column, int(4), kw_end_DASH_line, int(2626), kw_end_DASH_column, int(53))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp8 := lang.Apply(v3, []any{v4, v5, v6})
						return tmp8
					case 1:
						v8 := args[0]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v4, v5, v6, v8})
						return tmp9
					case 2:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						tmp10 := lang.Apply(v3, []any{v4, v5, v6, v8, v9})
						return tmp10
					case 3:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						tmp11 := lang.Apply(v3, []any{v4, v5, v6, v8, v9, v10})
						return tmp11
					default:
						checkArity(args, 3)
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var v11 any = lang.NewList(args[3:]...)
						_ = v11
						tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp13 := lang.Apply(tmp12, []any{v3, v4, v5, v6, v8, v9, v10, v11})
						return tmp13
					}
				})
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2628), kw_column, int(4), kw_end_DASH_line, int(2633), kw_end_DASH_column, int(58))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp9
			default:
				checkArity(args, 4)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						checkArity(args, 0)
						var v9 any = lang.NewList(args[0:]...)
						_ = v9
						tmp10 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp11 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp12 := lang.Apply(tmp11, []any{v7, v9})
						tmp13 := lang.Apply(tmp10, []any{v3, v4, v5, v6, tmp12})
						return tmp13
					}
				})
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2635), kw_column, int(4), kw_end_DASH_line, int(2635), kw_end_DASH_column, int(60))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition
	{
		tmp0 := sym_partition.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll), lang.NewVector(sym_n, sym_step, sym_coll), lang.NewVector(sym_n, sym_step, sym_pad, sym_coll)), kw_doc, "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3177), kw_end_DASH_line, int(3177))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_partition)
				tmp6 := lang.Apply(tmp5, []any{v3, v3, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v5})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "s"
								var v13 any = v10
								_ = v13
								var tmp14 any
								{ // let
									// let binding "p"
									tmp15 := checkDerefVar(var_glojure_DOT_core_doall)
									tmp16 := checkDerefVar(var_glojure_DOT_core_take)
									tmp17 := lang.Apply(tmp16, []any{v3, v13})
									tmp18 := lang.Apply(tmp15, []any{tmp17})
									var v19 any = tmp18
									_ = v19
									var tmp20 any
									tmp21 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp22 := checkDerefVar(var_glojure_DOT_core_count)
									tmp23 := lang.Apply(tmp22, []any{v19})
									tmp24 := lang.Apply(tmp21, []any{v3, tmp23})
									if lang.IsTruthy(tmp24) {
										tmp25 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp26 := checkDerefVar(var_glojure_DOT_core_partition)
										tmp27 := checkDerefVar(var_glojure_DOT_core_nthrest)
										tmp28 := lang.Apply(tmp27, []any{v13, v4})
										tmp29 := lang.Apply(tmp26, []any{v3, v4, tmp28})
										tmp30 := lang.Apply(tmp25, []any{v19, tmp29})
										tmp20 = tmp30
									} else {
									}
									tmp14 = tmp20
								} // end let
								tmp12 = tmp14
							} // end let
							tmp11 = tmp12
						} else {
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp8 any
					{ // let
						// let binding "temp__0__auto__"
						tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp10 := lang.Apply(tmp9, []any{v6})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "s"
								var v14 any = v11
								_ = v14
								var tmp15 any
								{ // let
									// let binding "p"
									tmp16 := checkDerefVar(var_glojure_DOT_core_doall)
									tmp17 := checkDerefVar(var_glojure_DOT_core_take)
									tmp18 := lang.Apply(tmp17, []any{v3, v14})
									tmp19 := lang.Apply(tmp16, []any{tmp18})
									var v20 any = tmp19
									_ = v20
									var tmp21 any
									tmp22 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp23 := checkDerefVar(var_glojure_DOT_core_count)
									tmp24 := lang.Apply(tmp23, []any{v20})
									tmp25 := lang.Apply(tmp22, []any{v3, tmp24})
									if lang.IsTruthy(tmp25) {
										tmp26 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp27 := checkDerefVar(var_glojure_DOT_core_partition)
										tmp28 := checkDerefVar(var_glojure_DOT_core_nthrest)
										tmp29 := lang.Apply(tmp28, []any{v14, v4})
										tmp30 := lang.Apply(tmp27, []any{v3, v4, v5, tmp29})
										tmp31 := lang.Apply(tmp26, []any{v20, tmp30})
										tmp21 = tmp31
									} else {
										tmp32 := checkDerefVar(var_glojure_DOT_core_list)
										tmp33 := checkDerefVar(var_glojure_DOT_core_take)
										tmp34 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp35 := lang.Apply(tmp34, []any{v20, v5})
										tmp36 := lang.Apply(tmp33, []any{v3, tmp35})
										tmp37 := lang.Apply(tmp32, []any{tmp36})
										tmp21 = tmp37
									}
									tmp15 = tmp21
								} // end let
								tmp13 = tmp15
							} // end let
							tmp12 = tmp13
						} else {
						}
						tmp8 = tmp12
					} // end let
					return tmp8
				})
				tmp8 := lang.Apply(lang.NewLazySeq, []any{tmp7})
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition-all
	{
		tmp0 := sym_partition_DASH_all.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n), lang.NewVector(sym_n, sym_coll), lang.NewVector(sym_n, sym_step, sym_coll)), kw_doc, "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(7222), kw_end_DASH_line, int(7222))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "a"
						tmp7 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
						tmp8 := lang.Apply(tmp7, []any{v3})
						tmp9 := lang.Apply(lang.NewArrayList, []any{tmp8})
						var v10 any = tmp9
						_ = v10
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp12 := lang.Apply(v5, nil)
								return tmp12
							case 1:
								v12 := args[0]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "result"
									var tmp14 any
									tmp15, ok := lang.FieldOrMethod(v10, "isEmpty")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "isEmpty")))
									}
									var tmp16 any
									switch reflect.TypeOf(tmp15).Kind() {
									case reflect.Func:
										tmp16 = lang.Apply(tmp15, nil)
									default:
										tmp16 = tmp15
									}
									if lang.IsTruthy(tmp16) {
										tmp14 = v12
									} else {
										var tmp17 any
										{ // let
											// let binding "v"
											tmp18 := checkDerefVar(var_glojure_DOT_core_vec)
											tmp19, ok := lang.FieldOrMethod(v10, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "toArray")))
											}
											var tmp20 any
											switch reflect.TypeOf(tmp19).Kind() {
											case reflect.Func:
												tmp20 = lang.Apply(tmp19, nil)
											default:
												tmp20 = tmp19
											}
											tmp21 := lang.Apply(tmp18, []any{tmp20})
											var v22 any = tmp21
											_ = v22
											tmp23, ok := lang.FieldOrMethod(v10, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "clear")))
											}
											var tmp24 any
											switch reflect.TypeOf(tmp23).Kind() {
											case reflect.Func:
												tmp24 = lang.Apply(tmp23, nil)
											default:
												tmp24 = tmp23
											}
											_ = tmp24
											tmp25 := checkDerefVar(var_glojure_DOT_core_unreduced)
											tmp26 := lang.Apply(v5, []any{v12, v22})
											tmp27 := lang.Apply(tmp25, []any{tmp26})
											tmp17 = tmp27
										} // end let
										tmp14 = tmp17
									}
									var v18 any = tmp14
									_ = v18
									tmp19 := lang.Apply(v5, []any{v18})
									tmp13 = tmp19
								} // end let
								return tmp13
							case 2:
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								tmp14, _ := lang.FieldOrMethod(v10, "add")
								if reflect.TypeOf(tmp14).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
								}
								tmp15 := lang.Apply(tmp14, []any{v13})
								_ = tmp15
								var tmp16 any
								tmp17 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp18, ok := lang.FieldOrMethod(v10, "size")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "size")))
								}
								var tmp19 any
								switch reflect.TypeOf(tmp18).Kind() {
								case reflect.Func:
									tmp19 = lang.Apply(tmp18, nil)
								default:
									tmp19 = tmp18
								}
								tmp20 := lang.Apply(tmp17, []any{v3, tmp19})
								if lang.IsTruthy(tmp20) {
									var tmp21 any
									{ // let
										// let binding "v"
										tmp22 := checkDerefVar(var_glojure_DOT_core_vec)
										tmp23, ok := lang.FieldOrMethod(v10, "toArray")
										if !ok {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "toArray")))
										}
										var tmp24 any
										switch reflect.TypeOf(tmp23).Kind() {
										case reflect.Func:
											tmp24 = lang.Apply(tmp23, nil)
										default:
											tmp24 = tmp23
										}
										tmp25 := lang.Apply(tmp22, []any{tmp24})
										var v26 any = tmp25
										_ = v26
										tmp27, ok := lang.FieldOrMethod(v10, "clear")
										if !ok {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "clear")))
										}
										var tmp28 any
										switch reflect.TypeOf(tmp27).Kind() {
										case reflect.Func:
											tmp28 = lang.Apply(tmp27, nil)
										default:
											tmp28 = tmp27
										}
										_ = tmp28
										tmp29 := lang.Apply(v5, []any{v12, v26})
										tmp21 = tmp29
									} // end let
									tmp16 = tmp21
								} else {
									tmp16 = v12
								}
								return tmp16
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7231), kw_column, int(8), kw_end_DASH_line, int(7247), kw_end_DASH_column, int(23))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp13
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7229), kw_column, int(4), kw_end_DASH_line, int(7247), kw_end_DASH_column, int(25))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_partition_DASH_all)
				tmp6 := lang.Apply(tmp5, []any{v3, v3, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v5})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "s"
								var v13 any = v10
								_ = v13
								var tmp14 any
								{ // let
									// let binding "seg"
									tmp15 := checkDerefVar(var_glojure_DOT_core_doall)
									tmp16 := checkDerefVar(var_glojure_DOT_core_take)
									tmp17 := lang.Apply(tmp16, []any{v3, v13})
									tmp18 := lang.Apply(tmp15, []any{tmp17})
									var v19 any = tmp18
									_ = v19
									tmp20 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp21 := checkDerefVar(var_glojure_DOT_core_partition_DASH_all)
									tmp22 := checkDerefVar(var_glojure_DOT_core_nthrest)
									tmp23 := lang.Apply(tmp22, []any{v13, v4})
									tmp24 := lang.Apply(tmp21, []any{v3, v4, tmp23})
									tmp25 := lang.Apply(tmp20, []any{v19, tmp24})
									tmp14 = tmp25
								} // end let
								tmp12 = tmp14
							} // end let
							tmp11 = tmp12
						} else {
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition-by
	{
		tmp0 := sym_partition_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym_coll)), kw_doc, "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(7142), kw_end_DASH_line, int(7142))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "a"
						var v7 any = "unimplemented: new with non-constant class type"
						_ = v7
						// let binding "pv"
						tmp8 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp9 := lang.Apply(tmp8, []any{kw_glojure_DOT_core_SLASH_none})
						var v10 any = tmp9
						_ = v10
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp12 := lang.Apply(v5, nil)
								return tmp12
							case 1:
								v12 := args[0]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "result"
									var tmp14 any
									tmp15, ok := lang.FieldOrMethod(v7, "isEmpty")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "isEmpty")))
									}
									var tmp16 any
									switch reflect.TypeOf(tmp15).Kind() {
									case reflect.Func:
										tmp16 = lang.Apply(tmp15, nil)
									default:
										tmp16 = tmp15
									}
									if lang.IsTruthy(tmp16) {
										tmp14 = v12
									} else {
										var tmp17 any
										{ // let
											// let binding "v"
											tmp18 := checkDerefVar(var_glojure_DOT_core_vec)
											tmp19, ok := lang.FieldOrMethod(v7, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "toArray")))
											}
											var tmp20 any
											switch reflect.TypeOf(tmp19).Kind() {
											case reflect.Func:
												tmp20 = lang.Apply(tmp19, nil)
											default:
												tmp20 = tmp19
											}
											tmp21 := lang.Apply(tmp18, []any{tmp20})
											var v22 any = tmp21
											_ = v22
											tmp23, ok := lang.FieldOrMethod(v7, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "clear")))
											}
											var tmp24 any
											switch reflect.TypeOf(tmp23).Kind() {
											case reflect.Func:
												tmp24 = lang.Apply(tmp23, nil)
											default:
												tmp24 = tmp23
											}
											_ = tmp24
											tmp25 := checkDerefVar(var_glojure_DOT_core_unreduced)
											tmp26 := lang.Apply(v5, []any{v12, v22})
											tmp27 := lang.Apply(tmp25, []any{tmp26})
											tmp17 = tmp27
										} // end let
										tmp14 = tmp17
									}
									var v18 any = tmp14
									_ = v18
									tmp19 := lang.Apply(v5, []any{v18})
									tmp13 = tmp19
								} // end let
								return tmp13
							case 2:
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								var tmp14 any
								{ // let
									// let binding "pval"
									tmp15 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp16 := lang.Apply(tmp15, []any{v10})
									var v17 any = tmp16
									_ = v17
									// let binding "val"
									tmp18 := lang.Apply(v3, []any{v13})
									var v19 any = tmp18
									_ = v19
									tmp20 := checkDerefVar(var_glojure_DOT_core_vreset_BANG_)
									tmp21 := lang.Apply(tmp20, []any{v10, v19})
									_ = tmp21
									var tmp22 any
									var tmp23 any
									{ // let
										// let binding "or__0__auto__"
										tmp24 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
										tmp25 := lang.Apply(tmp24, []any{v17, kw_glojure_DOT_core_SLASH_none})
										var v26 any = tmp25
										_ = v26
										var tmp27 any
										if lang.IsTruthy(v26) {
											tmp27 = v26
										} else {
											tmp28 := checkDerefVar(var_glojure_DOT_core__EQ_)
											tmp29 := lang.Apply(tmp28, []any{v19, v17})
											tmp27 = tmp29
										}
										tmp23 = tmp27
									} // end let
									if lang.IsTruthy(tmp23) {
										tmp24, _ := lang.FieldOrMethod(v7, "add")
										if reflect.TypeOf(tmp24).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
										}
										tmp25 := lang.Apply(tmp24, []any{v13})
										_ = tmp25
										tmp22 = v12
									} else {
										var tmp26 any
										{ // let
											// let binding "v"
											tmp27 := checkDerefVar(var_glojure_DOT_core_vec)
											tmp28, ok := lang.FieldOrMethod(v7, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "toArray")))
											}
											var tmp29 any
											switch reflect.TypeOf(tmp28).Kind() {
											case reflect.Func:
												tmp29 = lang.Apply(tmp28, nil)
											default:
												tmp29 = tmp28
											}
											tmp30 := lang.Apply(tmp27, []any{tmp29})
											var v31 any = tmp30
											_ = v31
											tmp32, ok := lang.FieldOrMethod(v7, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "clear")))
											}
											var tmp33 any
											switch reflect.TypeOf(tmp32).Kind() {
											case reflect.Func:
												tmp33 = lang.Apply(tmp32, nil)
											default:
												tmp33 = tmp32
											}
											_ = tmp33
											var tmp34 any
											{ // let
												// let binding "ret"
												tmp35 := lang.Apply(v5, []any{v12, v31})
												var v36 any = tmp35
												_ = v36
												var tmp37 any
												tmp38 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
												tmp39 := lang.Apply(tmp38, []any{v36})
												if lang.IsTruthy(tmp39) {
												} else {
													tmp40, _ := lang.FieldOrMethod(v7, "add")
													if reflect.TypeOf(tmp40).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
													}
													tmp41 := lang.Apply(tmp40, []any{v13})
													tmp37 = tmp41
												}
												_ = tmp37
												tmp34 = v36
											} // end let
											tmp26 = tmp34
										} // end let
										tmp22 = tmp26
									}
									tmp14 = tmp22
								} // end let
								return tmp14
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7152), kw_column, int(7), kw_end_DASH_line, int(7176), kw_end_DASH_column, int(28))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp13
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7149), kw_column, int(3), kw_end_DASH_line, int(7176), kw_end_DASH_column, int(30))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								{ // let
									// let binding "fst"
									tmp14 := checkDerefVar(var_glojure_DOT_core_first)
									tmp15 := lang.Apply(tmp14, []any{v12})
									var v16 any = tmp15
									_ = v16
									// let binding "fv"
									tmp17 := lang.Apply(v3, []any{v16})
									var v18 any = tmp17
									_ = v18
									// let binding "run"
									tmp19 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp20 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
									var tmp21 lang.FnFunc
									tmp21 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v22 := args[0]
										_ = v22
										tmp23 := checkDerefVar(var_glojure_DOT_core__EQ_)
										tmp24 := lang.Apply(v3, []any{v22})
										tmp25 := lang.Apply(tmp23, []any{v18, tmp24})
										return tmp25
									})
									tmp22 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7182), kw_column, int(41), kw_end_DASH_line, int(7182), kw_end_DASH_column, int(53))
									tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp24 := checkDerefVar(var_glojure_DOT_core_next)
									tmp25 := lang.Apply(tmp24, []any{v12})
									tmp26 := lang.Apply(tmp20, []any{tmp23, tmp25})
									tmp27 := lang.Apply(tmp19, []any{v16, tmp26})
									var v28 any = tmp27
									_ = v28
									tmp29 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp30 := checkDerefVar(var_glojure_DOT_core_partition_DASH_by)
									var tmp31 lang.FnFunc
									tmp31 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 0)
										tmp32 := checkDerefVar(var_glojure_DOT_core_drop)
										tmp33 := checkDerefVar(var_glojure_DOT_core_count)
										tmp34 := lang.Apply(tmp33, []any{v28})
										tmp35 := lang.Apply(tmp32, []any{tmp34, v12})
										return tmp35
									})
									tmp32 := lang.Apply(lang.NewLazySeq, []any{tmp31})
									tmp33 := lang.Apply(tmp30, []any{v3, tmp32})
									tmp34 := lang.Apply(tmp29, []any{v28, tmp33})
									tmp13 = tmp34
								} // end let
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partitionv
	{
		tmp0 := sym_partitionv.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll), lang.NewVector(sym_n, sym_step, sym_coll), lang.NewVector(sym_n, sym_step, sym_pad, sym_coll)), kw_doc, "Returns a lazy sequence of vectors of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7262), kw_end_DASH_line, int(7262))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_partitionv)
				tmp6 := lang.Apply(tmp5, []any{v3, v3, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v5})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "s"
								var v13 any = v10
								_ = v13
								var tmp14 any
								{ // let
									// let binding "p"
									tmp15 := checkDerefVar(var_glojure_DOT_core_into)
									tmp16 := lang.NewVector()
									tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7274), kw_column, int(22), kw_end_DASH_line, int(7274), kw_end_DASH_column, int(23))
									tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp19 := checkDerefVar(var_glojure_DOT_core_take)
									tmp20 := lang.Apply(tmp19, []any{v3})
									tmp21 := lang.Apply(tmp15, []any{tmp18, tmp20, v13})
									var v22 any = tmp21
									_ = v22
									var tmp23 any
									tmp24 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp25 := checkDerefVar(var_glojure_DOT_core_count)
									tmp26 := lang.Apply(tmp25, []any{v22})
									tmp27 := lang.Apply(tmp24, []any{v3, tmp26})
									if lang.IsTruthy(tmp27) {
										tmp28 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp29 := checkDerefVar(var_glojure_DOT_core_partitionv)
										tmp30 := checkDerefVar(var_glojure_DOT_core_nthrest)
										tmp31 := lang.Apply(tmp30, []any{v13, v4})
										tmp32 := lang.Apply(tmp29, []any{v3, v4, tmp31})
										tmp33 := lang.Apply(tmp28, []any{v22, tmp32})
										tmp23 = tmp33
									} else {
									}
									tmp14 = tmp23
								} // end let
								tmp12 = tmp14
							} // end let
							tmp11 = tmp12
						} else {
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp8 any
					{ // let
						// let binding "temp__0__auto__"
						tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp10 := lang.Apply(tmp9, []any{v6})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "s"
								var v14 any = v11
								_ = v14
								var tmp15 any
								{ // let
									// let binding "p"
									tmp16 := checkDerefVar(var_glojure_DOT_core_into)
									tmp17 := lang.NewVector()
									tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7280), kw_column, int(22), kw_end_DASH_line, int(7280), kw_end_DASH_column, int(23))
									tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp20 := checkDerefVar(var_glojure_DOT_core_take)
									tmp21 := lang.Apply(tmp20, []any{v3})
									tmp22 := lang.Apply(tmp16, []any{tmp19, tmp21, v14})
									var v23 any = tmp22
									_ = v23
									var tmp24 any
									tmp25 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp26 := checkDerefVar(var_glojure_DOT_core_count)
									tmp27 := lang.Apply(tmp26, []any{v23})
									tmp28 := lang.Apply(tmp25, []any{v3, tmp27})
									if lang.IsTruthy(tmp28) {
										tmp29 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp30 := checkDerefVar(var_glojure_DOT_core_partitionv)
										tmp31 := checkDerefVar(var_glojure_DOT_core_nthrest)
										tmp32 := lang.Apply(tmp31, []any{v14, v4})
										tmp33 := lang.Apply(tmp30, []any{v3, v4, v5, tmp32})
										tmp34 := lang.Apply(tmp29, []any{v23, tmp33})
										tmp24 = tmp34
									} else {
										tmp35 := checkDerefVar(var_glojure_DOT_core_list)
										tmp36 := checkDerefVar(var_glojure_DOT_core_into)
										tmp37 := lang.NewVector()
										tmp38 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7283), kw_column, int(24), kw_end_DASH_line, int(7283), kw_end_DASH_column, int(25))
										tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp40 := checkDerefVar(var_glojure_DOT_core_take)
										tmp41 := lang.Apply(tmp40, []any{v3})
										tmp42 := checkDerefVar(var_glojure_DOT_core_concat)
										tmp43 := lang.Apply(tmp42, []any{v23, v5})
										tmp44 := lang.Apply(tmp36, []any{tmp39, tmp41, tmp43})
										tmp45 := lang.Apply(tmp35, []any{tmp44})
										tmp24 = tmp45
									}
									tmp15 = tmp24
								} // end let
								tmp13 = tmp15
							} // end let
							tmp12 = tmp13
						} else {
						}
						tmp8 = tmp12
					} // end let
					return tmp8
				})
				tmp8 := lang.Apply(lang.NewLazySeq, []any{tmp7})
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partitionv-all
	{
		tmp0 := sym_partitionv_DASH_all.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n), lang.NewVector(sym_n, sym_coll), lang.NewVector(sym_n, sym_step, sym_coll)), kw_doc, "Returns a lazy sequence of vector partitions, but may include\n  partitions with fewer than n items at the end.\n  Returns a stateful transducer when no collection is provided.", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(7285), kw_end_DASH_line, int(7285))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_partition_DASH_all)
				tmp5 := lang.Apply(tmp4, []any{v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_partitionv_DASH_all)
				tmp6 := lang.Apply(tmp5, []any{v3, v3, v4})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v5})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "s"
								var v13 any = v10
								_ = v13
								var tmp14 any
								{ // let
									// let binding "seg"
									tmp15 := checkDerefVar(var_glojure_DOT_core_into)
									tmp16 := lang.NewVector()
									tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7297), kw_column, int(24), kw_end_DASH_line, int(7297), kw_end_DASH_column, int(25))
									tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp19 := checkDerefVar(var_glojure_DOT_core_take)
									tmp20 := lang.Apply(tmp19, []any{v3})
									tmp21 := lang.Apply(tmp15, []any{tmp18, tmp20, v5})
									var v22 any = tmp21
									_ = v22
									tmp23 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp24 := checkDerefVar(var_glojure_DOT_core_partitionv_DASH_all)
									tmp25 := checkDerefVar(var_glojure_DOT_core_drop)
									tmp26 := lang.Apply(tmp25, []any{v4, v13})
									tmp27 := lang.Apply(tmp24, []any{v3, v4, tmp26})
									tmp28 := lang.Apply(tmp23, []any{v22, tmp27})
									tmp14 = tmp28
								} // end let
								tmp12 = tmp14
							} // end let
							tmp11 = tmp12
						} else {
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pcalls
	{
		tmp0 := sym_pcalls.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_fns)), kw_doc, "Executes the no-arg fns in parallel, returning a lazy sequence of\n  their values", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(7056), kw_end_DASH_line, int(7056))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_pmap)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v6 := args[0]
					_ = v6
					tmp7 := lang.Apply(v6, nil)
					return tmp7
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7061), kw_column, int(17), kw_end_DASH_line, int(7061), kw_end_DASH_column, int(20))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7, v3})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// peek
	{
		tmp0 := sym_peek.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1455), kw_end_DASH_line, int(1455))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "Peek")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Peek is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// persistent!
	{
		tmp0 := sym_persistent_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(3350), kw_end_DASH_line, int(3350))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "Persistent")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Persistent")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pmap
	{
		tmp0 := sym_pmap.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_coll, sym__AMP_, sym_colls)), kw_doc, "Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(7031), kw_end_DASH_line, int(7031))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "n"
					tmp6 := checkDerefVar(var_glojure_DOT_core__PLUS_)
					tmp7 := lang.Apply(runtime14.NumCPU, nil)
					tmp8 := lang.Apply(tmp6, []any{int64(2), tmp7})
					var v9 any = tmp8
					_ = v9
					// let binding "rets"
					tmp10 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp11 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v12 := args[0]
						_ = v12
						tmp13 := checkDerefVar(var_glojure_DOT_core_future_DASH_call)
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							tmp15 := lang.Apply(v3, []any{v12})
							return tmp15
						})
						tmp15 := lang.Apply(tmp13, []any{tmp14})
						return tmp15
					})
					tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7041), kw_column, int(20), kw_end_DASH_line, int(7041), kw_end_DASH_column, int(34))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp14 := lang.Apply(tmp10, []any{tmp13, v4})
					var v15 any = tmp14
					_ = v15
					// let binding "step"
					var tmp16 lang.FnFunc
					{ // function step
						var v17 lang.FnFunc
						tmp16 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v18 := args[0]
							_ = v18
							v19 := args[1]
							_ = v19
							var tmp20 any
							{ // let
								// let binding "vec__335"
								var v21 any = v18
								_ = v21
								// let binding "seq__336"
								tmp22 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp23 := lang.Apply(tmp22, []any{v21})
								var v24 any = tmp23
								_ = v24
								// let binding "first__337"
								tmp25 := checkDerefVar(var_glojure_DOT_core_first)
								tmp26 := lang.Apply(tmp25, []any{v24})
								var v27 any = tmp26
								_ = v27
								// let binding "seq__336"
								tmp28 := checkDerefVar(var_glojure_DOT_core_next)
								tmp29 := lang.Apply(tmp28, []any{v24})
								var v30 any = tmp29
								_ = v30
								// let binding "x"
								var v31 any = v27
								_ = v31
								// let binding "xs"
								var v32 any = v30
								_ = v32
								// let binding "vs"
								var v33 any = v21
								_ = v33
								var tmp34 lang.FnFunc
								tmp34 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 0)
									var tmp35 any
									{ // let
										// let binding "temp__0__auto__"
										tmp36 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp37 := lang.Apply(tmp36, []any{v19})
										var v38 any = tmp37
										_ = v38
										var tmp39 any
										if lang.IsTruthy(v38) {
											var tmp40 any
											{ // let
												// let binding "s"
												var v41 any = v38
												_ = v41
												tmp42 := checkDerefVar(var_glojure_DOT_core_cons)
												tmp43 := checkDerefVar(var_glojure_DOT_core_deref)
												tmp44 := lang.Apply(tmp43, []any{v31})
												tmp45 := checkDerefVar(var_glojure_DOT_core_rest)
												tmp46 := lang.Apply(tmp45, []any{v41})
												tmp47 := lang.Apply(v17, []any{v32, tmp46})
												tmp48 := lang.Apply(tmp42, []any{tmp44, tmp47})
												tmp40 = tmp48
											} // end let
											tmp39 = tmp40
										} else {
											tmp41 := checkDerefVar(var_glojure_DOT_core_map)
											tmp42 := checkDerefVar(var_glojure_DOT_core_deref)
											tmp43 := lang.Apply(tmp41, []any{tmp42, v33})
											tmp39 = tmp43
										}
										tmp35 = tmp39
									} // end let
									return tmp35
								})
								tmp35 := lang.Apply(lang.NewLazySeq, []any{tmp34})
								tmp20 = tmp35
							} // end let
							return tmp20
						})
						v17 = tmp16
						_ = v17
					}
					tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7042), kw_column, int(15), kw_end_DASH_line, int(7046), kw_end_DASH_column, int(36))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v19 any = tmp18
					_ = v19
					tmp20 := checkDerefVar(var_glojure_DOT_core_drop)
					tmp21 := lang.Apply(tmp20, []any{v9, v15})
					tmp22 := lang.Apply(v19, []any{v15, tmp21})
					tmp5 = tmp22
				} // end let
				return tmp5
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "step"
					var tmp7 lang.FnFunc
					{ // function step
						var v8 lang.FnFunc
						tmp7 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v9 := args[0]
							_ = v9
							var tmp10 lang.FnFunc
							tmp10 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								var tmp11 any
								{ // let
									// let binding "ss"
									tmp12 := checkDerefVar(var_glojure_DOT_core_map)
									tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp14 := lang.Apply(tmp12, []any{tmp13, v9})
									var v15 any = tmp14
									_ = v15
									var tmp16 any
									tmp17 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
									tmp18 := checkDerefVar(var_glojure_DOT_core_identity)
									tmp19 := lang.Apply(tmp17, []any{tmp18, v15})
									if lang.IsTruthy(tmp19) {
										tmp20 := checkDerefVar(var_glojure_DOT_core_cons)
										tmp21 := checkDerefVar(var_glojure_DOT_core_map)
										tmp22 := checkDerefVar(var_glojure_DOT_core_first)
										tmp23 := lang.Apply(tmp21, []any{tmp22, v15})
										tmp24 := checkDerefVar(var_glojure_DOT_core_map)
										tmp25 := checkDerefVar(var_glojure_DOT_core_rest)
										tmp26 := lang.Apply(tmp24, []any{tmp25, v15})
										tmp27 := lang.Apply(v8, []any{tmp26})
										tmp28 := lang.Apply(tmp20, []any{tmp23, tmp27})
										tmp16 = tmp28
									} else {
									}
									tmp11 = tmp16
								} // end let
								return tmp11
							})
							tmp11 := lang.Apply(lang.NewLazySeq, []any{tmp10})
							return tmp11
						})
						v8 = tmp7
						_ = v8
					}
					tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7049), kw_column, int(15), kw_end_DASH_line, int(7053), kw_end_DASH_column, int(67))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v10 any = tmp9
					_ = v10
					tmp11 := checkDerefVar(var_glojure_DOT_core_pmap)
					var tmp12 lang.FnFunc
					tmp12 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v13 := args[0]
						_ = v13
						tmp14 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp15 := lang.Apply(tmp14, []any{v3, v13})
						return tmp15
					})
					tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7054), kw_column, int(12), kw_end_DASH_line, int(7054), kw_end_DASH_column, int(23))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp16 := lang.Apply(tmp15, []any{v4, v5})
					tmp17 := lang.Apply(v10, []any{tmp16})
					tmp18 := lang.Apply(tmp11, []any{tmp14, tmp17})
					tmp6 = tmp18
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop
	{
		tmp0 := sym_pop.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item. If\n  the collection is empty, throws an exception.  Note - not the same\n  as next/butlast.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1462), kw_end_DASH_line, int(1462))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "Pop")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Pop is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop!
	{
		tmp0 := sym_pop_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3393), kw_end_DASH_line, int(3393))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "pop")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "pop")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop-thread-bindings
	{
		tmp0 := sym_pop_DASH_thread_DASH_bindings.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Pop one set of bindings pushed with push-binding before. It is an error to\n  pop bindings without pushing before.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(1929), kw_end_DASH_line, int(1929))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := lang.Apply(lang.PopThreadBindings, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pos-int?
	{
		tmp0 := sym_pos_DASH_int_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a positive fixed precision integer", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(1403), kw_end_DASH_line, int(1403))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp8 = tmp10
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pos?
	{
		var tmp1 lang.FnFunc
		{ // function pos?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_IsPos})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_pos_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_inline, tmp1, kw_doc, "Returns true if num is greater than zero, else false", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1252), kw_end_DASH_line, int(1252))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IsPos")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IsPos is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pr
	{
		tmp0 := sym_pr.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_more)), kw_doc, "Prints the object(s) to the output stream that is the current value\n  of *out*.  Prints the object(s), separated by spaces if there is\n  more than one.  By default, pr and prn print in a way that objects\n  can be read by the reader", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(7), kw_line, int(3678), kw_end_DASH_line, int(3678), kw_dynamic, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return nil
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
				tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_out_STAR_)
				tmp6 := lang.Apply(tmp4, []any{v3, tmp5})
				return tmp6
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
			recur_loop_671:
				tmp5 := checkDerefVar(var_glojure_DOT_core_pr)
				tmp6 := lang.Apply(tmp5, []any{v3})
				_ = tmp6
				tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_out_STAR_)
				tmp8 := lang.Apply(lang.AppendWriter, []any{tmp7, lang.NewChar(32)})
				_ = tmp8
				var tmp9 any
				{ // let
					// let binding "temp__0__auto__"
					tmp10 := checkDerefVar(var_glojure_DOT_core_next)
					tmp11 := lang.Apply(tmp10, []any{v4})
					var v12 any = tmp11
					_ = v12
					var tmp13 any
					if lang.IsTruthy(v12) {
						var tmp14 any
						{ // let
							// let binding "nmore"
							var v15 any = v12
							_ = v15
							tmp17 := checkDerefVar(var_glojure_DOT_core_first)
							tmp18 := lang.Apply(tmp17, []any{v4})
							var tmp16 any = tmp18
							var tmp19 any = v15
							v3 = tmp16
							v4 = tmp19
							goto recur_loop_671
						} // end let
						tmp13 = tmp14
					} else {
						tmp15 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp16 := checkDerefVar(var_glojure_DOT_core_pr)
						tmp17 := lang.Apply(tmp15, []any{tmp16, v4})
						tmp13 = tmp17
					}
					tmp9 = tmp13
				} // end let
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pr-on
	{
		tmp0 := sym_pr_DASH_on.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_w)), kw_static, true, kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3669), kw_end_DASH_line, int(3669), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core_print_DASH_dup)
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				tmp5 = tmp8
			} else {
				tmp9 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp5 = tmp10
			}
			_ = tmp5
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pr-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_pr_DASH_str.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_doc, "pr to a string, returning it", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4758), kw_end_DASH_line, int(4758))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp9 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp10 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_out_STAR_)
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp17 := checkDerefVar(var_glojure_DOT_core_pr)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v4})
							_ = tmp18
							tmp19 := checkDerefVar(var_glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prefer-method
	{
		tmp0 := sym_prefer_DASH_method.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn, sym_dispatch_DASH_val_DASH_x, sym_dispatch_DASH_val_DASH_y)), kw_doc, "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \n   when there is a conflict", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1801), kw_end_DASH_line, int(1801))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(v3, "PreferMethod")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("PreferMethod is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prefers
	{
		tmp0 := sym_prefers.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn)), kw_doc, "Given a multimethod, returns a map of preferred value -> set of other values", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(1822), kw_end_DASH_line, int(1822))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getPreferTable")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getPreferTable")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prep-hashes
	{
		tmp0 := sym_prep_DASH_hashes.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_expr_DASH_sym, sym_default, sym_tests, sym_thens)), kw_doc, "Takes a sequence of test constants and a corresponding sequence of then\n  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]\n  where case-map is a map of int case values to [test then] tuples, switch-type\n  is either :sparse or :compact, and skip-check is a set of case ints for which\n  post-switch equivalence checking must not be done (occurs with hash\n  collisions).", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(8), kw_line, int(6683), kw_end_DASH_line, int(6683), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			var tmp7 any
			{ // let
				// let binding "hashcode"
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v9 := args[0]
					_ = v9
					tmp10 := lang.Apply(lang.Hash, []any{v9})
					return tmp10
				})
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6691), kw_column, int(18), kw_end_DASH_line, int(6691), kw_end_DASH_column, int(66))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v11 any = tmp10
				_ = v11
				// let binding "hashes"
				tmp12 := checkDerefVar(var_glojure_DOT_core_into1)
				tmp13 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6692), kw_column, int(23), kw_end_DASH_line, int(6692), kw_end_DASH_column, int(25))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp16 := checkDerefVar(var_glojure_DOT_core_map)
				tmp17 := lang.Apply(tmp16, []any{v11, v5})
				tmp18 := lang.Apply(tmp12, []any{tmp15, tmp17})
				var v19 any = tmp18
				_ = v19
				var tmp20 any
				tmp21 := checkDerefVar(var_glojure_DOT_core__EQ__EQ_)
				tmp22 := checkDerefVar(var_glojure_DOT_core_count)
				tmp23 := lang.Apply(tmp22, []any{v5})
				tmp24 := checkDerefVar(var_glojure_DOT_core_count)
				tmp25 := lang.Apply(tmp24, []any{v19})
				tmp26 := lang.Apply(tmp21, []any{tmp23, tmp25})
				if lang.IsTruthy(tmp26) {
					var tmp27 any
					tmp28 := checkDerefVar(var_glojure_DOT_core_fits_DASH_table_QMARK_)
					tmp29 := lang.Apply(tmp28, []any{v19})
					if lang.IsTruthy(tmp29) {
						tmp30 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
						tmp31 := checkDerefVar(var_glojure_DOT_core_identity)
						tmp32 := lang.Apply(tmp30, []any{v11, tmp31, v5, v6})
						tmp33 := lang.NewVector(int64(0), int64(0), tmp32, kw_compact)
						tmp34 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6696), kw_column, int(9), kw_end_DASH_line, int(6696), kw_end_DASH_column, int(63))
						tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp27 = tmp35
					} else {
						var tmp36 any
						{ // let
							// let binding "vec__167"
							var tmp37 any
							{ // let
								// let binding "or__0__auto__"
								tmp38 := checkDerefVar(var_glojure_DOT_core_maybe_DASH_min_DASH_hash)
								tmp39 := lang.Apply(tmp38, []any{v19})
								var v40 any = tmp39
								_ = v40
								var tmp41 any
								if lang.IsTruthy(v40) {
									tmp41 = v40
								} else {
									tmp42 := lang.NewVector(int64(0), int64(0))
									tmp43 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6697), kw_column, int(56), kw_end_DASH_line, int(6697), kw_end_DASH_column, int(60))
									tmp44, err := lang.WithMeta(tmp42, tmp43.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp41 = tmp44
								}
								tmp37 = tmp41
							} // end let
							var v38 any = tmp37
							_ = v38
							// let binding "shift"
							tmp39 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp40 := lang.Apply(tmp39, []any{v38, int64(0), nil})
							var v41 any = tmp40
							_ = v41
							// let binding "mask"
							tmp42 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp43 := lang.Apply(tmp42, []any{v38, int64(1), nil})
							var v44 any = tmp43
							_ = v44
							var tmp45 any
							tmp46 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
							tmp47 := lang.Apply(tmp46, []any{v44})
							if lang.IsTruthy(tmp47) {
								tmp48 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
								tmp49 := checkDerefVar(var_glojure_DOT_core_identity)
								tmp50 := lang.Apply(tmp48, []any{v11, tmp49, v5, v6})
								tmp51 := lang.NewVector(int64(0), int64(0), tmp50, kw_sparse)
								tmp52 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6700), kw_column, int(13), kw_end_DASH_line, int(6700), kw_end_DASH_column, int(66))
								tmp53, err := lang.WithMeta(tmp51, tmp52.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp45 = tmp53
							} else {
								tmp54 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
								var tmp55 lang.FnFunc
								tmp55 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v56 := args[0]
									_ = v56
									tmp57 := checkDerefVar(var_glojure_DOT_core_shift_DASH_mask)
									tmp58 := lang.Apply(v11, []any{v56})
									tmp59 := lang.Apply(tmp57, []any{v41, v44, tmp58})
									return tmp59
								})
								tmp56 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6702), kw_column, int(35), kw_end_DASH_line, int(6702), kw_end_DASH_column, int(71))
								tmp57, err := lang.WithMeta(tmp55, tmp56.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp58 := checkDerefVar(var_glojure_DOT_core_identity)
								tmp59 := lang.Apply(tmp54, []any{tmp57, tmp58, v5, v6})
								tmp60 := lang.NewVector(v41, v44, tmp59, kw_compact)
								tmp61 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6702), kw_column, int(13), kw_end_DASH_line, int(6702), kw_end_DASH_column, int(103))
								tmp62, err := lang.WithMeta(tmp60, tmp61.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp45 = tmp62
							}
							tmp36 = tmp45
						} // end let
						tmp27 = tmp36
					}
					tmp20 = tmp27
				} else {
					var tmp37 any
					{ // let
						// let binding "vec__170"
						tmp38 := checkDerefVar(var_glojure_DOT_core_merge_DASH_hash_DASH_collisions)
						tmp39 := lang.Apply(tmp38, []any{v3, v4, v5, v6})
						var v40 any = tmp39
						_ = v40
						// let binding "tests"
						tmp41 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp42 := lang.Apply(tmp41, []any{v40, int64(0), nil})
						var v43 any = tmp42
						_ = v43
						// let binding "thens"
						tmp44 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp45 := lang.Apply(tmp44, []any{v40, int64(1), nil})
						var v46 any = tmp45
						_ = v46
						// let binding "skip-check"
						tmp47 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp48 := lang.Apply(tmp47, []any{v40, int64(2), nil})
						var v49 any = tmp48
						_ = v49
						// let binding "vec__173"
						tmp50 := checkDerefVar(var_glojure_DOT_core_prep_DASH_hashes)
						tmp51 := lang.Apply(tmp50, []any{v3, v4, v43, v46})
						var v52 any = tmp51
						_ = v52
						// let binding "shift"
						tmp53 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp54 := lang.Apply(tmp53, []any{v52, int64(0), nil})
						var v55 any = tmp54
						_ = v55
						// let binding "mask"
						tmp56 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp57 := lang.Apply(tmp56, []any{v52, int64(1), nil})
						var v58 any = tmp57
						_ = v58
						// let binding "case-map"
						tmp59 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp60 := lang.Apply(tmp59, []any{v52, int64(2), nil})
						var v61 any = tmp60
						_ = v61
						// let binding "switch-type"
						tmp62 := checkDerefVar(var_glojure_DOT_core_nth)
						tmp63 := lang.Apply(tmp62, []any{v52, int64(3), nil})
						var v64 any = tmp63
						_ = v64
						// let binding "skip-check"
						var tmp65 any
						tmp66 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
						tmp67 := lang.Apply(tmp66, []any{v58})
						if lang.IsTruthy(tmp67) {
							tmp65 = v49
						} else {
							tmp68 := checkDerefVar(var_glojure_DOT_core_into1)
							tmp69 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp70 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6708), kw_column, int(33), kw_end_DASH_line, int(6708), kw_end_DASH_column, int(35))
							tmp71, err := lang.WithMeta(tmp69, tmp70.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp72 := checkDerefVar(var_glojure_DOT_core_map)
							var tmp73 lang.FnFunc
							tmp73 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 1)
								v74 := args[0]
								_ = v74
								tmp75 := checkDerefVar(var_glojure_DOT_core_shift_DASH_mask)
								tmp76 := lang.Apply(tmp75, []any{v55, v58, v74})
								return tmp76
							})
							tmp74 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6708), kw_column, int(42), kw_end_DASH_line, int(6708), kw_end_DASH_column, int(67))
							tmp75, err := lang.WithMeta(tmp73, tmp74.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp76 := lang.Apply(tmp72, []any{tmp75, v49})
							tmp77 := lang.Apply(tmp68, []any{tmp71, tmp76})
							tmp65 = tmp77
						}
						var v78 any = tmp65
						_ = v78
						tmp79 := lang.NewVector(v55, v58, v61, v64, v78)
						tmp80 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6709), kw_column, int(9), kw_end_DASH_line, int(6709), kw_end_DASH_column, int(52))
						tmp81, err := lang.WithMeta(tmp79, tmp80.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp37 = tmp81
					} // end let
					tmp20 = tmp37
				}
				tmp7 = tmp20
			} // end let
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prep-ints
	{
		tmp0 := sym_prep_DASH_ints.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tests, sym_thens)), kw_doc, "Takes a sequence of int-sized test constants and a corresponding sequence of\n  then expressions. Returns a tuple of [shift mask case-map switch-type] where\n  case-map is a map of int case values to [test then] tuples, and switch-type\n  is either :sparse or :compact.", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(8), kw_line, int(6631), kw_end_DASH_line, int(6631), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_fits_DASH_table_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v3})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
				tmp9 := checkDerefVar(var_glojure_DOT_core_int)
				tmp10 := checkDerefVar(var_glojure_DOT_core_int)
				tmp11 := lang.Apply(tmp8, []any{tmp9, tmp10, v3, v4})
				tmp12 := lang.NewVector(int64(0), int64(0), tmp11, kw_compact)
				tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6639), kw_column, int(5), kw_end_DASH_line, int(6639), kw_end_DASH_column, int(49))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp5 = tmp14
			} else {
				var tmp15 any
				{ // let
					// let binding "vec__160"
					var tmp16 any
					{ // let
						// let binding "or__0__auto__"
						tmp17 := checkDerefVar(var_glojure_DOT_core_maybe_DASH_min_DASH_hash)
						tmp18 := checkDerefVar(var_glojure_DOT_core_map)
						tmp19 := checkDerefVar(var_glojure_DOT_core_int)
						tmp20 := lang.Apply(tmp18, []any{tmp19, v3})
						tmp21 := lang.Apply(tmp17, []any{tmp20})
						var v22 any = tmp21
						_ = v22
						var tmp23 any
						if lang.IsTruthy(v22) {
							tmp23 = v22
						} else {
							tmp24 := lang.NewVector(int64(0), int64(0))
							tmp25 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6640), kw_column, int(61), kw_end_DASH_line, int(6640), kw_end_DASH_column, int(65))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp23 = tmp26
						}
						tmp16 = tmp23
					} // end let
					var v17 any = tmp16
					_ = v17
					// let binding "shift"
					tmp18 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp19 := lang.Apply(tmp18, []any{v17, int64(0), nil})
					var v20 any = tmp19
					_ = v20
					// let binding "mask"
					tmp21 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp22 := lang.Apply(tmp21, []any{v17, int64(1), nil})
					var v23 any = tmp22
					_ = v23
					var tmp24 any
					tmp25 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
					tmp26 := lang.Apply(tmp25, []any{v23})
					if lang.IsTruthy(tmp26) {
						tmp27 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
						tmp28 := checkDerefVar(var_glojure_DOT_core_int)
						tmp29 := checkDerefVar(var_glojure_DOT_core_int)
						tmp30 := lang.Apply(tmp27, []any{tmp28, tmp29, v3, v4})
						tmp31 := lang.NewVector(int64(0), int64(0), tmp30, kw_sparse)
						tmp32 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6643), kw_column, int(9), kw_end_DASH_line, int(6643), kw_end_DASH_column, int(52))
						tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp24 = tmp33
					} else {
						tmp34 := checkDerefVar(var_glojure_DOT_core_case_DASH_map)
						var tmp35 lang.FnFunc
						tmp35 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v36 := args[0]
							_ = v36
							tmp37 := checkDerefVar(var_glojure_DOT_core_shift_DASH_mask)
							tmp38 := checkDerefVar(var_glojure_DOT_core_int)
							tmp39 := lang.Apply(tmp38, []any{v36})
							tmp40 := lang.Apply(tmp37, []any{v20, v23, tmp39})
							return tmp40
						})
						tmp36 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6645), kw_column, int(31), kw_end_DASH_line, int(6645), kw_end_DASH_column, int(62))
						tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp38 := checkDerefVar(var_glojure_DOT_core_int)
						tmp39 := lang.Apply(tmp34, []any{tmp37, tmp38, v3, v4})
						tmp40 := lang.NewVector(v20, v23, tmp39, kw_compact)
						tmp41 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6645), kw_column, int(9), kw_end_DASH_line, int(6645), kw_end_DASH_column, int(89))
						tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp24 = tmp42
					}
					tmp15 = tmp24
				} // end let
				tmp5 = tmp15
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prependss
	{
		tmp0 := sym_prependss.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_coll)), kw_doc, "Prepends a symbol or a seq to coll", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(8), kw_line, int(5857), kw_end_DASH_line, int(5857), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v3})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{v3, v4})
				tmp5 = tmp9
			} else {
				tmp10 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp11 := lang.Apply(tmp10, []any{v3, v4})
				tmp5 = tmp11
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// preserving-reduced
	{
		tmp0 := sym_preserving_DASH_reduced.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(7638), kw_column, int(7), kw_end_DASH_line, int(7638), kw_end_DASH_column, int(34), kw_arglists, lang.NewList(lang.NewVector(sym_rf)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ret"
					tmp8 := lang.Apply(v3, []any{v5, v6})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
					tmp12 := lang.Apply(tmp11, []any{v9})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(var_glojure_DOT_core_reduced)
						tmp14 := lang.Apply(tmp13, []any{v9})
						tmp10 = tmp14
					} else {
						tmp10 = v9
					}
					tmp7 = tmp10
				} // end let
				return tmp7
			})
			tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7640), kw_column, int(3), kw_end_DASH_line, int(7643), kw_end_DASH_column, int(12))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print
	{
		tmp0 := sym_print.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_more)), kw_doc, "Prints the object(s) to the output stream that is the current value\n  of *out*.  print and println produce output for human consumption.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3725), kw_end_DASH_line, int(3725))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					tmp5 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
					tmp6 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp7 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_readably_STAR_)
					tmp8 := lang.Apply(tmp6, []any{tmp7, nil})
					tmp9 := lang.Apply(tmp5, []any{tmp8})
					_ = tmp9
					var tmp10 any
					func() {
						defer func() {
							tmp11 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
							tmp12 := lang.Apply(tmp11, nil)
							_ = tmp12
						}()
						tmp13 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp14 := checkDerefVar(var_glojure_DOT_core_pr)
						tmp15 := lang.Apply(tmp13, []any{tmp14, v3})
						tmp10 = tmp15
					}()
					tmp4 = tmp10
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-ctor
	{
		tmp0 := sym_print_DASH_ctor.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(95), kw_column, int(7), kw_end_DASH_line, int(95), kw_end_DASH_column, int(16), kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_print_DASH_args, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := lang.Apply(lang.WriteWriter, []any{v5, "#=("})
			_ = tmp6
			tmp7 := checkDerefVar(var_glojure_DOT_core_class)
			tmp8 := lang.Apply(tmp7, []any{v3})
			tmp9, ok := lang.FieldOrMethod(tmp8, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp8, "Name")))
			}
			var tmp10 any
			switch reflect.TypeOf(tmp9).Kind() {
			case reflect.Func:
				tmp10 = lang.Apply(tmp9, nil)
			default:
				tmp10 = tmp9
			}
			tmp11 := lang.Apply(lang.WriteWriter, []any{v5, tmp10})
			_ = tmp11
			tmp12 := lang.Apply(lang.WriteWriter, []any{v5, ". "})
			_ = tmp12
			tmp13 := lang.Apply(v4, []any{v3, v5})
			_ = tmp13
			tmp14 := lang.Apply(lang.WriteWriter, []any{v5, ")"})
			return tmp14
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-dup
	{
		tmp0 := sym_print_DASH_dup.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3667), kw_column, int(11), kw_end_DASH_line, int(3667), kw_end_DASH_column, int(19), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := checkDerefVar(var_glojure_DOT_core_class)
			tmp7 := lang.Apply(tmp6, []any{v4})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3667), kw_column, int(21), kw_end_DASH_line, int(3667), kw_end_DASH_column, int(45))).(lang.FnFunc)
		tmp2 := lang.NewMultiFn("print-dup", tmp3, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v5 := args[0]
			_ = v5
			v6 := args[1]
			_ = v6
			tmp7 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp8 := lang.Apply(tmp7, []any{v5, v6})
			return tmp8
		})
		tmp2.AddMethod(nil, tmp4)
		tmp5 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v7 := args[0]
			_ = v7
			v8 := args[1]
			_ = v8
			tmp9 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp10 := lang.Apply(tmp9, []any{v7, v8})
			return tmp10
		})
		tmp2.AddMethod(tmp5, tmp6)
		tmp7 := reflect.TypeOf((*lang.IPersistentList)(nil)).Elem()
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v9 := args[0]
			_ = v9
			v10 := args[1]
			_ = v10
			tmp11 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp12 := lang.Apply(tmp11, []any{v9, v10})
			return tmp12
		})
		tmp2.AddMethod(tmp7, tmp8)
		tmp9 := reflect.TypeOf((*lang.Symbol)(nil))
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v11 := args[0]
			_ = v11
			v12 := args[1]
			_ = v12
			tmp13 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp14 := lang.Apply(tmp13, []any{v11, v12})
			return tmp14
		})
		tmp2.AddMethod(tmp9, tmp10)
		tmp11 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		var tmp12 lang.FnFunc
		tmp12 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v13 := args[0]
			_ = v13
			v14 := args[1]
			_ = v14
			tmp15 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp16 := lang.Apply(tmp15, []any{v13, v14})
			_ = tmp16
			tmp17 := lang.Apply(lang.WriteWriter, []any{v14, "#"})
			_ = tmp17
			tmp18 := checkDerefVar(var_glojure_DOT_core_class)
			tmp19 := lang.Apply(tmp18, []any{v13})
			tmp20, ok := lang.FieldOrMethod(tmp19, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp19, "Name")))
			}
			var tmp21 any
			switch reflect.TypeOf(tmp20).Kind() {
			case reflect.Func:
				tmp21 = lang.Apply(tmp20, nil)
			default:
				tmp21 = tmp20
			}
			tmp22 := lang.Apply(lang.WriteWriter, []any{v14, tmp21})
			_ = tmp22
			var tmp23 any
			tmp24 := checkDerefVar(var_glojure_DOT_core__STAR_verbose_DASH_defrecords_STAR_)
			if lang.IsTruthy(tmp24) {
				tmp25 := checkDerefVar(var_glojure_DOT_core_print_DASH_map)
				tmp26 := checkDerefVar(var_glojure_DOT_core_print_DASH_dup)
				tmp27 := lang.Apply(tmp25, []any{v13, tmp26, v14})
				tmp23 = tmp27
			} else {
				tmp28 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
				tmp29 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
				tmp30 := checkDerefVar(var_glojure_DOT_core_vals)
				tmp31 := lang.Apply(tmp30, []any{v13})
				tmp32 := lang.Apply(tmp28, []any{"[", tmp29, ", ", "]", tmp31, v14})
				tmp23 = tmp32
			}
			return tmp23
		})
		tmp2.AddMethod(tmp11, tmp12)
		tmp13 := reflect.TypeOf((*lang.Set)(nil))
		var tmp14 lang.FnFunc
		tmp14 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v15 := args[0]
			_ = v15
			v16 := args[1]
			_ = v16
			tmp17 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp18 := lang.Apply(tmp17, []any{v15, v16})
			return tmp18
		})
		tmp2.AddMethod(tmp13, tmp14)
		tmp15 := reflect.TypeOf((*lang.PersistentHashMap)(nil))
		var tmp16 lang.FnFunc
		tmp16 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v17 := args[0]
			_ = v17
			v18 := args[1]
			_ = v18
			tmp19 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp20 := lang.Apply(tmp19, []any{v17, v18})
			return tmp20
		})
		tmp2.AddMethod(tmp15, tmp16)
		tmp17 := reflect.TypeOf(int64(0))
		var tmp18 lang.FnFunc
		tmp18 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v19 := args[0]
			_ = v19
			v20 := args[1]
			_ = v20
			tmp21 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp22 := lang.Apply(tmp21, []any{v19, v20})
			return tmp22
		})
		tmp2.AddMethod(tmp17, tmp18)
		tmp19 := reflect.TypeOf((*lang.Vector)(nil))
		var tmp20 lang.FnFunc
		tmp20 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v21 := args[0]
			_ = v21
			v22 := args[1]
			_ = v22
			tmp23 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp24 := lang.Apply(tmp23, []any{v21, v22})
			return tmp24
		})
		tmp2.AddMethod(tmp19, tmp20)
		tmp21 := reflect.TypeOf(float64(0))
		var tmp22 lang.FnFunc
		tmp22 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v23 := args[0]
			_ = v23
			v24 := args[1]
			_ = v24
			tmp25 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp26 := lang.Apply(tmp25, []any{v23, v24})
			return tmp26
		})
		tmp2.AddMethod(tmp21, tmp22)
		tmp23 := reflect.TypeOf("")
		var tmp24 lang.FnFunc
		tmp24 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v25 := args[0]
			_ = v25
			v26 := args[1]
			_ = v26
			tmp27 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp28 := lang.Apply(tmp27, []any{v25, v26})
			return tmp28
		})
		tmp2.AddMethod(tmp23, tmp24)
		tmp25 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		var tmp26 lang.FnFunc
		tmp26 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v27 := args[0]
			_ = v27
			v28 := args[1]
			_ = v28
			tmp29 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp30 := lang.Apply(tmp29, []any{v27, v28})
			_ = tmp30
			tmp31 := lang.Apply(lang.WriteWriter, []any{v28, "#=("})
			_ = tmp31
			tmp32 := checkDerefVar(var_glojure_DOT_core_class)
			tmp33 := lang.Apply(tmp32, []any{v27})
			tmp34, ok := lang.FieldOrMethod(tmp33, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp33, "Name")))
			}
			var tmp35 any
			switch reflect.TypeOf(tmp34).Kind() {
			case reflect.Func:
				tmp35 = lang.Apply(tmp34, nil)
			default:
				tmp35 = tmp34
			}
			tmp36 := lang.Apply(lang.WriteWriter, []any{v28, tmp35})
			_ = tmp36
			tmp37 := lang.Apply(lang.WriteWriter, []any{v28, "/create "})
			_ = tmp37
			tmp38 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
			tmp39 := checkDerefVar(var_glojure_DOT_core_print_DASH_dup)
			tmp40 := lang.Apply(tmp38, []any{"[", tmp39, " ", "]", v27, v28})
			_ = tmp40
			tmp41 := lang.Apply(lang.WriteWriter, []any{v28, ")"})
			return tmp41
		})
		tmp2.AddMethod(tmp25, tmp26)
		tmp27 := reflect.TypeOf(int32(0))
		var tmp28 lang.FnFunc
		tmp28 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v29 := args[0]
			_ = v29
			v30 := args[1]
			_ = v30
			tmp31 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp32 := lang.Apply(tmp31, []any{v29, v30})
			return tmp32
		})
		tmp2.AddMethod(tmp27, tmp28)
		tmp29 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		var tmp30 lang.FnFunc
		tmp30 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v31 := args[0]
			_ = v31
			v32 := args[1]
			_ = v32
			tmp33 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp34 := lang.Apply(tmp33, []any{v31, v32})
			_ = tmp34
			tmp35 := lang.Apply(lang.WriteWriter, []any{v32, "#=("})
			_ = tmp35
			tmp36 := checkDerefVar(var_glojure_DOT_core_class)
			tmp37 := lang.Apply(tmp36, []any{v31})
			tmp38, ok := lang.FieldOrMethod(tmp37, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp37, "Name")))
			}
			var tmp39 any
			switch reflect.TypeOf(tmp38).Kind() {
			case reflect.Func:
				tmp39 = lang.Apply(tmp38, nil)
			default:
				tmp39 = tmp38
			}
			tmp40 := lang.Apply(lang.WriteWriter, []any{v32, tmp39})
			_ = tmp40
			tmp41 := lang.Apply(lang.WriteWriter, []any{v32, "/create "})
			_ = tmp41
			tmp42 := checkDerefVar(var_glojure_DOT_core_print_DASH_map)
			tmp43 := checkDerefVar(var_glojure_DOT_core_print_DASH_dup)
			tmp44 := lang.Apply(tmp42, []any{v31, tmp43, v32})
			_ = tmp44
			tmp45 := lang.Apply(lang.WriteWriter, []any{v32, ")"})
			return tmp45
		})
		tmp2.AddMethod(tmp29, tmp30)
		tmp31 := reflect.TypeOf((*lang.Namespace)(nil))
		var tmp32 lang.FnFunc
		tmp32 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v33 := args[0]
			_ = v33
			v34 := args[1]
			_ = v34
			tmp35 := lang.Apply(lang.WriteWriter, []any{v34, "#=(find-ns "})
			_ = tmp35
			tmp36 := checkDerefVar(var_glojure_DOT_core_print_DASH_dup)
			tmp37, ok := lang.FieldOrMethod(v33, "name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v33, "name")))
			}
			var tmp38 any
			switch reflect.TypeOf(tmp37).Kind() {
			case reflect.Func:
				tmp38 = lang.Apply(tmp37, nil)
			default:
				tmp38 = tmp37
			}
			tmp39 := lang.Apply(tmp36, []any{tmp38, v34})
			_ = tmp39
			tmp40 := lang.Apply(lang.WriteWriter, []any{v34, ")"})
			return tmp40
		})
		tmp2.AddMethod(tmp31, tmp32)
		tmp33 := reflect.TypeOf(false)
		var tmp34 lang.FnFunc
		tmp34 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v35 := args[0]
			_ = v35
			v36 := args[1]
			_ = v36
			tmp37 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp38 := lang.Apply(tmp37, []any{v35, v36})
			return tmp38
		})
		tmp2.AddMethod(tmp33, tmp34)
		tmp35 := reflect.TypeOf((*regexp15.Regexp)(nil))
		var tmp36 lang.FnFunc
		tmp36 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v37 := args[0]
			_ = v37
			v38 := args[1]
			_ = v38
			tmp39 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp40 := lang.Apply(tmp39, []any{v37, v38})
			return tmp40
		})
		tmp2.AddMethod(tmp35, tmp36)
		tmp37 := reflect.TypeOf((*lang.Ratio)(nil))
		var tmp38 lang.FnFunc
		tmp38 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v39 := args[0]
			_ = v39
			v40 := args[1]
			_ = v40
			tmp41 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp42 := lang.Apply(tmp41, []any{v39, v40})
			return tmp42
		})
		tmp2.AddMethod(tmp37, tmp38)
		tmp39 := reflect.TypeOf((*lang.Var)(nil))
		var tmp40 lang.FnFunc
		tmp40 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v41 := args[0]
			_ = v41
			v42 := args[1]
			_ = v42
			tmp43 := checkDerefVar(var_glojure_DOT_core_str)
			tmp44, ok := lang.FieldOrMethod(v41, "Namespace")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v41, "Namespace")))
			}
			var tmp45 any
			switch reflect.TypeOf(tmp44).Kind() {
			case reflect.Func:
				tmp45 = lang.Apply(tmp44, nil)
			default:
				tmp45 = tmp44
			}
			tmp46, ok := lang.FieldOrMethod(tmp45, "name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp45, "name")))
			}
			var tmp47 any
			switch reflect.TypeOf(tmp46).Kind() {
			case reflect.Func:
				tmp47 = lang.Apply(tmp46, nil)
			default:
				tmp47 = tmp46
			}
			tmp48, ok := lang.FieldOrMethod(v41, "sym")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v41, "sym")))
			}
			var tmp49 any
			switch reflect.TypeOf(tmp48).Kind() {
			case reflect.Func:
				tmp49 = lang.Apply(tmp48, nil)
			default:
				tmp49 = tmp48
			}
			tmp50 := lang.Apply(tmp43, []any{"#=(var ", tmp47, "/", tmp49, ")"})
			tmp51 := lang.Apply(lang.WriteWriter, []any{v42, tmp50})
			return tmp51
		})
		tmp2.AddMethod(tmp39, tmp40)
		tmp41 := reflect.TypeOf((*lang.BigDecimal)(nil))
		var tmp42 lang.FnFunc
		tmp42 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v43 := args[0]
			_ = v43
			v44 := args[1]
			_ = v44
			tmp45 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp46 := lang.Apply(tmp45, []any{v43, v44})
			return tmp46
		})
		tmp2.AddMethod(tmp41, tmp42)
		tmp43 := reflect.TypeOf((*lang.BigInt)(nil))
		var tmp44 lang.FnFunc
		tmp44 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v45 := args[0]
			_ = v45
			v46 := args[1]
			_ = v46
			tmp47 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp48 := lang.Apply(tmp47, []any{v45, v46})
			return tmp48
		})
		tmp2.AddMethod(tmp43, tmp44)
		tmp45 := reflect.TypeOf((*runtime.Fn)(nil))
		var tmp46 lang.FnFunc
		tmp46 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v47 := args[0]
			_ = v47
			v48 := args[1]
			_ = v48
			tmp49 := checkDerefVar(var_glojure_DOT_core_print_DASH_ctor)
			var tmp50 lang.FnFunc
			tmp50 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v51 := args[0]
				_ = v51
				v52 := args[1]
				_ = v52
				return nil
			})
			tmp51 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(167), kw_column, int(17), kw_end_DASH_line, int(167), kw_end_DASH_column, int(26))
			tmp52, err := lang.WithMeta(tmp50, tmp51.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp53 := lang.Apply(tmp49, []any{v47, tmp52, v48})
			return tmp53
		})
		tmp2.AddMethod(tmp45, tmp46)
		tmp47 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		var tmp48 lang.FnFunc
		tmp48 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v49 := args[0]
			_ = v49
			v50 := args[1]
			_ = v50
			tmp51 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp52 := lang.Apply(tmp51, []any{v49, v50})
			return tmp52
		})
		tmp2.AddMethod(tmp47, tmp48)
		tmp49 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp50 := reflect.TypeOf((*runtime.Fn)(nil))
		tmp2.PreferMethod(tmp49, tmp50)
		tmp51 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp52 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp2.PreferMethod(tmp51, tmp52)
		tmp53 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		tmp54 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		tmp2.PreferMethod(tmp53, tmp54)
		tmp55 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		tmp56 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp2.PreferMethod(tmp55, tmp56)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-initialized
	{
		tmp0 := sym_print_DASH_initialized.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core_print.glj", kw_line, int(520), kw_column, int(6), kw_end_DASH_line, int(520), kw_end_DASH_column, int(39), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, true, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-map
	{
		tmp0 := sym_print_DASH_map.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(252), kw_column, int(8), kw_end_DASH_line, int(252), kw_end_DASH_column, int(16), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_print_DASH_one, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := checkDerefVar(var_glojure_DOT_core_print_DASH_prefix_DASH_map)
			tmp7 := lang.Apply(tmp6, []any{nil, v3, v4, v5})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-meta
	{
		tmp0 := sym_print_DASH_meta.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(70), kw_column, int(8), kw_end_DASH_line, int(70), kw_end_DASH_column, int(17), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "temp__0__auto__"
				tmp6 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp7 := lang.Apply(tmp6, []any{v3})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "m"
						var v11 any = v8
						_ = v11
						var tmp12 any
						var tmp13 any
						{ // let
							// let binding "and__0__auto__"
							tmp14 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
							tmp15 := checkDerefVar(var_glojure_DOT_core_count)
							tmp16 := lang.Apply(tmp15, []any{v11})
							tmp17 := lang.Apply(tmp14, []any{tmp16})
							var v18 any = tmp17
							_ = v18
							var tmp19 any
							if lang.IsTruthy(v18) {
								var tmp20 any
								{ // let
									// let binding "or__0__auto__"
									tmp21 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
									var v22 any = tmp21
									_ = v22
									var tmp23 any
									if lang.IsTruthy(v22) {
										tmp23 = v22
									} else {
										var tmp24 any
										{ // let
											// let binding "and__0__auto__"
											tmp25 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_meta_STAR_)
											var v26 any = tmp25
											_ = v26
											var tmp27 any
											if lang.IsTruthy(v26) {
												tmp28 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_readably_STAR_)
												tmp27 = tmp28
											} else {
												tmp27 = v26
											}
											tmp24 = tmp27
										} // end let
										tmp23 = tmp24
									}
									tmp20 = tmp23
								} // end let
								tmp19 = tmp20
							} else {
								tmp19 = v18
							}
							tmp13 = tmp19
						} // end let
						if lang.IsTruthy(tmp13) {
							tmp14 := lang.Apply(lang.WriteWriter, []any{v4, "^"})
							_ = tmp14
							var tmp15 any
							var tmp16 any
							{ // let
								// let binding "and__0__auto__"
								tmp17 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp18 := checkDerefVar(var_glojure_DOT_core_count)
								tmp19 := lang.Apply(tmp18, []any{v11})
								tmp20 := lang.Apply(tmp17, []any{tmp19, int64(1)})
								var v21 any = tmp20
								_ = v21
								var tmp22 any
								if lang.IsTruthy(v21) {
									tmp23 := lang.Apply(kw_tag, []any{v11})
									tmp22 = tmp23
								} else {
									tmp22 = v21
								}
								tmp16 = tmp22
							} // end let
							if lang.IsTruthy(tmp16) {
								tmp17 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
								tmp18 := lang.Apply(kw_tag, []any{v11})
								tmp19 := lang.Apply(tmp17, []any{tmp18, v4})
								tmp15 = tmp19
							} else {
								tmp20 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
								tmp21 := lang.Apply(tmp20, []any{v11, v4})
								tmp15 = tmp21
							}
							_ = tmp15
							tmp22 := lang.Apply(lang.WriteWriter, []any{v4, " "})
							tmp12 = tmp22
						} else {
						}
						tmp10 = tmp12
					} // end let
					tmp9 = tmp10
				} else {
				}
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-method
	{
		tmp0 := sym_print_DASH_method.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3664), kw_column, int(11), kw_end_DASH_line, int(3664), kw_end_DASH_column, int(22), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "t"
				tmp7 := checkDerefVar(var_glojure_DOT_core_get)
				tmp8 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp9 := lang.Apply(tmp8, []any{v4})
				tmp10 := lang.Apply(tmp7, []any{tmp9, kw_type})
				var v11 any = tmp10
				_ = v11
				var tmp12 any
				tmp13 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp14 := lang.Apply(tmp13, []any{v11})
				if lang.IsTruthy(tmp14) {
					tmp12 = v11
				} else {
					tmp15 := checkDerefVar(var_glojure_DOT_core_class)
					tmp16 := lang.Apply(tmp15, []any{v4})
					tmp12 = tmp16
				}
				tmp6 = tmp12
			} // end let
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3664), kw_column, int(24), kw_end_DASH_line, int(3666), kw_end_DASH_column, int(58))).(lang.FnFunc)
		tmp2 := lang.NewMultiFn("print-method", tmp3, kw_default, lang.FindOrCreateNamespace(sym_glojure_DOT_core).FindInternedVar(sym_global_DASH_hierarchy))
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v5 := args[0]
			_ = v5
			v6 := args[1]
			_ = v6
			tmp7 := lang.Apply(lang.WriteWriter, []any{v6, "nil"})
			return tmp7
		})
		tmp2.AddMethod(nil, tmp4)
		tmp5 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		var tmp6 lang.FnFunc
		tmp6 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v7 := args[0]
			_ = v7
			v8 := args[1]
			_ = v8
			tmp9 := checkDerefVar(var_glojure_DOT_core_str)
			tmp10 := lang.Apply(tmp9, []any{v7})
			tmp11 := lang.Apply(lang.WriteWriter, []any{v8, tmp10})
			return tmp11
		})
		tmp2.AddMethod(tmp5, tmp6)
		tmp7 := reflect.TypeOf(uint32(0))
		var tmp8 lang.FnFunc
		tmp8 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v9 := args[0]
			_ = v9
			v10 := args[1]
			_ = v10
			tmp11 := checkDerefVar(var_glojure_DOT_core_str)
			tmp12 := lang.Apply(tmp11, []any{v9})
			tmp13, _ := lang.FieldOrMethod(v10, "write")
			if reflect.TypeOf(tmp13).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp14 := lang.Apply(tmp13, []any{tmp12})
			return tmp14
		})
		tmp2.AddMethod(tmp7, tmp8)
		tmp9 := reflect.TypeOf((*lang.Symbol)(nil))
		var tmp10 lang.FnFunc
		tmp10 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v11 := args[0]
			_ = v11
			v12 := args[1]
			_ = v12
			tmp13 := checkDerefVar(var_glojure_DOT_core_print_DASH_simple)
			tmp14 := lang.Apply(tmp13, []any{v11, v12})
			return tmp14
		})
		tmp2.AddMethod(tmp9, tmp10)
		tmp11 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		var tmp12 lang.FnFunc
		tmp12 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v13 := args[0]
			_ = v13
			v14 := args[1]
			_ = v14
			tmp15 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp16 := lang.Apply(tmp15, []any{v13, v14})
			_ = tmp16
			tmp17 := lang.Apply(lang.WriteWriter, []any{v14, "#"})
			_ = tmp17
			tmp18 := checkDerefVar(var_glojure_DOT_core_class)
			tmp19 := lang.Apply(tmp18, []any{v13})
			tmp20, ok := lang.FieldOrMethod(tmp19, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp19, "Name")))
			}
			var tmp21 any
			switch reflect.TypeOf(tmp20).Kind() {
			case reflect.Func:
				tmp21 = lang.Apply(tmp20, nil)
			default:
				tmp21 = tmp20
			}
			tmp22 := lang.Apply(lang.WriteWriter, []any{v14, tmp21})
			_ = tmp22
			tmp23 := checkDerefVar(var_glojure_DOT_core_print_DASH_map)
			tmp24 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
			tmp25 := lang.Apply(tmp23, []any{v13, tmp24, v14})
			return tmp25
		})
		tmp2.AddMethod(tmp11, tmp12)
		tmp13 := reflect.TypeOf(uint(0))
		var tmp14 lang.FnFunc
		tmp14 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v15 := args[0]
			_ = v15
			v16 := args[1]
			_ = v16
			tmp17 := checkDerefVar(var_glojure_DOT_core_str)
			tmp18 := lang.Apply(tmp17, []any{v15})
			tmp19, _ := lang.FieldOrMethod(v16, "write")
			if reflect.TypeOf(tmp19).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp20 := lang.Apply(tmp19, []any{tmp18})
			return tmp20
		})
		tmp2.AddMethod(tmp13, tmp14)
		tmp15 := reflect.TypeOf(int64(0))
		var tmp16 lang.FnFunc
		tmp16 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v17 := args[0]
			_ = v17
			v18 := args[1]
			_ = v18
			tmp19 := checkDerefVar(var_glojure_DOT_core_str)
			tmp20 := lang.Apply(tmp19, []any{v17})
			tmp21, _ := lang.FieldOrMethod(v18, "write")
			if reflect.TypeOf(tmp21).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp22 := lang.Apply(tmp21, []any{tmp20})
			return tmp22
		})
		tmp2.AddMethod(tmp15, tmp16)
		var tmp17 lang.FnFunc
		tmp17 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v18 := args[0]
			_ = v18
			v19 := args[1]
			_ = v19
			var tmp20 any
			tmp21 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp22 := reflect.TypeOf((*lang.IObj)(nil)).Elem()
			tmp23 := lang.Apply(tmp21, []any{tmp22, v18})
			if lang.IsTruthy(tmp23) {
				tmp24 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
				tmp25 := checkDerefVar(var_glojure_DOT_core_vary_DASH_meta)
				var tmp26 lang.FnFunc
				tmp26 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v27 := args[0]
					_ = v27
					tmp28 := checkDerefVar(var_glojure_DOT_core_dissoc)
					tmp29 := lang.Apply(tmp28, []any{v27, kw_type})
					return tmp29
				})
				tmp27 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(87), kw_column, int(32), kw_end_DASH_line, int(87), kw_end_DASH_column, int(48))
				tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp29 := lang.Apply(tmp25, []any{v18, tmp28})
				tmp30 := lang.Apply(tmp24, []any{tmp29, v19})
				tmp20 = tmp30
			} else {
				tmp31 := checkDerefVar(var_glojure_DOT_core_print_DASH_simple)
				tmp32 := lang.Apply(tmp31, []any{v18, v19})
				tmp20 = tmp32
			}
			return tmp20
		})
		tmp2.AddMethod(kw_default, tmp17)
		tmp18 := reflect.TypeOf(float64(0))
		var tmp19 lang.FnFunc
		tmp19 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v20 := args[0]
			_ = v20
			v21 := args[1]
			_ = v21
			var tmp22 any
			tmp23 := checkDerefVar(var_glojure_DOT_core__EQ_)
			tmp24 := lang.Apply(math7.Inf, []any{int64(1)})
			tmp25 := lang.Apply(tmp23, []any{tmp24, v20})
			if lang.IsTruthy(tmp25) {
				tmp26 := lang.Apply(lang.WriteWriter, []any{v21, "##Inf"})
				tmp22 = tmp26
			} else {
				var tmp27 any
				tmp28 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp29 := lang.Apply(math7.Inf, []any{int64(-1)})
				tmp30 := lang.Apply(tmp28, []any{tmp29, v20})
				if lang.IsTruthy(tmp30) {
					tmp31 := lang.Apply(lang.WriteWriter, []any{v21, "##-Inf"})
					tmp27 = tmp31
				} else {
					var tmp32 any
					tmp33 := lang.Apply(math7.IsNaN, []any{v20})
					if lang.IsTruthy(tmp33) {
						tmp34 := lang.Apply(lang.WriteWriter, []any{v21, "##NaN"})
						tmp32 = tmp34
					} else {
						var tmp35 any
						if lang.IsTruthy(kw_else) {
							tmp36 := checkDerefVar(var_glojure_DOT_core_str)
							tmp37 := lang.Apply(tmp36, []any{v20})
							tmp38 := lang.Apply(lang.WriteWriter, []any{v21, tmp37})
							tmp35 = tmp38
						} else {
						}
						tmp32 = tmp35
					}
					tmp27 = tmp32
				}
				tmp22 = tmp27
			}
			return tmp22
		})
		tmp2.AddMethod(tmp18, tmp19)
		tmp20 := reflect.TypeOf("")
		var tmp21 lang.FnFunc
		tmp21 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v22 := args[0]
			_ = v22
			v23 := args[1]
			_ = v23
			var tmp24 any
			var tmp25 any
			{ // let
				// let binding "or__0__auto__"
				tmp26 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
				var v27 any = tmp26
				_ = v27
				var tmp28 any
				if lang.IsTruthy(v27) {
					tmp28 = v27
				} else {
					tmp29 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_readably_STAR_)
					tmp28 = tmp29
				}
				tmp25 = tmp28
			} // end let
			if lang.IsTruthy(tmp25) {
				tmp26 := lang.Apply(lang.AppendWriter, []any{v23, lang.NewChar(34)})
				_ = tmp26
				var tmp27 any
				{ // let
					// let binding "n__0__auto__"
					tmp28 := checkDerefVar(var_glojure_DOT_core_long)
					tmp29 := checkDerefVar(var_glojure_DOT_core_count)
					tmp30 := lang.Apply(tmp29, []any{v22})
					tmp31 := lang.Apply(tmp28, []any{tmp30})
					var v32 any = tmp31
					_ = v32
					var tmp33 any
					{ // let
						// let binding "n"
						var v34 any = int64(0)
						_ = v34
						for {
							var tmp35 any
							tmp36 := checkDerefVar(var_glojure_DOT_core__LT_)
							tmp37 := lang.Apply(tmp36, []any{v34, v32})
							if lang.IsTruthy(tmp37) {
								var tmp38 any
								{ // let
									// let binding "c"
									tmp39 := lang.Apply(lang.CharAt, []any{v22, v34})
									var v40 any = tmp39
									_ = v40
									// let binding "e"
									tmp41 := checkDerefVar(var_glojure_DOT_core_char_DASH_escape_DASH_string)
									tmp42 := lang.Apply(tmp41, []any{v40})
									var v43 any = tmp42
									_ = v43
									var tmp44 any
									if lang.IsTruthy(v43) {
										tmp45 := lang.Apply(lang.WriteWriter, []any{v23, v43})
										tmp44 = tmp45
									} else {
										tmp46 := lang.Apply(lang.AppendWriter, []any{v23, v40})
										tmp44 = tmp46
									}
									tmp38 = tmp44
								} // end let
								_ = tmp38
								tmp40 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
								tmp41 := lang.Apply(tmp40, []any{v34})
								var tmp39 any = tmp41
								v34 = tmp39
								continue
							} else {
							}
							tmp33 = tmp35
							break
						}
					} // end let
					tmp27 = tmp33
				} // end let
				_ = tmp27
				tmp28 := lang.Apply(lang.AppendWriter, []any{v23, lang.NewChar(34)})
				tmp24 = tmp28
			} else {
				tmp29 := lang.Apply(lang.WriteWriter, []any{v23, v22})
				tmp24 = tmp29
			}
			_ = tmp24
			return nil
		})
		tmp2.AddMethod(tmp20, tmp21)
		tmp22 := reflect.TypeOf(int32(0))
		var tmp23 lang.FnFunc
		tmp23 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v24 := args[0]
			_ = v24
			v25 := args[1]
			_ = v25
			var tmp26 any
			var tmp27 any
			{ // let
				// let binding "or__0__auto__"
				tmp28 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
				var v29 any = tmp28
				_ = v29
				var tmp30 any
				if lang.IsTruthy(v29) {
					tmp30 = v29
				} else {
					tmp31 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_readably_STAR_)
					tmp30 = tmp31
				}
				tmp27 = tmp30
			} // end let
			if lang.IsTruthy(tmp27) {
				tmp28 := lang.Apply(lang.AppendWriter, []any{v25, lang.NewChar(92)})
				_ = tmp28
				var tmp29 any
				{ // let
					// let binding "n"
					tmp30 := checkDerefVar(var_glojure_DOT_core_char_DASH_name_DASH_string)
					tmp31 := lang.Apply(tmp30, []any{v24})
					var v32 any = tmp31
					_ = v32
					var tmp33 any
					if lang.IsTruthy(v32) {
						tmp34 := lang.Apply(lang.WriteWriter, []any{v25, v32})
						tmp33 = tmp34
					} else {
						tmp35 := lang.Apply(lang.AppendWriter, []any{v25, v24})
						tmp33 = tmp35
					}
					tmp29 = tmp33
				} // end let
				tmp26 = tmp29
			} else {
				tmp30 := lang.Apply(lang.AppendWriter, []any{v25, v24})
				tmp26 = tmp30
			}
			_ = tmp26
			return nil
		})
		tmp2.AddMethod(tmp22, tmp23)
		tmp24 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		var tmp25 lang.FnFunc
		tmp25 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v26 := args[0]
			_ = v26
			v27 := args[1]
			_ = v27
			tmp28 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp29 := lang.Apply(tmp28, []any{v26, v27})
			_ = tmp29
			var tmp30 any
			{ // let
				// let binding "vec__234"
				tmp31 := checkDerefVar(var_glojure_DOT_core_lift_DASH_ns)
				tmp32 := lang.Apply(tmp31, []any{v26})
				var v33 any = tmp32
				_ = v33
				// let binding "ns"
				tmp34 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp35 := lang.Apply(tmp34, []any{v33, int64(0), nil})
				var v36 any = tmp35
				_ = v36
				// let binding "lift-kvs"
				tmp37 := checkDerefVar(var_glojure_DOT_core_nth)
				tmp38 := lang.Apply(tmp37, []any{v33, int64(1), nil})
				var v39 any = tmp38
				_ = v39
				var tmp40 any
				if lang.IsTruthy(v36) {
					tmp41 := checkDerefVar(var_glojure_DOT_core_print_DASH_prefix_DASH_map)
					tmp42 := checkDerefVar(var_glojure_DOT_core_str)
					tmp43 := lang.Apply(tmp42, []any{"#:", v36})
					tmp44 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
					tmp45 := lang.Apply(tmp41, []any{tmp43, v39, tmp44, v27})
					tmp40 = tmp45
				} else {
					tmp46 := checkDerefVar(var_glojure_DOT_core_print_DASH_map)
					tmp47 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
					tmp48 := lang.Apply(tmp46, []any{v26, tmp47, v27})
					tmp40 = tmp48
				}
				tmp30 = tmp40
			} // end let
			return tmp30
		})
		tmp2.AddMethod(tmp24, tmp25)
		tmp26 := reflect.TypeOf((*lang.IPersistentVector)(nil)).Elem()
		var tmp27 lang.FnFunc
		tmp27 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v28 := args[0]
			_ = v28
			v29 := args[1]
			_ = v29
			tmp30 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp31 := lang.Apply(tmp30, []any{v28, v29})
			_ = tmp31
			tmp32 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
			tmp33 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
			tmp34 := lang.Apply(tmp32, []any{"[", tmp33, " ", "]", v28, v29})
			return tmp34
		})
		tmp2.AddMethod(tmp26, tmp27)
		tmp28 := reflect.TypeOf((*lang.IPersistentSet)(nil)).Elem()
		var tmp29 lang.FnFunc
		tmp29 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v30 := args[0]
			_ = v30
			v31 := args[1]
			_ = v31
			tmp32 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp33 := lang.Apply(tmp32, []any{v30, v31})
			_ = tmp33
			tmp34 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
			tmp35 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
			tmp36 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp37 := lang.Apply(tmp36, []any{v30})
			tmp38 := lang.Apply(tmp34, []any{"#{", tmp35, " ", "}", tmp37, v31})
			return tmp38
		})
		tmp2.AddMethod(tmp28, tmp29)
		tmp30 := reflect.TypeOf(uint8(0))
		var tmp31 lang.FnFunc
		tmp31 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v32 := args[0]
			_ = v32
			v33 := args[1]
			_ = v33
			tmp34 := checkDerefVar(var_glojure_DOT_core_str)
			tmp35 := lang.Apply(tmp34, []any{v32})
			tmp36, _ := lang.FieldOrMethod(v33, "write")
			if reflect.TypeOf(tmp36).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp37 := lang.Apply(tmp36, []any{tmp35})
			return tmp37
		})
		tmp2.AddMethod(tmp30, tmp31)
		tmp32 := reflect.TypeOf((*lang.IDeref)(nil)).Elem()
		var tmp33 lang.FnFunc
		tmp33 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v34 := args[0]
			_ = v34
			v35 := args[1]
			_ = v35
			tmp36 := checkDerefVar(var_glojure_DOT_core_print_DASH_tagged_DASH_object)
			tmp37 := checkDerefVar(var_glojure_DOT_core_deref_DASH_as_DASH_map)
			tmp38 := lang.Apply(tmp37, []any{v34})
			tmp39 := lang.Apply(tmp36, []any{v34, tmp38, v35})
			return tmp39
		})
		tmp2.AddMethod(tmp32, tmp33)
		tmp34 := reflect.TypeOf(false)
		var tmp35 lang.FnFunc
		tmp35 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v36 := args[0]
			_ = v36
			v37 := args[1]
			_ = v37
			tmp38 := checkDerefVar(var_glojure_DOT_core_str)
			tmp39 := lang.Apply(tmp38, []any{v36})
			tmp40 := lang.Apply(lang.WriteWriter, []any{v37, tmp39})
			return tmp40
		})
		tmp2.AddMethod(tmp34, tmp35)
		tmp36 := reflect.TypeOf((*lang.Object)(nil)).Elem()
		var tmp37 lang.FnFunc
		tmp37 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v38 := args[0]
			_ = v38
			v39 := args[1]
			_ = v39
			tmp40 := checkDerefVar(var_glojure_DOT_core_print_DASH_object)
			tmp41 := lang.Apply(tmp40, []any{v38, v39})
			return tmp41
		})
		tmp2.AddMethod(tmp36, tmp37)
		tmp38 := reflect.TypeOf(int(0))
		var tmp39 lang.FnFunc
		tmp39 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v40 := args[0]
			_ = v40
			v41 := args[1]
			_ = v41
			tmp42 := checkDerefVar(var_glojure_DOT_core_str)
			tmp43 := lang.Apply(tmp42, []any{v40})
			tmp44, _ := lang.FieldOrMethod(v41, "write")
			if reflect.TypeOf(tmp44).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp45 := lang.Apply(tmp44, []any{tmp43})
			return tmp45
		})
		tmp2.AddMethod(tmp38, tmp39)
		tmp40 := reflect.TypeOf((*regexp15.Regexp)(nil))
		var tmp41 lang.FnFunc
		tmp41 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v42 := args[0]
			_ = v42
			v43 := args[1]
			_ = v43
			tmp44 := lang.Apply(lang.WriteWriter, []any{v43, "#\""})
			_ = tmp44
			var tmp45 any
			{ // let
				// let binding "G__240"
				tmp46 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp47, ok := lang.FieldOrMethod(v42, "String")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v42, "String")))
				}
				var tmp48 any
				switch reflect.TypeOf(tmp47).Kind() {
				case reflect.Func:
					tmp48 = lang.Apply(tmp47, nil)
				default:
					tmp48 = tmp47
				}
				tmp49 := lang.Apply(tmp46, []any{tmp48})
				var v50 any = tmp49
				_ = v50
				// let binding "vec__241"
				var v51 any = v50
				_ = v51
				// let binding "seq__242"
				tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp53 := lang.Apply(tmp52, []any{v51})
				var v54 any = tmp53
				_ = v54
				// let binding "first__243"
				tmp55 := checkDerefVar(var_glojure_DOT_core_first)
				tmp56 := lang.Apply(tmp55, []any{v54})
				var v57 any = tmp56
				_ = v57
				// let binding "seq__242"
				tmp58 := checkDerefVar(var_glojure_DOT_core_next)
				tmp59 := lang.Apply(tmp58, []any{v54})
				var v60 any = tmp59
				_ = v60
				// let binding "c"
				var v61 any = v57
				_ = v61
				// let binding "r"
				var v62 any = v60
				_ = v62
				// let binding "s"
				var v63 any = v51
				_ = v63
				// let binding "qmode"
				var v64 any = false
				_ = v64
				var tmp65 any
				{ // let
					// let binding "G__240"
					var v66 any = v50
					_ = v66
					// let binding "qmode"
					var v67 any = v64
					_ = v67
					for {
						var tmp68 any
						{ // let
							// let binding "vec__244"
							var v69 any = v66
							_ = v69
							// let binding "seq__245"
							tmp70 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp71 := lang.Apply(tmp70, []any{v69})
							var v72 any = tmp71
							_ = v72
							// let binding "first__246"
							tmp73 := checkDerefVar(var_glojure_DOT_core_first)
							tmp74 := lang.Apply(tmp73, []any{v72})
							var v75 any = tmp74
							_ = v75
							// let binding "seq__245"
							tmp76 := checkDerefVar(var_glojure_DOT_core_next)
							tmp77 := lang.Apply(tmp76, []any{v72})
							var v78 any = tmp77
							_ = v78
							// let binding "c"
							var v79 any = v75
							_ = v79
							// let binding "r"
							var v80 any = v78
							_ = v80
							// let binding "s"
							var v81 any = v69
							_ = v81
							// let binding "qmode"
							var v82 any = v67
							_ = v82
							var tmp83 any
							if lang.IsTruthy(v81) {
								var tmp84 any
								tmp85 := checkDerefVar(var_glojure_DOT_core__EQ_)
								tmp86 := lang.Apply(tmp85, []any{v79, lang.NewChar(92)})
								if lang.IsTruthy(tmp86) {
									var tmp87 any
									{ // let
										// let binding "vec__247"
										var v88 any = v80
										_ = v88
										// let binding "seq__248"
										tmp89 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp90 := lang.Apply(tmp89, []any{v88})
										var v91 any = tmp90
										_ = v91
										// let binding "first__249"
										tmp92 := checkDerefVar(var_glojure_DOT_core_first)
										tmp93 := lang.Apply(tmp92, []any{v91})
										var v94 any = tmp93
										_ = v94
										// let binding "seq__248"
										tmp95 := checkDerefVar(var_glojure_DOT_core_next)
										tmp96 := lang.Apply(tmp95, []any{v91})
										var v97 any = tmp96
										_ = v97
										// let binding "c2"
										var v98 any = v94
										_ = v98
										// let binding "r2"
										var v99 any = v97
										_ = v99
										tmp100 := lang.Apply(lang.AppendWriter, []any{v43, lang.NewChar(92)})
										_ = tmp100
										tmp101 := lang.Apply(lang.AppendWriter, []any{v43, v98})
										_ = tmp101
										var tmp102 any
										if lang.IsTruthy(v82) {
											var tmp103 any = v99
											tmp105 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
											tmp106 := lang.Apply(tmp105, []any{v98, lang.NewChar(69)})
											var tmp104 any = tmp106
											v66 = tmp103
											v67 = tmp104
											continue
										} else {
											var tmp107 any = v99
											tmp109 := checkDerefVar(var_glojure_DOT_core__EQ_)
											tmp110 := lang.Apply(tmp109, []any{v98, lang.NewChar(81)})
											var tmp108 any = tmp110
											v66 = tmp107
											v67 = tmp108
											continue
										}
										tmp87 = tmp102
									} // end let
									tmp84 = tmp87
								} else {
									var tmp88 any
									tmp89 := checkDerefVar(var_glojure_DOT_core__EQ_)
									tmp90 := lang.Apply(tmp89, []any{v79, lang.NewChar(34)})
									if lang.IsTruthy(tmp90) {
										var tmp91 any
										if lang.IsTruthy(v82) {
											tmp92 := lang.Apply(lang.WriteWriter, []any{v43, "\\E\\\"\\Q"})
											tmp91 = tmp92
										} else {
											tmp93 := lang.Apply(lang.WriteWriter, []any{v43, "\\\""})
											tmp91 = tmp93
										}
										_ = tmp91
										var tmp94 any = v80
										var tmp95 any = v82
										v66 = tmp94
										v67 = tmp95
										continue
									} else {
										var tmp96 any
										if lang.IsTruthy(kw_else) {
											tmp97 := lang.Apply(lang.AppendWriter, []any{v43, v79})
											_ = tmp97
											var tmp98 any = v80
											var tmp99 any = v82
											v66 = tmp98
											v67 = tmp99
											continue
										} else {
										}
										tmp88 = tmp96
									}
									tmp84 = tmp88
								}
								tmp83 = tmp84
							} else {
							}
							tmp68 = tmp83
						} // end let
						tmp65 = tmp68
						break
					}
				} // end let
				tmp45 = tmp65
			} // end let
			_ = tmp45
			tmp46 := lang.Apply(lang.AppendWriter, []any{v43, lang.NewChar(34)})
			return tmp46
		})
		tmp2.AddMethod(tmp40, tmp41)
		tmp42 := reflect.TypeOf(int32(0))
		var tmp43 lang.FnFunc
		tmp43 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v44 := args[0]
			_ = v44
			v45 := args[1]
			_ = v45
			tmp46 := checkDerefVar(var_glojure_DOT_core_str)
			tmp47 := lang.Apply(tmp46, []any{v44})
			tmp48, _ := lang.FieldOrMethod(v45, "write")
			if reflect.TypeOf(tmp48).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp49 := lang.Apply(tmp48, []any{tmp47})
			return tmp49
		})
		tmp2.AddMethod(tmp42, tmp43)
		tmp44 := reflect.TypeOf((*lang.Ratio)(nil))
		var tmp45 lang.FnFunc
		tmp45 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v46 := args[0]
			_ = v46
			v47 := args[1]
			_ = v47
			tmp48 := checkDerefVar(var_glojure_DOT_core_str)
			tmp49 := lang.Apply(tmp48, []any{v46})
			tmp50, _ := lang.FieldOrMethod(v47, "write")
			if reflect.TypeOf(tmp50).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp51 := lang.Apply(tmp50, []any{tmp49})
			return tmp51
		})
		tmp2.AddMethod(tmp44, tmp45)
		tmp46 := reflect.TypeOf(float32(0))
		var tmp47 lang.FnFunc
		tmp47 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v48 := args[0]
			_ = v48
			v49 := args[1]
			_ = v49
			var tmp50 any
			tmp51 := checkDerefVar(var_glojure_DOT_core__EQ_)
			tmp52 := lang.Apply(math7.Inf, []any{int64(1)})
			tmp53 := lang.Apply(lang.Builtins["float32"], []any{tmp52})
			tmp54 := lang.Apply(tmp51, []any{tmp53, v48})
			if lang.IsTruthy(tmp54) {
				tmp55 := lang.Apply(lang.WriteWriter, []any{v49, "##Inf"})
				tmp50 = tmp55
			} else {
				var tmp56 any
				tmp57 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp58 := lang.Apply(math7.Inf, []any{int64(-1)})
				tmp59 := lang.Apply(lang.Builtins["float32"], []any{tmp58})
				tmp60 := lang.Apply(tmp57, []any{tmp59, v48})
				if lang.IsTruthy(tmp60) {
					tmp61 := lang.Apply(lang.WriteWriter, []any{v49, "##-Inf"})
					tmp56 = tmp61
				} else {
					var tmp62 any
					tmp63 := lang.Apply(math7.IsNaN, []any{v48})
					if lang.IsTruthy(tmp63) {
						tmp64 := lang.Apply(lang.WriteWriter, []any{v49, "##NaN"})
						tmp62 = tmp64
					} else {
						var tmp65 any
						if lang.IsTruthy(kw_else) {
							tmp66 := checkDerefVar(var_glojure_DOT_core_str)
							tmp67 := lang.Apply(tmp66, []any{v48})
							tmp68 := lang.Apply(lang.WriteWriter, []any{v49, tmp67})
							tmp65 = tmp68
						} else {
						}
						tmp62 = tmp65
					}
					tmp56 = tmp62
				}
				tmp50 = tmp56
			}
			return tmp50
		})
		tmp2.AddMethod(tmp46, tmp47)
		tmp48 := reflect.TypeOf(int16(0))
		var tmp49 lang.FnFunc
		tmp49 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v50 := args[0]
			_ = v50
			v51 := args[1]
			_ = v51
			tmp52 := checkDerefVar(var_glojure_DOT_core_str)
			tmp53 := lang.Apply(tmp52, []any{v50})
			tmp54, _ := lang.FieldOrMethod(v51, "write")
			if reflect.TypeOf(tmp54).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp55 := lang.Apply(tmp54, []any{tmp53})
			return tmp55
		})
		tmp2.AddMethod(tmp48, tmp49)
		tmp50 := reflect.TypeOf((*lang.Var)(nil))
		var tmp51 lang.FnFunc
		tmp51 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v52 := args[0]
			_ = v52
			v53 := args[1]
			_ = v53
			tmp54 := checkDerefVar(var_glojure_DOT_core_print_DASH_simple)
			tmp55 := lang.Apply(tmp54, []any{v52, v53})
			return tmp55
		})
		tmp2.AddMethod(tmp50, tmp51)
		tmp52 := reflect.TypeOf(int8(0))
		var tmp53 lang.FnFunc
		tmp53 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v54 := args[0]
			_ = v54
			v55 := args[1]
			_ = v55
			tmp56 := checkDerefVar(var_glojure_DOT_core_str)
			tmp57 := lang.Apply(tmp56, []any{v54})
			tmp58, _ := lang.FieldOrMethod(v55, "write")
			if reflect.TypeOf(tmp58).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp59 := lang.Apply(tmp58, []any{tmp57})
			return tmp59
		})
		tmp2.AddMethod(tmp52, tmp53)
		tmp54 := reflect.TypeOf(uint16(0))
		var tmp55 lang.FnFunc
		tmp55 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v56 := args[0]
			_ = v56
			v57 := args[1]
			_ = v57
			tmp58 := checkDerefVar(var_glojure_DOT_core_str)
			tmp59 := lang.Apply(tmp58, []any{v56})
			tmp60, _ := lang.FieldOrMethod(v57, "write")
			if reflect.TypeOf(tmp60).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp61 := lang.Apply(tmp60, []any{tmp59})
			return tmp61
		})
		tmp2.AddMethod(tmp54, tmp55)
		tmp56 := reflect.TypeOf(uint64(0))
		var tmp57 lang.FnFunc
		tmp57 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v58 := args[0]
			_ = v58
			v59 := args[1]
			_ = v59
			tmp60 := checkDerefVar(var_glojure_DOT_core_str)
			tmp61 := lang.Apply(tmp60, []any{v58})
			tmp62, _ := lang.FieldOrMethod(v59, "write")
			if reflect.TypeOf(tmp62).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("write is not a function")))
			}
			tmp63 := lang.Apply(tmp62, []any{tmp61})
			return tmp63
		})
		tmp2.AddMethod(tmp56, tmp57)
		tmp58 := reflect.TypeOf((*lang.BigDecimal)(nil))
		var tmp59 lang.FnFunc
		tmp59 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v60 := args[0]
			_ = v60
			v61 := args[1]
			_ = v61
			tmp62 := checkDerefVar(var_glojure_DOT_core_str)
			tmp63 := lang.Apply(tmp62, []any{v60})
			tmp64 := lang.Apply(lang.WriteWriter, []any{v61, tmp63})
			_ = tmp64
			tmp65 := lang.Apply(lang.WriteWriter, []any{v61, "M"})
			return tmp65
		})
		tmp2.AddMethod(tmp58, tmp59)
		tmp60 := reflect.TypeOf((*lang.BigInt)(nil))
		var tmp61 lang.FnFunc
		tmp61 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v62 := args[0]
			_ = v62
			v63 := args[1]
			_ = v63
			tmp64 := checkDerefVar(var_glojure_DOT_core_str)
			tmp65 := lang.Apply(tmp64, []any{v62})
			tmp66 := lang.Apply(lang.WriteWriter, []any{v63, tmp65})
			_ = tmp66
			tmp67 := lang.Apply(lang.WriteWriter, []any{v63, "N"})
			return tmp67
		})
		tmp2.AddMethod(tmp60, tmp61)
		tmp62 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		var tmp63 lang.FnFunc
		tmp63 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v64 := args[0]
			_ = v64
			v65 := args[1]
			_ = v65
			tmp66 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp67 := lang.Apply(tmp66, []any{v64, v65})
			_ = tmp67
			tmp68 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
			tmp69 := checkDerefVar(var_glojure_DOT_core_pr_DASH_on)
			tmp70 := lang.Apply(tmp68, []any{"(", tmp69, " ", ")", v64, v65})
			return tmp70
		})
		tmp2.AddMethod(tmp62, tmp63)
		tmp64 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp65 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
		tmp2.PreferMethod(tmp64, tmp65)
		tmp66 := reflect.TypeOf((*lang.IRecord)(nil)).Elem()
		tmp67 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
		tmp2.PreferMethod(tmp66, tmp67)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-object
	{
		tmp0 := sym_print_DASH_object.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(115), kw_column, int(8), kw_end_DASH_line, int(115), kw_end_DASH_column, int(19), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_print_DASH_tagged_DASH_object)
			tmp6 := checkDerefVar(var_glojure_DOT_core_str)
			tmp7 := lang.Apply(tmp6, []any{v3})
			tmp8 := lang.Apply(tmp5, []any{v3, tmp7, v4})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-prefix-map
	{
		tmp0 := sym_print_DASH_prefix_DASH_map.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(243), kw_column, int(8), kw_end_DASH_line, int(243), kw_end_DASH_column, int(23), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_prefix, sym_kvs, sym_print_DASH_one, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 4)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			tmp7 := checkDerefVar(var_glojure_DOT_core_print_DASH_sequential)
			tmp8 := checkDerefVar(var_glojure_DOT_core_str)
			tmp9 := lang.Apply(tmp8, []any{v3, "{"})
			var tmp10 lang.FnFunc
			tmp10 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v11 := args[0]
				_ = v11
				v12 := args[1]
				_ = v12
				var tmp13 any
				{ // let
					// let binding "vec__212"
					var v14 any = v11
					_ = v14
					// let binding "k"
					tmp15 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
					var v17 any = tmp16
					_ = v17
					// let binding "v"
					tmp18 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp19 := lang.Apply(tmp18, []any{v14, int64(1), nil})
					var v20 any = tmp19
					_ = v20
					tmp21 := lang.Apply(v5, []any{v17, v12})
					_ = tmp21
					tmp22 := lang.Apply(lang.AppendWriter, []any{v12, lang.NewChar(32)})
					_ = tmp22
					tmp23 := lang.Apply(v5, []any{v20, v12})
					tmp13 = tmp23
				} // end let
				return tmp13
			})
			tmp11 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(246), kw_column, int(5), kw_end_DASH_line, int(247), kw_end_DASH_column, int(107))
			tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp13 := lang.Apply(tmp7, []any{tmp9, tmp12, ", ", "}", v4, v6})
			return tmp13
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-sequential
	{
		tmp0 := sym_print_DASH_sequential.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(46), kw_column, int(8), kw_end_DASH_line, int(46), kw_end_DASH_column, int(23), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_begin, sym_print_DASH_one, sym_sep, sym_end, sym_sequence, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 6)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			v8 := args[5]
			_ = v8
			var tmp9 any
			{ // let
				tmp10 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp11 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
				tmp12 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_level_STAR_)
				var tmp13 any
				{ // let
					// let binding "and__0__auto__"
					tmp14 := checkDerefVar(var_glojure_DOT_core_not)
					tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
					tmp16 := lang.Apply(tmp14, []any{tmp15})
					var v17 any = tmp16
					_ = v17
					var tmp18 any
					if lang.IsTruthy(v17) {
						var tmp19 any
						{ // let
							// let binding "and__0__auto__"
							tmp20 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_level_STAR_)
							var v21 any = tmp20
							_ = v21
							var tmp22 any
							if lang.IsTruthy(v21) {
								tmp23 := checkDerefVar(var_glojure_DOT_core_dec)
								tmp24 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_level_STAR_)
								tmp25 := lang.Apply(tmp23, []any{tmp24})
								tmp22 = tmp25
							} else {
								tmp22 = v21
							}
							tmp19 = tmp22
						} // end let
						tmp18 = tmp19
					} else {
						tmp18 = v17
					}
					tmp13 = tmp18
				} // end let
				tmp14 := lang.Apply(tmp11, []any{tmp12, tmp13})
				tmp15 := lang.Apply(tmp10, []any{tmp14})
				_ = tmp15
				var tmp16 any
				func() {
					defer func() {
						tmp17 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp18 := lang.Apply(tmp17, nil)
						_ = tmp18
					}()
					var tmp19 any
					var tmp20 any
					{ // let
						// let binding "and__0__auto__"
						tmp21 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_level_STAR_)
						var v22 any = tmp21
						_ = v22
						var tmp23 any
						if lang.IsTruthy(v22) {
							tmp24 := checkDerefVar(var_glojure_DOT_core_neg_QMARK_)
							tmp25 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_level_STAR_)
							tmp26 := lang.Apply(tmp24, []any{tmp25})
							tmp23 = tmp26
						} else {
							tmp23 = v22
						}
						tmp20 = tmp23
					} // end let
					if lang.IsTruthy(tmp20) {
						tmp21 := lang.Apply(lang.WriteWriter, []any{v8, "#"})
						tmp19 = tmp21
					} else {
						tmp22 := lang.Apply(lang.WriteWriter, []any{v8, v3})
						_ = tmp22
						var tmp23 any
						{ // let
							// let binding "temp__0__auto__"
							tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp25 := lang.Apply(tmp24, []any{v7})
							var v26 any = tmp25
							_ = v26
							var tmp27 any
							if lang.IsTruthy(v26) {
								var tmp28 any
								{ // let
									// let binding "xs"
									var v29 any = v26
									_ = v29
									var tmp30 any
									var tmp31 any
									{ // let
										// let binding "and__0__auto__"
										tmp32 := checkDerefVar(var_glojure_DOT_core_not)
										tmp33 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_dup_STAR_)
										tmp34 := lang.Apply(tmp32, []any{tmp33})
										var v35 any = tmp34
										_ = v35
										var tmp36 any
										if lang.IsTruthy(v35) {
											tmp37 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_length_STAR_)
											tmp36 = tmp37
										} else {
											tmp36 = v35
										}
										tmp31 = tmp36
									} // end let
									if lang.IsTruthy(tmp31) {
										var tmp32 any
										{ // let
											// let binding "G__194"
											var v33 any = v29
											_ = v33
											// let binding "vec__195"
											var v34 any = v33
											_ = v34
											// let binding "seq__196"
											tmp35 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp36 := lang.Apply(tmp35, []any{v34})
											var v37 any = tmp36
											_ = v37
											// let binding "first__197"
											tmp38 := checkDerefVar(var_glojure_DOT_core_first)
											tmp39 := lang.Apply(tmp38, []any{v37})
											var v40 any = tmp39
											_ = v40
											// let binding "seq__196"
											tmp41 := checkDerefVar(var_glojure_DOT_core_next)
											tmp42 := lang.Apply(tmp41, []any{v37})
											var v43 any = tmp42
											_ = v43
											// let binding "x"
											var v44 any = v40
											_ = v44
											// let binding "xs"
											var v45 any = v43
											_ = v45
											// let binding "print-length"
											tmp46 := checkDerefVar(var_glojure_DOT_core__STAR_print_DASH_length_STAR_)
											var v47 any = tmp46
											_ = v47
											var tmp48 any
											{ // let
												// let binding "G__194"
												var v49 any = v33
												_ = v49
												// let binding "print-length"
												var v50 any = v47
												_ = v50
												for {
													var tmp51 any
													{ // let
														// let binding "vec__198"
														var v52 any = v49
														_ = v52
														// let binding "seq__199"
														tmp53 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp54 := lang.Apply(tmp53, []any{v52})
														var v55 any = tmp54
														_ = v55
														// let binding "first__200"
														tmp56 := checkDerefVar(var_glojure_DOT_core_first)
														tmp57 := lang.Apply(tmp56, []any{v55})
														var v58 any = tmp57
														_ = v58
														// let binding "seq__199"
														tmp59 := checkDerefVar(var_glojure_DOT_core_next)
														tmp60 := lang.Apply(tmp59, []any{v55})
														var v61 any = tmp60
														_ = v61
														// let binding "x"
														var v62 any = v58
														_ = v62
														// let binding "xs"
														var v63 any = v61
														_ = v63
														// let binding "print-length"
														var v64 any = v50
														_ = v64
														var tmp65 any
														tmp66 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
														tmp67 := lang.Apply(tmp66, []any{v64})
														if lang.IsTruthy(tmp67) {
															tmp68 := lang.Apply(lang.WriteWriter, []any{v8, "..."})
															tmp65 = tmp68
														} else {
															tmp69 := lang.Apply(v4, []any{v62, v8})
															_ = tmp69
															var tmp70 any
															if lang.IsTruthy(v63) {
																tmp71 := lang.Apply(lang.WriteWriter, []any{v8, v5})
																_ = tmp71
																var tmp72 any = v63
																tmp74 := checkDerefVar(var_glojure_DOT_core_dec)
																tmp75 := lang.Apply(tmp74, []any{v64})
																var tmp73 any = tmp75
																v49 = tmp72
																v50 = tmp73
																continue
															} else {
															}
															tmp65 = tmp70
														}
														tmp51 = tmp65
													} // end let
													tmp48 = tmp51
													break
												}
											} // end let
											tmp32 = tmp48
										} // end let
										tmp30 = tmp32
									} else {
										var tmp33 any
										{ // let
											// let binding "G__204"
											var v34 any = v29
											_ = v34
											// let binding "vec__205"
											var v35 any = v34
											_ = v35
											// let binding "seq__206"
											tmp36 := checkDerefVar(var_glojure_DOT_core_seq)
											tmp37 := lang.Apply(tmp36, []any{v35})
											var v38 any = tmp37
											_ = v38
											// let binding "first__207"
											tmp39 := checkDerefVar(var_glojure_DOT_core_first)
											tmp40 := lang.Apply(tmp39, []any{v38})
											var v41 any = tmp40
											_ = v41
											// let binding "seq__206"
											tmp42 := checkDerefVar(var_glojure_DOT_core_next)
											tmp43 := lang.Apply(tmp42, []any{v38})
											var v44 any = tmp43
											_ = v44
											// let binding "x"
											var v45 any = v41
											_ = v45
											// let binding "xs"
											var v46 any = v44
											_ = v46
											var tmp47 any
											{ // let
												// let binding "G__204"
												var v48 any = v34
												_ = v48
												for {
													var tmp49 any
													{ // let
														// let binding "vec__208"
														var v50 any = v48
														_ = v50
														// let binding "seq__209"
														tmp51 := checkDerefVar(var_glojure_DOT_core_seq)
														tmp52 := lang.Apply(tmp51, []any{v50})
														var v53 any = tmp52
														_ = v53
														// let binding "first__210"
														tmp54 := checkDerefVar(var_glojure_DOT_core_first)
														tmp55 := lang.Apply(tmp54, []any{v53})
														var v56 any = tmp55
														_ = v56
														// let binding "seq__209"
														tmp57 := checkDerefVar(var_glojure_DOT_core_next)
														tmp58 := lang.Apply(tmp57, []any{v53})
														var v59 any = tmp58
														_ = v59
														// let binding "x"
														var v60 any = v56
														_ = v60
														// let binding "xs"
														var v61 any = v59
														_ = v61
														tmp62 := lang.Apply(v4, []any{v60, v8})
														_ = tmp62
														var tmp63 any
														if lang.IsTruthy(v61) {
															tmp64 := lang.Apply(lang.WriteWriter, []any{v8, v5})
															_ = tmp64
															var tmp65 any = v61
															v48 = tmp65
															continue
														} else {
														}
														tmp49 = tmp63
													} // end let
													tmp47 = tmp49
													break
												}
											} // end let
											tmp33 = tmp47
										} // end let
										tmp30 = tmp33
									}
									tmp28 = tmp30
								} // end let
								tmp27 = tmp28
							} else {
							}
							tmp23 = tmp27
						} // end let
						_ = tmp23
						tmp24 := lang.Apply(lang.WriteWriter, []any{v8, v6})
						tmp19 = tmp24
					}
					tmp16 = tmp19
				}()
				tmp9 = tmp16
			} // end let
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-simple
	{
		tmp0 := sym_print_DASH_simple.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(81), kw_column, int(7), kw_end_DASH_line, int(81), kw_end_DASH_column, int(18), kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			_ = tmp6
			tmp7 := checkDerefVar(var_glojure_DOT_core_str)
			tmp8 := lang.Apply(tmp7, []any{v3})
			tmp9 := lang.Apply(lang.WriteWriter, []any{v4, tmp8})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_print_DASH_str.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_doc, "print to a string, returning it", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4776), kw_end_DASH_line, int(4776))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp9 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp10 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_out_STAR_)
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp17 := checkDerefVar(var_glojure_DOT_core_print)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v4})
							_ = tmp18
							tmp19 := checkDerefVar(var_glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-tagged-object
	{
		tmp0 := sym_print_DASH_tagged_DASH_object.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(102), kw_column, int(8), kw_end_DASH_line, int(102), kw_end_DASH_column, int(26), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_rep, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			tmp7 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp8 := reflect.TypeOf((*lang.IMeta)(nil)).Elem()
			tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
			if lang.IsTruthy(tmp9) {
				tmp10 := checkDerefVar(var_glojure_DOT_core_print_DASH_meta)
				tmp11 := lang.Apply(tmp10, []any{v3, v5})
				tmp6 = tmp11
			} else {
			}
			_ = tmp6
			tmp12 := lang.Apply(lang.WriteWriter, []any{v5, "#object["})
			_ = tmp12
			var tmp13 any
			{ // let
				// let binding "c"
				tmp14 := checkDerefVar(var_glojure_DOT_core_class)
				tmp15 := lang.Apply(tmp14, []any{v3})
				var v16 any = tmp15
				_ = v16
				var tmp17 any
				if lang.IsTruthy(false) {
					tmp18 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
					tmp19, ok := lang.FieldOrMethod(v16, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v16, "Name")))
					}
					var tmp20 any
					switch reflect.TypeOf(tmp19).Kind() {
					case reflect.Func:
						tmp20 = lang.Apply(tmp19, nil)
					default:
						tmp20 = tmp19
					}
					tmp21 := lang.Apply(tmp18, []any{tmp20, v5})
					tmp17 = tmp21
				} else {
					tmp22, ok := lang.FieldOrMethod(v16, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v16, "Name")))
					}
					var tmp23 any
					switch reflect.TypeOf(tmp22).Kind() {
					case reflect.Func:
						tmp23 = lang.Apply(tmp22, nil)
					default:
						tmp23 = tmp22
					}
					tmp24 := lang.Apply(lang.WriteWriter, []any{v5, tmp23})
					tmp17 = tmp24
				}
				tmp13 = tmp17
			} // end let
			_ = tmp13
			tmp14 := lang.Apply(lang.WriteWriter, []any{v5, " "})
			_ = tmp14
			tmp15 := checkDerefVar(var_glojure_DOT_core_format)
			tmp16 := lang.Apply(lang.IdentityHash, []any{v3})
			tmp17 := lang.Apply(tmp15, []any{"0x%x ", tmp16})
			tmp18 := lang.Apply(lang.WriteWriter, []any{v5, tmp17})
			_ = tmp18
			tmp19 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
			tmp20 := lang.Apply(tmp19, []any{v4, v5})
			_ = tmp20
			tmp21 := lang.Apply(lang.WriteWriter, []any{v5, "]"})
			return tmp21
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-throwable
	{
		tmp0 := sym_print_DASH_throwable.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(478), kw_column, int(8), kw_end_DASH_line, int(478), kw_end_DASH_column, int(22), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_o, sym_w)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(lang.WriteWriter, []any{v4, "#error {\n :cause "})
			_ = tmp5
			var tmp6 any
			{ // let
				// let binding "map__253"
				tmp7 := checkDerefVar(var_glojure_DOT_core_Throwable_DASH__GT_map)
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				// let binding "map__253"
				var tmp10 any
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
				tmp12 := lang.Apply(tmp11, []any{v9})
				if lang.IsTruthy(tmp12) {
					var tmp13 any
					tmp14 := checkDerefVar(var_glojure_DOT_core_next)
					tmp15 := lang.Apply(tmp14, []any{v9})
					if lang.IsTruthy(tmp15) {
						tmp16 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
						tmp17 := lang.Apply(tmp16, []any{v9})
						tmp18 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp17})
						tmp13 = tmp18
					} else {
						var tmp19 any
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := lang.Apply(tmp20, []any{v9})
						if lang.IsTruthy(tmp21) {
							tmp22 := checkDerefVar(var_glojure_DOT_core_first)
							tmp23 := lang.Apply(tmp22, []any{v9})
							tmp19 = tmp23
						} else {
						}
						tmp13 = tmp19
					}
					tmp10 = tmp13
				} else {
					tmp10 = v9
				}
				var v24 any = tmp10
				_ = v24
				// let binding "cause"
				tmp25 := checkDerefVar(var_glojure_DOT_core_get)
				tmp26 := lang.Apply(tmp25, []any{v24, kw_cause})
				var v27 any = tmp26
				_ = v27
				// let binding "data"
				tmp28 := checkDerefVar(var_glojure_DOT_core_get)
				tmp29 := lang.Apply(tmp28, []any{v24, kw_data})
				var v30 any = tmp29
				_ = v30
				// let binding "via"
				tmp31 := checkDerefVar(var_glojure_DOT_core_get)
				tmp32 := lang.Apply(tmp31, []any{v24, kw_via})
				var v33 any = tmp32
				_ = v33
				// let binding "trace"
				tmp34 := checkDerefVar(var_glojure_DOT_core_get)
				tmp35 := lang.Apply(tmp34, []any{v24, kw_trace})
				var v36 any = tmp35
				_ = v36
				// let binding "print-via"
				var tmp37 lang.FnFunc
				tmp37 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v38 := args[0]
					_ = v38
					tmp39 := lang.Apply(lang.WriteWriter, []any{v4, "{:type "})
					_ = tmp39
					tmp40 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
					tmp41 := lang.Apply(kw_type, []any{v38})
					tmp42 := lang.Apply(tmp40, []any{tmp41, v4})
					_ = tmp42
					tmp43 := lang.Apply(lang.WriteWriter, []any{v4, "\n   :message "})
					_ = tmp43
					tmp44 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
					tmp45 := lang.Apply(kw_message, []any{v38})
					tmp46 := lang.Apply(tmp44, []any{tmp45, v4})
					_ = tmp46
					var tmp47 any
					{ // let
						// let binding "temp__0__auto__"
						tmp48 := lang.Apply(kw_data, []any{v38})
						var v49 any = tmp48
						_ = v49
						var tmp50 any
						if lang.IsTruthy(v49) {
							var tmp51 any
							{ // let
								// let binding "data"
								var v52 any = v49
								_ = v52
								tmp53 := lang.Apply(lang.WriteWriter, []any{v4, "\n   :data "})
								_ = tmp53
								tmp54 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
								tmp55 := lang.Apply(tmp54, []any{v52, v4})
								tmp51 = tmp55
							} // end let
							tmp50 = tmp51
						} else {
						}
						tmp47 = tmp50
					} // end let
					_ = tmp47
					var tmp48 any
					{ // let
						// let binding "temp__0__auto__"
						tmp49 := lang.Apply(kw_at, []any{v38})
						var v50 any = tmp49
						_ = v50
						var tmp51 any
						if lang.IsTruthy(v50) {
							var tmp52 any
							{ // let
								// let binding "at"
								var v53 any = v50
								_ = v53
								tmp54 := lang.Apply(lang.WriteWriter, []any{v4, "\n   :at "})
								_ = tmp54
								tmp55 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
								tmp56 := lang.Apply(kw_at, []any{v38})
								tmp57 := lang.Apply(tmp55, []any{tmp56, v4})
								tmp52 = tmp57
							} // end let
							tmp51 = tmp52
						} else {
						}
						tmp48 = tmp51
					} // end let
					_ = tmp48
					tmp49 := lang.Apply(lang.WriteWriter, []any{v4, "}"})
					return tmp49
				})
				tmp38 := lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(481), kw_column, int(19), kw_end_DASH_line, int(491), kw_end_DASH_column, int(73))
				tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v40 any = tmp39
				_ = v40
				tmp41 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
				tmp42 := lang.Apply(tmp41, []any{v27, v4})
				_ = tmp42
				var tmp43 any
				if lang.IsTruthy(v30) {
					tmp44 := lang.Apply(lang.WriteWriter, []any{v4, "\n :data "})
					_ = tmp44
					tmp45 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
					tmp46 := lang.Apply(tmp45, []any{v30, v4})
					tmp43 = tmp46
				} else {
				}
				_ = tmp43
				var tmp47 any
				if lang.IsTruthy(v33) {
					tmp48 := lang.Apply(lang.WriteWriter, []any{v4, "\n :via\n ["})
					_ = tmp48
					var tmp49 any
					{ // let
						// let binding "temp__0__auto__"
						tmp50 := checkDerefVar(var_glojure_DOT_core_first)
						tmp51 := lang.Apply(tmp50, []any{v33})
						var v52 any = tmp51
						_ = v52
						var tmp53 any
						if lang.IsTruthy(v52) {
							var tmp54 any
							{ // let
								// let binding "fv"
								var v55 any = v52
								_ = v55
								tmp56 := lang.Apply(v40, []any{v55})
								_ = tmp56
								var tmp57 any
								{ // let
									// let binding "seq_254"
									tmp58 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp59 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp60 := lang.Apply(tmp59, []any{v33})
									tmp61 := lang.Apply(tmp58, []any{tmp60})
									var v62 any = tmp61
									_ = v62
									// let binding "chunk_255"
									var v63 any = nil
									_ = v63
									// let binding "count_256"
									var v64 any = int64(0)
									_ = v64
									// let binding "i_257"
									var v65 any = int64(0)
									_ = v65
									for {
										var tmp66 any
										tmp67 := checkDerefVar(var_glojure_DOT_core__LT_)
										tmp68 := lang.Apply(tmp67, []any{v65, v64})
										if lang.IsTruthy(tmp68) {
											var tmp69 any
											{ // let
												// let binding "v"
												tmp70, _ := lang.FieldOrMethod(v63, "nth")
												if reflect.TypeOf(tmp70).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
												}
												tmp71 := lang.Apply(tmp70, []any{v65})
												var v72 any = tmp71
												_ = v72
												tmp73 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
												_ = tmp73
												tmp74 := lang.Apply(v40, []any{v72})
												_ = tmp74
												var tmp75 any = v62
												var tmp76 any = v63
												var tmp77 any = v64
												tmp79 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
												tmp80 := lang.Apply(tmp79, []any{v65})
												var tmp78 any = tmp80
												v62 = tmp75
												v63 = tmp76
												v64 = tmp77
												v65 = tmp78
												continue
											} // end let
											tmp66 = tmp69
										} else {
											var tmp70 any
											{ // let
												// let binding "temp__0__auto__"
												tmp71 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp72 := lang.Apply(tmp71, []any{v62})
												var v73 any = tmp72
												_ = v73
												var tmp74 any
												if lang.IsTruthy(v73) {
													var tmp75 any
													{ // let
														// let binding "seq_254"
														var v76 any = v73
														_ = v76
														var tmp77 any
														tmp78 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
														tmp79 := lang.Apply(tmp78, []any{v76})
														if lang.IsTruthy(tmp79) {
															var tmp80 any
															{ // let
																// let binding "c__0__auto__"
																tmp81 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																tmp82 := lang.Apply(tmp81, []any{v76})
																var v83 any = tmp82
																_ = v83
																tmp85 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																tmp86 := lang.Apply(tmp85, []any{v76})
																var tmp84 any = tmp86
																var tmp87 any = v83
																tmp89 := checkDerefVar(var_glojure_DOT_core_int)
																tmp90 := checkDerefVar(var_glojure_DOT_core_count)
																tmp91 := lang.Apply(tmp90, []any{v83})
																tmp92 := lang.Apply(tmp89, []any{tmp91})
																var tmp88 any = tmp92
																tmp94 := checkDerefVar(var_glojure_DOT_core_int)
																tmp95 := lang.Apply(tmp94, []any{int64(0)})
																var tmp93 any = tmp95
																v62 = tmp84
																v63 = tmp87
																v64 = tmp88
																v65 = tmp93
																continue
															} // end let
															tmp77 = tmp80
														} else {
															var tmp81 any
															{ // let
																// let binding "v"
																tmp82 := checkDerefVar(var_glojure_DOT_core_first)
																tmp83 := lang.Apply(tmp82, []any{v76})
																var v84 any = tmp83
																_ = v84
																tmp85 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
																_ = tmp85
																tmp86 := lang.Apply(v40, []any{v84})
																_ = tmp86
																tmp88 := checkDerefVar(var_glojure_DOT_core_next)
																tmp89 := lang.Apply(tmp88, []any{v76})
																var tmp87 any = tmp89
																var tmp90 any = nil
																var tmp91 any = int64(0)
																var tmp92 any = int64(0)
																v62 = tmp87
																v63 = tmp90
																v64 = tmp91
																v65 = tmp92
																continue
															} // end let
															tmp77 = tmp81
														}
														tmp75 = tmp77
													} // end let
													tmp74 = tmp75
												} else {
												}
												tmp70 = tmp74
											} // end let
											tmp66 = tmp70
										}
										tmp57 = tmp66
										break
									}
								} // end let
								tmp54 = tmp57
							} // end let
							tmp53 = tmp54
						} else {
						}
						tmp49 = tmp53
					} // end let
					_ = tmp49
					tmp50 := lang.Apply(lang.WriteWriter, []any{v4, "]"})
					tmp47 = tmp50
				} else {
				}
				_ = tmp47
				var tmp51 any
				if lang.IsTruthy(v36) {
					tmp52 := lang.Apply(lang.WriteWriter, []any{v4, "\n :trace\n ["})
					_ = tmp52
					var tmp53 any
					{ // let
						// let binding "temp__0__auto__"
						tmp54 := checkDerefVar(var_glojure_DOT_core_first)
						tmp55 := lang.Apply(tmp54, []any{v36})
						var v56 any = tmp55
						_ = v56
						var tmp57 any
						if lang.IsTruthy(v56) {
							var tmp58 any
							{ // let
								// let binding "ft"
								var v59 any = v56
								_ = v59
								tmp60 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
								tmp61 := lang.Apply(tmp60, []any{v59, v4})
								_ = tmp61
								var tmp62 any
								{ // let
									// let binding "seq_258"
									tmp63 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp64 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp65 := lang.Apply(tmp64, []any{v36})
									tmp66 := lang.Apply(tmp63, []any{tmp65})
									var v67 any = tmp66
									_ = v67
									// let binding "chunk_259"
									var v68 any = nil
									_ = v68
									// let binding "count_260"
									var v69 any = int64(0)
									_ = v69
									// let binding "i_261"
									var v70 any = int64(0)
									_ = v70
									for {
										var tmp71 any
										tmp72 := checkDerefVar(var_glojure_DOT_core__LT_)
										tmp73 := lang.Apply(tmp72, []any{v70, v69})
										if lang.IsTruthy(tmp73) {
											var tmp74 any
											{ // let
												// let binding "t"
												tmp75, _ := lang.FieldOrMethod(v68, "nth")
												if reflect.TypeOf(tmp75).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
												}
												tmp76 := lang.Apply(tmp75, []any{v70})
												var v77 any = tmp76
												_ = v77
												tmp78 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
												_ = tmp78
												tmp79 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
												tmp80 := lang.Apply(tmp79, []any{v77, v4})
												_ = tmp80
												var tmp81 any = v67
												var tmp82 any = v68
												var tmp83 any = v69
												tmp85 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
												tmp86 := lang.Apply(tmp85, []any{v70})
												var tmp84 any = tmp86
												v67 = tmp81
												v68 = tmp82
												v69 = tmp83
												v70 = tmp84
												continue
											} // end let
											tmp71 = tmp74
										} else {
											var tmp75 any
											{ // let
												// let binding "temp__0__auto__"
												tmp76 := checkDerefVar(var_glojure_DOT_core_seq)
												tmp77 := lang.Apply(tmp76, []any{v67})
												var v78 any = tmp77
												_ = v78
												var tmp79 any
												if lang.IsTruthy(v78) {
													var tmp80 any
													{ // let
														// let binding "seq_258"
														var v81 any = v78
														_ = v81
														var tmp82 any
														tmp83 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
														tmp84 := lang.Apply(tmp83, []any{v81})
														if lang.IsTruthy(tmp84) {
															var tmp85 any
															{ // let
																// let binding "c__0__auto__"
																tmp86 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
																tmp87 := lang.Apply(tmp86, []any{v81})
																var v88 any = tmp87
																_ = v88
																tmp90 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
																tmp91 := lang.Apply(tmp90, []any{v81})
																var tmp89 any = tmp91
																var tmp92 any = v88
																tmp94 := checkDerefVar(var_glojure_DOT_core_int)
																tmp95 := checkDerefVar(var_glojure_DOT_core_count)
																tmp96 := lang.Apply(tmp95, []any{v88})
																tmp97 := lang.Apply(tmp94, []any{tmp96})
																var tmp93 any = tmp97
																tmp99 := checkDerefVar(var_glojure_DOT_core_int)
																tmp100 := lang.Apply(tmp99, []any{int64(0)})
																var tmp98 any = tmp100
																v67 = tmp89
																v68 = tmp92
																v69 = tmp93
																v70 = tmp98
																continue
															} // end let
															tmp82 = tmp85
														} else {
															var tmp86 any
															{ // let
																// let binding "t"
																tmp87 := checkDerefVar(var_glojure_DOT_core_first)
																tmp88 := lang.Apply(tmp87, []any{v81})
																var v89 any = tmp88
																_ = v89
																tmp90 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
																_ = tmp90
																tmp91 := checkDerefVar(var_glojure_DOT_core_print_DASH_method)
																tmp92 := lang.Apply(tmp91, []any{v89, v4})
																_ = tmp92
																tmp94 := checkDerefVar(var_glojure_DOT_core_next)
																tmp95 := lang.Apply(tmp94, []any{v81})
																var tmp93 any = tmp95
																var tmp96 any = nil
																var tmp97 any = int64(0)
																var tmp98 any = int64(0)
																v67 = tmp93
																v68 = tmp96
																v69 = tmp97
																v70 = tmp98
																continue
															} // end let
															tmp82 = tmp86
														}
														tmp80 = tmp82
													} // end let
													tmp79 = tmp80
												} else {
												}
												tmp75 = tmp79
											} // end let
											tmp71 = tmp75
										}
										tmp62 = tmp71
										break
									}
								} // end let
								tmp58 = tmp62
							} // end let
							tmp57 = tmp58
						} else {
						}
						tmp53 = tmp57
					} // end let
					_ = tmp53
					tmp54 := lang.Apply(lang.WriteWriter, []any{v4, "]"})
					tmp51 = tmp54
				} else {
				}
				tmp6 = tmp51
			} // end let
			_ = tmp6
			tmp7 := lang.Apply(lang.WriteWriter, []any{v4, "}"})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// printf
	{
		tmp0 := sym_printf.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_fmt, sym__AMP_, sym_args)), kw_doc, "Prints formatted output, as per format", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5725), kw_end_DASH_line, int(5725))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_print)
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_format)
				tmp8 := lang.Apply(tmp6, []any{tmp7, v3, v4})
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// println
	{
		tmp0 := sym_println.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_more)), kw_doc, "Same as print followed by (newline)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3734), kw_end_DASH_line, int(3734))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					tmp5 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
					tmp6 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp7 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_print_DASH_readably_STAR_)
					tmp8 := lang.Apply(tmp6, []any{tmp7, nil})
					tmp9 := lang.Apply(tmp5, []any{tmp8})
					_ = tmp9
					var tmp10 any
					func() {
						defer func() {
							tmp11 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
							tmp12 := lang.Apply(tmp11, nil)
							_ = tmp12
						}()
						tmp13 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp14 := checkDerefVar(var_glojure_DOT_core_prn)
						tmp15 := lang.Apply(tmp13, []any{tmp14, v3})
						tmp10 = tmp15
					}()
					tmp4 = tmp10
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// println-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_println_DASH_str.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_doc, "println to a string, returning it", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(4785), kw_end_DASH_line, int(4785))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp9 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp10 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_out_STAR_)
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp17 := checkDerefVar(var_glojure_DOT_core_println)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v4})
							_ = tmp18
							tmp19 := checkDerefVar(var_glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prn
	{
		tmp0 := sym_prn.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_more)), kw_doc, "Same as pr followed by (newline). Observes *flush-on-newline*", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(3715), kw_end_DASH_line, int(3715))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp5 := checkDerefVar(var_glojure_DOT_core_pr)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				_ = tmp6
				tmp7 := checkDerefVar(var_glojure_DOT_core_newline)
				tmp8 := lang.Apply(tmp7, nil)
				_ = tmp8
				var tmp9 any
				tmp10 := checkDerefVar(var_glojure_DOT_core__STAR_flush_DASH_on_DASH_newline_STAR_)
				if lang.IsTruthy(tmp10) {
					tmp11 := checkDerefVar(var_glojure_DOT_core_flush)
					tmp12 := lang.Apply(tmp11, nil)
					tmp9 = tmp12
				} else {
				}
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prn-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_prn_DASH_str.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_xs)), kw_doc, "prn to a string, returning it", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4767), kw_end_DASH_line, int(4767))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
						tmp9 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
						tmp10 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_out_STAR_)
						tmp11 := lang.Apply(tmp9, []any{tmp10, v6})
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						_ = tmp12
						var tmp13 any
						func() {
							defer func() {
								tmp14 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
								tmp15 := lang.Apply(tmp14, nil)
								_ = tmp15
							}()
							tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp17 := checkDerefVar(var_glojure_DOT_core_prn)
							tmp18 := lang.Apply(tmp16, []any{tmp17, v4})
							_ = tmp18
							tmp19 := checkDerefVar(var_glojure_DOT_core_str)
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp13 = tmp20
						}()
						tmp7 = tmp13
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// promise
	{
		tmp0 := sym_promise.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a promise object that can be read with deref/@, and set,\n  once only, with deliver. Calls to deref/@ prior to delivery will\n  block, unless the variant of deref with timeout is used. All\n  subsequent derefs will return the same delivered value without\n  blocking. See also - realized?.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(7078), kw_end_DASH_line, int(7078))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			var tmp3 any
			{ // let
				// let binding "d"
				tmp4 := lang.Apply(nil, []any{int64(1)})
				var v5 any = tmp4
				_ = v5
				// let binding "v"
				tmp6 := checkDerefVar(var_glojure_DOT_core_atom)
				tmp7 := lang.Apply(tmp6, []any{v5})
				var v8 any = tmp7
				_ = v8
				tmp9 := reflect.TypeOf((*lang.IDeref)(nil)).Elem()
				tmp10 := checkDerefVar(var_glojure_DOT_core_deref)
				tmp11 := lang.NewVector(nil)
				tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7091), kw_column, int(15), kw_end_DASH_line, int(7091), kw_end_DASH_column, int(17))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14, ok := lang.FieldOrMethod(v5, "await")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "await")))
				}
				var tmp15 any
				switch reflect.TypeOf(tmp14).Kind() {
				case reflect.Func:
					tmp15 = lang.Apply(tmp14, nil)
				default:
					tmp15 = tmp14
				}
				tmp16 := checkDerefVar(var_glojure_DOT_core_deref)
				tmp17 := lang.Apply(tmp16, []any{v8})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp15, tmp17})
				tmp19 := reflect.TypeOf((*lang.IBlockingDeref)(nil)).Elem()
				tmp20 := checkDerefVar(var_glojure_DOT_core_deref)
				tmp21 := lang.NewVector(nil, nil, nil)
				tmp22 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7094), kw_column, int(9), kw_end_DASH_line, int(7094), kw_end_DASH_column, int(34))
				tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp24 any
				tmp25, _ := lang.FieldOrMethod(v5, "await")
				if reflect.TypeOf(tmp25).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
				}
				tmp26 := lang.Apply(tmp25, []any{nil, time10.Millisecond})
				if lang.IsTruthy(tmp26) {
					tmp27 := checkDerefVar(var_glojure_DOT_core_deref)
					tmp28 := lang.Apply(tmp27, []any{v8})
					tmp24 = tmp28
				} else {
				}
				tmp29 := lang.Apply(tmp20, []any{tmp23, tmp24})
				tmp30 := reflect.TypeOf((*lang.IPending)(nil)).Elem()
				tmp31 := lang.NewVector(nil)
				tmp32 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7099), kw_column, int(19), kw_end_DASH_line, int(7099), kw_end_DASH_column, int(24))
				tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp34 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
				tmp35, ok := lang.FieldOrMethod(v5, "getCount")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "getCount")))
				}
				var tmp36 any
				switch reflect.TypeOf(tmp35).Kind() {
				case reflect.Func:
					tmp36 = lang.Apply(tmp35, nil)
				default:
					tmp36 = tmp35
				}
				tmp37 := lang.Apply(tmp34, []any{tmp36})
				tmp38 := lang.Apply(nil, []any{tmp33, tmp37})
				tmp39 := lang.NewVector(nil, nil)
				tmp40 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7103), kw_column, int(7), kw_end_DASH_line, int(7103), kw_end_DASH_column, int(14))
				tmp41, err := lang.WithMeta(tmp39, tmp40.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp42 any
				var tmp43 any
				{ // let
					// let binding "and__0__auto__"
					tmp44 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
					tmp45, ok := lang.FieldOrMethod(v5, "getCount")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "getCount")))
					}
					var tmp46 any
					switch reflect.TypeOf(tmp45).Kind() {
					case reflect.Func:
						tmp46 = lang.Apply(tmp45, nil)
					default:
						tmp46 = tmp45
					}
					tmp47 := lang.Apply(tmp44, []any{tmp46})
					var v48 any = tmp47
					_ = v48
					var tmp49 any
					if lang.IsTruthy(v48) {
						tmp50 := checkDerefVar(var_glojure_DOT_core_compare_DASH_and_DASH_set_BANG_)
						tmp51 := lang.Apply(tmp50, []any{v8, v5, nil})
						tmp49 = tmp51
					} else {
						tmp49 = v48
					}
					tmp43 = tmp49
				} // end let
				if lang.IsTruthy(tmp43) {
					tmp44, ok := lang.FieldOrMethod(v5, "countDown")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "countDown")))
					}
					var tmp45 any
					switch reflect.TypeOf(tmp44).Kind() {
					case reflect.Func:
						tmp45 = lang.Apply(tmp44, nil)
					default:
						tmp45 = tmp44
					}
					_ = tmp45
				} else {
				}
				tmp46 := lang.Apply(nil, []any{tmp41, tmp42})
				tmp47 := lang.Apply(nil, []any{tmp9, tmp18, tmp19, tmp29, tmp30, tmp38, nil, tmp46})
				tmp3 = tmp47
			} // end let
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// protocol?
	{
		tmp0 := sym_protocol_QMARK_.WithMeta(lang.NewMap(kw_file, "glojure/core_deftype.glj", kw_line, int(110), kw_column, int(8), kw_end_DASH_line, int(110), kw_end_DASH_column, int(16), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_maybe_DASH_p)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp6 := reflect.TypeOf((*lang.IAtom)(nil)).Elem()
			tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
			if lang.IsTruthy(tmp7) {
				tmp8 := checkDerefVar(var_glojure_DOT_core_boolean)
				tmp9 := checkDerefVar(var_glojure_DOT_core_deref)
				tmp10 := lang.Apply(tmp9, []any{v3})
				tmp11 := lang.Apply(kw_on_DASH_interface, []any{tmp10})
				tmp12 := lang.Apply(tmp8, []any{tmp11})
				tmp4 = tmp12
			} else {
				tmp4 = false
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// push-thread-bindings
	{
		tmp0 := sym_push_DASH_thread_DASH_bindings.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_bindings)), kw_doc, "WARNING: This is a low-level function. Prefer high-level macros like\n  binding where ever possible.\n\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\n  the current thread. Each call *MUST* be accompanied by a matching call to\n  pop-thread-bindings wrapped in a try-finally!\n  \n      (push-thread-bindings bindings)\n      (try\n        ...\n        (finally\n          (pop-thread-bindings)))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(26), kw_column, int(7), kw_line, int(1911), kw_end_DASH_line, int(1911))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.PushThreadBindings, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pvalues
	{
		tmp0 := sym_pvalues.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_exprs)), kw_doc, "Returns a lazy sequence of the values of the exprs, which are\n  evaluated in parallel", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(7063), kw_end_DASH_line, int(7063))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_pcalls})
				tmp10 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v12 := args[0]
					_ = v12
					tmp13 := checkDerefVar(var_glojure_DOT_core_list)
					tmp14 := lang.NewVector()
					tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7069), kw_column, int(30), kw_end_DASH_line, int(7069), kw_end_DASH_column, int(31))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_fn, tmp16, v12})
					return tmp17
				})
				tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7069), kw_column, int(19), kw_end_DASH_line, int(7069), kw_end_DASH_column, int(34))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.Apply(tmp10, []any{tmp13, v5})
				tmp15 := lang.Apply(tmp7, []any{tmp9, tmp14})
				tmp16 := lang.Apply(tmp6, []any{tmp15})
				return tmp16
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-ident?
	{
		tmp0 := sym_qualified_DASH_ident_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a symbol or keyword with a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(1618), kw_end_DASH_line, int(1618))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_boolean)
			var tmp5 any
			{ // let
				// let binding "and__0__auto__"
				tmp6 := checkDerefVar(var_glojure_DOT_core_ident_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "and__0__auto__"
						tmp11 := checkDerefVar(var_glojure_DOT_core_namespace)
						tmp12 := lang.Apply(tmp11, []any{v3})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						if lang.IsTruthy(v13) {
							tmp14 = true
						} else {
							tmp14 = v13
						}
						tmp10 = tmp14
					} // end let
					tmp9 = tmp10
				} else {
					tmp9 = v8
				}
				tmp5 = tmp9
			} // end let
			tmp6 := lang.Apply(tmp4, []any{tmp5})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-keyword?
	{
		tmp0 := sym_qualified_DASH_keyword_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a keyword with a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(1638), kw_end_DASH_line, int(1638))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_boolean)
			var tmp5 any
			{ // let
				// let binding "and__0__auto__"
				tmp6 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "and__0__auto__"
						tmp11 := checkDerefVar(var_glojure_DOT_core_namespace)
						tmp12 := lang.Apply(tmp11, []any{v3})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						if lang.IsTruthy(v13) {
							tmp14 = true
						} else {
							tmp14 = v13
						}
						tmp10 = tmp14
					} // end let
					tmp9 = tmp10
				} else {
					tmp9 = v8
				}
				tmp5 = tmp9
			} // end let
			tmp6 := lang.Apply(tmp4, []any{tmp5})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-symbol?
	{
		tmp0 := sym_qualified_DASH_symbol_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a symbol with a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(1628), kw_end_DASH_line, int(1628))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_boolean)
			var tmp5 any
			{ // let
				// let binding "and__0__auto__"
				tmp6 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v3})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "and__0__auto__"
						tmp11 := checkDerefVar(var_glojure_DOT_core_namespace)
						tmp12 := lang.Apply(tmp11, []any{v3})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						if lang.IsTruthy(v13) {
							tmp14 = true
						} else {
							tmp14 = v13
						}
						tmp10 = tmp14
					} // end let
					tmp9 = tmp10
				} else {
					tmp9 = v8
				}
				tmp5 = tmp9
			} // end let
			tmp6 := lang.Apply(tmp4, []any{tmp5})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// quot
	{
		var tmp1 lang.FnFunc
		{ // function quot__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Quotient})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_quot.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num, sym_div)), kw_inline, tmp1, kw_doc, "quot[ient] of dividing numerator by denominator.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1266), kw_end_DASH_line, int(1266))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Quotient")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Quotient is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand
	{
		tmp0 := sym_rand.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_n)), kw_doc, "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(4935), kw_end_DASH_line, int(4935))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.Apply(rand16.Float64, nil)
				return tmp3
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core__STAR_)
				tmp5 := checkDerefVar(var_glojure_DOT_core_rand)
				tmp6 := lang.Apply(tmp5, nil)
				tmp7 := lang.Apply(tmp4, []any{v3, tmp6})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand-int
	{
		tmp0 := sym_rand_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns a random integer between 0 (inclusive) and n (exclusive).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4943), kw_end_DASH_line, int(4943))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_int)
			tmp5 := checkDerefVar(var_glojure_DOT_core_rand)
			tmp6 := lang.Apply(tmp5, []any{v3})
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand-nth
	{
		tmp0 := sym_rand_DASH_nth.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(7213), kw_end_DASH_line, int(7213))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_nth)
			tmp5 := checkDerefVar(var_glojure_DOT_core_rand_DASH_int)
			tmp6 := checkDerefVar(var_glojure_DOT_core_count)
			tmp7 := lang.Apply(tmp6, []any{v3})
			tmp8 := lang.Apply(tmp5, []any{tmp7})
			tmp9 := lang.Apply(tmp4, []any{v3, tmp8})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// random-sample
	{
		tmp0 := sym_random_DASH_sample.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_prob), lang.NewVector(sym_prob, sym_coll)), kw_doc, "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(7699), kw_end_DASH_line, int(7699))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_filter)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v6 := args[0]
					_ = v6
					tmp7 := checkDerefVar(var_glojure_DOT_core__LT_)
					tmp8 := checkDerefVar(var_glojure_DOT_core_rand)
					tmp9 := lang.Apply(tmp8, nil)
					tmp10 := lang.Apply(tmp7, []any{tmp9, v3})
					return tmp10
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7704), kw_column, int(14), kw_end_DASH_line, int(7704), kw_end_DASH_column, int(37))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7})
				return tmp8
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_filter)
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v7 := args[0]
					_ = v7
					tmp8 := checkDerefVar(var_glojure_DOT_core__LT_)
					tmp9 := checkDerefVar(var_glojure_DOT_core_rand)
					tmp10 := lang.Apply(tmp9, nil)
					tmp11 := lang.Apply(tmp8, []any{tmp10, v3})
					return tmp11
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7706), kw_column, int(14), kw_end_DASH_line, int(7706), kw_end_DASH_column, int(37))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(tmp5, []any{tmp8, v4})
				return tmp9
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// random-uuid
	{
		tmp0 := sym_random_DASH_uuid.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Returns a pseudo-randomly generated java.util.UUID instance (i.e. type 4).\n\n  See: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#randomUUID--", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(6852), kw_end_DASH_line, int(6852))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := lang.Apply(uuid13.NewV7, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// range
	{
		tmp0 := sym_range.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_end), lang.NewVector(sym_start, sym_end), lang.NewVector(sym_start, sym_end, sym_step)), kw_doc, "Returns a lazy seq of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end to\n  infinity. When step is equal to 0, returns an infinite sequence of\n  start. When start is equal to end, returns empty list.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3018), kw_end_DASH_line, int(3018))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(var_glojure_DOT_core_iterate)
				tmp4 := checkDerefVar(var_glojure_DOT_core_inc_TICK_)
				tmp5 := lang.Apply(tmp3, []any{tmp4, int64(0)})
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					tmp7 := lang.Apply(lang.NewLongRange, []any{int64(0), v3, int64(1)})
					tmp4 = tmp7
				} else {
					tmp8 := lang.Apply(lang.NewRange, []any{int64(0), v3, int64(1)})
					tmp4 = tmp8
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				var tmp6 any
				{ // let
					// let binding "and__0__auto__"
					tmp7 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{v3})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp11 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
						tmp12 := lang.Apply(tmp11, []any{v4})
						tmp10 = tmp12
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				if lang.IsTruthy(tmp6) {
					tmp7 := lang.Apply(lang.NewLongRange, []any{v3, v4, int64(1)})
					tmp5 = tmp7
				} else {
					tmp8 := lang.Apply(lang.NewRange, []any{v3, v4, int64(1)})
					tmp5 = tmp8
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				var tmp7 any
				{ // let
					// let binding "and__0__auto__"
					tmp8 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v3})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						var tmp12 any
						{ // let
							// let binding "and__0__auto__"
							tmp13 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
							tmp14 := lang.Apply(tmp13, []any{v4})
							var v15 any = tmp14
							_ = v15
							var tmp16 any
							if lang.IsTruthy(v15) {
								tmp17 := checkDerefVar(var_glojure_DOT_core_int_QMARK_)
								tmp18 := lang.Apply(tmp17, []any{v5})
								tmp16 = tmp18
							} else {
								tmp16 = v15
							}
							tmp12 = tmp16
						} // end let
						tmp11 = tmp12
					} else {
						tmp11 = v10
					}
					tmp7 = tmp11
				} // end let
				if lang.IsTruthy(tmp7) {
					tmp8 := lang.Apply(lang.NewLongRange, []any{v3, v4, v5})
					tmp6 = tmp8
				} else {
					tmp9 := lang.Apply(lang.NewRange, []any{v3, v4, v5})
					tmp6 = tmp9
				}
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ratio?
	{
		tmp0 := sym_ratio_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is a Ratio", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3577), kw_end_DASH_line, int(3577))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Ratio)(nil))
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rational?
	{
		tmp0 := sym_rational_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Returns true if n is a rational number", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3613), kw_end_DASH_line, int(3613))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_integer_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp8 = v7
				} else {
					var tmp9 any
					{ // let
						// let binding "or__0__auto__"
						tmp10 := checkDerefVar(var_glojure_DOT_core_ratio_QMARK_)
						tmp11 := lang.Apply(tmp10, []any{v3})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							tmp13 = v12
						} else {
							tmp14 := checkDerefVar(var_glojure_DOT_core_decimal_QMARK_)
							tmp15 := lang.Apply(tmp14, []any{v3})
							tmp13 = tmp15
						}
						tmp9 = tmp13
					} // end let
					tmp8 = tmp9
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rationalize
	{
		tmp0 := sym_rationalize.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_doc, "returns the rational value of num", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(1282), kw_end_DASH_line, int(1282))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Rationalize")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Rationalize is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-find
	{
		tmp0 := sym_re_DASH_find.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m), lang.NewVector(sym_re, sym_s)), kw_doc, "Returns the next regex match, if any, of string to pattern, using\n  java.util.regex.Matcher.find().  Uses re-groups to return the\n  groups.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4922), kw_end_DASH_line, int(4922))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5, _ := lang.FieldOrMethod(v3, "find")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("find is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{})
				if lang.IsTruthy(tmp6) {
					tmp7 := checkDerefVar(var_glojure_DOT_core_re_DASH_groups)
					tmp8 := lang.Apply(tmp7, []any{v3})
					tmp4 = tmp8
				} else {
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "m"
					tmp6 := checkDerefVar(var_glojure_DOT_core_re_DASH_matcher)
					tmp7 := lang.Apply(tmp6, []any{v3, v4})
					var v8 any = tmp7
					_ = v8
					tmp9 := checkDerefVar(var_glojure_DOT_core_re_DASH_find)
					tmp10 := lang.Apply(tmp9, []any{v8})
					tmp5 = tmp10
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-groups
	{
		tmp0 := sym_re_DASH_groups.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m)), kw_doc, "Returns the groups from the most recent match/find. If there are no\n  nested groups, returns a string of the entire match. If there are\n  nested groups, returns a vector of the groups, the first element\n  being the entire match.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4882), kw_end_DASH_line, int(4882))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "gc"
				tmp5, _ := lang.FieldOrMethod(v3, "groupCount")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("groupCount is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				tmp9 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
				tmp10 := lang.Apply(tmp9, []any{v7})
				if lang.IsTruthy(tmp10) {
					tmp11, _ := lang.FieldOrMethod(v3, "group")
					if reflect.TypeOf(tmp11).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("group is not a function")))
					}
					tmp12 := lang.Apply(tmp11, []any{})
					tmp8 = tmp12
				} else {
					var tmp13 any
					{ // let
						// let binding "ret"
						tmp14 := lang.NewVector()
						tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4893), kw_column, int(20), kw_end_DASH_line, int(4893), kw_end_DASH_column, int(21))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v17 any = tmp16
						_ = v17
						// let binding "c"
						var v18 any = int64(0)
						_ = v18
						for {
							var tmp19 any
							tmp20 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
							tmp21 := lang.Apply(tmp20, []any{v18, v7})
							if lang.IsTruthy(tmp21) {
								tmp23 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp24, _ := lang.FieldOrMethod(v3, "groupInt")
								if reflect.TypeOf(tmp24).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("groupInt is not a function")))
								}
								tmp25 := lang.Apply(tmp24, []any{v18})
								tmp26 := lang.Apply(tmp23, []any{v17, tmp25})
								var tmp22 any = tmp26
								tmp28 := checkDerefVar(var_glojure_DOT_core_inc)
								tmp29 := lang.Apply(tmp28, []any{v18})
								var tmp27 any = tmp29
								v17 = tmp22
								v18 = tmp27
								continue
							} else {
								tmp19 = v17
							}
							tmp13 = tmp19
							break
						}
					} // end let
					tmp8 = tmp13
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-matcher
	{
		tmp1 := reflect.TypeOf((*lang.RegexpMatcher)(nil))
		tmp0 := sym_re_DASH_matcher.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_re, sym_s)), kw_doc, "Returns an instance of java.util.regex.Matcher, for use, e.g. in\n  re-find.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4873), kw_end_DASH_line, int(4873))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := lang.Apply(lang.NewRegexpMatcher, []any{v4, v5})
			return tmp6
		})
		tmp4 := reflect.TypeOf((*lang.RegexpMatcher)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-matches
	{
		tmp0 := sym_re_DASH_matches.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_re, sym_s)), kw_doc, "Returns the match, if any, of string to pattern, using\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\n  groups.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4910), kw_end_DASH_line, int(4910))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "m"
				tmp6 := checkDerefVar(var_glojure_DOT_core_re_DASH_matcher)
				tmp7 := lang.Apply(tmp6, []any{v3, v4})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				tmp10, _ := lang.FieldOrMethod(v8, "matches")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("matches is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{})
				if lang.IsTruthy(tmp11) {
					tmp12 := checkDerefVar(var_glojure_DOT_core_re_DASH_groups)
					tmp13 := lang.Apply(tmp12, []any{v8})
					tmp9 = tmp13
				} else {
				}
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-pattern
	{
		tmp1 := reflect.TypeOf((*regexp15.Regexp)(nil))
		tmp0 := sym_re_DASH_pattern.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Returns an instance of java.util.regex.Pattern, for use, e.g. in\n  re-matcher.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4863), kw_end_DASH_line, int(4863))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp7 := reflect.TypeOf((*regexp15.Regexp)(nil))
			tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
			if lang.IsTruthy(tmp8) {
				tmp5 = v4
			} else {
				tmp9 := lang.Apply(regexp15.MustCompile, []any{v4})
				tmp5 = tmp9
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*regexp15.Regexp)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-seq
	{
		tmp0 := sym_re_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_re, sym_s)), kw_doc, "Returns a lazy sequence of successive matches of pattern in string,\n  using java.util.regex.Matcher.find(), each such match processed with\n  re-groups.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4898), kw_end_DASH_line, int(4898))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "m"
				tmp6 := checkDerefVar(var_glojure_DOT_core_re_DASH_matcher)
				tmp7 := lang.Apply(tmp6, []any{v3, v4})
				var v8 any = tmp7
				_ = v8
				var tmp9 lang.FnFunc
				{ // function step
					var v10 lang.FnFunc
					tmp9 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						var tmp11 any
						tmp12, _ := lang.FieldOrMethod(v8, "find")
						if reflect.TypeOf(tmp12).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("find is not a function")))
						}
						tmp13 := lang.Apply(tmp12, []any{})
						if lang.IsTruthy(tmp13) {
							tmp14 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp15 := checkDerefVar(var_glojure_DOT_core_re_DASH_groups)
							tmp16 := lang.Apply(tmp15, []any{v8})
							var tmp17 lang.FnFunc
							tmp17 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								tmp18 := lang.Apply(v10, nil)
								return tmp18
							})
							tmp18 := lang.Apply(lang.NewLazySeq, []any{tmp17})
							tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
							tmp11 = tmp19
						} else {
						}
						return tmp11
					})
					v10 = tmp9
					_ = v10
				}
				tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4906), kw_column, int(6), kw_end_DASH_line, int(4908), kw_end_DASH_column, int(49))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := lang.Apply(tmp11, nil)
				tmp5 = tmp12
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read
	{
		tmp0 := sym_read.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_stream), lang.NewVector(sym_stream, sym_eof_DASH_error_QMARK_, sym_eof_DASH_value), lang.NewVector(sym_stream, sym_eof_DASH_error_QMARK_, sym_eof_DASH_value, sym_recursive_QMARK_), lang.NewVector(sym_opts, sym_stream)), kw_doc, "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n  Note that read can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use glojure.edn/read", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3742), kw_end_DASH_line, int(3742))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(var_glojure_DOT_core_read)
				tmp4 := checkDerefVar(var_glojure_DOT_core__STAR_in_STAR_)
				tmp5 := lang.Apply(tmp3, []any{tmp4})
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_read)
				tmp5 := lang.Apply(tmp4, []any{v3, true, nil})
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_read)
				tmp7 := lang.Apply(tmp6, []any{v3, v4, v5, false})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_boolean)
				tmp8 := lang.Apply(tmp7, []any{v4})
				tmp9, _ := lang.FieldOrMethod(nil, "read")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("read is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{v3, tmp8, v5, v6})
				return tmp10
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(nil, "read")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("read is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4, v3})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read+string
	{
		tmp0 := sym_read_PLUS_string.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_stream), lang.NewVector(sym_stream, sym_eof_DASH_error_QMARK_, sym_eof_DASH_value), lang.NewVector(sym_stream, sym_eof_DASH_error_QMARK_, sym_eof_DASH_value, sym_recursive_QMARK_), lang.NewVector(sym_opts, sym_stream)), kw_doc, "Like read, and taking the same args. stream must be a LineNumberingPushbackReader.\n  Returns a vector containing the object read and the (whitespace-trimmed) string read.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(3771), kw_end_DASH_line, int(3771))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := checkDerefVar(var_glojure_DOT_core_read_PLUS_string)
				tmp4 := checkDerefVar(var_glojure_DOT_core__STAR_in_STAR_)
				tmp5 := lang.Apply(tmp3, []any{tmp4})
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_read_PLUS_string)
				tmp5 := lang.Apply(tmp4, []any{v3, true, nil})
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_read_PLUS_string)
				tmp7 := lang.Apply(tmp6, []any{v3, v4, v5, false})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							if lang.CatchMatches(r, lang.Throwable) {
								v8 := r
								_ = v8
								tmp9, ok := lang.FieldOrMethod(v3, "getString")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getString")))
								}
								var tmp10 any
								switch reflect.TypeOf(tmp9).Kind() {
								case reflect.Func:
									tmp10 = lang.Apply(tmp9, nil)
								default:
									tmp10 = tmp9
								}
								_ = tmp10
								panic(v8)
							} else {
								panic(r)
							}
						}
					}()
					tmp8, ok := lang.FieldOrMethod(v3, "captureString")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "captureString")))
					}
					var tmp9 any
					switch reflect.TypeOf(tmp8).Kind() {
					case reflect.Func:
						tmp9 = lang.Apply(tmp8, nil)
					default:
						tmp9 = tmp8
					}
					_ = tmp9
					var tmp10 any
					{ // let
						// let binding "o"
						tmp11 := checkDerefVar(var_glojure_DOT_core_read)
						tmp12 := lang.Apply(tmp11, []any{v3, v4, v5, v6})
						var v13 any = tmp12
						_ = v13
						// let binding "s"
						tmp14, ok := lang.FieldOrMethod(v3, "getString")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getString")))
						}
						var tmp15 any
						switch reflect.TypeOf(tmp14).Kind() {
						case reflect.Func:
							tmp15 = lang.Apply(tmp14, nil)
						default:
							tmp15 = tmp14
						}
						tmp16, ok := lang.FieldOrMethod(tmp15, "trim")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp15, "trim")))
						}
						var tmp17 any
						switch reflect.TypeOf(tmp16).Kind() {
						case reflect.Func:
							tmp17 = lang.Apply(tmp16, nil)
						default:
							tmp17 = tmp16
						}
						var v18 any = tmp17
						_ = v18
						tmp19 := lang.NewVector(v13, v18)
						tmp20 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3783), kw_column, int(8), kw_end_DASH_line, int(3783), kw_end_DASH_column, int(12))
						tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp10 = tmp21
					} // end let
					tmp7 = tmp10
				}()
				return tmp7
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							if lang.CatchMatches(r, lang.Throwable) {
								v6 := r
								_ = v6
								tmp7, ok := lang.FieldOrMethod(v4, "getString")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getString")))
								}
								var tmp8 any
								switch reflect.TypeOf(tmp7).Kind() {
								case reflect.Func:
									tmp8 = lang.Apply(tmp7, nil)
								default:
									tmp8 = tmp7
								}
								_ = tmp8
								panic(v6)
							} else {
								panic(r)
							}
						}
					}()
					tmp6, ok := lang.FieldOrMethod(v4, "captureString")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "captureString")))
					}
					var tmp7 any
					switch reflect.TypeOf(tmp6).Kind() {
					case reflect.Func:
						tmp7 = lang.Apply(tmp6, nil)
					default:
						tmp7 = tmp6
					}
					_ = tmp7
					var tmp8 any
					{ // let
						// let binding "o"
						tmp9 := checkDerefVar(var_glojure_DOT_core_read)
						tmp10 := lang.Apply(tmp9, []any{v3, v4})
						var v11 any = tmp10
						_ = v11
						// let binding "s"
						tmp12, ok := lang.FieldOrMethod(v4, "getString")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getString")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						tmp14, ok := lang.FieldOrMethod(tmp13, "trim")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp13, "trim")))
						}
						var tmp15 any
						switch reflect.TypeOf(tmp14).Kind() {
						case reflect.Func:
							tmp15 = lang.Apply(tmp14, nil)
						default:
							tmp15 = tmp14
						}
						var v16 any = tmp15
						_ = v16
						tmp17 := lang.NewVector(v11, v16)
						tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3792), kw_column, int(8), kw_end_DASH_line, int(3792), kw_end_DASH_column, int(12))
						tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp19
					} // end let
					tmp5 = tmp8
				}()
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read-line
	{
		tmp0 := sym_read_DASH_line.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Reads the next line from stream that is the current value of *in* .", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3797), kw_end_DASH_line, int(3797))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			var tmp3 any
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_in_STAR_)
			tmp6 := lang.Apply(tmp4, []any{nil, tmp5})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core__STAR_in_STAR_)
				tmp8, ok := lang.FieldOrMethod(tmp7, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp7, "readLine")))
				}
				var tmp9 any
				switch reflect.TypeOf(tmp8).Kind() {
				case reflect.Func:
					tmp9 = lang.Apply(tmp8, nil)
				default:
					tmp9 = tmp8
				}
				tmp3 = tmp9
			} else {
				tmp10 := checkDerefVar(var_glojure_DOT_core__STAR_in_STAR_)
				tmp11, ok := lang.FieldOrMethod(tmp10, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp10, "readLine")))
				}
				var tmp12 any
				switch reflect.TypeOf(tmp11).Kind() {
				case reflect.Func:
					tmp12 = lang.Apply(tmp11, nil)
				default:
					tmp12 = tmp11
				}
				tmp3 = tmp12
			}
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read-string
	{
		tmp0 := sym_read_DASH_string.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s), lang.NewVector(sym_opts, sym_s)), kw_doc, "Reads one object from the string s. Optionally include reader\n  options, as specified in read.\n\n  Note that read-string can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use glojure.edn/read-string", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(3806), kw_end_DASH_line, int(3806))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(runtime.RTReadString, []any{v3})
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(runtime.RTReadString, []any{v4, v3})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reader-conditional
	{
		tmp0 := sym_reader_DASH_conditional.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_form, sym_splicing_QMARK_)), kw_doc, "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(7782), kw_end_DASH_line, int(7782))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reader-conditional?
	{
		tmp0 := sym_reader_DASH_conditional_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_value)), kw_doc, "Return true if the value is the data representation of a reader conditional", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(7), kw_line, int(7776), kw_end_DASH_line, int(7776))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// realized?
	{
		tmp0 := sym_realized_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(7559), kw_end_DASH_line, int(7559))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "isRealized")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isRealized")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce
	{
		tmp0 := sym_reduce.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_val, sym_coll)), kw_doc, "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6860), kw_end_DASH_line, int(6860))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IReduce)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
				if lang.IsTruthy(tmp8) {
					tmp9, _ := lang.FieldOrMethod(v4, "Reduce")
					if reflect.TypeOf(tmp9).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Reduce is not a function")))
					}
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp5 = tmp10
				} else {
					tmp11 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_coll_DASH_reduce)
					tmp12 := lang.Apply(tmp11, []any{v4, v3})
					tmp5 = tmp12
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp8 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v5})
				if lang.IsTruthy(tmp9) {
					tmp10, _ := lang.FieldOrMethod(v5, "ReduceInit")
					if reflect.TypeOf(tmp10).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
					}
					tmp11 := lang.Apply(tmp10, []any{v3, v4})
					tmp6 = tmp11
				} else {
					tmp12 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_coll_DASH_reduce)
					tmp13 := lang.Apply(tmp12, []any{v5, v3, v4})
					tmp6 = tmp13
				}
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce-kv
	{
		tmp0 := sym_reduce_DASH_kv.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_init, sym_coll)), kw_doc, "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", kw_file, "glojure/core.glj", kw_added, "1.4", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(6882), kw_end_DASH_line, int(6882))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_kv_DASH_reduce)
			tmp7 := lang.Apply(tmp6, []any{v5, v3, v4})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce1
	{
		tmp0 := sym_reduce1.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(923), kw_column, int(7), kw_end_DASH_line, int(924), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_val, sym_coll)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s"
					tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp7 := lang.Apply(tmp6, []any{v4})
					var v8 any = tmp7
					_ = v8
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp10 := checkDerefVar(var_glojure_DOT_core_reduce1)
						tmp11 := checkDerefVar(var_glojure_DOT_core_first)
						tmp12 := lang.Apply(tmp11, []any{v8})
						tmp13 := checkDerefVar(var_glojure_DOT_core_next)
						tmp14 := lang.Apply(tmp13, []any{v8})
						tmp15 := lang.Apply(tmp10, []any{v3, tmp12, tmp14})
						tmp9 = tmp15
					} else {
						tmp16 := lang.Apply(v3, nil)
						tmp9 = tmp16
					}
					tmp5 = tmp9
				} // end let
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
			recur_loop_156:
				var tmp6 any
				{ // let
					// let binding "s"
					tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp8 := lang.Apply(tmp7, []any{v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						var tmp11 any
						tmp12 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
						tmp13 := lang.Apply(tmp12, []any{v9})
						if lang.IsTruthy(tmp13) {
							var tmp14 any = v3
							tmp16 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
							tmp17 := lang.Apply(tmp16, []any{v9})
							tmp18, _ := lang.FieldOrMethod(tmp17, "ReduceInit")
							if reflect.TypeOf(tmp18).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
							}
							tmp19 := lang.Apply(tmp18, []any{v3, v4})
							var tmp15 any = tmp19
							tmp21 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_next)
							tmp22 := lang.Apply(tmp21, []any{v9})
							var tmp20 any = tmp22
							v3 = tmp14
							v4 = tmp15
							v5 = tmp20
							goto recur_loop_156
						} else {
							var tmp23 any = v3
							tmp25 := checkDerefVar(var_glojure_DOT_core_first)
							tmp26 := lang.Apply(tmp25, []any{v9})
							tmp27 := lang.Apply(v3, []any{v4, tmp26})
							var tmp24 any = tmp27
							tmp29 := checkDerefVar(var_glojure_DOT_core_next)
							tmp30 := lang.Apply(tmp29, []any{v9})
							var tmp28 any = tmp30
							v3 = tmp23
							v4 = tmp24
							v5 = tmp28
							goto recur_loop_156
						}
						tmp10 = tmp11
					} else {
						tmp10 = v4
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduced
	{
		tmp0 := sym_reduced.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Wraps x in a way such that a reduce will terminate with the value x", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(2828), kw_end_DASH_line, int(2828))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.NewReduced, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduced?
	{
		var tmp1 lang.FnFunc
		{ // function reduced?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_IsReduced})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp5, []any{tmp7, tmp9})
				tmp11 := lang.Apply(tmp4, []any{tmp10})
				return tmp11
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_reduced_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns true if x is the result of a call to reduced", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2834), kw_end_DASH_line, int(2834))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.IsReduced, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reductions
	{
		tmp0 := sym_reductions.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_coll), lang.NewVector(sym_f, sym_init, sym_coll)), kw_doc, "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7196), kw_end_DASH_line, int(7196))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								tmp13 := checkDerefVar(var_glojure_DOT_core_reductions)
								tmp14 := checkDerefVar(var_glojure_DOT_core_first)
								tmp15 := lang.Apply(tmp14, []any{v12})
								tmp16 := checkDerefVar(var_glojure_DOT_core_rest)
								tmp17 := lang.Apply(tmp16, []any{v12})
								tmp18 := lang.Apply(tmp13, []any{v3, tmp15, tmp17})
								tmp11 = tmp18
							} // end let
							tmp10 = tmp11
						} else {
							tmp12 := checkDerefVar(var_glojure_DOT_core_list)
							tmp13 := lang.Apply(v3, nil)
							tmp14 := lang.Apply(tmp12, []any{tmp13})
							tmp10 = tmp14
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
				tmp8 := lang.Apply(tmp7, []any{v4})
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_list)
					tmp10 := checkDerefVar(var_glojure_DOT_core_deref)
					tmp11 := lang.Apply(tmp10, []any{v4})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					tmp6 = tmp12
				} else {
					tmp13 := checkDerefVar(var_glojure_DOT_core_cons)
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						var tmp15 any
						{ // let
							// let binding "temp__0__auto__"
							tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp17 := lang.Apply(tmp16, []any{v5})
							var v18 any = tmp17
							_ = v18
							var tmp19 any
							if lang.IsTruthy(v18) {
								var tmp20 any
								{ // let
									// let binding "s"
									var v21 any = v18
									_ = v21
									tmp22 := checkDerefVar(var_glojure_DOT_core_reductions)
									tmp23 := checkDerefVar(var_glojure_DOT_core_first)
									tmp24 := lang.Apply(tmp23, []any{v21})
									tmp25 := lang.Apply(v3, []any{v4, tmp24})
									tmp26 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp27 := lang.Apply(tmp26, []any{v21})
									tmp28 := lang.Apply(tmp22, []any{v3, tmp25, tmp27})
									tmp20 = tmp28
								} // end let
								tmp19 = tmp20
							} else {
							}
							tmp15 = tmp19
						} // end let
						return tmp15
					})
					tmp15 := lang.Apply(lang.NewLazySeq, []any{tmp14})
					tmp16 := lang.Apply(tmp13, []any{v4, tmp15})
					tmp6 = tmp16
				}
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref
	{
		tmp0 := sym_ref.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_options)), kw_doc, "Creates and returns a Ref with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :min-history (default 0)\n  :max-history (default 10)\n\n  If metadata-map is supplied, it will become the metadata on the\n  ref. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception. validate-fn will be called on\n  transaction commit, when all refs have their final values.\n\n  Normally refs accumulate history dynamically as needed to deal with\n  read demands. If you know in advance you will need history you can\n  set :min-history to ensure it will be available when first needed (instead\n  of after a read fault). History is limited, and the limit can be set\n  with :max-history.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(2260), kw_end_DASH_line, int(2260))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(lang.NewRef, []any{v3})
				return tmp4
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "r"
					tmp6 := checkDerefVar(var_glojure_DOT_core_setup_DASH_reference)
					tmp7 := checkDerefVar(var_glojure_DOT_core_ref)
					tmp8 := lang.Apply(tmp7, []any{v3})
					tmp9 := lang.Apply(tmp6, []any{tmp8, v4})
					var v10 any = tmp9
					_ = v10
					// let binding "opts"
					tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp12 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp13 := lang.Apply(tmp11, []any{tmp12, v4})
					var v14 any = tmp13
					_ = v14
					var tmp15 any
					tmp16 := lang.Apply(kw_max_DASH_history, []any{v14})
					if lang.IsTruthy(tmp16) {
						tmp17 := lang.Apply(kw_max_DASH_history, []any{v14})
						tmp18, _ := lang.FieldOrMethod(v10, "setMaxHistory")
						if reflect.TypeOf(tmp18).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMaxHistory is not a function")))
						}
						tmp19 := lang.Apply(tmp18, []any{tmp17})
						tmp15 = tmp19
					} else {
					}
					_ = tmp15
					var tmp20 any
					tmp21 := lang.Apply(kw_min_DASH_history, []any{v14})
					if lang.IsTruthy(tmp21) {
						tmp22 := lang.Apply(kw_min_DASH_history, []any{v14})
						tmp23, _ := lang.FieldOrMethod(v10, "setMinHistory")
						if reflect.TypeOf(tmp23).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMinHistory is not a function")))
						}
						tmp24 := lang.Apply(tmp23, []any{tmp22})
						tmp20 = tmp24
					} else {
					}
					_ = tmp20
					tmp5 = v10
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-history-count
	{
		tmp0 := sym_ref_DASH_history_DASH_count.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref)), kw_doc, "Returns the history count of a ref", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(2455), kw_end_DASH_line, int(2455))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getHistoryCount")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getHistoryCount")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-max-history
	{
		tmp0 := sym_ref_DASH_max_DASH_history.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref), lang.NewVector(sym_ref, sym_n)), kw_doc, "Gets the max-history of a ref, or sets it and returns the ref", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(2471), kw_end_DASH_line, int(2471))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, ok := lang.FieldOrMethod(v3, "getMaxHistory")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMaxHistory")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "setMaxHistory")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMaxHistory is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-min-history
	{
		tmp0 := sym_ref_DASH_min_DASH_history.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref), lang.NewVector(sym_ref, sym_n)), kw_doc, "Gets the min-history of a ref, or sets it and returns the ref", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(2462), kw_end_DASH_line, int(2462))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, ok := lang.FieldOrMethod(v3, "getMinHistory")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMinHistory")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "setMinHistory")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMinHistory is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-set
	{
		tmp0 := sym_ref_DASH_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ref, sym_val)), kw_doc, "Must be called in a transaction. Sets the value of ref.\n  Returns val.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(2447), kw_end_DASH_line, int(2447))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "set")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("set is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// refer
	{
		tmp0 := sym_refer.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_ns_DASH_sym, sym__AMP_, sym_filters)), kw_doc, "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(4216), kw_end_DASH_line, int(4216))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "ns"
					var tmp6 any
					{ // let
						// let binding "or__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_find_DASH_ns)
						tmp8 := lang.Apply(tmp7, []any{v3})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							tmp10 = v9
						} else {
							tmp11 := checkDerefVar(var_glojure_DOT_core_str)
							tmp12 := lang.Apply(tmp11, []any{"No namespace: ", v3})
							tmp13 := lang.Apply(errors8.New, []any{tmp12})
							panic(tmp13)
						}
						tmp6 = tmp10
					} // end let
					var v7 any = tmp6
					_ = v7
					// let binding "fs"
					tmp8 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp9 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp10 := lang.Apply(tmp8, []any{tmp9, v4})
					var v11 any = tmp10
					_ = v11
					// let binding "nspublics"
					tmp12 := checkDerefVar(var_glojure_DOT_core_ns_DASH_publics)
					tmp13 := lang.Apply(tmp12, []any{v7})
					var v14 any = tmp13
					_ = v14
					// let binding "rename"
					var tmp15 any
					{ // let
						// let binding "or__0__auto__"
						tmp16 := lang.Apply(kw_rename, []any{v11})
						var v17 any = tmp16
						_ = v17
						var tmp18 any
						if lang.IsTruthy(v17) {
							tmp18 = v17
						} else {
							tmp19 := lang.NewMap()
							tmp20 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4236), kw_column, int(35), kw_end_DASH_line, int(4236), kw_end_DASH_column, int(36))
							tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp18 = tmp21
						}
						tmp15 = tmp18
					} // end let
					var v16 any = tmp15
					_ = v16
					// let binding "exclude"
					tmp17 := checkDerefVar(var_glojure_DOT_core_set)
					tmp18 := lang.Apply(kw_exclude, []any{v11})
					tmp19 := lang.Apply(tmp17, []any{tmp18})
					var v20 any = tmp19
					_ = v20
					// let binding "to-do"
					var tmp21 any
					tmp22 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp23 := lang.Apply(kw_refer, []any{v11})
					tmp24 := lang.Apply(tmp22, []any{kw_all, tmp23})
					if lang.IsTruthy(tmp24) {
						tmp25 := checkDerefVar(var_glojure_DOT_core_keys)
						tmp26 := lang.Apply(tmp25, []any{v14})
						tmp21 = tmp26
					} else {
						var tmp27 any
						{ // let
							// let binding "or__0__auto__"
							tmp28 := lang.Apply(kw_refer, []any{v11})
							var v29 any = tmp28
							_ = v29
							var tmp30 any
							if lang.IsTruthy(v29) {
								tmp30 = v29
							} else {
								var tmp31 any
								{ // let
									// let binding "or__0__auto__"
									tmp32 := lang.Apply(kw_only, []any{v11})
									var v33 any = tmp32
									_ = v33
									var tmp34 any
									if lang.IsTruthy(v33) {
										tmp34 = v33
									} else {
										tmp35 := checkDerefVar(var_glojure_DOT_core_keys)
										tmp36 := lang.Apply(tmp35, []any{v14})
										tmp34 = tmp36
									}
									tmp31 = tmp34
								} // end let
								tmp30 = tmp31
							}
							tmp27 = tmp30
						} // end let
						tmp21 = tmp27
					}
					var v28 any = tmp21
					_ = v28
					var tmp29 any
					var tmp30 any
					{ // let
						// let binding "and__0__auto__"
						var v31 any = v28
						_ = v31
						var tmp32 any
						if lang.IsTruthy(v31) {
							tmp33 := checkDerefVar(var_glojure_DOT_core_not)
							tmp34 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
							tmp35 := reflect.TypeOf((*lang.Sequential)(nil)).Elem()
							tmp36 := lang.Apply(tmp34, []any{tmp35, v28})
							tmp37 := lang.Apply(tmp33, []any{tmp36})
							tmp32 = tmp37
						} else {
							tmp32 = v31
						}
						tmp30 = tmp32
					} // end let
					if lang.IsTruthy(tmp30) {
						tmp31 := lang.Apply(errors8.New, []any{":only/:refer value must be a sequential collection of symbols"})
						panic(tmp31)
					} else {
					}
					_ = tmp29
					var tmp32 any
					{ // let
						// let binding "seq_9"
						tmp33 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp34 := lang.Apply(tmp33, []any{v28})
						var v35 any = tmp34
						_ = v35
						// let binding "chunk_10"
						var v36 any = nil
						_ = v36
						// let binding "count_11"
						var v37 any = int64(0)
						_ = v37
						// let binding "i_12"
						var v38 any = int64(0)
						_ = v38
						for {
							var tmp39 any
							tmp40 := checkDerefVar(var_glojure_DOT_core__LT_)
							tmp41 := lang.Apply(tmp40, []any{v38, v37})
							if lang.IsTruthy(tmp41) {
								var tmp42 any
								{ // let
									// let binding "sym"
									tmp43, _ := lang.FieldOrMethod(v36, "nth")
									if reflect.TypeOf(tmp43).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp44 := lang.Apply(tmp43, []any{v38})
									var v45 any = tmp44
									_ = v45
									var tmp46 any
									tmp47 := lang.Apply(v20, []any{v45})
									if lang.IsTruthy(tmp47) {
									} else {
										var tmp48 any
										{ // let
											// let binding "v"
											tmp49 := lang.Apply(v14, []any{v45})
											var v50 any = tmp49
											_ = v50
											var tmp51 any
											if lang.IsTruthy(v50) {
											} else {
												panic("unimplemented: new with non-constant class type")
											}
											_ = tmp51
											tmp52 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
											var tmp53 any
											{ // let
												// let binding "or__0__auto__"
												tmp54 := lang.Apply(v16, []any{v45})
												var v55 any = tmp54
												_ = v55
												var tmp56 any
												if lang.IsTruthy(v55) {
													tmp56 = v55
												} else {
													tmp56 = v45
												}
												tmp53 = tmp56
											} // end let
											tmp54, _ := lang.FieldOrMethod(tmp52, "Refer")
											if reflect.TypeOf(tmp54).Kind() != reflect.Func {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("Refer is not a function")))
											}
											tmp55 := lang.Apply(tmp54, []any{tmp53, v50})
											tmp48 = tmp55
										} // end let
										tmp46 = tmp48
									}
									_ = tmp46
									var tmp49 any = v35
									var tmp50 any = v36
									var tmp51 any = v37
									tmp53 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
									tmp54 := lang.Apply(tmp53, []any{v38})
									var tmp52 any = tmp54
									v35 = tmp49
									v36 = tmp50
									v37 = tmp51
									v38 = tmp52
									continue
								} // end let
								tmp39 = tmp42
							} else {
								var tmp43 any
								{ // let
									// let binding "temp__0__auto__"
									tmp44 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp45 := lang.Apply(tmp44, []any{v35})
									var v46 any = tmp45
									_ = v46
									var tmp47 any
									if lang.IsTruthy(v46) {
										var tmp48 any
										{ // let
											// let binding "seq_9"
											var v49 any = v46
											_ = v49
											var tmp50 any
											tmp51 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
											tmp52 := lang.Apply(tmp51, []any{v49})
											if lang.IsTruthy(tmp52) {
												var tmp53 any
												{ // let
													// let binding "c__0__auto__"
													tmp54 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
													tmp55 := lang.Apply(tmp54, []any{v49})
													var v56 any = tmp55
													_ = v56
													tmp58 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
													tmp59 := lang.Apply(tmp58, []any{v49})
													var tmp57 any = tmp59
													var tmp60 any = v56
													tmp62 := checkDerefVar(var_glojure_DOT_core_int)
													tmp63 := checkDerefVar(var_glojure_DOT_core_count)
													tmp64 := lang.Apply(tmp63, []any{v56})
													tmp65 := lang.Apply(tmp62, []any{tmp64})
													var tmp61 any = tmp65
													tmp67 := checkDerefVar(var_glojure_DOT_core_int)
													tmp68 := lang.Apply(tmp67, []any{int64(0)})
													var tmp66 any = tmp68
													v35 = tmp57
													v36 = tmp60
													v37 = tmp61
													v38 = tmp66
													continue
												} // end let
												tmp50 = tmp53
											} else {
												var tmp54 any
												{ // let
													// let binding "sym"
													tmp55 := checkDerefVar(var_glojure_DOT_core_first)
													tmp56 := lang.Apply(tmp55, []any{v49})
													var v57 any = tmp56
													_ = v57
													var tmp58 any
													tmp59 := lang.Apply(v20, []any{v57})
													if lang.IsTruthy(tmp59) {
													} else {
														var tmp60 any
														{ // let
															// let binding "v"
															tmp61 := lang.Apply(v14, []any{v57})
															var v62 any = tmp61
															_ = v62
															var tmp63 any
															if lang.IsTruthy(v62) {
															} else {
																panic("unimplemented: new with non-constant class type")
															}
															_ = tmp63
															tmp64 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
															var tmp65 any
															{ // let
																// let binding "or__0__auto__"
																tmp66 := lang.Apply(v16, []any{v57})
																var v67 any = tmp66
																_ = v67
																var tmp68 any
																if lang.IsTruthy(v67) {
																	tmp68 = v67
																} else {
																	tmp68 = v57
																}
																tmp65 = tmp68
															} // end let
															tmp66, _ := lang.FieldOrMethod(tmp64, "Refer")
															if reflect.TypeOf(tmp66).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("Refer is not a function")))
															}
															tmp67 := lang.Apply(tmp66, []any{tmp65, v62})
															tmp60 = tmp67
														} // end let
														tmp58 = tmp60
													}
													_ = tmp58
													tmp62 := checkDerefVar(var_glojure_DOT_core_next)
													tmp63 := lang.Apply(tmp62, []any{v49})
													var tmp61 any = tmp63
													var tmp64 any = nil
													var tmp65 any = int64(0)
													var tmp66 any = int64(0)
													v35 = tmp61
													v36 = tmp64
													v37 = tmp65
													v38 = tmp66
													continue
												} // end let
												tmp50 = tmp54
											}
											tmp48 = tmp50
										} // end let
										tmp47 = tmp48
									} else {
									}
									tmp43 = tmp47
								} // end let
								tmp39 = tmp43
							}
							tmp32 = tmp39
							break
						}
					} // end let
					tmp5 = tmp32
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// refer-glojure
	{
		tmp0 := sym_refer_DASH_glojure.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_filters)), kw_doc, "Same as (refer 'glojure.core <filters>)", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(11), kw_line, int(5800), kw_end_DASH_line, int(5800))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_refer})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_quote})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp7, []any{tmp9, tmp19, v5})
				tmp21 := lang.Apply(tmp6, []any{tmp20})
				return tmp21
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// release-pending-sends
	{
		tmp0 := sym_release_DASH_pending_DASH_sends.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Normally, actions sent directly or indirectly during another action\n  are held until the action completes (changes the agent's\n  state). This function can be used to dispatch any pending sent\n  actions immediately. This has no impact on actions sent during a\n  transaction, which are still held until commit. If no action is\n  occurring, does nothing. Returns the number of actions dispatched.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(27), kw_column, int(7), kw_line, int(2131), kw_end_DASH_line, int(2131))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := lang.Apply(nil, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rem
	{
		var tmp1 lang.FnFunc
		{ // function rem__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Remainder})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_rem.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num, sym_div)), kw_inline, tmp1, kw_doc, "remainder of dividing numerator by denominator.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1274), kw_end_DASH_line, int(1274))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Remainder")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Remainder is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove
	{
		tmp0 := sym_remove.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred), lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2818), kw_end_DASH_line, int(2818))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_filter)
				tmp5 := checkDerefVar(var_glojure_DOT_core_complement)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(tmp4, []any{tmp6})
				return tmp7
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_filter)
				tmp6 := checkDerefVar(var_glojure_DOT_core_complement)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := lang.Apply(tmp5, []any{tmp7, v4})
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-all-methods
	{
		tmp0 := sym_remove_DASH_all_DASH_methods.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn)), kw_doc, "Removes all of the methods of multimethod.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(1787), kw_end_DASH_line, int(1787))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "reset")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "reset")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-method
	{
		tmp0 := sym_remove_DASH_method.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_multifn, sym_dispatch_DASH_val)), kw_doc, "Removes the method of multimethod associated with dispatch-value.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1794), kw_end_DASH_line, int(1794))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "removeMethod")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeMethod is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-ns
	{
		tmp0 := sym_remove_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_doc, "Removes the namespace named by the symbol. Use with caution.\n  Cannot be used to remove the glojure namespace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(4139), kw_end_DASH_line, int(4139))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.RemoveNamespace, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-tap
	{
		tmp0 := sym_remove_DASH_tap.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f)), kw_doc, "Remove f from the tap set.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(7883), kw_end_DASH_line, int(7883))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_swap_BANG_)
			tmp5 := checkDerefVar(var_glojure_DOT_core_tapset)
			tmp6 := checkDerefVar(var_glojure_DOT_core_disj)
			tmp7 := lang.Apply(tmp4, []any{tmp5, tmp6, v3})
			_ = tmp7
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-watch
	{
		tmp0 := sym_remove_DASH_watch.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_reference, sym_key)), kw_doc, "Removes a watch (set by add-watch) from a reference", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(2160), kw_end_DASH_line, int(2160))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "removeWatch")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeWatch is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// repeat
	{
		tmp0 := sym_repeat.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x), lang.NewVector(sym_n, sym_x)), kw_doc, "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2997), kw_end_DASH_line, int(2997))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(lang.NewRepeat, []any{v3})
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.NewRepeatN, []any{v3, v4})
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// repeatedly
	{
		tmp0 := sym_repeatedly.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_n, sym_f)), kw_doc, "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(5167), kw_end_DASH_line, int(5167))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					tmp5 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp6 := lang.Apply(v3, nil)
					tmp7 := checkDerefVar(var_glojure_DOT_core_repeatedly)
					tmp8 := lang.Apply(tmp7, []any{v3})
					tmp9 := lang.Apply(tmp5, []any{tmp6, tmp8})
					return tmp9
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_take)
				tmp6 := checkDerefVar(var_glojure_DOT_core_repeatedly)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{v3, tmp7})
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace
	{
		tmp0 := sym_replace.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_smap), lang.NewVector(sym_smap, sym_coll)), kw_doc, "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5082), kw_end_DASH_line, int(5082))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v6 := args[0]
					_ = v6
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := checkDerefVar(var_glojure_DOT_core_find)
						tmp9 := lang.Apply(tmp8, []any{v3, v6})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							var tmp12 any
							{ // let
								// let binding "e"
								var v13 any = v10
								_ = v13
								tmp14 := checkDerefVar(var_glojure_DOT_core_val)
								tmp15 := lang.Apply(tmp14, []any{v13})
								tmp12 = tmp15
							} // end let
							tmp11 = tmp12
						} else {
							tmp11 = v6
						}
						tmp7 = tmp11
					} // end let
					return tmp7
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5090), kw_column, int(11), kw_end_DASH_line, int(5090), kw_end_DASH_column, int(47))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7})
				return tmp8
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp8 := checkDerefVar(var_glojure_DOT_core_reduce1)
					var tmp9 lang.FnFunc
					tmp9 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v10 := args[0]
						_ = v10
						v11 := args[1]
						_ = v11
						var tmp12 any
						{ // let
							// let binding "temp__0__auto__"
							tmp13 := checkDerefVar(var_glojure_DOT_core_find)
							tmp14 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp15 := lang.Apply(tmp14, []any{v10, v11})
							tmp16 := lang.Apply(tmp13, []any{v3, tmp15})
							var v17 any = tmp16
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								var tmp19 any
								{ // let
									// let binding "e"
									var v20 any = v17
									_ = v20
									tmp21 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp22 := checkDerefVar(var_glojure_DOT_core_val)
									tmp23 := lang.Apply(tmp22, []any{v20})
									tmp24 := lang.Apply(tmp21, []any{v10, v11, tmp23})
									tmp19 = tmp24
								} // end let
								tmp18 = tmp19
							} else {
								tmp18 = v10
							}
							tmp12 = tmp18
						} // end let
						return tmp12
					})
					tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5093), kw_column, int(17), kw_end_DASH_line, int(5096), kw_end_DASH_column, int(23))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 := checkDerefVar(var_glojure_DOT_core_range)
					tmp13 := checkDerefVar(var_glojure_DOT_core_count)
					tmp14 := lang.Apply(tmp13, []any{v4})
					tmp15 := lang.Apply(tmp12, []any{tmp14})
					tmp16 := lang.Apply(tmp8, []any{tmp11, v4, tmp15})
					tmp5 = tmp16
				} else {
					tmp17 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp18 lang.FnFunc
					tmp18 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v19 := args[0]
						_ = v19
						var tmp20 any
						{ // let
							// let binding "temp__0__auto__"
							tmp21 := checkDerefVar(var_glojure_DOT_core_find)
							tmp22 := lang.Apply(tmp21, []any{v3, v19})
							var v23 any = tmp22
							_ = v23
							var tmp24 any
							if lang.IsTruthy(v23) {
								var tmp25 any
								{ // let
									// let binding "e"
									var v26 any = v23
									_ = v26
									tmp27 := checkDerefVar(var_glojure_DOT_core_val)
									tmp28 := lang.Apply(tmp27, []any{v26})
									tmp25 = tmp28
								} // end let
								tmp24 = tmp25
							} else {
								tmp24 = v19
							}
							tmp20 = tmp24
						} // end let
						return tmp20
					})
					tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5098), kw_column, int(13), kw_end_DASH_line, int(5098), kw_end_DASH_column, int(49))
					tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp21 := lang.Apply(tmp17, []any{tmp20, v4})
					tmp5 = tmp21
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replicate
	{
		tmp0 := sym_replicate.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_x)), kw_doc, "DEPRECATED: Use 'repeat' instead.\n   Returns a lazy seq of n xs.", kw_file, "glojure/core.glj", kw_deprecated, "1.3", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3004), kw_end_DASH_line, int(3004))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_take)
			tmp6 := checkDerefVar(var_glojure_DOT_core_repeat)
			tmp7 := lang.Apply(tmp6, []any{v4})
			tmp8 := lang.Apply(tmp5, []any{v3, tmp7})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// require
	{
		tmp0 := sym_require.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_args)), kw_doc, "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib, a prefix list that identifies\n  multiple libs whose names share a common prefix, or a flag that modifies\n  how all the identified libs are loaded. Use :require in the ns macro\n  in preference to calling this directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of Clojure code. Lib names are symbols and each lib is associated\n  with a Clojure namespace and a Java package that share its name. A lib's\n  name also locates its root directory within classpath using Java's\n  package name to classpath-relative path mapping. All resources in a lib\n  should be contained in the directory structure under its root directory.\n  All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or\n  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The\n  root resource should contain code to create the lib's\n  namespace (usually by using the ns macro) and load any additional\n  lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :as-alias takes a symbol as its argument and aliases like :as, however\n    the lib will not be loaded. If the lib has not been loaded, a new\n    empty namespace will be created (as with create-ns).\n  :refer takes a list of symbols to refer from the namespace or the :all\n    keyword to bring in all public vars.\n\n  Prefix Lists\n\n  It's common for Clojure code to depend on several libs whose names have\n  the same prefix. When specifying libs, prefix lists can be used to reduce\n  repetition. A prefix list contains the shared prefix followed by libspecs\n  with the shared prefix removed from the lib names. After removing the\n  prefix, the names that remain must not contain any periods.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded (has no effect on libspecs using :as-alias)\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n    (has no effect on libspecs using :as-alias)\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the libraries glojure.zip and glojure.set\n  abbreviated as 's'.\n\n  (require '(glojure zip [set :as s]))", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5989), kw_end_DASH_line, int(5989))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp5 := checkDerefVar(var_glojure_DOT_core_load_DASH_libs)
				tmp6 := lang.Apply(tmp4, []any{tmp5, kw_require, v3})
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// requiring-resolve
	{
		tmp0 := sym_requiring_DASH_resolve.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym)), kw_doc, "Resolves namespace-qualified sym per 'resolve'. If initial resolve\nfails, attempts to require sym's namespace and retries.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(6068), kw_end_DASH_line, int(6068))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_qualified_DASH_symbol_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				var tmp7 any
				{ // let
					// let binding "or__0__auto__"
					tmp8 := checkDerefVar(var_glojure_DOT_core_resolve)
					tmp9 := lang.Apply(tmp8, []any{v3})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						tmp11 = v10
					} else {
						tmp12 := checkDerefVar(var_glojure_DOT_core_serialized_DASH_require)
						tmp13 := checkDerefVar(var_glojure_DOT_core_symbol)
						tmp14 := checkDerefVar(var_glojure_DOT_core_namespace)
						tmp15 := lang.Apply(tmp14, []any{v3})
						tmp16 := lang.Apply(tmp13, []any{tmp15})
						tmp17 := lang.Apply(tmp12, []any{tmp16})
						_ = tmp17
						tmp18 := checkDerefVar(var_glojure_DOT_core_resolve)
						tmp19 := lang.Apply(tmp18, []any{v3})
						tmp11 = tmp19
					}
					tmp7 = tmp11
				} // end let
				tmp4 = tmp7
			} else {
				tmp8 := checkDerefVar(var_glojure_DOT_core_str)
				tmp9 := lang.Apply(tmp8, []any{"Not a qualified symbol: ", v3})
				tmp10 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp9})
				panic(tmp10)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset!
	{
		tmp0 := sym_reset_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atom, sym_newval)), kw_doc, "Sets the value of atom to newval without regard for the\n  current value. Returns newval.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(2368), kw_end_DASH_line, int(2368))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "reset")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset-meta!
	{
		tmp0 := sym_reset_DASH_meta_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_iref, sym_metadata_DASH_map)), kw_doc, "Atomically resets the metadata for a namespace/var/ref/agent/atom", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(2408), kw_end_DASH_line, int(2408))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "ResetMeta")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ResetMeta is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset-vals!
	{
		tmp0 := sym_reset_DASH_vals_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atom, sym_newval)), kw_doc, "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(2375), kw_end_DASH_line, int(2375))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "resetVals")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("resetVals is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// resolve
	{
		tmp0 := sym_resolve.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sym), lang.NewVector(sym_env, sym_sym)), kw_doc, "same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4371), kw_end_DASH_line, int(4371))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_ns_DASH_resolve)
				tmp5 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_ns_DASH_resolve)
				tmp6 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
				tmp7 := lang.Apply(tmp5, []any{tmp6, v3, v4})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rest
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := sym_rest.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(64), kw_end_DASH_line, int(70))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		{ // function rest
			var v4 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.Rest, []any{v5})
				return tmp6
			})
			tmp3 = tmp3.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(70), kw_column, int(7), kw_end_DASH_line, int(70), kw_end_DASH_column, int(77))).(lang.FnFunc)
			v4 = tmp3
			_ = v4
		}
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// restart-agent
	{
		tmp0 := sym_restart_DASH_agent.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_new_DASH_state, sym__AMP_, sym_options)), kw_doc, "When an agent is failed, changes the agent state to new-state and\n  then un-fails the agent so that sends are allowed again.  If\n  a :clear-actions true option is given, any actions queued on the\n  agent that were being held while it was failed will be discarded,\n  otherwise those held actions will proceed.  The new-state must pass\n  the validator if any, or restart will throw an exception and the\n  agent will remain failed with its old state and error.  Watchers, if\n  any, will NOT be notified of the new state.  Throws an exception if\n  the agent is not failed.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(2175), kw_end_DASH_line, int(2175))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "opts"
					tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp8 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp9 := lang.Apply(tmp7, []any{tmp8, v5})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					tmp12 := lang.Apply(kw_clear_DASH_actions, []any{v10})
					if lang.IsTruthy(tmp12) {
						tmp11 = true
					} else {
						tmp11 = false
					}
					tmp13, _ := lang.FieldOrMethod(v3, "restart")
					if reflect.TypeOf(tmp13).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("restart is not a function")))
					}
					tmp14 := lang.Apply(tmp13, []any{v4, tmp11})
					tmp6 = tmp14
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// resultset-seq
	{
		tmp0 := sym_resultset_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_rs)), kw_doc, "Creates and returns a lazy sequence of structmaps corresponding to\n  the rows in the java.sql.ResultSet rs", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(5681), kw_end_DASH_line, int(5681))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "rsmeta"
				tmp5, _ := lang.FieldOrMethod(v3, "getMetaData")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("getMetaData is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{})
				var v7 any = tmp6
				_ = v7
				// let binding "idxs"
				tmp8 := checkDerefVar(var_glojure_DOT_core_range)
				tmp9 := checkDerefVar(var_glojure_DOT_core_inc)
				tmp10, _ := lang.FieldOrMethod(v7, "getColumnCount")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("getColumnCount is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{})
				tmp12 := lang.Apply(tmp9, []any{tmp11})
				tmp13 := lang.Apply(tmp8, []any{int64(1), tmp12})
				var v14 any = tmp13
				_ = v14
				// let binding "keys"
				tmp15 := checkDerefVar(var_glojure_DOT_core_map)
				tmp16 := checkDerefVar(var_glojure_DOT_core_comp)
				tmp17 := checkDerefVar(var_glojure_DOT_core_keyword)
				var tmp18 lang.FnFunc
				tmp18 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v19 := args[0]
					_ = v19
					tmp20, ok := lang.FieldOrMethod(v19, "toLowerCase")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v19, "toLowerCase")))
					}
					var tmp21 any
					switch reflect.TypeOf(tmp20).Kind() {
					case reflect.Func:
						tmp21 = lang.Apply(tmp20, nil)
					default:
						tmp21 = tmp20
					}
					return tmp21
				})
				tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5688), kw_column, int(35), kw_end_DASH_line, int(5688), kw_end_DASH_column, int(62))
				tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp21 := lang.Apply(tmp16, []any{tmp17, tmp20})
				tmp22 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp23 lang.FnFunc
				tmp23 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v24 := args[0]
					_ = v24
					tmp25, _ := lang.FieldOrMethod(v7, "getColumnLabel")
					if reflect.TypeOf(tmp25).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("getColumnLabel is not a function")))
					}
					tmp26 := lang.Apply(tmp25, []any{v24})
					return tmp26
				})
				tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5689), kw_column, int(26), kw_end_DASH_line, int(5689), kw_end_DASH_column, int(63))
				tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp26 := lang.Apply(tmp22, []any{tmp25, v14})
				tmp27 := lang.Apply(tmp15, []any{tmp21, tmp26})
				var v28 any = tmp27
				_ = v28
				// let binding "check-keys"
				var tmp29 any
				{ // let
					// let binding "or__0__auto__"
					tmp30 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp31 := checkDerefVar(var_glojure_DOT_core_distinct_QMARK_)
					tmp32 := lang.Apply(tmp30, []any{tmp31, v28})
					var v33 any = tmp32
					_ = v33
					var tmp34 any
					if lang.IsTruthy(v33) {
						tmp34 = v33
					} else {
						tmp35 := lang.Apply(lang.NewError, []any{"ResultSet must have unique column labels"})
						panic(tmp35)
					}
					tmp29 = tmp34
				} // end let
				var v30 any = tmp29
				_ = v30
				// let binding "row-struct"
				tmp31 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp32 := checkDerefVar(var_glojure_DOT_core_create_DASH_struct)
				tmp33 := lang.Apply(tmp31, []any{tmp32, v28})
				var v34 any = tmp33
				_ = v34
				// let binding "row-values"
				var tmp35 lang.FnFunc
				tmp35 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					tmp36 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp37 lang.FnFunc
					tmp37 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v38 := args[0]
						_ = v38
						tmp39, _ := lang.FieldOrMethod(v3, "getObject")
						if reflect.TypeOf(tmp39).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("getObject is not a function")))
						}
						tmp40 := lang.Apply(tmp39, []any{v38})
						return tmp40
					})
					tmp38 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5694), kw_column, int(34), kw_end_DASH_line, int(5694), kw_end_DASH_column, int(71))
					tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp40 := lang.Apply(tmp36, []any{tmp39, v14})
					return tmp40
				})
				tmp36 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5694), kw_column, int(22), kw_end_DASH_line, int(5694), kw_end_DASH_column, int(78))
				tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v38 any = tmp37
				_ = v38
				// let binding "rows"
				var tmp39 lang.FnFunc
				{ // function thisfn
					var v40 lang.FnFunc
					tmp39 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						var tmp41 any
						tmp42, _ := lang.FieldOrMethod(v3, "next")
						if reflect.TypeOf(tmp42).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("next is not a function")))
						}
						tmp43 := lang.Apply(tmp42, []any{})
						if lang.IsTruthy(tmp43) {
							tmp44 := checkDerefVar(var_glojure_DOT_core_cons)
							tmp45 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp46 := checkDerefVar(var_glojure_DOT_core_struct)
							tmp47 := lang.Apply(v38, nil)
							tmp48 := lang.Apply(tmp45, []any{tmp46, v34, tmp47})
							var tmp49 lang.FnFunc
							tmp49 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								tmp50 := lang.Apply(v40, nil)
								return tmp50
							})
							tmp50 := lang.Apply(lang.NewLazySeq, []any{tmp49})
							tmp51 := lang.Apply(tmp44, []any{tmp48, tmp50})
							tmp41 = tmp51
						} else {
						}
						return tmp41
					})
					v40 = tmp39
					_ = v40
				}
				tmp40 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5695), kw_column, int(16), kw_end_DASH_line, int(5697), kw_end_DASH_column, int(86))
				tmp41, err := lang.WithMeta(tmp39, tmp40.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v42 any = tmp41
				_ = v42
				tmp43 := lang.Apply(v42, nil)
				tmp4 = tmp43
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reverse
	{
		tmp0 := sym_reverse.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a seq of the items in coll in reverse order. Not lazy.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(940), kw_end_DASH_line, int(940))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_reduce1)
			tmp5 := checkDerefVar(var_glojure_DOT_core_conj)
			tmp6 := lang.Apply(tmp4, []any{tmp5, lang.NewList(), v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reversible?
	{
		tmp0 := sym_reversible_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll implements Reversible", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(6257), kw_end_DASH_line, int(6257))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// root-directory
	{
		tmp0 := sym_root_DASH_directory.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_lib)), kw_doc, "Returns the root resource path for a lib", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(8), kw_line, int(5871), kw_end_DASH_line, int(5871), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "d"
				tmp5 := checkDerefVar(var_glojure_DOT_core_root_DASH_resource)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_subs)
				tmp9 := lang.Apply(strings11.LastIndex, []any{v7, "/"})
				tmp10 := lang.Apply(tmp8, []any{v7, int64(0), tmp9})
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// root-resource
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_root_DASH_resource.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_lib)), kw_doc, "Returns the root directory path for a lib", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(8), kw_line, int(5864), kw_end_DASH_line, int(5864), kw_private, true)).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_str)
			tmp6 := checkDerefVar(var_glojure_DOT_core_name)
			tmp7 := lang.Apply(tmp6, []any{v4})
			tmp8 := lang.Apply(strings11.ReplaceAll, []any{tmp7, "-", "_"})
			tmp9 := lang.Apply(strings11.ReplaceAll, []any{tmp8, ".", "/"})
			tmp10 := lang.Apply(tmp5, []any{lang.NewChar(47), tmp9})
			return tmp10
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rseq
	{
		tmp0 := sym_rseq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_rev)), kw_doc, "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1577), kw_end_DASH_line, int(1577))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "rseq")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("rseq is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rsubseq
	{
		tmp0 := sym_rsubseq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sc, sym_test, sym_key), lang.NewVector(sym_sc, sym_start_DASH_test, sym_start_DASH_key, sym_end_DASH_test, sym_end_DASH_key)), kw_doc, "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(5150), kw_end_DASH_line, int(5150))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "include"
					tmp7 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
					tmp8 := lang.Apply(tmp7, []any{v3, v4, v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core__LT_)
					tmp12 := checkDerefVar(var_glojure_DOT_core__LT__EQ_)
					tmp13 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{tmp11, tmp12}))
					tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5158), kw_column, int(11), kw_end_DASH_line, int(5158), kw_end_DASH_column, int(17))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp16 := lang.Apply(tmp15, []any{v4})
					if lang.IsTruthy(tmp16) {
						var tmp17 any
						{ // let
							// let binding "temp__0__auto__"
							tmp18, _ := lang.FieldOrMethod(v3, "seqFrom")
							if reflect.TypeOf(tmp18).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
							}
							tmp19 := lang.Apply(tmp18, []any{v5, false})
							var v20 any = tmp19
							_ = v20
							var tmp21 any
							if lang.IsTruthy(v20) {
								var tmp22 any
								{ // let
									// let binding "vec__74"
									var v23 any = v20
									_ = v23
									// let binding "e"
									tmp24 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp25 := lang.Apply(tmp24, []any{v23, int64(0), nil})
									var v26 any = tmp25
									_ = v26
									// let binding "s"
									var v27 any = v23
									_ = v27
									var tmp28 any
									tmp29 := lang.Apply(v9, []any{v26})
									if lang.IsTruthy(tmp29) {
										tmp28 = v27
									} else {
										tmp30 := checkDerefVar(var_glojure_DOT_core_next)
										tmp31 := lang.Apply(tmp30, []any{v27})
										tmp28 = tmp31
									}
									tmp22 = tmp28
								} // end let
								tmp21 = tmp22
							} else {
							}
							tmp17 = tmp21
						} // end let
						tmp10 = tmp17
					} else {
						tmp18 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
						tmp19, _ := lang.FieldOrMethod(v3, "seq")
						if reflect.TypeOf(tmp19).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("seq is not a function")))
						}
						tmp20 := lang.Apply(tmp19, []any{false})
						tmp21 := lang.Apply(tmp18, []any{v9, tmp20})
						tmp10 = tmp21
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var tmp8 any
				{ // let
					// let binding "temp__0__auto__"
					tmp9, _ := lang.FieldOrMethod(v3, "seqFrom")
					if reflect.TypeOf(tmp9).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
					}
					tmp10 := lang.Apply(tmp9, []any{v7, false})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						var tmp13 any
						{ // let
							// let binding "vec__77"
							var v14 any = v11
							_ = v14
							// let binding "e"
							tmp15 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
							var v17 any = tmp16
							_ = v17
							// let binding "s"
							var v18 any = v14
							_ = v18
							tmp19 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
							tmp20 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
							tmp21 := lang.Apply(tmp20, []any{v3, v4, v5})
							var tmp22 any
							tmp23 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
							tmp24 := lang.Apply(tmp23, []any{v3, v6, v7})
							tmp25 := lang.Apply(tmp24, []any{v17})
							if lang.IsTruthy(tmp25) {
								tmp22 = v18
							} else {
								tmp26 := checkDerefVar(var_glojure_DOT_core_next)
								tmp27 := lang.Apply(tmp26, []any{v18})
								tmp22 = tmp27
							}
							tmp28 := lang.Apply(tmp19, []any{tmp21, tmp22})
							tmp13 = tmp28
						} // end let
						tmp12 = tmp13
					} else {
					}
					tmp8 = tmp12
				} // end let
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// run!
	{
		tmp0 := sym_run_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_proc, sym_coll)), kw_doc, "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(7708), kw_end_DASH_line, int(7708))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_reduce)
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v7 := args[0]
				_ = v7
				v8 := args[1]
				_ = v8
				tmp9 := lang.Apply(v3, []any{v8})
				return tmp9
			})
			tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7713), kw_column, int(11), kw_end_DASH_line, int(7713), kw_end_DASH_column, int(20))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := lang.Apply(tmp5, []any{tmp8, nil, v4})
			_ = tmp9
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// second
	{
		tmp0 := sym_second.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Same as (first (next x))", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(7), kw_column, int(2), kw_line, int(91), kw_end_DASH_line, int(95))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function second
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_first)
				tmp6 := checkDerefVar(var_glojure_DOT_core_next)
				tmp7 := lang.Apply(tmp6, []any{v4})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				return tmp8
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(95), kw_column, int(9), kw_end_DASH_line, int(95), kw_end_DASH_column, int(49))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// select-keys
	{
		tmp0 := sym_select_DASH_keys.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map, sym_keyseq)), kw_doc, "Returns a map containing only those entries in map whose key is in keys", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(1536), kw_end_DASH_line, int(1536))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "ret"
				tmp6 := lang.NewMap()
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(1541), kw_column, int(16), kw_end_DASH_line, int(1541), kw_end_DASH_column, int(17))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v9 any = tmp8
				_ = v9
				// let binding "keys"
				tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp11 := lang.Apply(tmp10, []any{v4})
				var v12 any = tmp11
				_ = v12
				for {
					var tmp13 any
					if lang.IsTruthy(v12) {
						var tmp14 any
						{ // let
							// let binding "entry"
							tmp15 := checkDerefVar(var_glojure_DOT_core_first)
							tmp16 := lang.Apply(tmp15, []any{v12})
							tmp17, _ := lang.FieldOrMethod(runtime.RT, "Find")
							if reflect.TypeOf(tmp17).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("Find is not a function")))
							}
							tmp18 := lang.Apply(tmp17, []any{v3, tmp16})
							var v19 any = tmp18
							_ = v19
							var tmp21 any
							if lang.IsTruthy(v19) {
								tmp22 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp23 := lang.Apply(tmp22, []any{v9, v19})
								tmp21 = tmp23
							} else {
								tmp21 = v9
							}
							var tmp20 any = tmp21
							tmp25 := checkDerefVar(var_glojure_DOT_core_next)
							tmp26 := lang.Apply(tmp25, []any{v12})
							var tmp24 any = tmp26
							v9 = tmp20
							v12 = tmp24
							continue
						} // end let
						tmp13 = tmp14
					} else {
						tmp15 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
						tmp16 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp17 := lang.Apply(tmp16, []any{v3})
						tmp18 := lang.Apply(tmp15, []any{v9, tmp17})
						tmp13 = tmp18
					}
					tmp5 = tmp13
					break
				}
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send
	{
		tmp0 := sym_send.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_f, sym__AMP_, sym_args)), kw_doc, "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread from a thread pool, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2109), kw_end_DASH_line, int(2109))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_send_DASH_via)
				tmp8 := lang.Apply(tmp6, []any{tmp7, nil, v3, v4, v5})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send-off
	{
		tmp0 := sym_send_DASH_off.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_f, sym__AMP_, sym_args)), kw_doc, "Dispatch a potentially blocking action to an agent. Returns the\n  agent immediately. Subsequently, in a separate thread, the state of\n  the agent will be set to the value of:\n\n  (apply action-fn state-of-agent args)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2120), kw_end_DASH_line, int(2120))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_send_DASH_via)
				tmp8 := lang.Apply(tmp6, []any{tmp7, nil, v3, v4, v5})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send-via
	{
		tmp0 := sym_send_DASH_via.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_executor, sym_a, sym_f, sym__AMP_, sym_args)), kw_doc, "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread supplied by executor, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2099), kw_end_DASH_line, int(2099))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					tmp8 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
					tmp9 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
					tmp10 := lang.InternVarName(sym_glojure_DOT_core, sym__STAR_agent_STAR_)
					tmp11 := lang.Apply(tmp9, []any{tmp10, v4})
					tmp12 := lang.Apply(tmp8, []any{tmp11})
					_ = tmp12
					var tmp13 any
					func() {
						defer func() {
							tmp14 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
							tmp15 := lang.Apply(tmp14, nil)
							_ = tmp15
						}()
						tmp16 := checkDerefVar(var_glojure_DOT_core_binding_DASH_conveyor_DASH_fn)
						tmp17 := lang.Apply(tmp16, []any{v5})
						tmp13 = tmp17
					}()
					tmp7 = tmp13
				} // end let
				tmp8, _ := lang.FieldOrMethod(v4, "dispatch")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("dispatch is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{tmp7, v6, v3})
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := sym_seq.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a seq on the collection. If the collection is\n    empty, returns nil.  (seq nil) returns nil. seq also works on\n    Strings, native Java arrays (of reference types) and any objects\n    that implement Iterable. Note that seqs cache values, thus seq\n    should not be used on any Iterable whose iterator repeatedly\n    returns the same mutable object.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(4), kw_column, int(2), kw_line, int(126), kw_end_DASH_line, int(136))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		{ // function seq
			var v4 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.Seq, []any{v5})
				return tmp6
			})
			tmp3 = tmp3.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(136), kw_column, int(6), kw_end_DASH_line, int(136), kw_end_DASH_column, int(126))).(lang.FnFunc)
			v4 = tmp3
			_ = v4
		}
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq-to-map-for-destructuring
	{
		tmp0 := sym_seq_DASH_to_DASH_map_DASH_for_DASH_destructuring.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Builds a map from a seq as described in\n  https://glojure.org/reference/special_forms#keyword-arguments", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(34), kw_column, int(7), kw_line, int(4390), kw_end_DASH_line, int(4390))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_next)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp9 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp8})
				tmp4 = tmp9
			} else {
				var tmp10 any
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := lang.Apply(tmp11, []any{v3})
				if lang.IsTruthy(tmp12) {
					tmp13 := checkDerefVar(var_glojure_DOT_core_first)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp10 = tmp14
				} else {
				}
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq?
	{
		tmp0 := sym_seq_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x implements ISeq", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(5), kw_column, int(2), kw_line, int(146), kw_end_DASH_line, int(150))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function seq?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v4})
				return tmp7
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(150), kw_column, int(7), kw_end_DASH_line, int(150), kw_end_DASH_column, int(87))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seqable?
	{
		tmp0 := sym_seqable_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if the seq function is supported for x", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(6204), kw_end_DASH_line, int(6204))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seque
	{
		tmp0 := sym_seque.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s), lang.NewVector(sym_n_DASH_or_DASH_q, sym_s)), kw_doc, "Creates a queued seq on another (presumably lazy) seq s. The queued\n  seq will produce a concrete seq in the background, and can get up to\n  n items ahead of the consumer. n-or-q can be an integer n buffer\n  size, or an instance of java.util.concurrent BlockingQueue. Note\n  that reading from a seque can block if the reader gets ahead of the\n  producer.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(5419), kw_end_DASH_line, int(5419))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seque)
				tmp5 := lang.Apply(tmp4, []any{int64(100), v3})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "q"
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{nil, v3})
					if lang.IsTruthy(tmp8) {
						tmp6 = v3
					} else {
						tmp9 := checkDerefVar(var_glojure_DOT_core_int)
						tmp10 := lang.Apply(tmp9, []any{v3})
						tmp11 := lang.Apply(nil, []any{tmp10})
						tmp6 = tmp11
					}
					var v12 any = tmp6
					_ = v12
					// let binding "NIL"
					tmp13 := lang.Apply(reflect.StructOf, []any{nil})
					tmp14 := lang.Apply(reflect.New, []any{tmp13})
					tmp15, ok := lang.FieldOrMethod(tmp14, "Interface")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp14, "Interface")))
					}
					var tmp16 any
					switch reflect.TypeOf(tmp15).Kind() {
					case reflect.Func:
						tmp16 = lang.Apply(tmp15, nil)
					default:
						tmp16 = tmp15
					}
					var v17 any = tmp16
					_ = v17
					// let binding "agt"
					tmp18 := checkDerefVar(var_glojure_DOT_core_agent)
					var tmp19 lang.FnFunc
					tmp19 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 0)
						return v4
					})
					tmp20 := lang.Apply(lang.NewLazySeq, []any{tmp19})
					tmp21 := lang.Apply(tmp18, []any{tmp20})
					var v22 any = tmp21
					_ = v22
					// let binding "log-error"
					var tmp23 lang.FnFunc
					tmp23 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 2)
						v24 := args[0]
						_ = v24
						v25 := args[1]
						_ = v25
						var tmp26 any
						tmp27, _ := lang.FieldOrMethod(v24, "offer")
						if reflect.TypeOf(tmp27).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
						}
						tmp28 := lang.Apply(tmp27, []any{v24})
						if lang.IsTruthy(tmp28) {
							panic(v25)
						} else {
							tmp26 = v25
						}
						return tmp26
					})
					tmp24 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5435), kw_column, int(20), kw_end_DASH_line, int(5438), kw_end_DASH_column, int(26))
					tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v26 any = tmp25
					_ = v26
					// let binding "fill"
					var tmp27 lang.FnFunc
					tmp27 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v28 := args[0]
						_ = v28
						var tmp29 any
						if lang.IsTruthy(v28) {
							var tmp30 any
							tmp31 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
							tmp32 := lang.Apply(tmp31, []any{nil, v28})
							if lang.IsTruthy(tmp32) {
								tmp33 := lang.Apply(v26, []any{v12, v28})
								tmp30 = tmp33
							} else {
								var tmp34 any
								func() {
									defer func() {
										if r := recover(); r != nil {
											if lang.CatchMatches(r, lang.Builtins["any"]) {
												v35 := r
												_ = v35
												tmp36 := lang.Apply(v26, []any{v12, v35})
												tmp34 = tmp36
											} else {
												panic(r)
											}
										}
									}()
									var tmp35 any
									{ // let
										// let binding "G__89"
										tmp36 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp37 := lang.Apply(tmp36, []any{v28})
										var v38 any = tmp37
										_ = v38
										// let binding "vec__90"
										var v39 any = v38
										_ = v39
										// let binding "seq__91"
										tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
										tmp41 := lang.Apply(tmp40, []any{v39})
										var v42 any = tmp41
										_ = v42
										// let binding "first__92"
										tmp43 := checkDerefVar(var_glojure_DOT_core_first)
										tmp44 := lang.Apply(tmp43, []any{v42})
										var v45 any = tmp44
										_ = v45
										// let binding "seq__91"
										tmp46 := checkDerefVar(var_glojure_DOT_core_next)
										tmp47 := lang.Apply(tmp46, []any{v42})
										var v48 any = tmp47
										_ = v48
										// let binding "x"
										var v49 any = v45
										_ = v49
										// let binding "xs"
										var v50 any = v48
										_ = v50
										// let binding "s"
										var v51 any = v39
										_ = v51
										var tmp52 any
										{ // let
											// let binding "G__89"
											var v53 any = v38
											_ = v53
											for {
												var tmp54 any
												{ // let
													// let binding "vec__93"
													var v55 any = v53
													_ = v55
													// let binding "seq__94"
													tmp56 := checkDerefVar(var_glojure_DOT_core_seq)
													tmp57 := lang.Apply(tmp56, []any{v55})
													var v58 any = tmp57
													_ = v58
													// let binding "first__95"
													tmp59 := checkDerefVar(var_glojure_DOT_core_first)
													tmp60 := lang.Apply(tmp59, []any{v58})
													var v61 any = tmp60
													_ = v61
													// let binding "seq__94"
													tmp62 := checkDerefVar(var_glojure_DOT_core_next)
													tmp63 := lang.Apply(tmp62, []any{v58})
													var v64 any = tmp63
													_ = v64
													// let binding "x"
													var v65 any = v61
													_ = v65
													// let binding "xs"
													var v66 any = v64
													_ = v66
													// let binding "s"
													var v67 any = v55
													_ = v67
													var tmp68 any
													if lang.IsTruthy(v67) {
														var tmp69 any
														var tmp70 any
														tmp71 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
														tmp72 := lang.Apply(tmp71, []any{v65})
														if lang.IsTruthy(tmp72) {
															tmp70 = v17
														} else {
															tmp70 = v65
														}
														tmp73, _ := lang.FieldOrMethod(v12, "offer")
														if reflect.TypeOf(tmp73).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
														}
														tmp74 := lang.Apply(tmp73, []any{tmp70})
														if lang.IsTruthy(tmp74) {
															var tmp75 any = v66
															v53 = tmp75
															continue
														} else {
															tmp69 = v67
														}
														tmp68 = tmp69
													} else {
														var tmp76 any
														tmp77, _ := lang.FieldOrMethod(v12, "offer")
														if reflect.TypeOf(tmp77).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
														}
														tmp78 := lang.Apply(tmp77, []any{v12})
														if lang.IsTruthy(tmp78) {
														} else {
															tmp76 = lang.NewList()
														}
														tmp68 = tmp76
													}
													tmp54 = tmp68
												} // end let
												tmp52 = tmp54
												break
											}
										} // end let
										tmp35 = tmp52
									} // end let
									tmp34 = tmp35
								}()
								tmp30 = tmp34
							}
							tmp29 = tmp30
						} else {
						}
						return tmp29
					})
					tmp28 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5439), kw_column, int(15), kw_end_DASH_line, int(5452), kw_end_DASH_column, int(44))
					tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v30 any = tmp29
					_ = v30
					// let binding "drain"
					var tmp31 lang.FnFunc
					{ // function drain
						var v32 lang.FnFunc
						tmp31 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							var tmp33 lang.FnFunc
							tmp33 = lang.NewFnFunc(func(args ...any) any {
								checkArity(args, 0)
								var tmp34 any
								{ // let
									// let binding "x"
									tmp35, ok := lang.FieldOrMethod(v12, "take")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "take")))
									}
									var tmp36 any
									switch reflect.TypeOf(tmp35).Kind() {
									case reflect.Func:
										tmp36 = lang.Apply(tmp35, nil)
									default:
										tmp36 = tmp35
									}
									var v37 any = tmp36
									_ = v37
									var tmp38 any
									tmp39 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
									tmp40 := lang.Apply(tmp39, []any{v37, v12})
									if lang.IsTruthy(tmp40) {
										tmp41 := checkDerefVar(var_glojure_DOT_core_deref)
										tmp42 := lang.Apply(tmp41, []any{v22})
										_ = tmp42
									} else {
										tmp43 := checkDerefVar(var_glojure_DOT_core_send_DASH_off)
										tmp44 := lang.Apply(tmp43, []any{v22, v30})
										_ = tmp44
										tmp45 := checkDerefVar(var_glojure_DOT_core_release_DASH_pending_DASH_sends)
										tmp46 := lang.Apply(tmp45, nil)
										_ = tmp46
										tmp47 := checkDerefVar(var_glojure_DOT_core_cons)
										var tmp48 any
										tmp49 := checkDerefVar(var_glojure_DOT_core_identical_QMARK_)
										tmp50 := lang.Apply(tmp49, []any{v37, v17})
										if lang.IsTruthy(tmp50) {
										} else {
											tmp48 = v37
										}
										tmp51 := lang.Apply(v32, nil)
										tmp52 := lang.Apply(tmp47, []any{tmp48, tmp51})
										tmp38 = tmp52
									}
									tmp34 = tmp38
								} // end let
								return tmp34
							})
							tmp34 := lang.Apply(lang.NewLazySeq, []any{tmp33})
							return tmp34
						})
						v32 = tmp31
						_ = v32
					}
					tmp32 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5453), kw_column, int(16), kw_end_DASH_line, int(5461), kw_end_DASH_column, int(73))
					tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v34 any = tmp33
					_ = v34
					tmp35 := checkDerefVar(var_glojure_DOT_core_send_DASH_off)
					tmp36 := lang.Apply(tmp35, []any{v22, v30})
					_ = tmp36
					tmp37 := lang.Apply(v34, nil)
					tmp5 = tmp37
				} // end let
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sequence
	{
		tmp0 := sym_sequence.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll), lang.NewVector(sym_xform, sym_coll), lang.NewVector(sym_xform, sym_coll, sym__AMP_, sym_colls)), kw_doc, "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2639), kw_end_DASH_line, int(2639))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				if lang.IsTruthy(tmp6) {
					tmp4 = v3
				} else {
					var tmp7 any
					{ // let
						// let binding "or__0__auto__"
						tmp8 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp9 := lang.Apply(tmp8, []any{v3})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v10) {
							tmp11 = v10
						} else {
							tmp11 = lang.NewList()
						}
						tmp7 = tmp11
					} // end let
					tmp4 = tmp7
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "or__0__auto__"
					tmp6 := lang.Apply(nil, []any{v4})
					tmp7 := lang.Apply(nil, []any{v3, tmp6})
					tmp8 := lang.Apply(nil, []any{tmp7})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp10 = v9
					} else {
						tmp10 = lang.NewList()
					}
					tmp5 = tmp10
				} // end let
				return tmp5
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "or__0__auto__"
					tmp7 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp8 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v9 := args[0]
						_ = v9
						tmp10 := lang.Apply(nil, []any{v9})
						return tmp10
					})
					tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2661), kw_column, int(17), kw_end_DASH_line, int(2661), kw_end_DASH_column, int(41))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp11 := checkDerefVar(var_glojure_DOT_core_cons)
					tmp12 := lang.Apply(tmp11, []any{v4, v5})
					tmp13 := lang.Apply(tmp7, []any{tmp10, tmp12})
					tmp14 := lang.Apply(nil, []any{v3, tmp13})
					tmp15 := lang.Apply(nil, []any{tmp14})
					var v16 any = tmp15
					_ = v16
					var tmp17 any
					if lang.IsTruthy(v16) {
						tmp17 = v16
					} else {
						tmp17 = lang.NewList()
					}
					tmp6 = tmp17
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sequential?
	{
		tmp0 := sym_sequential_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll implements Sequential", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(6229), kw_end_DASH_line, int(6229))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Sequential)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// serialized-require
	{
		tmp0 := sym_serialized_DASH_require.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_args)), kw_doc, "Like 'require', but serializes loading.\n  Interim function preferred over 'require' for known asynchronous loads.\n  Future changes may make these equivalent.", kw_file, "glojure/core.glj", kw_added, "1.10", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(8), kw_line, int(6059), kw_end_DASH_line, int(6059), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "lockee__0__auto__"
					var v5 any = nil
					_ = v5
					var tmp6 any
					func() {
						var tmp7 any
						{ // let
							// let binding "locklocal__1__auto__"
							var v8 any = v5
							_ = v8
							tmp9 := lang.Apply(nil, []any{v8})
							_ = tmp9
							var tmp10 any
							func() {
								defer func() {
									tmp11 := lang.Apply(nil, []any{v8})
									_ = tmp11
								}()
								tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
								tmp13 := checkDerefVar(var_glojure_DOT_core_require)
								tmp14 := lang.Apply(tmp12, []any{tmp13, v3})
								tmp10 = tmp14
							}()
							tmp7 = tmp10
						} // end let
						tmp6 = tmp7
					}()
					tmp4 = tmp6
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set
	{
		tmp0 := sym_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a set of the distinct elements of coll.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(4104), kw_end_DASH_line, int(4104))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_set_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
				tmp8 := lang.Apply(tmp7, []any{v3, nil})
				tmp4 = tmp8
			} else {
				var tmp9 any
				tmp10 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp11 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
				tmp12 := lang.Apply(tmp10, []any{tmp11, v3})
				if lang.IsTruthy(tmp12) {
					tmp13 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp15 := checkDerefVar(var_glojure_DOT_core_transient)
					tmp16 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4112), kw_column, int(108), kw_end_DASH_line, int(4112), kw_end_DASH_column, int(110))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp19 := lang.Apply(tmp15, []any{tmp18})
					tmp20, _ := lang.FieldOrMethod(v3, "ReduceInit")
					if reflect.TypeOf(tmp20).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
					}
					tmp21 := lang.Apply(tmp20, []any{tmp14, tmp19})
					tmp22 := lang.Apply(tmp13, []any{tmp21})
					tmp9 = tmp22
				} else {
					tmp23 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
					tmp24 := checkDerefVar(var_glojure_DOT_core_reduce1)
					tmp25 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp26 := checkDerefVar(var_glojure_DOT_core_transient)
					tmp27 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp28 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4113), kw_column, int(46), kw_end_DASH_line, int(4113), kw_end_DASH_column, int(48))
					tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp30 := lang.Apply(tmp26, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp25, tmp30, v3})
					tmp32 := lang.Apply(tmp23, []any{tmp31})
					tmp9 = tmp32
				}
				tmp4 = tmp9
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-agent-send-executor!
	{
		tmp0 := sym_set_DASH_agent_DASH_send_DASH_executor_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_executor)), kw_doc, "Sets the ExecutorService to be used by send", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(30), kw_column, int(7), kw_line, int(2087), kw_end_DASH_line, int(2087))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-agent-send-off-executor!
	{
		tmp0 := sym_set_DASH_agent_DASH_send_DASH_off_DASH_executor_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_executor)), kw_doc, "Sets the ExecutorService to be used by send-off", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(34), kw_column, int(7), kw_line, int(2093), kw_end_DASH_line, int(2093))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-error-handler!
	{
		tmp0 := sym_set_DASH_error_DASH_handler_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_handler_DASH_fn)), kw_doc, "Sets the error-handler of agent a to handler-fn.  If an action\n  being run by the agent throws an exception or doesn't pass the\n  validator fn, handler-fn will be called with two arguments: the\n  agent and the exception.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(2192), kw_end_DASH_line, int(2192))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "setErrorHandler")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorHandler is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-error-mode!
	{
		tmp0 := sym_set_DASH_error_DASH_mode_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_a, sym_mode_DASH_keyword)), kw_doc, "Sets the error-mode of agent a to mode-keyword, which must be\n  either :fail or :continue.  If an action being run by the agent\n  throws an exception or doesn't pass the validator fn, an\n  error-handler may be called (see set-error-handler!), after which,\n  if the mode is :continue, the agent will continue as if neither the\n  action that caused the error nor the error itself ever happened.\n  \n  If the mode is :fail, the agent will become failed and will stop\n  accepting new 'send' and 'send-off' actions, and any previously\n  queued actions will be held until a 'restart-agent'.  Deref will\n  still work, returning the state of the agent before the error.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(2210), kw_end_DASH_line, int(2210))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "setErrorMode")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorMode is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-validator!
	{
		tmp0 := sym_set_DASH_validator_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_iref, sym_validator_DASH_fn)), kw_doc, "Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an exception. If the current state (root\n  value if var) is not acceptable to the new validator, an exception\n  will be thrown and the validator will not be changed.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(2381), kw_end_DASH_line, int(2381))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "setValidator")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setValidator is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set?
	{
		tmp0 := sym_set_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x implements IPersistentSet", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(4098), kw_end_DASH_line, int(4098))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.IPersistentSet)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// setup-reference
	{
		tmp0 := sym_setup_DASH_reference.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(2043), kw_column, int(7), kw_end_DASH_line, int(2044), kw_end_DASH_column, int(17), kw_arglists, lang.NewList(lang.NewVector(sym_r, sym_options)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "opts"
				tmp6 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp7 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
				tmp8 := lang.Apply(tmp6, []any{tmp7, v4})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				tmp11 := lang.Apply(kw_meta, []any{v9})
				if lang.IsTruthy(tmp11) {
					tmp12 := lang.Apply(kw_meta, []any{v9})
					tmp13, _ := lang.FieldOrMethod(v3, "ResetMeta")
					if reflect.TypeOf(tmp13).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ResetMeta is not a function")))
					}
					tmp14 := lang.Apply(tmp13, []any{tmp12})
					tmp10 = tmp14
				} else {
				}
				_ = tmp10
				var tmp15 any
				tmp16 := lang.Apply(kw_validator, []any{v9})
				if lang.IsTruthy(tmp16) {
					tmp17 := lang.Apply(kw_validator, []any{v9})
					tmp18, _ := lang.FieldOrMethod(v3, "setValidator")
					if reflect.TypeOf(tmp18).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setValidator is not a function")))
					}
					tmp19 := lang.Apply(tmp18, []any{tmp17})
					tmp15 = tmp19
				} else {
				}
				_ = tmp15
				tmp5 = v3
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shift-mask
	{
		tmp0 := sym_shift_DASH_mask.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6598), kw_column, int(8), kw_end_DASH_line, int(6598), kw_end_DASH_column, int(17), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_shift, sym_mask, sym_x)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := checkDerefVar(var_glojure_DOT_core_bit_DASH_and)
			tmp7 := checkDerefVar(var_glojure_DOT_core_bit_DASH_shift_DASH_right)
			tmp8 := lang.Apply(tmp7, []any{v5, v3})
			tmp9 := lang.Apply(tmp6, []any{tmp8, v4})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// short
	{
		var tmp1 lang.FnFunc
		{ // function short__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				var tmp14 any
				tmp15 := checkDerefVar(var_glojure_DOT_core__STAR_unchecked_DASH_math_STAR_)
				if lang.IsTruthy(tmp15) {
					tmp14 = sym_uncheckedShortCast
				} else {
					tmp14 = sym_shortCast
				}
				tmp16 := lang.Apply(tmp13, []any{tmp14})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp12, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp11, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp20})
				tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp21})
				tmp23 := lang.Apply(tmp4, []any{tmp22})
				return tmp23
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_short.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to short", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(3499), kw_end_DASH_line, int(3499))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.ShortCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// short-array
	{
		var tmp1 lang.FnFunc
		{ // function short-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					checkArity(args, 0)
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp6 := checkDerefVar(var_glojure_DOT_core_list)
					tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
					tmp8 := checkDerefVar(var_glojure_DOT_core_list)
					tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
					tmp10 := checkDerefVar(var_glojure_DOT_core_list)
					tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_ShortArray})
					tmp12 := checkDerefVar(var_glojure_DOT_core_list)
					tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp15 := checkDerefVar(var_glojure_DOT_core_list)
					tmp16 := lang.Apply(tmp15, []any{sym_glojure_DOT_core_SLASH_unquote_DASH_splicing})
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym_glojure_DOT_core_SLASH_args})
					tmp19 := lang.Apply(tmp14, []any{tmp16, tmp18})
					tmp20 := lang.Apply(tmp13, []any{tmp19})
					tmp21 := lang.Apply(tmp12, []any{tmp20})
					tmp22 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp21})
					tmp23 := lang.Apply(tmp4, []any{tmp22})
					return tmp23
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_short_DASH_array.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_size_DASH_or_DASH_seq), lang.NewVector(sym_size, sym_init_DASH_val_DASH_or_DASH_seq)), kw_inline, tmp1, kw_doc, "Creates an array of shorts", kw_file, "glojure/core.glj", kw_inline_DASH_arities, lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(5333), kw_end_DASH_line, int(5333))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "ShortArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShortArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ShortArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShortArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shorts
	{
		var tmp1 lang.FnFunc
		{ // function shorts
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := lang.Apply(tmp10, []any{sym_glojure_DOT_core_SLASH_Shorts})
				tmp12 := checkDerefVar(var_glojure_DOT_core_list)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp11, tmp13})
				tmp15 := lang.Apply(tmp4, []any{tmp14})
				return tmp15
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_shorts.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xs)), kw_inline, tmp1, kw_doc, "Casts to shorts[]", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(12), kw_line, int(5387), kw_end_DASH_line, int(5387))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Shorts")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Shorts is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shuffle
	{
		tmp0 := sym_shuffle.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Return a random permutation of coll", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(7300), kw_end_DASH_line, int(7300))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "al"
				tmp5 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(lang.NewArrayList, []any{tmp6})
				var v8 any = tmp7
				_ = v8
				tmp9 := lang.Apply(nil, []any{v8})
				_ = tmp9
				tmp10, ok := lang.FieldOrMethod(v8, "toArray")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "toArray")))
				}
				var tmp11 any
				switch reflect.TypeOf(tmp10).Kind() {
				case reflect.Func:
					tmp11 = lang.Apply(tmp10, nil)
				default:
					tmp11 = tmp10
				}
				tmp12 := lang.Apply(nil, []any{tmp11})
				tmp4 = tmp12
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shutdown-agents
	{
		tmp0 := sym_shutdown_DASH_agents.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector()), kw_doc, "Initiates a shutdown of the thread pools that back the agent\n  system. Running actions will complete, but no new actions will be\n  accepted", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(2252), kw_end_DASH_line, int(2252))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := lang.Apply(lang.ShutdownAgents, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sigs
	{
		tmp0 := sym_sigs.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(223), kw_column, int(2), kw_end_DASH_line, int(224), kw_end_DASH_column, int(5), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_assert_DASH_valid_DASH_fdecl)
			tmp5 := lang.Apply(tmp4, []any{v3})
			_ = tmp5
			var tmp6 any
			{ // let
				// let binding "asig"
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v8 := args[0]
					_ = v8
					var tmp9 any
					{ // let
						// let binding "arglist"
						tmp10 := checkDerefVar(var_glojure_DOT_core_first)
						tmp11 := lang.Apply(tmp10, []any{v8})
						var v12 any = tmp11
						_ = v12
						// let binding "arglist"
						var tmp13 any
						tmp14 := checkDerefVar(var_glojure_DOT_core_first)
						tmp15 := lang.Apply(tmp14, []any{v12})
						tmp16 := lang.Apply(lang.Equals, []any{sym__AMP_form, tmp15})
						if lang.IsTruthy(tmp16) {
							tmp17 := lang.Apply(lang.Count, []any{v12})
							tmp18 := lang.Apply(lang.Subvec, []any{v12, int64(2), tmp17})
							tmp13 = tmp18
						} else {
							tmp13 = v12
						}
						var v19 any = tmp13
						_ = v19
						// let binding "body"
						tmp20 := checkDerefVar(var_glojure_DOT_core_next)
						tmp21 := lang.Apply(tmp20, []any{v8})
						var v22 any = tmp21
						_ = v22
						var tmp23 any
						tmp24 := checkDerefVar(var_glojure_DOT_core_map_QMARK_)
						tmp25 := checkDerefVar(var_glojure_DOT_core_first)
						tmp26 := lang.Apply(tmp25, []any{v22})
						tmp27 := lang.Apply(tmp24, []any{tmp26})
						if lang.IsTruthy(tmp27) {
							var tmp28 any
							tmp29 := checkDerefVar(var_glojure_DOT_core_next)
							tmp30 := lang.Apply(tmp29, []any{v22})
							if lang.IsTruthy(tmp30) {
								tmp31 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
								tmp32 := checkDerefVar(var_glojure_DOT_core_conj)
								var tmp33 any
								tmp34 := checkDerefVar(var_glojure_DOT_core_meta)
								tmp35 := lang.Apply(tmp34, []any{v19})
								if lang.IsTruthy(tmp35) {
									tmp36 := checkDerefVar(var_glojure_DOT_core_meta)
									tmp37 := lang.Apply(tmp36, []any{v19})
									tmp33 = tmp37
								} else {
									tmp38 := lang.NewMap()
									tmp39 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(237), kw_column, int(77), kw_end_DASH_line, int(237), kw_end_DASH_column, int(78))
									tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp33 = tmp40
								}
								tmp41 := checkDerefVar(var_glojure_DOT_core_first)
								tmp42 := lang.Apply(tmp41, []any{v22})
								tmp43 := lang.Apply(tmp32, []any{tmp33, tmp42})
								tmp44 := lang.Apply(tmp31, []any{v19, tmp43})
								tmp28 = tmp44
							} else {
								tmp28 = v19
							}
							tmp23 = tmp28
						} else {
							tmp23 = v19
						}
						tmp9 = tmp23
					} // end let
					return tmp9
				})
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(228), kw_column, int(10), kw_end_DASH_line, int(239), kw_end_DASH_column, int(25))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v10 any = tmp9
				_ = v10
				// let binding "resolve-tag"
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v12 := args[0]
					_ = v12
					var tmp13 any
					{ // let
						// let binding "m"
						tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp15 := lang.Apply(tmp14, []any{v12})
						var v16 any = tmp15
						_ = v16
						// let binding "tag"
						tmp17 := lang.Apply(kw_tag, []any{v16})
						var v18 any = tmp17
						_ = v18
						var tmp19 any
						tmp20 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp21 := reflect.TypeOf((*lang.Symbol)(nil))
						tmp22 := lang.Apply(tmp20, []any{tmp21, v18})
						if lang.IsTruthy(tmp22) {
							var tmp23 any
							tmp24, ok := lang.FieldOrMethod(v18, "Name")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v18, "Name")))
							}
							var tmp25 any
							switch reflect.TypeOf(tmp24).Kind() {
							case reflect.Func:
								tmp25 = lang.Apply(tmp24, nil)
							default:
								tmp25 = tmp24
							}
							tmp26 := lang.Apply(strings11.Index, []any{tmp25, "."})
							tmp27 := lang.Apply(lang.Equiv, []any{tmp26, int64(-1)})
							if lang.IsTruthy(tmp27) {
								var tmp28 any
								tmp29 := lang.Apply(lang.Equals, []any{nil, nil})
								if lang.IsTruthy(tmp29) {
									var tmp30 any
									{ // let
										// let binding "c"
										var v31 any = nil
										_ = v31
										var tmp32 any
										if lang.IsTruthy(v31) {
											tmp33 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
											tmp34 := checkDerefVar(var_glojure_DOT_core_assoc)
											tmp35, ok := lang.FieldOrMethod(v31, "Name")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v31, "Name")))
											}
											var tmp36 any
											switch reflect.TypeOf(tmp35).Kind() {
											case reflect.Func:
												tmp36 = lang.Apply(tmp35, nil)
											default:
												tmp36 = tmp35
											}
											tmp37 := lang.Apply(lang.NewSymbol, []any{tmp36})
											tmp38 := lang.Apply(tmp34, []any{v16, kw_tag, tmp37})
											tmp39 := lang.Apply(tmp33, []any{v12, tmp38})
											tmp32 = tmp39
										} else {
											tmp32 = v12
										}
										tmp30 = tmp32
									} // end let
									tmp28 = tmp30
								} else {
									tmp28 = v12
								}
								tmp23 = tmp28
							} else {
								tmp23 = v12
							}
							tmp19 = tmp23
						} else {
							tmp19 = v12
						}
						tmp13 = tmp19
					} // end let
					return tmp13
				})
				tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(240), kw_column, int(22), kw_end_DASH_line, int(252), kw_end_DASH_column, int(37))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v14 any = tmp13
				_ = v14
				var tmp15 any
				tmp16 := checkDerefVar(var_glojure_DOT_core_seq_QMARK_)
				tmp17 := checkDerefVar(var_glojure_DOT_core_first)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp16, []any{tmp18})
				if lang.IsTruthy(tmp19) {
					var tmp20 any
					{ // let
						// let binding "ret"
						tmp21 := lang.NewVector()
						tmp22 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(254), kw_column, int(19), kw_end_DASH_line, int(254), kw_end_DASH_column, int(20))
						tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v24 any = tmp23
						_ = v24
						// let binding "fdecls"
						var v25 any = v3
						_ = v25
						for {
							var tmp26 any
							if lang.IsTruthy(v25) {
								tmp28 := checkDerefVar(var_glojure_DOT_core_conj)
								tmp29 := checkDerefVar(var_glojure_DOT_core_first)
								tmp30 := lang.Apply(tmp29, []any{v25})
								tmp31 := lang.Apply(v10, []any{tmp30})
								tmp32 := lang.Apply(v14, []any{tmp31})
								tmp33 := lang.Apply(tmp28, []any{v24, tmp32})
								var tmp27 any = tmp33
								tmp35 := checkDerefVar(var_glojure_DOT_core_next)
								tmp36 := lang.Apply(tmp35, []any{v25})
								var tmp34 any = tmp36
								v24 = tmp27
								v25 = tmp34
								continue
							} else {
								tmp37 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp38 := lang.Apply(tmp37, []any{v24})
								tmp26 = tmp38
							}
							tmp20 = tmp26
							break
						}
					} // end let
					tmp15 = tmp20
				} else {
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := lang.Apply(v10, []any{v3})
					tmp23 := lang.Apply(v14, []any{tmp22})
					tmp24 := lang.Apply(tmp21, []any{tmp23})
					tmp15 = tmp24
				}
				tmp6 = tmp15
			} // end let
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(225), kw_column, int(2), kw_end_DASH_line, int(258), kw_end_DASH_column, int(43))).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-ident?
	{
		tmp0 := sym_simple_DASH_ident_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a symbol or keyword without a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1613), kw_end_DASH_line, int(1613))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_ident_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
					tmp10 := checkDerefVar(var_glojure_DOT_core_namespace)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					tmp8 = tmp12
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-keyword?
	{
		tmp0 := sym_simple_DASH_keyword_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a keyword without a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(1633), kw_end_DASH_line, int(1633))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_keyword_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
					tmp10 := checkDerefVar(var_glojure_DOT_core_namespace)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					tmp8 = tmp12
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-symbol?
	{
		tmp0 := sym_simple_DASH_symbol_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a symbol without a namespace", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(1623), kw_end_DASH_line, int(1623))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{v3})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
					tmp10 := checkDerefVar(var_glojure_DOT_core_namespace)
					tmp11 := lang.Apply(tmp10, []any{v3})
					tmp12 := lang.Apply(tmp9, []any{tmp11})
					tmp8 = tmp12
				} else {
					tmp8 = v7
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// slurp
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_slurp.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_f, sym__AMP_, sym_opts)), kw_doc, "Opens a reader on f and reads all its contents, returning a string.\n  See glojure.java.io/reader for a complete list of supported arguments.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(6982), kw_end_DASH_line, int(6982))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				var v5 any = lang.NewList(args[1:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "opts"
					tmp7 := checkDerefVar(var_glojure_DOT_core_normalize_DASH_slurp_DASH_opts)
					tmp8 := lang.Apply(tmp7, []any{v5})
					var v9 any = tmp8
					_ = v9
					// let binding "sw"
					var v10 any = "unimplemented: new with non-constant class type"
					_ = v10
					var tmp11 any
					{ // let
						// let binding "r"
						tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp13 := checkDerefVar(var_glojure_DOT_go_DOT_io_reader)
						tmp14 := lang.Apply(tmp12, []any{tmp13, v4, v9})
						var v15 any = tmp14
						_ = v15
						var tmp16 any
						func() {
							defer func() {
								tmp17, ok := lang.FieldOrMethod(v15, "close")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v15, "close")))
								}
								var tmp18 any
								switch reflect.TypeOf(tmp17).Kind() {
								case reflect.Func:
									tmp18 = lang.Apply(tmp17, nil)
								default:
									tmp18 = tmp17
								}
								_ = tmp18
							}()
							tmp19 := checkDerefVar(var_glojure_DOT_go_DOT_io_copy)
							tmp20 := lang.Apply(tmp19, []any{v15, v10})
							_ = tmp20
							tmp21 := lang.Apply(lang.ToString, []any{v10})
							tmp16 = tmp21
						}()
						tmp11 = tmp16
					} // end let
					tmp6 = tmp11
				} // end let
				return tmp6
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some
	{
		tmp0 := sym_some.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2684), kw_end_DASH_line, int(2684))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
		recur_loop_481:
			var tmp5 any
			{ // let
				// let binding "temp__0__auto__"
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := lang.Apply(tmp6, []any{v4})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "s"
						var v11 any = v8
						_ = v11
						var tmp12 any
						{ // let
							// let binding "or__0__auto__"
							tmp13 := checkDerefVar(var_glojure_DOT_core_first)
							tmp14 := lang.Apply(tmp13, []any{v11})
							tmp15 := lang.Apply(v3, []any{tmp14})
							var v16 any = tmp15
							_ = v16
							var tmp17 any
							if lang.IsTruthy(v16) {
								tmp17 = v16
							} else {
								var tmp18 any = v3
								tmp20 := checkDerefVar(var_glojure_DOT_core_next)
								tmp21 := lang.Apply(tmp20, []any{v11})
								var tmp19 any = tmp21
								v3 = tmp18
								v4 = tmp19
								goto recur_loop_481
							}
							tmp12 = tmp17
						} // end let
						tmp10 = tmp12
					} // end let
					tmp9 = tmp10
				} else {
				}
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some->
	{
		tmp0 := sym_some_DASH__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr, sym__AMP_, sym_forms)), kw_doc, "When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(7610), kw_end_DASH_line, int(7610))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, nil)
					var v10 any = tmp9
					_ = v10
					// let binding "steps"
					tmp11 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp12 lang.FnFunc
					tmp12 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v13 := args[0]
						_ = v13
						tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp16 := checkDerefVar(var_glojure_DOT_core_list)
						tmp17 := lang.Apply(tmp16, []any{sym_if})
						tmp18 := checkDerefVar(var_glojure_DOT_core_list)
						tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp21 := checkDerefVar(var_glojure_DOT_core_list)
						tmp22 := lang.Apply(tmp21, []any{sym_glojure_DOT_core_SLASH_nil_QMARK_})
						tmp23 := checkDerefVar(var_glojure_DOT_core_list)
						tmp24 := lang.Apply(tmp23, []any{v10})
						tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
						tmp26 := lang.Apply(tmp19, []any{tmp25})
						tmp27 := lang.Apply(tmp18, []any{tmp26})
						tmp28 := checkDerefVar(var_glojure_DOT_core_list)
						tmp29 := lang.Apply(tmp28, []any{nil})
						tmp30 := checkDerefVar(var_glojure_DOT_core_list)
						tmp31 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp32 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp33 := checkDerefVar(var_glojure_DOT_core_list)
						tmp34 := lang.Apply(tmp33, []any{sym_glojure_DOT_core_SLASH__DASH__GT_})
						tmp35 := checkDerefVar(var_glojure_DOT_core_list)
						tmp36 := lang.Apply(tmp35, []any{v10})
						tmp37 := checkDerefVar(var_glojure_DOT_core_list)
						tmp38 := lang.Apply(tmp37, []any{v13})
						tmp39 := lang.Apply(tmp32, []any{tmp34, tmp36, tmp38})
						tmp40 := lang.Apply(tmp31, []any{tmp39})
						tmp41 := lang.Apply(tmp30, []any{tmp40})
						tmp42 := lang.Apply(tmp15, []any{tmp17, tmp27, tmp29, tmp41})
						tmp43 := lang.Apply(tmp14, []any{tmp42})
						return tmp43
					})
					tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7616), kw_column, int(20), kw_end_DASH_line, int(7616), kw_end_DASH_column, int(64))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := lang.Apply(tmp11, []any{tmp14, v6})
					var v16 any = tmp15
					_ = v16
					tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{sym_glojure_DOT_core_SLASH_let})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp23 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v10})
					tmp28 := checkDerefVar(var_glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{v5})
					tmp30 := checkDerefVar(var_glojure_DOT_core_interleave)
					tmp31 := checkDerefVar(var_glojure_DOT_core_repeat)
					tmp32 := lang.Apply(tmp31, []any{v10})
					tmp33 := checkDerefVar(var_glojure_DOT_core_butlast)
					tmp34 := lang.Apply(tmp33, []any{v16})
					tmp35 := lang.Apply(tmp30, []any{tmp32, tmp34})
					tmp36 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp35})
					tmp37 := lang.Apply(tmp24, []any{tmp36})
					tmp38 := lang.Apply(tmp22, []any{tmp23, tmp37})
					tmp39 := lang.Apply(tmp21, []any{tmp38})
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					var tmp41 any
					tmp42 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
					tmp43 := lang.Apply(tmp42, []any{v16})
					if lang.IsTruthy(tmp43) {
						tmp41 = v10
					} else {
						tmp44 := checkDerefVar(var_glojure_DOT_core_last)
						tmp45 := lang.Apply(tmp44, []any{v16})
						tmp41 = tmp45
					}
					tmp46 := lang.Apply(tmp40, []any{tmp41})
					tmp47 := lang.Apply(tmp18, []any{tmp20, tmp39, tmp46})
					tmp48 := lang.Apply(tmp17, []any{tmp47})
					tmp7 = tmp48
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some->>
	{
		tmp0 := sym_some_DASH__GT__GT_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr, sym__AMP_, sym_forms)), kw_doc, "When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc", kw_file, "glojure/core.glj", kw_added, "1.5", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(11), kw_line, int(7624), kw_end_DASH_line, int(7624))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := checkDerefVar(var_glojure_DOT_core_gensym)
					tmp9 := lang.Apply(tmp8, nil)
					var v10 any = tmp9
					_ = v10
					// let binding "steps"
					tmp11 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp12 lang.FnFunc
					tmp12 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v13 := args[0]
						_ = v13
						tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp16 := checkDerefVar(var_glojure_DOT_core_list)
						tmp17 := lang.Apply(tmp16, []any{sym_if})
						tmp18 := checkDerefVar(var_glojure_DOT_core_list)
						tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp21 := checkDerefVar(var_glojure_DOT_core_list)
						tmp22 := lang.Apply(tmp21, []any{sym_glojure_DOT_core_SLASH_nil_QMARK_})
						tmp23 := checkDerefVar(var_glojure_DOT_core_list)
						tmp24 := lang.Apply(tmp23, []any{v10})
						tmp25 := lang.Apply(tmp20, []any{tmp22, tmp24})
						tmp26 := lang.Apply(tmp19, []any{tmp25})
						tmp27 := lang.Apply(tmp18, []any{tmp26})
						tmp28 := checkDerefVar(var_glojure_DOT_core_list)
						tmp29 := lang.Apply(tmp28, []any{nil})
						tmp30 := checkDerefVar(var_glojure_DOT_core_list)
						tmp31 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp32 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp33 := checkDerefVar(var_glojure_DOT_core_list)
						tmp34 := lang.Apply(tmp33, []any{sym_glojure_DOT_core_SLASH__DASH__GT__GT_})
						tmp35 := checkDerefVar(var_glojure_DOT_core_list)
						tmp36 := lang.Apply(tmp35, []any{v10})
						tmp37 := checkDerefVar(var_glojure_DOT_core_list)
						tmp38 := lang.Apply(tmp37, []any{v13})
						tmp39 := lang.Apply(tmp32, []any{tmp34, tmp36, tmp38})
						tmp40 := lang.Apply(tmp31, []any{tmp39})
						tmp41 := lang.Apply(tmp30, []any{tmp40})
						tmp42 := lang.Apply(tmp15, []any{tmp17, tmp27, tmp29, tmp41})
						tmp43 := lang.Apply(tmp14, []any{tmp42})
						return tmp43
					})
					tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7630), kw_column, int(20), kw_end_DASH_line, int(7630), kw_end_DASH_column, int(65))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := lang.Apply(tmp11, []any{tmp14, v6})
					var v16 any = tmp15
					_ = v16
					tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{sym_glojure_DOT_core_SLASH_let})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp23 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := lang.Apply(tmp26, []any{v10})
					tmp28 := checkDerefVar(var_glojure_DOT_core_list)
					tmp29 := lang.Apply(tmp28, []any{v5})
					tmp30 := checkDerefVar(var_glojure_DOT_core_interleave)
					tmp31 := checkDerefVar(var_glojure_DOT_core_repeat)
					tmp32 := lang.Apply(tmp31, []any{v10})
					tmp33 := checkDerefVar(var_glojure_DOT_core_butlast)
					tmp34 := lang.Apply(tmp33, []any{v16})
					tmp35 := lang.Apply(tmp30, []any{tmp32, tmp34})
					tmp36 := lang.Apply(tmp25, []any{tmp27, tmp29, tmp35})
					tmp37 := lang.Apply(tmp24, []any{tmp36})
					tmp38 := lang.Apply(tmp22, []any{tmp23, tmp37})
					tmp39 := lang.Apply(tmp21, []any{tmp38})
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					var tmp41 any
					tmp42 := checkDerefVar(var_glojure_DOT_core_empty_QMARK_)
					tmp43 := lang.Apply(tmp42, []any{v16})
					if lang.IsTruthy(tmp43) {
						tmp41 = v10
					} else {
						tmp44 := checkDerefVar(var_glojure_DOT_core_last)
						tmp45 := lang.Apply(tmp44, []any{v16})
						tmp41 = tmp45
					}
					tmp46 := lang.Apply(tmp40, []any{tmp41})
					tmp47 := lang.Apply(tmp18, []any{tmp20, tmp39, tmp46})
					tmp48 := lang.Apply(tmp17, []any{tmp47})
					tmp7 = tmp48
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some-fn
	{
		tmp0 := sym_some_DASH_fn.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_p), lang.NewVector(sym_p1, sym_p2), lang.NewVector(sym_p1, sym_p2, sym_p3), lang.NewVector(sym_p1, sym_p2, sym_p3, sym__AMP_, sym_ps)), kw_doc, "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(7462), kw_end_DASH_line, int(7462))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				{ // function sp1
					var v5 lang.FnFunc
					tmp4 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v6 := args[0]
							_ = v6
							tmp7 := lang.Apply(v3, []any{v6})
							return tmp7
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							var tmp8 any
							{ // let
								// let binding "or__0__auto__"
								tmp9 := lang.Apply(v3, []any{v6})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								if lang.IsTruthy(v10) {
									tmp11 = v10
								} else {
									tmp12 := lang.Apply(v3, []any{v7})
									tmp11 = tmp12
								}
								tmp8 = tmp11
							} // end let
							return tmp8
						case 3:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v3, []any{v6})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									var tmp13 any
									{ // let
										// let binding "or__0__auto__"
										tmp14 := lang.Apply(v3, []any{v7})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp16 = v15
										} else {
											tmp17 := lang.Apply(v3, []any{v8})
											tmp16 = tmp17
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						default:
							checkArity(args, 3)
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var v9 any = lang.NewList(args[3:]...)
							_ = v9
							var tmp10 any
							{ // let
								// let binding "or__0__auto__"
								tmp11 := lang.Apply(v5, []any{v6, v7, v8})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp13 = v12
								} else {
									tmp14 := checkDerefVar(var_glojure_DOT_core_some)
									tmp15 := lang.Apply(tmp14, []any{v3, v9})
									tmp13 = tmp15
								}
								tmp10 = tmp13
							} // end let
							return tmp10
						}
					})
					v5 = tmp4
					_ = v5
				}
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7469), kw_column, int(6), kw_end_DASH_line, int(7475), kw_end_DASH_column, int(43))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				{ // function sp2
					var v6 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v7 := args[0]
							_ = v7
							var tmp8 any
							{ // let
								// let binding "or__0__auto__"
								tmp9 := lang.Apply(v3, []any{v7})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								if lang.IsTruthy(v10) {
									tmp11 = v10
								} else {
									tmp12 := lang.Apply(v4, []any{v7})
									tmp11 = tmp12
								}
								tmp8 = tmp11
							} // end let
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v3, []any{v7})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									var tmp13 any
									{ // let
										// let binding "or__0__auto__"
										tmp14 := lang.Apply(v3, []any{v8})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp16 = v15
										} else {
											var tmp17 any
											{ // let
												// let binding "or__0__auto__"
												tmp18 := lang.Apply(v4, []any{v7})
												var v19 any = tmp18
												_ = v19
												var tmp20 any
												if lang.IsTruthy(v19) {
													tmp20 = v19
												} else {
													tmp21 := lang.Apply(v4, []any{v8})
													tmp20 = tmp21
												}
												tmp17 = tmp20
											} // end let
											tmp16 = tmp17
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						case 3:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var tmp10 any
							{ // let
								// let binding "or__0__auto__"
								tmp11 := lang.Apply(v3, []any{v7})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp13 = v12
								} else {
									var tmp14 any
									{ // let
										// let binding "or__0__auto__"
										tmp15 := lang.Apply(v3, []any{v8})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											tmp17 = v16
										} else {
											var tmp18 any
											{ // let
												// let binding "or__0__auto__"
												tmp19 := lang.Apply(v3, []any{v9})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													tmp21 = v20
												} else {
													var tmp22 any
													{ // let
														// let binding "or__0__auto__"
														tmp23 := lang.Apply(v4, []any{v7})
														var v24 any = tmp23
														_ = v24
														var tmp25 any
														if lang.IsTruthy(v24) {
															tmp25 = v24
														} else {
															var tmp26 any
															{ // let
																// let binding "or__0__auto__"
																tmp27 := lang.Apply(v4, []any{v8})
																var v28 any = tmp27
																_ = v28
																var tmp29 any
																if lang.IsTruthy(v28) {
																	tmp29 = v28
																} else {
																	tmp30 := lang.Apply(v4, []any{v9})
																	tmp29 = tmp30
																}
																tmp26 = tmp29
															} // end let
															tmp25 = tmp26
														}
														tmp22 = tmp25
													} // end let
													tmp21 = tmp22
												}
												tmp18 = tmp21
											} // end let
											tmp17 = tmp18
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								}
								tmp10 = tmp13
							} // end let
							return tmp10
						default:
							checkArity(args, 3)
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var v10 any = lang.NewList(args[3:]...)
							_ = v10
							var tmp11 any
							{ // let
								// let binding "or__0__auto__"
								tmp12 := lang.Apply(v6, []any{v7, v8, v9})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp14 = v13
								} else {
									tmp15 := checkDerefVar(var_glojure_DOT_core_some)
									var tmp16 lang.FnFunc
									tmp16 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v17 := args[0]
										_ = v17
										var tmp18 any
										{ // let
											// let binding "or__0__auto__"
											tmp19 := lang.Apply(v3, []any{v17})
											var v20 any = tmp19
											_ = v20
											var tmp21 any
											if lang.IsTruthy(v20) {
												tmp21 = v20
											} else {
												tmp22 := lang.Apply(v4, []any{v17})
												tmp21 = tmp22
											}
											tmp18 = tmp21
										} // end let
										return tmp18
									})
									tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7483), kw_column, int(34), kw_end_DASH_line, int(7483), kw_end_DASH_column, int(52))
									tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp19 := lang.Apply(tmp15, []any{tmp18, v10})
									tmp14 = tmp19
								}
								tmp11 = tmp14
							} // end let
							return tmp11
						}
					})
					v6 = tmp5
					_ = v6
				}
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7477), kw_column, int(6), kw_end_DASH_line, int(7483), kw_end_DASH_column, int(61))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				{ // function sp3
					var v7 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v8 := args[0]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v3, []any{v8})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									var tmp13 any
									{ // let
										// let binding "or__0__auto__"
										tmp14 := lang.Apply(v4, []any{v8})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp16 = v15
										} else {
											tmp17 := lang.Apply(v5, []any{v8})
											tmp16 = tmp17
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						case 2:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							var tmp10 any
							{ // let
								// let binding "or__0__auto__"
								tmp11 := lang.Apply(v3, []any{v8})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp13 = v12
								} else {
									var tmp14 any
									{ // let
										// let binding "or__0__auto__"
										tmp15 := lang.Apply(v3, []any{v9})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											tmp17 = v16
										} else {
											var tmp18 any
											{ // let
												// let binding "or__0__auto__"
												tmp19 := lang.Apply(v4, []any{v8})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													tmp21 = v20
												} else {
													var tmp22 any
													{ // let
														// let binding "or__0__auto__"
														tmp23 := lang.Apply(v4, []any{v9})
														var v24 any = tmp23
														_ = v24
														var tmp25 any
														if lang.IsTruthy(v24) {
															tmp25 = v24
														} else {
															var tmp26 any
															{ // let
																// let binding "or__0__auto__"
																tmp27 := lang.Apply(v5, []any{v8})
																var v28 any = tmp27
																_ = v28
																var tmp29 any
																if lang.IsTruthy(v28) {
																	tmp29 = v28
																} else {
																	tmp30 := lang.Apply(v5, []any{v9})
																	tmp29 = tmp30
																}
																tmp26 = tmp29
															} // end let
															tmp25 = tmp26
														}
														tmp22 = tmp25
													} // end let
													tmp21 = tmp22
												}
												tmp18 = tmp21
											} // end let
											tmp17 = tmp18
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								}
								tmp10 = tmp13
							} // end let
							return tmp10
						case 3:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							var tmp11 any
							{ // let
								// let binding "or__0__auto__"
								tmp12 := lang.Apply(v3, []any{v8})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp14 = v13
								} else {
									var tmp15 any
									{ // let
										// let binding "or__0__auto__"
										tmp16 := lang.Apply(v3, []any{v9})
										var v17 any = tmp16
										_ = v17
										var tmp18 any
										if lang.IsTruthy(v17) {
											tmp18 = v17
										} else {
											var tmp19 any
											{ // let
												// let binding "or__0__auto__"
												tmp20 := lang.Apply(v3, []any{v10})
												var v21 any = tmp20
												_ = v21
												var tmp22 any
												if lang.IsTruthy(v21) {
													tmp22 = v21
												} else {
													var tmp23 any
													{ // let
														// let binding "or__0__auto__"
														tmp24 := lang.Apply(v4, []any{v8})
														var v25 any = tmp24
														_ = v25
														var tmp26 any
														if lang.IsTruthy(v25) {
															tmp26 = v25
														} else {
															var tmp27 any
															{ // let
																// let binding "or__0__auto__"
																tmp28 := lang.Apply(v4, []any{v9})
																var v29 any = tmp28
																_ = v29
																var tmp30 any
																if lang.IsTruthy(v29) {
																	tmp30 = v29
																} else {
																	var tmp31 any
																	{ // let
																		// let binding "or__0__auto__"
																		tmp32 := lang.Apply(v4, []any{v10})
																		var v33 any = tmp32
																		_ = v33
																		var tmp34 any
																		if lang.IsTruthy(v33) {
																			tmp34 = v33
																		} else {
																			var tmp35 any
																			{ // let
																				// let binding "or__0__auto__"
																				tmp36 := lang.Apply(v5, []any{v8})
																				var v37 any = tmp36
																				_ = v37
																				var tmp38 any
																				if lang.IsTruthy(v37) {
																					tmp38 = v37
																				} else {
																					var tmp39 any
																					{ // let
																						// let binding "or__0__auto__"
																						tmp40 := lang.Apply(v5, []any{v9})
																						var v41 any = tmp40
																						_ = v41
																						var tmp42 any
																						if lang.IsTruthy(v41) {
																							tmp42 = v41
																						} else {
																							tmp43 := lang.Apply(v5, []any{v10})
																							tmp42 = tmp43
																						}
																						tmp39 = tmp42
																					} // end let
																					tmp38 = tmp39
																				}
																				tmp35 = tmp38
																			} // end let
																			tmp34 = tmp35
																		}
																		tmp31 = tmp34
																	} // end let
																	tmp30 = tmp31
																}
																tmp27 = tmp30
															} // end let
															tmp26 = tmp27
														}
														tmp23 = tmp26
													} // end let
													tmp22 = tmp23
												}
												tmp19 = tmp22
											} // end let
											tmp18 = tmp19
										}
										tmp15 = tmp18
									} // end let
									tmp14 = tmp15
								}
								tmp11 = tmp14
							} // end let
							return tmp11
						default:
							checkArity(args, 3)
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							var v11 any = lang.NewList(args[3:]...)
							_ = v11
							var tmp12 any
							{ // let
								// let binding "or__0__auto__"
								tmp13 := lang.Apply(v7, []any{v8, v9, v10})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									tmp15 = v14
								} else {
									tmp16 := checkDerefVar(var_glojure_DOT_core_some)
									var tmp17 lang.FnFunc
									tmp17 = lang.NewFnFunc(func(args ...any) any {
										checkArity(args, 1)
										v18 := args[0]
										_ = v18
										var tmp19 any
										{ // let
											// let binding "or__0__auto__"
											tmp20 := lang.Apply(v3, []any{v18})
											var v21 any = tmp20
											_ = v21
											var tmp22 any
											if lang.IsTruthy(v21) {
												tmp22 = v21
											} else {
												var tmp23 any
												{ // let
													// let binding "or__0__auto__"
													tmp24 := lang.Apply(v4, []any{v18})
													var v25 any = tmp24
													_ = v25
													var tmp26 any
													if lang.IsTruthy(v25) {
														tmp26 = v25
													} else {
														tmp27 := lang.Apply(v5, []any{v18})
														tmp26 = tmp27
													}
													tmp23 = tmp26
												} // end let
												tmp22 = tmp23
											}
											tmp19 = tmp22
										} // end let
										return tmp19
									})
									tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7491), kw_column, int(34), kw_end_DASH_line, int(7491), kw_end_DASH_column, int(59))
									tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp20 := lang.Apply(tmp16, []any{tmp19, v11})
									tmp15 = tmp20
								}
								tmp12 = tmp15
							} // end let
							return tmp12
						}
					})
					v7 = tmp6
					_ = v7
				}
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7485), kw_column, int(6), kw_end_DASH_line, int(7491), kw_end_DASH_column, int(68))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ps"
					tmp8 := checkDerefVar(var_glojure_DOT_core_list_STAR_)
					tmp9 := lang.Apply(tmp8, []any{v3, v4, v5, v6})
					var v10 any = tmp9
					_ = v10
					var tmp11 lang.FnFunc
					{ // function spn
						var v12 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								return nil
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := checkDerefVar(var_glojure_DOT_core_some)
								var tmp15 lang.FnFunc
								tmp15 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v16 := args[0]
									_ = v16
									tmp17 := lang.Apply(v16, []any{v13})
									return tmp17
								})
								tmp16 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7496), kw_column, int(21), kw_end_DASH_line, int(7496), kw_end_DASH_column, int(26))
								tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp18 := lang.Apply(tmp14, []any{tmp17, v10})
								return tmp18
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								tmp15 := checkDerefVar(var_glojure_DOT_core_some)
								var tmp16 lang.FnFunc
								tmp16 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v17 := args[0]
									_ = v17
									var tmp18 any
									{ // let
										// let binding "or__0__auto__"
										tmp19 := lang.Apply(v17, []any{v13})
										var v20 any = tmp19
										_ = v20
										var tmp21 any
										if lang.IsTruthy(v20) {
											tmp21 = v20
										} else {
											tmp22 := lang.Apply(v17, []any{v14})
											tmp21 = tmp22
										}
										tmp18 = tmp21
									} // end let
									return tmp18
								})
								tmp17 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7497), kw_column, int(23), kw_end_DASH_line, int(7497), kw_end_DASH_column, int(39))
								tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp19 := lang.Apply(tmp15, []any{tmp18, v10})
								return tmp19
							case 3:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								v15 := args[2]
								_ = v15
								tmp16 := checkDerefVar(var_glojure_DOT_core_some)
								var tmp17 lang.FnFunc
								tmp17 = lang.NewFnFunc(func(args ...any) any {
									checkArity(args, 1)
									v18 := args[0]
									_ = v18
									var tmp19 any
									{ // let
										// let binding "or__0__auto__"
										tmp20 := lang.Apply(v18, []any{v13})
										var v21 any = tmp20
										_ = v21
										var tmp22 any
										if lang.IsTruthy(v21) {
											tmp22 = v21
										} else {
											var tmp23 any
											{ // let
												// let binding "or__0__auto__"
												tmp24 := lang.Apply(v18, []any{v14})
												var v25 any = tmp24
												_ = v25
												var tmp26 any
												if lang.IsTruthy(v25) {
													tmp26 = v25
												} else {
													tmp27 := lang.Apply(v18, []any{v15})
													tmp26 = tmp27
												}
												tmp23 = tmp26
											} // end let
											tmp22 = tmp23
										}
										tmp19 = tmp22
									} // end let
									return tmp19
								})
								tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7498), kw_column, int(25), kw_end_DASH_line, int(7498), kw_end_DASH_column, int(47))
								tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp20 := lang.Apply(tmp16, []any{tmp19, v10})
								return tmp20
							default:
								checkArity(args, 3)
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								v15 := args[2]
								_ = v15
								var v16 any = lang.NewList(args[3:]...)
								_ = v16
								var tmp17 any
								{ // let
									// let binding "or__0__auto__"
									tmp18 := lang.Apply(v12, []any{v13, v14, v15})
									var v19 any = tmp18
									_ = v19
									var tmp20 any
									if lang.IsTruthy(v19) {
										tmp20 = v19
									} else {
										tmp21 := checkDerefVar(var_glojure_DOT_core_some)
										var tmp22 lang.FnFunc
										tmp22 = lang.NewFnFunc(func(args ...any) any {
											checkArity(args, 1)
											v23 := args[0]
											_ = v23
											tmp24 := checkDerefVar(var_glojure_DOT_core_some)
											tmp25 := lang.Apply(tmp24, []any{v23, v16})
											return tmp25
										})
										tmp23 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7500), kw_column, int(36), kw_end_DASH_line, int(7500), kw_end_DASH_column, int(49))
										tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp25 := lang.Apply(tmp21, []any{tmp24, v10})
										tmp20 = tmp25
									}
									tmp17 = tmp20
								} // end let
								return tmp17
							}
						})
						v12 = tmp11
						_ = v12
					}
					tmp12 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7494), kw_column, int(8), kw_end_DASH_line, int(7500), kw_end_DASH_column, int(56))
					tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp7 = tmp13
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_some_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is not nil, false otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(530), kw_end_DASH_line, int(530))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_not)
			tmp6 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp7 := lang.Apply(tmp6, []any{v4})
			tmp8 := lang.Apply(tmp5, []any{tmp7})
			return tmp8
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sort
	{
		tmp0 := sym_sort.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll), lang.NewVector(sym_comp, sym_coll)), kw_doc, "Returns a sorted sequence of the items in coll. If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3085), kw_end_DASH_line, int(3085))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_sort)
				tmp5 := checkDerefVar(var_glojure_DOT_core_compare)
				tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					var tmp8 any
					{ // let
						// let binding "a"
						tmp9 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
						tmp10 := lang.Apply(tmp9, []any{v4})
						var v11 any = tmp10
						_ = v11
						tmp12 := lang.Apply(lang.SortSlice, []any{v11, v3})
						_ = tmp12
						tmp13 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
						tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp15 := lang.Apply(tmp14, []any{v11})
						tmp16 := checkDerefVar(var_glojure_DOT_core_meta)
						tmp17 := lang.Apply(tmp16, []any{v4})
						tmp18 := lang.Apply(tmp13, []any{tmp15, tmp17})
						tmp8 = tmp18
					} // end let
					tmp5 = tmp8
				} else {
					tmp5 = lang.NewList()
				}
				return tmp5
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sort-by
	{
		tmp0 := sym_sort_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_keyfn, sym_coll), lang.NewVector(sym_keyfn, sym_comp, sym_coll)), kw_doc, "Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn item).  If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(3102), kw_end_DASH_line, int(3102))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_sort_DASH_by)
				tmp6 := checkDerefVar(var_glojure_DOT_core_compare)
				tmp7 := lang.Apply(tmp5, []any{v3, tmp6, v4})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_sort)
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v8 := args[0]
					_ = v8
					v9 := args[1]
					_ = v9
					tmp10 := lang.Apply(v3, []any{v8})
					tmp11 := lang.Apply(v3, []any{v9})
					tmp12 := lang.Apply(v4, []any{tmp10, tmp11})
					return tmp12
				})
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(3114), kw_column, int(10), kw_end_DASH_line, int(3114), kw_end_DASH_column, int(46))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := lang.Apply(tmp6, []any{tmp9, v5})
				return tmp10
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-map
	{
		tmp0 := sym_sorted_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_keyvals)), kw_doc, "keyval => key val\n  Returns a new sorted map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(397), kw_end_DASH_line, int(397))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentTreeMap, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-map-by
	{
		tmp0 := sym_sorted_DASH_map_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_comparator, sym__AMP_, sym_keyvals)), kw_doc, "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.  If any keys are equal, they are handled as if by\n  repeated uses of assoc.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(406), kw_end_DASH_line, int(406))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(nil, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-set
	{
		tmp0 := sym_sorted_DASH_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_keys)), kw_doc, "Returns a new sorted set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(416), kw_end_DASH_line, int(416))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentTreeSet, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-set-by
	{
		tmp0 := sym_sorted_DASH_set_DASH_by.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_comparator, sym__AMP_, sym_keys)), kw_doc, "Returns a new sorted set with supplied keys, using the supplied\n  comparator.  Any equal keys are handled as if by repeated uses of\n  conj.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(424), kw_end_DASH_line, int(424))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(lang.CreatePersistentTreeSetWithComparator, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted?
	{
		tmp0 := sym_sorted_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns true if coll implements Sorted", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(6235), kw_end_DASH_line, int(6235))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// special-symbol?
	{
		tmp0 := sym_special_DASH_symbol_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s)), kw_doc, "Returns true if s names a special form", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(4992), kw_end_DASH_line, int(4992))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
			tmp5, ok := lang.FieldOrMethod(runtime.Compiler, "specials")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", runtime.Compiler, "specials")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{tmp6, v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// spit
	{
		tmp0 := sym_spit.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_content, sym__AMP_, sym_options)), kw_doc, "Opposite of slurp.  Opens f with writer, writes content, then\n  closes f. Options passed to glojure.java.io/writer.", kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(6994), kw_end_DASH_line, int(6994))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "w"
					tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp8 := lang.Apply(tmp7, []any{nil, v3, v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					func() {
						defer func() {
							tmp11, ok := lang.FieldOrMethod(v9, "close")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "close")))
							}
							var tmp12 any
							switch reflect.TypeOf(tmp11).Kind() {
							case reflect.Func:
								tmp12 = lang.Apply(tmp11, nil)
							default:
								tmp12 = tmp11
							}
							_ = tmp12
						}()
						tmp13 := checkDerefVar(var_glojure_DOT_core_str)
						tmp14 := lang.Apply(tmp13, []any{v4})
						tmp15 := lang.Apply(lang.WriteWriter, []any{v9, tmp14})
						tmp10 = tmp15
					}()
					tmp6 = tmp10
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// split-at
	{
		tmp0 := sym_split_DASH_at.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a vector of [(take n coll) (drop n coll)]", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(2983), kw_end_DASH_line, int(2983))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_take)
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			tmp7 := checkDerefVar(var_glojure_DOT_core_drop)
			tmp8 := lang.Apply(tmp7, []any{v3, v4})
			tmp9 := lang.NewVector(tmp6, tmp8)
			tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2988), kw_column, int(5), kw_end_DASH_line, int(2988), kw_end_DASH_column, int(33))
			tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// split-with
	{
		tmp0 := sym_split_DASH_with.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(2990), kw_end_DASH_line, int(2990))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			tmp7 := checkDerefVar(var_glojure_DOT_core_drop_DASH_while)
			tmp8 := lang.Apply(tmp7, []any{v3, v4})
			tmp9 := lang.NewVector(tmp6, tmp8)
			tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2995), kw_column, int(5), kw_end_DASH_line, int(2995), kw_end_DASH_column, int(51))
			tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// splitv-at
	{
		tmp0 := sym_splitv_DASH_at.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a vector of [(into [] (take n) coll) (drop n coll)]", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(7256), kw_end_DASH_line, int(7256))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_into)
			tmp6 := lang.NewVector()
			tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7260), kw_column, int(10), kw_end_DASH_line, int(7260), kw_end_DASH_column, int(11))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := checkDerefVar(var_glojure_DOT_core_take)
			tmp10 := lang.Apply(tmp9, []any{v3})
			tmp11 := lang.Apply(tmp5, []any{tmp8, tmp10, v4})
			tmp12 := checkDerefVar(var_glojure_DOT_core_drop)
			tmp13 := lang.Apply(tmp12, []any{v3, v4})
			tmp14 := lang.NewVector(tmp11, tmp13)
			tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7260), kw_column, int(3), kw_end_DASH_line, int(7260), kw_end_DASH_column, int(41))
			tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp16
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// spread
	{
		tmp0 := sym_spread.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_arglist)), kw_static, true, kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(632), kw_end_DASH_line, int(632), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
			} else {
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
				tmp9 := checkDerefVar(var_glojure_DOT_core_next)
				tmp10 := lang.Apply(tmp9, []any{v3})
				tmp11 := lang.Apply(tmp8, []any{tmp10})
				if lang.IsTruthy(tmp11) {
					tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp13 := checkDerefVar(var_glojure_DOT_core_first)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp15 := lang.Apply(tmp12, []any{tmp14})
					tmp7 = tmp15
				} else {
					var tmp16 any
					if lang.IsTruthy(kw_else) {
						tmp17 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp18 := checkDerefVar(var_glojure_DOT_core_first)
						tmp19 := lang.Apply(tmp18, []any{v3})
						tmp20 := checkDerefVar(var_glojure_DOT_core_spread)
						tmp21 := checkDerefVar(var_glojure_DOT_core_next)
						tmp22 := lang.Apply(tmp21, []any{v3})
						tmp23 := lang.Apply(tmp20, []any{tmp22})
						tmp24 := lang.Apply(tmp17, []any{tmp19, tmp23})
						tmp16 = tmp24
					} else {
					}
					tmp7 = tmp16
				}
				tmp4 = tmp7
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := sym_str.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_x), lang.NewVector(sym_x, sym__AMP_, sym_ys)), kw_doc, "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(543), kw_end_DASH_line, int(543))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return ""
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_nil_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp5 = ""
				} else {
					tmp8 := lang.Apply(lang.ToString, []any{v4})
					tmp5 = tmp8
				}
				return tmp5
			default:
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				var v5 any = lang.NewList(args[1:]...)
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 2)
					v7 := args[0]
					_ = v7
					v8 := args[1]
					_ = v8
				recur_loop_74:
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp11 := checkDerefVar(var_glojure_DOT_core_str)
						tmp12 := checkDerefVar(var_glojure_DOT_core_first)
						tmp13 := lang.Apply(tmp12, []any{v8})
						tmp14 := lang.Apply(tmp11, []any{tmp13})
						tmp15, _ := lang.FieldOrMethod(v7, "WriteString")
						if reflect.TypeOf(tmp15).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("WriteString is not a function")))
						}
						tmp16 := lang.Apply(tmp15, []any{tmp14})
						_ = tmp16
						var tmp10 any = v7
						tmp18 := checkDerefVar(var_glojure_DOT_core_next)
						tmp19 := lang.Apply(tmp18, []any{v8})
						var tmp17 any = tmp19
						v7 = tmp10
						v8 = tmp17
						goto recur_loop_74
					} else {
						tmp20, ok := lang.FieldOrMethod(v7, "String")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "String")))
						}
						var tmp21 any
						switch reflect.TypeOf(tmp20).Kind() {
						case reflect.Func:
							tmp21 = lang.Apply(tmp20, nil)
						default:
							tmp21 = tmp20
						}
						tmp9 = tmp21
					}
					return tmp9
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(554), kw_column, int(7), kw_end_DASH_line, int(554), kw_end_DASH_column, int(127))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				tmp11 := lang.Apply(tmp8, []any{"unimplemented: new with non-constant class type", tmp10})
				return tmp11
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-into!
	{
		tmp0 := sym_stream_DASH_into_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_to, sym_stream), lang.NewVector(sym_to, sym_xform, sym_stream)), kw_doc, "Returns a new coll consisting of coll with all of the items of the\n  stream conjoined. This is a terminal operation on the stream.", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(7), kw_line, int(6810), kw_end_DASH_line, int(6810))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp7 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
				if lang.IsTruthy(tmp8) {
					tmp9 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp10 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
					tmp11 := checkDerefVar(var_glojure_DOT_core_stream_DASH_reduce_BANG_)
					tmp12 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_transient)
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp15 := lang.Apply(tmp11, []any{tmp12, tmp14, v4})
					tmp16 := lang.Apply(tmp10, []any{tmp15})
					tmp17 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.Apply(tmp9, []any{tmp16, tmp18})
					tmp5 = tmp19
				} else {
					tmp20 := checkDerefVar(var_glojure_DOT_core_stream_DASH_reduce_BANG_)
					tmp21 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp22 := lang.Apply(tmp20, []any{tmp21, v3, v4})
					tmp5 = tmp22
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp8 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
				if lang.IsTruthy(tmp9) {
					tmp10 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp11 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
					tmp12 := checkDerefVar(var_glojure_DOT_core_stream_DASH_transduce_BANG_)
					tmp13 := checkDerefVar(var_glojure_DOT_core_conj_BANG_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_transient)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(tmp12, []any{v4, tmp13, tmp15, v5})
					tmp17 := lang.Apply(tmp11, []any{tmp16})
					tmp18 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp19 := lang.Apply(tmp18, []any{v3})
					tmp20 := lang.Apply(tmp10, []any{tmp17, tmp19})
					tmp6 = tmp20
				} else {
					tmp21 := checkDerefVar(var_glojure_DOT_core_stream_DASH_transduce_BANG_)
					tmp22 := checkDerefVar(var_glojure_DOT_core_conj)
					tmp23 := lang.Apply(tmp21, []any{v4, tmp22, v3, v5})
					tmp6 = tmp23
				}
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-reduce!
	{
		tmp0 := sym_stream_DASH_reduce_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f, sym_s), lang.NewVector(sym_f, sym_init, sym_s)), kw_doc, "Works like reduce but takes a java.util.stream.BaseStream as its source.\n  Honors 'reduced', is a terminal operation on the stream", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(6784), kw_end_DASH_line, int(6784))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, ok := lang.FieldOrMethod(v4, "iterator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "iterator")))
				}
				var tmp6 any
				switch reflect.TypeOf(tmp5).Kind() {
				case reflect.Func:
					tmp6 = lang.Apply(tmp5, nil)
				default:
					tmp6 = tmp5
				}
				tmp7 := lang.Apply(nil, []any{tmp6, v3})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6, ok := lang.FieldOrMethod(v5, "iterator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "iterator")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				tmp8 := lang.Apply(nil, []any{tmp7, v3, v4})
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-seq!
	{
		tmp0 := sym_stream_DASH_seq_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_stream)), kw_doc, "Takes a java.util.stream.BaseStream instance s and returns a seq of its\n  contents. This is a terminal operation on the stream.", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(6793), kw_end_DASH_line, int(6793))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_iterator_DASH_seq)
			tmp5, ok := lang.FieldOrMethod(v3, "iterator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "iterator")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			tmp7 := lang.Apply(tmp4, []any{tmp6})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-transduce!
	{
		tmp0 := sym_stream_DASH_transduce_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xform, sym_f, sym_stream), lang.NewVector(sym_xform, sym_f, sym_init, sym_stream)), kw_doc, "Works like transduce but takes a java.util.stream.BaseStream as its source.\n  This is a terminal operation on the stream.", kw_file, "glojure/core.glj", kw_added, "1.12", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(6800), kw_end_DASH_line, int(6800))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_stream_DASH_transduce_BANG_)
				tmp7 := lang.Apply(v4, nil)
				tmp8 := lang.Apply(tmp6, []any{v3, v4, tmp7, v5})
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "f"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ret"
					tmp10 := checkDerefVar(var_glojure_DOT_core_stream_DASH_reduce_BANG_)
					tmp11 := lang.Apply(tmp10, []any{v9, v5, v6})
					var v12 any = tmp11
					_ = v12
					tmp13 := lang.Apply(v9, []any{v12})
					tmp7 = tmp13
				} // end let
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// string?
	{
		tmp0 := sym_string_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a String", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(2), kw_line, int(160), kw_end_DASH_line, int(164))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function string?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := lang.Apply(tmp5, []any{lang.Builtins["string"], v4})
				return tmp6
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(164), kw_column, int(10), kw_end_DASH_line, int(164), kw_end_DASH_column, int(58))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// strip-ns
	{
		tmp0 := sym_strip_DASH_ns.WithMeta(lang.NewMap(kw_file, "glojure/core_print.glj", kw_line, int(255), kw_column, int(8), kw_end_DASH_line, int(255), kw_end_DASH_column, int(15), kw_private, true, kw_arglists, lang.NewList(lang.NewVector(sym_named)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core_symbol)
				tmp8 := checkDerefVar(var_glojure_DOT_core_name)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp7, []any{nil, tmp9})
				tmp4 = tmp10
			} else {
				tmp11 := checkDerefVar(var_glojure_DOT_core_keyword)
				tmp12 := checkDerefVar(var_glojure_DOT_core_name)
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(tmp11, []any{nil, tmp13})
				tmp4 = tmp14
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// struct
	{
		tmp0 := sym_struct.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym__AMP_, sym_vals)), kw_doc, "Returns a new structmap instance with the keys of the\n  structure-basis. vals must be supplied for basis keys in order -\n  where values are not supplied they will default to nil.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4061), kw_end_DASH_line, int(4061))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(lang.ConstructPersistentStructMap, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// struct-map
	{
		tmp0 := sym_struct_DASH_map.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym__AMP_, sym_inits)), kw_doc, "Returns a new structmap instance with the keys of the\n  structure-basis. keyvals may contain all, some or none of the basis\n  keys - where values are not supplied they will default to nil.\n  keyvals can also contain keys not in the basis.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(4051), kw_end_DASH_line, int(4051))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(lang.CreatePersistentStructMap, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subs
	{
		tmp0 := sym_subs.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_s, sym_start), lang.NewVector(sym_s, sym_start, sym_end)), kw_doc, "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(5005), kw_end_DASH_line, int(5005))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.Builtins["slice"], []any{v3, v4})
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.Apply(lang.Builtins["slice"], []any{v3, v4, v5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subseq
	{
		tmp0 := sym_subseq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_sc, sym_test, sym_key), lang.NewVector(sym_sc, sym_start_DASH_test, sym_start_DASH_key, sym_end_DASH_test, sym_end_DASH_key)), kw_doc, "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5133), kw_end_DASH_line, int(5133))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "include"
					tmp7 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
					tmp8 := lang.Apply(tmp7, []any{v3, v4, v5})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core__GT_)
					tmp12 := checkDerefVar(var_glojure_DOT_core__GT__EQ_)
					tmp13 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{tmp11, tmp12}))
					tmp14 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5141), kw_column, int(11), kw_end_DASH_line, int(5141), kw_end_DASH_column, int(17))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp16 := lang.Apply(tmp15, []any{v4})
					if lang.IsTruthy(tmp16) {
						var tmp17 any
						{ // let
							// let binding "temp__0__auto__"
							tmp18, _ := lang.FieldOrMethod(v3, "seqFrom")
							if reflect.TypeOf(tmp18).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
							}
							tmp19 := lang.Apply(tmp18, []any{v5, true})
							var v20 any = tmp19
							_ = v20
							var tmp21 any
							if lang.IsTruthy(v20) {
								var tmp22 any
								{ // let
									// let binding "vec__68"
									var v23 any = v20
									_ = v23
									// let binding "e"
									tmp24 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp25 := lang.Apply(tmp24, []any{v23, int64(0), nil})
									var v26 any = tmp25
									_ = v26
									// let binding "s"
									var v27 any = v23
									_ = v27
									var tmp28 any
									tmp29 := lang.Apply(v9, []any{v26})
									if lang.IsTruthy(tmp29) {
										tmp28 = v27
									} else {
										tmp30 := checkDerefVar(var_glojure_DOT_core_next)
										tmp31 := lang.Apply(tmp30, []any{v27})
										tmp28 = tmp31
									}
									tmp22 = tmp28
								} // end let
								tmp21 = tmp22
							} else {
							}
							tmp17 = tmp21
						} // end let
						tmp10 = tmp17
					} else {
						tmp18 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
						tmp19, _ := lang.FieldOrMethod(v3, "seq")
						if reflect.TypeOf(tmp19).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("seq is not a function")))
						}
						tmp20 := lang.Apply(tmp19, []any{true})
						tmp21 := lang.Apply(tmp18, []any{v9, tmp20})
						tmp10 = tmp21
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var tmp8 any
				{ // let
					// let binding "temp__0__auto__"
					tmp9, _ := lang.FieldOrMethod(v3, "seqFrom")
					if reflect.TypeOf(tmp9).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
					}
					tmp10 := lang.Apply(tmp9, []any{v5, true})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						var tmp13 any
						{ // let
							// let binding "vec__71"
							var v14 any = v11
							_ = v14
							// let binding "e"
							tmp15 := checkDerefVar(var_glojure_DOT_core_nth)
							tmp16 := lang.Apply(tmp15, []any{v14, int64(0), nil})
							var v17 any = tmp16
							_ = v17
							// let binding "s"
							var v18 any = v14
							_ = v18
							tmp19 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
							tmp20 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
							tmp21 := lang.Apply(tmp20, []any{v3, v6, v7})
							var tmp22 any
							tmp23 := checkDerefVar(var_glojure_DOT_core_mk_DASH_bound_DASH_fn)
							tmp24 := lang.Apply(tmp23, []any{v3, v4, v5})
							tmp25 := lang.Apply(tmp24, []any{v17})
							if lang.IsTruthy(tmp25) {
								tmp22 = v18
							} else {
								tmp26 := checkDerefVar(var_glojure_DOT_core_next)
								tmp27 := lang.Apply(tmp26, []any{v18})
								tmp22 = tmp27
							}
							tmp28 := lang.Apply(tmp19, []any{tmp21, tmp22})
							tmp13 = tmp28
						} // end let
						tmp12 = tmp13
					} else {
					}
					tmp8 = tmp12
				} // end let
				return tmp8
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subvec
	{
		tmp0 := sym_subvec.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_v, sym_start), lang.NewVector(sym_v, sym_start, sym_end)), kw_doc, "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(3819), kw_end_DASH_line, int(3819))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_subvec)
				tmp6 := checkDerefVar(var_glojure_DOT_core_count)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := lang.Apply(tmp5, []any{v3, v4, tmp7})
				return tmp8
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(runtime.RT, "Subvec")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Subvec is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v3, v4, v5})
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// supers
	{
		tmp0 := sym_supers.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_class)), kw_doc, "Returns the immediate and indirect superclasses and interfaces of c, if any", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(5532), kw_end_DASH_line, int(5532))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := checkDerefVar(var_glojure_DOT_core_set)
				tmp6 := checkDerefVar(var_glojure_DOT_core_bases)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := lang.Apply(tmp5, []any{tmp7})
				var v9 any = tmp8
				_ = v9
				// let binding "cs"
				var v10 any = v9
				_ = v10
				for {
					var tmp11 any
					tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp13 := lang.Apply(tmp12, []any{v10})
					if lang.IsTruthy(tmp13) {
						var tmp14 any
						{ // let
							// let binding "c"
							tmp15 := checkDerefVar(var_glojure_DOT_core_first)
							tmp16 := lang.Apply(tmp15, []any{v10})
							var v17 any = tmp16
							_ = v17
							// let binding "bs"
							tmp18 := checkDerefVar(var_glojure_DOT_core_bases)
							tmp19 := lang.Apply(tmp18, []any{v17})
							var v20 any = tmp19
							_ = v20
							tmp22 := checkDerefVar(var_glojure_DOT_core_into1)
							tmp23 := lang.Apply(tmp22, []any{v9, v20})
							var tmp21 any = tmp23
							tmp25 := checkDerefVar(var_glojure_DOT_core_into1)
							tmp26 := checkDerefVar(var_glojure_DOT_core_disj)
							tmp27 := lang.Apply(tmp26, []any{v10, v17})
							tmp28 := lang.Apply(tmp25, []any{tmp27, v20})
							var tmp24 any = tmp28
							v9 = tmp21
							v10 = tmp24
							continue
						} // end let
						tmp11 = tmp14
					} else {
						tmp15 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
						tmp16 := lang.Apply(tmp15, []any{v9})
						tmp11 = tmp16
					}
					tmp4 = tmp11
					break
				}
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// swap!
	{
		tmp0 := sym_swap_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atom, sym_f, sym__AMP_, sym_args)), kw_doc, "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(2343), kw_end_DASH_line, int(2343))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "swap")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("swap is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// swap-vals!
	{
		tmp0 := sym_swap_DASH_vals_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_atom, sym_f, sym__AMP_, sym_args)), kw_doc, "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(2352), kw_end_DASH_line, int(2352))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "swapVals")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("swapVals is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// symbol
	{
		tmp1 := reflect.TypeOf((*lang.Symbol)(nil))
		tmp0 := sym_symbol.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_name), lang.NewVector(sym_ns, sym_name)), kw_doc, "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(584), kw_end_DASH_line, int(584))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
				tmp7 := lang.Apply(tmp6, []any{v4})
				if lang.IsTruthy(tmp7) {
					tmp5 = v4
				} else {
					var tmp8 any
					tmp9 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp10 := lang.Apply(tmp9, []any{lang.Builtins["string"], v4})
					if lang.IsTruthy(tmp10) {
						tmp11 := lang.Apply(lang.NewSymbol, []any{v4})
						tmp8 = tmp11
					} else {
						var tmp12 any
						tmp13 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
						tmp14 := reflect.TypeOf((*lang.Var)(nil))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v4})
						if lang.IsTruthy(tmp15) {
							tmp16, ok := lang.FieldOrMethod(v4, "toSymbol")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toSymbol")))
							}
							var tmp17 any
							switch reflect.TypeOf(tmp16).Kind() {
							case reflect.Func:
								tmp17 = lang.Apply(tmp16, nil)
							default:
								tmp17 = tmp16
							}
							tmp12 = tmp17
						} else {
							var tmp18 any
							tmp19 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
							tmp20 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
							tmp21 := lang.Apply(tmp19, []any{tmp20, v4})
							if lang.IsTruthy(tmp21) {
								tmp22, ok := lang.FieldOrMethod(v4, "sym")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "sym")))
								}
								var tmp23 any
								switch reflect.TypeOf(tmp22).Kind() {
								case reflect.Func:
									tmp23 = lang.Apply(tmp22, nil)
								default:
									tmp23 = tmp22
								}
								tmp18 = tmp23
							} else {
								var tmp24 any
								if lang.IsTruthy(kw_else) {
									tmp25 := lang.Apply(lang.NewIllegalArgumentError, []any{"no conversion to symbol"})
									panic(tmp25)
								} else {
								}
								tmp18 = tmp24
							}
							tmp12 = tmp18
						}
						tmp8 = tmp12
					}
					tmp5 = tmp8
				}
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.InternSymbol, []any{v4, v5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp4 := reflect.TypeOf((*lang.Symbol)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// symbol?
	{
		tmp0 := sym_symbol_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a Symbol", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(557), kw_end_DASH_line, int(557))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Symbol)(nil))
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sync
	{
		tmp0 := sym_sync.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_flags_DASH_ignored_DASH_for_DASH_now, sym__AMP_, sym_body)), kw_doc, "transaction-flags => TBD, pass nil for now\n\n  Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of sync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(2490), kw_end_DASH_line, int(2490))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym__DOT_})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_LockingTransaction})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{sym_glojure_DOT_core_SLASH_RunInTransaction})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp21 := checkDerefVar(var_glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp25 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp26 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp27 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp28 := lang.Apply(tmp27, nil)
				tmp29 := lang.Apply(tmp26, []any{tmp28})
				tmp30 := lang.Apply(tmp24, []any{tmp25, tmp29})
				tmp31 := lang.Apply(tmp23, []any{tmp30})
				tmp32 := lang.Apply(tmp20, []any{tmp22, tmp31, v6})
				tmp33 := lang.Apply(tmp19, []any{tmp32})
				tmp34 := lang.Apply(tmp18, []any{tmp33})
				tmp35 := lang.Apply(tmp15, []any{tmp17, tmp34})
				tmp36 := lang.Apply(tmp14, []any{tmp35})
				tmp37 := lang.Apply(tmp13, []any{tmp36})
				tmp38 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp37})
				tmp39 := lang.Apply(tmp7, []any{tmp38})
				return tmp39
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// system-newline
	{
		tmp0 := sym_system_DASH_newline.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(3695), kw_column, int(6), kw_end_DASH_line, int(3695), kw_end_DASH_column, int(40), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, "\n", true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tagged-literal
	{
		tmp0 := sym_tagged_DASH_literal.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag, sym_form)), kw_doc, "Construct a data representation of a tagged literal from a\n  tag symbol and a form.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(7769), kw_end_DASH_line, int(7769))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tagged-literal?
	{
		tmp0 := sym_tagged_DASH_literal_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_value)), kw_doc, "Return true if the value is the data representation of a tagged literal", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(7763), kw_end_DASH_line, int(7763))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := lang.Apply(tmp4, []any{nil, v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take
	{
		tmp0 := sym_take.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n), lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(2853), kw_end_DASH_line, int(2853))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "nv"
						tmp7 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{v3})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "n"
									tmp14 := checkDerefVar(var_glojure_DOT_core_deref)
									tmp15 := lang.Apply(tmp14, []any{v9})
									var v16 any = tmp15
									_ = v16
									// let binding "nn"
									tmp17 := checkDerefVar(var_glojure_DOT_core_dec)
									tmp18, ok := lang.FieldOrMethod(v9, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Deref")))
									}
									var tmp19 any
									switch reflect.TypeOf(tmp18).Kind() {
									case reflect.Func:
										tmp19 = lang.Apply(tmp18, nil)
									default:
										tmp19 = tmp18
									}
									tmp20 := lang.Apply(tmp17, []any{tmp19})
									tmp21, _ := lang.FieldOrMethod(v9, "reset")
									if reflect.TypeOf(tmp21).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp22 := lang.Apply(tmp21, []any{tmp20})
									var v23 any = tmp22
									_ = v23
									// let binding "result"
									var tmp24 any
									tmp25 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
									tmp26 := lang.Apply(tmp25, []any{v16})
									if lang.IsTruthy(tmp26) {
										tmp27 := lang.Apply(v5, []any{v11, v12})
										tmp24 = tmp27
									} else {
										tmp24 = v11
									}
									var v28 any = tmp24
									_ = v28
									var tmp29 any
									tmp30 := checkDerefVar(var_glojure_DOT_core_not)
									tmp31 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
									tmp32 := lang.Apply(tmp31, []any{v23})
									tmp33 := lang.Apply(tmp30, []any{tmp32})
									if lang.IsTruthy(tmp33) {
										tmp34 := checkDerefVar(var_glojure_DOT_core_ensure_DASH_reduced)
										tmp35 := lang.Apply(tmp34, []any{v28})
										tmp29 = tmp35
									} else {
										tmp29 = v28
									}
									tmp13 = tmp29
								} // end let
								return tmp13
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2862), kw_column, int(10), kw_end_DASH_line, int(2873), kw_end_DASH_column, int(28))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2860), kw_column, int(6), kw_end_DASH_line, int(2873), kw_end_DASH_column, int(30))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					tmp7 := checkDerefVar(var_glojure_DOT_core_pos_QMARK_)
					tmp8 := lang.Apply(tmp7, []any{v3})
					if lang.IsTruthy(tmp8) {
						var tmp9 any
						{ // let
							// let binding "temp__0__auto__"
							tmp10 := checkDerefVar(var_glojure_DOT_core_seq)
							tmp11 := lang.Apply(tmp10, []any{v4})
							var v12 any = tmp11
							_ = v12
							var tmp13 any
							if lang.IsTruthy(v12) {
								var tmp14 any
								{ // let
									// let binding "s"
									var v15 any = v12
									_ = v15
									tmp16 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp17 := checkDerefVar(var_glojure_DOT_core_first)
									tmp18 := lang.Apply(tmp17, []any{v15})
									tmp19 := checkDerefVar(var_glojure_DOT_core_take)
									tmp20 := checkDerefVar(var_glojure_DOT_core_dec)
									tmp21 := lang.Apply(tmp20, []any{v3})
									tmp22 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp23 := lang.Apply(tmp22, []any{v15})
									tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
									tmp25 := lang.Apply(tmp16, []any{tmp18, tmp24})
									tmp14 = tmp25
								} // end let
								tmp13 = tmp14
							} else {
							}
							tmp9 = tmp13
						} // end let
						tmp6 = tmp9
					} else {
					}
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-last
	{
		tmp0 := sym_take_DASH_last.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2939), kw_end_DASH_line, int(2939))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "s"
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := lang.Apply(tmp6, []any{v4})
				var v8 any = tmp7
				_ = v8
				// let binding "lead"
				tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp10 := checkDerefVar(var_glojure_DOT_core_drop)
				tmp11 := lang.Apply(tmp10, []any{v3, v4})
				tmp12 := lang.Apply(tmp9, []any{tmp11})
				var v13 any = tmp12
				_ = v13
				for {
					var tmp14 any
					if lang.IsTruthy(v13) {
						tmp16 := checkDerefVar(var_glojure_DOT_core_next)
						tmp17 := lang.Apply(tmp16, []any{v8})
						var tmp15 any = tmp17
						tmp19 := checkDerefVar(var_glojure_DOT_core_next)
						tmp20 := lang.Apply(tmp19, []any{v13})
						var tmp18 any = tmp20
						v8 = tmp15
						v13 = tmp18
						continue
					} else {
						tmp14 = v8
					}
					tmp5 = tmp14
					break
				}
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-nth
	{
		tmp0 := sym_take_DASH_nth.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_n), lang.NewVector(sym_n, sym_coll)), kw_doc, "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4287), kw_end_DASH_line, int(4287))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "iv"
						tmp7 := checkDerefVar(var_glojure_DOT_core_volatile_BANG_)
						tmp8 := lang.Apply(tmp7, []any{int64(-1)})
						var v9 any = tmp8
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp11 := lang.Apply(v5, nil)
								return tmp11
							case 1:
								v11 := args[0]
								_ = v11
								tmp12 := lang.Apply(v5, []any{v11})
								return tmp12
							case 2:
								v11 := args[0]
								_ = v11
								v12 := args[1]
								_ = v12
								var tmp13 any
								{ // let
									// let binding "i"
									tmp14 := checkDerefVar(var_glojure_DOT_core_inc)
									tmp15, ok := lang.FieldOrMethod(v9, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v9, "Deref")))
									}
									var tmp16 any
									switch reflect.TypeOf(tmp15).Kind() {
									case reflect.Func:
										tmp16 = lang.Apply(tmp15, nil)
									default:
										tmp16 = tmp15
									}
									tmp17 := lang.Apply(tmp14, []any{tmp16})
									tmp18, _ := lang.FieldOrMethod(v9, "reset")
									if reflect.TypeOf(tmp18).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp19 := lang.Apply(tmp18, []any{tmp17})
									var v20 any = tmp19
									_ = v20
									var tmp21 any
									tmp22 := checkDerefVar(var_glojure_DOT_core_zero_QMARK_)
									tmp23 := checkDerefVar(var_glojure_DOT_core_rem)
									tmp24 := lang.Apply(tmp23, []any{v20, v3})
									tmp25 := lang.Apply(tmp22, []any{tmp24})
									if lang.IsTruthy(tmp25) {
										tmp26 := lang.Apply(v5, []any{v11, v12})
										tmp21 = tmp26
									} else {
										tmp21 = v11
									}
									tmp13 = tmp21
								} // end let
								return tmp13
							default:
								checkArity(args, -1)
								panic("unreachable")
							}
						})
						tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4295), kw_column, int(10), kw_end_DASH_line, int(4302), kw_end_DASH_column, int(28))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4293), kw_column, int(6), kw_end_DASH_line, int(4302), kw_end_DASH_column, int(30))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								tmp13 := checkDerefVar(var_glojure_DOT_core_cons)
								tmp14 := checkDerefVar(var_glojure_DOT_core_first)
								tmp15 := lang.Apply(tmp14, []any{v12})
								tmp16 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
								tmp17 := checkDerefVar(var_glojure_DOT_core_drop)
								tmp18 := lang.Apply(tmp17, []any{v3, v12})
								tmp19 := lang.Apply(tmp16, []any{v3, tmp18})
								tmp20 := lang.Apply(tmp13, []any{tmp15, tmp19})
								tmp11 = tmp20
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-while
	{
		tmp0 := sym_take_DASH_while.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred), lang.NewVector(sym_pred, sym_coll)), kw_doc, "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(2880), kw_end_DASH_line, int(2880))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							tmp10 := lang.Apply(v3, []any{v8})
							if lang.IsTruthy(tmp10) {
								tmp11 := lang.Apply(v5, []any{v7, v8})
								tmp9 = tmp11
							} else {
								tmp12 := checkDerefVar(var_glojure_DOT_core_reduced)
								tmp13 := lang.Apply(tmp12, []any{v7})
								tmp9 = tmp13
							}
							return tmp9
						default:
							checkArity(args, -1)
							panic("unreachable")
						}
					})
					tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2888), kw_column, int(8), kw_end_DASH_line, int(2894), kw_end_DASH_column, int(33))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2887), kw_column, int(6), kw_end_DASH_line, int(2894), kw_end_DASH_column, int(34))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp8 := lang.Apply(tmp7, []any{v4})
						var v9 any = tmp8
						_ = v9
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "s"
								var v12 any = v9
								_ = v12
								var tmp13 any
								tmp14 := checkDerefVar(var_glojure_DOT_core_first)
								tmp15 := lang.Apply(tmp14, []any{v12})
								tmp16 := lang.Apply(v3, []any{tmp15})
								if lang.IsTruthy(tmp16) {
									tmp17 := checkDerefVar(var_glojure_DOT_core_cons)
									tmp18 := checkDerefVar(var_glojure_DOT_core_first)
									tmp19 := lang.Apply(tmp18, []any{v12})
									tmp20 := checkDerefVar(var_glojure_DOT_core_take_DASH_while)
									tmp21 := checkDerefVar(var_glojure_DOT_core_rest)
									tmp22 := lang.Apply(tmp21, []any{v12})
									tmp23 := lang.Apply(tmp20, []any{v3, tmp22})
									tmp24 := lang.Apply(tmp17, []any{tmp19, tmp23})
									tmp13 = tmp24
								} else {
								}
								tmp11 = tmp13
							} // end let
							tmp10 = tmp11
						} else {
						}
						tmp6 = tmp10
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tapset
	{
		tmp0 := sym_tapset.WithMeta(lang.NewMap(kw_private, true, kw_file, "glojure/core.glj", kw_line, int(7882), kw_column, int(10), kw_end_DASH_line, int(7882), kw_end_DASH_column, int(25), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core))).(*lang.Symbol)
		tmp2 := lang.NewAtom(lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{})))
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// test
	{
		tmp0 := sym_test.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_v)), kw_doc, "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(4853), kw_end_DASH_line, int(4853))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "f"
				tmp5 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp6 := lang.Apply(tmp5, []any{v3})
				tmp7 := lang.Apply(kw_test, []any{tmp6})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					tmp10 := lang.Apply(v8, nil)
					_ = tmp10
					tmp9 = kw_ok
				} else {
					tmp9 = kw_no_DASH_test
				}
				tmp4 = tmp9
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// the-ns
	{
		tmp0 := sym_the_DASH_ns.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "If passed a namespace, returns it. Else, when passed a symbol,\n  returns the namespace named by it, throwing an exception if not\n  found.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(4152), kw_end_DASH_line, int(4152))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp6 := reflect.TypeOf((*lang.Namespace)(nil))
			tmp7 := lang.Apply(tmp5, []any{tmp6, v3})
			if lang.IsTruthy(tmp7) {
				tmp4 = v3
			} else {
				var tmp8 any
				{ // let
					// let binding "or__0__auto__"
					tmp9 := checkDerefVar(var_glojure_DOT_core_find_DASH_ns)
					tmp10 := lang.Apply(tmp9, []any{v3})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						tmp12 = v11
					} else {
						tmp13 := checkDerefVar(var_glojure_DOT_core_str)
						tmp14 := lang.Apply(tmp13, []any{"No namespace: ", v3, " found"})
						tmp15 := lang.Apply(lang.NewError, []any{tmp14})
						panic(tmp15)
					}
					tmp8 = tmp12
				} // end let
				tmp4 = tmp8
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// thread-bound?
	{
		tmp0 := sym_thread_DASH_bound_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_vars)), kw_doc, "Returns true if all of the vars provided as arguments have thread-local bindings.\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.2", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(5499), kw_end_DASH_line, int(5499))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_every_QMARK_)
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v6 := args[0]
					_ = v6
					tmp7, ok := lang.FieldOrMethod(v6, "getThreadBinding")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "getThreadBinding")))
					}
					var tmp8 any
					switch reflect.TypeOf(tmp7).Kind() {
					case reflect.Func:
						tmp8 = lang.Apply(tmp7, nil)
					default:
						tmp8 = tmp7
					}
					return tmp8
				})
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5505), kw_column, int(11), kw_end_DASH_line, int(5505), kw_end_DASH_column, int(78))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp8 := lang.Apply(tmp4, []any{tmp7, v3})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// throw-if
	{
		tmp0 := sym_throw_DASH_if.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_pred, sym_fmt, sym__AMP_, sym_args)), kw_doc, "Throws a CompilerException with a message if pred is true", kw_file, "glojure/core.glj", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(8), kw_line, int(5832), kw_end_DASH_line, int(5832), kw_private, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v3) {
					var tmp7 any
					{ // let
						// let binding "message"
						tmp8 := checkDerefVar(var_glojure_DOT_core_apply)
						tmp9 := checkDerefVar(var_glojure_DOT_core_format)
						tmp10 := lang.Apply(tmp8, []any{tmp9, v4, v5})
						var v11 any = tmp10
						_ = v11
						// let binding "exception"
						tmp12 := lang.Apply(lang.NewError, []any{v11})
						var v13 any = tmp12
						_ = v13
						// let binding "raw-trace"
						tmp14, ok := lang.FieldOrMethod(v13, "getStackTrace")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v13, "getStackTrace")))
						}
						var tmp15 any
						switch reflect.TypeOf(tmp14).Kind() {
						case reflect.Func:
							tmp15 = lang.Apply(tmp14, nil)
						default:
							tmp15 = tmp14
						}
						var v16 any = tmp15
						_ = v16
						// let binding "boring?"
						var tmp17 lang.FnFunc
						tmp17 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 1)
							v18 := args[0]
							_ = v18
							tmp19 := checkDerefVar(var_glojure_DOT_core_not_EQ_)
							tmp20, ok := lang.FieldOrMethod(v18, "getMethodName")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v18, "getMethodName")))
							}
							var tmp21 any
							switch reflect.TypeOf(tmp20).Kind() {
							case reflect.Func:
								tmp21 = lang.Apply(tmp20, nil)
							default:
								tmp21 = tmp20
							}
							tmp22 := lang.Apply(tmp19, []any{tmp21, "doInvoke"})
							return tmp22
						})
						tmp18 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5839), kw_column, int(19), kw_end_DASH_line, int(5839), kw_end_DASH_column, int(74))
						tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v20 any = tmp19
						_ = v20
						// let binding "trace"
						tmp21 := checkDerefVar(var_glojure_DOT_core_into_DASH_array)
						tmp22 := checkDerefVar(var_glojure_DOT_core_drop)
						tmp23 := checkDerefVar(var_glojure_DOT_core_drop_DASH_while)
						tmp24 := lang.Apply(tmp23, []any{v20, v16})
						tmp25 := lang.Apply(tmp22, []any{int64(2), tmp24})
						tmp26 := lang.Apply(tmp21, []any{nil, tmp25})
						var v27 any = tmp26
						_ = v27
						tmp28, _ := lang.FieldOrMethod(v13, "setStackTrace")
						if reflect.TypeOf(tmp28).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setStackTrace is not a function")))
						}
						tmp29 := lang.Apply(tmp28, []any{v27})
						_ = tmp29
						tmp30 := checkDerefVar(var_glojure_DOT_core__STAR_file_STAR_)
						tmp31, ok := lang.FieldOrMethod(nil, "Deref")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "Deref")))
						}
						var tmp32 any
						switch reflect.TypeOf(tmp31).Kind() {
						case reflect.Func:
							tmp32 = lang.Apply(tmp31, nil)
						default:
							tmp32 = tmp31
						}
						tmp33, ok := lang.FieldOrMethod(nil, "Deref")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "Deref")))
						}
						var tmp34 any
						switch reflect.TypeOf(tmp33).Kind() {
						case reflect.Func:
							tmp34 = lang.Apply(tmp33, nil)
						default:
							tmp34 = tmp33
						}
						tmp35 := lang.Apply(lang.NewCompilerError, []any{tmp30, tmp32, tmp34, v13})
						panic(tmp35)
					} // end let
					tmp6 = tmp7
				} else {
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// time
	{
		tmp0 := sym_time.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_expr)), kw_doc, "Evaluates expr and prints the time it took.  Returns the value of\n expr.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(3885), kw_end_DASH_line, int(3885))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp8 := checkDerefVar(var_glojure_DOT_core_list)
			tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_let})
			tmp10 := checkDerefVar(var_glojure_DOT_core_list)
			tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
			tmp12 := checkDerefVar(var_glojure_DOT_core_vector)
			tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp15 := checkDerefVar(var_glojure_DOT_core_list)
			tmp16 := lang.Apply(tmp15, []any{sym_start__0__auto__})
			tmp17 := checkDerefVar(var_glojure_DOT_core_list)
			tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp20 := checkDerefVar(var_glojure_DOT_core_list)
			tmp21 := lang.Apply(tmp20, []any{sym__DOT_UnixNano})
			tmp22 := checkDerefVar(var_glojure_DOT_core_list)
			tmp23 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp24 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp25 := checkDerefVar(var_glojure_DOT_core_list)
			tmp26 := lang.Apply(tmp25, []any{sym_time_DOT_Now})
			tmp27 := lang.Apply(tmp24, []any{tmp26})
			tmp28 := lang.Apply(tmp23, []any{tmp27})
			tmp29 := lang.Apply(tmp22, []any{tmp28})
			tmp30 := lang.Apply(tmp19, []any{tmp21, tmp29})
			tmp31 := lang.Apply(tmp18, []any{tmp30})
			tmp32 := lang.Apply(tmp17, []any{tmp31})
			tmp33 := checkDerefVar(var_glojure_DOT_core_list)
			tmp34 := lang.Apply(tmp33, []any{sym_ret__1__auto__})
			tmp35 := checkDerefVar(var_glojure_DOT_core_list)
			tmp36 := lang.Apply(tmp35, []any{v5})
			tmp37 := lang.Apply(tmp14, []any{tmp16, tmp32, tmp34, tmp36})
			tmp38 := lang.Apply(tmp13, []any{tmp37})
			tmp39 := lang.Apply(tmp11, []any{tmp12, tmp38})
			tmp40 := lang.Apply(tmp10, []any{tmp39})
			tmp41 := checkDerefVar(var_glojure_DOT_core_list)
			tmp42 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp43 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp44 := checkDerefVar(var_glojure_DOT_core_list)
			tmp45 := lang.Apply(tmp44, []any{sym_glojure_DOT_core_SLASH_prn})
			tmp46 := checkDerefVar(var_glojure_DOT_core_list)
			tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp49 := checkDerefVar(var_glojure_DOT_core_list)
			tmp50 := lang.Apply(tmp49, []any{sym_glojure_DOT_core_SLASH_str})
			tmp51 := checkDerefVar(var_glojure_DOT_core_list)
			tmp52 := lang.Apply(tmp51, []any{"Elapsed time: "})
			tmp53 := checkDerefVar(var_glojure_DOT_core_list)
			tmp54 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp55 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp56 := checkDerefVar(var_glojure_DOT_core_list)
			tmp57 := lang.Apply(tmp56, []any{sym_glojure_DOT_core_SLASH__SLASH_})
			tmp58 := checkDerefVar(var_glojure_DOT_core_list)
			tmp59 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp60 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp61 := checkDerefVar(var_glojure_DOT_core_list)
			tmp62 := lang.Apply(tmp61, []any{sym_glojure_DOT_core_SLASH_double})
			tmp63 := checkDerefVar(var_glojure_DOT_core_list)
			tmp64 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp65 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp66 := checkDerefVar(var_glojure_DOT_core_list)
			tmp67 := lang.Apply(tmp66, []any{sym_glojure_DOT_core_SLASH__DASH_})
			tmp68 := checkDerefVar(var_glojure_DOT_core_list)
			tmp69 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp70 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp71 := checkDerefVar(var_glojure_DOT_core_list)
			tmp72 := lang.Apply(tmp71, []any{sym__DOT_UnixNano})
			tmp73 := checkDerefVar(var_glojure_DOT_core_list)
			tmp74 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp75 := checkDerefVar(var_glojure_DOT_core_concat)
			tmp76 := checkDerefVar(var_glojure_DOT_core_list)
			tmp77 := lang.Apply(tmp76, []any{sym_time_DOT_Now})
			tmp78 := lang.Apply(tmp75, []any{tmp77})
			tmp79 := lang.Apply(tmp74, []any{tmp78})
			tmp80 := lang.Apply(tmp73, []any{tmp79})
			tmp81 := lang.Apply(tmp70, []any{tmp72, tmp80})
			tmp82 := lang.Apply(tmp69, []any{tmp81})
			tmp83 := lang.Apply(tmp68, []any{tmp82})
			tmp84 := checkDerefVar(var_glojure_DOT_core_list)
			tmp85 := lang.Apply(tmp84, []any{sym_start__0__auto__})
			tmp86 := lang.Apply(tmp65, []any{tmp67, tmp83, tmp85})
			tmp87 := lang.Apply(tmp64, []any{tmp86})
			tmp88 := lang.Apply(tmp63, []any{tmp87})
			tmp89 := lang.Apply(tmp60, []any{tmp62, tmp88})
			tmp90 := lang.Apply(tmp59, []any{tmp89})
			tmp91 := lang.Apply(tmp58, []any{tmp90})
			tmp92 := checkDerefVar(var_glojure_DOT_core_list)
			tmp93 := lang.Apply(tmp92, []any{float64(1e+06)})
			tmp94 := lang.Apply(tmp55, []any{tmp57, tmp91, tmp93})
			tmp95 := lang.Apply(tmp54, []any{tmp94})
			tmp96 := lang.Apply(tmp53, []any{tmp95})
			tmp97 := checkDerefVar(var_glojure_DOT_core_list)
			tmp98 := lang.Apply(tmp97, []any{" msecs"})
			tmp99 := lang.Apply(tmp48, []any{tmp50, tmp52, tmp96, tmp98})
			tmp100 := lang.Apply(tmp47, []any{tmp99})
			tmp101 := lang.Apply(tmp46, []any{tmp100})
			tmp102 := lang.Apply(tmp43, []any{tmp45, tmp101})
			tmp103 := lang.Apply(tmp42, []any{tmp102})
			tmp104 := lang.Apply(tmp41, []any{tmp103})
			tmp105 := checkDerefVar(var_glojure_DOT_core_list)
			tmp106 := lang.Apply(tmp105, []any{sym_ret__1__auto__})
			tmp107 := lang.Apply(tmp7, []any{tmp9, tmp40, tmp104, tmp106})
			tmp108 := lang.Apply(tmp6, []any{tmp107})
			return tmp108
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-array
	{
		tmp0 := sym_to_DASH_array.WithMeta(lang.NewMap(kw_tag, "[Ljava.lang.Object;", kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns an array of Objects containing the contents of coll, which\n  can be any Collection.  Maps to java.util.Collection.toArray().", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(337), kw_end_DASH_line, int(337))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime.RT, "ToArray")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ToArray is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, "[Ljava.lang.Object;")).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-array-2d
	{
		tmp0 := sym_to_DASH_array_DASH_2d.WithMeta(lang.NewMap(kw_tag, "[[Ljava.lang.Object;", kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a (potentially-ragged) 2-dimensional array of Objects\n  containing the contents of coll, which can be any Collection of any\n  Collection.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(4002), kw_end_DASH_line, int(4002))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := checkDerefVar(var_glojure_DOT_core_make_DASH_array)
				tmp6 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
				tmp7, _ := lang.FieldOrMethod(tmp6, "forName")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("forName is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{"[Ljava.lang.Object;"})
				tmp9, _ := lang.FieldOrMethod(v3, "size")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("size is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{})
				tmp11 := lang.Apply(tmp5, []any{tmp8, tmp10})
				var v12 any = tmp11
				_ = v12
				var tmp13 any
				{ // let
					// let binding "i"
					var v14 any = int64(0)
					_ = v14
					// let binding "xs"
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := lang.Apply(tmp15, []any{v3})
					var v17 any = tmp16
					_ = v17
					for {
						var tmp18 any
						if lang.IsTruthy(v17) {
							tmp19 := checkDerefVar(var_glojure_DOT_core_aset)
							tmp20 := checkDerefVar(var_glojure_DOT_core_to_DASH_array)
							tmp21 := checkDerefVar(var_glojure_DOT_core_first)
							tmp22 := lang.Apply(tmp21, []any{v17})
							tmp23 := lang.Apply(tmp20, []any{tmp22})
							tmp24 := lang.Apply(tmp19, []any{v12, v14, tmp23})
							_ = tmp24
							tmp26 := checkDerefVar(var_glojure_DOT_core_inc)
							tmp27 := lang.Apply(tmp26, []any{v14})
							var tmp25 any = tmp27
							tmp29 := checkDerefVar(var_glojure_DOT_core_next)
							tmp30 := lang.Apply(tmp29, []any{v17})
							var tmp28 any = tmp30
							v14 = tmp25
							v17 = tmp28
							continue
						} else {
						}
						tmp13 = tmp18
						break
					}
				} // end let
				_ = tmp13
				tmp4 = v12
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, "[[Ljava.lang.Object;")).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// trampoline
	{
		tmp0 := sym_trampoline.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_f), lang.NewVector(sym_f, sym__AMP_, sym_args)), kw_doc, "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(7), kw_line, int(6293), kw_end_DASH_line, int(6293))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
			recur_loop_1073:
				var tmp4 any
				{ // let
					// let binding "ret"
					tmp5 := lang.Apply(v3, nil)
					var v6 any = tmp5
					_ = v6
					var tmp7 any
					tmp8 := checkDerefVar(var_glojure_DOT_core_fn_QMARK_)
					tmp9 := lang.Apply(tmp8, []any{v6})
					if lang.IsTruthy(tmp9) {
						var tmp10 any = v6
						v3 = tmp10
						goto recur_loop_1073
					} else {
						tmp7 = v6
					}
					tmp4 = tmp7
				} // end let
				return tmp4
			default:
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_trampoline)
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 0)
					tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp8 := lang.Apply(tmp7, []any{v3, v4})
					return tmp8
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6309), kw_column, int(18), kw_end_DASH_line, int(6309), kw_end_DASH_column, int(32))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// transduce
	{
		tmp0 := sym_transduce.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_xform, sym_f, sym_coll), lang.NewVector(sym_xform, sym_f, sym_init, sym_coll)), kw_doc, "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(6905), kw_end_DASH_line, int(6905))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_transduce)
				tmp7 := lang.Apply(v4, nil)
				tmp8 := lang.Apply(tmp6, []any{v3, v4, tmp7, v5})
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "f"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ret"
					var tmp10 any
					tmp11 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
					tmp12 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
					tmp13 := lang.Apply(tmp11, []any{tmp12, v6})
					if lang.IsTruthy(tmp13) {
						tmp14, _ := lang.FieldOrMethod(v6, "ReduceInit")
						if reflect.TypeOf(tmp14).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
						}
						tmp15 := lang.Apply(tmp14, []any{v9, v5})
						tmp10 = tmp15
					} else {
						tmp16 := checkDerefVar(var_glojure_DOT_core_DOT_protocols_coll_DASH_reduce)
						tmp17 := lang.Apply(tmp16, []any{v6, v9, v5})
						tmp10 = tmp17
					}
					var v18 any = tmp10
					_ = v18
					tmp19 := lang.Apply(v9, []any{v18})
					tmp7 = tmp19
				} // end let
				return tmp7
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// transient
	{
		tmp0 := sym_transient.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Returns a new, transient version of the collection, in constant time.\n\n  Transients support a parallel set of 'changing' operations, with similar names\n  followed by ! - assoc!, conj! etc. These do the same things as their persistent\n  counterparts except the return values are themselves transient.\n\n  Note in particular that transients are not designed to be bashed in-place. You\n  must capture and use the return value in the next call. In this way, they support\n  the same code structure as the functional persistent code they replace.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(3335), kw_end_DASH_line, int(3335))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "AsTransient")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "AsTransient")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tree-seq
	{
		tmp0 := sym_tree_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_branch_QMARK_, sym_children, sym_root)), kw_doc, "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(4955), kw_end_DASH_line, int(4955))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 3)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "walk"
				var tmp7 lang.FnFunc
				{ // function walk
					var v8 lang.FnFunc
					tmp7 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v9 := args[0]
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 0)
							tmp11 := checkDerefVar(var_glojure_DOT_core_cons)
							var tmp12 any
							tmp13 := lang.Apply(v3, []any{v9})
							if lang.IsTruthy(tmp13) {
								tmp14 := checkDerefVar(var_glojure_DOT_core_mapcat)
								tmp15 := lang.Apply(v4, []any{v9})
								tmp16 := lang.Apply(tmp14, []any{v8, tmp15})
								tmp12 = tmp16
							} else {
							}
							tmp17 := lang.Apply(tmp11, []any{v9, tmp12})
							return tmp17
						})
						tmp11 := lang.Apply(lang.NewLazySeq, []any{tmp10})
						return tmp11
					})
					v8 = tmp7
					_ = v8
				}
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(4965), kw_column, int(15), kw_end_DASH_line, int(4969), kw_end_DASH_column, int(53))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v10 any = tmp9
				_ = v10
				tmp11 := lang.Apply(v10, []any{v5})
				tmp6 = tmp11
			} // end let
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// true?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := sym_true_QMARK_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is the value true, false otherwise.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(511), kw_end_DASH_line, int(511))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Identical, []any{v4, true})
			return tmp5
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// type
	{
		tmp0 := sym_type.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns the :type metadata of x, or its Class if none", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(3467), kw_end_DASH_line, int(3467))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := checkDerefVar(var_glojure_DOT_core_get)
				tmp6 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := lang.Apply(tmp5, []any{tmp7, kw_type})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp10 = v9
				} else {
					tmp11 := checkDerefVar(var_glojure_DOT_core_class)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp10 = tmp12
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-add
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-add__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_UncheckedAdd})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_add.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the sum of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1203), kw_end_DASH_line, int(1203))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "UncheckedAdd")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedAdd is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-add-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-add-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Unchecked_int_add})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_add_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the sum of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(1196), kw_end_DASH_line, int(1196))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_add")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_add is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-byte
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-byte__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedByteCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_byte.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to byte. Subject to rounding or truncation.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(3517), kw_end_DASH_line, int(3517))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedByteCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-char
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-char__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedCharCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_char.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to char. Subject to rounding or truncation.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(3529), kw_end_DASH_line, int(3529))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime.RT, "UncheckedCharCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedCharCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-dec
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-dec__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedDec})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_dec.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one less than x, a long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1175), kw_end_DASH_line, int(1175))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "UncheckedDec")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedDec is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-dec-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-dec-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Unchecked_int_dec})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_dec_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one less than x, an int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(1168), kw_end_DASH_line, int(1168))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_dec")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_dec is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-divide-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-divide-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_UncheckedIntDivide})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_divide_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(26), kw_column, int(7), kw_line, int(1238), kw_end_DASH_line, int(1238))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "UncheckedIntDivide")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedIntDivide is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-double
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-double__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedDoubleCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_double.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to double. Subject to rounding.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(3553), kw_end_DASH_line, int(3553))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.AsFloat64, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-float
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-float__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedFloatCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_float.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to float. Subject to rounding.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(3547), kw_end_DASH_line, int(3547))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedFloatCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-inc
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-inc__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Unchecked_inc})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_inc.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one greater than x, a long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(1161), kw_end_DASH_line, int(1161))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_inc")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_inc is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-inc-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-inc-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Unchecked_int_inc})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_inc_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns a number one greater than x, an int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(7), kw_line, int(1154), kw_end_DASH_line, int(1154))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_inc")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_inc is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedIntCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to int. Subject to rounding or truncation.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(7), kw_line, int(3535), kw_end_DASH_line, int(3535))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedIntCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-long
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-long__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedLongCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_long.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to long. Subject to rounding or truncation.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(3541), kw_end_DASH_line, int(3541))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedLongCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-multiply
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-multiply__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Unchecked_multiply})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_multiply.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the product of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(1231), kw_end_DASH_line, int(1231))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_multiply")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_multiply is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-multiply-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-multiply-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Unchecked_int_multiply})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_multiply_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the product of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(28), kw_column, int(7), kw_line, int(1224), kw_end_DASH_line, int(1224))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_multiply")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_multiply is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-negate
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-negate__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Unchecked_minus})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_negate.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns the negation of x, a long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(22), kw_column, int(7), kw_line, int(1189), kw_end_DASH_line, int(1189))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_negate")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_negate is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-negate-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-negate-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_Unchecked_int_negate})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_negate_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Returns the negation of x, an int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(26), kw_column, int(7), kw_line, int(1182), kw_end_DASH_line, int(1182))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_negate")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_negate is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-remainder-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-remainder-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Unchecked_int_remainder})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_remainder_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the remainder of division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(29), kw_column, int(7), kw_line, int(1245), kw_end_DASH_line, int(1245))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_remainder")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_remainder is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-short
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-short__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_runtime_DOT_RT})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_UncheckedShortCast})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_short.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_inline, tmp1, kw_doc, "Coerce to short. Subject to rounding or truncation.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(7), kw_line, int(3523), kw_end_DASH_line, int(3523))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedShortCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-subtract
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-subtract__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Unchecked_minus})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_subtract.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the difference of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(7), kw_line, int(1217), kw_end_DASH_line, int(1217))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_minus")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_minus is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-subtract-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-subtract-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_Unchecked_int_subtract})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unchecked_DASH_subtract_DASH_int.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_y)), kw_inline, tmp1, kw_doc, "Returns the difference of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(28), kw_column, int(7), kw_line, int(1210), kw_end_DASH_line, int(1210))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_subtract")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_subtract is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// underive
	{
		tmp0 := sym_underive.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_tag, sym_parent), lang.NewVector(sym_h, sym_tag, sym_parent)), kw_doc, "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(7), kw_line, int(5643), kw_end_DASH_line, int(5643))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_alter_DASH_var_DASH_root)
				tmp6 := lang.InternVarName(sym_glojure_DOT_core, sym_global_DASH_hierarchy)
				tmp7 := checkDerefVar(var_glojure_DOT_core_underive)
				tmp8 := lang.Apply(tmp5, []any{tmp6, tmp7, v3, v4})
				_ = tmp8
				return nil
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "parentMap"
					tmp7 := lang.Apply(kw_parents, []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "childsParents"
					var tmp9 any
					tmp10 := lang.Apply(v8, []any{v4})
					if lang.IsTruthy(tmp10) {
						tmp11 := checkDerefVar(var_glojure_DOT_core_disj)
						tmp12 := lang.Apply(v8, []any{v4})
						tmp13 := lang.Apply(tmp11, []any{tmp12, v5})
						tmp9 = tmp13
					} else {
						tmp14 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
						tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5652), kw_column, int(36), kw_end_DASH_line, int(5652), kw_end_DASH_column, int(38))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp16
					}
					var v17 any = tmp9
					_ = v17
					// let binding "newParents"
					var tmp18 any
					tmp19 := checkDerefVar(var_glojure_DOT_core_not_DASH_empty)
					tmp20 := lang.Apply(tmp19, []any{v17})
					if lang.IsTruthy(tmp20) {
						tmp21 := checkDerefVar(var_glojure_DOT_core_assoc)
						tmp22 := lang.Apply(tmp21, []any{v8, v4, v17})
						tmp18 = tmp22
					} else {
						tmp23 := checkDerefVar(var_glojure_DOT_core_dissoc)
						tmp24 := lang.Apply(tmp23, []any{v8, v4})
						tmp18 = tmp24
					}
					var v25 any = tmp18
					_ = v25
					// let binding "deriv-seq"
					tmp26 := checkDerefVar(var_glojure_DOT_core_flatten)
					tmp27 := checkDerefVar(var_glojure_DOT_core_map)
					var tmp28 lang.FnFunc
					tmp28 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 1)
						v29 := args[0]
						_ = v29
						tmp30 := checkDerefVar(var_glojure_DOT_core_cons)
						tmp31 := checkDerefVar(var_glojure_DOT_core_key)
						tmp32 := lang.Apply(tmp31, []any{v29})
						tmp33 := checkDerefVar(var_glojure_DOT_core_interpose)
						tmp34 := checkDerefVar(var_glojure_DOT_core_key)
						tmp35 := lang.Apply(tmp34, []any{v29})
						tmp36 := checkDerefVar(var_glojure_DOT_core_val)
						tmp37 := lang.Apply(tmp36, []any{v29})
						tmp38 := lang.Apply(tmp33, []any{tmp35, tmp37})
						tmp39 := lang.Apply(tmp30, []any{tmp32, tmp38})
						return tmp39
					})
					tmp29 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5656), kw_column, int(28), kw_end_DASH_line, int(5656), kw_end_DASH_column, int(70))
					tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp31 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp32 := lang.Apply(tmp31, []any{v25})
					tmp33 := lang.Apply(tmp27, []any{tmp30, tmp32})
					tmp34 := lang.Apply(tmp26, []any{tmp33})
					var v35 any = tmp34
					_ = v35
					var tmp36 any
					tmp37 := checkDerefVar(var_glojure_DOT_core_contains_QMARK_)
					tmp38 := lang.Apply(v8, []any{v4})
					tmp39 := lang.Apply(tmp37, []any{tmp38, v5})
					if lang.IsTruthy(tmp39) {
						tmp40 := checkDerefVar(var_glojure_DOT_core_reduce1)
						var tmp41 lang.FnFunc
						tmp41 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 2)
							v42 := args[0]
							_ = v42
							v43 := args[1]
							_ = v43
							tmp44 := checkDerefVar(var_glojure_DOT_core_apply)
							tmp45 := checkDerefVar(var_glojure_DOT_core_derive)
							tmp46 := lang.Apply(tmp44, []any{tmp45, v42, v43})
							return tmp46
						})
						tmp42 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5659), kw_column, int(11), kw_end_DASH_line, int(5659), kw_end_DASH_column, int(31))
						tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp44 := checkDerefVar(var_glojure_DOT_core_make_DASH_hierarchy)
						tmp45 := lang.Apply(tmp44, nil)
						tmp46 := checkDerefVar(var_glojure_DOT_core_partition)
						tmp47 := lang.Apply(tmp46, []any{int64(2), v35})
						tmp48 := lang.Apply(tmp40, []any{tmp43, tmp45, tmp47})
						tmp36 = tmp48
					} else {
						tmp36 = v3
					}
					tmp6 = tmp36
				} // end let
				return tmp6
			default:
				checkArity(args, -1)
				panic("unreachable")
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unquote
	{
		tmp0 := sym_unquote.WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unquote-splicing
	{
		tmp0 := sym_unquote_DASH_splicing.WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unreduced
	{
		tmp0 := sym_unreduced.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "If x is reduced?, returns (deref x), else returns x", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2847), kw_end_DASH_line, int(2847))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_reduced_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				tmp7 := checkDerefVar(var_glojure_DOT_core_deref)
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp4 = tmp8
			} else {
				tmp4 = v3
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unsigned-bit-shift-right
	{
		var tmp1 lang.FnFunc
		{ // function unsigned-bit-shift-right__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp6 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := lang.Apply(tmp7, []any{sym__DOT_})
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp14 := checkDerefVar(var_glojure_DOT_core_list)
				tmp15 := lang.Apply(tmp14, []any{sym_glojure_DOT_core_SLASH_UnsignedShiftRight})
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := lang.Apply(tmp18, []any{v4})
				tmp20 := lang.Apply(tmp13, []any{tmp15, tmp17, tmp19})
				tmp21 := lang.Apply(tmp12, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp21})
				tmp23 := lang.Apply(tmp6, []any{tmp8, tmp10, tmp22})
				tmp24 := lang.Apply(tmp5, []any{tmp23})
				return tmp24
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_unsigned_DASH_bit_DASH_shift_DASH_right.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_n)), kw_inline, tmp1, kw_doc, "Bitwise shift right, without sign-extension.", kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(30), kw_column, int(7), kw_line, int(1373), kw_end_DASH_line, int(1373))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "UnsignedShiftRight")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UnsignedShiftRight is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update
	{
		tmp0 := sym_update.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_k, sym_f), lang.NewVector(sym_m, sym_k, sym_f, sym_x), lang.NewVector(sym_m, sym_k, sym_f, sym_x, sym_y), lang.NewVector(sym_m, sym_k, sym_f, sym_x, sym_y, sym_z), lang.NewVector(sym_m, sym_k, sym_f, sym_x, sym_y, sym_z, sym__AMP_, sym_more)), kw_doc, "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6174), kw_end_DASH_line, int(6174))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp7 := checkDerefVar(var_glojure_DOT_core_get)
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				tmp9 := lang.Apply(v5, []any{tmp8})
				tmp10 := lang.Apply(tmp6, []any{v3, v4, tmp9})
				return tmp10
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp8 := checkDerefVar(var_glojure_DOT_core_get)
				tmp9 := lang.Apply(tmp8, []any{v3, v4})
				tmp10 := lang.Apply(v5, []any{tmp9, v6})
				tmp11 := lang.Apply(tmp7, []any{v3, v4, tmp10})
				return tmp11
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp9 := checkDerefVar(var_glojure_DOT_core_get)
				tmp10 := lang.Apply(tmp9, []any{v3, v4})
				tmp11 := lang.Apply(v5, []any{tmp10, v6, v7})
				tmp12 := lang.Apply(tmp8, []any{v3, v4, tmp11})
				return tmp12
			case 6:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				tmp9 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp10 := checkDerefVar(var_glojure_DOT_core_get)
				tmp11 := lang.Apply(tmp10, []any{v3, v4})
				tmp12 := lang.Apply(v5, []any{tmp11, v6, v7, v8})
				tmp13 := lang.Apply(tmp9, []any{v3, v4, tmp12})
				return tmp13
			default:
				checkArity(args, 6)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				var v9 any = lang.NewList(args[6:]...)
				_ = v9
				tmp10 := checkDerefVar(var_glojure_DOT_core_assoc)
				tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_glojure_DOT_core_get)
				tmp13 := lang.Apply(tmp12, []any{v3, v4})
				tmp14 := lang.Apply(tmp11, []any{v5, tmp13, v6, v7, v8, v9})
				tmp15 := lang.Apply(tmp10, []any{v3, v4, tmp14})
				return tmp15
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-in
	{
		tmp0 := sym_update_DASH_in.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_ks, sym_f, sym__AMP_, sym_args)), kw_doc, "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(6158), kw_end_DASH_line, int(6158))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "up"
					var tmp8 lang.FnFunc
					{ // function up
						var v9 lang.FnFunc
						tmp8 = lang.NewFnFunc(func(args ...any) any {
							checkArity(args, 4)
							v10 := args[0]
							_ = v10
							v11 := args[1]
							_ = v11
							v12 := args[2]
							_ = v12
							v13 := args[3]
							_ = v13
							var tmp14 any
							{ // let
								// let binding "vec__141"
								var v15 any = v11
								_ = v15
								// let binding "seq__142"
								tmp16 := checkDerefVar(var_glojure_DOT_core_seq)
								tmp17 := lang.Apply(tmp16, []any{v15})
								var v18 any = tmp17
								_ = v18
								// let binding "first__143"
								tmp19 := checkDerefVar(var_glojure_DOT_core_first)
								tmp20 := lang.Apply(tmp19, []any{v18})
								var v21 any = tmp20
								_ = v21
								// let binding "seq__142"
								tmp22 := checkDerefVar(var_glojure_DOT_core_next)
								tmp23 := lang.Apply(tmp22, []any{v18})
								var v24 any = tmp23
								_ = v24
								// let binding "k"
								var v25 any = v21
								_ = v25
								// let binding "ks"
								var v26 any = v24
								_ = v26
								var tmp27 any
								if lang.IsTruthy(v26) {
									tmp28 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp29 := checkDerefVar(var_glojure_DOT_core_get)
									tmp30 := lang.Apply(tmp29, []any{v10, v25})
									tmp31 := lang.Apply(v9, []any{tmp30, v26, v12, v13})
									tmp32 := lang.Apply(tmp28, []any{v10, v25, tmp31})
									tmp27 = tmp32
								} else {
									tmp33 := checkDerefVar(var_glojure_DOT_core_assoc)
									tmp34 := checkDerefVar(var_glojure_DOT_core_apply)
									tmp35 := checkDerefVar(var_glojure_DOT_core_get)
									tmp36 := lang.Apply(tmp35, []any{v10, v25})
									tmp37 := lang.Apply(tmp34, []any{v12, tmp36, v13})
									tmp38 := lang.Apply(tmp33, []any{v10, v25, tmp37})
									tmp27 = tmp38
								}
								tmp14 = tmp27
							} // end let
							return tmp14
						})
						v9 = tmp8
						_ = v9
					}
					tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6167), kw_column, int(15), kw_end_DASH_line, int(6171), kw_end_DASH_column, int(59))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v11 any = tmp10
					_ = v11
					tmp12 := lang.Apply(v11, []any{v3, v4, v5, v6})
					tmp7 = tmp12
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-keys
	{
		tmp0 := sym_update_DASH_keys.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_f)), kw_doc, "m f => {(f k) v ...}\n\n  Given a map m and a function f of 1-argument, returns a new map whose\n  keys are the result of applying f to the keys of m, mapped to the\n  corresponding values of m.\n  f must return a unique key for each key of m, else the behavior is undefined.", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(7906), kw_end_DASH_line, int(7906))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "ret"
				tmp6 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
				tmp7 := checkDerefVar(var_glojure_DOT_core_reduce_DASH_kv)
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 3)
					v9 := args[0]
					_ = v9
					v10 := args[1]
					_ = v10
					v11 := args[2]
					_ = v11
					tmp12 := checkDerefVar(var_glojure_DOT_core_assoc_BANG_)
					tmp13 := lang.Apply(v4, []any{v10})
					tmp14 := lang.Apply(tmp12, []any{v9, tmp13, v11})
					return tmp14
				})
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7916), kw_column, int(25), kw_end_DASH_line, int(7916), kw_end_DASH_column, int(59))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp12 := lang.NewMap()
				tmp13 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7917), kw_column, int(36), kw_end_DASH_line, int(7917), kw_end_DASH_column, int(37))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp15 := lang.Apply(tmp11, []any{tmp14})
				tmp16 := lang.Apply(tmp7, []any{tmp10, tmp15, v3})
				tmp17 := lang.Apply(tmp6, []any{tmp16})
				var v18 any = tmp17
				_ = v18
				tmp19 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
				tmp20 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp21 := lang.Apply(tmp20, []any{v3})
				tmp22 := lang.Apply(tmp19, []any{v18, tmp21})
				tmp5 = tmp22
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-vals
	{
		tmp0 := sym_update_DASH_vals.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_m, sym_f)), kw_doc, "m f => {k (f v) ...}\n\n  Given a map m and a function f of 1-argument, returns a new map where the keys of m\n  are mapped to result of applying f to the corresponding values of m.", kw_file, "glojure/core.glj", kw_added, "1.11", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(17), kw_column, int(7), kw_line, int(7890), kw_end_DASH_line, int(7890))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
			tmp6 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
			tmp7 := checkDerefVar(var_glojure_DOT_core_reduce_DASH_kv)
			var tmp8 lang.FnFunc
			tmp8 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 3)
				v9 := args[0]
				_ = v9
				v10 := args[1]
				_ = v10
				v11 := args[2]
				_ = v11
				tmp12 := checkDerefVar(var_glojure_DOT_core_assoc_BANG_)
				tmp13 := lang.Apply(v4, []any{v11})
				tmp14 := lang.Apply(tmp12, []any{v9, v10, tmp13})
				return tmp14
			})
			tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7899), kw_column, int(17), kw_end_DASH_line, int(7899), kw_end_DASH_column, int(51))
			tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp11 any
			tmp12 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp13 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
			tmp14 := lang.Apply(tmp12, []any{tmp13, v3})
			if lang.IsTruthy(tmp14) {
				tmp15 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp11 = tmp16
			} else {
				tmp17 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp18 := lang.NewMap()
				tmp19 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7902), kw_column, int(30), kw_end_DASH_line, int(7902), kw_end_DASH_column, int(31))
				tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp21 := lang.Apply(tmp17, []any{tmp20})
				tmp11 = tmp21
			}
			tmp22 := lang.Apply(tmp7, []any{tmp10, tmp11, v3})
			tmp23 := lang.Apply(tmp6, []any{tmp22})
			tmp24 := checkDerefVar(var_glojure_DOT_core_meta)
			tmp25 := lang.Apply(tmp24, []any{v3})
			tmp26 := lang.Apply(tmp5, []any{tmp23, tmp25})
			return tmp26
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// uri?
	{
		tmp0 := sym_uri_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a java.net.URI", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(7877), kw_end_DASH_line, int(7877))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*url5.URL)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// use
	{
		tmp0 := sym_use.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_args)), kw_doc, "Like 'require, but also refers to each lib's namespace using\n  glojure.core/refer. Use :use in the ns macro in preference to calling\n  this directly.\n\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\n  The arguments and semantics for :exclude, :only, and :rename are the same\n  as those documented for glojure.core/refer.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(6079), kw_end_DASH_line, int(6079))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 0)
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp5 := checkDerefVar(var_glojure_DOT_core_load_DASH_libs)
				tmp6 := lang.Apply(tmp4, []any{tmp5, kw_require, kw_use, v3})
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// uuid?
	{
		tmp0 := sym_uuid_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x is a java.util.UUID", kw_file, "glojure/core.glj", kw_added, "1.9", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(6847), kw_end_DASH_line, int(6847))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf([16]uint8{})
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// val
	{
		tmp0 := sym_val.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_e)), kw_doc, "Returns the value in the map entry.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(1570), kw_end_DASH_line, int(1570))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "GetValue")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("GetValue is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vals
	{
		tmp0 := sym_vals.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_map)), kw_doc, "Returns a sequence of the map's values, in the same order as (seq map).", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(1557), kw_end_DASH_line, int(1557))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.Vals, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var-get
	{
		tmp0 := sym_var_DASH_get.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Gets the value in the var object", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4326), kw_end_DASH_line, int(4326))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "Get")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Get is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var-set
	{
		tmp0 := sym_var_DASH_set.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x, sym_val)), kw_doc, "Sets the value in the var object to val. The var must be\n thread-locally bound.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4332), kw_end_DASH_line, int(4332))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "Set")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Set is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var?
	{
		tmp0 := sym_var_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_v)), kw_doc, "Returns true if v is of type glojure.lang.Var", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(7), kw_line, int(4999), kw_end_DASH_line, int(4999))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Var)(nil))
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vary-meta
	{
		tmp0 := sym_vary_DASH_meta.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_obj, sym_f, sym__AMP_, sym_args)), kw_doc, "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(668), kw_end_DASH_line, int(668))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
				tmp7 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp8 := checkDerefVar(var_glojure_DOT_core_meta)
				tmp9 := lang.Apply(tmp8, []any{v3})
				tmp10 := lang.Apply(tmp7, []any{v4, tmp9, v5})
				tmp11 := lang.Apply(tmp6, []any{v3, tmp10})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vec
	{
		tmp0 := sym_vec.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_coll)), kw_doc, "Creates a new vector containing the contents of coll. Java arrays\n  will be aliased and should not be modified.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(9), kw_column, int(7), kw_line, int(366), kw_end_DASH_line, int(366))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
			tmp6 := lang.Apply(tmp5, []any{v3})
			if lang.IsTruthy(tmp6) {
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp9 := reflect.TypeOf((*lang.IObj)(nil)).Elem()
				tmp10 := lang.Apply(tmp8, []any{tmp9, v3})
				if lang.IsTruthy(tmp10) {
					tmp11 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp12 := lang.Apply(tmp11, []any{v3, nil})
					tmp7 = tmp12
				} else {
					tmp13 := lang.Apply(lang.CreateLazilyPersistentVector, []any{v3})
					tmp7 = tmp13
				}
				tmp4 = tmp7
			} else {
				tmp14 := lang.Apply(lang.CreateLazilyPersistentVector, []any{v3})
				tmp4 = tmp14
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vector
	{
		tmp0 := sym_vector.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(), lang.NewVector(sym_a), lang.NewVector(sym_a, sym_b), lang.NewVector(sym_a, sym_b, sym_c), lang.NewVector(sym_a, sym_b, sym_c, sym_d), lang.NewVector(sym_a, sym_b, sym_c, sym_d, sym_e), lang.NewVector(sym_a, sym_b, sym_c, sym_d, sym_e, sym_f), lang.NewVector(sym_a, sym_b, sym_c, sym_d, sym_e, sym_f, sym__AMP_, sym_args)), kw_doc, "Creates a new vector containing the args.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(352), kw_end_DASH_line, int(352))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.NewVector()
				tmp4 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(356), kw_column, int(7), kw_end_DASH_line, int(356), kw_end_DASH_column, int(8))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.NewVector(v3)
				tmp5 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(357), kw_column, int(8), kw_end_DASH_line, int(357), kw_end_DASH_column, int(10))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.NewVector(v3, v4)
				tmp6 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(358), kw_column, int(10), kw_end_DASH_line, int(358), kw_end_DASH_column, int(14))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.NewVector(v3, v4, v5)
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(359), kw_column, int(12), kw_end_DASH_line, int(359), kw_end_DASH_column, int(18))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.NewVector(v3, v4, v5, v6)
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(360), kw_column, int(14), kw_end_DASH_line, int(360), kw_end_DASH_column, int(22))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp9
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := lang.NewVector(v3, v4, v5, v6, v7)
				tmp9 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(361), kw_column, int(15), kw_end_DASH_line, int(361), kw_end_DASH_column, int(25))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp10
			case 6:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				tmp9 := lang.NewVector(v3, v4, v5, v6, v7, v8)
				tmp10 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(362), kw_column, int(17), kw_end_DASH_line, int(362), kw_end_DASH_column, int(29))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp11
			default:
				checkArity(args, 6)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				var v9 any = lang.NewList(args[6:]...)
				_ = v9
				tmp10 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp11 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp12 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp13 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp14 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp15 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp16 := lang.Apply(tmp15, []any{v8, v9})
				tmp17 := lang.Apply(tmp14, []any{v7, tmp16})
				tmp18 := lang.Apply(tmp13, []any{v6, tmp17})
				tmp19 := lang.Apply(tmp12, []any{v5, tmp18})
				tmp20 := lang.Apply(tmp11, []any{v4, tmp19})
				tmp21 := lang.Apply(tmp10, []any{v3, tmp20})
				tmp22 := lang.Apply(lang.CreateLazilyPersistentVector, []any{tmp21})
				return tmp22
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vector?
	{
		tmp0 := sym_vector_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Return true if x implements IPersistentVector", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(8), kw_column, int(2), kw_line, int(174), kw_end_DASH_line, int(178))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function vector?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v4 := args[0]
				_ = v4
				tmp5 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
				tmp6 := reflect.TypeOf((*lang.IPersistentVector)(nil)).Elem()
				tmp7 := lang.Apply(tmp5, []any{tmp6, v4})
				return tmp7
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(178), kw_column, int(10), kw_end_DASH_line, int(178), kw_end_DASH_column, int(106))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// volatile!
	{
		tmp1 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
		tmp0 := sym_volatile_BANG_.WithMeta(lang.NewMap(kw_tag, tmp1, kw_arglists, lang.NewList(lang.NewVector(sym_val)), kw_doc, "Creates and returns a Volatile with an initial value of val.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2517), kw_end_DASH_line, int(2517))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.NewVolatile, []any{v4})
			return tmp5
		})
		tmp4 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// volatile?
	{
		tmp0 := sym_volatile_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_x)), kw_doc, "Returns true if x is a volatile.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(7), kw_line, int(2540), kw_end_DASH_line, int(2540))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_instance_QMARK_)
			tmp5 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
			tmp6 := lang.Apply(tmp4, []any{tmp5, v3})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vreset!
	{
		tmp0 := sym_vreset_BANG_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_vol, sym_newval)), kw_doc, "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(2524), kw_end_DASH_line, int(2524))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "reset")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vswap!
	{
		tmp0 := sym_vswap_BANG_.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_vol, sym_f, sym__AMP_, sym_args)), kw_doc, "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", kw_file, "glojure/core.glj", kw_added, "1.7", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(16), kw_column, int(11), kw_line, int(2531), kw_end_DASH_line, int(2531))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 4)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 any
				{ // let
					// let binding "v"
					tmp9 := checkDerefVar(var_glojure_DOT_core_with_DASH_meta)
					tmp10 := lang.NewMap(kw_tag, sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Volatile)
					tmp11 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(2537), kw_column, int(26), kw_end_DASH_line, int(2537), kw_end_DASH_column, int(81))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := lang.Apply(tmp9, []any{v5, tmp12})
					var v14 any = tmp13
					_ = v14
					tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp16 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp17 := checkDerefVar(var_glojure_DOT_core_list)
					tmp18 := lang.Apply(tmp17, []any{sym__DOT_reset})
					tmp19 := checkDerefVar(var_glojure_DOT_core_list)
					tmp20 := lang.Apply(tmp19, []any{v14})
					tmp21 := checkDerefVar(var_glojure_DOT_core_list)
					tmp22 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp23 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp24 := checkDerefVar(var_glojure_DOT_core_list)
					tmp25 := lang.Apply(tmp24, []any{v6})
					tmp26 := checkDerefVar(var_glojure_DOT_core_list)
					tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp28 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp29 := checkDerefVar(var_glojure_DOT_core_list)
					tmp30 := lang.Apply(tmp29, []any{sym__DOT_Deref})
					tmp31 := checkDerefVar(var_glojure_DOT_core_list)
					tmp32 := lang.Apply(tmp31, []any{v14})
					tmp33 := lang.Apply(tmp28, []any{tmp30, tmp32})
					tmp34 := lang.Apply(tmp27, []any{tmp33})
					tmp35 := lang.Apply(tmp26, []any{tmp34})
					tmp36 := lang.Apply(tmp23, []any{tmp25, tmp35, v7})
					tmp37 := lang.Apply(tmp22, []any{tmp36})
					tmp38 := lang.Apply(tmp21, []any{tmp37})
					tmp39 := lang.Apply(tmp16, []any{tmp18, tmp20, tmp38})
					tmp40 := lang.Apply(tmp15, []any{tmp39})
					tmp8 = tmp40
				} // end let
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when
	{
		tmp0 := sym_when.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_test, sym__AMP_, sym_body)), kw_doc, "Evaluates test. If logical true, evaluates body in an implicit do.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(14), kw_column, int(11), kw_line, int(492), kw_end_DASH_line, int(492))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{sym_do, v6})
				tmp10 := lang.Apply(tmp7, []any{sym_if, v5, tmp9})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-first
	{
		tmp0 := sym_when_DASH_first.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(11), kw_line, int(4622), kw_end_DASH_line, int(4622))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_str)
					tmp11 := checkDerefVar(var_glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(kw_line, []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp21 := checkDerefVar(var_glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{int64(2), tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "exactly 2 forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "vec__20"
					var v34 any = v5
					_ = v34
					// let binding "x"
					tmp35 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp36 := lang.Apply(tmp35, []any{v34, int64(0), nil})
					var v37 any = tmp36
					_ = v37
					// let binding "xs"
					tmp38 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp39 := lang.Apply(tmp38, []any{v34, int64(1), nil})
					var v40 any = tmp39
					_ = v40
					tmp41 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp42 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp43 := checkDerefVar(var_glojure_DOT_core_list)
					tmp44 := lang.Apply(tmp43, []any{sym_glojure_DOT_core_SLASH_when_DASH_let})
					tmp45 := checkDerefVar(var_glojure_DOT_core_list)
					tmp46 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp47 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp48 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp49 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp50 := checkDerefVar(var_glojure_DOT_core_list)
					tmp51 := lang.Apply(tmp50, []any{sym_xs__0__auto__})
					tmp52 := checkDerefVar(var_glojure_DOT_core_list)
					tmp53 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp54 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp55 := checkDerefVar(var_glojure_DOT_core_list)
					tmp56 := lang.Apply(tmp55, []any{sym_glojure_DOT_core_SLASH_seq})
					tmp57 := checkDerefVar(var_glojure_DOT_core_list)
					tmp58 := lang.Apply(tmp57, []any{v40})
					tmp59 := lang.Apply(tmp54, []any{tmp56, tmp58})
					tmp60 := lang.Apply(tmp53, []any{tmp59})
					tmp61 := lang.Apply(tmp52, []any{tmp60})
					tmp62 := lang.Apply(tmp49, []any{tmp51, tmp61})
					tmp63 := lang.Apply(tmp48, []any{tmp62})
					tmp64 := lang.Apply(tmp46, []any{tmp47, tmp63})
					tmp65 := lang.Apply(tmp45, []any{tmp64})
					tmp66 := checkDerefVar(var_glojure_DOT_core_list)
					tmp67 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp68 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp69 := checkDerefVar(var_glojure_DOT_core_list)
					tmp70 := lang.Apply(tmp69, []any{sym_glojure_DOT_core_SLASH_let})
					tmp71 := checkDerefVar(var_glojure_DOT_core_list)
					tmp72 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp73 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp74 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp75 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp76 := checkDerefVar(var_glojure_DOT_core_list)
					tmp77 := lang.Apply(tmp76, []any{v37})
					tmp78 := checkDerefVar(var_glojure_DOT_core_list)
					tmp79 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp80 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp81 := checkDerefVar(var_glojure_DOT_core_list)
					tmp82 := lang.Apply(tmp81, []any{sym_glojure_DOT_core_SLASH_first})
					tmp83 := checkDerefVar(var_glojure_DOT_core_list)
					tmp84 := lang.Apply(tmp83, []any{sym_xs__0__auto__})
					tmp85 := lang.Apply(tmp80, []any{tmp82, tmp84})
					tmp86 := lang.Apply(tmp79, []any{tmp85})
					tmp87 := lang.Apply(tmp78, []any{tmp86})
					tmp88 := lang.Apply(tmp75, []any{tmp77, tmp87})
					tmp89 := lang.Apply(tmp74, []any{tmp88})
					tmp90 := lang.Apply(tmp72, []any{tmp73, tmp89})
					tmp91 := lang.Apply(tmp71, []any{tmp90})
					tmp92 := lang.Apply(tmp68, []any{tmp70, tmp91, v6})
					tmp93 := lang.Apply(tmp67, []any{tmp92})
					tmp94 := lang.Apply(tmp66, []any{tmp93})
					tmp95 := lang.Apply(tmp42, []any{tmp44, tmp65, tmp94})
					tmp96 := lang.Apply(tmp41, []any{tmp95})
					tmp33 = tmp96
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-let
	{
		tmp0 := sym_when_DASH_let.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(1859), kw_end_DASH_line, int(1859))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_str)
					tmp11 := checkDerefVar(var_glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(kw_line, []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp21 := checkDerefVar(var_glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{int64(2), tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "exactly 2 forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "form"
					tmp34 := lang.Apply(v5, []any{int64(0)})
					var v35 any = tmp34
					_ = v35
					// let binding "tst"
					tmp36 := lang.Apply(v5, []any{int64(1)})
					var v37 any = tmp36
					_ = v37
					tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp39 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{sym_glojure_DOT_core_SLASH_let})
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					tmp43 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp44 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp45 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp46 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp47 := checkDerefVar(var_glojure_DOT_core_list)
					tmp48 := lang.Apply(tmp47, []any{sym_temp__0__auto__})
					tmp49 := checkDerefVar(var_glojure_DOT_core_list)
					tmp50 := lang.Apply(tmp49, []any{v37})
					tmp51 := lang.Apply(tmp46, []any{tmp48, tmp50})
					tmp52 := lang.Apply(tmp45, []any{tmp51})
					tmp53 := lang.Apply(tmp43, []any{tmp44, tmp52})
					tmp54 := lang.Apply(tmp42, []any{tmp53})
					tmp55 := checkDerefVar(var_glojure_DOT_core_list)
					tmp56 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp57 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp58 := checkDerefVar(var_glojure_DOT_core_list)
					tmp59 := lang.Apply(tmp58, []any{sym_glojure_DOT_core_SLASH_when})
					tmp60 := checkDerefVar(var_glojure_DOT_core_list)
					tmp61 := lang.Apply(tmp60, []any{sym_temp__0__auto__})
					tmp62 := checkDerefVar(var_glojure_DOT_core_list)
					tmp63 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp64 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp65 := checkDerefVar(var_glojure_DOT_core_list)
					tmp66 := lang.Apply(tmp65, []any{sym_glojure_DOT_core_SLASH_let})
					tmp67 := checkDerefVar(var_glojure_DOT_core_list)
					tmp68 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp69 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp70 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp71 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp72 := checkDerefVar(var_glojure_DOT_core_list)
					tmp73 := lang.Apply(tmp72, []any{v35})
					tmp74 := checkDerefVar(var_glojure_DOT_core_list)
					tmp75 := lang.Apply(tmp74, []any{sym_temp__0__auto__})
					tmp76 := lang.Apply(tmp71, []any{tmp73, tmp75})
					tmp77 := lang.Apply(tmp70, []any{tmp76})
					tmp78 := lang.Apply(tmp68, []any{tmp69, tmp77})
					tmp79 := lang.Apply(tmp67, []any{tmp78})
					tmp80 := lang.Apply(tmp64, []any{tmp66, tmp79, v6})
					tmp81 := lang.Apply(tmp63, []any{tmp80})
					tmp82 := lang.Apply(tmp62, []any{tmp81})
					tmp83 := lang.Apply(tmp57, []any{tmp59, tmp61, tmp82})
					tmp84 := lang.Apply(tmp56, []any{tmp83})
					tmp85 := lang.Apply(tmp55, []any{tmp84})
					tmp86 := lang.Apply(tmp39, []any{tmp41, tmp54, tmp85})
					tmp87 := lang.Apply(tmp38, []any{tmp86})
					tmp33 = tmp87
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-not
	{
		tmp0 := sym_when_DASH_not.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_test, sym__AMP_, sym_body)), kw_doc, "Evaluates test. If logical false, evaluates body in an implicit do.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(18), kw_column, int(11), kw_line, int(498), kw_end_DASH_line, int(498))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_list)
				tmp8 := checkDerefVar(var_glojure_DOT_core_cons)
				tmp9 := lang.Apply(tmp8, []any{sym_do, v6})
				tmp10 := lang.Apply(tmp7, []any{sym_if, v5, nil, tmp9})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-some
	{
		tmp0 := sym_when_DASH_some.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "bindings => binding-form test\n\n   When test is not nil, evaluates body with binding-form bound to the\n   value of test", kw_file, "glojure/core.glj", kw_added, "1.6", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(1894), kw_end_DASH_line, int(1894))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_str)
					tmp11 := checkDerefVar(var_glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(kw_line, []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp21 := checkDerefVar(var_glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{int64(2), tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "exactly 2 forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				{ // let
					// let binding "form"
					tmp34 := lang.Apply(v5, []any{int64(0)})
					var v35 any = tmp34
					_ = v35
					// let binding "tst"
					tmp36 := lang.Apply(v5, []any{int64(1)})
					var v37 any = tmp36
					_ = v37
					tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp39 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{sym_glojure_DOT_core_SLASH_let})
					tmp42 := checkDerefVar(var_glojure_DOT_core_list)
					tmp43 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp44 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp45 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp46 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp47 := checkDerefVar(var_glojure_DOT_core_list)
					tmp48 := lang.Apply(tmp47, []any{sym_temp__0__auto__})
					tmp49 := checkDerefVar(var_glojure_DOT_core_list)
					tmp50 := lang.Apply(tmp49, []any{v37})
					tmp51 := lang.Apply(tmp46, []any{tmp48, tmp50})
					tmp52 := lang.Apply(tmp45, []any{tmp51})
					tmp53 := lang.Apply(tmp43, []any{tmp44, tmp52})
					tmp54 := lang.Apply(tmp42, []any{tmp53})
					tmp55 := checkDerefVar(var_glojure_DOT_core_list)
					tmp56 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp57 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp58 := checkDerefVar(var_glojure_DOT_core_list)
					tmp59 := lang.Apply(tmp58, []any{sym_if})
					tmp60 := checkDerefVar(var_glojure_DOT_core_list)
					tmp61 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp62 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp63 := checkDerefVar(var_glojure_DOT_core_list)
					tmp64 := lang.Apply(tmp63, []any{sym_glojure_DOT_core_SLASH_nil_QMARK_})
					tmp65 := checkDerefVar(var_glojure_DOT_core_list)
					tmp66 := lang.Apply(tmp65, []any{sym_temp__0__auto__})
					tmp67 := lang.Apply(tmp62, []any{tmp64, tmp66})
					tmp68 := lang.Apply(tmp61, []any{tmp67})
					tmp69 := lang.Apply(tmp60, []any{tmp68})
					tmp70 := checkDerefVar(var_glojure_DOT_core_list)
					tmp71 := lang.Apply(tmp70, []any{nil})
					tmp72 := checkDerefVar(var_glojure_DOT_core_list)
					tmp73 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp74 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp75 := checkDerefVar(var_glojure_DOT_core_list)
					tmp76 := lang.Apply(tmp75, []any{sym_glojure_DOT_core_SLASH_let})
					tmp77 := checkDerefVar(var_glojure_DOT_core_list)
					tmp78 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp79 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp80 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp81 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp82 := checkDerefVar(var_glojure_DOT_core_list)
					tmp83 := lang.Apply(tmp82, []any{v35})
					tmp84 := checkDerefVar(var_glojure_DOT_core_list)
					tmp85 := lang.Apply(tmp84, []any{sym_temp__0__auto__})
					tmp86 := lang.Apply(tmp81, []any{tmp83, tmp85})
					tmp87 := lang.Apply(tmp80, []any{tmp86})
					tmp88 := lang.Apply(tmp78, []any{tmp79, tmp87})
					tmp89 := lang.Apply(tmp77, []any{tmp88})
					tmp90 := lang.Apply(tmp74, []any{tmp76, tmp89, v6})
					tmp91 := lang.Apply(tmp73, []any{tmp90})
					tmp92 := lang.Apply(tmp72, []any{tmp91})
					tmp93 := lang.Apply(tmp57, []any{tmp59, tmp69, tmp71, tmp92})
					tmp94 := lang.Apply(tmp56, []any{tmp93})
					tmp95 := lang.Apply(tmp55, []any{tmp94})
					tmp96 := lang.Apply(tmp39, []any{tmp41, tmp54, tmp95})
					tmp97 := lang.Apply(tmp38, []any{tmp96})
					tmp33 = tmp97
				} // end let
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// while
	{
		tmp0 := sym_while.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_test, sym__AMP_, sym_body)), kw_doc, "Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(15), kw_column, int(11), kw_line, int(6327), kw_end_DASH_line, int(6327))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_loop})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp13 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp16 := lang.Apply(tmp15, nil)
				tmp17 := lang.Apply(tmp14, []any{tmp16})
				tmp18 := lang.Apply(tmp12, []any{tmp13, tmp17})
				tmp19 := lang.Apply(tmp11, []any{tmp18})
				tmp20 := checkDerefVar(var_glojure_DOT_core_list)
				tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp22 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := lang.Apply(tmp23, []any{sym_glojure_DOT_core_SLASH_when})
				tmp25 := checkDerefVar(var_glojure_DOT_core_list)
				tmp26 := lang.Apply(tmp25, []any{v5})
				tmp27 := checkDerefVar(var_glojure_DOT_core_list)
				tmp28 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp29 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp30 := checkDerefVar(var_glojure_DOT_core_list)
				tmp31 := lang.Apply(tmp30, []any{sym_recur})
				tmp32 := lang.Apply(tmp29, []any{tmp31})
				tmp33 := lang.Apply(tmp28, []any{tmp32})
				tmp34 := lang.Apply(tmp27, []any{tmp33})
				tmp35 := lang.Apply(tmp22, []any{tmp24, tmp26, v6, tmp34})
				tmp36 := lang.Apply(tmp21, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp8, []any{tmp10, tmp19, tmp37})
				tmp39 := lang.Apply(tmp7, []any{tmp38})
				return tmp39
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-bindings
	{
		tmp0 := sym_with_DASH_bindings.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_binding_DASH_map, sym__AMP_, sym_body)), kw_doc, "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then executes body. Pops the installed\n  bindings after body was evaluated. Returns the value of body.", kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(23), kw_column, int(11), kw_line, int(1984), kw_end_DASH_line, int(1984))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_with_DASH_bindings_STAR_})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{v5})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp20 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp21 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp22 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp23 := lang.Apply(tmp22, nil)
				tmp24 := lang.Apply(tmp21, []any{tmp23})
				tmp25 := lang.Apply(tmp19, []any{tmp20, tmp24})
				tmp26 := lang.Apply(tmp18, []any{tmp25})
				tmp27 := lang.Apply(tmp15, []any{tmp17, tmp26, v6})
				tmp28 := lang.Apply(tmp14, []any{tmp27})
				tmp29 := lang.Apply(tmp13, []any{tmp28})
				tmp30 := lang.Apply(tmp8, []any{tmp10, tmp12, tmp29})
				tmp31 := lang.Apply(tmp7, []any{tmp30})
				return tmp31
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-bindings*
	{
		tmp0 := sym_with_DASH_bindings_STAR_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_binding_DASH_map, sym_f, sym__AMP_, sym_args)), kw_doc, "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then calls f with the supplied arguments.\n  Pops the installed bindings after f returned. Returns whatever f returns.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.1", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(1971), kw_end_DASH_line, int(1971))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_push_DASH_thread_DASH_bindings)
				tmp7 := lang.Apply(tmp6, []any{v3})
				_ = tmp7
				var tmp8 any
				func() {
					defer func() {
						tmp9 := checkDerefVar(var_glojure_DOT_core_pop_DASH_thread_DASH_bindings)
						tmp10 := lang.Apply(tmp9, nil)
						_ = tmp10
					}()
					tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp12 := lang.Apply(tmp11, []any{v4, v5})
					tmp8 = tmp12
				}()
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-in-str
	{
		tmp0 := sym_with_DASH_in_DASH_str.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_s, sym__AMP_, sym_body)), kw_doc, "Evaluates body in a context in which *in* is bound to a fresh\n  StringReader initialized with the string s.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(11), kw_line, int(4749), kw_end_DASH_line, int(4749))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_with_DASH_open})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp13 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp14 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp15 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp16 := checkDerefVar(var_glojure_DOT_core_list)
				tmp17 := lang.Apply(tmp16, []any{sym_s__0__auto__})
				tmp18 := checkDerefVar(var_glojure_DOT_core_list)
				tmp19 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp20 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp21 := checkDerefVar(var_glojure_DOT_core_list)
				tmp22 := lang.Apply(tmp21, []any{sym_glojure_DOT_core_SLASH__DASH__GT_})
				tmp23 := checkDerefVar(var_glojure_DOT_core_list)
				tmp24 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp25 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp26 := checkDerefVar(var_glojure_DOT_core_list)
				tmp27 := lang.Apply(tmp26, []any{sym_java_DOT_io_DOT_StringReader_DOT_})
				tmp28 := checkDerefVar(var_glojure_DOT_core_list)
				tmp29 := lang.Apply(tmp28, []any{v5})
				tmp30 := lang.Apply(tmp25, []any{tmp27, tmp29})
				tmp31 := lang.Apply(tmp24, []any{tmp30})
				tmp32 := lang.Apply(tmp23, []any{tmp31})
				tmp33 := checkDerefVar(var_glojure_DOT_core_list)
				tmp34 := lang.Apply(tmp33, []any{sym_glojure_DOT_lang_DOT_LineNumberingPushbackReader_DOT_})
				tmp35 := lang.Apply(tmp20, []any{tmp22, tmp32, tmp34})
				tmp36 := lang.Apply(tmp19, []any{tmp35})
				tmp37 := lang.Apply(tmp18, []any{tmp36})
				tmp38 := lang.Apply(tmp15, []any{tmp17, tmp37})
				tmp39 := lang.Apply(tmp14, []any{tmp38})
				tmp40 := lang.Apply(tmp12, []any{tmp13, tmp39})
				tmp41 := lang.Apply(tmp11, []any{tmp40})
				tmp42 := checkDerefVar(var_glojure_DOT_core_list)
				tmp43 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp44 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp45 := checkDerefVar(var_glojure_DOT_core_list)
				tmp46 := lang.Apply(tmp45, []any{sym_glojure_DOT_core_SLASH_binding})
				tmp47 := checkDerefVar(var_glojure_DOT_core_list)
				tmp48 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp49 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp50 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp51 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp52 := checkDerefVar(var_glojure_DOT_core_list)
				tmp53 := lang.Apply(tmp52, []any{sym_glojure_DOT_core_SLASH__STAR_in_STAR_})
				tmp54 := checkDerefVar(var_glojure_DOT_core_list)
				tmp55 := lang.Apply(tmp54, []any{sym_s__0__auto__})
				tmp56 := lang.Apply(tmp51, []any{tmp53, tmp55})
				tmp57 := lang.Apply(tmp50, []any{tmp56})
				tmp58 := lang.Apply(tmp48, []any{tmp49, tmp57})
				tmp59 := lang.Apply(tmp47, []any{tmp58})
				tmp60 := lang.Apply(tmp44, []any{tmp46, tmp59, v6})
				tmp61 := lang.Apply(tmp43, []any{tmp60})
				tmp62 := lang.Apply(tmp42, []any{tmp61})
				tmp63 := lang.Apply(tmp8, []any{tmp10, tmp41, tmp62})
				tmp64 := lang.Apply(tmp7, []any{tmp63})
				return tmp64
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-loading-context
	{
		tmp0 := sym_with_DASH_loading_DASH_context.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5734), kw_column, int(11), kw_end_DASH_line, int(5734), kw_end_DASH_column, int(30), kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_macro, true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp10 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := lang.Apply(tmp11, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_loading__0__auto__})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp17 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp20 := lang.Apply(tmp19, nil)
				tmp21 := lang.Apply(tmp18, []any{tmp20})
				tmp22 := lang.Apply(tmp16, []any{tmp17, tmp21})
				tmp23 := lang.Apply(tmp15, []any{tmp22})
				tmp24 := checkDerefVar(var_glojure_DOT_core_list)
				tmp25 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp26 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp27 := checkDerefVar(var_glojure_DOT_core_list)
				tmp28 := lang.Apply(tmp27, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PushThreadBindings})
				tmp29 := checkDerefVar(var_glojure_DOT_core_list)
				tmp30 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp31 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
				tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp33 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp34 := lang.Apply(tmp33, nil)
				tmp35 := lang.Apply(tmp32, []any{tmp34})
				tmp36 := lang.Apply(tmp30, []any{tmp31, tmp35})
				tmp37 := lang.Apply(tmp29, []any{tmp36})
				tmp38 := lang.Apply(tmp26, []any{tmp28, tmp37})
				tmp39 := lang.Apply(tmp25, []any{tmp38})
				tmp40 := lang.Apply(tmp24, []any{tmp39})
				tmp41 := checkDerefVar(var_glojure_DOT_core_list)
				tmp42 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp43 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp44 := checkDerefVar(var_glojure_DOT_core_list)
				tmp45 := lang.Apply(tmp44, []any{sym_try})
				tmp46 := checkDerefVar(var_glojure_DOT_core_list)
				tmp47 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp48 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp49 := checkDerefVar(var_glojure_DOT_core_list)
				tmp50 := lang.Apply(tmp49, []any{sym_finally})
				tmp51 := checkDerefVar(var_glojure_DOT_core_list)
				tmp52 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp53 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp54 := checkDerefVar(var_glojure_DOT_core_list)
				tmp55 := lang.Apply(tmp54, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PopThreadBindings})
				tmp56 := lang.Apply(tmp53, []any{tmp55})
				tmp57 := lang.Apply(tmp52, []any{tmp56})
				tmp58 := lang.Apply(tmp51, []any{tmp57})
				tmp59 := lang.Apply(tmp48, []any{tmp50, tmp58})
				tmp60 := lang.Apply(tmp47, []any{tmp59})
				tmp61 := lang.Apply(tmp46, []any{tmp60})
				tmp62 := lang.Apply(tmp43, []any{tmp45, v5, tmp61})
				tmp63 := lang.Apply(tmp42, []any{tmp62})
				tmp64 := lang.Apply(tmp41, []any{tmp63})
				tmp65 := lang.Apply(tmp10, []any{tmp12, tmp14, tmp23, tmp40, tmp64})
				tmp66 := lang.Apply(tmp9, []any{tmp65})
				tmp67 := lang.Apply(tmp8, []any{tmp66})
				tmp68 := lang.Apply(tmp7, []any{tmp67})
				tmp69 := lang.Apply(tmp6, []any{tmp68})
				return tmp69
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-local-vars
	{
		tmp0 := sym_with_DASH_local_DASH_vars.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_name_DASH_vals_DASH_vec, sym__AMP_, sym_body)), kw_doc, "varbinding=> symbol init-expr\n\n  Executes the exprs in a context in which the symbols are bound to\n  vars with per-thread bindings to the init-exprs.  The symbols refer\n  to the var objects themselves, and must be accessed with var-get and\n  var-set", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(25), kw_column, int(11), kw_line, int(4339), kw_end_DASH_line, int(4339))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_str)
					tmp11 := checkDerefVar(var_glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(kw_line, []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(var_glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				tmp33 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp34 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp35 := checkDerefVar(var_glojure_DOT_core_list)
				tmp36 := lang.Apply(tmp35, []any{sym_glojure_DOT_core_SLASH_let})
				tmp37 := checkDerefVar(var_glojure_DOT_core_list)
				tmp38 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp39 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp40 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp41 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp42 := checkDerefVar(var_glojure_DOT_core_interleave)
				tmp43 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
				tmp44 := lang.Apply(tmp43, []any{int64(2), v5})
				tmp45 := checkDerefVar(var_glojure_DOT_core_repeat)
				tmp46 := lang.Apply(tmp45, []any{lang.NewList(sym__DOT__DOT_, sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT__STAR_Var, sym_create, sym_setDynamic)})
				tmp47 := lang.Apply(tmp42, []any{tmp44, tmp46})
				tmp48 := lang.Apply(tmp41, []any{tmp47})
				tmp49 := lang.Apply(tmp40, []any{tmp48})
				tmp50 := lang.Apply(tmp38, []any{tmp39, tmp49})
				tmp51 := lang.Apply(tmp37, []any{tmp50})
				tmp52 := checkDerefVar(var_glojure_DOT_core_list)
				tmp53 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp54 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp55 := checkDerefVar(var_glojure_DOT_core_list)
				tmp56 := lang.Apply(tmp55, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PushThreadBindings})
				tmp57 := checkDerefVar(var_glojure_DOT_core_list)
				tmp58 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp59 := checkDerefVar(var_glojure_DOT_core_hash_DASH_map)
				tmp60 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp61 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp62 := lang.Apply(tmp61, nil)
				tmp63 := lang.Apply(tmp60, []any{tmp62})
				tmp64 := lang.Apply(tmp58, []any{tmp59, tmp63})
				tmp65 := lang.Apply(tmp57, []any{tmp64})
				tmp66 := lang.Apply(tmp54, []any{tmp56, tmp65})
				tmp67 := lang.Apply(tmp53, []any{tmp66})
				tmp68 := lang.Apply(tmp52, []any{tmp67})
				tmp69 := checkDerefVar(var_glojure_DOT_core_list)
				tmp70 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp71 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp72 := checkDerefVar(var_glojure_DOT_core_list)
				tmp73 := lang.Apply(tmp72, []any{sym_try})
				tmp74 := checkDerefVar(var_glojure_DOT_core_list)
				tmp75 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp76 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp77 := checkDerefVar(var_glojure_DOT_core_list)
				tmp78 := lang.Apply(tmp77, []any{sym_finally})
				tmp79 := checkDerefVar(var_glojure_DOT_core_list)
				tmp80 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp81 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp82 := checkDerefVar(var_glojure_DOT_core_list)
				tmp83 := lang.Apply(tmp82, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_PopThreadBindings})
				tmp84 := lang.Apply(tmp81, []any{tmp83})
				tmp85 := lang.Apply(tmp80, []any{tmp84})
				tmp86 := lang.Apply(tmp79, []any{tmp85})
				tmp87 := lang.Apply(tmp76, []any{tmp78, tmp86})
				tmp88 := lang.Apply(tmp75, []any{tmp87})
				tmp89 := lang.Apply(tmp74, []any{tmp88})
				tmp90 := lang.Apply(tmp71, []any{tmp73, v6, tmp89})
				tmp91 := lang.Apply(tmp70, []any{tmp90})
				tmp92 := lang.Apply(tmp69, []any{tmp91})
				tmp93 := lang.Apply(tmp34, []any{tmp36, tmp51, tmp68, tmp92})
				tmp94 := lang.Apply(tmp33, []any{tmp93})
				return tmp94
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-meta
	{
		tmp0 := sym_with_DASH_meta.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_obj, sym_m)), kw_doc, "Returns an object of the same type and value as obj, with\n    map m as its metadata.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(10), kw_column, int(2), kw_line, int(211), kw_end_DASH_line, int(216))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function with-meta
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 2)
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v4, "WithMeta")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("WithMeta is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v5})
				return tmp7
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(216), kw_column, int(12), kw_end_DASH_line, int(217), kw_end_DASH_column, int(32))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-open
	{
		tmp0 := sym_with_DASH_open.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "bindings => [name init ...]\n\n  Evaluates body in a try expression with names bound to the values\n  of the inits, and a finally clause that calls (.close name) on each\n  name in reverse order.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(19), kw_column, int(11), kw_line, int(3832), kw_end_DASH_line, int(3832))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := checkDerefVar(var_glojure_DOT_core_vector_QMARK_)
				tmp9 := lang.Apply(tmp8, []any{v5})
				if lang.IsTruthy(tmp9) {
				} else {
					tmp10 := checkDerefVar(var_glojure_DOT_core_str)
					tmp11 := checkDerefVar(var_glojure_DOT_core_first)
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp14 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp16 := lang.Apply(kw_line, []any{tmp15})
					tmp17 := lang.Apply(tmp10, []any{tmp12, " requires ", "a vector for its binding", " in ", tmp13, ":", tmp16})
					tmp18 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp17})
					panic(tmp18)
				}
				_ = tmp7
				var tmp19 any
				tmp20 := checkDerefVar(var_glojure_DOT_core_even_QMARK_)
				tmp21 := checkDerefVar(var_glojure_DOT_core_count)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{tmp22})
				if lang.IsTruthy(tmp23) {
				} else {
					tmp24 := checkDerefVar(var_glojure_DOT_core_str)
					tmp25 := checkDerefVar(var_glojure_DOT_core_first)
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := checkDerefVar(var_glojure_DOT_core__STAR_ns_STAR_)
					tmp28 := checkDerefVar(var_glojure_DOT_core_meta)
					tmp29 := lang.Apply(tmp28, []any{v3})
					tmp30 := lang.Apply(kw_line, []any{tmp29})
					tmp31 := lang.Apply(tmp24, []any{tmp26, " requires ", "an even number of forms in binding vector", " in ", tmp27, ":", tmp30})
					tmp32 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp31})
					panic(tmp32)
				}
				_ = tmp19
				var tmp33 any
				tmp34 := checkDerefVar(var_glojure_DOT_core__EQ_)
				tmp35 := checkDerefVar(var_glojure_DOT_core_count)
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp34, []any{tmp36, int64(0)})
				if lang.IsTruthy(tmp37) {
					tmp38 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp39 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp40 := checkDerefVar(var_glojure_DOT_core_list)
					tmp41 := lang.Apply(tmp40, []any{sym_do})
					tmp42 := lang.Apply(tmp39, []any{tmp41, v6})
					tmp43 := lang.Apply(tmp38, []any{tmp42})
					tmp33 = tmp43
				} else {
					var tmp44 any
					tmp45 := checkDerefVar(var_glojure_DOT_core_symbol_QMARK_)
					tmp46 := lang.Apply(v5, []any{int64(0)})
					tmp47 := lang.Apply(tmp45, []any{tmp46})
					if lang.IsTruthy(tmp47) {
						tmp48 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp49 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp50 := checkDerefVar(var_glojure_DOT_core_list)
						tmp51 := lang.Apply(tmp50, []any{sym_glojure_DOT_core_SLASH_let})
						tmp52 := checkDerefVar(var_glojure_DOT_core_list)
						tmp53 := checkDerefVar(var_glojure_DOT_core_subvec)
						tmp54 := lang.Apply(tmp53, []any{v5, int64(0), int64(2)})
						tmp55 := lang.Apply(tmp52, []any{tmp54})
						tmp56 := checkDerefVar(var_glojure_DOT_core_list)
						tmp57 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp58 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp59 := checkDerefVar(var_glojure_DOT_core_list)
						tmp60 := lang.Apply(tmp59, []any{sym_try})
						tmp61 := checkDerefVar(var_glojure_DOT_core_list)
						tmp62 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp63 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp64 := checkDerefVar(var_glojure_DOT_core_list)
						tmp65 := lang.Apply(tmp64, []any{sym_glojure_DOT_core_SLASH_with_DASH_open})
						tmp66 := checkDerefVar(var_glojure_DOT_core_list)
						tmp67 := checkDerefVar(var_glojure_DOT_core_subvec)
						tmp68 := lang.Apply(tmp67, []any{v5, int64(2)})
						tmp69 := lang.Apply(tmp66, []any{tmp68})
						tmp70 := lang.Apply(tmp63, []any{tmp65, tmp69, v6})
						tmp71 := lang.Apply(tmp62, []any{tmp70})
						tmp72 := lang.Apply(tmp61, []any{tmp71})
						tmp73 := checkDerefVar(var_glojure_DOT_core_list)
						tmp74 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp75 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp76 := checkDerefVar(var_glojure_DOT_core_list)
						tmp77 := lang.Apply(tmp76, []any{sym_finally})
						tmp78 := checkDerefVar(var_glojure_DOT_core_list)
						tmp79 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp80 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp81 := checkDerefVar(var_glojure_DOT_core_list)
						tmp82 := lang.Apply(tmp81, []any{sym__DOT_})
						tmp83 := checkDerefVar(var_glojure_DOT_core_list)
						tmp84 := lang.Apply(v5, []any{int64(0)})
						tmp85 := lang.Apply(tmp83, []any{tmp84})
						tmp86 := checkDerefVar(var_glojure_DOT_core_list)
						tmp87 := lang.Apply(tmp86, []any{sym_close})
						tmp88 := lang.Apply(tmp80, []any{tmp82, tmp85, tmp87})
						tmp89 := lang.Apply(tmp79, []any{tmp88})
						tmp90 := lang.Apply(tmp78, []any{tmp89})
						tmp91 := lang.Apply(tmp75, []any{tmp77, tmp90})
						tmp92 := lang.Apply(tmp74, []any{tmp91})
						tmp93 := lang.Apply(tmp73, []any{tmp92})
						tmp94 := lang.Apply(tmp58, []any{tmp60, tmp72, tmp93})
						tmp95 := lang.Apply(tmp57, []any{tmp94})
						tmp96 := lang.Apply(tmp56, []any{tmp95})
						tmp97 := lang.Apply(tmp49, []any{tmp51, tmp55, tmp96})
						tmp98 := lang.Apply(tmp48, []any{tmp97})
						tmp44 = tmp98
					} else {
						var tmp99 any
						if lang.IsTruthy(kw_else) {
							tmp100 := lang.Apply(lang.NewIllegalArgumentError, []any{"with-open only allows Symbols in bindings"})
							panic(tmp100)
						} else {
						}
						tmp44 = tmp99
					}
					tmp33 = tmp44
				}
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-out-str
	{
		tmp0 := sym_with_DASH_out_DASH_str.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym__AMP_, sym_body)), kw_doc, "Evaluates exprs in a context in which *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(22), kw_column, int(11), kw_line, int(4738), kw_end_DASH_line, int(4738))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 2)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp7 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_glojure_DOT_core_SLASH_let})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp12 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp13 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp14 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{sym_s__0__auto__})
				tmp17 := checkDerefVar(var_glojure_DOT_core_list)
				tmp18 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp19 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp20 := checkDerefVar(var_glojure_DOT_core_list)
				tmp21 := lang.Apply(tmp20, []any{sym_new})
				tmp22 := checkDerefVar(var_glojure_DOT_core_list)
				tmp23 := lang.Apply(tmp22, []any{sym_strings_DOT_Builder})
				tmp24 := lang.Apply(tmp19, []any{tmp21, tmp23})
				tmp25 := lang.Apply(tmp18, []any{tmp24})
				tmp26 := lang.Apply(tmp17, []any{tmp25})
				tmp27 := lang.Apply(tmp14, []any{tmp16, tmp26})
				tmp28 := lang.Apply(tmp13, []any{tmp27})
				tmp29 := lang.Apply(tmp11, []any{tmp12, tmp28})
				tmp30 := lang.Apply(tmp10, []any{tmp29})
				tmp31 := checkDerefVar(var_glojure_DOT_core_list)
				tmp32 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp33 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp34 := checkDerefVar(var_glojure_DOT_core_list)
				tmp35 := lang.Apply(tmp34, []any{sym_glojure_DOT_core_SLASH_binding})
				tmp36 := checkDerefVar(var_glojure_DOT_core_list)
				tmp37 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp38 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp39 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp40 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp41 := checkDerefVar(var_glojure_DOT_core_list)
				tmp42 := lang.Apply(tmp41, []any{sym_glojure_DOT_core_SLASH__STAR_out_STAR_})
				tmp43 := checkDerefVar(var_glojure_DOT_core_list)
				tmp44 := lang.Apply(tmp43, []any{sym_s__0__auto__})
				tmp45 := lang.Apply(tmp40, []any{tmp42, tmp44})
				tmp46 := lang.Apply(tmp39, []any{tmp45})
				tmp47 := lang.Apply(tmp37, []any{tmp38, tmp46})
				tmp48 := lang.Apply(tmp36, []any{tmp47})
				tmp49 := checkDerefVar(var_glojure_DOT_core_list)
				tmp50 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp51 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp52 := checkDerefVar(var_glojure_DOT_core_list)
				tmp53 := lang.Apply(tmp52, []any{sym_glojure_DOT_core_SLASH_str})
				tmp54 := checkDerefVar(var_glojure_DOT_core_list)
				tmp55 := lang.Apply(tmp54, []any{sym_s__0__auto__})
				tmp56 := lang.Apply(tmp51, []any{tmp53, tmp55})
				tmp57 := lang.Apply(tmp50, []any{tmp56})
				tmp58 := lang.Apply(tmp49, []any{tmp57})
				tmp59 := lang.Apply(tmp33, []any{tmp35, tmp48, v5, tmp58})
				tmp60 := lang.Apply(tmp32, []any{tmp59})
				tmp61 := lang.Apply(tmp31, []any{tmp60})
				tmp62 := lang.Apply(tmp7, []any{tmp9, tmp30, tmp61})
				tmp63 := lang.Apply(tmp6, []any{tmp62})
				return tmp63
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-precision
	{
		tmp0 := sym_with_DASH_precision.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_precision, sym__AMP_, sym_exprs)), kw_doc, "Sets the precision and rounding mode to be used for BigDecimal operations.\n\n  Usage: (with-precision 10 (/ 1M 3))\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\n\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(24), kw_column, int(11), kw_line, int(5110), kw_end_DASH_line, int(5110))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "vec__65"
					var tmp8 any
					tmp9 := checkDerefVar(var_glojure_DOT_core__EQ_)
					tmp10 := checkDerefVar(var_glojure_DOT_core_first)
					tmp11 := lang.Apply(tmp10, []any{v6})
					tmp12 := lang.Apply(tmp9, []any{tmp11, kw_rounding})
					if lang.IsTruthy(tmp12) {
						tmp13 := checkDerefVar(var_glojure_DOT_core_next)
						tmp14 := checkDerefVar(var_glojure_DOT_core_next)
						tmp15 := lang.Apply(tmp14, []any{v6})
						tmp16 := lang.Apply(tmp13, []any{tmp15})
						tmp17 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp18 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp19 := checkDerefVar(var_glojure_DOT_core_list)
						tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp21 := checkDerefVar(var_glojure_DOT_core_concat)
						tmp22 := checkDerefVar(var_glojure_DOT_core_list)
						tmp23 := lang.Apply(tmp22, []any{sym__DOT_})
						tmp24 := checkDerefVar(var_glojure_DOT_core_list)
						tmp25 := lang.Apply(tmp24, []any{sym_java_DOT_math_DOT_RoundingMode})
						tmp26 := checkDerefVar(var_glojure_DOT_core_list)
						tmp27 := checkDerefVar(var_glojure_DOT_core_second)
						tmp28 := lang.Apply(tmp27, []any{v6})
						tmp29 := lang.Apply(tmp26, []any{tmp28})
						tmp30 := lang.Apply(tmp21, []any{tmp23, tmp25, tmp29})
						tmp31 := lang.Apply(tmp20, []any{tmp30})
						tmp32 := lang.Apply(tmp19, []any{tmp31})
						tmp33 := lang.Apply(tmp18, []any{tmp32})
						tmp34 := lang.Apply(tmp17, []any{tmp33})
						tmp35 := lang.NewVector(tmp16, tmp34)
						tmp36 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5121), kw_column, int(23), kw_end_DASH_line, int(5122), kw_end_DASH_column, int(69))
						tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp37
					} else {
						tmp38 := lang.NewVector(v6, nil)
						tmp39 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(5123), kw_column, int(23), kw_end_DASH_line, int(5123), kw_end_DASH_column, int(33))
						tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp40
					}
					var v41 any = tmp8
					_ = v41
					// let binding "body"
					tmp42 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp43 := lang.Apply(tmp42, []any{v41, int64(0), nil})
					var v44 any = tmp43
					_ = v44
					// let binding "rm"
					tmp45 := checkDerefVar(var_glojure_DOT_core_nth)
					tmp46 := lang.Apply(tmp45, []any{v41, int64(1), nil})
					var v47 any = tmp46
					_ = v47
					tmp48 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp49 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp50 := checkDerefVar(var_glojure_DOT_core_list)
					tmp51 := lang.Apply(tmp50, []any{sym_glojure_DOT_core_SLASH_binding})
					tmp52 := checkDerefVar(var_glojure_DOT_core_list)
					tmp53 := checkDerefVar(var_glojure_DOT_core_apply)
					tmp54 := checkDerefVar(var_glojure_DOT_core_vector)
					tmp55 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp56 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp57 := checkDerefVar(var_glojure_DOT_core_list)
					tmp58 := lang.Apply(tmp57, []any{sym_glojure_DOT_core_SLASH__STAR_math_DASH_context_STAR_})
					tmp59 := checkDerefVar(var_glojure_DOT_core_list)
					tmp60 := checkDerefVar(var_glojure_DOT_core_seq)
					tmp61 := checkDerefVar(var_glojure_DOT_core_concat)
					tmp62 := checkDerefVar(var_glojure_DOT_core_list)
					tmp63 := lang.Apply(tmp62, []any{sym_java_DOT_math_DOT_MathContext_DOT_})
					tmp64 := checkDerefVar(var_glojure_DOT_core_list)
					tmp65 := lang.Apply(tmp64, []any{v5})
					tmp66 := lang.Apply(tmp61, []any{tmp63, tmp65, v47})
					tmp67 := lang.Apply(tmp60, []any{tmp66})
					tmp68 := lang.Apply(tmp59, []any{tmp67})
					tmp69 := lang.Apply(tmp56, []any{tmp58, tmp68})
					tmp70 := lang.Apply(tmp55, []any{tmp69})
					tmp71 := lang.Apply(tmp53, []any{tmp54, tmp70})
					tmp72 := lang.Apply(tmp52, []any{tmp71})
					tmp73 := lang.Apply(tmp49, []any{tmp51, tmp72, v44})
					tmp74 := lang.Apply(tmp48, []any{tmp73})
					tmp7 = tmp74
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-redefs
	{
		tmp0 := sym_with_DASH_redefs.WithMeta(lang.NewMap(kw_macro, true, kw_arglists, lang.NewList(lang.NewVector(sym_bindings, sym__AMP_, sym_body)), kw_doc, "binding => var-symbol temp-value-expr\n\n  Temporarily redefines Vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var.  After the body is\n  executed, the root values of all the Vars will be set back to their\n  old values.  These temporary changes will be visible in all threads.\n  Useful for mocking out functions during testing.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(21), kw_column, int(11), kw_line, int(7544), kw_end_DASH_line, int(7544))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				checkArity(args, 3)
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp8 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp9 := checkDerefVar(var_glojure_DOT_core_list)
				tmp10 := lang.Apply(tmp9, []any{sym_glojure_DOT_core_SLASH_with_DASH_redefs_DASH_fn})
				tmp11 := checkDerefVar(var_glojure_DOT_core_list)
				tmp12 := checkDerefVar(var_glojure_DOT_core_zipmap)
				tmp13 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp14 lang.FnFunc
				tmp14 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v15 := args[0]
					_ = v15
					tmp16 := checkDerefVar(var_glojure_DOT_core_list)
					tmp17 := lang.Apply(tmp16, []any{sym_var, v15})
					return tmp17
				})
				tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7555), kw_column, int(34), kw_end_DASH_line, int(7555), kw_end_DASH_column, int(47))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp17 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
				tmp18 := lang.Apply(tmp17, []any{int64(2), v5})
				tmp19 := lang.Apply(tmp13, []any{tmp16, tmp18})
				tmp20 := checkDerefVar(var_glojure_DOT_core_take_DASH_nth)
				tmp21 := checkDerefVar(var_glojure_DOT_core_next)
				tmp22 := lang.Apply(tmp21, []any{v5})
				tmp23 := lang.Apply(tmp20, []any{int64(2), tmp22})
				tmp24 := lang.Apply(tmp12, []any{tmp19, tmp23})
				tmp25 := lang.Apply(tmp11, []any{tmp24})
				tmp26 := checkDerefVar(var_glojure_DOT_core_list)
				tmp27 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp28 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp29 := checkDerefVar(var_glojure_DOT_core_list)
				tmp30 := lang.Apply(tmp29, []any{sym_glojure_DOT_core_SLASH_fn})
				tmp31 := checkDerefVar(var_glojure_DOT_core_list)
				tmp32 := checkDerefVar(var_glojure_DOT_core_apply)
				tmp33 := checkDerefVar(var_glojure_DOT_core_vector)
				tmp34 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp35 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp36 := lang.Apply(tmp35, nil)
				tmp37 := lang.Apply(tmp34, []any{tmp36})
				tmp38 := lang.Apply(tmp32, []any{tmp33, tmp37})
				tmp39 := lang.Apply(tmp31, []any{tmp38})
				tmp40 := lang.Apply(tmp28, []any{tmp30, tmp39, v6})
				tmp41 := lang.Apply(tmp27, []any{tmp40})
				tmp42 := lang.Apply(tmp26, []any{tmp41})
				tmp43 := lang.Apply(tmp8, []any{tmp10, tmp25, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-redefs-fn
	{
		tmp0 := sym_with_DASH_redefs_DASH_fn.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_binding_DASH_map, sym_func)), kw_doc, "Temporarily redefines Vars during a call to func.  Each val of\n  binding-map will replace the root value of its key which must be\n  a Var.  After func is called with no args, the root values of all\n  the Vars will be set back to their old values.  These temporary\n  changes will be visible in all threads.  Useful for mocking out\n  functions during testing.", kw_file, "glojure/core.glj", kw_added, "1.3", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(20), kw_column, int(7), kw_line, int(7524), kw_end_DASH_line, int(7524))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "root-bind"
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v7 := args[0]
					_ = v7
					var tmp8 any
					{ // let
						// let binding "seq_338"
						tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
						tmp10 := lang.Apply(tmp9, []any{v7})
						var v11 any = tmp10
						_ = v11
						// let binding "chunk_339"
						var v12 any = nil
						_ = v12
						// let binding "count_340"
						var v13 any = int64(0)
						_ = v13
						// let binding "i_341"
						var v14 any = int64(0)
						_ = v14
						for {
							var tmp15 any
							tmp16 := checkDerefVar(var_glojure_DOT_core__LT_)
							tmp17 := lang.Apply(tmp16, []any{v14, v13})
							if lang.IsTruthy(tmp17) {
								var tmp18 any
								{ // let
									// let binding "vec__342"
									tmp19, _ := lang.FieldOrMethod(v12, "nth")
									if reflect.TypeOf(tmp19).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp20 := lang.Apply(tmp19, []any{v14})
									var v21 any = tmp20
									_ = v21
									// let binding "a-var"
									tmp22 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp23 := lang.Apply(tmp22, []any{v21, int64(0), nil})
									var v24 any = tmp23
									_ = v24
									// let binding "a-val"
									tmp25 := checkDerefVar(var_glojure_DOT_core_nth)
									tmp26 := lang.Apply(tmp25, []any{v21, int64(1), nil})
									var v27 any = tmp26
									_ = v27
									tmp28, _ := lang.FieldOrMethod(v24, "bindRoot")
									if reflect.TypeOf(tmp28).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("bindRoot is not a function")))
									}
									tmp29 := lang.Apply(tmp28, []any{v27})
									_ = tmp29
									var tmp30 any = v11
									var tmp31 any = v12
									var tmp32 any = v13
									tmp34 := checkDerefVar(var_glojure_DOT_core_unchecked_DASH_inc)
									tmp35 := lang.Apply(tmp34, []any{v14})
									var tmp33 any = tmp35
									v11 = tmp30
									v12 = tmp31
									v13 = tmp32
									v14 = tmp33
									continue
								} // end let
								tmp15 = tmp18
							} else {
								var tmp19 any
								{ // let
									// let binding "temp__0__auto__"
									tmp20 := checkDerefVar(var_glojure_DOT_core_seq)
									tmp21 := lang.Apply(tmp20, []any{v11})
									var v22 any = tmp21
									_ = v22
									var tmp23 any
									if lang.IsTruthy(v22) {
										var tmp24 any
										{ // let
											// let binding "seq_338"
											var v25 any = v22
											_ = v25
											var tmp26 any
											tmp27 := checkDerefVar(var_glojure_DOT_core_chunked_DASH_seq_QMARK_)
											tmp28 := lang.Apply(tmp27, []any{v25})
											if lang.IsTruthy(tmp28) {
												var tmp29 any
												{ // let
													// let binding "c__0__auto__"
													tmp30 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_first)
													tmp31 := lang.Apply(tmp30, []any{v25})
													var v32 any = tmp31
													_ = v32
													tmp34 := checkDerefVar(var_glojure_DOT_core_chunk_DASH_rest)
													tmp35 := lang.Apply(tmp34, []any{v25})
													var tmp33 any = tmp35
													var tmp36 any = v32
													tmp38 := checkDerefVar(var_glojure_DOT_core_int)
													tmp39 := checkDerefVar(var_glojure_DOT_core_count)
													tmp40 := lang.Apply(tmp39, []any{v32})
													tmp41 := lang.Apply(tmp38, []any{tmp40})
													var tmp37 any = tmp41
													tmp43 := checkDerefVar(var_glojure_DOT_core_int)
													tmp44 := lang.Apply(tmp43, []any{int64(0)})
													var tmp42 any = tmp44
													v11 = tmp33
													v12 = tmp36
													v13 = tmp37
													v14 = tmp42
													continue
												} // end let
												tmp26 = tmp29
											} else {
												var tmp30 any
												{ // let
													// let binding "vec__345"
													tmp31 := checkDerefVar(var_glojure_DOT_core_first)
													tmp32 := lang.Apply(tmp31, []any{v25})
													var v33 any = tmp32
													_ = v33
													// let binding "a-var"
													tmp34 := checkDerefVar(var_glojure_DOT_core_nth)
													tmp35 := lang.Apply(tmp34, []any{v33, int64(0), nil})
													var v36 any = tmp35
													_ = v36
													// let binding "a-val"
													tmp37 := checkDerefVar(var_glojure_DOT_core_nth)
													tmp38 := lang.Apply(tmp37, []any{v33, int64(1), nil})
													var v39 any = tmp38
													_ = v39
													tmp40, _ := lang.FieldOrMethod(v36, "bindRoot")
													if reflect.TypeOf(tmp40).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("bindRoot is not a function")))
													}
													tmp41 := lang.Apply(tmp40, []any{v39})
													_ = tmp41
													tmp43 := checkDerefVar(var_glojure_DOT_core_next)
													tmp44 := lang.Apply(tmp43, []any{v25})
													var tmp42 any = tmp44
													var tmp45 any = nil
													var tmp46 any = int64(0)
													var tmp47 any = int64(0)
													v11 = tmp42
													v12 = tmp45
													v13 = tmp46
													v14 = tmp47
													continue
												} // end let
												tmp26 = tmp30
											}
											tmp24 = tmp26
										} // end let
										tmp23 = tmp24
									} else {
									}
									tmp19 = tmp23
								} // end let
								tmp15 = tmp19
							}
							tmp8 = tmp15
							break
						}
					} // end let
					return tmp8
				})
				tmp7 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7533), kw_column, int(19), kw_end_DASH_line, int(7535), kw_end_DASH_column, int(93))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v9 any = tmp8
				_ = v9
				// let binding "old-vals"
				tmp10 := checkDerefVar(var_glojure_DOT_core_zipmap)
				tmp11 := checkDerefVar(var_glojure_DOT_core_keys)
				tmp12 := lang.Apply(tmp11, []any{v3})
				tmp13 := checkDerefVar(var_glojure_DOT_core_map)
				var tmp14 lang.FnFunc
				tmp14 = lang.NewFnFunc(func(args ...any) any {
					checkArity(args, 1)
					v15 := args[0]
					_ = v15
					tmp16, ok := lang.FieldOrMethod(v15, "getRawRoot")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v15, "getRawRoot")))
					}
					var tmp17 any
					switch reflect.TypeOf(tmp16).Kind() {
					case reflect.Func:
						tmp17 = lang.Apply(tmp16, nil)
					default:
						tmp17 = tmp16
					}
					return tmp17
				})
				tmp15 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(7537), kw_column, int(31), kw_end_DASH_line, int(7537), kw_end_DASH_column, int(92))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp17 := checkDerefVar(var_glojure_DOT_core_keys)
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.Apply(tmp13, []any{tmp16, tmp18})
				tmp20 := lang.Apply(tmp10, []any{tmp12, tmp19})
				var v21 any = tmp20
				_ = v21
				var tmp22 any
				func() {
					defer func() {
						tmp23 := lang.Apply(v9, []any{v21})
						_ = tmp23
					}()
					tmp24 := lang.Apply(v9, []any{v3})
					_ = tmp24
					tmp25 := lang.Apply(v4, nil)
					tmp22 = tmp25
				}()
				tmp5 = tmp22
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// xml-seq
	{
		tmp0 := sym_xml_DASH_seq.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_root)), kw_doc, "A tree seq on the xml elements as per xml/parse", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(13), kw_column, int(7), kw_line, int(4982), kw_end_DASH_line, int(4982))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			tmp4 := checkDerefVar(var_glojure_DOT_core_tree_DASH_seq)
			tmp5 := checkDerefVar(var_glojure_DOT_core_complement)
			tmp6 := checkDerefVar(var_glojure_DOT_core_string_QMARK_)
			tmp7 := lang.Apply(tmp5, []any{tmp6})
			tmp8 := checkDerefVar(var_glojure_DOT_core_comp)
			tmp9 := checkDerefVar(var_glojure_DOT_core_seq)
			tmp10 := lang.Apply(tmp8, []any{tmp9, kw_content})
			tmp11 := lang.Apply(tmp4, []any{tmp7, tmp10, v3})
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// zero?
	{
		var tmp1 lang.FnFunc
		{ // function zero?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				checkArity(args, 1)
				v3 := args[0]
				_ = v3
				tmp4 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp5 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp6 := checkDerefVar(var_glojure_DOT_core_list)
				tmp7 := lang.Apply(tmp6, []any{sym__DOT_})
				tmp8 := checkDerefVar(var_glojure_DOT_core_list)
				tmp9 := lang.Apply(tmp8, []any{sym_github_DOT_com_DOLLAR_glojurelang_DOLLAR_glojure_DOLLAR_pkg_DOLLAR_lang_DOT_Numbers})
				tmp10 := checkDerefVar(var_glojure_DOT_core_list)
				tmp11 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp12 := checkDerefVar(var_glojure_DOT_core_concat)
				tmp13 := checkDerefVar(var_glojure_DOT_core_list)
				tmp14 := lang.Apply(tmp13, []any{sym_glojure_DOT_core_SLASH_IsZero})
				tmp15 := checkDerefVar(var_glojure_DOT_core_list)
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp14, tmp16})
				tmp18 := lang.Apply(tmp11, []any{tmp17})
				tmp19 := lang.Apply(tmp10, []any{tmp18})
				tmp20 := lang.Apply(tmp5, []any{tmp7, tmp9, tmp19})
				tmp21 := lang.Apply(tmp4, []any{tmp20})
				return tmp21
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := sym_zero_QMARK_.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_num)), kw_inline, tmp1, kw_doc, "Returns true if num is zero, else false", kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(11), kw_column, int(7), kw_line, int(860), kw_end_DASH_line, int(860))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IsZero")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IsZero is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// zipmap
	{
		tmp0 := sym_zipmap.WithMeta(lang.NewMap(kw_arglists, lang.NewList(lang.NewVector(sym_keys, sym_vals)), kw_doc, "Returns a map with the keys mapped to the corresponding vals.", kw_static, true, kw_file, "glojure/core.glj", kw_added, "1.0", kw_ns, lang.FindOrCreateNamespace(sym_glojure_DOT_core), kw_end_DASH_column, int(12), kw_column, int(7), kw_line, int(6583), kw_end_DASH_line, int(6583))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 2)
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "map"
				tmp6 := checkDerefVar(var_glojure_DOT_core_transient)
				tmp7 := lang.NewMap()
				tmp8 := lang.NewMap(kw_file, "glojure/core.glj", kw_line, int(6588), kw_column, int(27), kw_end_DASH_line, int(6588), kw_end_DASH_column, int(28))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := lang.Apply(tmp6, []any{tmp9})
				var v11 any = tmp10
				_ = v11
				// let binding "ks"
				tmp12 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp13 := lang.Apply(tmp12, []any{v3})
				var v14 any = tmp13
				_ = v14
				// let binding "vs"
				tmp15 := checkDerefVar(var_glojure_DOT_core_seq)
				tmp16 := lang.Apply(tmp15, []any{v4})
				var v17 any = tmp16
				_ = v17
				for {
					var tmp18 any
					var tmp19 any
					{ // let
						// let binding "and__0__auto__"
						var v20 any = v14
						_ = v20
						var tmp21 any
						if lang.IsTruthy(v20) {
							tmp21 = v17
						} else {
							tmp21 = v20
						}
						tmp19 = tmp21
					} // end let
					if lang.IsTruthy(tmp19) {
						tmp21 := checkDerefVar(var_glojure_DOT_core_assoc_BANG_)
						tmp22 := checkDerefVar(var_glojure_DOT_core_first)
						tmp23 := lang.Apply(tmp22, []any{v14})
						tmp24 := checkDerefVar(var_glojure_DOT_core_first)
						tmp25 := lang.Apply(tmp24, []any{v17})
						tmp26 := lang.Apply(tmp21, []any{v11, tmp23, tmp25})
						var tmp20 any = tmp26
						tmp28 := checkDerefVar(var_glojure_DOT_core_next)
						tmp29 := lang.Apply(tmp28, []any{v14})
						var tmp27 any = tmp29
						tmp31 := checkDerefVar(var_glojure_DOT_core_next)
						tmp32 := lang.Apply(tmp31, []any{v17})
						var tmp30 any = tmp32
						v11 = tmp20
						v14 = tmp27
						v17 = tmp30
						continue
					} else {
						tmp33 := checkDerefVar(var_glojure_DOT_core_persistent_BANG_)
						tmp34 := lang.Apply(tmp33, []any{v11})
						tmp18 = tmp34
					}
					tmp5 = tmp18
					break
				}
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}

// Code generated by glojure codegen. DO NOT EDIT.

package fn_DASH_recur

import (
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime "github.com/glojurelang/glojure/pkg/runtime"
)

func init() {
	runtime.RegisterNSLoader("codegen.test.fn-recur", LoadNS)
}

func checkDerefVar(v *lang.Var) any {
	if v.IsMacro() {
		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", v)))
	}
	return v.Get()
}

func checkArity(args []any, expected int) {
	if len(args) != expected {
		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
	}
}

// LoadNS initializes the namespace "codegen.test.fn-recur"
func LoadNS() {
	sym__PLUS_ := lang.NewSymbol("+")
	sym__DASH_main := lang.NewSymbol("-main")
	sym__EQ_ := lang.NewSymbol("=")
	sym_codegen_DOT_test_DOT_fn_DASH_recur := lang.NewSymbol("codegen.test.fn-recur")
	sym_fib := lang.NewSymbol("fib")
	sym_glojure_DOT_core := lang.NewSymbol("glojure.core")
	sym_inc := lang.NewSymbol("inc")
	sym_n := lang.NewSymbol("n")
	kw_arglists := lang.NewKeyword("arglists")
	kw_column := lang.NewKeyword("column")
	kw_doc := lang.NewKeyword("doc")
	kw_end_DASH_column := lang.NewKeyword("end-column")
	kw_end_DASH_line := lang.NewKeyword("end-line")
	kw_expected_DASH_output := lang.NewKeyword("expected-output")
	kw_file := lang.NewKeyword("file")
	kw_line := lang.NewKeyword("line")
	kw_ns := lang.NewKeyword("ns")
	kw_rettag := lang.NewKeyword("rettag")
	// var codegen.test.fn-recur/fib
	var_codegen_DOT_test_DOT_fn_DASH_recur_fib := lang.InternVarName(sym_codegen_DOT_test_DOT_fn_DASH_recur, sym_fib)
	// var glojure.core/=
	var_glojure_DOT_core__EQ_ := lang.InternVarName(sym_glojure_DOT_core, sym__EQ_)
	// var glojure.core/+
	var_glojure_DOT_core__PLUS_ := lang.InternVarName(sym_glojure_DOT_core, sym__PLUS_)
	// var glojure.core/inc
	var_glojure_DOT_core_inc := lang.InternVarName(sym_glojure_DOT_core, sym_inc)
	// reference fmt to avoid unused import error
	_ = fmt.Printf
	ns := lang.FindOrCreateNamespace(sym_codegen_DOT_test_DOT_fn_DASH_recur)
	_ = ns
	// -main
	{
		tmp0 := sym__DASH_main.WithMeta(lang.NewMap(kw_expected_DASH_output, int64(55), kw_file, "codegen/test/fn_recur.glj", kw_line, int(12), kw_column, int(7), kw_end_DASH_line, int(12), kw_end_DASH_column, int(34), kw_arglists, lang.NewList(lang.NewVector()), kw_ns, lang.FindOrCreateNamespace(sym_codegen_DOT_test_DOT_fn_DASH_recur))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 0)
			tmp3 := checkDerefVar(var_codegen_DOT_test_DOT_fn_DASH_recur_fib)
			tmp4 := lang.Apply(tmp3, []any{int64(10)})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fib
	{
		tmp0 := sym_fib.WithMeta(lang.NewMap(kw_file, "codegen/test/fn_recur.glj", kw_line, int(3), kw_column, int(7), kw_end_DASH_line, int(3), kw_end_DASH_column, int(9), kw_arglists, lang.NewList(lang.NewVector(sym_n)), kw_doc, "Calculates the nth Fibonacci number using iteration with recur.", kw_ns, lang.FindOrCreateNamespace(sym_codegen_DOT_test_DOT_fn_DASH_recur))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			checkArity(args, 1)
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "fib-helper"
				var tmp5 lang.FnFunc
				{ // function fib-helper
					var v6 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						checkArity(args, 3)
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
					recur_loop_1612:
						var tmp10 any
						tmp11 := checkDerefVar(var_glojure_DOT_core__EQ_)
						tmp12 := lang.Apply(tmp11, []any{v9, v3})
						if lang.IsTruthy(tmp12) {
							tmp10 = v7
						} else {
							var tmp13 any = v8
							tmp15 := checkDerefVar(var_glojure_DOT_core__PLUS_)
							tmp16 := lang.Apply(tmp15, []any{v7, v8})
							var tmp14 any = tmp16
							tmp18 := checkDerefVar(var_glojure_DOT_core_inc)
							tmp19 := lang.Apply(tmp18, []any{v9})
							var tmp17 any = tmp19
							v7 = tmp13
							v8 = tmp14
							v9 = tmp17
							goto recur_loop_1612
						}
						return tmp10
					})
					v6 = tmp5
					_ = v6
				}
				tmp6 := lang.NewMap(kw_file, "codegen/test/fn_recur.glj", kw_line, int(6), kw_column, int(20), kw_end_DASH_line, int(9), kw_end_DASH_column, int(50))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v8 any = tmp7
				_ = v8
				tmp9 := lang.Apply(v8, []any{int64(0), int64(1), int64(0)})
				tmp4 = tmp9
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(kw_rettag, nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}
